# Copyright (c) 2016-2017 Cirrus Logic, Inc and
# Cirrus Logic International Semiconductor Ltd.  All rights reserved.
#
# This software as well as any related documentation is furnished under
# license and may only be used or copied in accordance with the terms of the
# license.  The information in this file is furnished for informational use
# only, is subject to change without notice, and should not be construed as
# a commitment by Cirrus Logic.  Cirrus Logic assumes no responsibility or
# liability for any errors or inaccuracies that may appear in this document
# or any software that may be provided in association with this document.
# Except as permitted by such license, no part of this document may be
# reproduced, stored in a retrieval system, or transmitted in any form or by
# any means without the express written consent of Cirrus Logic.
#
# Warning
# This software is specifically written for Cirrus Logic devices.
# It may not be used with other devices.
#
# @file     CS44L2x.py
# @brief    CS44L2x.py is the device helper class for both the CS44L20 and CS44L21
#
class CS44L2x(object):
    """ Device class for Taylor.

    """
    
    def __init__(self, device):
        """Instantiate a Taylor object.
        
        Args:
            device (obj): object containing functions for writeField, readField, writeRegister and readRegister

        """
        self.writeField = device.writeField
        self.readField = device.readField
        try:
            self.writeRegister = device.writeRegister
            self.readRegister = device.readRegister
        except AttributeError:
            self.writeRegister = device.writeRegisterByAddress
            self.readRegister = device.writeRegisterByAddress
        
        
    def initialize(self, out_mode, vdd_io=None, load_low_r=False, load_low_l=True, errata=None):
        """Perform initial device configuration
        
        Args:
            out_mode (int): selects output mode, 0, 1 or 2
            vdd_io (float): manually sets VDD_IO level, can be 1.8 or 1.2
            load_low_r (bool): set True for loads < 12 ohms
            load_low_l (bool): set True for loads < 0.5 uH (i.e. lab testing)
            errata (string): applies errata writes for a specific silicon version (i.e. "A0")
            
        """
        if errata == 'A0':
            # unlock password
            self.writeRegister(0x00000020, 0x00000055)
            self.writeRegister(0x00000020, 0x000000AA)
            
            # tst_classd_glitch_prevent_en=0
            self.writeRegister(0x00004210, 0x0000E200)
            
            # tst_classd_glitch_prevent_en=0
            self.writeRegister(0x00003850, 0x00001004)
            
            # tst_classd_quan_delay_res=7
            self.writeRegister(0x0000425c, 0x00590807)
            
            # pdm_mod_idx=1
            self.writeRegister(0x00002C00, 0x00011000)
            
            # tst_classd_int1_cmctrl_input_bias_trim=2
            # tst_classd_int1_cmctrl_ab_bias_trim=2 
            # tst_classd_int1_comp_trim=1
            # tst_classd_int1_comp_trim_force_en=1
            self.writeRegister(0x00004208, 0x07003512)
            
            # CP_SDM_FIR_3M=0xe
            self.writeRegister(0x0000400C, 0x0000051E)
            
            # classd_int1_cmfb_bias_trim=3
            self.writeRegister(0x0000391C, 0x00300027)
            
            # classd_drv_dio_ctrl_fb_ena_large_val=3; classd_drv_dio_ctrl_fb_prebias_large_val=3
            self.writeRegister(0x00003918, 0x043C60E8)
            
            # lock password
            self.writeRegister(0x00000020, 0x000000CC)
            self.writeRegister(0x00000020, 0x00000033)
        
        if vdd_io is not None:
            lookup = {1.8: 1, 1.2: 0}
            self.writeField('VDDIO_CONFIG', lookup[vdd_io])
            self.writeField('VDDIO_OVERRIDE_EN', 1)
        else:  # auto detect
            self.writeField('VDDIO_OVERRIDE_EN', 0)
        
        self.writeField('HP_LOAD', load_low_r)
        self.writeField('LOW_L_MODE', load_low_l)
            
        lookup = {0: 0, 1: 2, 2: 4}
        self.writeField('MODE', lookup[out_mode])
        
        
    def configure_serial_port(self, format, sample_rate, ch_sel=1, ch_size=32, num_ch=2):
        """Configure the Audio Serial Port. All channels are assumed to be the same size.
        In TDM mode, all channels are expected to be adjacent.
        
        Args:
            format (str): selects audio format, can be "I2S" or "TDM"
            sample_rate (int): sample rate in kHz
            ch_sel (int): selects which channel to grab data, 1=Left and 2=Right in I2S mode
            ch_size (int): number of bits per channel (data bits + padded bits)
            num_ch (int): number of active channels
            duty (str): frame clock duty cycle, can be "One Bit", "One Channel" or "50%"
            
        """
        # sample rate
        lookup = {24: 0b00010, 48: 0b00011, 96: 0b00100, 192: 0b00101, 44.1: 0b01011, 
            88.2: 0b01100, 176.4: 0b01101, 16: 0b10010, 32: 0b10011}
        self.writeField('PCM_FS_RATE', lookup[sample_rate])
        
        # BCLK frequency
        clk_rate = sample_rate*ch_size*num_ch/1000.0

        if clk_rate > 6.144:
            self.writeField('CLK_FREQ_GROUP', 3)
            self.writeField('CLK_INPUT_DIV', 1)
        elif clk_rate >= 5.6448:
            self.writeField('CLK_FREQ_GROUP', 2)
            self.writeField('CLK_INPUT_DIV', 0)
        elif clk_rate >= 2.048:
            self.writeField('CLK_FREQ_GROUP', 1)
            self.writeField('CLK_INPUT_DIV', 0)
        else:
            self.writeField('CLK_FREQ_GROUP', 0)
            self.writeField('CLK_INPUT_DIV', 0)
        
        # channel resolution
        if ch_size < 24:
            bit_width = 1  # 16 bits
        elif ch_size < 32:
            bit_width = 2  # 24 bits
        else:
            bit_width = 3  # 32 bits
        self.writeField('ASP_RES', bit_width)
            
        # LRCK period
        self.writeField('FSYNC_PERIOD',  num_ch*ch_size - 1)
        
        if format.upper() == 'I2S':  # I2S Configuration (2 FSYNC phases)
            self.writeField('ASP_5050', 1)
            self.writeField('ASP_STP', 0)
            self.writeField('ASP_FSD', 2)
            self.writeField('ASP_SCPOL_IN', 1)
            lookup = {1: 0, 2: 1}
            self.writeField('ASP_AP', lookup[ch_sel])  # Ch1 = low phase, Ch2 = high phase
            self.writeField('ASP_MSB_LOC', 0)
        else:  # TDM Configuration (1 FSYNC phase, data channels are adjacent)
            self.writeField('ASP_5050', 0)
            self.writeField('ASP_STP', 1)
            self.writeField('ASP_MSB_LOC', ch_size*(ch_sel-1))
            
        self.writeField('ASP_EN', 1)
        
        
    def configure_pdm_port(self, clk_rate, ch_sel, pin_ctrl=False, data_det=None):
        """Perform initial device configuration
        
        Args:
            clk_rate (int): clock rate in MHz
            ch_sel (int): set to 1 for ChA (rising edge) or 2 for ChB (falling edge)
            pin_ctrl (bool): selects whether the output is controlled by the pin or register
            data_det (int): after this many consecutive 1's or 0's, soft mute is applied
            
        """
        # stuck data detect
        if data_det is None:
            self.writeField('PDM_DATA_STUCK_DET_EN', 0)
        else:
            self.writeField('PDM_DATA_STUCK_DET_THRESH_0', data_det)
            self.writeField('PDM_DATA_STUCK_DET_THRESH_1', data_det)
            self.writeField('PDM_DATA_STUCK_DET_EN', 1)
        
        # clock rate
        if clk_rate > 6.144:
            raise ValueError
        elif clk_rate >= 5.6448:
            self.writeField('CLK_FREQ_GROUP', 2)
            self.writeField('PDM_RATE', 2)
        elif clk_rate >= 2.8224:
            self.writeField('CLK_FREQ_GROUP', 1)
            self.writeField('PDM_RATE', 1)
        else:
            self.writeField('CLK_FREQ_GROUP', 0)
            self.writeField('PDM_RATE', 0)
        self.writeField('CLK_INPUT_DIV', 0)
        self.writeField('CLK_EN', 1)
        
        # L/R channel select
        lookup = {1: 0, 'a': 0, 'A': 0, 2: 1, 'b': 1, 'B': 2}
        self.writeField('PDM_CH_SEL', lookup[ch_sel])
        
        # reg / pin enable select
        self.writeField('PDM_EN_CTRL', pin_ctrl)
        
        
    def configure_pll(self, clk_in, clk_out):
        """Configure and enable the PLL. Fractional mode currently not supported
        
        Args:
            clk_in (int, float): PLL reference clock in MHz
            clk_out (int, float): PLL generated clock in MHz
            
        """
        self.writeField('PLL_EN', 0)
        
        clk_in = float(clk_in)
        clk_out = float(clk_out)
        
        # lookup DIVOUT value
        r = clk_out%clk_in
        if r:
            lookup = {5.6448: 36, 6.144: 30}
            divout = lookup[clk_out]
        else:  # evenly divisible
            divout = 32
        
        # divide input clock
        if clk_in > 6.144:
            pre_div = 2
            clk_in = clk_in / 4.0
        elif clk_in > 3.072:
            pre_div = 1
            clk_in = clk_in / 2.0
        else:
            pre_div = 0
        
        # calculate integer value
        integer = round(divout*(clk_out/clk_in), 13)
        if integer%1:
            raise ValueError("PLL does not currently support input clock = {}MHz, and output clock = {}MHz".format(clk_in, clk_out))
        
        # calculate cal ratio
        cal_ratio = (clk_out*32)/clk_in
        
        self.writeField('PLL_REFCLK_PREDIVIDE', pre_div)
        self.writeField('DIVOUT', divout)
        self.writeField('CAL_RATIO', int(round(cal_ratio)))
        self.writeField('INT', int(integer))
        
        self.writeField('PLL_EN', 1)
        