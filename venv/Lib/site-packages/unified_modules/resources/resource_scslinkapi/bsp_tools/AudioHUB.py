# Copyright (c) 2016 Cirrus Logic, Inc and
# Cirrus Logic International Semiconductor Ltd.  All rights reserved.
#
# This software as well as any related documentation is furnished under
# license and may only be used or copied in accordance with the terms of the
# license.  The information in this file is furnished for informational use
# only, is subject to change without notice, and should not be construed as
# a commitment by Cirrus Logic.  Cirrus Logic assumes no responsibility or
# liability for any errors or inaccuracies that may appear in this document
# or any software that may be provided in association with this document.
# Except as permitted by such license, no part of this document may be
# reproduced, stored in a retrieval system, or transmitted in any form or by
# any means without the express written consent of Cirrus Logic.
#
# Warning
# This software is specifically written for Cirrus Logic devices.
# It may not be used with other devices.
#
# @file     AudioHub.py
# @brief    AudioHub.py is the helper class for the AudioHub
#
from time import sleep

import platform
if platform.system() == 'Java':
    from com.cirrus.scs.studiolink.api.device_comm import GpioGetTransaction
    from com.cirrus.scs.studiolink.api.device_comm import GpioSetTransaction
    from com.cirrus.scs.studiolink.api.enums       import GpioPinDirection
    from com.cirrus.scs.studiolink.api.enums       import GpioPinState
elif platform.system() == 'Linux':
    pass
else:
    # GPIO classes from API
    from studiolink.device_comm.GpioGetTransaction import GpioGetTransaction
    from studiolink.device_comm.GpioSetTransaction import GpioSetTransaction
    from studiolink.enums.GpioPinDirection         import GpioPinDirection
    from studiolink.enums.GpioPinState             import GpioPinState
    import paramiko # for SSH communcation with Linux OS

class AudioHub(object):
    """ Contains device classes for AudioHub.

    """
    GPIO0 = 1
    GPIO1 = 2
    GPIO2 = 3
    GPIO3 = 4

    INT_0 = 1
    INT_1 = 2
    INT_2 = 3

    lookup_mux = {}
    mclk = 'MCLK'
    sclk = 'SCLK'
    lrck = 'LRCK'
    sdata = 'SDATA'
    pdm_clk = 'PDM_CLK'
    pdm_data = 'PDM_DATA'

    # MCLK mux options
    lookup_mux[mclk] = {
    '12MHz': 0x02,
    '12 MHz clock': 0x02,
    '12.288MHz': 0x03,
    '12.288 MHz clock': 0x03,
    '11.2896MHz': 0x04,
    '11.2896 MHz clock': 0x04,
    'SAIO_MCLK1': 0x05,
    'SAIO_MCLK2': 0x06,
    'PDMIO_CLK1': 0x07,
    'PDMIO_CLK2': 0x08,
    'DEV_MCLK2': 0x09,
    'PLL1': 0x0A,
    'PLL1 CLK_OUT': 0x0A,
    'PLL2': 0x0B,
    'PLL2 CLK_OUT': 0x0B,
    'SPDIF_RX_RMCK': 0x0C,
    'S/PDIF Rx RMCK': 0x0C,
    'AC0': 0x0D,
    'AC0 MCLK': 0x0D,
    '24MHz': 0x0E,
    '24 MHz clock': 0x0E,
    '24.576MHz': 0x0F,
    '24.576 MHz clock': 0x0F,
    '22.5792MHz': 0x10,
    '22.5792 MHz clock': 0x10
    }

    # SCLK mux options
    lookup_mux[sclk] = {
    '2.4MHz': 0x02,
    '2.4 MHz clock': 0x02,
    'SAI': 0x03,
    'SAI SCLK': 0x03,
    'SAO': 0x04,
    'SAO SCLK': 0x04,
    'DEV_AIF1': 0x05,
    'DEV_AIF1 SCLK': 0x05,
    'DEV_AIF2': 0x06,
    'DEV_AIF2 SCLK': 0x06,
    'DEV_AIF3': 0x07,
    'DEV_AIF3 SCLK': 0x07,
    'PLL1': 0x08,
    'PLL1 CLK_OUT': 0x08,
    'PLL2': 0x09,
    'PLL2 CLK_OUT': 0x09,
    'SPDIF_RX_ISCLK': 0x0A,
    'SPDIF Rx ISCLK': 0x0A,
    'SPDIF_RX': 0x0B,
    'SPDIF Rx OSCLK1': 0x0B,
    'SPDIF_TX': 0x0C,
    'SPDIF Tx ISCLK': 0x0C,
    'XUSB': 0x0D,
    'USB Audio SCLK': 0x0D,
    'AC0': 0x0E,
    'AC0 SCLK': 0x0E
    }

    # LRCK mux options
    lookup_mux[lrck] = {
    '48kHz': 0x02,
    '48 kHz clock': 0x02,
    'SAI': 0x03,
    'SAI LRCK': 0x03,
    'SAO': 0x04,
    'SAO LRCK': 0x04,
    'DEV_AIF1': 0x05,
    'DEV_AIF1 LRCK': 0x05,
    'DEV_AIF2': 0x06,
    'DEV_AIF2 LRCK': 0x06,
    'DEV_AIF3': 0x07,
    'DEV_AIF3 LRCK': 0x07,
    'SPDIF_RX_ILRCK': 0x08,
    'SPDIF Rx ILRCK': 0x08,
    'SPDIF_RX': 0x09,
    'SPDIF Rx OLRCK1': 0x09,
    'SPDIF_TX': 0x0A,
    'SPDIF Tx ILRCK': 0x0A,
    'XUSB': 0x0B,
    'USB Audio LRCK': 0x0B,
    'AC0': 0x0C,
    'AC0 LRCK': 0x0C
    }

    # SDATA mux options
    lookup_mux[sdata] = {
    'SAI_DATA1': 0x02,
    'SAI DATA1': 0x02,
    'SAI_DATA2': 0x03,
    'SAI DATA2': 0x03,
    'SAI_DATA3': 0x04,
    'SAI DATA3': 0x04,
    'SAI_DATA4': 0x05,
    'SAI DATA4': 0x05,
    'DEV_AIF1_SDATA1': 0x06,
    'DEV_AIF1 SDATA1': 0x06,
    'DEV_AIF1_SDATA2': 0x07,
    'DEV_AIF1 SDATA2': 0x07,
    'DEV_AIF2_SDATA1': 0x08,
    'DEV_AIF2 SDATA1': 0x08,
    'DEV_AIF2_SDATA2': 0x09,
    'DEV_AIF2 SDATA2': 0x09,
    'DEV_AIF3_SDATA1': 0x0A,
    'DEV_AIF3 SDATA1': 0x0A,
    'DEV_AIF3_SDATA2': 0x0B,
    'DEV_AIF3 SDATA2': 0x0B,
    'SPDIF_RX_SDOUT1': 0x0C,
    'SPDIF Rx SDOUT1': 0x0C,
    'XUSB_SDOUT1': 0x0D,
    'USB Audio SDOUT1': 0x0D,
    'XUSB_SDOUT2': 0x0E,
    'USB Audio SDOUT2': 0x0E,
    'AC0_SDOUT1': 0x0F,
    'AC0 SDOUT1': 0x0F,
    'AC0_SDOUT2': 0x10,
    'AC0 SDOUT2': 0x10,
    'AC0_SDOUT3': 0x11,
    'AC0 SDOUT3': 0x11,
    'AC0_SDOUT4': 0x12,
    'AC0 SDOUT4': 0x12
    }

    # PDM clock mux options
    lookup_mux[pdm_clk] = {
    'PDMIO1': 0x02,
    'PDMIO CLK1': 0x02,
    'PDMIO2': 0x03,
    'PDMIO CLK2': 0x03,
    'DEV_PDM1': 0x04,
    'DEV_PDM1 CLK': 0x04,
    'DEV_PDM2': 0x05,
    'DEV_PDM2 CLK': 0x05,
    'DEV_PDM3': 0x06,
    'DEV_PDM3 CLK': 0x06,
    'DEV_PDM4': 0x07,
    'DEV_PDM4 CLK': 0x07,
    'DEV_PDM5': 0x08,
    'DEV_PDM5 CLK': 0x08,
    'DEV_PDM6': 0x09,
    'DEV_PDM6 CLK': 0x09,
    'DEV_PDM7': 0x0A,
    'DEV_PDM7 CLK': 0x0A
    }

    # PDM DATA mux options
    lookup_mux[pdm_data] = {
    'PDMIO1': 0x02,
    'PDMIO1 DATA': 0x02,
    'PDMIO2': 0x03,
    'PDMIO2 DATA': 0x03,
    'DEV_PDM1': 0x04,
    'DEV_PDM1 DATA': 0x04,
    'DEV_PDM2': 0x05,
    'DEV_PDM2 DATA': 0x05,
    'DEV_PDM3': 0x06,
    'DEV_PDM3 DATA': 0x06,
    'DEV_PDM4': 0x07,
    'DEV_PDM4 DATA': 0x07,
    'DEV_PDM5': 0x08,
    'DEV_PDM5 DATA': 0x08,
    'DEV_PDM6': 0x09,
    'DEV_PDM6 DATA': 0x09,
    'DEV_PDM7': 0x0A,
    'DEV_PDM7 DATA': 0x0A
    }

    def __init__(self, system, dev_map=None):
        """Instatiate an AudioHub object.

        Args:
            dev_map (dict): contains mapping for device names to hub names (e.g. "ASP1" -> "DEV_AIF1")
            system (obj): context.system object which contains device objects

        """
        self.clsystem = system
        self.fpga = system.getDevice('AudioHUB FPGA')
        self.io = system.getDevice('AudioHUB IO EXPANDER')
        self.spdif_rx = system.getDevice('SPDIF RX ASRC')
        self.spdif_tx = system.getDevice('SPDIF TX')
        self.pll1 = system.getDevice('PLL 1')
        self.pll2 = system.getDevice('PLL 2')
        self.dev_map = dev_map

# ----------------------------------------------------------------------------
# system commands
# ----------------------------------------------------------------------------
    def initialize(self):
        """Perform an initial set of writes.

        """
        self.fpga.writeField('DEV_GLOBAL_HIZ', 0)
        self.io.writeRegisterByAddress(0x06, 0x00)
        self.io.writeRegisterByAddress(0x07, 0x00)


    def reset_dut(self):
        """Toggle the DUT_RESET pin.

        """
        self.fpga.writeField('FORCE_DUT_RESETN', 1)
        sleep(.1)
        self.fpga.writeField('FORCE_DUT_RESETN', 0)
        sleep(.2)  # wait for reset line to deassert


    def reset_sys(self):
        """Toggle the SYS_RESET pin.

        """
        self.fpga.writeField('FORCE_SYS_RESETN', 1)
        sleep(.1)
        self.fpga.writeField('FORCE_SYS_RESETN', 0)
        sleep(.2)  # wait for reset line to deassert
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# configure methods
# ----------------------------------------------------------------------------
    def configureUSB(self, mode, format='I2S'):
        """Configure the USB Audio Module

        Args:
            mode (int): selects sample rate and bits per channel
                - Mode 0: 44.1kHz sample rate, 32 bits per word (MCLK set to 11.2896MHz)
                - Mode 1: 48kHz sample rate, 25 bits per word (MCLK set to 12MHz)
                - Mode 2: 48kHz sample rate, 32 bits per word (MCLK set to 12.288MHz)
            format(str): selects between "I2S" and "TDM" modes of operation

        """
        # configure I2S vs TDM settings
        if format == 'I2S':
            lookup = {0: 4, 1: 2, 2: 3}
            self.fpga.writeField('XUSB_MCLK_SEL', lookup[mode])
            self.fpga.writeField('XUSB_MCLK_RATE', 0x01)   # ~12MHz master clock
            self.fpga.writeField('XUSB_TDM', 0x00)
            self.fpga.writeField('XUSB_CLK_FAM', mode)
            self.fpga.writeField('XUSB_LRCK_RATE', 0x00)  # ~48kHz
            self.fpga.writeField('XUSB_LRCK_MODE', 0x00)
            self.fpga.writeField('XUSB_LRCK_POL', 0x01)
            self.fpga.writeField('XUSB_LRCK_SHIFT', 0x01)
        elif format == 'TDM':
            lookup = {0: 0x10, 1: 0x0e, 2: 0x0f}
            self.fpga.writeField('XUSB_MCLK_SEL', lookup[mode])
            self.fpga.writeField('XUSB_MCLK_RATE', 0x00)   # ~24MHz master clock
            self.fpga.writeField('XUSB_TDM', 0x01)
            self.fpga.writeField('XUSB_CLK_FAM', mode)
            self.fpga.writeField('XUSB_LRCK_RATE', 0x00)  # ~48kHz
            self.fpga.writeField('XUSB_LRCK_MODE', 0x02)
            self.fpga.writeField('XUSB_LRCK_POL', 0x00)
            self.fpga.writeField('XUSB_LRCK_SHIFT', 0x00)
        else:
            raise ValueError(format)


    def configurePLL(self, pll, out_clk):
        """configure a PLL to generate a clock based on the internal 48kHz clock

        Args:
            pll (int, string): select between PLL1 and PLL2
            out_clk (int, float): output clock in MHz

        """
        if pll in [1, '1', 'pll1', 'PLL1']:
            pll = self.pll1
            name = 'PLL1'
        elif pll in [2, '2', 'pll2', 'PLL2']:
            pll = self.pll2
            name = 'PLL2'
        else:
            raise ValueError(pll)

        self.fpga.writeField(name +'_REF_CLK_SEL', 2)  # 48kHz

        coef = int(round(out_clk/.048*(2**20)))
        coefs = [(coef>>(8*i))&0xff for i in list(range(4))]

        pll.writeRegisterByAddress(0x05, 0x09)  # freeze register writes
        pll.writeRegisterByAddress(0x02, 0x00)  # enable AUX, enable CKL_OUT
        pll.writeRegisterByAddress(0x03, 0x07)  # Ratio Mod = 1, enable PLL Lock, enable CP
        pll.writeRegisterByAddress(0x06, coefs[3])  # Byte 3
        pll.writeRegisterByAddress(0x07, coefs[2])  # Byte 2
        pll.writeRegisterByAddress(0x08, coefs[1])  # Byte 1
        pll.writeRegisterByAddress(0x09, coefs[0])  # Byte 0
        pll.writeRegisterByAddress(0x16, 0x10)  # disable clock skipping, AUX_OUT is PUSH-PULL, enable CP
        pll.writeRegisterByAddress(0x17, 0x08)  # clocks low when unlocked, high precision 12.20
        pll.writeRegisterByAddress(0x1e, 0x70)  # min loop bandwidth = 128Hz
        pll.writeRegisterByAddress(0x05, 0x01)  # clear freeze bit, register writes take effect, enable CP ]


    def configureSPDIF(self, master=True, src=False, clk_ratio=256):
        """Configures the S/PDIF RX and TX. An internal PLL generates the TX MCLK = LRCKx256.
        1) Using the SRC means the LRCK is fixed at XTI/clk_ratio and therefore 
        the rate does not match the input stream.
        2) Bypassing the SRC means LRCK and RMCK match the input stream but are asynchronous 
        to the rest of the system unless RMCK is used as the MCLK.

        Args:
            master (bool, int): sets whether the S/PDIF RX masters the serial audio clocks
            src (bool, int): sets whether the ASRC is in the path or bypassed
            clk_ratio (int): ratio of MCLK/LRCK. Sets the LRCK rate if using the SRC otherwise sets the RMCK rate.

        """
        lookup_clk_ratio = {64:0, 96:1, 128:2, 192:3, 256:4, 384:5, 512:6, 768:7, 1024:8}
        if src:
            self.spdif_rx.writeField('SAO_CLK', lookup_clk_ratio[clk_ratio])  # SAO_MCLK/OLRCK1 ratio
            self.spdif_rx.writeField('SAO_MCLK', 0)  # XTI XTO
            self.spdif_rx.writeField('SRCD', 1)  # AES3 -> SRC
            self.spdif_rx.writeField('SDOUT1', 0)  # SRC -> SDOUT1
        else:
            self.spdif_rx.writeField('RMCK_CTL', 0)  # RMCK output from frame rate
            self.spdif_rx.writeField('RMCK', lookup_clk_ratio[clk_ratio])  # RMCK = 256xFsi
            self.spdif_rx.writeField('SAO_MCLK', 1)  # Recovered MCLK
            self.spdif_rx.writeField('SDOUT1', 1)  # AES3 -> SDOUT1
        self.spdif_rx.writeField('SOFSEL1', 1)  # I2S
        self.spdif_rx.writeField('SOMS1', master)  # SPDIF RX masters OSCLK1&OLRCK1 or not
        self.spdif_rx.writeField('PDN', 0)

        # setup SPDIF TX
        self.spdif_tx.writeRegisterByAddress(0x03, 0x40)  # TX disabled
        self.spdif_tx.writeRegisterByAddress(0x01, 0x00)  # default, AES3 not muted
        self.spdif_tx.writeRegisterByAddress(0x02, 0x00)  # AES3 operates as stereo
        self.spdif_tx.writeRegisterByAddress(0x05, 0x05)  # set as 24 bit I2S slave (LRCK is high for right channel)
        self.spdif_tx.writeRegisterByAddress(0x04, 0x40)  # power up device, OMCK = 256 x Fs
        self.spdif_tx.writeRegisterByAddress(0x03, 0x00)  # TX enabled, normal operation
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# low level routing methods
# ----------------------------------------------------------------------------
    def mux_mclk(self, pin, source=None):
        """Setup one MCLK signal (direction + mux source)

        Args:
            pin (str): pin name to configure
            source (str): name of mux source, set to 'None' for Hi-Z

        """
        pin_name = pin  # no modifications required?

        if source is None:
            self.fpga.writeField(pin_name+ '_DIR', 0x01)
            if 'SAIO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x00)
        else:
            if 'SAIO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x01)
            self.fpga.writeField(pin_name + '_SEL', self.lookup_mux[self.mclk][source])
            if 'DEV' in pin:
                self.fpga.writeField(pin_name + '_FUNC', 0x02)
            if 'DEV' in pin or 'SAIO' in pin:
                self.fpga.writeField(pin_name + '_DIR', 0x00)


    def mux_sclk(self, pin, source=None, prefix=None):
        """Setup one SCLK signal (direction + mux source)

        Args:
            pin (str): pin name to configure
            source (str): name of mux source, set to 'None' for Hi-Z
            prefix (str): set to "I" to use "SPDIF_RX_ISCLK"

        """
        # Resolve naming difference for SPDIF (e.g. 'x_OSCLK' vs 'x_SCLK')
        if prefix is None:
            if 'SPDIF' in pin:
                if 'RX' in pin:
                    prefix = 'O'
                elif 'TX' in pin:
                    prefix = 'I'
                else:
                    raise ValueError(pin)
            else:
                prefix=''
        pin_name = pin + '_' + prefix + 'SCLK'

        if source is None:
            self.fpga.writeField(pin_name+ '_DIR', 0x01)
            if 'SAI' in pin or 'SAO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x00)
        else:
            if 'SAI' in pin or 'SAO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x01)
            self.fpga.writeField(pin_name + '_SEL', self.lookup_mux[self.sclk][source])
            if 'DEV' in pin:
                self.fpga.writeField(pin_name + '_FUNC', 0x02)
            self.fpga.writeField(pin_name + '_DIR', 0x00)


    def mux_lrck(self, pin, source=None, prefix=None):
        """Setup one LRCK signal (direction + mux source)

        Args:
            pin (str): pin name to configure
            source (str): name of mux source, set to 'None' for Hi-Z
            prefix (str): set to "I" if trying to use "SPDIF_RX_ILRCK"

        """
        # Resolve naming difference for SPDIF (e.g. 'x_OLRCK' vs 'x_LRCK')
        if prefix is None:
            if 'SPDIF' in pin:
                if 'RX' in pin:
                    prefix = 'O'
                elif 'TX' in pin:
                    prefix = 'I'
                else:
                    raise ValueError(pin)
            else:
                prefix=''
        pin_name = pin + '_' + prefix + 'LRCK'

        if source is None:
            self.fpga.writeField(pin_name+ '_DIR', 0x01)
            if 'SAI' in pin or 'SAO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x00)
        else:
            if 'SAI' in pin or 'SAO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x01)
            self.fpga.writeField(pin_name + '_SEL', self.lookup_mux[self.lrck][source])
            if 'DEV' in pin:
                self.fpga.writeField(pin_name + '_FUNC', 0x02)
            self.fpga.writeField(pin_name + '_DIR', 0x00)


    def mux_sdata(self, pin, source=None):
        """Setup one PCM Data signal (direction + mux source)

        Args:
            pin (str): pin name to configure
            source (str): name of mux source, set to 'None' for Hi-Z

        """
        pin_name = pin  # no modifications required?

        if source is None:
            if 'DEV' in pin:
                self.fpga.writeField(pin_name+ '_DIR', 0x01)
        else:
            self.fpga.writeField(pin_name + '_SEL', self.lookup_mux[self.sdata][source])
            if 'DEV' in pin:
                self.fpga.writeField(pin_name + '_FUNC', 0x02)
                self.fpga.writeField(pin_name + '_DIR', 0x00)


    def mux_pdm_clk(self, pin, source=None):
        """Setup one PDM Clock signal (direction + mux source)

        Args:
            pin (str): pin name to configure
            source (str): name of mux source, set to 'None' for Hi-Z

        """
        pin_name = pin + '_CLK'

        if source is None:
            self.fpga.writeField(pin_name+ '_DIR', 0x01)
            if 'PDMIO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x00)
        else:
            if 'PDMIO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x01)
            self.fpga.writeField(pin_name + '_SEL', self.lookup_mux[self.pdm_clk][source])
            if 'DEV' in pin:
                self.fpga.writeField(pin_name + '_FUNC', 0x02)
            self.fpga.writeField(pin_name + '_DIR', 0x00)


    def mux_pdm_data(self, pin, source=None):
        """Setup one PDM Clock signal (direction + mux source)

        Args:
            pin (str): pin name to configure
            source (str): name of mux source, set to 'None' for Hi-Z

        """
        pin_name = pin + '_DATA'

        if source is None:
            self.fpga.writeField(pin_name+ '_DIR', 0x01)
            if 'PDMIO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x00)
        else:
            if 'PDMIO' in pin:
                    self.io.writeField(pin_name + '_DIR_3V3', 0x01)
            self.fpga.writeField(pin_name + '_SEL', self.lookup_mux[self.pdm_data][source])
            if 'DEV' in pin:
                self.fpga.writeField(pin_name + '_FUNC', 0x02)
            self.fpga.writeField(pin_name + '_DIR', 0x00)
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# high level routing methods
# ----------------------------------------------------------------------------
    def routeMCLK(self, source):
        """Route a single MCLK source to everything!

        Args:
            source (str): source of the master clock

        """
        for name in ['SAIO_MCLK1', 'SAIO_MCLK2', 'SPDIF_RX_XTI',
                            'AC0_MCLK', 'XUSB_MCLK', 'DEV_MCLK1', 'DEV_MCLK2']:
            if name in source:
                self.mux_mclk(name)  # input (can't source itself)
            else:
                self.mux_mclk(name, source)


    def routeSAIO(self, dev_port, master):
        """Connect SAIO headers to a device AIF port. SAO is always slaved.
        DEV_AIFx_SDATA1 is routed from SAI SDATA1
        DEV_AIFx_SDATA2 is routed to SAO SDATA1

        Args:
            device (string): device AIF port, will attempt to lookup mapping
            master (bool): specifies clock direction, set True for device master

        """
        # attempt to lookup device <-> audiohub mapping
        if self.dev_map is not None:
            try:
                dev_port = self.dev_map[dev_port]
            except KeyError:
                pass

        # route device and SAI clocks
        if master == 1:
            self.mux_sclk(dev_port)
            self.mux_lrck(dev_port)
            self.mux_sclk('SAI', dev_port)
            self.mux_lrck('SAI', dev_port)
        elif master == 0:
            self.mux_sclk('SAI')
            self.mux_lrck('SAI')
            self.mux_sclk(dev_port, 'SAI')
            self.mux_lrck(dev_port, 'SAI')
        else:
            raise ValueError(master)

        # route data and SAO clocks (always slave)
        self.mux_sclk('SAO', dev_port)
        self.mux_lrck('SAO', dev_port)
        self.mux_sdata(dev_port + '_SDATA1', 'SAI_DATA1')
        self.mux_sdata(dev_port + '_SDATA2')
        self.mux_sdata('SAO_DATA1', dev_port + '_SDATA2')


    def routeSPDIF(self, dev_port, master):
        """Connect S/PDIF RX and TX to a device AIF port. S/PDIF TX is always slaved.
        DEV_AIFx_SDATA1 is routed from SPDIF_RX_SDOUT1
        DEV_AIFx_SDATA2 is routed to SPDIF_TX_SDIN

        Args:
            device (string): device AIF port, will attempt to lookup mapping
            master (bool): specifies clock direction, set True for device master

        """
        # attempt to lookup device <-> audiohub mapping
        if self.dev_map is not None:
            try:
                dev_port = self.dev_map[dev_port]
            except KeyError:
                pass

        # route S/PDIF RX and device clocks
        if master == 1:
            self.mux_sclk(dev_port)
            self.mux_lrck(dev_port)
            self.mux_sclk('SPDIF_RX', dev_port)
            self.mux_lrck('SPDIF_RX', dev_port)
        elif master == 0:
            self.mux_sclk('SPDIF_RX')
            self.mux_lrck('SPDIF_RX')
            self.mux_sclk(dev_port, 'SPDIF_RX')
            self.mux_lrck(dev_port, 'SPDIF_RX')
        else:
            raise ValueError(master)

        # route data and SPDIF clocks (always slave)
        self.mux_sclk('SPDIF_TX', dev_port)
        self.mux_lrck('SPDIF_TX', dev_port)
        self.mux_sdata(dev_port + '_SDATA1', 'SPDIF_RX_SDOUT1')
        self.mux_sdata(dev_port + '_SDATA2')
        self.mux_sdata('SPDIF_TX_SDIN', dev_port + '_SDATA2')


    def routeUSB(self, dev_port):
        """Connect USB Audio Module (master only) to a device AIF port
        DEV_AIFx_SDATA1 is routed from USB Audio SDOUT1
        DEV_AIFx_SDATA2 is routed to USB Audio SDIN1

        Args:
            device (string): device AIF port, will attempt to lookup mapping
            master (bool): specifies clock direction, set True for device master

        """
        # attempt to lookup device <-> audiohub mapping
        if self.dev_map is not None:
            try:
                dev_port = self.dev_map[dev_port]
            except KeyError:
                pass

        # route clocks and data (USB always master)
        self.mux_sclk(dev_port, 'XUSB')
        self.mux_lrck(dev_port, 'XUSB')
        self.mux_sdata(dev_port + '_SDATA1', 'XUSB_SDOUT1')
        self.mux_sdata(dev_port + '_SDATA2')
        self.mux_sdata('XUSB_SDIN1', dev_port + '_SDATA2')


    def routePDMIO(self, hdr, dev_port, clk_dir, data_dir):
        """Connect a PDMIO header to a device PDM port.

        Args:
            hdr (int): PDMIO header, can be 1 or 2
            dev_port (string): device PDM port, will attempt to lookup mapping
            clk_dir (bool): specifies clock direction, set True for device -> HDR
            data_dir (bool): specifies data direction, set True for device -> HDR

        """
        # attempt to lookup device <-> audiohub mapping
        if self.dev_map is not None:
            try:
                dev_port = self.dev_map[dev_port]
            except KeyError:
                pass

        # get name of PDMIO header
        if hdr in [1, '1', 'PDMIO1', 'pdmio1']:
            hdr_name = 'PDMIO1'
        elif hdr in [2, '2', 'PDMIO2', 'pdmio2']:
            hdr_name = 'PDMIO2'
        else:
            raise ValueError(hdr)

        # route PDM CLK
        if clk_dir == True:
            self.mux_pdm_clk(dev_port)
            self.mux_pdm_clk(hdr_name, dev_port)
        elif clk_dir == False:
            self.mux_pdm_clk(hdr_name)
            self.mux_pdm_clk(dev_port, hdr_name)
        else:
            raise ValueError(clk_dir)

        # route PDM Data
        if data_dir == True:
            self.mux_pdm_data(dev_port)
            self.mux_pdm_data(hdr_name, dev_port)
        elif data_dir == False:
            self.mux_pdm_data(hdr_name)
            self.mux_pdm_data(dev_port, hdr_name)
        else:
            raise ValueError(data_dir)
# ----------------------------------------------------------------------------

# GPIO and INT functions
# ----------------------------------------------------------------------------
# There are four GPIO pins on AudioHub and they are 1 indexed
#
# GPIO0 - 1
# GPIO1 - 2
# GPIO2 - 3
# GPIO3 - 4
#
# NOTE: method setPinLevel will be changed to setPinState eventually (hopefully)
# ----------------------------------------------------------------------------
    def setGPIO(self, pin, state=None):
        """Set the directionality and state of a GPIO pin.

        Args:
            pin (int): pin number
                - GPIO0 = 1
                - GPIO1 = 2
                - GPIO2 = 3
                - GPIO3 = 4
            state (bool): set direction and state of GPIO pin
                - None = Hi-Z
                - True = High
                - False = Low

        """
        # this is here to patch a problem with the API
        if not hasattr(GpioSetTransaction, 'setPinState'):
            GpioSetTransaction.setPinState = GpioSetTransaction.setPinLevel

        if state is None:
            directionSetting = GpioSetTransaction().setPinDirection(pin, GpioPinDirection.INPUT)
            self.clsystem.setGpio(directionSetting)
        else:
            directionSetting = GpioSetTransaction().setPinDirection(pin, GpioPinDirection.OUTPUT)
            if state == True:
                stateSetting = GpioSetTransaction().setPinState(pin, GpioPinState.HIGH)
            elif state == False:
                stateSetting = GpioSetTransaction().setPinState(pin, GpioPinState.LOW)
            else:
                raise ValueError(state)
            self.clsystem.setGpio(directionSetting)
            self.clsystem.setGpio(stateSetting)


    def getGPIO(self, pin):
        """Return the directionality and state of a GPIO pin.

        Args:
            pin (int): pin number
                - GPIO0 = 1
                - GPIO1 = 2
                - GPIO2 = 3
                - GPIO3 = 4

        Returns:
            state (unknown): state of GPIO pin

        """
        # this is here to patch a problem with the API
        if not hasattr(GpioGetTransaction, 'getPinState'):
            GpioGetTransaction.getPinState = GpioGetTransaction.getPinLevel

        directionSetting = GpioGetTransaction().getPinDirection(pin)
        stateSetting = GpioGetTransaction().getPinState(pin)

        direction = self.clsystem.getGpio(directionSetting)[0].getDirection()
        state = self.clsystem.getGpio(stateSetting)[0].getState()

        if platform.system() != 'Java':
            direction = direction.value
            state = state.value

        return state


    def getINT(self, pin):
        """Create a SSH link to Linux OS on AudioHub and return INT pin state."""
        if   pin == 1: gpio = 962 # INT_0
        elif pin == 2: gpio = 963 # INT_1
        elif pin == 3: gpio = 964 # INT_2
        else:
            raise ValueError(pin)

        details = self.clsystem.getTransportDetails()
        hostIP = details[details.find('[')+1:details.find(']')-5]
        username = 'root'
        password = 'crus'

        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(hostIP, username=username, password=password)
        stdin, stdout, sterr = ssh.exec_command('echo %s > /sys/class/gpio/export' % gpio)
        stdin, stdout, sterr = ssh.exec_command('echo in > /sys/class/gpio/gpio%s/direction' % gpio)
        stdin, stdout, sterr = ssh.exec_command('cat /sys/class/gpio/gpio%s/value' % gpio)
        output = stdout.read()
        if output == '1\n':
            state = self.HIGH
        elif output == '0\n':
            state = self.LOW
        else:
            state = 'UNKNOWN'
        ssh.close()
        return state
