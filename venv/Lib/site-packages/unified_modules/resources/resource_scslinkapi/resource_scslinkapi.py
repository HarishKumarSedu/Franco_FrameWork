#!/usr/bin/env python
"""
@brief
A resource library to access the DUT registers and bit fields via SCS StudioLink.

@Description:
This resource library provides wrapper methods to access all the
python APIs in the StudioLink class.

Supported features:
- start link
- stop link
- discover a particular device
- connect to a particular device
- read register properties
- write to a register
- read and write to a bit field
- list devices discovered
@b Usage
@code
scs_link = ScsLinkApi(tag="dut_scs_link", configs=config)
@endcode
"""
import os
import sys
import re
from time import sleep
import socket
import paramiko
import threading
from collections import namedtuple

from studiolink.StudioLink import StudioLink
from studiolink.enums.ConnectionStatus import ConnectionStatus
from studiolink.exceptions.StudioLinkException import StudioLinkException

from studiolink.device_comm.GpioGetTransaction import GpioGetTransaction
from studiolink.device_comm.GpioSetTransaction import GpioSetTransaction
from studiolink.enums.GpioPinDirection import GpioPinDirection
from studiolink.enums.GpioPinState import GpioPinState


from .bsp_tools.AudioHUB import *
from .bsp_tools.CS44L2x import *

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


_FPGA = namedtuple('BSP_FPGA', 'Control_FPGA AudioHub_FPGA AudioHUB_FPGA AudioHub2_FPGA AudioHUB2_FPGA')
BSP_FPGA = _FPGA("Control FPGA", 'AudioHub FPGA', 'AudioHUB FPGA', 'AudioHub2 FPGA', 'AudioHUB2 FPGA')
_STATES =  namedtuple('GPIO_STATES', 'HIGH LOW UNKNOWN')
GPIO_STATES = _STATES(1, 0, -1)
_gpio_dir =  namedtuple('GPIO_DIR', 'INPUT OUTPUT')
GPIO_DIR = _gpio_dir(1, 0)
_ah_gpios = namedtuple('AH_GPIOS', "GPIO0 GPIO1 GPIO2 GPIO3 GPIO4 GPIO5")
AH_GPIOS = _ah_gpios('DEV_PDM1_CLK_DIR', 'DEV_PDM1_DATA_DIR', 'DEV_PDM2_CLK_DIR', 'DEV_PDM2_DATA_DIR',
                     'DEV_PDM3_CLK_DIR', 'DEV_PDM3_DATA_DIR')

_gpio_read = namedtuple('GPIO_READ', "DEV_PDM1_CLK_VIS DEV_PDM1_DATA_VIS DEV_PDM2_CLK_VIS DEV_PDM2_DATA_VIS"
                                     " DEV_PDM3_CLK_VIS DEV_PDM3_DATA_VIS")
GPIO_READ = _gpio_read(0, 1, 2, 3, 4, 5)

_gpio_write = namedtuple('GPIO_WRITE', "GPIO0 GPIO1 GPIO2 GPIO3 GPIO4 GPIO5")
GPIO_WRITE = _gpio_write("DEV_PDM1_CLK_SEL", "DEV_PDM1_DATA_SEL", "DEV_PDM2_CLK_SEL", "DEV_PDM2_DATA_SEL",
                         "DEV_PDM3_CLK_SEL", "DEV_PDM3_DATA_SEL")

class BspPythonHelperException(Exception):
    "Exception class for BspPythonHelper"
    pass


class BspPythonHelper(object):
    """
    Helper class initialize the system
    """

    def __init__(self, system, device, target_device, cirruslink_present=False, bsp_projects=None,
                 bsp_mapping=None):
        self.log = logging.getLogger(BspPythonHelper.__name__)
        self.target_device = target_device
        self.cirruslink_present = cirruslink_present
        self.bsp_name = self.target_device.split('_')[0]
        self.bsp_projects = bsp_projects
        self.bsp_mapping = bsp_mapping
        self.bsp_device_num = "".join(["CS", self.bsp_mapping[self.bsp_name]])
        device_string = "Device"

        # Getting Audio hub fpga instance
        if self.bsp_name in [self.bsp_projects.Cornell, self.bsp_projects.Trucks, self.bsp_projects.Berry,
                             self.bsp_projects.Becker]:
            self.fpga = system.getDevice(BSP_FPGA.AudioHub_FPGA)
        elif self.bsp_projects.Domino in self.target_device:
            self.fpga = system.getDevice(BSP_FPGA.AudioHub2_FPGA)
            device_string = "Mode"
        # AudioHUB2 - HUB!
        elif self.bsp_name in [self.bsp_projects.BBking, self.bsp_projects.Dollar, self.bsp_projects.Sterling]:
            self.fpga = system.getDevice(BSP_FPGA.AudioHub2_FPGA)
        elif self.bsp_name in self.bsp_projects.Lynott:
            self.fpga = system.getDevice(BSP_FPGA.AudioHub2_FPGA)
            self.control_fpga = system.getDevice('CS40L40 Control FPGA')
            self.fpga_wrapper = system.getDevice('CS40L40 FPGA Wrapper')

        # Getting Device instance
        if self.bsp_name in [self.bsp_projects.Cornell, self.bsp_projects.Dollar, self.bsp_projects.Sterling, self.bsp_projects.Lynott,self.bsp_projects.Mahoney]:
            self.device = system.getDevice(self.bsp_device_num)
        elif self.target_device == self.bsp_projects.Taylor:
            self.device = CS44L2x(device)
            self.audiohub = AudioHub(system, dev_map={'ASP': 'DEV_AIF1', 'PDM': 'DEV_PDM1'})
        elif self.bsp_name in [self.bsp_projects.Trucks, self.bsp_projects.Berry, self.bsp_projects.Becker, self.bsp_projects.Domino]:
            device_list = re.findall('\d+', self.target_device)
            device = ' '.join([self.bsp_device_num, device_string, (device_list[0])])
            self.device = system.getDevice(device)
        elif self.bsp_name in self.bsp_projects.BBking:
            # Device name for BBKing is device_num 1X where X is a Letter (ex. CS35L37 1A)
            device = "{device_num} {device_str}".format(
                device_num=self.bsp_device_num,
                device_str=target_device.split('_')[1].upper()
            )
            self.device = system.getDevice(device)
        else:
            raise ScsLinkApiError("Resource library not supported for device %s" % self.target_device)

    def init_bsp(self):
        """
        Initialize self.bsp_projects system. Reset device and configure Control FPGA or Audio Hub FPGA.
        """
        if self.target_device == self.bsp_projects.Taylor:
            self.device.writeField("HPAMP_EN", 0)
            self.device.writeField("PDM_EN_CTRL", 0)
            self.audiohub.initialize()
            self.device.initialize(out_mode=2, errata='A0')
        elif self.bsp_projects.Cornell in self.target_device:
            self.fpga.writeField('DEV_GLOBAL_HIZ', 0)
            self.audiohub_reset_dut()
            # 12MHz clock setting
            self.fpga.writeField('DEV_MCLK1_SEL', 0x4f)
            self.fpga.writeField('DEV_MCLK1_DIR', 0)
            # 125 Mode (12MHz MCLK)
            self.device.writeField('INTERNAL_FS', 0)
            self.device.writeField('MCLK_EN', 1)
            self.device.writeField('OTP_START', 1)
            for _ in list(range(100)):
                if self.device.readField('OTP_INACTIVE'):
                    break
            else:
                raise BspPythonHelperException("OTP timed out")
            # power on the device
            self.device.writeField('GLOBAL_EN', 1)
            self.device.writeField('PWR_DOMAIN1_EN', 1)
            self.device.writeField('PWR_DOMAIN2_EN', 1)
        elif self.bsp_name in [self.bsp_projects.Trucks, self.bsp_projects.Berry]:
            self.audiohub_reset_dut()
            self.device.writeField('SFT_RST', 0x5A)
        elif self.bsp_name in [self.bsp_projects.Becker, self.bsp_projects.Domino, self.bsp_projects.BBking,
                               self.bsp_projects.Sterling, self.bsp_projects.Lynott, self.bsp_projects.Dollar]:
            self.audiohub_reset_dut()
        else:
            raise ScsLinkApiError("Resource library not supported for device %s" % self.target_device)

    def dollar_ah_mlck_config(self, dut_master=True, mclk_mhz=24.576):
        """Audiohub MCLK needs to be configured for Dollar EMU board to be initialised
        """
        self.fpga.writeField('DEV_GLOBAL_HIZ', 0x0)
        if mclk_mhz == 24.576:
            self.fpga.writeField('DEV_MCLK1_SEL', 0x4B)  # 0x4B = 24.576, 0x4C = 24MHz
        elif mclk_mhz == 24:
            self.fpga.writeField('DEV_MCLK1_SEL', 0x4C)  # 0x4B = 24.576, 0x4C = 24MHz
        elif mclk_mhz == 12.288:
            self.fpga.writeField('DEV_MCLK1_SEL', 0x33)  # 0x4B = 24.576, 0x4C = 24MHz
        elif mclk_mhz == 12:
            self.fpga.writeField('DEV_MCLK1_SEL', 0x32)  # 0x4B = 24.576, 0x4C = 24MHz
        else:
            raise ValueError

        self.fpga.writeField('FORCE_DUT_RESETN', 0x0)  # out of reset
        self.fpga.writeField('DEV_PDM5_DATA_SEL', 0x1)  # force panic high
        self.fpga.writeField('VIO_HDR_SEL', 0x1)  # 1.8V on audiohub headers

        if dut_master is True:
            # Serial Audio In
            self.fpga.writeField('SAI_MCLK_DIR', 0x0)  # OUT
            self.fpga.writeField('SAI_MCLK_SEL', 0x22)  # Dev MCLK1
            self.fpga.writeField('SAI_BCLK_DIR', 0x0)  # OUT
            self.fpga.writeField('SAI_BCLK_SEL', 0x28)  # ASP1 BCLK
            self.fpga.writeField('SAI_FCLK_DIR', 0x0)  # OUT
            self.fpga.writeField('SAI_FCLK_SEL', 0x29)  # ASP1 FCLK

            # Dev ASP1 Audio Hub Slave
            self.fpga.writeField('DEV_ASP1_BCLK_DIR', 0x1)  # IN
            self.fpga.writeField('DEV_ASP1_FCLK_DIR', 0x1)  # IN
            # DUT SDIN
            self.fpga.writeField('DEV_ASP1_DATA2_DIR', 0x0)  # OUT
            self.fpga.writeField('DEV_ASP1_DATA2_SEL', 0x8)  # SAI SDI1
            # DUT SDOUT
            self.fpga.writeField('DEV_ASP1_DATA1_DIR', 0x1)  # IN
        else:
            # Serial Audio In
            self.fpga.writeField('SAI_MCLK_DIR', 0x0)  # OUT
            self.fpga.writeField('SAI_MCLK_SEL', 0x22)  # Dev MCLK1
            self.fpga.writeField('SAI_BCLK_DIR', 0x1)  # IN
            self.fpga.writeField('SAI_FCLK_DIR', 0x1)  # IN

            # Dev ASP1 Audio Hub Mastering
            self.fpga.writeField('DEV_ASP1_BCLK_DIR', 0x0)  # OUT
            self.fpga.writeField('DEV_ASP1_BCLK_SEL', 0x6)  # SAI BCLK
            self.fpga.writeField('DEV_ASP1_FCLK_DIR', 0x0)  # OUT
            self.fpga.writeField('DEV_ASP1_FCLK_SEL', 0x7)  # SAI FCLK

            # DUT SDIN
            self.fpga.writeField('DEV_ASP1_DATA2_DIR', 0x0)  # OUT
            self.fpga.writeField('DEV_ASP1_DATA2_SEL', 0x8)  # SAI SDI1
            # DUT SDOUT
            self.fpga.writeField('DEV_ASP1_DATA1_DIR', 0x1)  # IN

        # Serial Audio Out
        self.fpga.writeField('SAO_MCLK_DIR', 0x0)  # OUT
        self.fpga.writeField('SAO_MCLK_SEL', 0x22)  # Dev MCLK1
        self.fpga.writeField('SAO_BCLK_DIR', 0x0)  # OUT
        self.fpga.writeField('SAO_BCLK_SEL', 0x28)  # ASP1 BCLK
        self.fpga.writeField('SAO_FCLK_DIR', 0x0)  # OUT
        self.fpga.writeField('SAO_FCLK_SEL', 0x29)  # ASP1 FCLK
        self.fpga.writeField('SAO_SDO2_SEL', 0x2a)  # DEV ASP Data1

    def configure_serial_port(self, master=False):
        if self.target_device == self.bsp_projects.Taylor:
            self.audiohub.routeSAIO("ASP", master=master)
            self.device.configure_serial_port(format='A0', sample_rate=48, ch_sel=1, ch_size=32, num_ch=2)
            self.device.configure_pll(clk_in=3.072,
                                      clk_out=6.144)  # Note: clock_in = sample_rate * ch_size * num_ch / 1000.0
            # turn on amp output
            self.device.writeField("AMP_INPUT", 0)
            self.device.writeField("HPAMP_EN", 1)

    def audiohub_reset_dut(self):
        """
        Toggle the DUT_RESET pin.
        """
        try:
            self.fpga.writeField('FORCE_DUT_RESETN', 1)
            sleep(.1)
            self.fpga.writeField('FORCE_DUT_RESETN', 0)
            sleep(.2)  # wait for reset line to deassert
        except:
            self.log.warning("Not able to toggle the DUT_RESET pin")

    def control_fpga_reset_dut(self):
        """
        Toggle the DUT_RESET pin.
        """
        self.fpga.writeField("DUT_RESETB", 0)
        self.fpga.writeField("DUT_RESETB", 1)
        # Device reset takes 750ms in EMU platforms
        sleep(.75)

    def audiohub_reset_sys(self):
        """
        Toggle the SYS_RESET pin.
        """
        self.fpga.writeField('FORCE_SYS_RESETN', 1)
        # wait for reset line to deassert
        sleep(.1)
        self.fpga.writeField('FORCE_SYS_RESETN', 0)


class ScsLinkApiError(Exception):
    """Define ScsLinkApiError Exception type"""
    pass


class ScsLinkApi(object):
    """
    Wrapper to StudioLink python APIs
    """
    list_of_discovered_systems = []

    def __init__(self):
        self.log = logging.getLogger(ScsLinkApi.__name__)
        self.list_of_discovered_systems = []
        self.device_list = []
        self.registers_and_address = []
        self.path_dev_defn = None
        self.scs_link_path = None
        self.studiolink = None
        self.system = None
        self.device = None
        self.control_fpga = None
        self.fpga_wrapper = None
        self.python_helper = None
        self.init_pyhelper = False
        self.cirruslink_present = False
        self.bsp_projects = None
        self.bsp_mapping = None
        self.gpio_num = None
        self.stop_gpio_polling = False
        self.gpio_state = None


    def set_bsp_mapping(self, bsp_projects, bsp_mapping):
        bsp_dev_id_keys = list(bsp_projects.keys())
        _BSP_PROJECTS = namedtuple('BspProjects', ' '.join(bsp_dev_id_keys))
        self.bsp_projects = _BSP_PROJECTS(*list(bsp_projects.values()))
        self.bsp_mapping = bsp_mapping

    def initiate_studiolink(self, scs_link_path):
        self.scs_link_path = scs_link_path
        self.studiolink = StudioLink(self.scs_link_path)
        if not self.studiolink:
            raise ScsLinkApiError("failed to initiate StudioLink")
        return "StudioLink initiated"

    def start_link(self):
        """
        This method will start SCS Link
        """
        self.studiolink.start()

    def stop_link(self, user_home=None):
        """
        This method will stop SCS link
        :return:
        """
        import glob

        version = "v" + self.get_installed_scs_base_version()
        self.studiolink.stop()
        self.studiolink.killLink()
        users_home = os.path.expanduser("~")
        if 'C:\Windows\system32\config\systemprofile' in users_home:
            users_home = user_home
        scs_log_type = 'scs_link*.log'
        if 'Darwin' in platform.system():
            scs_log_type = 'MacLink*.log'
        scs_logs_path = os.path.join(users_home, 'SoundClearStudio', version, 'log', scs_log_type)
        scs_log_files = glob.glob(scs_logs_path)
        scs_latest_log = max(scs_log_files, key=os.path.getctime) if scs_log_files else None
        return scs_latest_log

    def discover_sys(self):
        """
        This method will discover visible systems
        :return: self.discovered_systems which is a list of found Systems discovered by Link
        """
        discovered_systems = self.studiolink.getDiscoveredCLSystems()
        for system in discovered_systems:
            self.list_of_discovered_systems.append(system)
            board_status = str(system.getName()) + '\tConnection status: ' + \
                           str(system.getConnectionStatus())
            self.log.info(board_status)
        return self.list_of_discovered_systems

    def get_system_ip(self):
        """
        This method will discover visible systems and returns system names and corresponding IP address details
        :return: system_ip_details
        """
        system_ip_details = dict()
        try:
            discovered_systems = self.discover_sys()
        except StudioLinkException as sle:
            discovered_systems = None
            self.log.error("Could get the system details; exception is: %s" % sle.message)
        if discovered_systems is not None:
            for system in discovered_systems:
                details = system.getTransportDetails()
                match = re.search(r'\d+\.\d+.\d+\.\d+', details, re.U)
                system_ip_details[str(system.getName())] = match.group(0)
            return system_ip_details

    def wait_until_system_available(self, system, timeout=15):
        """
        Wait until given system available.
        @param system: System name
        @return: True or False
        """
        for i in range(timeout):
            status = system.getConnectionStatus()
            self.log.info("Connection Status: %s", str(status))
            if status == ConnectionStatus.AVAILABLE or status == ConnectionStatus.CONNECTED:
                return True
            else:
                sleep(1)
        return False

    def list_system_devices(self):
        """
        This method will list all of devices for desired system
        :return: self.device_list - list of all discovered devices for desired system
        """
        for system in self.list_of_discovered_systems:
            devices = system.getDevices()
            for single_device in devices:
                self.device_list.append(single_device.getName())
        return self.device_list

    def connect_to_board(self, board):
        """
        Use this to connect to desired board
        :return: Board is connected
        """
        self.studiolink.setDefaultCLSystem(board)
        self.studiolink.connectToCLSystem(board)

    def list_all_register_from_device(self):
        """
        Use this method to list all registers from desired device
        :return: register_and_address: list of all register and addresses
        """
        register_address = []
        register_name = []
        registers = self.device.getRegisters()
        for single_register in registers:
            register_address.append('%02x' % single_register.getAddress())
            register_name.append(single_register.getName())
            self.registers_and_address = list(zip(register_address, register_name))
        return self.registers_and_address

    def read_register_value_by_name(self, name, result_inst=None):
        """
        This method will return value of a desired register.
        @param name: name of a register
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: [str] register value as String
        """
        try:
            reg_value = self.device.readRegisterByName(name)
            return str(reg_value)
        except StudioLinkException as sle:
            self.log.error("Could not read register value by name. reg_name %s", name)
            if result_inst:
                result_inst.assert_true(False, "Read register %s" % name)

    def read_register_value_by_address(self, address, result_inst=None, verbose=True):
        """
        This method will return value of a desired register.
        @param name: address of a register
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: [str] address value as String
        """
        try:
            if verbose:
                self.log.info("Reading register by address %s" % hex(address))
            reg_value = self.device.readRegisterByAddress(address)
            return str(reg_value)
        except StudioLinkException as sle:
            self.log.error("Could not read register value by address %s" % address)
            if result_inst:
                result_inst.assert_true(False, "Read register %s" % address)

    def read_reg_default_value(self, reg_name, result_inst=None):
        """
        This method will return default value of a desired register.
        @param reg_name: name of register
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: register value as integer
        """
        try:
            reg_info = self.device.getRegisterInfoByName(reg_name)
            reg_default_value = reg_info.getDefaultValue()
            return reg_default_value
        except StudioLinkException as sle:
            self.log.error("Could not read register default value. reg_name: %s" % reg_name)
            if result_inst:
                result_inst.assert_true(False, "Read register info %s" % reg_name)

    def write_register_by_name(self, reg_name, reg_value=None, reg_width=None,
                               invalid_data=False, raise_excep_on_fail=False, result_inst=None):
        """
        Write value to a register
        @param reg_name: Register name
        @param reg_value: Value to write
        @param reg_width: Register width is provided to write max value
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        """
        if reg_value is None:
            reg_value = 2 ** reg_width
        else:
            if invalid_data == False:
                reg_value = int(reg_value, 16)
        try:
            self.log.info("Writing register %s, value %s" % (reg_name, reg_value))
            self.device.writeRegisterByName(reg_name, reg_value)
        except StudioLinkException as sle:
            log_msg = "Could not write to register by name. reg_name:%s, excep:%s" % (reg_name, sle.message)
            self.log.error(log_msg)
            if result_inst:
                result_inst.assert_true(False, "Write register %s" % reg_name)
            if raise_excep_on_fail or invalid_data:
                raise ScsLinkApiError(log_msg)
            self.log.error(log_msg)

    def read_reg_field(self, field_name, result_inst=None):
        """
        Read register bit field
        @param field_name: [string] bit field name of a register
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: bit field value in HEX
        """
        try:
            return str(self.device.readField(field_name))
        except StudioLinkException as sle:
            self.log.error("could not read register bit field. field_name: %s" % field_name)
            if result_inst:
                result_inst.assert_true(False, "Read register bitfield %s" % field_name)

    def read_ah_reg_field(self, field_name, result_inst=None):
        """
        Read Audio Hub Register bit field
        @param field_name: [string] audio hub bit field name
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: AH bit field value in HEX
        """
        try:
            return str(self.python_helper.fpga.readField(field_name))
        except StudioLinkException as sle:
            self.log.error("could not read Audio Hub register bit field. field_name: %s", field_name)
            if result_inst:
                result_inst.assert_true(False, "Read Audio Hub register bitfield %s" % field_name)

    def write_ah_reg_field(self, field_name, value, result_inst=None):
        try:
            self.log.info("Writing bitfield %s, value %s", (field_name, hex(value)))
            return str(self.python_helper.fpga.writeField(field_name, value))
        except StudioLinkException as sle:
            self.log.error("could not write Audio Hub register bit field. field_name: %s", field_name)
            if result_inst:
                result_inst.assert_true(False, "write Audio Hub register bitfield %s" % field_name)

    def write_ah_reg_by_name(self, reg_name, value, result_inst=None):
        try:
            self.log.info("Writing Register %s, value %s" % (reg_name, hex(value)))
            return str(self.python_helper.fpga.writeRegisterByName(reg_name, value))
        except StudioLinkException as sle:
            self.log.error("could not write Audio Hub register. reg_name: %s", reg_name)
            if result_inst:
                result_inst.assert_true(False, "write Audio Hub register %s" % reg_name)

    def read_ah_reg_by_name(self, reg_name, result_inst=None):
        try:
            return str(self.python_helper.fpga.readRegisterByName(reg_name))
        except StudioLinkException as sle:
            self.log.error("could not read Audio Hub register. reg_name: %s", reg_name)
            if result_inst:
                result_inst.assert_true(False, "Read Audio Hub register %s" % reg_name)

    def add_system_manually(self, system_name, system_file):
        """
        Creating a Simulated system
        @param system_name Name of Simulated system
        @param system_file System xml file
        @return None
        """
        try:
            self.studiolink.addCLSystemManually(system_name, system_file)
        except StudioLinkException as sle:
            if "A system already exists with the given name" not in sle.message:
                raise sle

    def get_system(self, system_name):
        """
        Gets CL system object associated with name system_name
        @param system_name System Name
        @return System object
        """
        return self.studiolink.getCLSystem(system_name)

    def connect_to_system_and_device(self,
                                     system_name,
                                     device_name,
                                     init_pyhelper=False,
                                     target_device='',
                                     cirruslink_present=False):
        """
        Connects to given system and device
        @param system_name System Name
        @param device_name Device Name
        @param init_pyhelper initialize python helper modules, applicable only to real hardware tests.
        @param target_device target DUT name, example:cornell, cornell_emu, cornell_emu_sim, etc.
        """
        bsp_device_num = ''
        self.cirruslink_present = cirruslink_present
        self.system = self.get_system(system_name)
        bsp_name = target_device.split('_')[0]
        if bsp_name in [self.bsp_projects.Taylor, self.bsp_projects.Cornell, self.bsp_projects.Trucks,
                        self.bsp_projects.Berry, self.bsp_projects.Becker, self.bsp_projects.Domino,
                        self.bsp_projects.BBking, self.bsp_projects.Dollar, self.bsp_projects.Lynott,self.bsp_projects.Mahoney]:
            bsp_device_num = "".join(["CS", self.bsp_mapping[bsp_name]])

        if self.bsp_projects.Becker in target_device or self.bsp_projects.Trucks in target_device:
            device_list = re.findall('\d+', target_device)
            device_name = ''.join([bsp_device_num, " Device ", (device_list[0])])
        elif self.bsp_projects.Domino in target_device:
            if 'mode' in target_device:
                device_list = re.findall('\d+', target_device)
                device_name = ''.join([bsp_device_num, " Mode ", (device_list[0])])
            else:
                device_name = '%s_FPGA_EMU_TOP' % bsp_device_num
        elif self.bsp_projects.BBking in target_device:
            device_name = ' '.join([bsp_device_num, target_device.split('_')[1].upper()])

        self.device = self.system.getDevice(device_name)
        if self.bsp_projects.Lynott in target_device:
            self.control_fpga = self.system.getDevice('CS40L40 Control FPGA')
            self.fpga_wrapper = self.system.getDevice('CS40L40 FPGA Wrapper')
        if self.bsp_projects.Mahoney in target_device:
            self.emu_fpga = self.system.getDevice('EMU FPGA')
            self.fpga = self.system.getDevice('AudioHub FPGA')
            self.pll1 = self.system.getDevice('PLL 1')

        self.init_pyhelper = init_pyhelper
        if self.init_pyhelper and target_device != '':
            self.python_helper = BspPythonHelper(system=self.system,
                                                 device=self.device,
                                                 target_device=target_device,
                                                 cirruslink_present=self.cirruslink_present,
                                                 bsp_projects=self.bsp_projects,
                                                 bsp_mapping=self.bsp_mapping)
            self.python_helper.init_bsp()

    def dev_configure_serial_port(self):
        self.python_helper.configure_serial_port()

    def get_device_type(self):
        """
        Get the system type.

        @return: [string] system type
        """
        return self.system.getType()

    def connect_to_device(self, device_name):
        """
        Get a device by name.

        @param device_name: device name
        @return: Device if present or None
        """
        try:
            self.device = self.system.getDevice(device_name)
        except StudioLinkException as sle:
            raise ScsLinkApiError(sle)

    def write_to_field(self, field_name, value, string_value=False, raise_excep_on_fail=False, result_inst=None):
        """
        Write a value to a field on the device.

        @param field_name: [string] name of field where value will be written
        @param value: [long] value for writing to field
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: None
        """
        try:
            if string_value:
                if isinstance(value, str) and '0x' in value:
                    value = value.rstrip('L')
                    value = int(value, 16)
                else:
                    value = int(value)
            self.device.writeField(field_name, value)
        except StudioLinkException as sle:
            log_msg = "Could not write to field. field_name: %s, excep:%s" % (field_name, sle.message)
            self.log.error(log_msg)
            if result_inst:
                result_inst.assert_true(False, "Write register field %s" % field_name)
            if raise_excep_on_fail:
                raise ScsLinkApiError(log_msg)
            self.log.error(log_msg)

    def write_register_by_address(self, address, value, result_inst=None, verbose=True):
        """
        Write a value to a register on the device; register is specified by address.

        @param address: [long] address of register for writing
        @param value: [long] value to write to specified register
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: None
        """
        try:
            if verbose:
                self.log.info("Writing register by address %s, value %s" % (hex(address), hex(value)))
            self.device.writeRegisterByAddress(address, value)
        except StudioLinkException as sle:
            self.log.error("Could not write register by address. address:%s value:%s" % address, value)
            if result_inst:
                result_inst.assert_true(False, "Write register %s" % address)

    def disconnect_all_except_system(self, system_name):
        try:
            systems = self.studiolink.getDiscoveredCLSystems()
            for system in systems:
                if system_name not in str(system.getName()):
                    self.log.info("Disconnecting System: %s", str(system.getName()))
                    self.studiolink.disconnectCLSystem(system.getName())
            sleep(3)
        except StudioLinkException:
            self.log.error("Error at disconnecting devices")

    def wait_until_system_available_to_connect(self, system_name, retries=30):
        """
        Wait until System is available to connect.
        @param system_name: System name
        @param tries: optional default is 5 tries.
        @return: returns system name if it exists in list of detected systems
        """
        for retry in range(retries):
            try:
                systems = self.studiolink.getDiscoveredCLSystems()
                for system in systems:
                    self.log.info("Systems:%s" % str(system.getName()))
                    if system_name in str(system.getName()):
                        if self.wait_until_system_available(system):
                            self.log.info("System %s discovered", system_name)
                            return system_name
                sleep(3)
            except StudioLinkException:
                self.log.error("Device not discovered, try again")

    def write_block_to_field(self, field_name, count, values, raise_excep_on_fail=False, result_inst=None):
        """
        Write a block of values to a field on the device.

        @param field_name: [str] Name of field to start writing at
        @param count: [integer] number of fields to write
        @param values: [list<long>]  list of values to write
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: None
        """
        try:
            hex_values = [int(str_val, 16) for str_val in values]
            self.device.blockWriteField(field_name, count, hex_values)
        except StudioLinkException as sle:
            log_msg = "Could not write register block field. field_name: %s count: " \
                      "%s values: %s except:%s" % (field_name, count, str(values), sle.message)
            self.log.error(log_msg)
            if result_inst:
                result_inst.assert_true(False, "Write block values to register field %s" % field_name)
            if raise_excep_on_fail:
                raise ScsLinkApiError(log_msg)
            self.log.error(log_msg)

    def read_block_field(self, field_name, count, result_inst=None):
        """
        Read a block of values from a field on the device.

        @param field_name: [string] name of field to start reading from
        @param count:  [long] number of fields to read
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return [list<long>] list of values from a field on the device, one entry for each field
                             read
        """
        try:
            long_values = self.device.blockReadField(field_name, count)
            long_values = [int(long_val) for long_val in long_values]
            str_values = [hex(long_val) for long_val in long_values]
            str_values_upper = [val.upper() for val in str_values]
            str_values_upper = [tmp[:-1] if 'L' in tmp else tmp for tmp in str_values_upper]
            return str_values_upper
        except StudioLinkException as sle:
            self.log.error("Could not read register block field. field_name: %s count: %s", field_name, count)
            if result_inst:
                result_inst.assert_true(False, "Read register block field %s" % field_name)

    def write_block_to_reg_by_addr(self, address, page, count, values, raise_excep_on_fail=False, result_inst=None):
        """
        Write a block of values to a device register

        @param address: [long] address of register to start writing
        @param page: [long] page which register address is on
        @param count: [long] count of registers to write. (Number of items in the values list)
        @param values: [list] An array or list of numeric values to write. The list can have any
                              integer numeric type.
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: None
        """
        try:
            hex_values = [int(str_val, 16) for str_val in values]
            self.device.blockWriteRegisterByAddress(address, page, count, hex_values)
        except StudioLinkException as sle:
            log_msg = "Could not write register block by address. " \
                      "address:%s page:%s count:%s values:%s except:%s" % (address, page, count, values, sle.message)
            self.log.error(log_msg)
            if result_inst:
                result_inst.assert_true(False, "Write block values to register %s" % address)
            if raise_excep_on_fail:
                raise ScsLinkApiError(log_msg)
            self.log.error(log_msg)

    def read_block_from_reg_by_addr(self, address, page, count, result_inst=None, bulk=False, addr_width=32):
        """
        Read a block of values from a device register; register is specified by address and page.

        @param address: [long] address of register to start reading
        @param page: [long] page of the register to start reading
        @param count: [long] count of registers to read
        @param result_inst: [object] optional - Results object - this is to log metric for failure cases
        @param bulk: [bool] True to read bulk data from the same address.
        @param addr_width: [int] register width - supported 8, 16, 24, 32
        @return: [list<long>] list of register values, one for each register read.
        """
        if bulk:
            if addr_width == 32:
                address = address | 0x80000000
            elif addr_width == 24:
                address = address | 0x800000
            elif addr_width == 16:
                address = address | 0x8000
            elif addr_width == 8:
                address = address | 0x80
        try:
            long_values = self.device.blockReadRegisterByAddress(address, page, count)
            long_values = [int(long_val) for long_val in long_values]
            str_values = [hex(long_val) for long_val in long_values]
            str_values_upper = [val.upper() for val in str_values]
            str_values_upper = [tmp[:-1] if 'L' in tmp else tmp for tmp in str_values_upper]
            return str_values_upper
        except StudioLinkException as sle:
            self.log.error("Could not read register block by address. address: %s page: %s count: %s ", address, page, count)
            if result_inst:
                result_inst.assert_true(False, "Read register block field %s" % address)

    def write_block_to_reg_by_name(self, reg_name, count, values, result_inst=None):
        """
        Write a block of values to a device register; register is specified by name.

        @param reg_name: [string] name of register to start writing
        @param count: [long] count of registers to write. (Number of items in the values list)
        @param values: [list] An array or list of numeric values to write.
                              The list can have any integer numeric type.
        @pram result_inst: [object] optional - Results object - this is to log metric for failure cases
        @return: None
        """
        try:
            self.device.blockWriteRegisterByName(reg_name, count, values)
        except StudioLinkException as sle:
            self.log.error("Could not write register block by name. reg_name:%s count:%s values:%s"
                           % (reg_name, count, values))
            if result_inst:
                result_inst.assert_true(False, "Write block values to register %s" % reg_name)

    def read_block_from_reg_by_name(self, reg_name, count):
        """
        Read a block of values from a device register; register is specified by name.

        @param reg_name: [string] name of register to start reading
        @param count: [long] count of registers to read
        @return: [list<long>] list of register values, one for each register read
        """
        try:
            return self.device.blockReadRegisterByName(reg_name, count)
        except StudioLinkException as sle:
            self.log.warning("Could not read register block by name. reg_name:%s count:%s ", reg_name, count)

    def get_studio_link_version(self):
        """
        Get the version of StudioLink being used.

        @return: [Version] StudioLink version
        """
        return self.studiolink.getStudioLinkVersion()

    def get_system_descriptions(self):
        """
        Get the list of system descriptions that StudioLink has loaded.

        @return: list of loaded system descriptions
        """
        return self.studiolink.getSystemDescriptions()

    def get_system_device_information(self, dev_name):
        """
        Get the list of system descriptions that StudioLink has loaded. And extract requested device information
        @param dev_name: [string] name of the device
        @return: Dictionary of system device information
        """
        dev_desc = {}
        device_descriptions = self.studiolink.getSystemDescriptions()
        for dev_dec in device_descriptions:
            dev_desc_devices = dev_dec.getDevices()
            for dev_dec_dev in dev_desc_devices:
                if dev_name == dev_dec_dev.getName():
                    dev_desc["ControlInterface"] = dev_dec_dev.getControlInterface().name
                    dev_desc["DeviceAddress"] = dev_dec_dev.getDeviceAddress()
                    dev_desc["Type"] = dev_dec_dev.getDeviceType()
                    return dev_desc

    def cirruslink_restart(self, ipaddress, port=22):
        """
        Given the audio hub ip address, this method creates a ssh connection to connect to audio hub,
        and issues a cirruslink service restart.
        @param: ipaddress: IP address of the audio hub hardware extracted from the system name.
        @param: port, default port number 22 is used.
        """
        username = 'root'
        password = 'crus'
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(ipaddress, port=port, username=username, password=password)
        stdin, _, _ = ssh.exec_command('service cirruslink stop')
        stdin.flush()
        sleep(0.5)
        stdin, _, _ = ssh.exec_command('service cirruslink start')
        stdin.flush()
        sleep(0.5)
        ssh.close()

    def get_installed_scs_base_version(self):
        """
        Gets the installed scs base version
        """
        self.log.info("Get the installed SCS base version")
        if "Windows" in platform.system():
            last = []
            installed_scs_folder_path = r"C:\Program Files\Cirrus Logic"
            if os.path.exists(installed_scs_folder_path):
                for filename in os.listdir(installed_scs_folder_path):
                    if filename.find("SoundClearStudio") != -1:
                        last = str(re.findall('\d+\.\d+', filename))
                        if last < str(re.findall('\d+\.\d+', filename)):
                            last = str(re.findall('\d+\.\d+', filename))
                if last == []:
                    return None
                else:
                    return str(last[2:-2])
            else:
                return None
        if "Darwin" in platform.system():
            last = []
            installed_scs_folder_path = r"/Applications"
            if os.path.exists(installed_scs_folder_path):
                for filename in os.listdir('/Applications'):
                    if str(filename).find("SoundClear Studio") > -1:
                        last = str(re.findall('\d+\.\d+', filename))
                        if last < str(re.findall('\d+\.\d+', filename)):
                            last = str(re.findall('\d+\.\d+', filename))
                return str(last[2:-2])
            else:
                return None

    def connect_to_device_write_to_field(self, device_name, field_name, field_value):
        """
        Connects to a device and write to a field
        @param device_name: [str] Device name
        @param field_name: [str] Bit field name
        @param field_value: [hex] Bit field value
        """
        device = self.system.getDevice(device_name)
        device.writeField(field_name, field_value)

    def connect_to_device_write_to_reg_by_address(self, device_name, reg_address, reg_value):
        """
        Connect to a device and write to a register by register address
        @param device_name: [str] Device name
        @param reg_address: [hex] Register address
        @param reg_value: [hex] Register value
        """
        device = self.system.getDevice(device_name)
        device.writeRegisterByAddress(reg_address, reg_value)

    def config_gpio(self, gpio_num=None, direction=GPIO_DIR.INPUT, config_all=False):
        """Set GPIO Pin Direction
        :param gpio_num: GPIO pin
        :param direction: GPIO Direction
        """
        if config_all:
            self.log.info("Configure all GPIOs in the audiohub in direction %s",
                          self.get_key_by_value(GPIO_DIR, direction))

            self.python_helper.fpga.writeField(AH_GPIOS.GPIO0, direction)  # GPIO 0 input
            self.python_helper.fpga.writeField(AH_GPIOS.GPIO1, direction)  # GPIO 1 input
            self.python_helper.fpga.writeField(AH_GPIOS.GPIO2, direction)  # GPIO 2 input
            self.python_helper.fpga.writeField(AH_GPIOS.GPIO3, direction)  # GPIO 3 input
            self.python_helper.fpga.writeField(AH_GPIOS.GPIO4, direction)  # GPIO 4 input
            self.python_helper.fpga.writeField(AH_GPIOS.GPIO5, direction)  # GPIO 5 input
        else:
            gpio_set = GpioSetTransaction()
            gpio_set.setPinDirection(gpio_num + 1, direction)
            self.system.setGpio(gpio_set)

    @staticmethod
    def get_key_by_value(named_tuple, value):
        return list(named_tuple._asdict().keys())[list(named_tuple._asdict().values()).index(value)]

    def get_gpio_state(self, gpio_num):
        """Read GPIO Pin
        :param gpio_num: GPIO pin
        :return: GPIO state(high/low)
        """
        self.log.debug("Reading bit field %s to get gpio%s state", self.get_key_by_value(GPIO_READ, gpio_num), gpio_num)
        return int(self.python_helper.fpga.readField(self.get_key_by_value(GPIO_READ, gpio_num)))


    def set_gpio_state(self, gpio_num, state=1):
        """Set GPIO Pin
        :param gpio_num: GPIO pin
        :state: GPIO state(high/low)
        """
        self.log.info("Write to bit field %s to set gpio %s state to %s",
                      gpio_num, self.get_key_by_value(GPIO_WRITE, gpio_num), state)
        self.python_helper.fpga.writeField(gpio_num, state)

    def config_irq(self, direction=GPIO_DIR.INPUT, irq_field='DEV_PDM5_CLK_DIR'):
        """
        Set IRQ Pin Direction
        :param direction: IRQ Direction, input=1, output=0
        :param irq_field: Name of the IRQ pin
        """
        self.python_helper.fpga.writeField(irq_field, direction)

    def get_irq_state(self, irq_field='DEV_PDM5_CLK_VIS'):
        """
        Read IRQ Pin
        :param irq_field: Name of the IRQ pin
        :return: IRQ state(high/low)
        """
        self.log.debug("Reading bit field %s to get IRQ state", irq_field)
        return int(self.python_helper.fpga.readField(irq_field))

    def monitor_gpio(self, gpio_num):
        """GPIO Monitoring
        :param gpio_num (int): GPIO pin
        :return: GPIO state(high/low)
        """
        self.gpio_num = gpio_num
        self.stop_gpio_polling = False
        thread = threading.Thread(target=self.start_monitoring_gpio)
        thread.start()
        thread.join()
        return self.gpio_state

    def stop_monitoring_gpio(self):
        """Stop GPIO Monitoring
        """
        self.stop_gpio_polling = True

    def start_monitoring_gpio(self):
        """Start GPIO Monitoring
        """
        self.gpio_state = self.get_gpio_state(self.gpio_num)
        while self.gpio_state != GPIO_STATES.HIGH and not self.stop_gpio_polling:
            sleep(0.25)
            self.gpio_state = self.get_gpio_state(self.gpio_num)
            if self.gpio_state == GPIO_STATES.HIGH:
                self.stop_monitoring_gpio()


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support


        class ScsLinkApiCli(ScsLinkApi, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self, *args, **kwargs):
                ScsLinkApi.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ScsLinkApi)


        RUN = ScsLinkApiCli()
    else:
        from unified_modules.test_support.testresults import TestResults


        class ScsLinkApiUnitTest(ScsLinkApi):
            TARGET_SYSTEM_NAME = "CS42L75_Simulated_System"
            TARGET_DEVICE_NAME = "CS42L75"
            TARGET_SYSTEM_FILE = "cdb42l75.xml"

            def __init__(self, scs_link_path):
                self.results = TestResults()
                self.log = logging.getLogger('ScsLinkApiUnitTest')
                self.studiolink = StudioLink(scs_link_path)
                self.list_of_discovered_systems = []
                self.device_list = []
                self.registers_and_address = []

            def test_scs_link_api(self):
                self.results.set_test_title('test_scs_link_api')
                self.log = self.results.log
                self.start_link()
                self.discover_sys()
                self.add_system_manually(self.TARGET_SYSTEM_NAME, self.TARGET_SYSTEM_FILE)
                self.connect_to_system_and_device(self.TARGET_SYSTEM_NAME,
                                                  self.TARGET_DEVICE_NAME)
                reg_value = self.read_register_value_by_name('Device ID A and B')
                self.results.assert_equal(int(reg_value),
                                          66,
                                          "Expected to be equal")
                self.stop_link()
                self.results.report_result_to_tf()

            def test_gpio(self):
                # TODO: GPIO Unit test implementation
                pass

        test_scs_link = ScsLinkApiUnitTest('C:/Program Files/Cirrus Logic/'
                                           'SoundClearStudio_1.4/link/bin/')
        test_scs_link.test_scs_link_api()
