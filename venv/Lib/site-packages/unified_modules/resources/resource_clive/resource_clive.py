"""
@brief
A resource library to wrap basic functionality around the Validation CLIVE tool.

@Description
This resource library provide a simplified wrapper for basic features of CLIVE

Supported Features:
- Launching CLIVE with username, project, and hardware configuration
- Shutting down CLIVE properly

Supported Metrics:
- Username
- Project
- Hardware configuration

@b Usage
@code
resource = ResourceCLIVE()
@endcode

"""

import sys
import os
import subprocess
from unified_modules.resources.resource_teststand.resource_teststand import ResourceTestStand


try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

class ResourceCLIVEError(Exception):
    """Define ResourceCLIVEError Exception type"""
    pass

class ResourceCLIVE(object):

    def __init__(self):
        current_path = os.path.realpath(__file__)
        current_path = os.path.dirname(current_path)

        self.RUN_PATH = '%s\\utility\\launch_clive.seq' % (current_path)
        # self.EXIT_PATH = '%s\\utility\\exit_clive.seq' % (current_path)
        self.log = logging.getLogger(ResourceCLIVE.__name__)
        self.RUN_CLIVE_PATH = '%s\\utility\\run_clive.vi' % (current_path)
        self.RUN_CLIVE_STATUS_PATH = '%s\\utility\\run_clive_status.txt' % (current_path)
        self.EXIT_CLIVE_PATH = '%s\\utility\\exit_clive.vi' % (current_path)
        self.EXIT_CLIVE_STATUS_PATH = '%s\\utility\\exit_clive_status.txt' % (current_path)
        self.UTILITY_PATH = '%s\\utility' % (current_path)

    def configure(self, config):
        """ Configures the resource configuration attributes  """
        self.username = config.get('username')
        self.hw_config = config.get('hw_config')
        self.project = config.get('project')
        self.LV_PATH = config.get('lv_path')
        self.CACHE_GEN_PATH = config.get('cache_gen_path')

    def config_ts(self, config):
        self.ts_resource = ResourceTestStand()
        self.ts_resource.configure(config)

    def launch(self):
        # launch CLIVE though run_clive.vi, based on given project, configuration (username would be auto generated).
        # *NOTE: LabVIEW may have to be closed for this function to work
        self.log.info('Running Virtual Instrument "%s" to launch CLIVE' % (self.RUN_CLIVE_PATH))
        # Remove run-clive_status.txt if generated already
        if(os.path.isfile(self.RUN_CLIVE_STATUS_PATH)):
            os.remove(self.RUN_CLIVE_STATUS_PATH)
        command = 'LabVIEWCLI -LabVIEWPath "%s" -OperationName RunVI -VIPath "%s" "%s" "%s" "%s" "%s"' % (self.LV_PATH, self.RUN_CLIVE_PATH, self.project, "%username%", self.hw_config, self.UTILITY_PATH)
        self.log.info('Running LabVIEW command: ' + command)
        result_run_CLIVE = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        while(not os.path.isfile(self.RUN_CLIVE_STATUS_PATH)):
            pass
        # TODO: raise timeout error if time takes too long, or LabVIEW error if run_clive_status.txt contains "1" (error) and not "0" (pass)

    def initialize(self):
        self.log.info('Running TestStand to initialize CLIVE......')
        results = self.ts_resource.run_test_seq(self.RUN_PATH)
        return (len(results.issues) == 0)

    def shutdown_power_supply(self, power_supply, address):
        if power_supply == 'E3631A':
            vi_path = "%s\\shutdownE3631A.vi" % (self.UTILITY_PATH)
            self.log.info('Shutting down E3631A...')
            command = 'LabVIEWCLI -LabVIEWPath "%s" -OperationName RunVI -VIPath "%s" "%s"' % (self.LV_PATH, vi_path, address)
            self.log.info('Running LabVIEW command: ' + command)
            result = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    def gen_reg_cache(self, component, version, dut_path='', fpga_path=''):
        """
        Runs the CLIVE cache generator

        @param instruction_file: [str] The full path to the instruction file
        """
        instruction_file = 'C:\\temp\\cache_gen_instruction_tmp.ini'
        self.__gen_cache_ini(component, version, dut_path=dut_path, fpga_path=fpga_path)
        command = 'LabVIEWCLI -LabVIEWPath "%s" -OperationName RunVI -VIPath "%s" "%s"' % (self.LV_PATH, self.CACHE_GEN_PATH, instruction_file)
        process = subprocess.Popen(command, stdout = subprocess.PIPE)
        stdout, stderr = process.communicate()
        self.log.info(stdout)
        os.remove(instruction_file)

    def __gen_cache_ini(self, component, version, dut_path='', fpga_path=''):
        """ Generates a temporary instruction file for the cache generator """
        instruction_file = open('c:\\temp\\cache_gen_instruction_tmp.ini', 'w')
        instruction_file.write('[Project Info]\n')
        instruction_file.write('Project Name = "%s"\n' % (self.project))
        instruction_file.write('Proj DUT Path = "%s"\n' % (dut_path))
        instruction_file.write('Proj FPGA Path = "%s"\n\n' % (fpga_path))
        instruction_file.write('[Single]\n')
        instruction_file.write('Components.<size(s)> = "1"\n')
        instruction_file.write('Components 0.Component Name = "%s"\n' % (component))
        instruction_file.write('Components 0.File Version to Regenerate The Cache = "%s"\n\n' % (version))
        instruction_file.write('[Composite]\n')
        instruction_file.write('Components.<size(s)> = "0"\n')
        instruction_file.close()

    def exit(self):
        # Exit CLIVE though exit_clive.vi, similar to self.launch().
        self.log.info('Using Virtual Instrument "%s" to exit CLIVE' % (self.EXIT_CLIVE_PATH))
        if(os.path.isfile(self.EXIT_CLIVE_STATUS_PATH)):
            os.remove(self.EXIT_CLIVE_STATUS_PATH)
        command = 'LabVIEWCLI -LabVIEWPath "%s" -OperationName RunVI -VIPath "%s" "%s"' % (self.LV_PATH, self.EXIT_CLIVE_PATH, self.UTILITY_PATH)
        self.log.info('Running LabVIEW command: ' + command)
        result_exit_CLIVE = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        self.log.info('Waiting for CLIVE to terminate......')
        while(not os.path.isfile(self.EXIT_CLIVE_STATUS_PATH)):
            pass

        return True

if __name__ == "__main__":
    from unified_modules.test_support.testbaseclass import BaseTest
    from unified_modules.test_support.testbaseclass import BaseTest
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceCLIVECli(ResourceCLIVE, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self, *args, **kwargs):
                ResourceCLIVE.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceCLIVE)

        RUN = ResourceCLIVECli()
    else:

        class ResourceCLIVEUnittest(BaseTest):
            def __init__(self, result):
                super(ResourceCLIVEUnittest, self).__init__(result)
                self.res_clive = None

            def setup(self):
                ts_config = {   'entry_point': "Single Pass",
                                'quit': False,
                                'exit_on_fail': False,
                                'use_existing': True,
                                'seq_root': '',
                                'cfg_root': "C:\\ProgramData\\National Instruments\\TestStand 2019 (64-bit)\\Cfg"
                            }
                self.res_clive = ResourceCLIVE()
                self.res_clive.config_ts(ts_config)
                # Configure CLIVE
                config  =   {   'username' : 'svc_lynott_val',
                                'project' : 'Lynott',
                                'hw_config' : 'Emulation'
                            }
                self.res_clive.configure(config)

            def initiate(self):
                #success = self.res_clive.exit()
                #self.result.assert_true(success, 'First Exit')
                #success = self.res_clive.exit()
                #self.result.assert_true(success, 'Second Exit')

                # Run launch and exit twice, it should be able to handle multiple calls
                # TO-DO: After resource_teststand supports custom command lines, pass in
                #        the username, project, and hw config parameters into launch()
                success = self.res_clive.launch()
                self.result.assert_true(success, 'First Launch')
                success = self.res_clive.launch()
                self.result.assert_true(success, 'Second Launch')

                # Only do one exit. If exit is called and CLIVE isn't open
                success = self.res_clive.exit()
                self.result.assert_true(success, 'First Exit')
                success = self.res_clive.exit()
                self.result.assert_true(success, 'Second Exit')

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceCLIVEUnittest(result=RESULTS)
        TEST.run()
