#!/usr/bin/env python
"""
@brief
A resource library to interact with NIDAQmx ANSI C driver.

@Description:
Features supported:
- Read data from data acquisition hardware.
@b Usage
@code
nidataaquisition = ResourceNIDataAquisition()
@endcode
"""
from pylab import *
import numpy as np
import nidaqmx
from nidaqmx.stream_readers import AnalogMultiChannelReader
from nidaqmx.stream_writers import AnalogMultiChannelWriter
from nidaqmx.constants import VoltageUnits, TerminalConfiguration, Edge, AcquisitionType, CurrentShuntResistorLocation

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class NIDataAquisitionError(Exception):
    """Define NIDataAquisitionError Exception type"""
    pass


class ResourceNIDataAquisition(object):
    """
     A resource library to interact with NIDaq.
    """

    def __init__(self):
        self.task = nidaqmx.Task()
        self.log = logging.getLogger(ResourceNIDataAquisition.__name__)
        self.physical_channel = None
        self.name_to_assign_to_channel = None
        self.terminal_config = TerminalConfiguration.DEFAULT
        self.min_val = None
        self.max_val = None
        self.units = VoltageUnits.VOLTS
        self.custom_scale_name = None
        self.sample_rate = None
        self.source = None
        self.active_edge = Edge.RISING
        self.sample_mode = AcquisitionType.FINITE
        self.no_channels_to_capture = None
        self.shunt_resistor_loc = CurrentShuntResistorLocation.LET_DRIVER_CHOOSE
        self.external_shunt_resistor_val = None

    def set_config_details(self, config):
        self.physical_channel = config.get('physical_channel')
        self.name_to_assign_to_channel = config.get('name_to_assign_to_channel')
        self.min_val = config.get('min_val')
        self.max_val = config.get('max_val')
        self.custom_scale_name = config.get('custom_scale_name')
        self.sample_rate = config.get('sample_rate')
        self.source = config.get('source')
        self.no_channels_to_capture = config.get('no_channels_to_capture')
        self.external_shunt_resistor_val = config.get('external_shunt_resistor_val')

    def read_data(self, t_seconds):
        """
        Reads one or more floating-point samples from a single analog input channel in a task.
        @param t_seconds: Duration for reading data in sec
        @return: [array] array of samples
        """
        stream_in = AnalogMultiChannelReader(self.task.in_stream)
        samples_per_chan = self.sample_rate * t_seconds
        buffer_size = samples_per_chan
        data = np.zeros((self.no_channels_to_capture, buffer_size), dtype=np.float64)
        stream_in.read_many_sample(data, number_of_samples_per_channel=-1, timeout=t_seconds)
        return data

    def write_data(self, data, t_seconds):
        """
        Writes one or more floating-point samples to a single analog output channel in a task
        @param data: Array of samples
        @param t_seconds: Duration for writing data in sec
        """
        stream_out = AnalogMultiChannelWriter(self.task.out_stream)
        stream_out.write_many_sample(data, timeout=t_seconds)

    def create_channel_to_measure_response(self, response='voltage'):
        """
        Creates channel(s) to measure voltage. If the measurement requires the use of internal excitation or you need
        excitation to scale the voltage, use the AI Custom Voltage with Excitation instance of this function.
        @param response: Set the response to measure the samples
        """
        if response == 'voltage':
            self.task.ai_channels.add_ai_voltage_chan(self.physical_channel, self.name_to_assign_to_channel,
                                                      self.terminal_config, self.min_val, self.max_val,
                                                      self.units, self.custom_scale_name)
        elif response == 'current':
            self.task.ai_channels.add_ai_current_chan(self.physical_channel, self.name_to_assign_to_channel,
                                                      self.terminal_config, self.min_val, self.max_val, self.units,
                                                      self.shunt_resistor_loc, self.external_shunt_resistor_val,
                                                      self.custom_scale_name)
        else:
            self.log.info("No response is selected")

    def set_sample_clock(self, t_seconds):
        """
        Sets the source of the Sample Clock, the rate of the Sample Clock, and the number of samples to acquire or
        generate.
        @param t_seconds: Duration of the measuring period
        """
        self.task.timing.cfg_samp_clk_timing(self.sample_rate, self.source, self.active_edge, self.sample_mode,
                                             samps_per_chan=self.sample_rate * t_seconds)

    def start_task(self):
        """
        Transitions the task to the running state to begin the measurement or generation. Using this method is required
        for some applications and is optional for others.
        """
        self.task.start()

    def stop_task(self):
        """
        Stops the task and returns it to the state the task was in before the DAQmx Start Task method ran.
        """
        self.task.stop()

    def close_task(self):
        """
        Clears the task.
        """
        self.task.close()


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support


        class ResourceCirrusLinkCli(ResourceNIDataAquisition, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self, *args, **kwargs):
                ResourceNIDataAquisition.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceNIDataAquisition)


        RUN = ResourceNIDataAquisition()
    else:
        # Unit test works only with real hardware
        # Replace the ip address with Audio hub under test Ip address
        # Open SoundClearStudio IDE and hover over the system to get the IP address
        class ResourceNIDataAquisitionUnittest(ResourceNIDataAquisition):
            def __init__(self):
                # Audio hub IP
                self.config = {'physical_channel': 'Dev2/ai1:2',
                               'name_to_assign_to_channel': 'generic_channel',
                               'min_val': -10,
                               'max_val': 10,
                               'custom_scale_name': None,
                               'sample_rate': 48000,
                               'source': 'OnboardClock',
                               'no_channels_to_capture': 2,
                               'external_shunt_resistor_val': None}
                super(ResourceNIDataAquisitionUnittest, self).__init__()

            def test_data_acq(self):
                self.set_config_details(self.config)
                self.read_data(10)


        resource_data_acq_test_test = ResourceNIDataAquisitionUnittest()
        resource_data_acq_test_test.test_data_acq()
