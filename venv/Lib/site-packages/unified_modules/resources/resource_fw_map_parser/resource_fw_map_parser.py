#!/usr/bin/env python
"""
@brief
Resource for firmware proect map parsing

@Description:
This resource library provides methods to parse firmware project map file
"""

import sys
import re
import os

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class ResourceFirmwareMapParserException(Exception):
    """
    Exception class if requested element is not found in the Firmware map file
    """
    def __init__(self, message):
        super(ResourceFirmwareMapParserException, self).__init__(message)


class ResourceFirmwareMapParser(object):

    def __init__(self):
        self.log = logging.getLogger(ResourceFirmwareMapParser.__name__)
        self.map_filename = ''
        self.map = dict()
        self._file_lines = list()
        self._current_line = 0
        self._variable_start_line_index = None

    def load_map(self, map_filename, start_signature='BuildAttributes'):
        """
        To load the map file and populate the data structure
        :param map_filename: Path of project map file
        :param start_signature: Start signature string
        """
        if os.path.exists(map_filename):
            self.map_filename = map_filename
            self._load_file_contents()
            self._search_map_start(start_signature)
            self._load_variables_into_map()
        else:
            raise ResourceFirmwareMapParserException("File path: %s doesn't exists" % map_filename)

    def _load_file_contents(self):
        """
        Load map_filename and read text lines into attribute, trim any whitespaces
        """
        with open(self.map_filename, 'rb') as map_file:
            for line_index, line in enumerate(map_file):
                # read only non-empty lines, strip white spaces
                if not re.match(r'^\s*$', line):
                    line_text = line.strip()
                    self._file_lines.append(line_text)

    def _search_map_start(self, start_signature):
        """
        Search the firmware map file lines until the line starting with search key is reached
        """
        for line_index, line in enumerate(self._file_lines):
            search_begin_pattern = re.compile(r"\b" + start_signature + r"\$\$(.*)")
            search_begin_obj = search_begin_pattern.search(line)
            if search_begin_obj is not None:
                # once the start_signature is found, skip to the next line, which is the start of the variable list
                self._variable_start_line_index = line_index + 1
                break

    def _load_variables_into_map(self):
        """
        Read the map file lines starting from _current_line, each line is a variable.
        """
        # This regex is for any alphanumeric string (variable name), followed by whitespace,
        # followed by another alphanumeric string (variable address), then more whitespace
        variables_regex = r"([a-zA-Z0-9\._$]+)\s+([0-9a-zA-Z_.]+)\s+"
        variables_pattern = re.compile(variables_regex)

        # Stop when the first sequence of '===' is reached.
        search_stop_pattern = re.compile(r"===+")

        for line_index, line_text in enumerate(self._file_lines):
            # Fast forward until variable list start
            if line_index >= self._variable_start_line_index:
                # break the loop if stop pattern is found
                stop_pattern_obj = search_stop_pattern.search(line_text)
                if stop_pattern_obj is not None:
                    break
                else:
                    variables_obj = variables_pattern.search(line_text)
                    if variables_obj is not None:
                        variable_name = variables_obj.group(1)
                        address_string = variables_obj.group(2)
                        if address_string[0:2] == '0x':
                            self.map[variable_name] = int(address_string, 0)


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceFirmwareMapParserCli(ResourceFirmwareMapParser, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceFirmwareMapParser.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceFirmwareMapParser)

        RUN = ResourceFirmwareMapParserCli()
