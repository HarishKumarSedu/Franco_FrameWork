#!/usr/bin/env python
"""
Resource library for analysing audio wav files.
Refer to https://gist.github.com/endolith/246092
"""
from __future__ import division
import os
import sys
import subprocess
import copy
from numpy import argmax, sqrt, mean, absolute, arange, log10
import numpy as np
from numpy.core import (amax as npc_amax, absolute as npc_absolute)
from collections import namedtuple
from scipy.signal import hilbert
import matplotlib.pyplot as plt
import math

from .wave_performance import get_sample_automatically, calc_thdn

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

try:
    import soundfile as sf
except ImportError:
    from scikits.audiolab import Sndfile

measure = namedtuple('measure', 'THD THDN')
AUDIO_METRICS = measure('THD', 'THDN')


class ResourceAudioAnalysisError(Exception):
    """Exception class for ResourceAudioAnalysis"""
    pass


class AudioMeasurements:
    """
    This class forms the data structure to store audio measurement attributes.
    """
    def __init__(self, rms_level=None, peak_amp=None, dc_offset=None, dominant_frequency=None, thdn_db=None):
        setattr(self, 'rms_level', rms_level)
        setattr(self, 'peak_amplitude', peak_amp)
        setattr(self, 'dc_offset', dc_offset)
        setattr(self, 'dominant_frequency', dominant_frequency)
        setattr(self, 'thdn_db', thdn_db)


class ResourceAudioAnalysis(object):
    """Utility for generating wave files on the test head"""
    def __init__(self):
        self.log = logging.getLogger(self.__class__.__name__)
        self.filename = None
        self.signal = None
        self.signal_thdn = None
        self.fs = None
        self.audio_measurement = AudioMeasurements()
        self.multi_ch_metrics_dict = {}
        self.reset_channel_attributes()
        self.plot_data = False
        self.plot_filename = None
        self.wave_scale = (12.3 / (math.pow(2, 15) - 1))

    def set_plot_data(self, plot_filename, plot_data=True):
        """TODO: Enable plot_data figure to be saved for each channel"""
        self.plot_data = plot_data
        self.plot_filename = plot_filename

    def reset_channel_attributes(self):
        self.rms_level = None
        self.dc_offset = None
        self.peak_index = None
        self.peak_freq = None
        self.peak_amplitude = None
        self.ch_no = 1

    def ms_to_samples(self, x_ms):
        """Convert ms to samples
        @param x_ms - milliseconds into wav"""
        samples = x_ms
        if x_ms is not None:
            samples = int(self.fs * (float(x_ms) / 1000))
        return samples

    def get_rms_level(self, signal):
        """
        Return the root mean square of all the elements of *signal*, flattened out.
        """
        return np.sqrt(np.mean(npc_absolute(signal)**2))

    def get_dc_offset(self, signal):
        """
        Return the root mean square of all the elements of *signal*, flattened out.
        """
        return float(mean(signal))

    def get_peak_frequency(self, signal):
        """Get peak frequency of the input signal"""

        # fft is calculated with  2^N, where N is the number of points. Set N to 16 points.
        # each frequency bin is separated by fs/N
        fft_slice_index = 2 ** 16
        fft_signal = np.fft.rfft(signal[0:fft_slice_index])
        self.peak_index = argmax(abs(fft_signal[0:fft_signal.size]))
        self.peak_freq = self.peak_index * (self.fs / float(fft_slice_index))
        return self.peak_freq

    def get_peak_amplitude(self, signal):
        self.peak_amplitude = npc_amax(npc_absolute(signal))
        return self.peak_amplitude

    def get_thdn(self, signal_thdn):
        thdn_db, _ = calc_thdn(signal_thdn, self.fs, window='blackmann',
                               plot_data=self.plot_data, use_name='Auto, Blackmann')
        self.log.info("THDN value in dB: %.2f%%", thdn_db)
        return thdn_db

    def analyse_each_channel(self, signal, ch_no=1):
        """
        Calculate all the audio measurements for this channel.
        """
        self.reset_channel_attributes()
        self.ch_no = ch_no
        self.audio_measurement = AudioMeasurements()
        # Trim Leading and Trailing zeros
        trimmed_signal = np.trim_zeros(signal)

        # True RMS of the signal is calculated after removing leading/trailing zeros
        self.audio_measurement.rms_level = self.get_rms_level(trimmed_signal)
        self.log.info("Channel %s: RMS Level:%s", self.ch_no, self.audio_measurement.rms_level)

        # peak amplitude
        self.audio_measurement.peak_amplitude = self.get_peak_amplitude(trimmed_signal)
        self.log.info("Channel %s: Peak amplitude:%s", self.ch_no, self.audio_measurement.peak_amplitude)

        _, signal_thdn, _ = get_sample_automatically(signal, self.fs, 0.250, 2000, scale_data=self.wave_scale)

        # DC offset of the signal
        self.audio_measurement.dc_offset = self.get_dc_offset(signal_thdn)
        self.log.info("Channel %s: DC Offset: %s", self.ch_no, self.audio_measurement.dc_offset)

        self.audio_measurement.thdn_db,\
        self.audio_measurement.dominant_frequency = calc_thdn(signal_thdn,
                                                              self.fs,
                                                              window='blackmann',
                                                              plot_data=self.plot_data,
                                                              use_name='Auto, Blackmann')
        self.log.info("Channel %s: Peak frequency:%s", self.ch_no, self.audio_measurement.dominant_frequency)
        self.log.info("Channel %s: THDN value in dB: %s", self.ch_no, self.audio_measurement.thdn_db)

    def read_wav_file(self, filename):
        """
        Load a wave file and return the signal, sample rate and number of channels.
        Can be any format that libsndfile supports, like .wav, .flac, etc.
        """
        try:
            self.wave_file = sf.SoundFile(filename)
            self.signal = self.wave_file.read()
        except ImportError:
            self.wave_file = Sndfile(filename, 'r')
            self.signal = self.wave_file.read_frames(self.wave_file.nframes)
        self.channels = self.wave_file.channels
        self.fs = self.wave_file.samplerate

    def analyse_channels(self, filename):
        """
        Given a filename, run the given analyser function on each channel of the
        file and get all the supported metrics.
        """
        self.filename = filename
        self.multi_ch_metrics_dict = {}
        self.read_wav_file(self.filename)

        self.log.info("Analysing file %s", self.filename)
        if self.channels == 1:
            self.analyse_each_channel(self.signal, ch_no=self.channels)
            self.multi_ch_metrics_dict.update({"ch1": self.audio_measurement.__dict__})
        elif self.channels == 2:
            # Stereo
            if np.array_equal(self.signal[:, 0], self.signal[:, 1]):
                self.log.info("-- Left and Right channels are identical --")
                self.analyse_each_channel(self.signal[:, 0], ch_no=1)
                self.multi_ch_metrics_dict.update({"ch1": self.audio_measurement.__dict__,
                                                   "ch2": self.audio_measurement.__dict__})
            else:
                self.log.info("-- Left channel --")
                self.analyse_each_channel(self.signal[:, 0], ch_no=1)
                self.multi_ch_metrics_dict.update({"ch1": self.audio_measurement.__dict__})
                self.log.info("-- Right channel --")
                self.analyse_each_channel(self.signal[:, 1], ch_no=2)
                self.multi_ch_metrics_dict.update({"ch2": self.audio_measurement.__dict__})
        else:
            # Refer to https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.transpose.html
            # Multi-channel audio analysis
            for ch_no, channel_data in enumerate(self.signal.T):
                self.log.info("-- Channel %d --", ch_no + 1)
                self.analyse_each_channel(channel_data, ch_no=ch_no)
                self.multi_ch_metrics_dict.update({"ch%s" % (ch_no + 1): self.audio_measurement.__dict__})
        return copy.deepcopy(self.multi_ch_metrics_dict)

    def remove_lead_trail_silence(self, wav_file, sox_tmp_path="sox_tmp",
                                  file_name_without_silence="trimmed_silence.wav"):
        """
        Removes leading and trailing silence from given wav file.
        This generates an trimmed_silence.wav file in sox_tmp directory.
        This requires sox installed.

        @param [String] wav_file  name of the file in which silence has to be removed
        @return None
        """
        # The above-periods value is used to indicate if audio should be trimmed
        # at the beginning of the audio.
        # 0 - Doesn't remove the silence
        # 1 - Removes the silence
        above_period = 1
        # The above-periods value is used to indicate if audio should be trimmed
        # at the end of the audio.
        # 0 - Doesn't remove the silence
        # 1 - Removes the silence
        below_period = 1
        # Duration indications the amount of time that non-silence must be detected
        # before it stops trimming audio. By increasing the duration, burst of
        # noise can be treated as silence and trimmed off.
        duration = 0.1

        silence_thrshold = -100
        if not os.path.exists(sox_tmp_path):
            os.makedirs(sox_tmp_path)

        # Remove leading and trailing silence from output file
        # For the below command to work you need to install sox
        command = "sox.exe %s %s/%s silence %s %s %sd reverse silence %s %s %sd reverse"\
                  %(wav_file, sox_tmp_path, file_name_without_silence, above_period, duration,
                    silence_thrshold, below_period, duration, silence_thrshold)
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderror = process.communicate()
        if stderror:
            raise ResourceAudioAnalysisError("Failed to remove the silence: %s" % stderror)
        else:
            self.log.info("Silence removed successfully \n %s" % stdout)

    def is_bit_perfect(self, input_file, output_file, silence_remove=True):
        """
        Compare the output with input or reference for bit-perfect.
        This comparison is done with excluding the ouput header.

        @param [String] input_file  The name of the input or reference file
        @param [String] output_file  The name of the output file
        @param [boolean] silence_remove true removes silence else doesn't.
        @return true if output is bit-perfect with input else false.
        """
        bit_perfect_flag = False
        wav_header_length = 44
        if silence_remove:
            self.remove_lead_trail_silence(output_file, file_name_without_silence='output_after_removing_silence.wav')
            output_file = os.path.join('sox_tmp', 'output_after_removing_silence.wav')
            self.remove_lead_trail_silence(input_file, file_name_without_silence="input_after_removing_silence.wav")
            input_file = os.path.join('sox_tmp', 'input_after_removing_silence.wav')

        with open(output_file) as ofh:
            ofh.seek(wav_header_length)
            op_data = ofh.read()
        with open(input_file) as ifh:
            ifh.seek(wav_header_length)
            ip_data = ifh.read()
        if op_data == ip_data:
            bit_perfect_flag = True
            self.log.info("Output is bit-perfect with given reference")
        else:
            self.log.info("Output is NOT bit-perfect with given reference")

        return bit_perfect_flag

    def duration(self, signal):
        """TODO
        """
        analytic_signal = hilbert(signal)
        amplitude_envelope = np.abs(analytic_signal)

        fs = 48000
        duration = 2
        time = np.arange(96000) / fs

        print(len(amplitude_envelope))
        dur = []

        for amp in range(len(amplitude_envelope)):
            if amplitude_envelope[amp] > 0.1:
                dur.append(1)
            else:
                dur.append(0)

        print(len(dur))

        fig = plt.figure()
        plt.plot(time, signal, label='signal')
        plt.plot(time, amplitude_envelope, label='envelope')
        plt.plot(time, dur, label='dur')
        plt.show()

        np.savetxt('test.txt', dur, delimiter=',')

        count_zeros_ones = []
        count = 0
        index = 1
        while index < dur:
            if dur[index - 1] == dur[index]:
                count += 1
            else:
                count_zeros_ones.append(count)
                count = 0

        print(count_zeros_ones)


if __name__ == '__main__':
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support


        class ResourceAudioAnalysisCli(ResourceAudioAnalysis, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self, *args, **kwargs):
                ResourceAudioAnalysis.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceAudioAnalysis)

        RUN = ResourceAudioAnalysisCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest


        class ResourceAudioAnalysisUnitTests(BaseTest):
            def __init__(self, result):
                super(ResourceAudioAnalysisUnitTests, self).__init__(result)
                self.audio_analysis = ResourceAudioAnalysis()
                self.result.set_test_title('Audio Analysis Unit Tests')

            def complete(self):
                gen_filename = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'generated_4ch_diff.wav')

                measurements = self.audio_analysis.analyse_channels(gen_filename)
                expected_dict = {'ch1': {'rms_level': 0.7, 'dc_offset': 3.6e-8, 'peak_amplitude': 1.0,
                                         'dominant_frequency': 500, 'thdn_db': -96},
                                 'ch2': {'rms_level': 0.7, 'dc_offset': 7.2e-8, 'peak_amplitude': 1.0,
                                         'dominant_frequency': 1000, 'thdn_db': -96},
                                 'ch3': {'rms_level': 0.7, 'dc_offset': 0.0, 'peak_amplitude': 1.0,
                                         'dominant_frequency': 1500, 'thdn_db': -96},
                                 'ch4': {'rms_level': 0.7, 'dc_offset': 0.0, 'peak_amplitude': 1.0,
                                         'dominant_frequency': 2000, 'thdn_db': -96}}
                tolerance_perc = 10
                for ch in measurements:
                    for tag in measurements[ch]:
                        self.result.assert_within_percentage(measurements[ch][tag], expected_dict[ch][tag],
                                                             tolerance_perc,
                                                             'Check %s measurement against expected value' % tag)

            def teardown(self):
                self.result.report_result_to_tf()

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceAudioAnalysisUnitTests(result=RESULTS)
        TEST.run()