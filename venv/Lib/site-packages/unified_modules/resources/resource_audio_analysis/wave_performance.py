# wave perfomance and utilities
# 1/25/2019 PM
# Billy Eno

from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
import math
from scipy.io import wavfile
from scipy.signal import blackmanharris, hilbert, hamming, hanning
import soundfile as sf


def plot_a_wave(wave_data, use_name=''):
    time = np.linspace(0, wave_data.size, num=wave_data.size)
    fig, axs = plt.subplots(1, 1)
    fig.suptitle(use_name)
    axs.plot(time, wave_data)
    plt.show()


def find_closest_odd(aval):
    out_value = int(np.round(aval, 0))
    if (out_value % 2) == 0:
        if out_value > aval:
            out_value -= 1
        else:
            out_value += 1
            
    return out_value


def calc_closest_coherent_freq(tgt_freq, fs, sample_size):
    num_periods = find_closest_odd((tgt_freq/fs) * sample_size)
    return (num_periods/sample_size) * fs


def gen_sine_wave(freq, fs, sample_size, full_scale=float(1), dbgain=float(0)):
    t = (sample_size-1)/fs
    scale = (pow(10, dbgain/20)) * full_scale
    out_wave = np.linspace(0, t, sample_size)
    out_wave = np.sin(2 * np.pi * freq * out_wave)
    out_wave = out_wave * scale
    return out_wave


def get_wav_file(filename):
    try:
        fs, ip_data = wavfile.read(filename)
    except ValueError:
        print('-- using soundfile.read instead of numpy.read -- ')
        ip_data, fs = sf.read(filename)

    return fs, ip_data


def find_peak_freq(wave_data, fs):
    spectrum = np.fft.rfft(wave_data * blackmanharris(wave_data.size))
    spectrum = (np.abs(spectrum))
    # plot_a_wave(spectrum)
    peak_index = np.argmax(spectrum)
    peak_freq = (fs/2) * (peak_index/spectrum.size)
    return peak_freq


def get_sample_automatically(wave_data, fs, settle_time=.1, min_sample_size=2000, max_analysis_size=None, scale_data=None):

    # strip leading zeros
    # find frequency based on initial FFT
    # back out a sample size that should produce a reasonably coherent sample size

    wave_data = np.trim_zeros(wave_data)

    if max_analysis_size is None:
        # assume we don't want more than 10x the min_sample size to determine the frequency
        max_analysis_size = 10 * min_sample_size

    # pull off initial settle time
    settle_samples = int(settle_time/(1/float(fs)))
    if (settle_samples + max_analysis_size) > wave_data.size:
        raise Exception("settle time + max_analysis_size size * 10extends past the end of the waveform")

    wave_data = np.array(wave_data[settle_samples:settle_samples + 10 * min_sample_size])

    # plot_a_wave(wave_data, "Wave Data")

    fund_freq = find_peak_freq(wave_data, fs)
    fund_samples = fs/fund_freq
    use_sample_size = int(math.ceil(min_sample_size/fund_samples) * fund_samples)

    if use_sample_size > wave_data.size:
        raise Exception("calculated sample time extends past the end of the waveform")

    output_data = wave_data[0:use_sample_size-1]
    if scale_data is not None:
        output_data = np.multiply(output_data, scale_data)
    return fs, output_data, fund_freq


def get_wav_sample(filename, start_sample, sample_size, scale_data=None):

    fs, ip_data = get_wav_file(filename)

    output_data = np.array(ip_data[start_sample:(start_sample+sample_size)])
    if scale_data is not None:
        output_data = np.multiply(output_data, scale_data)
        
    return fs, output_data


def print_fft_info(total_pwr, fund_pwr, noise_and_harm_pwr, noise_pwr, noise_floor_pwr, harm_pwr, fund_freq):
    print('           Frequency:  %.2f Hz' % fund_freq)
    print()
    print('           Total Pwr: %04.03e' % total_pwr)
    print('            Fund Pwr: %04.03e' % fund_pwr)
    print('Noise & Harmonic Pwr: %04.03e' % noise_and_harm_pwr)
    print('           Noise Pwr: %04.03e' % noise_pwr)
    print('     Noise Floor Pwr: %04.03e' % noise_floor_pwr)
    print('        Harmonic Pwr: %04.03e' % harm_pwr)
    print()
    print('           Total Pwr: %.2f dB' % (np.log10(total_pwr)*10))
    print('            Fund Pwr: %.2f dB' % (np.log10(fund_pwr)*10))
    print('Noise & Harmonic Pwr: %.2f dB' % (np.log10(noise_and_harm_pwr) * 10))
    print('           Noise Pwr: %.2f dB' % (np.log10(noise_pwr)*10))
    print('     Noise Floor Pwr: %.2f dB' % (np.log10(noise_floor_pwr) * 10))
    print('        Harmonic Pwr: %.2f dB' % (np.log10(harm_pwr) * 10))


def fft_info(spectrum, fs, fund_freq=None, bin_spread=1, bw_low=20, bw_high=20000, num_harmonics=0, verbose=False):
    """
    :param spectrum: spectrum of signal of interest
    :param fs: sample frequency
    :param fund_freq: fundamental frequency, if None, fft_info will attempt to find the frequency
    :param bin_spread: bin spread associated with the window (if any) applied to waveform before fft
    :param bw_low: low bandwidth
    :param bw_high: high bandwidth
    :param num_harmonics: number of harmonics for use with calcluating harmonic power, if 0, this will be skipped
    :param verbose: print out debug information
    :return:    total_pwr           -- total power
                fund_pwr            -- power in the fundamental
                noise_and_harm_pwr  -- noise plus harmonic power
                noise_pwr           -- noise power
                noise_floor_pwr     -- noise floor power
                harm_pwr            -- power in the harmonics
                fund_freq           -- fundamental frequency (found or passed in)
    """
    spectrum = np.abs(spectrum)

    if fund_freq is None:
        if verbose:
            print(' searching for fundamental')
        fund_freq = (fs/2) * np.argmax(spectrum)/spectrum.size

    fund_bin = int(np.round(spectrum.size * (fund_freq/(fs/2)), 0))
    if verbose:
        print('fund_freq = ' + str(fund_freq))
    if verbose:
        print('fund_bin = ' + str(fund_bin))

    freq_step = (fs/2)/spectrum.size
    low_bin = int(np.round(bw_low/freq_step, 0))
    high_bin = int(np.round(bw_high/freq_step, 0))

    if (bin_spread < 1) or ((bin_spread % 2) != 1):
        raise Exception('bin_spread must be 1 or larger and odd')

    half_spread = int(np.round((bin_spread-1)/2, 0))

    if low_bin <= half_spread:
        # DC spreads out to the half_spread
        use_low_bin = half_spread + 1
        if (fund_bin - half_spread - use_low_bin) < 0:
            raise Exception('DC spreads into fundamental')
        else:
            # Calculate DC Replacement noise by averaging noise from UseLow_Bin to the Fundamental
            sampled_noise = np.sum(spectrum[use_low_bin: fund_bin - half_spread - 1])
            dc_replace_noise_pwr = (use_low_bin - low_bin) * (sampled_noise / (fund_bin - half_spread - use_low_bin))

    else:
        # Low_Bin is above the spread of the DC
        use_low_bin = low_bin
        dc_replace_noise_pwr = 0

    # Total Power - UseLow_Bin to High_Bin + DC Replacement Noise
    total_pwr = np.sum(spectrum[use_low_bin:high_bin]) + dc_replace_noise_pwr
    # Fundamental Power
    if half_spread == 0:
        fund_pwr = spectrum[fund_bin]
    else:
        fund_pwr = np.sum(spectrum[fund_bin - half_spread:fund_bin + half_spread])

    noise_and_harm_pwr = dc_replace_noise_pwr + np.sum(spectrum[use_low_bin: fund_bin - half_spread - 1])
    noise_and_harm_pwr += np.sum(spectrum[fund_bin + half_spread + 1: high_bin])

    # Calculate Harmonic Related Powers
    # Start the Harmonic related values with bad values.
    # If the harmonics are calculated, these will be overwritten

    harm_pwr = total_pwr
    replace_noise_pwr = total_pwr
    fundamental_replace_noise_pwr = total_pwr

    # if 0 specified, skip harmonic, noise and noise floor calculations, Bad values will be returned
    if num_harmonics > 0:
        # if the number of harmonic specified goes past the High_Bin return an error and the bad values will be used
        if fund_bin * (num_harmonics + 1) + half_spread > high_bin:
            raise Exception('number of harmonics goes past the high bin')
        else:
            # Fundamental replacement noise
            noise_sample_size = fund_bin - bin_spread
            # Noise between the Fundamental and 1st Harmonic, this also primes the noise calculations
            # during the harmonic noise replacemente
            last_noise = np.sum(spectrum[fund_bin + half_spread + 1: fund_bin * 2 - half_spread - 1])
            # Noise between Low_Bin and the fundamental
            sampled_noise = np.sum(spectrum[use_low_bin: fund_bin - half_spread]) + last_noise
            sampled_noise = sampled_noise / ((fund_bin - half_spread - use_low_bin) + noise_sample_size)
            fundamental_replace_noise_pwr = sampled_noise * bin_spread

            harm_pwr = 0
            replace_noise_pwr = 0

            for i in range(1, num_harmonics):
                harm_bin = fund_bin * (i+1)
                next_harm_bin = fund_bin * (i+2)
                harm_pwr += np.sum(spectrum[harm_bin - half_spread:harm_bin + half_spread])
                sampled_noise = np.sum(spectrum[harm_bin + half_spread + 1:next_harm_bin - half_spread - 1])
                replace_noise_pwr += bin_spread * ((sampled_noise + last_noise) / (bin_spread * 2))

    noise_pwr = noise_and_harm_pwr - harm_pwr + replace_noise_pwr
    noise_floor_pwr = noise_pwr + fundamental_replace_noise_pwr

    return total_pwr, fund_pwr, noise_and_harm_pwr, noise_pwr, noise_floor_pwr, harm_pwr, fund_freq


def calc_thdn(wave_data, fs, window='rectangular', return_in_db=True, plot_data=False, use_name=""):
    axs = ()
    time = ()
    fig = None
    if plot_data:
        time = np.linspace(0, wave_data.size / fs, num=wave_data.size)
        fig, axs = plt.subplots(3, 1)
        axs[0].set_title('signal')
        axs[0].plot(time, wave_data, label='signal')

    if window == 'blackmann':
        wave_data = wave_data * blackmanharris(wave_data.size)
        bin_spread = 9
    elif window == 'hanning':
        wave_data = wave_data * hanning(wave_data.size)
        bin_spread = 5
    elif window == 'hamming':
        wave_data = wave_data * hamming(wave_data.size)
        bin_spread = 7
    else:
        bin_spread = 1

    spectrum = np.fft.rfft(wave_data)
    spectrum = np.power(abs(spectrum), 2)

    if plot_data:
        axs[1].set_title('windowed')
        axs[1].plot(time, wave_data, label='signal')

        ybins = np.linspace(0, fs / 2, num=spectrum.size)
        # ybins = np.linspace(0, spectrum.size - 1, num=spectrum.size)  #bin
        axs[2].grid(True, 'both', 'both')
        axs[2].set_title('fft')
        axs[2].plot(ybins, np.multiply(np.log10(spectrum), 20), label='fft')

    (total_pwr, fund_pwr, noise_and_harm_pwr, noise_pwr, noise_floor_pwr, harm_pwr, fund_freq) = \
        fft_info(spectrum, fs, bin_spread=bin_spread, bw_low=20, bw_high=20000, num_harmonics=0, verbose=False)

    # print_fft_info(total_pwr, fund_pwr, noise_and_harm_pwr, noise_pwr, noise_floor_pwr, harm_pwr, fund_freq)

    thdn = noise_and_harm_pwr / fund_pwr
    if return_in_db:
        thdn = np.log10(thdn) * 10

    if plot_data:
        if return_in_db:
            fig.suptitle(use_name + '- %.2f dB' % thdn)
        else:
            fig.suptitle(use_name + '- %04.03e' % thdn)

        plt.show()
    return thdn, fund_freq

