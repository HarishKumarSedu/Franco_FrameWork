import os
import platform
import re
import time
import subprocess
from .ts_xml.ts_xml import ts_xml
import xml.etree.ElementTree as ET

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

class ResourceTestStandError(Exception):
    """Define ResourceTestStandError Exception type"""
    pass

class ResourceTestStand(object):
    """
        Resource wrapper for running test stand sequences
    """

    def __init__(self):
        self.entry_point = None
        self.quit = True
        self.exit_on_fail = False
        self.xml_result_path = None
        self.xmlns = '{http://www.ni.com/TestStand/19.0.0/PropertyObjectFile}'
        self.log = logging.getLogger(ResourceTestStand.__name__)

    def configure(self, config):
        """ Configures the resource configuration attributes  """
        self.entry_point = config['entry_point']
        self.quit = config['quit']
        self.exit_on_fail = config['exit_on_fail']
        self.use_existing = config['use_existing']
        self.seq_root = config['seq_root']
        self.cfg_root = config['cfg_root']
        self.xml_result_path = self.__get_result_path()

    def run_test_seq(self, seq_path, custom_cmd=''):
        """
        Launches TestStand and runs the specified test sequence file

        @param seq_path: [str] The full path to the sequence file to run
        @returns: [ts_xml] ts_xml object containing issue information
        """

        # Clean up any existing xml file
        # This is required because this function determines if the test sequence process is done by looking for an XML file
        if(os.path.isfile(self.xml_result_path)):
            os.remove(self.xml_result_path)

        # Build the command line string based on the configuration options
        command = 'SeqEdit /runEntryPoint "%s" "%s" %s' % (self.entry_point, seq_path, custom_cmd)
        if(self.quit):
            command += ' /quit'
        if(self.use_existing):
            command += ' /useExisting'

        self.log.info('Running command line: ' + command)

        # Launch TestStand sequence editor as a subprocess
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # Teststand will run in a background process since we have the "/useExisting" command line option set
        # When the test result xml file exists, the process is finished
        # TODO - Need to have a method for timing out and a watchdog to make sure the function continues if TestStand
        #        has an issue
        while(not os.path.isfile(self.xml_result_path)):
            pass

        ts_results = ts_xml(self.xml_result_path)

        return ts_results

    def __get_result_path(self):
        """
            Finds the ResultProcessing.cfg file for TestStand and extracts the path to the result xml
        """
        # Parse the configuration file for result processing
        cfg_file_path = '%s\\ModelPlugins\\ResultProcessing.cfg' % self.cfg_root
        tree = ET.parse(cfg_file_path)
        root = tree.getroot()

        # First search for the Obj node with these attributes.
        # This is done because multiple "ReportFilePath" nodes exist int he config xml and the one we care about
        # is under the node with these attributes
        attributes =    {   'typename':'NI_ModelPluginConfiguration',
                            'name':'<Default for Inline Processing>'
                        }
        config_node = self.__search4node(root, '%sObj' % self.xmlns, attributes)
        if(config_node != None):
            # Search for the ReportFilePath node under this config node and return the value (which is the path to the XML)
            path_node = self.__search4node(config_node, '%sReportFilePath' % self.xmlns)
            if(path_node != None):
                path_value = path_node.find('%svalue' % (self.xmlns))
                if(path_value != None):
                    return path_value.text
                else:
                    raise ResourceTestStandError('Result Processing configuration is missing the ReportFilePath value. Please ensure that a explicit report file path is defined')
            else:
                raise ResourceTestStandError('Result Processing configuration is missing the ReportFilePath value. Please ensure that a explicit report file path is defined')
        else:
            raise ResourceTestStandError('Could not find "Default for Inline Processing" configuration in the ResultProcessing.cfg file')


    def __search4node(self, root_node, tag, attributes = None):
        """
            Recursive function to traverse the nodes of the XML and find the node with the matching tag and attributes

            @param root_node: [ElementTree] The root XML node to start searching from
            @param tag: [str] The tag value of the node to search for
            @param attributes: [dict] Dictionary of attributes. Keys and element should be string values
        """

        for n in root_node:
            # Search through each node directly under root_node for the matching tag
            if(n.tag.strip() == tag):
                # If attribuates are defined, then they will be compared here
                # else we only care about the matching tag values
                if(attributes != None):
                    # If a key in the attributes dictionary is not found in the node attributes then no match
                    # Use a try except KeyError to catch this case
                    try:
                        # We only care that the defined attributes from the function parameters match the node attributes
                        # i.e. the attributes parameter can be a subset of the node attributes
                        match = True
                        for key in attributes.keys():
                            if(n.attrib[key] != attributes[key]):
                                match = False
                        if(match):
                            return n
                    except KeyError as e:
                        pass
                else:
                    return n
            else:
                # Search the nodes under the current node, this is the recursive call
                next_search_node = self.__search4node(n, tag, attributes)
                if(next_search_node != None):
                    return next_search_node

        # Return none if no nodes were found under the root node that match
        return None


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description='Run standalone tests for the ResourceTestStand class')
    parser.add_argument('--unittest', help='Flag to run the unit tests for this class', action='store_true')
    args = parser.parse_args()

    if(args.unittest):
        class ResourceTestStandUnittest(ResourceTestStand):
            def __init__(self):
                path = os.getcwd()
                self.config =    {   'entry_point': "Single Pass",
                                     'quit': False,
                                     'exit_on_fail': False,
                                     'use_existing': True,
                                     'seq_root': path,
                                     'cfg_root': "C:\\ProgramData\\National Instruments\\TestStand 2019 (64-bit)\\Cfg"
                                 }
                super(ResourceTestStandUnittest, self).__init__()

                self.seq_path = path + '\\teststand_seq_4_unittest.seq'

            def test_teststand(self):
                self.configure(self.config)
                self.run_test_seq(self.seq_path)
                # TO-DO: The process for creating custom command line arguments for a TestStand
                #        sequence has not been figured out yet. After it is figured out, need to
                #        add a test rung with custom command lines here

        resource_teststand_test = ResourceTestStandUnittest()
        resource_teststand_test.test_teststand()
