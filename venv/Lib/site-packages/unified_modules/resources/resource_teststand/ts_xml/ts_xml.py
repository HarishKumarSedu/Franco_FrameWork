import os
import sys
import xml.etree.ElementTree as ET

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

class issue(object):

    def __init__(self):
        self.call_stack = []

    def push_node(self, node):
        self.call_stack.append(node)

    def gen_report(self):
        report = ''
        for call in reversed(self.call_stack):
            report += call.attrib['name'] + '\n'

        return report

class error(issue):
    """ This represents an error """
    def __init__(self):
        super(error, self).__init__()


class failure(issue):

    def __init__(self):
        super(failure, self).__init__()


class ts_xml:

    def __init__(self, xml_path):
        self.log = logging.getLogger(ts_xml.__name__)
        self.tr_type = '{urn:IEEE-1636.1:2013:TestResults}'
        self.trc_type = '{urn:IEEE-1636.1:2013:TestResultsCollection}'
        self.issues = []
        self.__parse_xml(xml_path)

    def has_error(self):
        for my_issue in self.issues:
            if(type(my_issue) == type(error())):
                return True
        return False

    def gen_full_call_stack(self):
        call_stack = ''
        for my_issue in self.issues:
            call_stack += my_issue.gen_report()
        return call_stack

    def __parse_xml(self, xml_path):
        self.log.info("Parsing Teststand XML File")
        f = open(xml_path, 'r')
        tree = ET.parse(xml_path)
        root = tree.getroot()

        tr_label = '%sTestResults' % (self.trc_type)
        rs_label = '%sResultSet' % (self.tr_type)
        tr_node = root.find(tr_label).find(rs_label)
        self.issues = self.__traverse_nodes(tr_node)
        f.close()

    def __traverse_nodes(self, node):
        """
            Description:
            Recursive function that will traverse through the tree of XML subnodes that are under the
            node that is passed in as a parameter. Searches for any Outcome or SessionActionOutcome
            that has a value of Failed or Aborted. Any issues found will push the root node to its call
            stack

            Parameters:
            node -> root node to start the search from

            Returns:
            issues -> list of issue type objects
        """
        issues = []

        for n in node:
            # If the Outcome tag or SessionAction Outcome tag is found and it shows a fail or error
            # create an issue object and append to the issues list
            if(n.tag == '%sOutcome' % (self.tr_type) or n.tag == '%sActionOutcome' % (self.tr_type)):
                if(n.attrib['value'] == 'Failed'):
                    my_issue = failure()
                    issues.append(my_issue)
                elif(n.attrib['value'] == 'Aborted'):
                    my_issue = error()
                    issues.append(my_issue)

            # If it is not an Outcome type node, traverse any of the sub-nodes to continue searching
            else:
                # The issues list will be extended with any new outcomes found
                issues.extend(self.__traverse_nodes(n))

        # Go through any issues that are found and push the root node to create the call stack
        for i in issues:
            i.push_node(node)

        return issues
