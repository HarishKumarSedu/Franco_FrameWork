#!/usr/bin/env python
"""
@brief
Resource library for Command line interface

@Description:
This resource library provides method to run and get command output
- Execute command and return console output
- Execute command and return error output
"""
import subprocess
import sys
from unified_modules.test_support.testutils import ThreadWithReturnValue


try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class ResourceCliException(Exception):
    """Exception class for ResourceCli"""
    def __init__(self, message=None):
        super(ResourceCliException, self).__init__(message)


class ResourceCli(object):

    def __init__(self):
        """
        Create reference for logger
        """
        self.log = logging.getLogger(ResourceCli.__name__)

    @staticmethod
    def run_command(cmd, stdout=False, stderr=False):
        """
        This method runs command and returns console, error output based on flags.
        @param cmd A string, or a sequence of command line arguments
        @param stdout [bool] flag to return console_output
        @param stderr [bool] flag to return error output

        Usage:
        <Cli object>.run_command("example.bat", stdout=True, stderr=True)
        """
        console_output = []
        error_output = []
        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE, shell=True)
            console_output, error_output = process.communicate("")
            console_output = console_output.splitlines()
            console_output = [temp_var.rstrip() for temp_var in console_output]
            error_output = error_output.splitlines()
            error_output = [temp_var.rstrip() for temp_var in error_output]
            if stdout and stderr:
                return console_output, error_output
            elif stdout:
                return console_output
            elif stderr:
                return error_output
            else:
                return process.returncode
        except (OSError, subprocess.CalledProcessError) as err:
            raise ResourceCliException(err)

    def run_cmd_log_stdout(self, command):
        """
        Execute system command and log stdout and stderr to test log file
        @param command: [str] System command
        @return process stdout and process stderr
        """
        process = subprocess.Popen(command, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE, universal_newlines=True)
        stdout_th = ThreadWithReturnValue(target=self._log_stdout, args=[process])
        process_stdout = stdout_th.join()
        process_stderr = process.stderr.read()
        process.stderr.close()
        return process_stdout, process_stderr

    def _log_stdout(self, _process):
        """
        Reads the process stdout and logs it to console and log file
        @param _process: [subprocess.Popen] Instance of subprocess.Popen
        @return: [str] Standard output of the process
        """
        stdout = ""
        for line in iter(_process.stdout.readline, ""):
            stdout += line
            self.log.info(line.replace('\n', ''))
        _process.stdout.close()
        return stdout


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceCliCli(ResourceCli, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceCli.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceCli)

        RUN = ResourceCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest


        class ResourceCliUnittests(BaseTest):
            def __init__(self, result):
                super(ResourceCliUnittests, self).__init__(result)
                self.cli = ResourceCli()

            def setup(self):
                self.record_test_name()

            def test_run_command(self):
                self.result.assert_equal(self.cli.run_command('echo hi', stdout=True), ['hi'],
                                         "Running command and reading stdout")
                self.result.assert_equal(self.cli.run_command('error', stdout=True, stderr=True),
                                         ([], ["'error' is not recognized as an internal or external command,",
                                               'operable program or batch file.']),
                                         "Running command and reading stdout, stderr", )
                self.result.assert_equal(self.cli.run_command('echo hi'), 0, "Running command")

            def initiate(self):
                self.test_run_command()

            def complete(self):
                self.result.assert_equal("PPP : PASS", "%s : %s" % (self.result.step_outcome(),
                                                                    self.result.get_overall_outcome()), "Expected Pass")

            def teardown(self):
                self.result.report_result_to_tf()

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceCliUnittests(result=RESULTS)
        TEST.run()
