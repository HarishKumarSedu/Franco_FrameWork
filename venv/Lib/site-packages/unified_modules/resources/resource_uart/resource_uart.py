#!/usr/bin/env python
"""

@brief
A resource library to interact writing/reading with a serial port hardware

@Description:
This resource library provides wrapper methods to execute operations that
write and read through the USB port connected to RS232 converter with 8 bit
format at different speed in asynchronous mode.


Supported features:
- Write in asynchronous mode.
- Read in asynchronous mode.
- The maximum speed is 115200 bps.
- Compatibility with Windows and Unix system.

@b Usage
@code
resource = ResourceUart()
@endcode

"""

import sys
import serial
import time
import traceback
from binascii import unhexlify

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


# TODO: Clean this code up and make it generic. UM Team approved it to get uart infrastructure working.


class GeneratingVectors:
    def __init__(self, qty):
        print("Executing the Class")
        self.qty = qty
        self.buffer = []

    def buffer_statement(self, size_of_frame=10):
        self.buffer = [[self.qty for i in range(3)] for j in range(size_of_frame)]

    def create_messages(self, data):
        """Reading the structure will be created the messages"""
        for row in range(0, self.qty):
            # TODO: What is this 33 for ? magic number: fix it
            "Creates the structure of the frame and shows the sequence"
            "Byte 01 : Header of Frame"
            "Byte 02 :   Index of Message"
            "Byte 03 : X Axis"
            "Byte 04 : Y Axis"
            "Byte 05 : Z Axis"
            "Byte 06 : Affirmative Negative Value X Axis"
            "Byte 07 : Affirmative Negative Value Y Axis"
            "Byte 08 : Affirmative Negative Value Z Axis"
            "Byte 09 : Closing Byte"
            "Byte 10 : End Message"
            self.buffer[row] = (33, row, data['x'][row], data['y'][row], data['z'][row], data['ois_pwm'][row],
                                data['af_pwm'][row], data['xyz_sense'][row], 255, 0)

    def convert_message(self, int_value, num_bytes):
        negative_flag = 0
        if int_value < 0:
            negative_flag = 1
        data_ = format(int_value, 'x')
        subtotal = len(data_) + len(data_) % 2

        if num_bytes * 2 >= subtotal:
            delta = num_bytes * 2 - subtotal
        else:
            delta = 0
        total = subtotal + delta
        result = data_.rjust(total, '0')
        hexed = unhexlify(result)
        return hexed, negative_flag


class ResourceUartError(Exception):
    """Define ResourceRS232Error Exception Type"""
    pass


class ResourceUart(object):
    """Class which encapsulates API to communicate Serial Port through USB converter"""
    def __init__(self):
        """
        Initializing the default values the setup of hardware interface.
        """
        self.log = logging.getLogger(ResourceUart.__name__)
        self.serial = None
        self.config = None
        self.size_of_frame = None
        self.uart_vector = None

    def set_config_details(self, config):
        """
        Set configuration details
        """
        self.config = config

        try:
            self.serial = serial.Serial(port=config['port'],
                                        baudrate=int(config['baudrate']),
                                        stopbits=int(config['stopbits']),
                                        parity=config['parity'],
                                        bytesize=int(config['bytesize']))
        except serial.SerialException:
            raise ResourceUartError("Failed to initialize serial object - %s" % self.get_stack_trace())

    def set_size_of_frame(self, frame_size=10):
        self.size_of_frame = frame_size

    def write_data(self, data=None, time_to_wait=2, sleep_time=0.05):
        """
        Send data to serial port
        :param data: Byte to be sent
        :return: None
        """
        # Generating the uart_vector.buffer Space and Vector Scanning
        self.uart_vector = GeneratingVectors(self.size_of_frame)
        self.uart_vector.buffer_statement(self.size_of_frame)
        self.uart_vector.create_messages(data)
        data_len = 0
        try:
            start_time = time.time()
            while time.time() - start_time < time_to_wait:
                for seq in range(0, self.size_of_frame):
                    frame = []
                    for frame_val in range(0, self.size_of_frame):
                        frame.append(self.uart_vector.buffer[seq][frame_val])

                    self.log.info("UART Frame to be written to STM32: %s", frame)

                    for x in range(0, self.size_of_frame):
                        # All the values need to be converted to Hex Values
                        hexed, negative_flag = self.uart_vector.convert_message(int(frame[x]), num_bytes=1)
                        write_len = self.serial.write(hexed)
                        data_len = data_len + write_len
                time.sleep(sleep_time)
        except (serial.portNotOpenError, TypeError, IOError):
            raise ResourceUartError("Failed to write data %s - %s" % (hexed, self.get_stack_trace()))
        return data_len

    def read_data(self, size_bytes):
        """
        Read data from serial port
        :param size_bytes: Number of bytes to read
        :return: Read bytes
        """
        try:
            return self.serial.readline(size_bytes)
        except (serial.portNotOpenError, ValueError):
            raise ResourceUartError("Read operation failed reading %s bytes - %s" % (size_bytes,
                                                                                     self.get_stack_trace()))

    def open_port(self):
        """
        Start serial port connection
        :return: None
        """
        try:
            self.serial.open()
        except serial.SerialException:
            raise ResourceUartError("Failed to open serial port - %s" % self.get_stack_trace())

    def close_port(self):
        """
        Close serial port
        :return: None
        """
        try:
            self.serial.close()
        except serial.SerialException:
            raise ResourceUartError("Failed to close serial port - %s" % self.get_stack_trace())

    def data_flush(self):
        """
        Flush buffer data
        :return: None
        """
        try:
            self.serial.flush()
        except (serial.SerialException, ValueError):
            raise ResourceUartError("Failed to flush buffer - %s" % self.get_stack_trace())

    @staticmethod
    def get_stack_trace():
        """Provide the stack trace string"""
        return traceback.format_exc(traceback.extract_stack())


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line

        import unified_modules.test_support.cli_support as cli_support

        class ResourceUartCli(ResourceUart, cli_support.CliOptions):
            """
            Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class
            """

            def __init__(self, *args, **kwargs):
                ResourceUart.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceUart)

        RUN = ResourceUartCli()
    else:
        # Unit test works only with real hardware
        # Be careful about the path declarations considering paths.

        from unified_modules.test_support.testresults import TestResults

        class ResourceUartUnitTest(ResourceUart):
            """
            UnitTest for UART interface resource.
            """
            def __init__(self):
                self.results = TestResults()
                self.results.set_test_title('test_resource_uart')
                self.log = self.results.log

            def test_resource_uart(self):
                """
                Test firmware to verify the kernel detection about hardware converter.
                """
                config = {"device": "COM14",
                          "speed": 115200,
                          "bytesize": 8,
                          "timeout": "None",
                          "stopbits": 1,
                          "parity": 'N'}

                self.set_config_details(config)

                self.results.assert_not_raises(ResourceUartError,
                                               self.write_data(0x00),
                                               "Expected not to raise Error")
                self.serial.close()


        TEST_UART = ResourceUartUnitTest()
        TEST_UART.test_resource_uart()
