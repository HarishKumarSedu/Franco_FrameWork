"""
@summary: Resource for Digital/Analog Play and Record works only on Windows.
"""
import csv
import wave
import os
import subprocess
import sys
import time
try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

from threading import Thread


SEM_NO_GP_FAULT_ERROR_BOX = 0x0002


class ResourceRecordPlayAudioError(Exception):
    """
    Exception class ResourceRecordPlayAudio
    """
    def __init__(self, message=None):
        super(ResourceRecordPlayAudioError, self).__init__(message)


class ResourceRecordPlayAudio(object):
    """
    Wrapper for Digital/Analog playback.
    """
    def __init__(self):
        self.log = logging.getLogger(ResourceRecordPlayAudio.__name__)
        self.host_api = None
        self.device_string = ''
        self.sample_rate = None
        self.bit_depth = None
        self.buffer_size = None
        self.play_thread = None
        self.rec_thread = None
        self.rec_value = None
        self.play_value = None
        # Adding exe and dll libraries path to OS path variable
        lib_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'audio_utils', 'lib'))
        bin_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'audio_utils', 'bin'))
        os.environ['PATH'] = os.environ['PATH'] + os.pathsep + lib_path + os.pathsep + bin_path

    def set_config(self, host_api='ASIO', device_string='', sample_rate=48000,
                   bit_depth=16, buffer_size=512):
        """
        Set up the pa_multitrack utility for playback by performing the command:
        pa_multitrack <HOST_API> "<DEVICE_NAME>" <SAMPLE_RATE> <BIT_DEPTH>
                     <BUFFER_SIZE>.

        @return None
        """
        self.host_api = host_api
        self.device_string = device_string
        self.sample_rate = sample_rate
        self.bit_depth = bit_depth
        self.buffer_size = buffer_size
        cmd_line = 'pa_multitrack {} "{}" {} {} {}'.format(self.host_api,
                                                           self.device_string,
                                                           self.sample_rate,
                                                           self.bit_depth,
                                                           self.buffer_size)
        process = subprocess.Popen(cmd_line, shell=True, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        stdout, stderror = process.communicate()
        if stderror:
            self.log.error(stderror)
            raise ResourceRecordPlayAudioError("PA Multitrack setup configuration failed")
        else:
            self.log.info("PA Multitrack setup Success \n %s" % stdout)

    @staticmethod
    def __create_csv(track_list, record):
        """
        Write our list of playback tracks to a CSV file to be used with
         pa_multitrack.
        The CSV file will have rows of the form:
            '<track file>, <record_channel_num>, <play_channel_num>'

        Each track file should be a mono recording.

        @param track_list    [Array[Array]]    Array of track tuples to play/
                                               record of the form:
                                               [ track_file,
                                               play_channel_num,
                                               record_channel_num ]
        @param record       [Bool]            Boolean variable to tell the
                                              function whether to record track
                                              list or playback track list.
        @return The relative path of the CSV file created.
        """
        tmp_dir = 'tmp'

        if not os.path.exists(tmp_dir):
            os.makedirs(tmp_dir)
        if record:
            filename = os.path.join(tmp_dir, 'tracklist_record.csv')
        else:
            filename = os.path.join(tmp_dir, 'tracklist.csv')
        with open(filename, 'wb') as csv_file:
            csv_file = csv.writer(csv_file)
            for _, track_list_item in enumerate(track_list):
                if isinstance(track_list_item, list):
                    track_name = track_list_item[0]
                    play_channel_num = track_list_item[1]
                    record_channel_num = track_list_item[2]
                    csv_file.writerow([track_name,
                                       record_channel_num,
                                       play_channel_num])
        return filename

    @staticmethod
    def invoke_pa_multitrack(command):
        """
        Invokes Pa Multitrack with given command.
        @param command [String] Command line of pa multitrack.
        @return None
        """
        # To disable dailog box when in negative scenarios of pa_multitrack
        if sys.platform.startswith("win"):
            import ctypes
            ctypes.windll.kernel32.SetErrorMode(SEM_NO_GP_FAULT_ERROR_BOX)
            subprocess_flags = 0x8000000  # win32con.CREATE_NO_WINDOW?
        else:
            subprocess_flags = 0

        process = subprocess.Popen(command,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT,
                                   creationflags=subprocess_flags)

        # Poll process for new output until finished
        while True:
            next_char = process.stdout.read(1)
            if next_char == '' and process.poll() is not None:
                break
            sys.stdout.write(next_char)
        return process.returncode

    @staticmethod
    def get_samples_in_wav_file(wav_file_path):
        """
        Get number of samples in wav files

        @param wav_file_path: [str] wav file path
        @return: [str] Number of samples in a wav file
        """
        wav_handle = wave.open(wav_file_path, 'r')
        sample_rate = wav_handle.getframerate()
        duration = wav_handle.getnframes() / float(sample_rate)
        samples = int(sample_rate * duration)
        samples = str(samples)
        return samples

    def play_record_track_list(self,
                               track_list_play,
                               record=True,
                               samples=48000,
                               background=False):
        """
        Write out our track list as CSV, then immediately play it using
        pa_multitrack.

        @param track_list_play    [Array[Array]]
                                  Array of track tuples to play/record of the
                                  form:
                                  [ track_file, playback_number, record_number ]
        @param record     [Boolean]    Boolean variable to tell the function
                                       whether to record or not.
        @param samples    [Integer]    Record for the given number of samples
        @param background    [Boolean] Boolean variable to tell the function
                                       whether play or record in background or
                                       not.
        @return    None
        """

        csv_file = self.__create_csv(track_list_play, record)
        samples = str(samples)
        if background:
            if record:
                self.rec_thread = Thread(
                    target=lambda _: self.invoke_pa_multitrack(["pa_multitrack",
                                                                csv_file,
                                                                samples]),
                    args=[None])
                self.rec_thread.start()
            else:
                self.play_thread = Thread(
                    target=lambda _: self.invoke_pa_multitrack(["pa_multitrack",
                                                                csv_file]),
                    args=[None])
                self.play_thread.start()

            # Initialize time for pa_multi_track to setup.
            time.sleep(1.5)
        else:
            if record:
                command = ["pa_multitrack", csv_file, samples]
                self.rec_value = self.invoke_pa_multitrack(command)
            else:
                command = ["pa_multitrack", csv_file]
                self.play_value = self.invoke_pa_multitrack(command)


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceRecordPlayAudioCli(ResourceRecordPlayAudio, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceRecordPlayAudio.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceRecordPlayAudio)

        RUN = ResourceRecordPlayAudioCli()
    else:
        # TODO - Implementation of unit tests for ResourceRecordPlayAudio
        pass
