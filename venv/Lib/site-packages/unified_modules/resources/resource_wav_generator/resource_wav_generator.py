#!/usr/bin/env python
"""
Resource library for generating audio wav files.
Refer to https://www.pythonforengineers.com/audio-and-digital-signal-processingdsp-in-python/
"""

import sys
import os
import wave

from math import (sin, pi)
from struct import pack, error
from scipy.io.wavfile import write
import numpy as np


class Struct:
    def __init__(self, **entries):
        self.__dict__.update(entries)


class WaveGenInputs(object):
    def __init__(self, filename, duration=2000, samplerate=48000, amplitude=0.5, sample_width=2,
                 start=160, end=300, frequency=500, force_create=True, nchannels=1, freq_delta=0, time_offset=0):
        """
        Wave generation data structure

        @param filename - Filename of wav file to be created.
        @param duration - Duration of wav file, all effects must fit this in ms.
        @param samplerate - Sample rate in Hz.
        @param amplitude - Maximum amplitude of wave form (1.0 - 0.0).
        @param sample_width - 1 or 2 byte samples.
        @param start - start silence effect in ms
        @param end - end silence effect in ms.
        @param frequency - Wave form frequency.
        @param force_create - Force the file to be created if already exists.
        @param nchannels - Number of channels to be created.
        @param freq_delta - Frequency increase for subsequent channels(applies to multichannel wav files)
        @param time_offset - Time offset in ms for subsequent channels(applies to multichannel wav files)
        """
        self.filename = filename
        self.duration = duration
        self.samplerate = samplerate
        self.amplitude = amplitude
        self.sample_width = sample_width
        self.start = start
        self.end = end
        self.frequency = frequency
        self.force_create = force_create
        self.nchannels = nchannels
        self.freq_delta = freq_delta
        self.time_offset = time_offset


class ResourceWavGenerator(object):
    """Utility for generating wave files on the test head"""
    def __init__(self):
        """Setup some default values and initialise storage"""
        # The maximum range varies depending on the sample size
        # 8-bit PCM max:255 (0xFF) min:0
        # 16-bit PCM max:32767 (0x7FFF) -min:-32768 (-0x8000)
        # 24-bit PCM max:8388607 (0x7FFFFF) -min:-8388608 (-0x800000)
        # 32-bit PCM max:2147483647 (0x7FFFFFFF) -min:-2147483647 (-0x800000)
        self.sample_scale = {1: 2 ** 7 - 1,
                             2: 2 ** 15 - 1,
                             3: 2 ** 23 - 1,
                             4: 2 ** 0}

        # The value for silence varies depending on the encoding, which depends on sample size
        # One to eight bits Unsigned integer, Midpoint Value (silence) is 128
        # Nine or more bits Signed integer i, Midpoint Value (silence) is 0
        self.sample_silence = {1: 128,
                               2: 0,
                               3: 0,
                               4: 0}

        self.data = []

        # Initialise some default values
        self.amplitude = 1
        self.sample_width = 2
        self.samplerate = 8000
        self.duration = 10000
        self.nchannels = 1

        self.freq_delta = 0
        self.time_offset = 0

        self.sample_format = None
        self.frequency = None

        self.file = None

    def set_wav_defaults(self,
                         amplitude=0.5,
                         sample_width=2,
                         samplerate=8000,
                         duration=30000,
                         nchannels=1,
                         freq_delta=0,
                         time_offset=0):
        """Set default wav attributes - used when generating effects to mix
        @param amplitude - Maximum amplitude of wave form (1.0 - 0.0).
        @param sample_width - 1 or 2 byte samples.
        @param samplerate - Sample rate in Hz.
        @param duration - Duration of wav file, all effects must fit this in ms.
        @param nchannels - Number of channels to be created.
        @param freq_delta - Freqency increase for subsequent channels.
        @param time_offset - Time offset in ms for subsequent channels.
        """
        self.amplitude = amplitude
        self.sample_width = sample_width
        self.samplerate = samplerate
        self.nchannels = nchannels
        self.freq_delta = freq_delta
        self.time_offset = time_offset
        self.duration = duration

        # Initialise storage
        self.effect_silence(0, -1)

    def make_sine_tone_wav(self, sine_tone_wav):
        """Creates a sine wav file
        @param sine_tone_wav [WaveGenInputs] Wave generation data structure
        """
        if isinstance(sine_tone_wav, dict):
            sine_tone_wav = Struct(**sine_tone_wav)
        wave_file_name = sine_tone_wav.filename
        if not os.path.exists(wave_file_name) or sine_tone_wav.force_create:
            duration = float(sine_tone_wav.duration)
            samplerate = float(sine_tone_wav.samplerate)
            amplitude = float(sine_tone_wav.amplitude)
            sample_width = float(sine_tone_wav.sample_width)
            start = float(sine_tone_wav.start)
            end = float(sine_tone_wav.end)
            frequency = float(sine_tone_wav.frequency)
            nchannels = int(sine_tone_wav.nchannels)
            freq_delta = float(sine_tone_wav.freq_delta)
            time_offset = float(sine_tone_wav.time_offset)

            # Create directory if not present
            if not os.path.exists(os.path.dirname(wave_file_name)) and \
                    os.path.dirname(wave_file_name) != "":
                os.makedirs(os.path.dirname(wave_file_name))

            # https://stackoverflow.com/questions/10357992/how-to-generate-audio-from-a-numpy-array/37423879
            if sample_width == 4:
                data = (np.sin(2 * np.pi * np.arange(samplerate * duration/1000.0) * frequency / samplerate))
                start_samples = self.ms_to_samples(start)
                end_samples = len(data) - self.ms_to_samples(end) - 1
                data[:start_samples] = [self.sample_silence[sample_width]] * start_samples
                data[end_samples:] = [self.sample_silence[sample_width]] * (len(data) - end_samples)
                scaled_data = np.float32((data * amplitude) / np.max(np.abs(data)) * self.sample_scale[sample_width])
                scaled_data = np.tile(scaled_data, (nchannels, 1)).T
                write(wave_file_name, int(samplerate), scaled_data)
                print("WAV Generated successfully (%s)" % wave_file_name)
                return

            self.file = wave.open(wave_file_name, 'w')

            # https://docs.python.org/2/library/struct.html
            self.sample_format = {1: 'B',  # unsigned char, 1B
                                  2: 'h',  # short int, 2B
                                  3: 'i',  # signed int, 4B
                                  4: 'l'}  # signed long, 4B
            # Reference code: https://www.daniweb.com/programming/software-development/code/263775/
            # create-a-synthetic-sine-wave-wave-file
            # Scale wav wide attributes
            comptype = "NONE"
            compname = "not compressed"

            self.frequency = frequency
            self.nchannels = nchannels
            self.sample_width = sample_width
            self.samplerate = samplerate
            self.amplitude = amplitude * self.sample_scale[self.sample_width]
            # Ensure the wav does not end before expected, up to 1ms of silence at the end

            data_size = self.ms_to_samples(duration) * nchannels

            self.file.setparams((nchannels,
                                 sample_width,
                                 samplerate,
                                 data_size,
                                 comptype,
                                 compname))

            # Record the file
            (start, stop) = self.get_start_end_samples(start, duration-end)
            (begin, end) = self.get_start_end_samples(0, duration)
            clip_count = 0

            for sample_no in list(range(begin, end)):
                for channel in list(range(nchannels)):
                    if stop >= sample_no >= start:
                        # Only record sin value if the sample is within the start-stop range
                        value = self.get_value_sine(sample_no+(time_offset*channel),
                                                    self.frequency+(freq_delta*channel))
                    else:
                        # Otherwise silence
                        value = self.sample_silence[self.sample_width]

                    try:
                        # Always signed format to use for pack
                        packed_sample = pack(self.sample_format[self.sample_width], value)

                        if self.sample_width == 3:
                            # Chop 4th byte
                            packed_sample = packed_sample[0] + packed_sample[1] + packed_sample[2]

                    except error:
                        clip_count += 1
                        # Clip to min/max
                        packed_sample = pack(self.sample_format[self.sample_width],
                                             (self.sample_scale[self.sample_width] *
                                              1))
                    self.file.writeframes(packed_sample)

            self.file.close()

            clip_warning = ""
            if clip_count > 0:
                clip_warning = ", WARNING clipped %d samples" % clip_count

            print("WAV Generated successfully (%s) %s" % (wave_file_name, clip_warning))
            sys.stdout.flush()

    def ms_to_samples(self, x_ms):
        """Convert ms to samples
        @param x_ms - milliseconds into wav"""
        samples = x_ms
        if x_ms is not None:
            samples = int(self.samplerate * (float(x_ms) / 1000))
        return samples

    def get_start_end_samples(self, start, end):
        """Convert start/end in ms to samples
        @param start - start of the effect in ms.
        @param end - end of the effect in ms.
        """
        # From
        start_at = int(self.ms_to_samples(start))
        # To
        if end != -1:
            end_at = int(self.ms_to_samples(end))
        else:
            end_at = None

        return start_at, end_at

    def get_value_sine(self, sample_no, frequency=None):
        """Provide the amplitude of the sine wave at a given location"""

        if frequency is None:
            frequency = self.frequency

        value = (sin(2 * pi * frequency * (float(sample_no) / self.samplerate)) * self.amplitude)

        # 8 bit is always unsigned in a wav file
        if self.sample_width == 1:
            value = value + (self.sample_scale[self.sample_width])

        return value

    def generate_wav_file(self,
                          filename,
                          _attributes=None,
                          duration=30000,
                          samplerate=8000,
                          amplitude=0.5,
                          sample_width=2,
                          nchannels=1,
                          _silent=False):
        """Create a new silent wav file, use effects to add sounds or noise
          before storing.
        @param filename - Filename of file to be created.
        @param _attributes - Use the effect commands to apply the attributes (Optional)
        @param duration - Duration of wav file, all effects must fit this in ms.
        @param samplerate - Sample rate in Hz.
        @param amplitude - Maximum amplitude of wave form (1.0 - 0.0).
        @param sample_width - 1 or 2 byte samples.
        @param nchannels - Number of channels to be created.
        @param _silent - Optional silent mode, not used from interactive modes
         """

        duration = float(duration)
        samplerate = float(samplerate)
        amplitude = float(amplitude)
        sample_width = float(sample_width)
        nchannels = int(nchannels)

        comptype = "NONE"
        compname = "not compressed"

        self.data = []

        #Create directory if not present
        if (not os.path.exists(os.path.dirname(filename))
                and os.path.dirname(filename) != ""):
            os.makedirs(os.path.dirname(filename))

        # Storage for file contents in buffer mode
        self.file_contents = []
        self.file = wave.open(filename, 'w')

        # Scale wav wide attributes
        self.nchannels = nchannels
        self.sample_width = sample_width
        self.amplitude = amplitude * self.sample_scale[self.sample_width]
        # Ensure the wav does not end before expected, up to 1ms of silence
        # at end
        self.duration = duration + 1
        self.samplerate = samplerate

        data_size = int((float(self.duration) / 1000) * samplerate)
        self.file.setparams((nchannels,
                             sample_width,
                             samplerate,
                             data_size,
                             comptype,
                             compname))

        effects_lookup = {'sin': self.effect_sine_wave,
                          'silence': self.effect_silence,
                          # TBD, 'white_noise': None, # TBD, write effect_white_noise()
                          'mix': self.effect_mix}

        # Always create the full duration of the wav file, this creates the
        # array for audio data
        if _attributes is None:
            _attributes = []

        for channel in list(range(nchannels)):
            _attributes.insert(0, ('silence', 0, -1, {}, channel))

        # Run the required effects
        for (effect, start, stop, parameters, channel) in _attributes:
            effects_lookup[effect](start, stop, parameters, channel)

        if not _silent:
            print("OK")
            sys.stdout.flush()

    def store_wav_file(self):
        """Record the wav file to disk"""
        # Always signed
        # format to use for pack
        # https://docs.python.org/2/library/struct.html
        self.sample_format = {1: 'B',  # unsigned char, 1B
                              2: 'h',  # short int, 2B
                              3: 'i',  # signed int, 4B
                              4: 'l'}  # signed long, 4B

        # Record the file
        for value in self.data:
            try:
                packed_sample = pack(self.sample_format[self.sample_width], value)

                if self.sample_width == 3:
                    # Chop 4th byte
                    packed_sample = packed_sample[0] + packed_sample[1] + packed_sample[2]

            except error:
                # Clip to min/max
                packed_sample = pack(self.sample_format[self.sample_width],
                                     (self.sample_scale[self.sample_width] * 1))
            self.file.writeframes(packed_sample)

        self.file.close()

        print("OK WAV Generated")
        sys.stdout.flush()

    def effect_silence(self, start, end, parameters=None, channel=0, data_store=None):
        """Create silence
        @param start - start of the effect in ms.
        @param end - end of the effect in ms.
        @param parameters - dictionary of sine wave parameters.
        @param data_store - optional list to store output (Optional).
        @param channel - Channel to be modified.
        """
        if (parameters is not None) and (parameters != {}):
            outstr = str(parameters)
            print("silence does not take parameters %s ignored" % outstr)

        if data_store is None:
            data_store = self.data

        (start_at, end_at) = self.get_start_end_samples(start, end)
        start_at = start_at * self.nchannels

        try:
            end_at = end_at * self.nchannels
        except TypeError:
            end_at = end_at

        if self.data == []:
            # Array needs creating, all channels will be silent
            self.data = [self.sample_silence[self.sample_width] for dummy in
                         range(self.ms_to_samples(self.duration) * self.nchannels)][start_at:end_at]
        else:

            # overlay on existing wav on a specific channel
            for sample_no in range(
                    self.ms_to_samples(self.duration) * self.nchannels)[start_at:end_at]:
                if sample_no % self.nchannels == channel:
                    data_store[sample_no] = self.sample_silence[self.sample_width]

    def mix_sine_wave(self, start, end, amplitude, frequency, channel=0):
        """Mix sine wave with created wav
        @param start - start of the effect in ms.
        @param end - end of the effect in ms.
        @param amplitude - Maximum amplitude of wave form (1.0 - 0.0).
        @param frequency - Wave form frequency.
        @param channel - Channel to be modified.
        """
        channel = int(channel)
        start = float(start)
        if end is not None:
            end = float(end)
        amplitude = float(amplitude)
        frequency = float(frequency)
        store = [0] * len(self.data)

        self.effect_sine_wave(start, end, {'amplitude': amplitude,
                                           'frequency': frequency}, channel, store)

        self.effect_mix(start, end, {'signal_to_mix': store}, channel, store)
        print("OK")
        sys.stdout.flush()

    def effect_sine_wave(self, start, end, parameters, channel=0, data_store=None):
        """Create sine wave tone
        @param start - start of the effect in ms.
        @param end - end of the effect in ms.
        @param parameters - dictionary of sine wave parameters.
        @param data_store - optional list to store output (Optional).
        @param channel - Channel to be modified.
        """
        frequency = parameters['frequency']
        amplitude = (parameters['amplitude'] *
                     self.sample_scale[self.sample_width])
        if data_store is None:
            data_store = self.data

        (start_at, end_at) = self.get_start_end_samples(start, end)
        start_at = start_at * self.nchannels

        try:
            end_at = end_at * self.nchannels
        except TypeError:
            end_at = end_at

        # create sine wave on a specific channel
        for sample_no in range(self.ms_to_samples(self.duration) * self.nchannels)[start_at:end_at]:

            if sample_no % self.nchannels == channel:
                data_store[sample_no] = (sin(
                    2 * pi * frequency *
                    (float(sample_no/self.nchannels) / self.samplerate)) * amplitude)

            # 8 bit is always unsigned in a wav file
            if self.sample_width == 1:
                if sample_no % self.nchannels == channel:
                    data_store[sample_no] = (data_store[sample_no] +
                                             self.sample_scale[self.sample_width])

        return data_store

    def effect_mix(self, start, end, parameters, channel=0, data_store=None, ):
        """Perform mix
        @param start - start of the effect in ms.
        @param end - end of the effect in ms.
        @param parameters - dictionary of sine wave parameters
        @param data_store - optional list to store output (Optional)
        @param channel - Channel to be modified.
        """
        additional_audio = parameters['signal_to_mix']
        if data_store is None:
            data_store = self.data

        (start_at, dummy) = self.get_start_end_samples(start, end)
        start_at = start_at * self.nchannels

        # Mix on specific channel
        for (sample_no, new_sample_no) in zip(
                list(range(self.ms_to_samples(self.duration)))[start_at:len(additional_audio)],
                list(range(len(additional_audio)))):

            if sample_no % self.nchannels == channel:
                self.data[sample_no] = (self.data[sample_no] + additional_audio[new_sample_no])


if __name__ == '__main__':
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support


        class ResourceWavGeneratorCli(ResourceWavGenerator, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self, *args, **kwargs):
                ResourceWavGenerator.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceWavGenerator)

        RUN = ResourceWavGeneratorCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest


        class ResourceWavGeneratorUnitTests(BaseTest):
            def __init__(self, result):
                super(ResourceWavGeneratorUnitTests, self).__init__(result)
                self.file_gen = ResourceWavGenerator()

            def complete(self):
                import filecmp
                exp_filename = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'expected_sine.wav')
                gen_filename = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'generated_sine.wav')
                duration = 2000
                samplerate = 48000
                amplitude = 1
                sample_width = 2
                start_padding = 160
                end_padding = 300
                frequency = 500
                nchannels = 1
                wave_struct = WaveGenInputs(gen_filename, duration, samplerate, amplitude, sample_width, start_padding,
                                            end_padding, frequency, nchannels=nchannels)
                self.file_gen.make_sine_tone_wav(wave_struct)
                self.result.assert_true(filecmp.cmp(exp_filename, gen_filename),
                                        "Sine tone simple: Check if both files are the same")

                exp_filename = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'expected_mix.wav')
                gen_filename = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'generated_mix.wav')
                input_amplitude = 0.5
                self.file_gen.generate_wav_file(gen_filename,
                                                duration=duration,
                                                samplerate=samplerate,
                                                amplitude=input_amplitude,
                                                sample_width=sample_width,
                                                nchannels=nchannels)

                out_channels = 2
                input_frequency = [150, 20000, 300, 21000]
                start_padding = 150

                for channel in range(out_channels):
                    stream_channel = channel / 2
                    self.result.test_step("Mix in audio at frequency %d" % input_frequency[channel])
                    self.file_gen.mix_sine_wave(start=start_padding,
                                                end=duration,
                                                amplitude=input_amplitude,
                                                frequency=input_frequency[channel],
                                                channel=stream_channel)
                self.file_gen.store_wav_file()
                self.result.assert_true(filecmp.cmp(exp_filename, gen_filename),
                                        "Mixed tones: Check if both files are the same")

            def teardown(self):
                self.result.report_result_to_tf()

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceWavGeneratorUnitTests(result=RESULTS)
        TEST.run()