#!/usr/bin/env python
"""
Resource library for analysing audio wav files
"""
import sys
import wave
import platform
from scipy.io.wavfile import write, read

import sounddevice as sd
import soundfile as sf
from collections import namedtuple

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


bit_depth = namedtuple('bit_depth', 'bit8 bit16 bit24 bit32')
BIT_DEPTH = bit_depth(8, 16, 24, 32)

sub_type = namedtuple('sub_type', 'bit8 bit16 bit24 bit32')
SUB_TYPE = sub_type('PCM_U8', 'PCM_16', 'PCM_24', 'FLOAT')

dtype = namedtuple('dtype', 'bit8 bit16 bit24 bit32')
DTYPE = dtype('int32', 'int32', 'int32', 'float32')


class ResourceAudioPlayRecError(Exception):
    """Exception class for ResourceAudioRecPlay"""
    pass


class ResourceAudioPlayRec(object):
    """Utility for play and record on the test head"""
    def __init__(self):
        self.log = logging.getLogger(self.__class__.__name__)
        self.playback_device_name = None
        self.record_device_name = None
        self.subtype_mapping = {BIT_DEPTH.bit8: SUB_TYPE.bit8,
                                BIT_DEPTH.bit16: SUB_TYPE.bit16,
                                BIT_DEPTH.bit24: SUB_TYPE.bit24,
                                BIT_DEPTH.bit32: SUB_TYPE.bit32}
        self.dtype_mapping = {BIT_DEPTH.bit8: DTYPE.bit8,
                              BIT_DEPTH.bit16: DTYPE.bit16,
                              BIT_DEPTH.bit24: DTYPE.bit24,
                              BIT_DEPTH.bit32: DTYPE.bit32}

    def set_config_details(self, config):
        self.playback_device_name = config['playback_device']
        self.record_device_name = config['record_device']

    def play_record(self, input_wav, output_wav, sample_rate=None, bitdepth=None):
        """
        Play and Record method

        :param input_wav: string - input wave file path including file name
        :param output_wav: - string - recorded file path with file name where to be saved
        :param sample_rate: - int - sample rate to play/record
        :param bitdepth: - int - bit depth - supported 8, 16, 24, 32
        :return: None
        """
        # Need to set blocksize to 16394(minimum) for performing play record on Mac
        # else "input underflow" error will be raised by sounddevice module
        if 'Darwin' in platform.system():
            sd.default.blocksize = 16394

        try:
            input_fs, input_data = read(input_wav)
            # channels = input_data.ndim
            # With ndim api above we are getting the wrong channels count for 4 channel stream
            wave_file_handler = wave.open(input_wav)
            channels = wave_file_handler.getnchannels()
            wave_file_handler.close()
            if bitdepth is None:
                bitdepth = input_data.dtype.itemsize * 8
        except ValueError:
            wave_file_handler = wave.open(input_wav)
            if bitdepth is None:
                bitdepth = wave_file_handler.getsampwidth() * 8
                wave_file_handler.close()
        data, fs = sf.read(input_wav, dtype=self.dtype_mapping[bitdepth])
        if sample_rate is None:
            sample_rate = fs

        record_data = sd.playrec(data, sample_rate, device=self.playback_device_name, channels=channels,
                                 dtype=self.dtype_mapping[bitdepth], blocking=True)
        if bitdepth == 32:
            write(output_wav, sample_rate, record_data)
        else:
            sf.write(output_wav, record_data, sample_rate, self.subtype_mapping[bitdepth])
        status = sd.get_status()
        if status:
            self.log.error(str(status))
            raise ResourceAudioPlayRecError("Error in play or record.")
        else:
            self.log.info('Play and Record is Done...')
            return True

    def duration_of_wav(self,wave_file):
        """
        This is the function for getting the wave duration
        @param   wave_file      : name of a wav file with fill path (string)
        @return  wave_duration  : duration of the waveform
        """
        f = sf.SoundFile(wave_file)
        wave_duration = len(f) / f.samplerate
        self.log.info("Duration of the waveform is  %d sec" %wave_duration)
        return wave_duration

    def play(self,wave_file):
        """
        This is the method for playing a wav file
        @param  wave_file : name of a wav file with fill path (string)
        """
        sd.default.device = self.playback_device_name
        data, samplerate = sf.read(wave_file)
        self.log.info("playing Audio")
        try:
            sd.play(data, samplerate, blocking=True)
        except:
            raise ResourceAudioPlayRecError("Error in play.")

    def record(self,record_file_name, rec_duration=10, fs = 48000, num_channel=2 ):
        """
        This is the function for recording a wav file
        @param  record_file_name : name of the recording file with path (string)
        @param  rec_duration     : duration of recording (int) [optional/default value is 10 sec]
        @param  num_channel      : number of channels (int) [optional/default value is 2]
        @param  fs               : sample frequency (int) [optional/default value is 48000]
        @return  True if the recording is done successfully
        """
        sd.default.device = self.record_device_name
        myrecording = sd.rec(rec_duration * fs, samplerate=fs, channels=num_channel, dtype='float32', blocking=True)
        #reading myrecording into a stream
        self.log.info("Recording Audio...")
        sf.write(record_file_name, myrecording, fs)
        status = sd.get_status()
        if status:
            self.log.error(str(status))
            raise ResourceAudioPlayRecError("Error in record.")
        else:
            self.log.info('Record is Done...')
            return True

    def stop_play(self):
        pass

    def stop_rec(self):
        pass

    def get_all_playback_rec_devies(self):
        """
        This is the method to get all the audio devices
        @return  : list of dictionary all the devices(each dictionaty is having the detailed information of a device)
        """
        return sd.query_devices()

    def record_from_device(self, rec_duration=10, fs = 48000, num_channel=2):
        """
        Records the playback
        @param rec_time : [int] adequate time to record the playback
        """
        recording_buffer = sd.rec(rec_duration * fs, samplerate=fs, channels=num_channel, dtype='float32')
        return recording_buffer

    def write_recording_to_file(self, recording_buffer, record_file_name, fs = 48000):
        """
        Writes the recorded buffer into a file
        @param recording_buffer : buffer which is returned by the sound device recording function
        @param file_name        : [str] name of the file to which recording has to be saved
        """

        sf.write(record_file_name, recording_buffer, fs)
        return True

if __name__ == '__main__':
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support


        class ResourceAudioRecPlayCli(ResourceAudioPlayRec, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self, *args, **kwargs):
                ResourceAudioPlayRec.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceAudioPlayRec)

        RUN = ResourceAudioRecPlayCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest
        # Replace the input file name with an existing wav file


        class ResourceAudioRecPlayUnitTests(BaseTest):
            def __init__(self, result):
                super(ResourceAudioRecPlayUnitTests, self).__init__(result)
                self.rec_play = ResourceAudioPlayRec()
                self.rec_play.device_name = "Cirrus Logic ASIO Driver"

            def complete(self):
                input_filename = 'C:\\Users\\sbussa\\Desktop\\whitenoise.wav'
                output_filename = 'C:\\Users\\sbussa\\Desktop\\output.wav'
                status = self.rec_play.play_record(input_filename, output_filename)
                self.result.assert_true(status, "Play Record status")
                self.rec_play.duration_of_wav(output_filename)

            def teardown(self):
                self.result.report_result_to_tf()

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceAudioRecPlayUnitTests(result=RESULTS)
        TEST.run()