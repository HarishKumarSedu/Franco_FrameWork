#!/usr/bin/env python
"""

@brief
A resource library to interact with Segger J-Trace device

@Description:
This resource library provides wrapper methods to perform operations using
a SWD interface to debug Cortex-M architecture.

Supported features:
- Execute Firmware Download Script through JLink Commander
- Read register function using JLink connection
- Read on realtime the core activity considering hot state

@b Usage
@code
swd = ResourceSWD()
@endcode

"""
import os
import subprocess
import traceback
import sys
import pylink
from collections import namedtuple

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

swd_op_mode = namedtuple('SwdOpModes', 'Single_SWD ITM_SWD')
SWD_OP_MODE = swd_op_mode('Single_SWD', 'ITM_SWD')


class ResourceSwdError(Exception):
    """Define ResourceSwdError Exception type"""
    pass


class ResourceSwd(object):
    """Class which encapsulates API to interact with JLink CLI """

    def __init__(self):
        """
        Initialize default values
        """
        self.log = logging.getLogger(ResourceSwd.__name__)
        self.config = None
        self.jlink_cli_path = None
        self.device = None
        self.jlink = None
        self.operation_mode = None
        self.swo_speed = None
        self.register_width = None

    def set_register_width(self, register_width):
        self.register_width = int(register_width)

    def set_config_details(self, config):
        """
        Set config details from configuration
        """
        self.config = config
        self.jlink_cli_path = config['jlink_cli_path']
        self.operation_mode = config['operation_mode']

        try:
            self.jlink = pylink.JLink()
            self.device = self.config['device']
            self.jlink.open(int(self.config['serial_number']))
            self.jlink.set_tif(pylink.enums.JLinkInterfaces.SWD)
            self.jlink.connect(self.device, verbose=True)
            if self.operation_mode == SWD_OP_MODE.Single_SWD:
                self.jlink.reset()
                self.jlink.halt()
                self.jlink.reset(ms=10, halt=False)
            elif self.operation_mode == SWD_OP_MODE.ITM_SWD:
                self.jlink.coresight_configure()
                self.jlink.reset()
                self.jlink.halt()
                self.swo_speed = self.jlink.swo_supported_speeds(int(self.config['speed_core']), 10)[0]
                self.jlink.swo_start(self.swo_speed)
                self.jlink.swo_flush()
                self.jlink.reset(self.config['delay_reset'], halt=False)
            else:
                raise ResourceSwdError("SWD Operation mode %s not supported" % self.operation_mode)
        except (pylink.errors.JLinkException, KeyError):
                raise ResourceSwdError("Failed to create JLink for SWD operation mode %s - %s" % (self.operation_mode,
                                                                                                  self.get_stack_trace()))

    def write_register(self, address, write_value):
        """
        Write register value at specified address
        @:param address: Register memory address
        @:param write_value: Value to be written in memory
        @:param register_width: Register bit width

        @:return None
        """
        try:
            write_value_list = [int(write_value, 16)]

            if self.register_width == 32:
                self.jlink.memory_write32(address, write_value_list)
            else:
                address = address + int(self.config["ram1_offset"], 16)
                self.jlink.memory_write16(address, write_value_list)

        except (ValueError, pylink.errors.JLinkException):
            raise ResourceSwdError("Write operation failed at 0x%08X - %s" % (address, self.get_stack_trace()))

    def read_register(self, address):
        """
        Read register value at specified address
        @:param address: Register memory address
        @:param register_width: Register bit width
        @:param size_of_elements: Size of elements to be read from memory

        @:return Returns the list of read values
        """
        try:
            result = []
            regs_to_read = 1
            if self.register_width == 32:
                result = self.jlink.memory_read32(address, regs_to_read)
            elif self.register_width == 16:
                address = address + int(self.config["ram1_offset"], 16)
                result = self.jlink.memory_read16(address, regs_to_read)
            if len(result) > 1:
                raise ResourceSwdError("Read operation returned more than one value for this register: %s", result)
            long_val = int(result[0])
            return hex(long_val).replace('L', '')
        except (ValueError, pylink.errors.JLinkException):
            raise ResourceSwdError("Read operation failed at 0x%08X - %s" % (address, self.get_stack_trace()))

    def read_block_from_reg_by_addr(self, address, register_width=32, size_of_elements=1):
        """
        Read register block at specified address
        @:param address: Register memory address
        @:param register_width: Register bit width
        @:param size_of_elements: Size of elements to be read from memory

        @:return Returns the list of read values
        """
        try:
            result = []
            if register_width == 32:
                result = self.jlink.memory_read32(address, size_of_elements)
            elif register_width == 16:
                address = address + int(self.config["ram1_offset"], 16)
                result = self.jlink.memory_read16(address, size_of_elements)

            result = [reg_value for reg_value in map(int, result)]
            return result

        except ValueError:
            raise ResourceSwdError("Read operation failed at 0x%08X - %s" %
                                   (address, self.get_stack_trace()))

    def write_block_to_reg_by_addr(self, address, write_values, register_width=32):
        """
        Write register block at specified address
        @:param address: Register memory address
        @:param write_value: List with values to be written in memory
        @:param register_width: Register bit width

        @:return None
        """
        try:
            if type(write_values) == 'list':
                write_byte_list = write_values

            elif type(write_values) == 'int':
                write_byte_list = [write_values]
            else:
                raise ResourceSwdError(
                    "Write register block should receive list or int - %s" %
                    self.get_stack_trace())

            if register_width == 32:
                self.jlink.memory_write32(address, write_byte_list)
            else:
                address = address + int(self.config["ram1_offset"], 16)
                self.jlink.memory_write16(address, write_byte_list)

        except ValueError:
            raise ResourceSwdError("Write block operation failed at 0x%08X - %s" % (address, self.get_stack_trace()))

    def download_firmware_to_board(self, commander_script=None, config=None):
        """
        Execute JLink Commander script and download firmware to board

        @:return Returns STDOUT, STDERR and Exit code from download execution
        """
        if self.config is None:
            self.config = config

        if self.jlink_cli_path is None:
            self.jlink_cli_path = self.config['jlink_cli_path']

        if not commander_script:
            commander_script = self.config['commander_script']

        fw_download_command = ("\"{jlink_path}\" "
                               "-Device {jlink_device} "
                               "-if SWD -jtagconf -1,-1 "
                               "-speed {jlink_speed} -autoconnect "
                               "{jlink_autoconnect} "
                               "-CommanderScript {jlink_file} "
                               "-SelectEmuBySN {jlink_sn}")

        stdout = ''
        stderr = ''
        exit_code = 1

        # Check for commander script and executable files
        if not os.path.isfile(commander_script):
            raise ResourceSwdError("Commander script file '%s' does not exist" % commander_script)

        if not os.path.isfile(self.jlink_cli_path):
            raise ResourceSwdError("JLink executable not found at path '%s'" % self.jlink_cli_path)

        jlink_command = fw_download_command.format(jlink_path=self.jlink_cli_path,
                                                   jlink_device=self.config.get('device', self.device),
                                                   jlink_speed=self.config['speed_core'],
                                                   jlink_autoconnect=self.config['auto_connect'],
                                                   jlink_file=commander_script,
                                                   jlink_sn=self.config['serial_number'])

        self.log.info("Executing JLink Command: %s" % jlink_command)

        try:
            process = subprocess.Popen(jlink_command,
                                       shell=True,
                                       stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE)

            stdout, stderr = process.communicate()
            exit_code = process.returncode

        except (OSError, ValueError, subprocess.CalledProcessError):
            self.log.warning("Firmware download command failed - %s", self.get_stack_trace())

        return stdout, stderr, exit_code

    def run_jlink_script(self, commander_script=None, config=None):
        """
        Execute JLink Commander script
        @:return Returns STDOUT, STDERR and Exit code from script execution
        """
        if self.config is None:
            self.config = config

        if self.jlink_cli_path is None:
            self.jlink_cli_path = self.config['jlink_cli_path']

        if not commander_script:
            commander_script = self.config['commander_script']

        fw_download_command = ("\"{jlink_path}\" "
                               "-Device {jlink_device} "
                               "-if SWD -jtagconf -1,-1 "
                               "-speed {jlink_speed} -autoconnect "
                               "{jlink_autoconnect} "
                               "-CommanderScript {jlink_file} "
                               "-SelectEmuBySN {jlink_sn}")

        stdout = ''
        stderr = ''
        exit_code = 1

        # Check for commander script and executable files
        if not os.path.isfile(commander_script):
            raise ResourceSwdError("Commander script file '%s' does not exist" % commander_script)

        if not os.path.isfile(self.jlink_cli_path):
            raise ResourceSwdError("JLink executable not found at path '%s'" % self.jlink_cli_path)

        jlink_command = fw_download_command.format(jlink_path=self.jlink_cli_path,
                                                   jlink_device=self.config.get('device', self.device),
                                                   jlink_speed=self.config['speed_core'],
                                                   jlink_autoconnect=self.config['auto_connect'],
                                                   jlink_file=commander_script,
                                                   jlink_sn=self.config['serial_number'])

        self.log.info("Executing JLink Command: %s" % jlink_command)

        try:
            process = subprocess.Popen(jlink_command,
                                       shell=True,
                                       stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE)

            stdout, stderr = process.communicate()
            exit_code = process.returncode

        except (OSError, ValueError, subprocess.CalledProcessError):
            self.log.warning("Script command failed - %s", self.get_stack_trace())
        return stdout, stderr, exit_code

    def close_jlink_connection(self):
        """
        Close connection to PyLink interface
        """
        self.jlink.close()
        self.log.info('Closed PyLink connection')

    def trace_data(self):
        """Sequence of configuration considering the CORTEX M4 Family"""

        try:
            self.jlink.etm_register_write(self.config['register_lock_address'],
                                          self.config['unlock_access'],
                                          delay=False)
            self.jlink.etm_register_write(self.config['register_ctrl_address'], self.config['trace_setup'], delay=False)
            self.jlink.etm_register_write(self.config['register_status_address'],
                                          self.config['unlock_access'], delay=False)
            self.jlink.etm_register_write(self.config['register_trigger_event_address'],
                                          self.config['trigger_event'], delay=False)
            self.jlink.etm_register_write(self.config['register_enable_start_address'],
                                          self.config['trace_start_stop'], delay=False)
            self.jlink.etm_register_write(self.config['register_enable_trace_address '],
                                          self.config['unlock_access'], delay=False)
        except (pylink.errors.JLinkException, KeyError):
                raise ResourceSwdError("Configuration failed to setup trace data - %s" % self.get_stack_trace())

        while self.config['trace_data_flag'] == 'Enable':
            num_bytes = self.jlink.swo_num_bytes()
            data = self.jlink.swo_read_stimulus(0, num_bytes)
            # This DataOut string will be caught on high level
            sys.stdout.write(''.join(map(chr, data)))
            self.log.info("Extracting data over ITM: %s" % data)

    def execute_command_file(self, command_file_path, config):
        """
        Execute command file

        @param command_file_path: [str] Command file path
        @param config: [str] swd configuration
        """
        if self.config is None:
            self.config = config

        if self.jlink_cli_path is None:
            self.jlink_cli_path = self.config['jlink_cli_path']

        exc_cmd_file = "%s -autoconnect %s -Device %s -If SWD -Speed %s " \
                       "-CommandFile \"%s\"" % (self.jlink_cli_path,
                                                self.config['auto_connect'],
                                                self.config['device'],
                                                self.config['speed'],
                                                command_file_path)
        process = subprocess.Popen(exc_cmd_file)
        _, stderr = process.communicate()
        exit_code = process.returncode
        if exit_code != 0:
            raise ResourceSwdError("Error: %s occurred while executing CommandFile: %s",
                                   self.get_stack_trace(), command_file_path)

    @staticmethod
    def get_stack_trace():
        """Provide the stack trace string"""
        return traceback.format_exc(traceback.extract_stack())


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line

        import unified_modules.test_support.cli_support as cli_support

        class ResourceSwdCli(ResourceSwd, cli_support.CliOptions):
            """
            Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class
            """

            def __init__(self, *args, **kwargs):
                ResourceSwd.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceSwd)

        RUN = ResourceSwdCli()
    else:
        # Unit test works only with real hardware
        # Replace the jlink_cli_path and commander script with JLink real path

        from unified_modules.test_support.testresults import TestResults

        class ResourceSwdUnitTest(ResourceSwd):
            """
            UnitTest for Resource JTAG
            """
            def __init__(self):
                self.results = TestResults()
                self.results.set_test_title('test_resource_swd')
                self.log = self.results.log

            def test_resource_swd(self):
                """
                Test firmware download and read register with 16 and 32 bit length
                """

                config = {"jlink_cli_path": "C:\\Program Files (x86)\\SEGGER\\JLink_V632g\\JLink.exe",
                          "device": "CORTEX-M4",
                          "speed": "50000",
                          "serial_number": "752000673",
                          "ram1_offset": "0x40020400",
                          "commander_script": "fw_download.jlink",
                          "autoconnect": "1"}
                self.set_config_details(config)

                self.results.assert_not_raises(ResourceSwdError,
                                               self.download_firmware_to_board,
                                               "Expected not to raise Error")

                reg_value = self.read_register(address=0x11F)
                self.results.assert_equal(reg_value[0], 0xc400,
                                          "Expected to be equal")

                reg_value = self.read_register(address=0x0)
                self.results.assert_equal(reg_value[0], 0x19000,
                                          "Expected to be equal")

                self.close_jlink_connection()


        TEST_SWD = ResourceSwdUnitTest()
        TEST_SWD.test_resource_swd()
