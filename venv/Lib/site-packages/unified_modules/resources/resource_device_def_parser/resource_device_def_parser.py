"""
@brief
A resource library to parse the Device Definition file.

@details
@b Description
This resource library provides methods read desired field from
Device Definition file.

Supported features:
- Validates an XML device file with SCSDevice Schema
- Method to read device info under DeviceInfo tag from XML
- Method to read register info under Register tag from XML
- Method to read bit fields info under Bit field tag from XML
- Method to read each register information by its name
  and return as list.

@b Usage
By Importing this file and creating an object for ResourceDeviceDefParser

@code
    from resource_device_def_parser import ResourceDeviceDefParser\n
    dv_def_parser = ResourceDeviceDefParser(device_xsd_file='SCSDeviceFile.xsd',
                                            device_xml_file='cs42l75.xml')
@endcode
"""
import os
import sys
import inspect
import xmltodict
import json
import copy
import subprocess
from lxml import etree
import re
import platform
import yaml

if sys.version_info[0] == 3:
    import urllib.request, urllib.parse, urllib.error
    import importlib
    import operator
elif sys.version_info[0] == 2:
    import urllib

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class XmlValidationFailed(Exception):
    """
    Exception class for mismatch of Device file with Device Schema
    """
    def __init__(self, message=None):
        super(XmlValidationFailed, self).__init__(message)


class ElementNotFoundException(Exception):
    """
    Exception class if requested element is not found in the XML
    """
    def __init__(self, message):
        super(ElementNotFoundException, self).__init__(message)


class BitFieldTypeError(Exception):
    """
    Exception class for bit field type
    """
    def __init__(self, message=None):
        super(BitFieldTypeError, self).__init__(message)


class Register(object):
    """
    Class for Device Registers
    """
    def __init__(self, display_name, address, default_value, access, bit_fields):
        self.set_attribute('DisplayName', display_name)
        self.set_attribute('Address', address)
        self.set_attribute('DefaultValue', default_value)
        self.set_attribute('Access', access)
        self.set_attribute('BitFields', bit_fields)

    def set_attribute(self, attr_name, attr_value):
        setattr(self, attr_name, attr_value)

    def __str__(self):
        bit_fields_str = ""
        for bit_field in self.BitFields:
            bit_fields_str += str(bit_field) + ", "
        return "Address: %s, Def val: %s, Access: %s, Bit Fields: %s" \
               % (self.Address, self.DefaultValue,
                  self.Access, bit_fields_str)

    def __getitem__(self, item):
        return getattr(self, item)


class BitField(object):
    """
    Class for Device Bit fields
    """
    def __init__(self, field_name, default_value, access, address, software_access, volatile,
                 test_field, values=[], description=''):
        self.set_attribute('Address', address)
        self.set_attribute('DefaultValue', default_value)
        self.set_attribute('Access', access)
        self.set_attribute('Name', field_name)
        self.set_attribute('Values', values)
        self.set_attribute('BitFieldLocation', re.search(r'(\[.*\])', address).group(1))
        self.set_attribute('SoftwareAccess', software_access)
        self.set_attribute('Volatile', volatile)
        self.set_attribute('Test', test_field)
        self.set_attribute('Description', description)
        if values:
            self.set_attribute('FieldType', self.get_field_type(address, values))
        else:
            self.set_attribute('FieldType', 'text_field')
        tmp_values = []
        for value in self.Values:
            tmp_dict = {}
            for values_dict in value:
                for key,val in values_dict.items():
                    tmp_dict[key] = val
            if tmp_dict != {}:
                tmp_values.append([tmp_dict])
        self.Values = tmp_values

    def set_attribute(self, attr_name, attr_value):
        setattr(self, attr_name, attr_value)

    def __str__(self):
        self.Values = [str(val) for val in self.Values if val is not None]
        if not self.Values:
            return "Field Name : %s, Def Val: %s, Access: %s, Address: %s, FieldType: %s, SoftwareAccess: %s, " \
                   "Volatile: %s, Test: %s, BitFieldLocation: %s"% (self.Name, self.DefaultValue, self.Access, self.Address, self.FieldType,
                                              self.SoftwareAccess, self.Volatile, self.Test, self.BitFieldLocation)
        else:
            return "Field Name : %s, Def Val: %s, Access: %s, Address: %s, FieldType: %s, SoftwareAccess: %s, " \
                   "Volatile: %s, Test: %s, Values: %s, BitFieldLocation: %s" % (self.Name, self.DefaultValue, self.Access,
                                                          self.Address, self.FieldType, self.SoftwareAccess,
                                                          self.Volatile, self.Test, self.Values, self.BitFieldLocation)

    def __getitem__(self, item):
        return getattr(self, item)

    def get_field_type(self, address, values):
        """
        Gets the type of BitField(Can be RadioButton, ComboBox, TextField, Slider)

        @param address: [str] address of bit field
        @param values: [list] values list of bit field
        @return: [str] type of bit field(Can be RadioButton, ComboBox, TextField, Slider)
        """
        bit_width_pattern = re.search('\[(\d+):?(\d+)?\]', address)
        try:
            bit_width = int(bit_width_pattern.group(1)) - int(bit_width_pattern.group(2))
        except TypeError:
            bit_width = int(bit_width_pattern.group(1))
        if bit_width == 0:
            bit_width = 1
        num_of_values = len(values)
        if num_of_values == 2:
            attributes = [attr_key for val in values[0] for attr_key in list(val.keys())]
            if all(i in attributes for i in ['End', 'Start', 'Multiplier']):
                bit_type = 'slider'
            else:
                bit_type = 'radio_button'
        elif (bit_width > 1 and num_of_values > 2) or (bit_width == 1 and num_of_values != 2):
            is_slider_checks = []
            is_slider = False
            for value in values:
                for value_dict in value:
                    value_keys = list(value_dict.keys())
                    value_keys.sort()
                    if self.compare_value_keys(value_keys):
                        is_slider = True
                is_slider_checks.append(is_slider)
            if all(is_slider_checks):
                bit_type = 'slider'
            else:
                bit_type = 'combo_box'
        elif num_of_values == 1:
            attributes = [attr_key for val in values[0] for attr_key in list(val.keys())]
            if all(i in attributes for i in ['End', 'Start', 'Multiplier']):
                bit_type = 'slider'
            else:
                bit_type = 'text_field'
        else:
            raise BitFieldTypeError('Unable to get bit field type of : %s' % address)
        return bit_type

    @staticmethod
    def compare_value_keys(value_keys):
        """
        Return True when values_keys match with ['End', 'Start'] or ['End', 'Position', 'Start']
        """
        if sys.version_info[0] == 3:
            if operator.eq(['End', 'Start'], value_keys) == 0 or\
                    operator.eq(['End', 'Position', 'Start'], value_keys) == 0:
                return True
        elif sys.version_info[0] == 2:
            if cmp(['End', 'Start'], value_keys) == 0 or\
                    cmp(['End', 'Position', 'Start'], value_keys) == 0:
                return True
        return False


class ResourceDeviceDefParser(object):
    """
    Generic parser for all Device definition files.
    """
    def __init__(self):
        """
        Initialise
        """
        self.log = logging.getLogger(ResourceDeviceDefParser.__name__)
        self.etree_root = None
        self.device_xml_file = None
        self.verify_bsp_exe = os.path.abspath(os.path.join(os.path.dirname(__file__),
                                              "verify_bsp_bin"))
        self.reg_width = None
        self.xml_version = None
        self.project_name = None

    def set_config_details(self, device_xml_file, internal=False):
        self.device_xml_file = device_xml_file
        if internal:
            self.bsp_type = "internal"
        else:
            self.bsp_type = "external"

    def validate_dev_def_file(self):
        """
        Validates the device xml file using VerifyBSP.exe tool.
        Parses the device xml file if the xml is valid

        @throws XmlValidationFailed If any error os thrown by Subproces module
        @throws XmlValidationFailed if the xml file is not valid with
                                    given xsd file
        @throws XmlValidationFailed If platform is other than Windows
        @return Stdout of VerifyBSP executable
        """
        if platform.system() == "Windows":
            if self.bsp_type == "internal":
                command = '%s\VerifyBSP.exe -di "%s"' % (self.verify_bsp_exe,
                                                         self.device_xml_file)
            else:
                command = '%s\VerifyBSP.exe -d "%s"' % (self.verify_bsp_exe,
                                                        self.device_xml_file)
            try:
                verify_bsp_cmd = subprocess.Popen(command, stdout=subprocess.PIPE,
                                                  stderr=subprocess.PIPE,
                                                  shell=True)
                verify_bsp_stdout = verify_bsp_cmd.communicate()[0]
            except (subprocess.CalledProcessError, IndexError, OSError) as e:
                raise XmlValidationFailed(e)

            if not "Looks good! Device file passes schema validation," \
                   " load and semantic tests" in verify_bsp_stdout:
                raise XmlValidationFailed(verify_bsp_stdout)
            else:
                self.log.info(verify_bsp_stdout)
        else:
            raise XmlValidationFailed("Validation of Xml file can be only done on Windows platform")
        return verify_bsp_stdout

    def parse_dev_def_file(self, dev_def_file=None, xml_version="", project_name="", xml_name=""):
        if dev_def_file:
            self.device_xml_file = dev_def_file
        if self.device_xml_file is None:
            if xml_version and project_name and xml_name:
                if xml_version != 'latest':
                    xml_version = 'e' + xml_version
                file_url = r"http://crystal.cirrus.com/~%s/trunk/registers/%s/%s_external_regs_scs.xml" % \
                           (project_name, xml_version, xml_name)
                self.log.debug("Device xml file path:%s", file_url)
                if sys.version_info[0] == 3:
                    self.device_xml_file = urllib.request.urlretrieve(file_url)[0]
                elif sys.version_info[0] == 2:
                    self.device_xml_file = urllib.urlretrieve(file_url)[0]

                self.doc_version = xml_version
                if not os.path.exists(self.device_xml_file):
                    raise IOError("File %s not found" % self.device_xml_file)
            else:
                raise RuntimeError("Mandatory input parameter xml_version or project_name xml_name missing")

        try:
            with open(self.device_xml_file, 'rU') as xml_con:
                self.etree_root = etree.XML(xml_con.read())
        except etree.XMLSyntaxError:
            raise IOError("Invalid xml file format for %s" % self.device_xml_file)

    def parse_datasheet_file(self, bsp_name, mode_and_bsp_type=None):
        """
        Parse the datasheet file to compare datasheet values with the device definition xml file
        """
        # Just to fill 0s to make the version as always 4 digits
        self.doc_version = self.get_datasheet_file_number().zfill(4)
        if mode_and_bsp_type:
            bsp_type = mode_and_bsp_type
        else:
            bsp_type = self.bsp_type
        file_url = r"http://crystal.cirrus.com/~%s/trunk/registers/e%s/%s_systems_debug_%s_regs_scs.xml" % (
            bsp_name, self.doc_version, bsp_name, bsp_type)
        if sys.version_info[0] == 3:
            self.datasheet_file = urllib.request.urlretrieve(file_url)[0]
        elif sys.version_info[0] == 2:
            self.datasheet_file = urllib.urlretrieve(file_url)[0]

        if os.path.exists(self.datasheet_file):
            self.parse_dev_def_file(self.datasheet_file)
            self.datasheet_register_class_dict = self.get_register_class_dict()
            return self.datasheet_register_class_dict
        else:
            raise IOError("File %s not found" % self.datasheet_file)

    def get_device_info(self):
        """
        Gets the information matching with device tag and returns device type value
        @return System Device Information
        """
        try:
            find_text = etree.XPath("//DeviceInfo/*")
        except IndexError:
            raise ElementNotFoundException("Device Info element is not present")
        dev_info_tags = find_text(self.etree_root)
        device_info_xml = dev_info_tags[0].getparent()
        str_xml = etree.tostring(device_info_xml)
        device_info_ord_dict = xmltodict.parse(str_xml)
        device_info_json = (json.dumps(device_info_ord_dict))
        device_info_dict = json.loads(device_info_json)
        dev_info = device_info_dict['DeviceInfo']
        return dev_info

    def construct_reg_class_dict(self, all_reg_info_dict, all_fields_info_dict):
        """
        Construct a register class dictionary,with key as register name and value as register
        object,register object has some of the attributes of register and also bit field objects
        associated with value of that register.
        @param all_reg_info_dict All registers info
        @param all_fields_info_dict All bit fields info
        @return constructed register class dictionary
        """
        register_class_dict = {}
        common_bit_fields = {}
        for reg_dict in all_reg_info_dict:
            reg_address = reg_dict.get('Address')
            reg_default_value = reg_dict.get('DefaultValue')
            if reg_default_value is None:
                reg_default_value = '0x' + '0' * int(self.get_register_width() / 4)
            reg_access = reg_dict.get('Access')
            display_name = reg_dict.get('DisplayName')
            reg_name = reg_dict.get('Name')
            bit_field_objects = []
            for bit_field in all_fields_info_dict:
                bit_field_pattern = re.compile(r'^%s\[.*\]$' % reg_name)
                if bool(bit_field_pattern.search(str(bit_field.get('Address')))):
                    field_name = bit_field.get('Name')
                    field_address = bit_field.get('Address')
                    field_default_value = bit_field.get('DefaultValue')
                    if field_default_value is None:
                        field_default_value = '0x' + '0' * self.get_bit_width(":".join(field_address))
                    field_access = bit_field.get('Access')
                    software_access = bit_field.get('SoftwareAccess')
                    volatile = bit_field.get('Volatile')
                    test_field = bit_field.get('Test')
                    possible_values = []
                    description = bit_field.get('Description')
                    try:
                        possible_values = bit_field.get('Values', None)
                        if possible_values is None:
                            possible_values = []
                    except:
                        pass
                    field_obj = BitField(field_name, field_default_value, field_access,
                                         field_address, software_access, volatile, test_field,
                                         possible_values, description)
                    bit_field_objects.append(field_obj)
                    if "+" in str(bit_field.get('Address')):
                        common_bit_fields[field_name] = [field_obj,
                                                         bit_field.get('Address').split("+")]
            if display_name is None:
                register_name = reg_name
            else:
                register_name = display_name
            register_obj = Register(register_name, reg_address, reg_default_value, reg_access, bit_field_objects)
            register_class_dict[register_name] = register_obj
        register_class_dict = self.update_common_bit_fields(common_bit_fields, register_class_dict)
        return register_class_dict

    @staticmethod
    def get_bit_width(bit_field_location):
        """
        This method returns bit field width based on bit field location
        """
        bit_width = None
        if ':' in bit_field_location:
            bit_field_locations = [int(index) for index in bit_field_location.split(':')]
            bit_field_locations.sort()
            if bit_field_locations[0] == 0:
                bit_width = bit_field_locations[1] + 1
            else:
                bit_width = (bit_field_locations[1] - bit_field_locations[0]) + 1
        else:
            if bit_field_location == '0':
                bit_width = 1
            else:
                bit_width = int(bit_field_location)
        return bit_width

    def get_register_class_dict(self):
        """
        Populates the register_class dictionary with register name as key and
        register class object as value.
        @return register class dictionary
        """
        reg_info_dict = self.get_each_register_info()
        bit_field_info = self.get_each_bit_field_info()
        self.register_class_dict = self.construct_reg_class_dict(reg_info_dict, bit_field_info)
        return self.register_class_dict

    def get_each_register_info(self):
        """
        Gets all Information of every register by its name.
        @return list of dictionaries,each has info of corresponding register.
        """
        reg_info_dict = []
        find_text = etree.XPath('//Registers/*')
        register_tags = find_text(self.etree_root)
        for index, register_tag in enumerate(register_tags):
            device_reg_dict = {}
            for register_children in register_tag.getchildren():
                device_reg_dict[register_children.tag] = register_children.text
            for reg_key in list(device_reg_dict.keys()):
                if str(type(reg_key)) == "<type 'cython_function_or_method'>":
                    del device_reg_dict[reg_key]
            reg_info_dict.append(device_reg_dict)
        return reg_info_dict

    def get_each_bit_field_info(self):
        """
        Gets all Information of every register by its name.
        @return list of dictionaries,each has info of corresponding register.
        """
        if sys.version_info[0] == 3:
            importlib.reload(sys)
        elif sys.version_info[0] == 2:
            reload(sys)
            sys.setdefaultencoding('utf8')

        reg_info_dict = []
        find_text = etree.XPath('//Fields/*')
        register_tags = find_text(self.etree_root)
        for index, register_tag in enumerate(register_tags):
            device_reg_dict = {}
            for register_children in register_tag.getchildren():
                if register_children.getchildren():
                    device_reg_dict[register_children.tag] = []
                    values = register_children.getchildren()
                    for value_child in values:
                        values_children = [{str(ch.tag): str(ch.text)} for ch in value_child.getchildren()]
                        value = dict(value_child.attrib)
                        if value:
                            values_children.append(value)
                        device_reg_dict[register_children.tag].append(values_children)
                else:
                    device_reg_dict[register_children.tag] = register_children.text
            reg_info_dict.append(device_reg_dict)
        return reg_info_dict

    def get_register_width(self):
        """
        Returns the width of the register
        """
        find_text = etree.XPath("//Registers")
        try:
            matched_text = find_text(self.etree_root)[0]
        except IndexError:
            raise ElementNotFoundException("Register width not found")
        return int(matched_text.attrib.get('Width'))

    def get_field_info(self, dv_field_key, device_fields=None):
        """
        Gets the information matching with tag and return it as a dictionary
        from device_fields dictionary

        @param dv_field_key: Can be any tag under root or value of any tag
        @param device_fields optional device fields dictionary
        @return list of all matching values associated with key dv_field_key
        """
        fields_tag = None
        for child in self.etree_root.getchildren():
            if child.tag == dv_field_key:
                fields_tag = dv_field_key
        if fields_tag:
            str_xml = etree.tostring(self.etree_root)
        else:
            try:
                find_text = etree.XPath("//*[starts-with(text(), '%s')]" % dv_field_key)
                text = find_text(self.etree_root)
            except IndexError:
                raise ElementNotFoundException("Element is not found")
            else:
                for tx in text:
                    parent_text = tx.getparent()
                    str_xml = etree.tostring(parent_text)
                    device_fields_xml = xmltodict.parse(str_xml)
                    device_fields_json = (json.dumps(device_fields_xml))
                    device_fields_dic = json.loads(device_fields_json)

    def get_datasheet_file_number(self):
        if not os.path.exists(self.device_xml_file):
            raise ElementNotFoundException("xml file %s is not found" % self.device_xml_file)
        pattern = '# GENERATED: Publish #'
        with open(self.device_xml_file, 'r') as xml_file:
            for line in xml_file:
                if pattern in line:
                    file_number = line.replace(pattern, "")
                    file_number = re.sub('\D', "", file_number.split()[0])
                    return file_number

    def get_system_file(self, system_xml_path):
        if not os.path.exists(system_xml_path):
            raise ElementNotFoundException("xml file %s is not found" % system_xml_path)
        with open(system_xml_path, 'r') as f:
            for line in f:
                if '@file' in line:
                    system_file_match = re.search('[\w]+\..*', line)
                    if system_file_match and 'xml' in system_file_match.group(0):
                        return system_file_match.group(0)
                    else:
                        raise ElementNotFoundException("device file name not found in system xml file")

    def get_registers_to_skip(self, skip_registers_yml):
        with open(skip_registers_yml, 'r') as stream:
            skip_registers = yaml.safe_load(stream)
            return skip_registers

    def get_regname_for_field(self, field_name):
        all_fields = self.get_each_bit_field_info()
        for field in all_fields:
            if field.get('Name') == field_name:
                return field['Address'].split('[')[0]

    def update_common_bit_fields(self, common_bit_fields, register_class_dict):
        """
        Update register and bit field data structures with registers having common bit field
        @param common_bit_fields: [list] Registers having common bit field
        @param register_class_dict: [dict] register class dictionary
        @return: [dict] Updated register class dictionary
        """
        # Iterating through all bit fields in each registers,if a bit field spans
        # across multiple registers,then update the Bit field Address and BitFieldLocation
        # if bit field already exists in register or else create the bit field
        # with its configuration and update the bit field address and bit field
        # location
        # After updating bit field object the BitFieldLocation is number of locations
        # occupied by the bit field in a register and Bit field Address corresponds to
        # register name + number of locations occupied by the bit field(sum of
        # all locations occupied by bit field in each register it belongs).
        for reg_name, reg_ob in register_class_dict.items():
            for bit_field in reg_ob.BitFields:
                bit_field_name = bit_field.Name
                if bit_field_name in list(common_bit_fields.keys()):
                    bit_field_info = common_bit_fields[bit_field_name][0]
                    registers = common_bit_fields[bit_field_name][1]
                    bit_field_len = self.cal_bit_width(registers)
                    for register in registers:
                        bit_field_loc = re.search(r'\[.*\]', register).group()
                        _register_name = re.search(r'(.*)\[.*\]', register).group(1)
                        field_present = False
                        for index, _bit_field in enumerate(register_class_dict[_register_name].BitFields):
                            if bit_field_name == _bit_field.Name:
                                _bit_field.Address = _register_name + bit_field_len
                                _bit_field.BitFieldLocation = bit_field_loc
                                field_present = True
                                register_class_dict[_register_name].BitFields[index] = _bit_field
                        if not field_present:
                            bit_field_info.Address = _register_name + bit_field_len
                            bit_field_info.BitFieldLocation = bit_field_loc
                            register_class_dict[_register_name].BitFields.append(bit_field_info)
                        register_class_dict = copy.deepcopy(register_class_dict)
        return register_class_dict

    def cal_bit_width(self, field_addresses):
        """
        Calculate bit field width for a bit field which spans multiple registers
        @param field_addresses: [str] bit field address tag
        @return: Bit width of bit field
        """
        # Calculating the number of locations occupied by bit field through its
        # Address value, going through each register name and parsing the number
        # locations,summing up the address and form bit field address
        mat = re.search(r'\[(\d+(:\d+)?)\]', field_addresses[0])
        wid_str = mat.group(1)
        if ":" in wid_str:
            wid_str = [int(index) for index in wid_str.split(':')]
            wid_str.sort()
            strt_index = wid_str[0]
            bit_w = wid_str[1] - strt_index
        else:
            strt_index = int(wid_str)
            bit_w = strt_index
        for index in range(1, len(field_addresses)):
            mat = re.search(r'\[(\d+(:\d+)?)\]', field_addresses[index])
            wid_str = mat.group(1)
            if ":" in wid_str:
                wid_str = [int(index) for index in wid_str.split(':')]
                wid_str.sort()
                bit_w += wid_str[1] - wid_str[0]
            else:
                strt_index = int(wid_str)
                bit_w += strt_index
            bit_w += 1
        return '[%s:%s]' % (bit_w, strt_index)

    def get_reg_and_bit_field_names(self):
        """
        Return register and bit field names as list
        @return: [list] register name bit field names
        """
        find_text = etree.XPath('//Registers/*')
        register_tags = find_text(self.etree_root)
        reg_bitfield_names = []
        for index, register_tag in enumerate(register_tags):
            for register_children in register_tag.getchildren():
                if register_children.tag == "Name":
                    reg_name = register_children.text
                    reg_name = reg_name.replace('[', "_")
                    reg_name = reg_name.replace(']', "")
                    reg_bitfield_names.append(reg_name)
        find_text = etree.XPath('//Fields/*')
        field_tags = find_text(self.etree_root)
        for index, field_tag in enumerate(field_tags):
            for field_children in field_tag.getchildren():
                if field_children.tag == "Name":
                    field_name = field_children.text
                    field_name = field_name.replace('[', "_")
                    field_name = field_name.replace(']', "")
                    reg_bitfield_names.append(field_name)
        reg_bitfield_names = list(set(reg_bitfield_names))
        return reg_bitfield_names

    def get_reg_names(self, regex=".*"):
        """
        Return register names as list
        @return: [list] register names
        """
        find_text = etree.XPath('//Registers/*')
        register_tags = find_text(self.etree_root)
        reg_names = []
        for index, register_tag in enumerate(register_tags):
            for register_children in register_tag.getchildren():
                if register_children.tag == "Name":
                    reg_name = register_children.text
                    reg_name = reg_name.replace('[', "_")
                    reg_name = reg_name.replace(']', "")
                    if re.search(regex, reg_name):
                        reg_names.append(reg_name)
        return reg_names

    def get_register_address(self, register_name):
        """
        Get register address giving the register name
        @param register_name: [str] register name to get the address
        @return: [Register Address |None]
        """
        self.get_register_attr(register_name, "Address")

    def get_register_default(self, register_name):
        """
        Get register default value giving the register name
        @param register_name: [str] register name to get the default value
        @return: [Register Default value |None]
        """
        register_info = self.register_class_dict.get(register_name)
        if register_info:
            return register_info['DefaultValue']

    def get_bit_field_default(self, bit_field_name, register_name=None):
        """
        Returns the default value of a bitfield

        @param bit_field_name: [str] Bit field name
        @param register_name: [str] Register name of the bit field
        @return: [str] default value of bit field
        """
        bit_field_info = self.get_bit_field_info(bit_field_name, register_name)
        return bit_field_info['DefaultValue']

    def get_bit_field_info(self, bit_field_name, register_name=None):
        """
        Returns bit field info

        @param bit_field_name: [str] Bit field name to look in register_info
        @param register_name: [str] Register name of the bit field
        @return: [dict] Bit field info
        """
        if not register_name:
            register_name = self.get_regname_for_field(bit_field_name)

        register_info = self.register_class_dict[register_name]
        for field in register_info['BitFields']:
            if field['Name'] == bit_field_name:
                return field

    def get_register_attr(self, register_name, attr_name):
        """
        Returns a register attribute by its Name or DisplayName
        @param register_name: [str] Register Name or DisplayName
        @param attr_name: [str] Register attribute Key
        @return: [str] Register attribute value
        """
        find_text = etree.XPath('//Registers/*')
        register_tags = find_text(self.etree_root)
        for index, register_tag in enumerate(register_tags):
            reg_children = register_tag.getchildren()
            reg_details = {reg.tag: reg.text for reg in reg_children}
            if reg_details.get("Name") == register_name or reg_details.get("DisplayName"):
                return reg_details[attr_name]

    def get_bit_fields_of_reg(self, reg_name):
        """
        Returns a dictionary with bit field as key and field name as value
        @param reg_name: [str] Register Name
        @return: [dictionary] Bit field as key and field name as value
        """
        bit_fields_with_index = {}
        with open(self.device_xml_file, 'r') as file_handler:
            file_data = file_handler.read()
        regex = r"<Name>(.*?)<\/Name>\s*.*?%s\[(\d+(:\d+)?)]" % reg_name
        matches = re.finditer(regex, file_data, re.MULTILINE)
        for matchNum, match in enumerate(matches, start=1):
            bit_fields_with_index[match.group(2)] = match.group(1)
        return bit_fields_with_index


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceDeviceDefParserCli(ResourceDeviceDefParser, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceDeviceDefParser.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceDeviceDefParser)

        RUN = ResourceDeviceDefParserCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest

        DEVICE_SCHEMA = "SCSDeviceFile.xsd"
        DEVICE_XML = "C:\ProgramData\Cirrus Logic\SCS_1.4\devices\cs42l75\cs42l75.xml"
        AUDIOHUB_FPGA = r"C:\ProgramData\Cirrus Logic\SCS_1.4\devices\audiohub_fpga\audiohub" \
                        r"_fpga.xml"

        class ResourceDeviceDefParserUnittests(BaseTest):
            def setup(self):
                self.record_test_name()

            def test1_dv_def_parsing(self):
                self.result.test_step(inspect.currentframe().f_code.co_name +
                                      " - Parsing cs2300 xml")
                self.device_parser.set_config_details(DEVICE_SCHEMA, DEVICE_XML)
                self.device_parser.validate_parse_dev_def_file()
                self.device_parser.get_register_width('Device Cfg 1')
                self.result.assert_equal([], self.device_parser.get_device_info("DevInfo"),
                                         "Expected Pass")
                self.result.assert_equal("CS2300", self.device_parser.get_device_info("Type")[0],
                                         "Expected Pass, Type : CS2300")
                self.result.assert_equal([{'ControlInterface': [
                    {'DeviceAddress': ['0x9C', '0x9E'], 'InterfaceProtocol': 'SMbus_8inx_8dat'}]}],
                    self.device_parser.get_device_info("ControlInterfaces")[0], "Expected Pass")
                self.result.assert_equal(
                    {'Name': 'Device Cfg 1', 'DefaultValue': '0x0', 'Access': 'R/W',
                     'Address': '0x3', 'IsPageRegister': 'false', 'Page': '0x0'},
                    self.device_parser._get_register_info("Device Cfg 1")[0], "Expected Pass")
                self.result.assert_equal({'Access': 'R/W', 'DefaultValue': '0x0', 'Name': 'ISBH',
                                          'Address': '32-Bit Ratio MSB-8[7:0]'},
                    self.device_parser.get_field_info("ISBH")[0], "Expected Pass")

            def test2_dv_def_parsing(self):
                self.result.test_step(inspect.currentframe().f_code.co_name +
                                      " - Parsing AUDIOHUB_FPGA xml")
                self.device_parser.set_config_details(DEVICE_SCHEMA, AUDIOHUB_FPGA)
                self.device_parser.validate_parse_dev_def_file()
                self.result.assert_equal([], self.device_parser.get_device_info("DevInfo"),
                                         "Expected Pass")
                self.result.assert_equal("AUDIOHUB_FPGA",
                                         self.device_parser.get_device_info("Type")[0],
                                         "Expected Pass")
                self.result.assert_equal("SMbus_8inx_8dat",
                    self.device_parser.get_device_info("InterfaceProtocol")[0], "Expected Pass")
                self.result.assert_equal(
                    {'Access': 'R/W', 'DefaultValue': '0x0', 'Name': 'System Control',
                     'Address': '0x3'}, self.device_parser.construct_reg_class_dict("System Control")[0],
                    "Expected Pass")

                self.result.assert_equal({'Access': 'R/W', 'DefaultValue': '0x0', 'Values':
                    [{'Value': [[{'attrib': {'Value': '0x0'}}, {'Type': 'Label',
                                                                 'Description': 'Output'}],
                    [{'attrib': {'Value': '0x1'}}, {'Type': 'Label', 'Description': 'Input'}]]}],
                                          'Name': 'DEV_AIF3_SCLK_DIR',
                                          'Address': 'Signal Direction Control 3[7]'},
                    self.device_parser.get_field_info("DEV_AIF3_SCLK_DIR")[0], "Expected Pass")

            def initiate(self):
                self.device_parser = ResourceDeviceDefParser()
                self.test1_dv_def_parsing()
                self.test2_dv_def_parsing()

            def complete(self):
                self.result.assert_equal("PPPPPPPPPP : PASS",
                                         "%s : %s" % (self.result.step_outcome(),
                                                      self.result.get_overall_outcome()),
                                         "Expected Pass")

            def teardown(self):
                self.result.report_result_to_tf()

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceDeviceDefParserUnittests(result=RESULTS)
        TEST.run()
