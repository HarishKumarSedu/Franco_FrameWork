"""
@brief
A resource library to use Keithley 2000 Digital Multimeter.

@Description
This resource library provide a simplified wrapper for
the most common commands for the Device

Supported Features:
- Connect to Device
- Get Full Device Name
- Read Configuration
- Write Configuration
- Measure a metric

Supported Metrics:
- Voltage AC/DC
- Current AC/DC

@b Usage
@code
resource = ResourceDmm()
resource.setup("ASRL5::INSTR")
@endcode

"""

import visa
import sys
from collections import namedtuple

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


_DMM_CMDS = namedtuple('DMM_CMDS', 'DC_VOLTAGE AC_VOLTAGE DC_CURRENT AC_CURRENT')
DMM_CMDS = _DMM_CMDS("VOLT:DC", "VOLT:AC", "CURR:DC", "CURR:AC")


class ResourceDmmError(Exception):
    """Exception class for ResourceDmm"""
    pass


class ResourceDmm(object):
    """
    Class which encapsulates SCPI API for Digital Multimeter
    """

    def __init__(self):
        self.log = logging.getLogger(ResourceDmm.__name__)
        self.device = None

    def setup(self, resource_id):
        """
        Connects with a DMM using the resource ID
        @param resource_id: [str] VISA ID for DMM
        """
        resource_manager = visa.ResourceManager()
        device_list = resource_manager.list_resources()
        if resource_id not in device_list:
            excep_msg = "Unable to find resource with resource id %s in the list of resources %s" % (
                resource_id, device_list)
            raise ResourceDmmError(excep_msg)

        self.device = resource_manager.open_resource(resource_id, read_termination='\r')
        self.log.info("Connected to Device: %s", self.get_dmm_id())

    def get_dmm_id(self):
        """
        Get Full Device Name

        @return: [str]
        """
        return self.device.query("*IDN?")

    def read_configuration(self):
        """
        Reads the current configuration from the device

        @return: [str] Current DMM configuration type,
            "VOLT:DC", "CURR:AC", ...
        """
        return self.device.query("CONF?")[1:-1]

    def write_configuration(self, config_type):
        """
        Write/Change DMM configuration
        @param config_type: [str] Configuration type to be written to DMM
        """
        self.device.write("CONF:" + config_type)

    def read_measurement(self, metric_type):
        """
        Read the requested measurement
        @param metric_type: [str] type of measurement to be executed

        @return: [float] the value of the measurement in _metric type_
        """
        return float(self.device.query("MEASure:" + metric_type + "?"))


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceDmmCli(ResourceDmm, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceDmm.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceDmm)
        RUN = ResourceDmmCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest

        class ResourceDmmUnitTest(BaseTest):
            def __init__(self, result):
                super(ResourceDmmUnitTest, self).__init__(result)
                self.dmm = None

            def setup(self):
                self.record_test_name()
                self.dmm = ResourceDmm()

            def initiate(self):
                # Connect to DMM
                self.dmm.setup("ASRL5::INSTR")
                manufacturer, model = self.dmm.get_dmm_id().split(",")[:2]

                # Verify Name
                self.result.assert_equal(manufacturer, "KEITHLEY INSTRUMENTS INC.",
                                         "Verifying Manufacturer")
                self.result.assert_equal(model, "MODEL 2000", "Model")

                self.dmm.write_configuration(DMM_CMDS.DC_VOLTAGE)
                dmm_config = str(self.dmm.read_configuration())

                self.result.assert_equal(dmm_config, DMM_CMDS.DC_VOLTAGE,
                                         "Configuration should be Voltage DC after setting it")

                voltage = self.dmm.read_measurement(DMM_CMDS.DC_VOLTAGE)
                self.result.assert_almost_equal(voltage, 0, 0.2, "Voltage almost 0,")

                self.dmm.write_configuration(DMM_CMDS.DC_CURRENT)
                dmm_config = self.dmm.read_configuration()
                self.result.assert_equal(dmm_config, DMM_CMDS.DC_CURRENT, "Configuration should be Current DC")

            def teardown(self):
                self.dmm.write_configuration(DMM_CMDS.DC_VOLTAGE)

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceDmmUnitTest(result=RESULTS)
        TEST.run()
