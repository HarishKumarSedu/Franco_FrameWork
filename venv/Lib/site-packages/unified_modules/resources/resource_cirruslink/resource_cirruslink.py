#!/usr/bin/env python
"""
@brief
A resource library to interact with audio hub.

@Description:
Features supported:
- Start and stop cirrus link using audio hub.
@b Usage
@code
cirruslink = ResourceCirrusLink()
@endcode
"""
import sys
import platform
import paramiko
import socket
import re
from subprocess import Popen, PIPE
from collections import namedtuple

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

_CONN_TYPES = namedtuple('CONN_TYPES', 'SSH SCSLINK TCP')
CONN_TYPES = _CONN_TYPES('ssh', 'scslink', 'tcp')

_HW_TYPES = namedtuple('HW_TYPES', 'AUDIOHUB TUNINGHUB')
HW_TYPES = _HW_TYPES('ah', 'th')

class CirrusLinkError(Exception):
    """Define CirrusLinkError Exception type"""
    pass


class ResourceCirrusLink(object):
    """
     A resource library to interact with audio hub.
    """
    def __init__(self):
        self.log = logging.getLogger(ResourceCirrusLink.__name__)
        self.username = 'root'
        self.password = 'crus'
        self.ipaddress = None
        self.port = 22
        self.cirruslink_session = None
        self.cirrus_link_service = 'service cirruslink'
        self.conn_type = CONN_TYPES.SSH
        self.i2c_device_address = None
        self.device_id = '/dev/i2c-0'
        self.speed = 0b010
        self.register_map_size = 0b010
        self.transfer_length = None
        self.cirruslink_start_cmd = ""
        self.cirruslink_stop_cmd = ""
        self.cirruslink_restart_cmd = ""
        self.cirruslink_status_cmd = ""
        self.linux_version = ""
        self.hw_type = HW_TYPES.AUDIOHUB

    def set_config_details(self, config):
        self.username = config.get('username', 'root')
        self.password = config.get('password', 'crus')
        self.ipaddress = config['ipaddress']
        self.port = config.get('port', 22)
        self.conn_type = config.get('conn_type', CONN_TYPES.SSH)
        self.i2c_device_address = config.get('i2c_device_address', None)
        self.device_id = config.get('device_id', '/dev/i2c-0')
        self.speed = config.get('speed', 0b010)
        self.register_map_size = config.get('register_map_size', 0b010)
        self.transfer_length = config.get('transfer_length', None)
        self.hw_type = config.get('hw_type', HW_TYPES.AUDIOHUB)

    def validate_ip(self):
        """
        This method will validate whether cirruslink ipaddress is reachable or not
        """
        if platform.system()=='Darwin':
            pingstatus = Popen(['ping', self.ipaddress, '-c', '1'], stdout=PIPE)
        else:
            pingstatus = Popen(['ping', self.ipaddress, '-n', '1'], stdout=PIPE)
        output = pingstatus.communicate()[0]
        hostalive = pingstatus.returncode
        # check the response...
        if hostalive == 0 and not b'unreachable' in output:
            self.log.info(" %s is reachable " % self.ipaddress)
        else:
            raise RuntimeError("cirrus link %s is not reachable " % self.ipaddress)

    def verify_cirruslink_status(self):
        """
        This method will verify whether cirruslink service is available or not
        @return: [bool] True/False true if service is available else false
        """
        _, stdout, stderr = self.cirruslink_session.exec_command('%s status' % self.cirrus_link_service)
        stdout = stdout.read()
        if 'Active: inactive (dead)' in stdout:
            self.log.error("CirrusLink service is not available")
            return False
        return True

    def connect(self):
        """
        This method will connect to cirruslink
        @return: [bool] True/False False if cirruslink service is not available else True
        """
        self.validate_ip()
        if self.conn_type == CONN_TYPES.SSH:
            self.cirruslink_session = paramiko.SSHClient()
            self.cirruslink_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        elif self.conn_type == CONN_TYPES.TCP:
            self.cirruslink_session = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if not self.cirruslink_session:
            raise CirrusLinkError("Failed to initiate CirrusLink")
        self.log.info("CirrusLink initiated")
        try:
            if self.conn_type == CONN_TYPES.SSH:
                self.cirruslink_session.connect(self.ipaddress, port=self.port, username=self.username,
                                                password=self.password)
                if self.hw_type == HW_TYPES.AUDIOHUB:
                    self.linux_version = self.read_linux_version()
                    self.update_cirruslink_commands()
                    scs_link_stdin, _, _ = self.cirruslink_session.exec_command(self.cirruslink_start_cmd)
                    scs_link_stdin.flush()
            elif self.conn_type == CONN_TYPES.TCP:
                self.cirruslink_session.connect((self.ipaddress, self.port))
        except socket.error:
            raise CirrusLinkError('Failed to start CirrusLink %s', self.hw_type)
        self.log.info("CirrusLink Started %s",self.hw_type)
        return True

    def disconnect(self):
        """
        This method will disconnect to cirruslink
        """
        if self.conn_type == CONN_TYPES.SSH:
            scs_link_stdin, _, _ = self.cirruslink_session.exec_command(self.cirruslink_stop_cmd)
            scs_link_stdin.flush()
            self.cirruslink_session.close()
        elif self.conn_type == CONN_TYPES.TCP:
            self.cirruslink_session.close()
        self.log.info("CirrusLink Stopped")

    def write_register(self, register_address, values_to_write):
        """
        Write value to a register
        @param register_address: register address
        @param values_to_write: values to write
        """
        values_to_write = self.convert_hex_to_cirruslink_format(values_to_write)
        command_to_write = 'xi2c -d {device_to_use} -s {speed} -p {i2c_address} -a write -r {register_map_value}' \
                           ' -z {register_map_size} -l {length_of_transfer} ' \
                           '-v {value}'.format(device_to_use=self.device_id, speed=self.speed,
                                               i2c_address=self.i2c_device_address,
                                               register_map_value=register_address,
                                               register_map_size=self.register_map_size,
                                               length_of_transfer=self.transfer_length,
                                               value=values_to_write)
        self.cirruslink_session.exec_command(command_to_write)

    def read_register(self, register_address):
        """
        This method will return value of a desired register.
        @param register_address: address of a register
        @return: [str] register value as String
        """
        command_to_read = 'xi2c -d {device_to_use} -s {speed} -p {i2c_address} -a read -r {register_map_value} ' \
                          '-z {register_map_size} ' \
                          '-l {length_of_transfer}'.format(device_to_use=self.device_id,
                                                           speed=self.speed,
                                                           i2c_address=self.i2c_device_address,
                                                           register_map_value=register_address,
                                                           register_map_size=self.register_map_size,
                                                           length_of_transfer=self.transfer_length)
        stdin, stdout, stderr = self.cirruslink_session.exec_command(command_to_read)
        register_value = self.convert_cirruslink_format_to_int(stdout.readlines()[0].strip())
        return register_value

    def write_to_field(self, field_name, value, string_value=False, raise_excep_on_fail=False):
        """
        Write a value to a field on the device.
        [TO BE IMPLEMENTED]

        @param field_name: [string] name of field where value will be written
        @param value: [long] value for writing to field
        @return: None
        """
        pass

    def read_modify_write(self, value, address, mask=0xFFFFFFFF):
        """
        Write a value to a maskable register.

        @param value: [int] value for writing
        @param address: [int] address to update
        @param mask: [int] bitwise mask to allow update
        @return: None
        """
        # Read
        reg_val = self.read_register(hex(address))
        reg_val &= mask
        # Modify
        set_bits = mask & value
        reg_val |= set_bits
        # Write
        self.write_register(hex(address), self.int_to_audiohub_format(reg_val))

    def convert_cirruslink_format_to_int(self, cirruslink_value):
        """
        Takes a string in the cirruslink format "XX:XX:XX:XX" and returns the
        hex equivalent.

        @param cirruslink_value: [string] '[XX:XX:XX:XX]' where XX is a byte corresponding to the value
        @return int_value: Int value
        """
        try:
            int_value = int(cirruslink_value.replace(':', '').replace('0x', '').strip('L'), 16)
            return int_value
        except ValueError:
            raise CirrusLinkError('Failed to convert cirruslink value to int')

    def convert_hex_to_cirruslink_format(self, hex_value):
        """
        Takes a 32bit value and returns the audiohub string literal needed to
        send it in the proper format.

        @param hex_value: [int] value to convert
        @return cirruslink_value
        """
        cirruslink_value = str(hex(hex_value).replace('0x', '')).zfill(8).strip('L')
        cirruslink_value = ':'.join(cirruslink_value[i:i + 2] for i in range(0, len(cirruslink_value), 2))
        return cirruslink_value

    def cirruslink_restart(self, ip_address=None, ssh_session_port=22):
        """
        Given the audio hub ip address, this method creates a ssh connection to connect to
        audio hub if not created already and issues a cirruslink service restart.
        @param: ip_address: IP address of the audio hub hardware extracted from the system name.
        @param: port, default port number 22 is used.
        """
        if ip_address != self.ipaddress:
            if not ip_address:
                ip_address = self.ipaddress
            config = {'ipaddress': ip_address, 'port': ssh_session_port}
            self.set_config_details(config)
            self.connect()
        scs_link_stdin, _, _ = self.cirruslink_session.exec_command(self.cirruslink_restart_cmd)
        scs_link_stdin.flush()
        status_stdout = ''
        while 'start/running' not in status_stdout and 'active (running)' not in status_stdout:
            _, status_stdout, _ = self.cirruslink_session.exec_command(self.cirruslink_status_cmd)
            status_stdout = status_stdout.read()
        self.log.info("CirrusLink restarted")

    def cirruslink_reboot(self):
        """
        Given the audio hub/tuninghub ip address, this method creates a ssh connection to connect to
        audio hub/tuninghub if not created already and issues a reboot.
        @param: ip_address: IP address of the audio hub hardware extracted from the system name.
        @param: port, default port number 22 is used.
        """
        stdin, stdout, stderr = self.cirruslink_session.exec_command('reboot')
        return stdin, stdout.read(), stderr.read()
        self.log.info("CirrusLink %s rebooted", self.hw_type)

    def execute_command(self, cmd):
        """
        This will execute the command on audio hub target
        @param: cmd Command to be executed on audio hub
        @return: [str,str,str] stdin, stdout, stderr of command
        """
        stdin, stdout, stderr = self.cirruslink_session.exec_command('%s' % cmd)
        return stdin, stdout.read(), stderr.read()

    def read_linux_version(self):
        """
        Read linux version if audiohub
        @return: [float] linux version
        """
        linux_version = ""
        _, stdout, _ = self.cirruslink_session.exec_command('cat /etc/os-release')
        linux_version_info = stdout.read()
        linux_version_info = linux_version_info.split("\n")
        for info in linux_version_info:
            if 'VERSION_ID' in info:
                version_mat = re.search(r'([\d\\.]+)', info)
                if version_mat:
                    linux_version = version_mat.group(1)
        return float(linux_version)

    def update_cirruslink_commands(self):
        """
        Updates cirruslink commands according to linux versions
        """
        self.cirruslink_reboot_cmd = 'reboot'
        if self.linux_version == 14.04:
            self.cirruslink_start_cmd = '%s start' % self.cirrus_link_service
            self.cirruslink_stop_cmd = '%s stop' % self.cirrus_link_service
            self.cirruslink_restart_cmd = '%s restart' % self.cirrus_link_service
            self.cirruslink_status_cmd = '%s status' % self.cirrus_link_service

        else:
            # linux version >= 16.04
            cmd = "systemctl <> cl_server"
            self.cirruslink_start_cmd = cmd.replace('<>', 'start')
            self.cirruslink_stop_cmd = cmd.replace('<>', 'stop')
            self.cirruslink_restart_cmd = cmd.replace('<>', 'restart')
            self.cirruslink_status_cmd = cmd.replace('<>', 'status')


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceCirrusLinkCli(ResourceCirrusLink, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceCirrusLink.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceCirrusLink)

        RUN = ResourceCirrusLinkCli()
    else:
        # Unit test works only with real hardware
        # Replace the ip address with Audio hub under test Ip address
        # Open SoundClearStudio IDE and hover over the system to get the IP address
        class ResourceCirrusLinkUnittest(ResourceCirrusLink):
            def __init__(self):
                # Audio hub IP
                self.config = {'ipaddress': '169.254.7.111',
                               'port': 22,
                               'conn_type': CONN_TYPES.SSH,
                               'i2c_device_address': '0x62',
                               'device_id': '/dev/i2c-0',
                               'speed': '0b010',
                               'register_map_size': '0b111',
                               'transfer_length': 'aa',
                               'hw_type':HW_TYPES.AUDIOHUB}
                super(ResourceCirrusLinkUnittest, self).__init__()

            def test_cirrus_link(self):
                self.set_config_details(self.config)
                self.connect()
                self.write_register('0x550', '0x03')
                self.log.info(self.read_register('0x550'))
                self.disconnect()

        resource_cirrus_link_test = ResourceCirrusLinkUnittest()
        resource_cirrus_link_test.test_cirrus_link()