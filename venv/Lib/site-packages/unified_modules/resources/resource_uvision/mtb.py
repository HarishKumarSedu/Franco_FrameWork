import os
import sys
import time
import ftd2xx


class MtbError(Exception):
    """Class to catch MTB errors"""
    pass


class MTB(object):
    """ Class to communicate with MTB hardware"""
    def __init__(self, device_name, log):
        """
        MTB initialization
        @param device_name: MTB Device name
        @param log: logger instance
        """
        self.log = log
        # Find correct FTDI device
        dev_list = ftd2xx.listDevices(2)
        self.log.info("Available devices %s" % dev_list)
        device_index = -1
        for i in range(len(dev_list)):
            if b'%s_MTBUFF A' % device_name.encode() in dev_list[i]:
                device_index = i

        if device_index == -1:
            raise Exception("ERROR: No MTB found")

        # Open handle and setup device
        self.log.info("Using device %s" % dev_list[device_index])
        self.mtb = ftd2xx.open(device_index)
        self.mtb.setBitMode(0xFF, 0x00)  # reset mode
        self.mtb.setBitMode(0xFF, 0x40)  # single channel 245 Synchronous FIFO mode
        self.mtb.setLatencyTimer(2)  # between 2 and 255 ms in 1ms intervals
        self.mtb.setUSBParameters(65536, 65536)  # set buffer size
        self.mtb.setFlowControl(0x0100, 0, 0)  # FLOW_RTS_CTS

        time.sleep(0.1)  # 100ms

    def read_word_data(self, address, burst_size, auto_incr):
        """
        Read the MTB buffer data
        @param address: Address from where to start the read
        @param burst_size: <TBD>
        @param auto_incr: boolean True or False
        @return: data array integer values
        """
        packet = []
        string_packet = b''
        lower_addr = address & 0x0FFFFFFFF
        upper_addr = address >> 32
        packet.append((int(auto_incr) << 6) + upper_addr)
        packet.append(burst_size - 1)
        packet.append((lower_addr >> 24) & 0xFF)
        packet.append((lower_addr >> 16) & 0xFF)
        packet.append((lower_addr >> 8) & 0xFF)
        packet.append(lower_addr & 0xFF)
        for part in packet:
            string_packet = string_packet + (b'%c' % part)

        self.mtb.write(string_packet)
        # elapsed time from start ~40us

        rx_bytes = 0
        tries = 0
        while (rx_bytes == 0) and (tries < 15):
            rx_bytes = self.mtb.getQueueStatus()
            time.sleep(0.002)
            tries += 1
        # elapsed time from start ~1.4ms for 1024 bytes ... very slow but moving on

        data_array_char = self.mtb.read(rx_bytes)

        if ((rx_bytes / 4) != burst_size):
            # have to read the remaining in chunks
            tries = 0
            bytesRead = rx_bytes
            while ((bytesRead >> 2) < burst_size) and tries < 50:
                rx_bytes = 0
                while rx_bytes == 0:
                    tries += 1
                    rx_bytes = self.mtb.getQueueStatus()
                    # sometimes the FPGA fails to send 1024 bytes to the rx buffer of the ftdi chip
                    # if after 10 tries of pulling the rx_buffer, resend command to request the remaining bytes
                    if (tries > 10):
                        del data_array_char
                        data_array_char = b""
                        # send read command
                        self.mtb.write(string_packet)
                        bytesRead = 0
                        time.sleep(0.002)
                    self.log.info("Trying to read buffer, attempt # %s", tries)
                    if tries > 50:
                        break
                data_array_char += self.mtb.read(rx_bytes)
                bytesRead += rx_bytes

        # elapsed time from start ~1.8ms
        data_array_int = []
        if data_array_char:
            for i in range(burst_size):
                num = 0
                num += data_array_char[4 * i] << 24
                num += data_array_char[4 * i + 1] << 16
                num += data_array_char[4 * i + 2] << 8
                num += data_array_char[4 * i + 3]
                data_array_int.append(num)
        # elapsed time from start ~1.8ms
        return data_array_int

    def write_word_data(self, address, data_array, auto_incr):
        """
        Write to MTB buffer
        @param address: Address from where to start the write
        @param data_array: data to write
        @param auto_incr: boolean True or False
        @return: None
        """
        packet = []
        string_packet = b''
        lower_addr = address & 0x0FFFFFFFF
        upper_addr = address >> 32
        packet.append((int(auto_incr) << 6) + upper_addr + 128)
        packet.append(len(data_array) - 1)
        packet.append((lower_addr >> 24) & 0xFF)
        packet.append((lower_addr >> 16) & 0xFF)
        packet.append((lower_addr >> 8) & 0xFF)
        packet.append(lower_addr & 0xFF)
        for d in data_array:
            packet.append((d >> 24) & 0xFF)
            packet.append((d >> 16) & 0xFF)
            packet.append((d >> 8) & 0xFF)
            packet.append(d & 0xFF)
        for part in packet:
            string_packet = string_packet + (b'%c' % part)
        self.mtb.write(string_packet)

    def read_entry_count(self, address=0x01000004):
        """
        Read the MTB entry count
        @param address: address of the number of entries that have been logged in the MTB
        @return: entry count value
        """
        count = self.read_word_data(address, 1, True)[0]
        self.log.info('Entry Count is 0x%08X', count)
        # If MTB entry count is too large, that means MTB went to bad state, so throw exception
        count_hex_str = format(count, '#010x')
        max_hex_str = '0xFF000000'
        result_hex_str = hex(int(count_hex_str, 16) & int(max_hex_str, 16))
        result_int = int(result_hex_str, 16)
        if result_int > 0:
            raise MtbError("Entry Count is too large")
        return count

    def flush_capture(self, address=0x01000008):
        data_to_send = [0x00000002]
        self.write_word_data(address, data_to_send, True)
        time.sleep(0.1)  # 100ms
        data_to_send = [0x00000000]
        self.write_word_data(address, data_to_send, True)

    def reset_capture(self, address=0x01000008):
        data_to_send = [0x00000001]
        self.write_word_data(address, data_to_send, True)
        time.sleep(0.1)  # 100ms
        data_to_send = [0x00000000]
        self.write_word_data(address, data_to_send, True)

    def empty_read_buffer(self):
        bytes_in_buffer = self.mtb.getQueueStatus()
        self.log.info('Bytes in buffer: %s' % bytes_in_buffer)
        if bytes_in_buffer > 0:
            dataChar = self.mtb.read(bytes_in_buffer)

    def dump_memory(self, csv_paths, file_name, base_address=0x200000000):
        """
        Dump all MTB data to csv files.
        @param csv_paths: csv file path
        @param file_name: csv file name
        @param base_address: base adress
        @return: None
        """
        self.flush_capture()
        self.empty_read_buffer()
        time.sleep(0.1)
        words = self.read_entry_count()
        _bytes = words * 4
        data = []

        if words > 0:
            start_time = time.time()
            address = base_address
            next_percent_address = address
            next_percent = 0
            # Builds and populates the data list
            word_size = 256
            while words > word_size:
                if address > next_percent_address:
                    self._update_progress("Reading Data", next_percent)
                    next_percent += 1
                    next_percent_address += (_bytes / 100)
                data.extend(self.read_word_data(address, word_size, True))
                words -= word_size
                address += (4 * word_size)
            if words > 0:
                data.extend(self.read_word_data(address, words, True))

            end_time = time.time() - start_time
            self.log.info("Dumped data in %d minutes and %0.3f seconds" % ((end_time / 60), (end_time % 60)))

            # _create_csv_file(data)
            # Creating Keil-Importable Texts
            max_entries_per_file = (4194304 * 2)
            length = len(data)
            self.log.info("Generating Keil Files...")
            num_import_files = int(length / max_entries_per_file)  # python 2 truncates variables
            if length % max_entries_per_file != 0:
                num_import_files += 1
            self._create_importable_files(data, num_import_files, max_entries_per_file, csv_paths, file_name)
        self.reset_capture()

    def read_and_save_block(self, addr, w, outfile):
        """
        Reads the block of data and save to file
        :param addr: start address
        :param w: width
        :param outfile: file to save the read data
        :return: None
        """
        block = []
        if w > 0:
            if w > 256:
                block.extend(self.read_word_data(addr, 256, True))
            else:
                block.extend(self.read_word_data(addr, w, True))
            for x in block:
                outfile.write(('0x%08X' % x) + '\n')
        del block[:]

    def close(self):
        """
        Close MTB
        :return: None
        """
        self.mtb.close()

    @staticmethod
    def _update_progress(action_label, progress):
        """
        Used for the MTB Memory dump to print a progress bar out to the screen
        :param action_label: str Reading or Writing
        :param progress: progress percentage
        :return: None
        """
        toolbar_width = 25
        # Perform the first time setup for the toolbar
        if progress == 0:
            sys.stdout.write("%s: [%s]" % (action_label, (" " * toolbar_width)))
            sys.stdout.flush()
            sys.stdout.write("\b" * (toolbar_width + 1))  # return to start of line, after '['
        # Update the progress bar every 4%
        if (progress % 4) == 0:
            sys.stdout.write("-")
            sys.stdout.flush()
        # Print the ending bracket
        if progress == 98:
            sys.stdout.write("]\n")

    def _create_csv_file(self, data):
        """
        Create MtbMemoryDump.csv file and dump the data
        :param data: data to dump
        :return: None
        """
        mem_dump_handle = open('MtbMemoryDump.csv', 'w')
        length = len(data)
        next_percent = 0
        index = 0
        for x in data:
            if (index % (length / 100)) == 0:
                self._update_progress("Writing Data", next_percent)
                next_percent += 1
            mem_dump_handle.write(('0x%08X' % x) + '\n')
            index += 1
        mem_dump_handle.close()

    @staticmethod
    def _create_importable_files(data, num_import_files, max_entries_per_file,
                                 importable_files_dir_path, file_name):
        """
        Create given files and dump the data in to those files
        :param data: data to dump in to files
        :param num_import_files: number of files to create to dump the data
        :param max_entries_per_file: max entries per file
        :param importable_files_dir_path: files dir path
        :param file_name: file name
        :return: None
        """
        # Printing a loading bar out to the console
        sys.stdout.write("Files Finished: [0/%d]" % num_import_files)
        sys.stdout.flush()
        sys.stdout.write("\b" * 4)  # return to start of line, after '['

        length = len(data)
        for i in range(num_import_files):
            base = (i * max_entries_per_file)
            file_path = os.path.join(importable_files_dir_path, file_name)
            file_path = os.path.abspath(file_path)
            file_path = os.path.splitext(file_path)[0]
            file_path = file_path +  "_%03d.csv" % i
            with open(file_path, 'w') as f:
                # importable_file_handle = open(os.path.join(importable_files_dir_path,
                #                                            file_name), "w+")
                f.write("MTB S: 0x%.8x, 1, 0\n" % data[base])  # Necessary header for each file

                offset = 0  # An entry is 2 lines; a Starting address and an Ending address: Jump From -> Jump to
                while offset < max_entries_per_file and (base + offset) < length:
                    f.write("0x%08X\n" % data[base + offset])
                    offset += 1

                f.write("MTB E: 0x%.8x, 1, 1" % data[base + (offset - 1)])  # Footer for each file
                f.close()
                sys.stdout.write("%d\b" % (i + 1))
                sys.stdout.flush()
        print("")  # this clears the current line
