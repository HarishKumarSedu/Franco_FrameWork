#!/usr/bin/env python
"""

@brief
A resource library to perform ITM operations

"""
from __future__ import division
from unified_modules.resources.resource_data_lib.resource_data_lib import ResourceDataLib
from unified_modules.resources.resource_file_lib.resource_file_lib import ResourceFileLib
from unified_modules.test_support.testresults import TestResults

from unified_modules.resources.resource_itm import itm_packet_definitions as itm_packets
from unified_modules.resources.resource_itm import itm_header_definitions as itm_headers
import os
from unified_modules.resources.resource_itm.itm_named_tuples \
    import timestamp_format, global_timestamp_format, trace_address_type

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class ResourceItmLib(object):
    def __init__(self, byte_list=None):
        self.byte_list = byte_list
        self.itm_packets = None
        self.find_address_header = True
        self.packet_count = 0
        self.byte_count = 0
        self.packet_error_counter = 0
        self.data_lib = ResourceDataLib()
        self.file_lib = ResourceFileLib()

    def load_hex_file(self, itm_bin_filename):
        self.byte_list = self.file_lib.load_bytes_from_binary_file(itm_bin_filename)

    def convert_byte_list_to_itm_packets(self):
        self.reset()
        if self.find_address_header:
            self.byte_count += self.find_address_offset_header()
        while len(self.byte_list) > 0:
            try:
                itm_packet = self.pop_itm_packet()
            except ValueError:
                self.packet_error_counter += 1
                itm_packet = None
            if itm_packet is not None:
                self.itm_packets.append(itm_packet)
                # Add 1 byte to byte_count for the header
                self.byte_count += len(itm_packet.payload_bytes) + 1
                self.packet_count += 1
            else:
                print('Warning: ITM Factory - Synchronization Packet at byte number {}'.format(
                    self.byte_count))
                self.byte_count += 1

    def reset(self):
        self.itm_packets = []
        self.packet_count = 0
        self.byte_count = 0

    def find_address_offset_header(self):
        byte_count = 0
        while len(self.byte_list) > 0:
            try:
                itm_headers.TraceAddressOffsetHeader(self.byte_list[0])
                return byte_count
            except ValueError:
                byte_count += 1
                self.byte_list.pop(0)
        return byte_count

    def pop_itm_packet(self):

        header = self.pop_header()
        if itm_headers.LocalTimestampHeader.is_type(header):
            packet = self.create_local_ts_packet(header)

        elif itm_headers.TraceAddressOffsetHeader.is_type(header):
            packet = self.create_trace_address_packet(header)

        elif itm_headers.TraceDataValueHeader.is_type(header):
            packet = self.create_trace_data_packet(header)

        elif itm_headers.GlobalTimestampHeader.is_type(header):
            packet = self.create_global_ts_packet(header)

        elif itm_headers.SynchronizationHeader.is_type(header):
            return None

        elif itm_headers.EventCounterHeader.is_type(header):
            packet = self.create_event_counter_packet(header)

        elif itm_headers.InstrumentationHeader.is_type(header):
            try:
                packet = self.create_instrumentation_packet(header)
            except NotImplementedError as error:
                print("Warning: ITM Factory - {}".format(str(error)))
                packet = None
            return packet

        elif itm_headers.OverflowHeader.is_type(header):
            packet = self.create_overflow_packet(header)

        elif itm_headers.ExtensionHeader.is_type(header):
            try:
                packet = self.create_extension_packet(header)
            except NotImplementedError as error:
                print("Warning: ITM Factory - {}".format(str(error)))
                packet = None
            return packet

        elif itm_headers.ExceptionTraceHeader.is_type(header):
            packet = self.create_exception_packet(header)

        elif itm_headers.PeriodicPcSampleHeader.is_type(header):
            packet = self.create_pc_sample_packet(header)

        elif itm_headers.PeriodicPcSleepHeader.is_type(header):
            packet = self.create_pc_sleep_packet(header)
        else:
            raise ValueError(
                'Header value ({0}) does not resolve to known packet type.'.format(hex(header)))

        return packet

    def pop_header(self):
        # header is a single byte in the first position of the byte list
        header = self.data_lib.pop_slice(self.byte_list, 0, 1)[0]
        return header

    def create_synchronization_packet(self, header_value):
        packet = itm_packets.SynchronizationPacket()
        packet.header = itm_headers.SynchronizationHeader(header_value)
        packet.payload_bytes = self.pop_sync_payload()
        packet.deserialize()
        return packet

    def create_extension_packet(self, header_value):
        packet = itm_packets.ExtensionPacket()
        packet.header = itm_headers.ExtensionHeader(header_value)
        if packet.header.continuation == 1:
            packet.payload_bytes = self.pop_extension_info_payload()
        else:
            packet.payload_bytes = []
        packet.deserialize()
        return packet

    def create_local_ts_packet(self, header_value):
        packet = itm_packets.LocalTimestampPacket()
        packet.header = itm_headers.LocalTimestampHeader(header_value)

        # Format ID 1 has variable length payload (uses continuation bits),
        # Format ID 2 has no payload
        if packet.header.format_id == timestamp_format.LONG:
            packet.payload_bytes = self.pop_continuous_payload()
        else:
            packet.payload_bytes = []

        packet.deserialize()
        return packet

    def create_global_ts_packet(self, header_value):
        packet = itm_packets.GlobalTimestampPacket()
        packet.header = itm_headers.GlobalTimestampHeader(header_value)

        # Format ID 1 has variable length payload (uses continuation bits),
        # Format ID 2 has 4 payload bytes
        if packet.header.format_id == global_timestamp_format.GTS1:
            packet.payload_bytes = self.pop_continuous_payload()
        elif packet.header.format_id == global_timestamp_format.GTS2:
            packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0, 4)

        packet.deserialize()
        return packet

    @staticmethod
    def create_overflow_packet(header_value):
        packet = itm_packets.OverflowPacket()
        packet.header = itm_headers.OverflowHeader(header_value)
        packet.payload_bytes = []
        packet.deserialize()
        return packet

    def create_trace_data_packet(self, header_value):
        packet = itm_packets.TraceDataValuePacket()
        packet.header = itm_headers.TraceDataValueHeader(header_value)
        packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0,
                                                       packet.header.payload_size)
        packet.deserialize()
        return packet

    def create_trace_address_packet(self, header_value):
        packet = itm_packets.TraceAddressOffsetPacket()
        packet.header = itm_headers.TraceAddressOffsetHeader(header_value)

        if packet.header.trace_address_type == trace_address_type.OFFSET:
            packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0, 2)
        else:
            # Program Counter is 4 bytes
            packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0, 4)

        packet.deserialize()
        return packet

    def create_instrumentation_packet(self, header_value):
        packet = itm_packets.InstrumentationPacket()
        packet.header = itm_headers.InstrumentationHeader(header_value)
        packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0,
                                                       packet.header.payload_size)
        packet.deserialize()
        return packet

    def create_event_counter_packet(self, header_value):
        packet = itm_packets.EventCounterPacket()
        packet.header = itm_headers.EventCounterHeader(header_value)
        packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0, 1)
        packet.deserialize()
        return packet

    def create_exception_packet(self, header_value):
        packet = itm_packets.ExceptionTracePacket()
        packet.header = itm_headers.ExceptionTraceHeader(header_value)
        packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0, 2)
        packet.deserialize()
        return packet

    def create_pc_sample_packet(self, header_value):
        packet = itm_packets.PeriodicPcSamplePacket()
        packet.header = itm_headers.PeriodicPcSampleHeader(header_value)
        packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0, 4)
        packet.deserialize()
        return packet

    def create_pc_sleep_packet(self, header_value):
        packet = itm_packets.PeriodicPcSleepPacket()
        packet.header = itm_headers.PeriodicPcSleepHeader(header_value)
        packet.payload_bytes = self.data_lib.pop_slice(self.byte_list, 0, 1)
        packet.deserialize()
        return packet

    def pop_continuous_payload(self):
        byte_count = 0
        continuation_bit = 0
        for b in self.byte_list:
            byte_count += 1
            continuation_bit = self.data_lib.get_bit_field(b, 7, 1)
            if continuation_bit == 0:
                break

        # Validate contents of continuous payload bytes
        if byte_count > 4:
            raise ValueError('Maximum packet payload size (4) has been exceeded ({0}).'
                             .format(byte_count))
        if continuation_bit != 0:
            raise ValueError('End of byte list reached before payload byte with '
                             'continuation bit = 0 was found.')

        return self.data_lib.pop_slice(self.byte_list, 0, byte_count)

        # TODO Finish this - last payload byte (4th) does not check continuation bit,
        #  i.e. may be equal to 0 or 1

    def pop_extension_info_payload(self):
        byte_count = 0
        continuation_bit = 0
        for b in self.byte_list:
            byte_count += 1
            continuation_bit = self.data_lib.get_bit_field(b, 7, 1)
            if continuation_bit == 0:
                break

        # Validate contents of continuous payload bytes
        if byte_count > 4:
            raise ValueError('Maximum packet payload size (4) has been exceeded ({0}).'
                             .format(byte_count))
        if continuation_bit != 0:
            raise ValueError('End of byte list reached before payload byte with '
                             'continuation bit = 0 was found.')

        return self.data_lib.pop_slice(self.byte_list, 0, byte_count)

    def pop_sync_payload(self):
        byte_count = 0
        current_byte = 0
        for current_byte in self.byte_list:
            byte_count += 1
            if current_byte > 1:
                raise ValueError(
                    'Sync Payload byte ({0}) must be 0x00 until last byte == 0x01.'
                    .format(hex(current_byte)))
            elif current_byte == 1:
                break

        # Validate contents of continuous payload bytes
        if byte_count < 6:
            raise ValueError('Sync payload size ({0}) is less than minimum (6).'.format(byte_count))
        if current_byte != 0x80:
            raise ValueError('Last byte of Sync payload ({0}) must be == 0x80'.format(current_byte))

        return self.data_lib.pop_slice(self.byte_list, 0, byte_count)


if __name__ == "__main__":
    class ResourceItmLibUnitTest(ResourceItmLib):
        """
        UnitTest for ITM lib resource.
        """
        def __init__(self):
            super(ResourceItmLibUnitTest, self).__init__()
            self.results = TestResults()
            self.results.set_test_title('test_resource_itm_lib')
            self.log = self.results.log
            self.find_address_header = True
            self.hex_filename = os.path.join(os.getcwd(), 'swo.hex')

        def test_resource_itmlib(self):
            self.log.info("Testing SWO Output from Hex File: %s", self.hex_filename)
            self.load_hex_file(self.hex_filename)
            self.log.info("Processing {0} Bytes...".format(len(self.byte_list)))

            try:
                self.convert_byte_list_to_itm_packets()
            except Exception as e:
                self.log.info("***** ITM Error Occurred! *****\n", str(e), "\n")
            finally:
                self.log.info("Generated {0} ITM Packets...".format(self.packet_count))
                self.log.info("Processed {0} bytes...".format(self.byte_count))

            self.log.info("ITM Packet Processing Complete.")


    resource_itm_lib_test = ResourceItmLibUnitTest()
    resource_itm_lib_test.test_resource_itmlib()
