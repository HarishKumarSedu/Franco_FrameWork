from unified_modules.resources.resource_itm.itm_named_tuples \
    import packet_type, timestamp_format, global_timestamp_format, trace_address_type
from unified_modules.resources.resource_data_lib.resource_data_lib \
    import ResourceDataLib as data_lib
from abc import ABCMeta


def remove_continuation_bits(payload_bytes):
    data_bytes = []
    for payload_byte in payload_bytes:
        data_bytes.append(payload_byte & 0x7F)
    return data_bytes


class ItmPacket(object):
    __metaclass__ = ABCMeta

    def __init__(self):
        self.header = None
        self.payload_bytes = []
        self.type = packet_type.ITM

    def validate_continuous_payload(self):
        """ Generic function to validate continuous payload """
        # Check that all payload bytes before last byte have continuation bits == 1
        for payload_byte in self.payload_bytes[:-1]:
            continuation_bit = data_lib.get_bit_field(payload_byte, 7, 1)
            if continuation_bit != 1:
                raise ValueError('Continuation bit for payload byte ({0}) must be 1.'.format(payload_byte))

        # Check that last payload byte has continuation bit == 0
        continuation_bit = data_lib.get_bit_field(self.payload_bytes[-1], 7, 1)
        if continuation_bit != 0:
            raise ValueError('Continuation bit for payload byte ({0}) must be 0.'.format(self.payload_bytes[-1]))


# TODO Complete SynchronizationPacket
class SynchronizationPacket(ItmPacket):
    def __init__(self):
        super(SynchronizationPacket, self).__init__()
        self.type = packet_type.SYNC

    def deserialize(self):
        self.validate_payload()

    def validate_payload(self):
        pass


class ProtocolPacket(ItmPacket):
    __metaclass__ = ABCMeta

    def __init__(self):
        super(ProtocolPacket, self).__init__()
        self.type = packet_type.PROTOCOL


# TODO Complete OverflowPacket
class OverflowPacket(ProtocolPacket):
    def __init__(self):
        super(OverflowPacket, self).__init__()
        self.type = packet_type.OVERFLOW

    def deserialize(self):
        self.validate_payload()

    def validate_payload(self):
        pass


# TODO Consider splitting LocalTimestampPacket into 2 sub-classes for format 1 and format 2
class LocalTimestampPacket(ProtocolPacket):
    def __init__(self):
        super(LocalTimestampPacket, self).__init__()
        self.type = packet_type.LOCAL_TS
        self.timestamp = None

    def deserialize(self):
        self.validate_payload()
        if self.header.format_id == timestamp_format.LONG:
            self._extract_format1_timestamp()
        else:
            self._extract_format2_timestamp()

    def _extract_format1_timestamp(self):
        data_bytes = remove_continuation_bits(self.payload_bytes)
        self.timestamp = data_lib.bytes_to_num(data_bytes, little_endian=True, bit_length=7)

    def _extract_format2_timestamp(self):
        # In TS format 2 (short), the timestamp is stored in 3 header bits, should already have been parsed
        self.timestamp = self.header.timestamp

    def validate_payload(self):
        payload_size = len(self.payload_bytes)
        if self.header.format_id == timestamp_format.LONG:
            self.validate_continuous_payload()
        else:
            if payload_size != 0:
                raise ValueError('Length of Local Timestamp Format2 payload bytes ({0}) must be 0'.format(payload_size))


# TODO Consider splitting GlobalTimestampPacket into 2 sub-classes for GTS1 and GTS2
class GlobalTimestampPacket(ProtocolPacket):
    def __init__(self):
        super(GlobalTimestampPacket, self).__init__()
        self.type = packet_type.GLOBAL_TS
        self.timestamp = None
        self.wrap = None
        self.clock_change = None

    def deserialize(self):
        self.validate_payload()
        self._set_wrap()
        self._set_clock_change()
        self._extract_global_timestamp(self.header.format_id)

    def _extract_global_timestamp(self, ts_format):
        data_bytes = remove_continuation_bits(self.payload_bytes)
        if ts_format == global_timestamp_format.GTS1:
            # Set Wrap and ClkCh bits [6:5] in last payload byte to zero for GTS1. GTS2 has those bits already in zero
            data_bytes[-1] = data_lib.keep_lower_bits(data_bytes[-1], 5)
        self.timestamp = data_lib.bytes_to_num(data_bytes, little_endian=True, bit_length=7)

    def _set_wrap(self):
        # Get Wrap bit [6] from last payload byte
        self.wrap = data_lib.get_bit_field(self.payload_bytes[-1], 6, 1)

    def _set_clock_change(self):
        # Get ClkCh bit [5] from last payload byte
        self.clock_change = data_lib.get_bit_field(self.payload_bytes[-1], 5, 1)

    def validate_payload(self):
        payload_size = len(self.payload_bytes)
        if self.header.format_id == global_timestamp_format.GTS1:
            self.validate_continuous_payload()
        else:
            if payload_size != 4:
                raise ValueError('Length of Global Timestamp Format 2 payload bytes (%i) must be 4' % payload_size)


# TODO Consider splitting ExtensionPacket into 2 sub-classes for ExtensionInformation and StimulusPortPageNumber
class ExtensionPacket(ProtocolPacket):
    def __init__(self):
        super(ExtensionPacket, self).__init__()
        self.type = packet_type.EXTENSION
        self.info = None
        raise NotImplementedError('ExtensionPacket class is not yet implemented')

    def deserialize(self):
        self.validate_payload()

    def validate_payload(self):
        pass


class SourcePacket(ItmPacket):
    __metaclass__ = ABCMeta

    def __init__(self):
        super(SourcePacket, self).__init__()
        self.type = packet_type.SOURCE


class InstrumentationPacket(SourcePacket):
    def __init__(self):
        super(InstrumentationPacket, self).__init__()
        self.type = packet_type.INSTRUMENTATION
        self.data = None
        raise NotImplementedError('InstrumentationPacket class is not yet implemented')

    def deserialize(self):
        self.validate_payload()
        self.data = data_lib.bytes_to_num(self.payload_bytes, little_endian=True)

    # TODO Replace with a common reusable method validate_data_payload stored in a base class
    def validate_payload(self):
        payload_size = len(self.payload_bytes)
        if payload_size not in [1, 2, 4]:
            raise ValueError('Length of Trace Data payload bytes ({0}) must equal 1, 2 or 4.'.format(payload_size))
        if payload_size != self.header.payload_size:
            raise ValueError('Length of Trace Data payload bytes ({0}) must equal header payload size ({1})'.format(
                 payload_size, self.header.payload_size))


class HardwarePacket(SourcePacket):
    __metaclass__ = ABCMeta

    def __init__(self):
        super(HardwarePacket, self).__init__()
        self.type = packet_type.HARDWARE


class EventCounterPacket(HardwarePacket):
    def __init__(self):
        super(EventCounterPacket, self).__init__()
        self.type = packet_type.EVENT_COUNTER
        self.payload = None
        self.POSTCNT = None
        self.FOLDCNT = None
        self.LSUCNT = None
        self.SLEEPCNT = None
        self.EXCCNT = None
        self.CPICNT = None

    def deserialize(self):
        self.validate_payload()
        self.payload = self.payload_bytes[0]
        self._set_event_bit_fields()

    def _set_event_bit_fields(self):
        self.POSTCNT = data_lib.get_bit_field(self.payload, 5, 1)
        self.FOLDCNT = data_lib.get_bit_field(self.payload, 4, 1)
        self.LSUCNT = data_lib.get_bit_field(self.payload, 3, 1)
        self.SLEEPCNT = data_lib.get_bit_field(self.payload, 2, 1)
        self.EXCCNT = data_lib.get_bit_field(self.payload, 1, 1)
        self.CPICNT = data_lib.get_bit_field(self.payload, 0, 1)

    def validate_payload(self):
        payload_size = len(self.payload_bytes)
        if payload_size != 1:
            raise ValueError(
              'Length of Event Counter payload bytes ({0}) must equal 1'.format(payload_size))


class ExceptionTracePacket(HardwarePacket):
    def __init__(self):
        super(ExceptionTracePacket, self).__init__()
        self.type = packet_type.EXCEPTION
        self.exception_number = None
        self.function = None
        raise NotImplementedError('ExceptionTracePacket class is not yet implemented')

    def deserialize(self):
        self.validate_payload()

    def validate_payload(self):
        pass


class PeriodicPcPacket(HardwarePacket):
    __metaclass__ = ABCMeta

    def __init__(self):
        super(PeriodicPcPacket, self).__init__()
        self.type = packet_type.PERIODIC_PC


class PeriodicPcSamplePacket(PeriodicPcPacket):
    def __init__(self):
        super(PeriodicPcSamplePacket, self).__init__()
        self.type = packet_type.PC_SAMPLE
        self.pc = None
        raise NotImplementedError('PeriodicPcSamplePacket class is not yet implemented')

    def deserialize(self):
        self.validate_payload()
        self.pc = data_lib.bytes_to_num(self.payload_bytes, little_endian=True)

    def validate_payload(self):
        payload_size = len(self.payload_bytes)
        if payload_size != 4:
            raise ValueError('Length of PC Sample payload bytes ({0}) must equal 4.'.format(payload_size))


class PeriodicPcSleepPacket(PeriodicPcPacket):
    def __init__(self):
        super(PeriodicPcSleepPacket, self).__init__()
        self.type = packet_type.PC_SLEEP
        self.payload = None

    def deserialize(self):
        self.validate_payload()
        self.payload = self.payload_bytes[0]

    def validate_payload(self):
        if self.payload_bytes != [0x00]:
            raise ValueError('PC Sleep payload ({0}) must equal to a single byte 0x00.'.format(self.payload_bytes))


class DataTracePacket(HardwarePacket):
    __metaclass__ = ABCMeta

    def __init__(self):
        super(DataTracePacket, self).__init__()
        self.type = packet_type.TRACE


# TODO Consider splitting TraceAddressOffsetPacket into 2 sub-classes for PcValuePacket and AddressOffsetPacket
class TraceAddressOffsetPacket(DataTracePacket):
    def __init__(self):
        super(TraceAddressOffsetPacket, self).__init__()
        self.type = packet_type.TRACE_ADDRESS
        self.address = None

    def deserialize(self):
        self.validate_payload()
        self.address = data_lib.bytes_to_num(self.payload_bytes, little_endian=True)

    def validate_payload(self):
        payload_size = len(self.payload_bytes)
        if self.header.trace_address_type == trace_address_type.OFFSET:
            if payload_size != 2:
                raise ValueError('Length of Address Offset payload bytes ({0}) must equal 2.'.format(payload_size))
        else:
            if payload_size != 4:
                raise ValueError('Length of PC payload bytes ({0}) must equal 4.'.format(payload_size))


# TODO Consider splitting TraceDataValuePacket into 2 sub-classes for ReadPacket and WritePacket
class TraceDataValuePacket(DataTracePacket):
    def __init__(self):
        super(TraceDataValuePacket, self).__init__()
        self.type = packet_type.TRACE_DATA
        self.value = None

    def deserialize(self):
        self.validate_payload()
        self.value = data_lib.bytes_to_num(self.payload_bytes, little_endian=True)

    # TODO Replace with a common reusable method validate_data_payload stored in a base class
    def validate_payload(self):
        payload_size = len(self.payload_bytes)
        if payload_size not in [1, 2, 4]:
            raise ValueError('Length of Trace Data payload bytes ({0}) must equal 1, 2 or 4.'.format(payload_size))
        if payload_size != self.header.payload_size:
            raise ValueError('Length of Trace Data payload bytes ({0}) must equal header payload size ({1})'.format(
                 payload_size, self.header.payload_size))
