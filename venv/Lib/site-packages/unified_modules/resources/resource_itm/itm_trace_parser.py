import logging
from unified_modules.resources.resource_itm.itm_named_tuples \
    import packet_type, data_size, global_timestamp_format, trace_parsing_state


class TracePacket(object):
    """ Container of trace packet. It has address, data, access and
        cycle number
    """
    def __init__(self, mcu_freq_mhz=48):
        self.mcu_freq_mhz = mcu_freq_mhz
        self.address = None
        self.data = None
        self._cycle = None
        self._time_us = None
        self.access = None

    def __repr__(self):
        return 'TracePacket(address=%s, data=%s, cycle=%s, access=%s, timestamp_us=%i)' % (
            hex(self.address), hex(self.data), self.cycle, self.access, self.time_us)

    @property
    def cycle(self):
        return self._cycle

    @cycle.setter
    def cycle(self, value):
        self._cycle = value
        self._time_us = value / self.mcu_freq_mhz

    @property
    def time_us(self):
        return self._time_us

    @time_us.setter
    def time_us(self, value):
        self._time_us = value
        self._cycle = value * self.mcu_freq_mhz


class ItmTraceParser:

    def __init__(self, register_watch_list, mcu_freq_mhz=48):
        self.register_watch_list = register_watch_list
        self.mcu_freq_mhz = mcu_freq_mhz
        self.trace_data_comparator = None
        self.local_timestamp_enabled = True
        self.global_timestamp_enabled = False
        self.global_ts1_hold_value = 0
        self.global_ts2_hold_value = 0
        self.global_ts2_offset = 26
        self.trace_packet = TracePacket(mcu_freq_mhz=self.mcu_freq_mhz)

    def parse_itm_trace_packets(self, itm_trace_packets):
        """ Parse list of packet strings and return list of TracePacket objects
        """
        trace_packets = []
        data_trace_headers = self._get_data_address_headers()
        parsing_state = trace_parsing_state.WAIT_FOR_ADDRESS
        cycle_counter = 0
        byte_count = 0
        warning_count = 0
        max_cycles_local_ts = 1999999
        errors_counter = 0
        max_errors_allowed = 2
        for itm_packet in itm_trace_packets:

            if parsing_state == trace_parsing_state.WAIT_FOR_ADDRESS:

                if itm_packet.type == packet_type.TRACE_ADDRESS:
                    self.trace_packet.address, self.trace_data_comparator =\
                        self._process_trace_address_packet(itm_packet, data_trace_headers)

                    parsing_state = trace_parsing_state.WAIT_FOR_TS
                elif itm_packet.type == packet_type.LOCAL_TS and trace_packets:
                    if itm_packet.timestamp < max_cycles_local_ts:
                        cycle_counter += itm_packet.timestamp
                        trace_packets[-1].cycle = cycle_counter
                else:
                    logging.error(
                        'ITM Parse error at byte 0x%X: Expecting address packet' % byte_count)
                    warning_count += 1
                    self._reset()
                    # TODO: Uncomment this line once the extra sync bytes are fixed
                    # raise ValueError(
                    #    ('ITM Parse error at byte %i:  Expecting address packet, got '
                    #     % byte_count) + str(itm_packet.type))

            elif parsing_state in\
                    [trace_parsing_state.WAIT_FOR_TS, trace_parsing_state.WAIT_FOR_DATA]:

                if itm_packet.type in [packet_type.LOCAL_TS, packet_type.GLOBAL_TS]:
                    if itm_packet.type == packet_type.GLOBAL_TS:
                        timestamp_cycles = self._process_global_ts_packet(itm_packet)
                        if timestamp_cycles is None:
                            continue
                        else:
                            # Reset cycle_counter to zero as there is a new global timestamp value
                            cycle_counter = 0
                    else:
                        timestamp_cycles = itm_packet.timestamp
                    cycle_counter += timestamp_cycles
                    self.trace_packet.cycle = cycle_counter
                    parsing_state = trace_parsing_state.WAIT_FOR_DATA

                elif itm_packet.type == packet_type.TRACE_DATA:
                    if itm_packet.header.comparator == self.trace_data_comparator:
                        self._process_trace_data_packet(itm_packet)
                    parsing_state = trace_parsing_state.WAIT_FOR_TS
                elif itm_packet.type == packet_type.TRACE_ADDRESS \
                        and errors_counter < max_errors_allowed:
                    self.trace_packet.address, self.trace_data_comparator = \
                        self._process_trace_address_packet(itm_packet, data_trace_headers)
                    errors_counter += 1
                elif itm_packet.type == packet_type.OVERFLOW \
                        and errors_counter < max_errors_allowed:
                    errors_counter += 1
                else:
                    logging.error("ITM Parse error at byte 0x%X: Expecting Data or TS" % byte_count)
                    warning_count += 1
                    parsing_state = trace_parsing_state.WAIT_FOR_ADDRESS
                    byte_count += len(itm_packet.payload_bytes) + 1
                    self._reset()
                    continue
                    # TODO: Uncomment this line once the extra sync bytes are fixed
                    # raise ValueError(
                    #    ('ITM Parse error at byte %i: Expecting Data or TS, got '
                    #     % byte_count) + str(itm_packet.type))

                if ((self.trace_packet.cycle is not None) or
                    not (self.local_timestamp_enabled or
                         self.global_timestamp_enabled)) and \
                        (self.trace_packet.data is not None):
                    trace_packets.append(self.trace_packet)
                    parsing_state = trace_parsing_state.WAIT_FOR_ADDRESS
                    self._reset()
                    errors_counter = 0

            byte_count += len(itm_packet.payload_bytes) + 1

        if warning_count:
            logging.warning("ITM Parser discarded %i packets" % warning_count)

        return trace_packets

    def _get_data_address_headers(self):
        """ Return a dictionary with address and expected data trace headers """
        # Header for Data Address Offset packet for comparator 0
        base_data_address_header = 0x4E0000
        expected_headers = {}
        for register in self.register_watch_list:
            # Build address header based base_header and comparator number
            address_header = base_data_address_header \
                             + (self.register_watch_list.index(register) << 20)
            # Add the lowest 16 bit of address to the header
            address_header += (register & 0xFFFF)
            comparator = self.register_watch_list.index(register)
            # Generate a tuple with address and comparator number for each register watch point
            expected_headers[address_header] = (register, comparator)
        return expected_headers

    @staticmethod
    def _process_trace_address_packet(trace_address_packet, data_trace_headers):
        trace_address_value = trace_address_packet.address
        trace_data_comparator = trace_address_packet.header.comparator
        packet_header = (trace_address_packet.header.value << data_size.HALFWORD) |\
            trace_address_packet.address
        for data_trace_key in list(data_trace_headers.keys()):
            # Check if data address is not 4-byte aligned and find the absolute address
            if abs(packet_header - data_trace_key) < 4:
                trace_address_msb = data_trace_headers[data_trace_key][0] & 0xFFFF0000
                trace_address_value = trace_address_msb + trace_address_packet.address
                break
        return trace_address_value, trace_data_comparator

    def _process_trace_data_packet(self, itm_packet):
        self.trace_packet.access = 'W' if itm_packet.header.transfer_direction else 'R'
        self.trace_packet.data = itm_packet.value

    def _process_global_ts_packet(self, itm_packet):
        if itm_packet.header.format_id == global_timestamp_format.GTS1:
            if itm_packet.wrap:
                # Store current TS1 value and wait for next GTS2 packet
                self.global_ts1_hold_value = itm_packet.timestamp
            else:
                # Calculate and return full global timestamp value
                cycle_count = self.global_ts2_hold_value + itm_packet.timestamp
                return cycle_count
        else:
            self.global_ts2_hold_value = itm_packet.timestamp << self.global_ts2_offset
            # If previous GTS1 timestamp available, return full global timestamp value
            if self.global_ts1_hold_value:
                cycle_count = self.global_ts1_hold_value + self.global_ts2_hold_value
                self.global_ts1_hold_value = 0
                return cycle_count

    def _reset(self):
        self.trace_data_comparator = None
        self.trace_packet = TracePacket(mcu_freq_mhz=self.mcu_freq_mhz)
