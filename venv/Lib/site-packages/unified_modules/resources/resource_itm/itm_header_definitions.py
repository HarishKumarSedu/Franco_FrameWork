from unified_modules.resources.resource_itm.itm_named_tuples \
    import timestamp_format, global_timestamp_format, payload_size
from unified_modules.resources.resource_data_lib.resource_data_lib \
    import ResourceDataLib as data_lib


class ItmHeader(object):
    def __init__(self, value):
        self.value = value

    def validate_expected(self, expected_value):
        """ Generic Utility function for itm_headers that need to validate the header value against a specific value"""
        if self.value != expected_value:
            raise ValueError('Header value ({0}) does not match expected ({1})'.format(
                hex(self.value), hex(expected_value)))

    @staticmethod
    def validate(value):
        if not ItmHeader.is_type(value):
            raise ValueError('ItmHeader value ({0}) must be a byte.)'.format(hex(value)))

    @staticmethod
    def is_type(value):
        return 0x00 <= value <= 0xFF


class SynchronizationHeader(ItmHeader):
    def __init__(self, value):
        super(SynchronizationHeader, self).__init__(value)
        self.validate_expected(0x00)

    @staticmethod
    def is_type(value):
        return value == 0x00

# region ProtocolHeader


class ProtocolHeader(ItmHeader):
    def __init__(self, value):
        super(ProtocolHeader, self).__init__(value)
        ProtocolHeader.validate(value)

    # TODO Validate method should only check is_child_type() not is_type, which checks parent
    @staticmethod
    def validate(value):
        super(ProtocolHeader, ProtocolHeader).validate(value)
        if not ProtocolHeader.is_type(value):
            raise ValueError('ProtocolHeader ({0}) must have Payload Size bits[0:1] equal to 0b00 and cannot equal 0x00'
                             .format(hex(value)))

    # TODO Separate is_child_type logic in a separate method so validate() can be optimized
    @staticmethod
    def is_type(value):
        is_parent_type = super(ProtocolHeader, ProtocolHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 0, 2) == 0 and value != 0x00
        return is_parent_type and is_child_type


class OverflowHeader(ProtocolHeader):
    def __init__(self, value):
        super(OverflowHeader, self).__init__(value)
        self.validate_expected(0x70)

    @staticmethod
    def is_type(value):
        return value == 0x70


# TODO Consider splitting LocalTimestampHeader into 2 sub-classes for format 1 and format 2
class LocalTimestampHeader(ProtocolHeader):
    def __init__(self, value):
        super(LocalTimestampHeader, self).__init__(value)
        LocalTimestampHeader.validate(value)

        self.continuation = data_lib.get_bit_field(value, 7, 1)
        if self.continuation == 1:
            self.format_id = timestamp_format.LONG
            self.correlation_id = data_lib.get_bit_field(value, 4, 2)
        else:
            self.format_id = timestamp_format.SHORT
            self.timestamp = data_lib.get_bit_field(value, 4, 3)

    @staticmethod
    def validate(value):
        super(LocalTimestampHeader, LocalTimestampHeader).validate(value)
        if not LocalTimestampHeader.is_type(value):
            raise ValueError('LocalTimestampHeader value ({0}) must not have Data bits [4:6] equal to 0b000 or 0b111'
                             .format(hex(value)))

    @staticmethod
    def is_type(value):
        lower_nibble = data_lib.get_bit_field(value, 0, 4)
        upper_nibble = data_lib.get_bit_field(value, 4, 4)

        is_timestamp = lower_nibble == 0x0
        is_short_ts = 1 <= upper_nibble <= 6
        is_long_ts = upper_nibble >= 0xC

        is_child_type = is_timestamp and (is_short_ts or is_long_ts)
        return is_child_type


# TODO Consider splitting GlobalTimestampHeader into 2 sub-classes for GTS1 and GTS2
class GlobalTimestampHeader(ProtocolHeader):
    def __init__(self, value):
        super(GlobalTimestampHeader, self).__init__(value)
        GlobalTimestampHeader.validate(value)

        self.continuation = data_lib.get_bit_field(value, 7, 1)
        if data_lib.get_bit_field(value, 5, 1):
            self.format_id = global_timestamp_format.GTS2
        else:
            self.format_id = global_timestamp_format.GTS1

    @staticmethod
    def validate(value):
        super(GlobalTimestampHeader, GlobalTimestampHeader).validate(value)
        if not GlobalTimestampHeader.is_type(value):
            raise ValueError('GlobalTimestampHeader value ({0}) must have bits[2,4,7] equal to 1'.format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(GlobalTimestampHeader, GlobalTimestampHeader).is_type(value)
        global_ts_header_mask = 0x94
        is_child_type = value & global_ts_header_mask
        return is_parent_type and (is_child_type == global_ts_header_mask)


# TODO Consider splitting ExtensionHeader into 2 sub-classes for ExtensionInformation and StimulusPortPageNumber
class ExtensionHeader(ProtocolHeader):
    def __init__(self, value):
        super(ExtensionHeader, self).__init__(value)
        ExtensionHeader.validate(value)

        self.continuation = data_lib.get_bit_field(value, 7, 1)
        self.info_LSB = data_lib.get_bit_field(value, 4, 3)
        self.source = data_lib.get_bit_field(value, 2, 1)

    @staticmethod
    def validate(value):
        super(ExtensionHeader, ExtensionHeader).validate(value)
        if not ExtensionHeader.is_type(value):
            # StimulusPortPageNumber not yet supported (bit[3] = 0)
            raise ValueError('ExtensionHeader value ({0}) must have bit[3] equal to 1'.format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(ExtensionHeader, ExtensionHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 3, 1) == 1
        return is_parent_type and is_child_type

# endregion ProtocolHeader

# region SourceHeader


class SourceHeader(ItmHeader):
    def __init__(self, value):
        super(SourceHeader, self).__init__(value)
        SourceHeader.validate(value)
        payload_size_bits = data_lib.get_bit_field(value, 0, 2)

        # convert from the encoded size to the actual expected payload size
        if payload_size_bits == payload_size.BYTES_1:
            self.payload_size = 1
        elif payload_size_bits == payload_size.BYTES_2:
            self.payload_size = 2
        elif payload_size_bits == payload_size.BYTES_4:
            self.payload_size = 4

    @staticmethod
    def validate_source_header(value):
        super(SourceHeader, SourceHeader).validate(value)
        if not SourceHeader.is_type(value):
            raise ValueError('SourceHeader value ({0}) must NOT have Payload Size bits[0:1] equal to 0b00'
                             .format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(SourceHeader, SourceHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 0, 2) != 0
        return is_parent_type and is_child_type


class InstrumentationHeader(SourceHeader):
    def __init__(self, value):
        super(InstrumentationHeader, self).__init__(value)
        InstrumentationHeader.validate(value)
        self.port_number = data_lib.get_bit_field(value, 3, 5)

    @staticmethod
    def validate(value):
        super(InstrumentationHeader, InstrumentationHeader).validate(value)
        if not InstrumentationHeader.is_type(value):
            raise ValueError('InstrumentationHeader value ({0}) must have bit[2] equal to 0'.format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(InstrumentationHeader, InstrumentationHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 2, 1) == 0
        return is_parent_type and is_child_type


class HardwareHeader(SourceHeader):
    def __init__(self, value):
        super(HardwareHeader, self).__init__(value)
        HardwareHeader.validate(value)
        self.discriminator_id = data_lib.get_bit_field(value, 3, 5)

    @staticmethod
    def validate(value):
        super(HardwareHeader, HardwareHeader).validate(value)
        if not HardwareHeader.is_type(value):
            raise ValueError('HardwareHeader value ({0}) must have bit[2] equal to 1'.format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(HardwareHeader, HardwareHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 2, 1) == 1
        return is_parent_type and is_child_type


class EventCounterHeader(HardwareHeader):
    def __init__(self, value):
        super(EventCounterHeader, self).__init__(value)
        self.validate_expected(0x05)

    @staticmethod
    def is_type(value):
        return value == 0x05


class ExceptionTraceHeader(HardwareHeader):
    def __init__(self, value):
        super(ExceptionTraceHeader, self).__init__(value)
        self.validate_expected(0x0E)

    @staticmethod
    def is_type(value):
        return value == 0x0E


class PeriodicPcHeader(HardwareHeader):
    def __init__(self, value):
        super(PeriodicPcHeader, self).__init__(value)
        PeriodicPcHeader.validate(value)

    @staticmethod
    def validate(value):
        super(PeriodicPcHeader, PeriodicPcHeader).validate(value)
        if not PeriodicPcHeader.is_type(value):
            raise ValueError('PeriodicPcHeader value ({0}) must be 0x17 or 0x15.'.format(hex(value)))

    @staticmethod
    def is_type(value):
        # Must be one of its two children, which have totally hardcoded header values
        return value in [0x17, 0x15]


class PeriodicPcSampleHeader(PeriodicPcHeader):
    def __init__(self, value):
        super(PeriodicPcSampleHeader, self).__init__(value)
        self.validate_expected(0x17)

    @staticmethod
    def is_type(value):
        return value == 0x17


class PeriodicPcSleepHeader(PeriodicPcHeader):
    def __init__(self, value):
        super(PeriodicPcSleepHeader, self).__init__(value)
        self.validate_expected(0x15)

    @staticmethod
    def is_type(value):
        return value == 0x15


class DataTraceHeader(HardwareHeader):
    def __init__(self, value):
        super(DataTraceHeader, self).__init__(value)
        DataTraceHeader.validate(value)
        self.comparator = data_lib.get_bit_field(value, 4, 2)

    @staticmethod
    def validate(value):
        super(DataTraceHeader, DataTraceHeader).validate(value)
        if not DataTraceHeader.is_type(value):
            raise ValueError('DataTraceHeader ({0}) Trace Type bits[6:7] must be 0b01 or 0b10.'.format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(DataTraceHeader, DataTraceHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 6, 2) in [0b01, 0b10]
        return is_parent_type and is_child_type


# TODO Consider splitting TraceAddressOffsetHeader into 2 sub-classes for PcValuePacket and AddressOffsetPacket
class TraceAddressOffsetHeader(DataTraceHeader):
    def __init__(self, value):
        super(TraceAddressOffsetHeader, self).__init__(value)
        TraceAddressOffsetHeader.validate(value)
        self.trace_address_type = data_lib.get_bit_field(value, 3, 1)

    @staticmethod
    def validate(value):
        super(TraceAddressOffsetHeader, TraceAddressOffsetHeader).validate(value)
        if not TraceAddressOffsetHeader.is_type(value):
            raise ValueError('TraceAddressOffsetHeader ({0}) Trace Type bits[6:7] must be 0b01.'.format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(TraceAddressOffsetHeader, TraceAddressOffsetHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 6, 2) == 0b01
        return is_parent_type and is_child_type


# TODO Consider splitting TraceDataValueHeader into 2 sub-classes for ReadPacket and WritePacket
class TraceDataValueHeader(DataTraceHeader):
    def __init__(self, value):
        super(TraceDataValueHeader, self).__init__(value)
        TraceDataValueHeader.validate(value)
        self.transfer_direction = data_lib.get_bit_field(value, 3, 1)

    @staticmethod
    def validate(value):
        super(TraceDataValueHeader, TraceDataValueHeader).validate(value)
        if not TraceDataValueHeader.is_type(value):
            raise ValueError('TraceDataValueHeader ({0}) Trace Type bits[6:7] must be 0b10.'.format(hex(value)))

    @staticmethod
    def is_type(value):
        is_parent_type = super(DataTraceHeader, DataTraceHeader).is_type(value)
        is_child_type = data_lib.get_bit_field(value, 6, 2) == 0b10
        return is_parent_type and is_child_type

# region SourceHeader

if __name__ == '__main__':

    not_itm         = 0x100
    sync_hdr        = 0x00
    overflow_hdr    = 0x70
    local_ts1_hdr   = 0xC0
    local_ts2_hdr   = 0x50
    global_ts1_hdr  = 0x94
    global_ts2_hdr  = 0xB4
    ext_hdr         = 0x08
    inst_hdr        = 0xAB
    event_hdr       = 0x05
    exception_hdr   = 0x0E
    pc_sleep_hdr    = 0x17
    pc_sample_hdr   = 0x15
    trace_addr_hdr  = 0x7F
    trace_data_hdr  = 0xBF

    # TODO Find out why HardwareHeader exception is triggered instead of SourcePacket for top part of list
    #TraceDataValueHeader(not_itm)
    #TraceDataValueHeader(sync_hdr)
    #TraceDataValueHeader(overflow_hdr)
    #TraceDataValueHeader(local_ts1_hdr)
    #TraceDataValueHeader(local_ts2_hdr)
    #TraceDataValueHeader(global_ts1_hdr)
    #TraceDataValueHeader(global_ts2_hdr)
    #TraceDataValueHeader(ext_hdr)
    #TraceDataValueHeader(inst_hdr)
    #TraceDataValueHeader(pc_sleep_hdr)
    #TraceDataValueHeader(pc_sample_hdr)
    #TraceDataValueHeader(exception_hdr)
    #TraceDataValueHeader(event_hdr)
    #TraceDataValueHeader(trace_addr_hdr)
    TraceDataValueHeader(trace_data_hdr)        # PASS !

    #LocalTimestampHeader(not_itm)
    #LocalTimestampHeader(sync_hdr)
    #LocalTimestampHeader(overflow_hdr)
    #LocalTimestampHeader(global_ts1_hdr)
    #LocalTimestampHeader(global_ts2_hdr)
    #LocalTimestampHeader(ext_hdr)
    #LocalTimestampHeader(inst_hdr)
    #LocalTimestampHeader(pc_sleep_hdr)
    #LocalTimestampHeader(pc_sample_hdr)
    #LocalTimestampHeader(exception_hdr)
    #LocalTimestampHeader(event_hdr)
    #LocalTimestampHeader(trace_addr_hdr)
    #LocalTimestampHeader(trace_data_hdr)
    LocalTimestampHeader(local_ts1_hdr)        # PASS !
    LocalTimestampHeader(local_ts2_hdr)        # PASS !

