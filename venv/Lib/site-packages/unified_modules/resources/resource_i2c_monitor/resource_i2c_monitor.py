import os
import time
import threading
import logging.handlers
import numpy as np
from unified_modules.test_support.testresults import TestResults
from unified_modules.resources.resource_i2c_monitor.cirrus_beagle_driver import BeagleDriver
from unified_modules.resources.resource_file_lib.resource_file_lib import ResourceFileLib as FileLib
try:
    import queue as Queue
except ImportError:
    import Queue


DEBUG_MODULE = False


class I2CMonitor:
    """
    I2CMonitor class is used to start a producer and one or several consumers of i2c packets
    while running a test case.
    """
    production_in_progress = True

    class Consumer:
        def __init__(self, custom_setup_function, custom_consume_function, custom_end_function,
                     period, duty_cycle, packets_stored_in_ram):
            self.setup_consumer = custom_setup_function or self.setup_default
            self.custom_consume_function = custom_consume_function
            self.end_function = custom_end_function
            self.time_period = period
            self.duty_cycle = duty_cycle
            self.big_chunk_size = packets_stored_in_ram
            self.size_of_small_chunk_of_packets = 10
            thread_name = "consumer_" + custom_consume_function.__name__
            self.thread_error = None
            self.consumer_thread = threading.Thread(target=self.start_consumer, name=thread_name)
            self.consumer_thread.daemon = True
            self.shared_queue = Queue.Queue()
            self.queue_size_log = []

        @staticmethod
        def setup_default():
            return 0

        def start_consumer(self):
            self.setup_consumer()
            if self.big_chunk_size:
                if self.consumer_thread.getName() == "consumer_log_i2c_transaction":
                    self.keep_circular_buffer()
                else:
                    self.consume_at_low_rate()
            else:
                self.consume_at_low_rate()
            self.consume_all_remaining_items_in_queue()
            if self.end_function is not None:
                try:
                    self.end_function()
                except Exception as error:
                    logging.error("End function error: {}".format(error))

        def keep_circular_buffer(self):
            while I2CMonitor.production_in_progress:
                if self.shared_queue.qsize() > self.big_chunk_size:
                    self.shared_queue.get()
                    self.shared_queue.task_done()
                else:
                    time.sleep(self.time_period)

        def consume_at_low_rate(self):
            chunk_of_items = self.size_of_small_chunk_of_packets
            while I2CMonitor.production_in_progress:
                if self.shared_queue.qsize() > chunk_of_items:
                    self.consume_fixed_number_of_items(sub_set_quantity=chunk_of_items)
                else:
                    time.sleep(self.duty_cycle)
                if DEBUG_MODULE:
                    self.query_consumer_buffer_status()

        def query_consumer_buffer_status(self):
            self.queue_size_log.append(self.shared_queue.qsize())

        def consume_all_remaining_items_in_queue(self):
            self.consume_fixed_number_of_items(sub_set_quantity=False)

        def consume_fixed_number_of_items(self, sub_set_quantity):
            try:
                if sub_set_quantity:
                    for _ in range(sub_set_quantity):
                        self.custom_consume_function(self.shared_queue.get())
                        self.shared_queue.task_done()
                else:
                    if DEBUG_MODULE:
                        debug_string = "[{}]: Queue size queue when production has stopped: {}"
                        logging.info(debug_string.format(self.consumer_thread.getName(),
                                                         self.shared_queue.qsize()))
                    for single_queued_item in self.get_single_item_from_queue():
                        self.custom_consume_function(single_queued_item)
                        self.shared_queue.task_done()
            except Exception as e:
                self.thread_error = e

        def get_single_item_from_queue(self):
            while self.shared_queue.qsize():
                yield self.shared_queue.get()

    def __init__(self):
        """
        Initializations
        """
        self.i2c_device = BeagleDriver(i2c_packet_length=10000)
        self.output_root_dir = ""
        self.producer_thread = threading.Thread(target=self.start_producer, name='producer')
        self.i2c_monitoring_disabled = True
        self.consumers = []
        self.i2c_log = None
        self.buffer_usage_log = []
        self.end_function = None
        self.packet_index = 0

    def start_i2c_monitoring(self, setup_function=None, loop_function=None,
                             end_function=None, period_s=0.1,
                             duty_cycle=0.01, packets_stored_in_ram=0):
        if self.i2c_device.open():
            logging.info("Starting I2C monitoring")
            # Add default logger consumer
            self.add_consumer(setup_function_pointer=self.configure_logger,
                              consume_function_pointer=self.log_i2c_transaction, period=period_s,
                              duty_cycle=duty_cycle, packets_stored_in_ram=100000)
            # Add optional consumer (externally defined).
            if loop_function:
                self.add_consumer(consume_function_pointer=loop_function, period=period_s,
                                  duty_cycle=duty_cycle, setup_function_pointer=setup_function,
                                  end_function_pointer=end_function,
                                  packets_stored_in_ram=packets_stored_in_ram)
            self.i2c_monitoring_disabled = False
            for thread in self.consumers:
                thread.consumer_thread.start()
            self.producer_thread.start()

    def add_consumer(self, consume_function_pointer, setup_function_pointer=None,
                     end_function_pointer=None, period=0.1, duty_cycle=0.01,
                     packets_stored_in_ram=0):
        self.consumers.append(
            self.Consumer(setup_function_pointer, consume_function_pointer, end_function_pointer,
                          period, duty_cycle, packets_stored_in_ram))

    def configure_logger(self):
        """
        Set path and open file for printing I2C data
        """
        params = self._load_logger_configuration_parameters()
        max_bytes = int(params['max_file_size_MB']) * 1024 * 1024
        backup_count = int(params['max_file_count'])
        i2c_output_file = params['i2c_output_file']
        bus_log_handler = logging.handlers.RotatingFileHandler(i2c_output_file, maxBytes=max_bytes,
                                                               backupCount=backup_count)
        bus_log_handler.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(message)s')
        bus_log_handler.setFormatter(formatter)
        self.i2c_log = logging.getLogger('i2c_channel')
        self.i2c_log.setLevel(logging.DEBUG)
        self.i2c_log.addHandler(bus_log_handler)
        header = ["# Level", "Index", "h:m:s.ms.us", "Dur", "Len", "Err", "S/P", "Addr", "Record",
                  "Data", "ASCII"]
        self.i2c_log.debug(','.join(header))

    def _load_logger_configuration_parameters(self):
        config_file = 'logger_i2c_config.yml'
        config_file_path = FileLib().get_abs_path_relative_to_current_module(config_file, __file__)
        logger_parameters = FileLib.load_yaml_file(config_file_path)
        if logger_parameters['max_file_size_MB'] > 100:
            logging.warning("Allowed max_file_size_MB is 100 Mb!")
        if logger_parameters['max_file_count'] > 1000:
            logging.warning("Allowed max_file_count is 1000 files!")
        if logger_parameters['max_file_size_MB'] * logger_parameters['max_file_count'] >= 1024:
            logging.warning("The total log size is more than 1 Gb!")
        i2c_file = 'i2c_output_file'
        if logger_parameters.get('i2c_output_file'):
            i2c_file = logger_parameters.get('i2c_output_file')
        logger_parameters['i2c_output_file'] = os.path.join(self.output_root_dir, i2c_file)
        return logger_parameters

    def log_i2c_transaction(self, packet):
        if packet.frame_size > -1:
            i2c_record = "0,{},{},{:10.3f} us,{} B,{},{},{},,"
            if packet.address.endswith("r"):
                address_operation = packet.address.replace("r", ",Read Transaction")
            else:
                address_operation = packet.address.replace("w", ",Write Transaction")
            i2c_data_in_hex = " ".join(['%02x' % x for x in packet.data])
            self.i2c_log.debug(
                i2c_record.format(self.packet_index, packet.timestamp, packet.duration_us,
                                  packet.frame_size, packet.status, address_operation,
                                  i2c_data_in_hex))
        self.packet_index += 1

    def start_producer(self):
        while self.i2c_device.has_packets_waiting() or not self.i2c_monitoring_disabled:
            i2c_packet = self.i2c_device.read()
            for consumer in self.consumers:
                consumer.shared_queue.put(i2c_packet)
            buffer_usage_rate = self.i2c_device.query_buffer_usage()
            if DEBUG_MODULE:
                self.debug_shared_queues_status(buffer_usage_rate)
        self.wait_shared_queue_is_fully_consumed()
        self.i2c_device.close()

    def debug_shared_queues_status(self, buffer_usage_rate):
        if self.i2c_monitoring_disabled and not buffer_usage_rate:
            logging.info("[{}]: Beagle buffer_usage_rate: {}".format(self.producer_thread.getName(),
                                                                     buffer_usage_rate))
        else:
            self.buffer_usage_log.append(buffer_usage_rate / 100)

    def wait_shared_queue_is_fully_consumed(self):
        I2CMonitor.production_in_progress = False
        for consumer in self.consumers:
            if DEBUG_MODULE:
                debug_string = "[{}]: waiting for {} to empty its shared queue: {}"
                logging.info(debug_string.format(self.producer_thread.getName(),
                                                 consumer.consumer_thread.getName(),
                                                 consumer.shared_queue.qsize()))
            consumer.shared_queue.join()  # Wait the consumers empty the shared queue.
        if DEBUG_MODULE:
            logging.info("[{}]: All the consumers have emptied their shared queue. DONE!".format(
                self.producer_thread.getName()))

    def stop_i2c_monitoring(self):
        logging.info("Stop i2c monitoring")
        if DEBUG_MODULE:
            logging.info("[MainThread] {} threads: {}".format(threading.active_count(),
                                                              threading.enumerate()))
        if not self.i2c_monitoring_disabled:
            self.stop_producer()
            self.stop_consumers()
        return self.i2c_monitoring_disabled

    def stop_producer(self):
        # Keep reading the beagle buffer 2 additional seconds because it reports zeros
        # periodically and it is a condition to exit the producer loop
        wait_for_beagle_buffer = 2
        for consumer in self.consumers:
            if DEBUG_MODULE:
                debug_string = "[MainThread]: {} shared queue SIZE: {}"
                logging.info(debug_string.format(consumer.consumer_thread.getName(),
                                                 consumer.shared_queue.qsize()))
        time.sleep(wait_for_beagle_buffer)
        self.i2c_monitoring_disabled = True
        if DEBUG_MODULE and self.buffer_usage_log:
            debug_string = "[{}] buffer history on average: {}"
            logging.info(debug_string.format(self.producer_thread.getName(),
                                             np.average(self.buffer_usage_log)))

    def stop_consumers(self):
        for consumer in self.consumers:
            if consumer.thread_error is None:
                if DEBUG_MODULE:
                    debug_string = "[MainThread]: waiting for {}"
                    logging.info(debug_string.format(consumer.consumer_thread.getName()))
                consumer.consumer_thread.join()
            else:
                logging.error("[{}]: Error in consumer loop_function(): {}".format(
                    consumer.consumer_thread.getName(), consumer.thread_error))
            if DEBUG_MODULE and consumer.queue_size_log:
                logging.info("[{}] average buffer: {}".format(consumer.consumer_thread.getName(),
                                                              np.average(consumer.queue_size_log)))


if __name__ == "__main__":
    class ResourceI2CMonitorUnitTest(I2CMonitor):
        """
        UnitTest for File lib resource.
        """

        def __init__(self):
            super(ResourceI2CMonitorUnitTest, self).__init__()
            self.results = TestResults()
            self.results.set_test_title('test_resource_i2c_monitor')
            self.log = self.results.log

        def test_resource_i2c_monitor(self):
            self.start_i2c_monitoring()
            time.sleep(15)
            self.results.assert_not_equal(self.consumers, [], "List of consumers is not empty")
            for consumer in self.consumers:
                self.results.assert_not_equal(consumer.shared_queue.qsize(), 0, "i2c packet queue")
            self.stop_i2c_monitoring()
            for consumer in self.consumers:
                self.results.assert_equal(consumer.shared_queue.qsize(), 0, "i2c packet queue")

    class_under_test = ResourceI2CMonitorUnitTest()
    class_under_test.test_resource_i2c_monitor()
