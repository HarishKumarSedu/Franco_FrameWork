from collections import namedtuple
from datetime import datetime
from unified_modules.resources.resource_i2c_monitor.totalphase_api import beagle_py as beagle
import logging


class BeagleDriver:
    _InputI2cPacket = namedtuple('_InputI2cPacket',
                                 ['count', 'status_code', 'time_sop', 'time_duration',
                                  'time_data_offset', 'latest_data'])

    I2cPacket = namedtuple('I2cPacket', ['timestamp', 'duration_us', 'frame_size', 'status',
                                         'address', 'data'])

    def __init__(self, i2c_packet_length=1000):
        self.beagle_id = None
        self.port = None
        self.bg_host_buffer_size = None
        self.sample_rate_khz = None
        self.data_input = beagle.array_u16(i2c_packet_length)

    def open(self):
        open_status = False
        if self.detect_one_beagle_device():
            open_status = self.open_and_configure_device()
        else:
            logging.error("BeagleDriver. open(): Not able to open a beagle device")
        return open_status

    def close(self):
        beagle.bg_disable(self.beagle_id)
        beagle.bg_close(self.beagle_id)
        logging.info("Beagle device closed.")

    def has_packets_waiting(self):
        return beagle.bg_host_buffer_used(self.beagle_id)

    def query_buffer_usage(self):
        buffer_usage_rate = beagle.bg_host_buffer_used(self.beagle_id) / self.bg_host_buffer_size
        return buffer_usage_rate

    def read(self):
        data_in = BeagleDriver._InputI2cPacket(*beagle.bg_i2c_read(self.beagle_id, self.data_input))
        if data_in.count < 0:
            self.reconnect()
        return BeagleDriver.I2cPacket(*self.decode_i2c_packet(data_in))

    def reconnect(self):
        self.close()
        self.open_and_configure_device()

    def decode_i2c_packet(self, data_in):
        timestamp = self.decode_timing_data(data_in.time_sop)
        duration_us = self.timing_data_to_us(data_in.time_duration)
        status = self.decode_status(data_in.status_code, data_in.latest_data[0])
        address, data_copy = self.copy_received_data(data_in.latest_data, data_in.count,
                                                     data_in.status_code)
        data_length = data_in.count - 1 if data_in.count > 0 else data_in.count
        return timestamp, duration_us, data_length, status, address, data_copy

    def decode_timing_data(self, time_sop):
        nanosecond = 10 ** 9
        microsecond = 10 ** 6
        # Translate timestamp when the packet begun to ns
        time_sop_ns = self.timing_data_to_ns(time_sop)
        # Get system date and time format
        system_time = datetime.fromtimestamp(time_sop_ns // nanosecond)
        system_time = system_time.replace(hour=0)
        time_stamp = system_time.strftime('%H:%M:%S')
        str_millis = str(time_sop_ns % nanosecond // microsecond).zfill(3)
        str_microseconds = str(time_sop_ns % microsecond // 1000).zfill(3)
        return time_stamp + '.' + str_millis + '.' + str_microseconds

    def timing_data_to_ns(self, timing_data):
        """
        Timing data to nanoseconds
        @:param timing_data: All of the timing data is measured in ticks of the sample rate clock.
        """
        return (timing_data * 1000) // (self.sample_rate_khz // 1000)

    def timing_data_to_us(self, timing_data):
        """
        Timing data to nanoseconds
        @:param timing_data: All of the timing data is measured in ticks of the sample rate clock.
        """
        return (timing_data * 1000.0) // self.sample_rate_khz

    @staticmethod
    def decode_status(status, address_byte):
        """
        Display general status codes
        """
        general_status = ""
        stop_condition = ","
        nack_status = ""
        if status == beagle.BG_READ_OK:
            general_status += ("OK" + " ")
        if status & beagle.BG_READ_TIMEOUT:
            general_status += ("TIMEOUT" + " ")
        if status & beagle.BG_READ_ERR_MIDDLE_OF_PACKET:
            general_status += ("MIDDLE" + " ")
        if not status & beagle.BG_READ_TIMEOUT and not status & beagle.BG_READ_ERR_MIDDLE_OF_PACKET:
            stop_condition += "S"
        if status & beagle.BG_READ_ERR_SHORT_BUFFER:
            general_status += ("SHORT BUFFER" + " ")
        if status & beagle.BG_READ_ERR_PARTIAL_LAST_BYTE:
            general_status += ("PARTIAL_BYTE(bit %d)" % (status & 0xff) + " ")
        if status & beagle.BG_READ_I2C_NO_STOP:
            general_status += "I2C_NO_STOP"
        else:
            stop_condition += "P"
        # Determine if address byte was NACKed
        if address_byte & beagle.BG_I2C_MONITOR_NACK:
            nack_status += " *"
        return general_status + stop_condition + nack_status

    def copy_received_data(self, beagle_array_u16, count, status):
        """
        @:param beagle_array_u16:  an allocated array of u16 which is filled with the received data
                                   type: array.array('H', [0] * n)
                                   For each u16 written to data_in by the function, the lower 8-bits
                                   represent the value of a byte of data sent across the bus and
                                   bit 8 represents the ACK or NACK value for that byte.
        @:param count:   number of bytes read or a negative value indicating an error
        @:param status:  filled with the status bit mask
        """
        address = ""
        if count <= 0 or status & beagle.BG_READ_ERR_MIDDLE_OF_PACKET:
            return address, []
        # a leading '111 10xx' introduces the 10 bit addressing scheme
        if count == 1 or (beagle_array_u16[0] & 0xf9) != 0xf0:
            address += self.display_seven_bit_address(beagle_array_u16[0])
            address_size = 1
        else:
            address_size = 2
            address += self.display_ten_bit_address(beagle_array_u16[:address_size])
        data = [x & 255 for x in beagle_array_u16[address_size: count]]
        return address, data

    def display_seven_bit_address(self, address_byte):
        address = ("%02x" % (int(address_byte & 0xff) >> 1))
        address += self.decode_rw_operation_status(address_byte)
        return address

    def display_ten_bit_address(self, address_bytes):
        first_byte_mask = 0x300
        second_byte_mask = 0xff
        address = ("%03x" % ((address_bytes[0] << 7) & first_byte_mask | (
                    address_bytes[1] & second_byte_mask)))
        address += self.decode_rw_operation_status(address_bytes[0])
        return address

    @staticmethod
    def decode_rw_operation_status(address_byte):
        """
        Display I2C data input status: read, write, ..
        @:param nack
        """
        operation = ""
        if address_byte & 0x01:
            operation += "r"
        else:
            operation += "w"
        return operation

    def detect_one_beagle_device(self):
        """
        Detect beagle devices. Only allow capturing for 1 device
        """
        one_device_ready = False
        num, ports, unique_ids = beagle.bg_find_devices_ext(16, 16)
        if num > 1:
            logging.warning("Beagle I2C capture: More than 2 devices connected."
                            "Utility works for only 1 device.")
        elif num == 1:
            self.port = ports[0]
            one_device_ready = self.is_device_available(num, ports, unique_ids)
        else:
            logging.error("BeagleDriver. detect_one_beagle_device(): No Beagle devices found.")
        return one_device_ready

    @staticmethod
    def is_device_available(num, ports, unique_ids):
        """
        Print the information on each device
        @:param num of devices
        @:param ports
        @:param unique ids
        """
        device_available = True
        inuse_status = "(available)"
        for i in range(num):
            port = ports[i]
            unique_id = "%04d-%06d" % (unique_ids[i] // 1000000, unique_ids[i] % 1000000)
            # Determine if the device is in-use
            device_status = "Beagle device: {} in port: {} status: {}"
            if port & beagle.BG_PORT_NOT_FREE:
                inuse_status = "(in-use)"
                port = port & ~beagle.BG_PORT_NOT_FREE
                device_available = False
                logging.error(device_status.format(unique_id, port, inuse_status))
            else:
                logging.info(device_status.format(unique_id, port, inuse_status))
        return device_available

    def open_and_configure_device(self):
        config_completed = False
        self.beagle_id = beagle.bg_open(self.port)
        if self.beagle_id <= 0:
            logging.error("Unable to open Beagle device on port %d" % self.port)
            logging.error("beagle.gb_open ERROR code = %d" % self.beagle_id)
        else:
            if self.set_beagle_device_settings():
                config_completed = True
        return config_completed

    def set_beagle_device_settings(self):
        """
         Configure device settings
         """
        device_enabled = False
        if self.set_sample_rate():
            self.set_timeout()
            self.set_latency()
            self.set_buffer_size()
            self.set_i2c_pull_up_target_power()
            if self.enable_monitor_i2c_protocol():
                device_enabled = True
        return device_enabled

    def set_sample_rate(self, default_sample_rate=10000):
        """
         Set sampling rate, default_sample_rate=10,000 kHz
         """
        sampling_rate_set = True
        # Set the sample_rate
        sample_rate = beagle.bg_samplerate(self.beagle_id, default_sample_rate)
        if sample_rate < 0:
            logging.warning("Sampling rate set to %d KHz." % sample_rate)
            logging.warning("Error: %s" % beagle.bg_status_string(sample_rate))
            sampling_rate_set = False
        else:
            # Get current_sampling_rate
            self.sample_rate_khz = beagle.bg_samplerate(self.beagle_id, 0)
        return sampling_rate_set

    def set_timeout(self, timeout_ms=3000):
        """
        Set the idle timeout.
        The Beagle read functions will return in the specified time
        if there is no data available on the bus.
        """
        beagle.bg_timeout(self.beagle_id, timeout_ms)

    def set_latency(self, latency_ms=200):
        """
        Set the latency.
        The latency parameter allows the programmer to balance the trade off between host side
        buffering and the latency to receive a packet when calling one of the Beagle read functions.
        """
        beagle.bg_latency(self.beagle_id, latency_ms)

    def set_buffer_size(self, size=None):
        """
        Set the amount of buffering that is to be allocated on the analysis PC.
        This function sets the amount of memory allocated to buffering data that has been siphoned
        off the Beagle analyzer by the host software library, but not yet read by the application.
        The absolute minimum and maximum values for this buffer size are 64 kB and 16 MB,
        respectively.
        :return:
        """
        max_buffer_size = 16 * 1024 * 1024  # in bytes
        if size is None:
            beagle.bg_host_buffer_size(self.beagle_id, max_buffer_size)
        else:
            beagle.bg_host_buffer_size(self.beagle_id, size)
        self.bg_host_buffer_size = float(beagle.bg_host_buffer_size(self.beagle_id, 0))

    def set_i2c_pull_up_target_power(self):
        """
        Pull ups and target power configuration
        """
        pull_ups = beagle.BG_I2C_PULLUP_OFF
        target_pow = beagle.BG_TARGET_POWER_OFF
        beagle.bg_i2c_pullup(self.beagle_id, pull_ups)
        beagle.bg_target_power(self.beagle_id, target_pow)

    def enable_monitor_i2c_protocol(self):
        """
        Enable beagle monitor
        """
        enable_monitor = True
        if beagle.bg_enable(self.beagle_id, beagle.BG_PROTOCOL_I2C) != beagle.BG_OK:
            logging.info("Error: could not enable I2C capture; exiting...")
            enable_monitor = False
        return enable_monitor


if __name__ == '__main__':
    beagle_i2c = BeagleDriver()
    if beagle_i2c.open():
        print(beagle_i2c.has_packets_waiting())
        print(beagle_i2c.read())
        beagle_i2c.close()
