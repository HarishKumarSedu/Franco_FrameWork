#!/usr/bin/env python
"""

@brief
A resource library to perform data operations

@Description:
This resource library provides wrapper methods to perform data operations
like bytes_to_num, get_bit_field etc...,


"""


from __future__ import division
from unified_modules.test_support.testresults import TestResults
import random
import zlib
import math

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class ResourceDataLib(object):
    @staticmethod
    def num_to_bytes(number, byte_count, little_endian=True):
        byte_list = []
        for byte_index in range(byte_count):
            bits_to_shift = 8 * byte_index
            current_byte = (number >> bits_to_shift) & 0xff
            byte_list.append(current_byte)

        # little endian means LSB is is in Byte position 0. Big endian means
        # MSB is in position 0
        if not little_endian:
            byte_list.reverse()

        return byte_list

    @staticmethod
    def bytes_to_num(byte_list, little_endian=True, bit_length=8):
        # loop through byte_list backwards and add up all the byte values
        # according to their position
        if isinstance(byte_list, list):
            byte_count = len(byte_list)
            number = 0
            for i in range(byte_count):
                bits_to_shift = i * bit_length if little_endian else \
                    (byte_count - i - 1) * bit_length
                number |= byte_list[i] << bits_to_shift
        else:
            number = byte_list

        return number

    def convert_words_to_bytes(self, word_list, bytes_per_word,
                               little_endian=True):
        byte_list = []
        for word in word_list:
            word_bytes = self.num_to_bytes(word, bytes_per_word, little_endian)
            # Payload must be Big Endian
            byte_list += word_bytes
        return byte_list

    def convert_bytes_to_words(self, byte_list, bytes_per_word, little_endian=True):
        number_of_registers = len(byte_list) // bytes_per_word
        if not isinstance(number_of_registers, int):
            raise ValueError('Data payload does not contain an integral number of '
                             'words of specified size.')

        # iterate through byte_list, jump by # bytes in a word, convert each
        # byte group to a word and add to word_list
        # word_pointer is  a byte index that jumps by # bytes per word,
        # i.e. points to start of each word in byte_list
        # byte_index is an index of the bytes within a single word
        word_list = []
        for word_pointer in range(0, len(byte_list), bytes_per_word):
            byte_slice = byte_list[word_pointer: word_pointer + bytes_per_word]
            word_value = self.bytes_to_num(byte_slice, little_endian)  # Payload is be Big Endian
            word_list.append(word_value)
        return word_list

    @staticmethod
    def validate_expected_values(actual_values, expected_values, mask_values):
        if len(actual_values) != len(expected_values):
            raise ValueError(
                "The length size of expected values ({0}) do not match with the length"
                " of actual values ({1})".format(len(expected_values), len(actual_values)))
        # If mask_values is empty, proceed to compare value without the mask
        if len(mask_values) == 0:
            if expected_values != actual_values:
                raise ValueError(
                    'The expected values ({0}) does not match with current values ({1})'.format(
                        expected_values, actual_values))
        else:
            # Verify mask_values length is the same length than actual_values and expected_values
            if len(actual_values) != len(mask_values):
                raise ValueError(
                    "The length size of mask values ({0}) do not match with the length of actual"
                    "values or expected values ({1})".format(len(mask_values), len(actual_values)))
            for actual, expected, mask in zip(actual_values, expected_values, mask_values):
                if (actual & mask) != (expected & mask):
                    raise ValueError(
                        'The expected values ({0}) does not match with actual values ({1})'
                        ' AND mask values ({2})'.format(expected, actual, mask))

    @staticmethod
    def pop_slice(original_list, start_index=0, end_index=1):
        popped_items = original_list[start_index: end_index]
        del original_list[start_index: end_index]
        return popped_items

    @staticmethod
    def get_bit_field(number, start_index, bit_width):
        """
        Extract a bitfield from number
        :param number: Number from which bitfield will be extracted
        :param start_index: Start index of bitfield, least-significant
        bit has index = 0
        :param bit_width: Number of bits in bitfield to extract
        :return: Extracted bitfield, converted to a number
        """
        # convert number into binary first and remove first two characters '0b'
        binary_str = bin(number)
        if number >= 0:
            binary_str = binary_str[2:]
        else:
            binary_str = binary_str[3:]

        # If the bitfield requested exceeds the size of the binary string,
        # xero-pad to cover all required bits
        zero_pad_size = start_index + bit_width - len(binary_str)
        binary_str = '0' * zero_pad_size + binary_str

        # start and end indices are required, since the number bits are in big
        # endian (MSb in pos 0),
        # but start_index assumes the LSb is in pos0
        end = len(binary_str) - start_index - 1
        start = end - bit_width + 1

        # extract bit sub-string
        extracted_bin = binary_str[start: end + 1]

        # convert extracted sub-string into decimal again
        extracted_num = int(extracted_bin, 2)

        return extracted_num

    @staticmethod
    def calculate_checksum(byte_list):
        checksum = abs(sum(byte_list) & 0xff)
        checksum = 0xFF - checksum
        return checksum

    @staticmethod
    def is_integer(x):
        return isinstance(x, int)

    @staticmethod
    def is_string(x):
        return isinstance(x, str)

    def generate_random_words(self, word_count, bits_per_word):
        """
        Generate list of random words with specified number of bits per word
        :param word_count: Number of random words to generate in list
        :param bits_per_word: Number of bits per word, e.g. for full words use
        32, for half words use 16, for bytes use 8
        :return: List of random words (integers)
        """
        max_value = 2 ** bits_per_word - 1
        random_words = self.generate_random_values(word_count, 0, max_value)
        return random_words

    @staticmethod
    def generate_random_values(value_count, min_value, max_value):
        """
        Generate list of random values from min_value to max_value, endpoints
        included
        :param value_count: number of random values to generate in list
        :param min_value: minimum value for random value, inclusive
        :param max_value: maximum value for random value, inclusive
        :return: list of random integers
        """
        random_values = []
        for i in range(value_count):
            random_value = random.randint(min_value, max_value)
            random_values.append(random_value)
        return random_values

    @staticmethod
    def convert_bytes_to_word(bytes_list, word_length):
        """
        Convert bytes list to words of given length
        :param bytes_list: byte array
        :param word_length: no of bytes per word
        :return: words list
        """
        word_list = []
        byte_count = 0
        word = 0

        for byte in bytes_list:
            word = (word << 8) + byte
            byte_count += 1

            if byte_count == word_length:
                word_list.append(word)
                word = 0
                byte_count = 0
        return word_list

    @staticmethod
    def convert_hex_string_to_integer(hex_string):
        return int(hex_string, 16)

    @staticmethod
    def are_elements_same_type(lst):
        same_type = True
        length_lst = len(lst)
        for i in range(length_lst - 1):
            if not isinstance(lst[length_lst - 1 - i], type(lst[length_lst - 1 - (i + 1)])):
                same_type = False
                break
        return same_type

    def convert_strings_to_numbers(self, string_list):
        """
        convert_strings_to_numbers() method converts every item in a list of
        strings numbers (they can be in hex format) to integers.
        NOTE: All the elements have the same type
        @:param string_list: it is a list of fixed point values
        @:return integer_list
        """
        integer_list = []
        if string_list and self.are_elements_same_type(string_list):
            if string_list[0].find('0x') > -1:
                integer_list = [int(hex_string, 16) for hex_string in string_list]
            elif string_list[0].isalnum():
                integer_list = [int(string) for string in string_list]
        return integer_list

    def convert_num_list_to_hex_string(self, num_list, sep=","):
        return sep.join(self.convert_nums_lst_to_hex_lst(num_list))

    def convert_nums_lst_to_hex_lst(self, num_list):
        return [self.convert_to_hex_string(num) for num in num_list]

    def convert_to_hex_string(self, item):
        if self.is_integer(item):
            return hex(item)
        else:
            return repr(item)

    def binary_file_data_to_bytelist(self, binary_file_path):
        raw_binary_data = self._load_data_from_file(binary_file_path)
        byte_list = self._convert_binary_data_to_byte_list(raw_binary_data)
        return byte_list

    @staticmethod
    def _load_data_from_file(file_path):
        with open(file_path, 'rb') as bin_file:
            raw_binary_data = bin_file.read()
        return raw_binary_data

    @staticmethod
    def _convert_binary_data_to_byte_list(binary_data):
        byte_list = []
        if not isinstance(binary_data, str):
            binary_data = "".join(chr(byte) for byte in binary_data)

        for binary_byte in binary_data:
            # The ord() method returns an integer representing Unicode code
            # point for the given Unicode character
            data_byte = ord(binary_byte)
            byte_list.append(data_byte)
        return byte_list

    @staticmethod
    def convert_to_list(value):
        if not isinstance(value, list):
            value = [value]
        return value

    @staticmethod
    def get_data_length(data):
        """
        Return length of data type. If the data type is not a countable
        data type (list, tuple, etc.) return 1
        :param data: data for which the length will be returned
        :return: Length of input data
        """
        try:
            length = len(data)
        except TypeError:
            length = 1
        return length

    @staticmethod
    def get_data_list(data):
        """
        If data is not a list, add data to a list and return that list. If data
         is already a list, return as is
        :param data: input data to be returned a a list
        :return: data as a list, or as is if already a list
        """
        if not isinstance(data, list):
            payload = [data]
        else:
            payload = data
        return payload

    @staticmethod
    def split_list_into_sub_lists(items_list, sub_list_length):
        """
        Split the given list of items into sub-lists.
        The last sublist can have a size smaller than sub_list_length
        :param items_list: list of items
        :param sub_list_length: (int) sub list length
        :return: list of sized sub-lists
        """
        sub_lists = []
        counter = 0
        sub_list = []
        for item in items_list:
            sub_list.append(item)
            counter += 1
            if counter == sub_list_length:
                sub_lists.append(sub_list)
                sub_list = []
                counter = 0
        # Add the left overs at the end
        if len(sub_list) > 0:
            sub_lists.append(sub_list)
        return sub_lists

    def convert_number_to_fixed_point_format(self, value, bit_length, decimal_bits):
        fix_point_base_code = 2
        integer_value = int(value * fix_point_base_code ** decimal_bits)
        if integer_value < 0:
            positive_value = integer_value * -1
            value = self.twos_complement(positive_value, bit_length)
            integer_value = \
                self.set_bits_field(previous_register_value=value,
                                    bit_width=1,
                                    position_lsb=bit_length - 1,
                                    new_field_value=1,
                                    number_bits_width=bit_length)
        return integer_value

    @staticmethod
    def float_to_24_bit_format(float_value):
        def shift_exponent_16_bits(previous_value, exp):
            return previous_value + math.floor(exp * 2 ** 16)

        def place_sign_bit_at_msb(previous_value, s):
            return previous_value + math.floor(s * 2 ** 23)

        def convert_mantissa_to_16_bits(y):
            return round(y * 2 ** 16)

        x = abs(float_value)
        mantissa = x
        lowest_value_of_exponent = -62
        exponent = lowest_value_of_exponent
        sign = 0
        if float_value < 0:
            sign = 1
        if mantissa > 2 ** 63:  # Handling NaN
            dec_value = math.floor(0)
            exponent = 127
            dec_value = shift_exponent_16_bits(dec_value, exponent)
            dec_value = place_sign_bit_at_msb(dec_value, sign)
        elif mantissa < 2 ** lowest_value_of_exponent:  # Handling normal case
            dec_value = math.floor(0)
            dec_value = place_sign_bit_at_msb(dec_value, sign)
        elif 1.0 <= mantissa < 2.0:  # fraction with exponent  0
            exponent = 63            # exponent biasing value
            mantissa = mantissa - 1  # fraction part of 1.?
            dec_value = convert_mantissa_to_16_bits(mantissa)
            dec_value = shift_exponent_16_bits(dec_value, exponent)
            dec_value = place_sign_bit_at_msb(dec_value, sign)
        else:  # Handling other numbers
            # Loop to scale the number in the range [1.0, 2.0)
            while mantissa < 1 or mantissa >= 2.0:
                mantissa = x / 2 ** exponent
                exponent = exponent + 1
            exponent = exponent + 62   # exponent biasing value
            mantissa = mantissa - 1    # fraction part of 1.?
            dec_value = convert_mantissa_to_16_bits(mantissa)
            dec_value = shift_exponent_16_bits(dec_value, exponent)
            dec_value = place_sign_bit_at_msb(dec_value, sign)
        return int(dec_value)

    def convert_to_signed_number(self, value, bit_length, decimal_bits=0):
        """
        This method converts the given number to signed number based on signed
         bit position
        :param value: number to be converted to signed number
        :param bit_length: Total bit length, highest bit (MSB) is considered
        as Signed bit
        :param decimal_bits: Number of decimal bits in binary value, e.g.
        Q12.7 format has decimal_bits=7
        :return: Signed number
        """
        value = self.keep_lower_bits(value, bit_length)
        signed_bit = self.get_bit_field(value, start_index=bit_length - 1, bit_width=1)
        if signed_bit == 1:
            positive_value = self.twos_complement(value, bit_length)
            value = positive_value * -1

        # shift the number to the right if there are decimal bits
        if decimal_bits > 0:
            value = float(value) / 2 ** decimal_bits
        return value

    @staticmethod
    def keep_lower_bits(value, bit_length):
        """
        This number takes only the number of bits required from the given
         value by masking the remaining bits.
        :param value:
        :param bit_length:
        :return: Masked value
        """
        mask = 2 ** bit_length - 1
        return value & mask

    @staticmethod
    def twos_complement(value, bit_length):
        """
        This method returns the 2's complement of the given number
        :param value: number to be converted to 2's complement
        :param bit_length: total no.of bits in the given number
        :return: 2's complement
        """
        max_value = (2 ** bit_length) - 1
        complement_value = (max_value - value) + 1
        return complement_value & max_value

    @staticmethod
    def get_bits_field(number, bit_width, position_lsb):
        return ((1 << bit_width) - 1) & (number >> position_lsb)

    @staticmethod
    def set_bits_field(previous_register_value, bit_width, position_lsb, new_field_value,
                       number_bits_width=8):
        mask = ((1 << bit_width) - 1) << position_lsb
        value_to_keep = ((~mask & ((1 << number_bits_width) - 1)) & previous_register_value)
        return value_to_keep | (new_field_value << position_lsb)

    @staticmethod
    def crc32_calculator(byte_list):
        import sys
        if sys.version.startswith('2'):  # Python 2
            char_list = [chr(i) for i in byte_list]
            crc = zlib.crc32(''.join(char_list))
        else:
            crc = zlib.crc32(bytes(byte_list))  # Python 3
        mask_32bits = (1 << 32) - 1
        return crc & mask_32bits


if __name__ == "__main__":

    class ResourceDataLibUnitTest(ResourceDataLib):
        """
        UnitTest for Data lib resource.
        """

        def __init__(self):
            self.results = TestResults()
            self.results.set_test_title('test_resource_data_lib')
            self.log = self.results.log

        def test_resource_data_lib(self):
            number = 2425
            returned_bytes = self.num_to_bytes(number, 3)
            self.results.assert_equal([121, 9, 0], returned_bytes,
                                      "number {0} in bytes".format(number))

            num = self.bytes_to_num(returned_bytes)
            self.results.assert_equal(2425, num, "bytes {0} to number"
                                      .format(returned_bytes))

            words_to_bytes = self.convert_words_to_bytes(returned_bytes, 3)
            self.results.assert_equal([121, 0, 0, 9, 0, 0, 0, 0, 0], words_to_bytes,
                                      "words {0} to bytes".format(returned_bytes))

            bytes_to_word = self.convert_bytes_to_word(words_to_bytes, 3)
            self.results.assert_equal([7929856, 589824, 0], bytes_to_word,
                                      "bytes {0} to words".format(words_to_bytes))

            popped_slice = self.pop_slice(words_to_bytes, 1, 4)
            self.results.assert_equal([0, 0, 9], popped_slice, "slice in {0} "
                                      .format(words_to_bytes))

            words_list = self.generate_random_words(10, 3)
            self.log.info("generated random words %s", words_list)

            values = self.generate_random_values(20, 1, 30)
            self.log.info("random values : %s", values)

            string_list = ['1', '2', '3', '4', '5']
            numbers_list = self.convert_strings_to_numbers(string_list)
            self.results.assert_equal([1, 2, 3, 4, 5], numbers_list, "string list {0} "
                                      .format(numbers_list))
            hex_list = self.convert_nums_lst_to_hex_lst(numbers_list)
            self.results.assert_equal(['0x1', '0x2', '0x3', '0x4', '0x5'],
                                      hex_list, "number list {0} in hex format"
                                      .format(numbers_list))

            string_of_hex_numbers = self.convert_num_list_to_hex_string([1, 2 ** 32])
            self.results.assert_equal("0x1,0x100000000",
                                      string_of_hex_numbers, "number list {0} in hex format"
                                      .format(numbers_list))

            sub_list = self.split_list_into_sub_lists(numbers_list, 3)
            self.results.assert_equal([[1, 2, 3], [4, 5]], sub_list,
                                      "list {0} is splited into sub lists"
                                      .format(numbers_list))

            complement = self.twos_complement(number, 8)
            self.results.assert_equal(135, complement, "Complement of {0} "
                                                       "for 8 bit length ".format(number))

            bin_file = "patch_test.bin"
            actual_byte_list = self.binary_file_data_to_bytelist(bin_file)
            expected_byte_list = [48, 50, 51, 53, 55, 67, 73, 82, 114, 117, 83]
            self.results.assert_equal(actual_byte_list, expected_byte_list,
                                      "binary_file_data_to_bytelist")

            bit_field_number = self.get_bit_field(number, start_index=2, bit_width=4)
            self.results.assert_equal(14, bit_field_number,
                                      "extracted bit fields in {0} ".format(number))

            bit_field_number = self.get_bits_field(number, bit_width=4, position_lsb=2)
            self.results.assert_equal(14, bit_field_number,
                                      "extracted bit fields in {0} ".format(number))

            register_initial_value = 1
            final_value = self.set_bits_field(previous_register_value=register_initial_value,
                                              bit_width=1, position_lsb=7, new_field_value=1,
                                              number_bits_width=8)
            self.results.assert_equal(2 ** 7 + 1, final_value, "final register value")

            test_input_list = [25, 121, 64, 22, 0, 9, 0, 1, 0, 0, 0, 0, 0, 58, 0, 1, 0, 0]
            expected_crc32 = 1343710057
            actual_crc32 = self.crc32_calculator(test_input_list)
            self.results.assert_equal(actual_crc32, expected_crc32, "crc32_calculator")

            value_bit_length = 8
            decimal_bit = 4
            float_value = -1.75
            fix_point_code_number = self.convert_number_to_fixed_point_format(float_value,
                                                                              value_bit_length,
                                                                              decimal_bit)
            decoded_float_value = \
                self.convert_to_signed_number(fix_point_code_number, value_bit_length, decimal_bit)

            assert_message = "Floats values must match: {},{}".format(decoded_float_value,
                                                                      float_value)
            self.results.assert_equal(decoded_float_value, float_value, assert_message)
            self.results.assert_less(self.float_to_24_bit_format(float_value), 2 ** 24,
                                     "MAX_24_bits")


    resource_data_lib_test = ResourceDataLibUnitTest()
    resource_data_lib_test.test_resource_data_lib()
