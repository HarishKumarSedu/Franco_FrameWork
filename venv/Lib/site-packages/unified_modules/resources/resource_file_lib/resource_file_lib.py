#!/usr/bin/env python

from __future__ import division
from unified_modules.test_support.testresults import TestResults
import os
import yaml
import re
import shutil
import csv

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class ResourceFileLibError(Exception):
    def __init__(self, error_message):
        super(ResourceFileLibError, self).__init__(error_message)


class ResourceFileLib(object):

    def get_abs_path_relative_to_current_module(self, file_name, module_file_path):
        dir_name = self.get_current_module_path(module_file_path)
        abs_path = os.path.join(dir_name, file_name)
        return abs_path

    @staticmethod
    def get_current_module_path(module_file_path):
        path = os.path.join(os.path.abspath(module_file_path))
        current_path = os.path.dirname(path)
        return current_path

    @staticmethod
    def get_execution_entry_point():
        """
        @:param None

        @:return return the path from which the caller python script is executed
        """
        return os.path.dirname(os.path.abspath('__file__'))

    @staticmethod
    def get_files_by_extension(dir_path, file_extension):
        """
        Get list of all files (with specific file extension) in a directory
        """
        file_paths = []
        for root, dirs, files in os.walk(dir_path):
            for f in files:
                if f.endswith(file_extension):
                    file_paths.append(os.path.join(root, f))
        return file_paths

    @staticmethod
    def copy_all_files_by_extension(file_extension, path_origin, path_destiny):
        """
        Copy all files from provided type file extension from a path of origin
        into a path of destiny.
        @:param type_file: file extension
        @:param path_origin: where the files to be copied are initially located
        @:param path_destiny: it is where the files will be copied.

        @:return None
        """
        quantity_files_copied = 0
        for item in os.listdir(path_origin):
            if item.endswith(file_extension):
                try:
                    shutil.copy(os.path.join(path_origin, item), path_destiny)
                    quantity_files_copied += 1
                except Exception as except_msg:
                    raise ResourceFileLibError(except_msg)
        if not quantity_files_copied:
            except_msg = 'None files have been copied!'
            raise ResourceFileLibError(except_msg)

    @staticmethod
    def write_to_file(file_path, data, op_mode='w'):
        """
        This function creates the text file with the given content
        """
        f = open(file_path, op_mode)
        f.write(data)
        f.close()

    @staticmethod
    def read_from_file(file_path):
        """
        This function read the file and return it's content
        """
        f = open(file_path, 'r')
        file_content = f.read()
        f.close()
        return file_content

    @staticmethod
    def load_yaml_file(file_path):
        """
        This file load the YAML file and return the data
        :param file_path: YML file path
        :return: yaml data in dictionary
        """
        if not os.path.exists(file_path):
            print("Config file '%s' not found" % file_path)
        else:
            with open(file_path, 'r') as stream:
                config = yaml.safe_load(stream)
                return config

    @staticmethod
    def load_bytes_from_binary_file(bin_filename):
        byte_list = []
        with open(bin_filename, 'rb') as hex_file:
            hex_values = hex_file.read()
            if not isinstance(hex_values, str):
                hex_values = "".join(chr(byte) for byte in hex_values)
            for char in hex_values:
                byte_list.append(ord(char))
        return byte_list

    def load_bytes_from_binary_file_to_csv(self, bin_filename):
        byte_list = self.load_bytes_from_binary_file(bin_filename)
        csv_path = bin_filename.replace('.hex', '.csv')
        csv_output_file = open(csv_path, 'w')
        i = 1
        for value in byte_list:
            csv_output_file.write(hex(value))
            sep = '\n' if i % 16 == 0 else ','
            csv_output_file.write(sep)
            i += 1
        csv_output_file.close()
        return byte_list

    @staticmethod
    def convert_csv_to_array(file_name):
        with open(file_name, "r") as csv_file:
            reader = csv.reader(csv_file)
            data = list(reader)
            return data

    def get_read_line_function(self, file_path):
        separator = None
        if file_path.lower().find('csv') > -1:
            separator = ','
        return self.read_line_from_txt_file(file_path, sep=separator)

    @staticmethod
    def read_line_from_txt_file(file_path, sep=None):
        with open(file_path, 'r') as f_handler:
            for line in f_handler:
                yield line.split(sep)

    @staticmethod
    def get_rotated_files_by_pattern(dir_path, pattern="log\.*(\d+)*$"):
        log_files = {}
        for filename in os.listdir(dir_path):
            result = re.search(pattern, filename)
            if result:
                if result.group(1):
                    log_files[int(result.group(1))] = filename
                else:
                    log_files[0] = filename
        return log_files

    def get_log_from_files(self, dir_path, file_extension="txt"):
        pattern = file_extension + "\.*(\d+)*$"
        csv_log_files = self.get_rotated_files_by_pattern(dir_path, pattern=pattern)
        for key in sorted(csv_log_files.keys(), reverse=True):
            file_abs_path = os.path.join(dir_path, csv_log_files[key])
            line_generator = self.get_read_line_function(file_abs_path)
            while True:
                try:
                    line = next(line_generator)
                    yield line
                except StopIteration:
                    break


if __name__ == "__main__":

    class ResourceFileLibUnitTest(ResourceFileLib):
        """
        UnitTest for File lib resource.
        """

        def __init__(self):
            self.results = TestResults()
            self.results.set_test_title('test_resource_file_lib')
            self.log = self.results.log

        def test_copy_all_files_by_extension(self):
            origin_path = self.get_execution_entry_point()
            destiny_path = os.path.join(origin_path, 'temp_dir')
            original_files = self.get_files_by_extension(origin_path, '.py')
            if not os.path.exists(destiny_path):
                os.mkdir(destiny_path)
            self.copy_all_files_by_extension('.py', origin_path, destiny_path)
            copied_files = self.get_files_by_extension(destiny_path, '.py')
            self.results.assert_equal(len(copied_files),
                                      len(original_files),
                                      "Total Files copied must match original number of files")
            if os.path.exists(destiny_path):
                shutil.rmtree(destiny_path)

        def test_resource_file_lib(self):
            abs_path = self.get_abs_path_relative_to_current_module('resource_file_lib.py', 'D')
            self.log.info("absolute path : %s", abs_path)
            entry_point = self.get_execution_entry_point()
            self.log.info("execution entry point : %s", entry_point)
            files = self.get_files_by_extension(os.getcwd(), '.py')
            self.log.info("list of files in directory are : %s", files)
            line_to_list_generator = self.get_read_line_function(
                os.path.join(os.getcwd(), 'resource_file_lib.py'))
            self.log.info("type of line_to_list_generator: %s", line_to_list_generator)
            files = self.get_rotated_files_by_pattern(entry_point, "main.+py\.*(\d+)*$")
            self.log.info("rotating files matching a pattern are : %s", files)
            file_content = self.get_log_from_files(entry_point, file_extension="py")
            self.log.info("content of the given file as lists is:")
            for line_as_list in file_content:
                self.log.info("%s", line_as_list)
            self.test_copy_all_files_by_extension()

    resource_file_lib_test = ResourceFileLibUnitTest()
    resource_file_lib_test.test_resource_file_lib()
