# Copyright (c) 2017 Cirrus Logic, Inc and
# Cirrus Logic International Semiconductor Ltd.  All rights reserved.
#
# This software as well as any related documentation is furnished under
# license and may only be used or copied in accordance with the terms of the
# license.  The information in this file is furnished for informational use
# only, is subject to change without notice, and should not be construed as
# a commitment by Cirrus Logic.  Cirrus Logic assumes no responsibility or
# liability for any errors or inaccuracies that may appear in this document
# or any software that may be provided in association with this document.
#
# Except as permitted by such license, no part of this document may be
# reproduced, stored in a retrieval system, or transmitted in any form or by
# any means without the express written consent of Cirrus Logic.
#
# Warning
#   This software is specifically written for Cirrus Logic devices.
#   It may not be used with other devices.
#
## @file   input_actions.py
## @brief  Mouse and keyboard operations

# Examples: click on button, click on check box, open menu, type in textbox...


import sys
import re
import platform

source(findFile("scripts", "read_actions.py"))
source(findFile("scripts", "real_names.py"))


class InputActions:

    @classmethod
    def maximizeWindow(cls, window):
        """
        This method maximize window of AUT

        @param window [string] real name of window that will be maximized
        @return no return

        Usage:
        InputActions.maximizeWindow(window)
        """
        try:
            obj = waitForObject(window)
        except LookupError as err:
            test.fail("FAIL", str(err))
        try:
            if waitForObject(window).maximized != "true":
                snooze(1)
                obj.forceActive()
                obj.setMaximized(True)
        except LookupError:
            test.fail("FAIL", "Unable to use '" + window + "'")
        try:
            mouseClick(MainShell().getMainWindow())
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + window + "'")

    @classmethod
    def minimizeWindow(cls, window):
        """
        This method is used for minimize window

        @param window [string] real name of window that will be minimized
        @return no return

        Usage:
        InputActions.minimizeWindow(window)
        """
        obj = waitForObject(window)
        snooze(1)
        obj.forceActive()
        obj.setMinimized(True)

    @classmethod
    def mouseClickOnTab(cls, name, window=None):
        """
        This method is used for click on certain tab

        @param name [string] name of tab to click
        @param window [string] default None(real name of the tab doesent have window inside)
                                           (real name of window that contains tab)
        @return [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.mouseClickOnTab("System Discovery")
        InputActions.mouseClickOnTab("System Discovery", window=MainShell.getMainWindow())
        """
        if window == None:
            tab = "{caption?='" + name + "' type='org.eclipse.swt.custom.CTabItem'}"
        else:
            tab = "{caption?='" + name + "' type='org.eclipse.swt.custom.CTabItem' window=" + window + "}"

        try:
            clickTab(waitForObject(tab), 5, 5, 0, Button.Button1)
            snooze(0.5)
            return True
        except:
            test.fail("FAIL", "Unable to click on tab '" + name + "'")
            return False

    @classmethod
    def closeTabOnMouseClick(cls, name):
        """
        This method is used for closing certain tab

        Usage:
        InputActions.closeTabOnMouseClick("Blank.panel")
        """

        cTabItem = "{caption?='" + name + "' parent.visible='true' type='org.eclipse.swt.custom.CTabItem' window=" + MainShell().getMainWindow() + "}"
        cTabCloseBox = "{container=" + cTabItem + " type='com.froglogic.squish.swt.CTabCloseBox'}"

        if object.exists(cTabCloseBox):
            try:
                mouseClick(waitForObject(cTabCloseBox), 5, 5, 0, Button.Button1)
                test.log("Close \"" + name + "\" Tab successfully")
                snooze(0.5)
                return True
            except LookupError:
                test.fail("FAIL", "Unable to close \"" + name + "\" Tab!")
                snooze(0.5)
                return False
        else:
            test.log("Tab \"" + name + "\" is already closed!")
            snooze(0.5)
            return True

    @classmethod
    def chooseEditorFromList(cls, tabName):
        cTab = "{caption='SoundClear Studio' isvisible='true' type='org.eclipse.swt.widgets.Shell'}"
        temp = "{container=" + cTab + " firstItemText='Show List' isvisible='true' type='org.eclipse.swt.widgets.ToolBar'}"
        showList = "{caption='Show List' container=" + temp + " type='org.eclipse.swt.widgets.ToolItem'}"

        textShell = "{caption='' isvisible='true' type='org.eclipse.swt.widgets.Shell'}"
        textBox = "{isvisible='true' type='org.eclipse.swt.widgets.Text' window=" + textShell + "}"

        tableShell = "{caption='' isvisible='true' type='org.eclipse.swt.widgets.Shell'}"
        aboveWidget = "{caption='' isvisible='true' type='org.eclipse.swt.widgets.Label' window=" + tableShell + "}"
        table = "{aboveWidget=" + aboveWidget + " isvisible='true' type='org.eclipse.swt.widgets.Table' window=" + tableShell + "}"
        snooze(0.5)
        try:
            mouseClick(waitForObject(showList), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + showList + "'.")
            return False
        type(waitForObject(textBox), tabName)

        try:
            mouseClick(waitForObjectItem(table, "0/0"), 83, 13, 0, Button.Button1)
            return True
        except LookupError:
            test.fail("FAIL", "Unable to click on table row.")
            return False

    @classmethod
    def doubleClickOnTab(cls, name, window=None):
        """
        This method is used for double click on tab

        @param name [string] name of tab to click
        @param window [string] default None(real name of the tab doesent have window inside)
                                           (real name of window that contains tab)
        @return [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.doubleClickOnTab("System Discovery")
        InputActions.doubleClickOnTab("System Discovery", window=MainShell.getMainWindow())
        """
        try:
            if window == None:
                tab = "{caption='" + name + "' type='org.eclipse.swt.custom.CTabItem'}"
            else:
                tab = "{caption='" + name + "' type='org.eclipse.swt.custom.CTabItem' window=" + window + "}"
            doubleClick(waitForObject(tab), 5, 5, 0, Button.Button1)
            return True
        except LookupError:
            test.fail("FAIL", "Unable to click on tab '" + name + "'")
            return False

    @classmethod
    def mouseClickOnTabHeader(cls, sysOrDevName, cardName):
        """
        This method is used for click on tab header

        @param sysOrDevName [string] name of system or device
        @param cardName [string] name of module in register map
        @return [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.mouseClickOnTabHeader("System_1", "CS42L42")
        """
        try:
            rnTabHeader = RegisterMap(sysOrDevName, cardName).getTabHeader()
            mouseClick(waitForObject(rnTabHeader), 5, 5, 0, Button.Button1)
            return True
        except LookupError:
            test.fail("FAIL", "Unable to click on tab '" + cardName + "'")
            return False

    @classmethod
    def mouseClickOnButton(cls, button):
        """
        This method is used for click on button

        @param button [string] real name of button to click
        @return [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.mouseClickOnButton(SystemDiscovery().getAddButton())
        """
        try:
            mouseClick(waitForObject(button), 5, 5, 0, Button.Button1)
            snooze(0.5)
            return True
        except LookupError:
            test.fail("FAIL", "Unable to click on button '" + button + "'")
            return False

    @classmethod
    def mouseClickOnItem(cls, item, button="left", wait=True, x=None, y=None):
        """
        This method is used for clicking on item

        @item [string] real name of item to click
        @param button [string] can be noButton, left, middle or right. Left is default.
        Button.NoButton   Usually: Make target visible and move mouse, but do not click.
        Button.Button1    Left mouse button
        Button.Button2    Middle mouse button
        Button.Button3    Right mouse button
        @param wait [bool] default True (wait for object and mouse click)
                                   False (only mouse click)
        @param x coordinate of x in pixels
        @param y coordinate of y in pixels
        @return [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.mouseClickOnItem(MainShell().getWindowClose("Welcome"))
        InputActions.mouseClickOnItem(MainShell().getWindowClose("Welcome"), "right")
        InputActions.mouseClickOnItem(MainShell().getWindowClose("Welcome"), "middle", True)
        InputActions.mouseClickOnItem(MainShell().getWindowClose("Welcome"), "middle", True, 20, 20)
        """
        if x == None:
            x = 5
        if y == None:
            y = 5
        if wait:
            try:
                if button == "noButton":
                    mouseClick(waitForObject(item), x, y, 0, Button.NoButton)
                if button == "left":
                    mouseClick(waitForObject(item), x, y, 0, Button.Button1)
                if button == "middle":
                    mouseClick(waitForObject(item), x, y, 0, Button.Button2)
                if button == "right":
                    mouseClick(waitForObject(item), x, y, 0, Button.Button3)
                return True
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + item + "'")
                return False
        else:
            try:
                if button == "noButton":
                    mouseClick(item, x, y, 0, Button.NoButton)
                if button == "left":
                    mouseClick(item, x, y, 0, Button.Button1)
                if button == "middle":
                    mouseClick(item, x, y, 0, Button.Button2)
                if button == "right":
                    mouseClick(item, x, y, 0, Button.Button3)
                return True
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + item + "'")
                return False

    @classmethod
    def mouseDoubleClickOnItem(cls, item, button="left", wait=True, x=5, y=5):
        """
        This method is used for double clicking on item

        @item [string] real name of item to click
        @param button [string] can be noButton, left, middle or right. Left is default.
        Button.NoButton   Usually: Make target visible and move mouse, but do not click.
        Button.Button1    Left mouse button
        Button.Button2    Middle mouse button
        Button.Button3    Right mouse button
        @param wait [bool] default True (wait for object and mouse click)
                                   False (only mouse click)
        @return [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.mouseDoubleClickOnItem(MainShell().getWindowClose("Welcome"))
        InputActions.mouseDoubleClickOnItem(MainShell().getWindowClose("Welcome"), "right")
        InputActions.mouseDoubleClickOnItem(MainShell().getWindowClose("Welcome"), "middle", True)
        """
        if wait:
            try:
                if button == "noButton":
                    doubleClick(waitForObject(item), x, y, 0, Button.NoButton)
                if button == "left":
                    doubleClick(waitForObject(item), x, y, 0, Button.Button1)
                if button == "middle":
                    doubleClick(waitForObject(item), x, y, 0, Button.Button2)
                if button == "right":
                    doubleClick(waitForObject(item), x, y, 0, Button.Button3)
                return True
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + item + "'")
                return False
        else:
            try:
                if button == "noButton":
                    doubleClick(item, x, y, 0, Button.NoButton)
                if button == "left":
                    doubleClick(item, x, y, 0, Button.Button1)
                if button == "middle":
                    doubleClick(item, x, y, 0, Button.Button2)
                if button == "right":
                    doubleClick(item, x, y, 0, Button.Button3)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + item + "'")
                return True

    @classmethod
    def mouseClickOnObjectItem(cls, listView, item):
        """
        This item is used for click on item from list

        @param listView [string] real name of list that contains item we want click
        @param item [string] real name of item to click
        @return no return

        Usage:
        InputActions.mouseClickOnObjectItem(PopupListView().getListView(), deviceOrSysName)
        """
        try:
            mouseClick(waitForObjectItem(listView, item), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on item '" + item + "'")

    @classmethod
    def mouseClickTableItem(cls, name, container, styletype="label"):
        """
        This item is used for click on item from table

        @param name [string] name of item that will be clicked
        @param container [string] real name of conteiner that contain item we click
        @param styletype [string] default label(styletype in real name is label)
                                               (styletype='cell indexed-cell table-cell table-column)
        @return success [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.mouseClickTableItem("Default", container=systemDiscoveryObj.getTable())
        """
        success = False
        if name == None:
            rnToolItem = container
        else:
            if styletype == "label":
                rnToolItem = "{caption='" + name + "' container=" + container + " styletype='label'}"
            else:
                rnToolItem = "{caption='" + name + "' container=" + container + " styletype='cell indexed-cell table-cell table-column'}"
        try:
            mouseClick(waitForObject(rnToolItem, 5000), 12, 10, 0, Button.Button1)
            success = True
        except LookupError:
            test.fail("FAIL", "Unable to click on Table item '" + name + "'")
        return success

    @classmethod
    def doubleClickOnTableCell(cls, name):
        """
        This item is used for double click on cell from table

        @param name [string] name of cell we want to click
        @return success [bool] True or False depending on whether the click was made or not

        Usage:
        InputActions.doubleClickOnTableCell("Discovered")
        """
        success = False
        cell = "{caption?='" + name + "' styletype='cell indexed-cell tree-table-cell table-column' visible='true' window=" + MainShell().getMainWindow() + "}"
        try:
            doubleClick(waitForObject(cell, 5000), 25, 5, 0, Button.Button1)
            success = True
        except LookupError:
            test.fail("FAIL", "Unable to double click on Table cell '" + name + "'")
        return success

    @classmethod
    def mouseClickOnDirectoryContent(cls, name):
        """
        This method left-click on System Directory content.

        @param name [string] name of project we want to click
        @return no return

        Usage:
        InputActions.mouseClickOnDirectoryContent("Register map")
        """
        try:
            mouseClick(waitForObject(Directory().getProjectName(name)), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Couldn't click on " + name)

    @classmethod
    def activateMenuItem(cls, menupath, result=True):
        """
        This method is used for activate item from menu on different OS.
        Depending of system this method will call method for OS that is
        on machine that using this script

        @param manupath [string] string that always contain (menu)->(item from menu) or shortcut from keyboard
        @param result [bool] True or False depending on whether the test status would be or would not be set
        @return success [bool] True or False depending on whether the menu item has been activated or not

        Usage:
        InputActions.activateMenuItem("Help->About")
        InputActions.activateMenuItem("<Alt+F4>")
        """
        testMachine = platform.system()
        if "Windows" in testMachine:
            success = cls.activateMenuItem_win(menupath, result)
            return success
        elif "Linux" in testMachine:
            success = cls.activateMenuItem_lin(menupath, result)
            return success
        elif "Darwin" in testMachine:
            success = cls.activateMenuItem_mac(menupath, result)
            return success
        else:
            sys.exit("OS not found")

    @classmethod
    def activateMenuItem_win(cls, menupath, result=True):
        """
        This method is always called from activateMenuItem method for win machines

        @param manupath [string] string that always contain (menu)->(item from menu) or shortcut from keyboard
        @param result [bool] True or False depending on whether the test status would be or would not be set
        @return success [bool] True or False depending on whether the click was made or not

        Usage:
        cls.activateMenuItem_win(menupath)
        """
        # Execute menu item using IDE menu
        if "->" in menupath:
            success = True
            rnMenuItem = "{type='org.eclipse.swt.widgets.Menu'}"
            snooze(0.5)
            arrMENU = re.split("->", menupath)
            for item in arrMENU:
                try:
                    menu_item = waitForObjectItem(rnMenuItem, item)
                    activateItem(menu_item)
                    snooze(0.5)
                except LookupError:
                    if result == True:
                        test.fail("FAIL", "Unable to select '" + item + "'")
                    success = False
            if success:
                test.log("Action activateMenuItem '" + menupath + "' is successfully executed")
            else:
                if result == True:
                    test.fail("FAIL", "Action activateMenuItem '" + menupath + "' is NOT successfully executed")
            return success
        # Execute menu item using keyboard shortcut
        else:
            nativeType(menupath)

    @classmethod
    def activateMenuItem_mac(cls, menupath, result=True):
        """
        This method is always called from activateMenuItem method for mac machines

        @param manupath [string] string that always contain (menu)->(item from menu) or shortcut from keyboard
        @param result [bool] True or False depending on whether the test status would be or would not be set
        @return success [bool] True or False depending on whether the click was made or not

        Usage:
        clc.activateMenuItem_mac("com.cirrus.scs.ide.application->About com.cirrus.scs.ide.application")
        """
        # Execute menu item using IDE menu
        if menupath == "Window->Preferences":
            nativeType("<Command+,>")
        else:
            if "->" in menupath:
                success = True
                rnMain = "{menuStyle='SWT.BAR' type='org.eclipse.swt.widgets.Menu'}"
                rnMenuItem = "{menuStyle='SWT.DROP_DOWN' type='org.eclipse.swt.widgets.Menu'}"
                arrMENU = menupath.split("->")
                itemMenu = ""
                itemMenu = arrMENU[0]
                snooze(0.5)
                if itemMenu == "SoundClear Studio":
                    menu_item = waitForObjectItem(rnMain, "File")
                    activateItem(menu_item)
                    nativeType("<Left>")
                    nativeType("<Down>")
                else:
                    menu_item = waitForObjectItem(rnMain, itemMenu)
                    activateItem(menu_item)
                for item in arrMENU[1:]:
                    try:
                        menu_item = waitForObjectItem(rnMenuItem, item)
                        activateItem(menu_item)
                        snooze(0.5)
                    except LookupError:
                        if result == True:
                            test.fail("FAIL", "Unable to select '" + item + "'")
                        success = False
                if success:
                    test.log("Action activateMenuItem '" + menupath + "' is successfully executed")
                else:
                    if result == True:
                        test.fail("FAIL", "Action activateMenuItem '" + menupath + "' is NOT successfully executed")
                return success
            # Execute menu item using keyboard shortcut
            else:
                if "Alt+Shift+q" in menupath:
                    menupath = menupath.replace("Alt+Shift+q", "Option+Command+q")
                if "Ctrl" in menupath:
                    menupath = menupath.replace("Ctrl", "Command")
                nativeType(menupath)

    @classmethod
    def activateMenuItem_lin(cls, menupath, result=True):
        """
        This method is always called from activateMenuItem method on linux

        @param manupath [string] string that always contain (menu)->(item from menu) or shortcut from keyboard
        @param result [bool] True or False depending on whether the test status would be or would not be set
        @return success [bool] True or False depending on whether the click was made or not

        Usage:
        clc.activateMenuItem_lin("Help->About")
        clc.activateMenuItem_lin("File->quit")
        # Execute menu item using IDE menu
        """
        if "->" in menupath:
            arrMENU = menupath.split("->")
            itemMenu = ""
            for item in arrMENU:
                itemMenu += " " + item
            print(itemMenu)
            success = False
            nativeType("<Alt>")
            snooze(0.5)
            nativeType(itemMenu)
            snooze(0.5)
            if nativeType("<Return>"):
                success = True
            if success:
                test.log("Action activateMenuItem '" + menupath + "' is successfully executed")
            else:
                if result == True:
                    test.fail("FAIL", "Action activateMenuItem '" + menupath + "' is NOT successfully executed")
            return success
        # Execute menu item using keyboard shortcut
        else:
            nativeType(menupath)

    @classmethod
    def mouseClickOnLink(cls, link):
        """
        This method is used to click on link

        @param link [string] real name of string we want to click
        @return [bool] True or False depending on whether the click was made or not

        Usage:
        inputActionsObj.mouseClickOnLink(mainShellObj.getWorkingPerspectiveLink())
        """
        success = False
        try:
            mouseClick(waitForObject(link, 5000), 3, 3, 0, Button.Button1)
            success = True
        except LookupError:
            test.fail("FAIL", "Unable to click on link '" + link + "'")
        return success

    @classmethod
    def rightClickOnProjectContent(cls, item, x=None, y=None):
        """
        This method is used for click right click on project content

        @param item [string] real name of objects
        @param x [int] x coordinate of object
        @param y [int] y coordinate of object
        @return success [bool] True or False depending on whether the click was made or not

        Usage:
        inputActionsObj.mouseClickOnDirectoryItem(project1)
        inputActionsObj.mouseClickOnDirectoryItem(project1, 3, 5)

        NOTE: Both coordinates x and y must be given or both omitted.
        """
        success = False
        try:
            if x == None:
                mouseClick(waitForObject(Directory().getProjectName(item)), 5, 5, 0, Button.Button3)
            else:
                mouseClick(waitForObject(Directory().getProjectName(item)), x, y, 0, Button.Button3)
            success = True
        except LookupError:
            test.fail("FAIL", "Unable to click on item '" + item + "'")
        return success

    @classmethod
    def changeValueOfRegisterOrBitField(cls, nameOfRegister, registerMapObj, valueRegister=None, nameOfBitFieldRegister=None, bitFieldValueType=None, valueBitField=None):
        """
        @param nameOfRegister [string] name of Register
        @param registerMapObj [string] object of register map(Ex.RegisterMap("CS42L75 (CS42L75)"))
        @param valueRegister [string] new value of register
        @param nameOfBitFieldRegister [string] name of bit field
        @param bitFieldValueType [string] can be "Radio Button", "Combo Box" or "Value"
        @param valueBitField [string] new value of bit field

        Usage:
        InputActions.changeValueOfRegisterOrBitField("ASP1 LRCK Period", RegisterMap("CS42L75 (CS42L75)"), "0xffffffff")
        InputActions.changeValueOfRegisterOrBitField("Page Select", RegisterMap("cs42l42 (CS42L42)"), None, "Value", "PAGE", "0x5")
        """
        try:
            mouseClick(waitForObject(registerMapObj.getRegisterFromRegTable(nameOfRegister)), 50, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click")
        snooze(1)
        if nameOfBitFieldRegister == None and valueBitField == None:
            row = str(waitForObject(registerMapObj.getRegisterFromRegTable(nameOfRegister)).cell.parent.index)
            Common.changeRegisterValue("Value", row, registerMapObj.getRegisterTable(), valueRegister)
            test.log("Register value changed")
        elif nameOfBitFieldRegister != None and valueBitField != None:
            row = str(waitForObject(registerMapObj.getRegisterFromBitFieldTable(nameOfBitFieldRegister)).cell.parent.index)
            if bitFieldValueType == "Value":
                Common.changeRegisterValue("Value", row, registerMapObj.getBitFieldTable(), valueBitField)
            elif bitFieldValueType == "Radio Button":
                InputActions.changeRadioButton(registerMapObj.getBitFieldTable(), row, valueBitField)
            elif bitFieldValueType == "Combo Box":
                InputActions.clickBitFieldComboBox(registerMapObj.getBitFieldTable(), row, valueBitField)
            elif bitFieldValueType == "Check Box":
                InputActions.clickBitFieldChackBox(registerMapObj.getBitFieldTable(), row, valueBitField)
            elif bitFieldValueType == None:
                test.fail("FAIL", "Type of bit field value is not entered")
            else:
                test.fail("FAIL", "Type of bit field value is not entered right")
            test.log("Bit Field value changed")
        else:
            test.fail("FAIL", "Register value are not changed")

    @classmethod
    def clickRegisterValue(cls, table, row, index, singleOrDouble="single"):
        """
        This method is used for clicking on radio button.

        @param table [sring] name of table
        @param row [string] name of row
        @param index [string] Variable 'index' corresponds to the desired button index, starts from 0.
        @return no return
        @singleOrDouble single or double click

        Usage:
        InputActions.clickRegisterValue(registerMapObj.getRegisterFromRegTable(), row, "1", "double")
        """
        rnCell = "{column='Value' container=" + table + " row ='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        cellObject = waitForObject(rnCell, 5000)

        # Click on Name field button
        if singleOrDouble == "single":
            mouseClick(cellObject, 5, 5, 0, Button.Button1)
        elif singleOrDouble == "double":
            doubleClick(cellObject, 5, 5, 0, Button.Button1)
        else:
            mouseClick(cellObject, 5, 5, 0, Button.Button1)

    @classmethod
    def clickRegisterName(cls, table, row, index, singleOrDouble="single"):
        """
        This method is used for clicking on radio button.

        @param table [sring] name of table
        @param row [string] name of row
        @param index [string] Variable 'index' corresponds to the desired button index, starts from 0.
        @return no return
        @singleOrDouble single or double click

        Usage:
        InputActions.clickRegisterName(registerMapObj.getRegisterFromRegTable(), row, "1", "double")
        """
        rnCell = "{column='Name' container=" + table + " id='registerTableNameColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column' visible='true'}"
        cellObject = waitForObject(rnCell, 5000)

        # Click on Name field button
        if singleOrDouble == "single":
            mouseClick(cellObject, 5, 5, 0, Button.Button1)
        elif singleOrDouble == "double":
            doubleClick(cellObject, 5, 5, 0, Button.Button1)
        else:
            mouseClick(cellObject, 5, 5, 0, Button.Button1)

    @classmethod
    def clickBitFieldRadioButton(cls, table, row, index, singleOrDouble="single"):
        """
        This method is used for clicking on radio button.

        @param table [sring] name of table
        @param row [string] name of row
        @param index [string] Variable 'index' corresponds to the desired button index, starts from 0.
        @return no return
        @singleOrDouble single or double click

        Usage:
        InputActions.clickBitFieldRadioButton(registerMapObj.getBitFieldTable(), row, "1")
        """
        radioCell = "{column='Value' container=" + table + " row= '" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        radioGroup = "{container=" + radioCell + " type='com.cirrus.scs.ide.registermap.ui.controls.RadioGroup' visible='true'}"
        try:
            radioGroupObject = waitForObject(radioGroup, 5000)
        except LookupError:
            test.fail("FAIL", "Unexpectedly failed to find the object")
        try:
            items = str(radioGroupObject.items)
        except LookupError:
            test.fail("FAIL", "Unexpectedly failed to find the property")

        # Get the radio button caption
        caption = ""
        captionTemp = ""
        stringToFind = "(" + index + ","
        position = items.index(stringToFind)
        captionTemp = items[position:]
        captionTemp = captionTemp[3:]

        for char in captionTemp:
            if char == ")":
                break
            caption += char

        if caption == "(Default":
            caption = "(Default)"
            captionTemp = captionTemp.replace("(Default)", "")
            for char in captionTemp:
                if char == ")":
                    break
                caption += char

        if caption == "(default":
            caption = "(default)"
            captionTemp = captionTemp.replace("(default)", "")
            for char in captionTemp:
                if char == ")":
                    break
                caption += char
        """
        # TBD:
        if "(" in caption:
            caption += ")"
        """
        if (caption[(len(caption) - 8): len(caption)] == "(Default") \
        or (caption[(len(caption) - 8): len(caption)] == "(default") \
        or (caption[(len(caption) - 5): len(caption)] == "(Hi-Z") \
        or (caption[(len(caption) - 7): len(caption)] == "(driven") \
        or (caption[(len(caption) - 12): len(caption)] == "(not doubled") \
        or (caption[(len(caption) - 31): len(caption)] == "(doubles the incoming LRCK rate") \
        or (caption[28:] == "(doubles the incoming LRCK rate") \
        or (caption == "Divide by 1 (source MCLKINT = ~12 MHz") \
        or (caption == "Divide by 2 (source MCLKINT = ~24 MHz") \
        or (caption == "LRCK is input from external source which is synchronous to SCLK (Slave Mode")\
        or (caption == "LRCK is an output generated from SCLK (Hybrid Master Mode")\
        or (caption == "Output follows the combination logic directly (nonlatched")\
        or (caption == "WAKE output deasserted (the TIP_SENSE_PLUG, TIP_SENSE_UNPLUG, SHORT_DETECT, SHORT_RELEASE bits in the VP domain are also cleared")\
        or (caption == "Inhibits the transfer of VD_FILT registers to VP registers (latched mode")\
        or (caption == "No external capacitor (Default because there is no pin on HS bias output")\
        or (caption == "Transfers VD_FILT fields to VP fields (transparent mode"):
            caption += ")"

        if caption == "Raw (unprocessed":
            caption = "Raw (unprocessed) status events are selected"

        if caption == "S/PDIF outputs 32-bit raw (software-formatted":
            caption = "S/PDIF outputs 32-bit raw (software-formatted) data"

        radioButton = "{caption='" + caption + "' container=" + radioCell + "styletype='radio-button' visible='true'}"
        radioButtonObject = waitForObject(radioButton, 5000)
        # Click on radio button
        if singleOrDouble == "single":
            mouseClick(radioButtonObject, 5, 5, 0, Button.Button1)
        elif singleOrDouble == "double":
            doubleClick(radioButtonObject, 5, 5, 0, Button.Button1)
        else:
            mouseClick(radioButtonObject, 5, 5, 0, Button.Button1)

    @classmethod
    def changeRadioButton(cls, table, row, velue):
        """
        This method is used for clicking on radio button in bit field table
        @param table - real name of table
        @param row [string] number of the row

        Usage:
        InputActions.changeRadioButton(registerMapObj.getBitFieldTable(), row, valueBitField)
        """
        radioCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        radioButton = "{caption='" + velue + "' container=" + radioCell + "styletype='radio-button' visible='true'}"
        dot = "{container=" + radioButton + " styletype='dot' visible='true'}"
        try:
            mouseClick(waitForObject(dot), 5, 5, 0, Button.Button1)
        except:
            test.fail("FAIL", "There is no " + radioButtonObject)

    @classmethod
    def clickBitFieldName(cls, table, row, index, singleOrDouble="single"):
        """
        This method is used for clicking on radio button.

        @param table [sring] name of table
        @param row [string] name of row
        @param index [string] Variable 'index' corresponds to the desired button index, starts from 0.
        @return no return
        @singleOrDouble single or double click

        Usage:
        InputActions.clickBitFieldName(registerMapObj.getBitFieldTable(), row, "1")
        """
        rnCell = "{column='Name' container=" + table + " row= '" + row + "' styletype='cell indexed-cell table-cell table-column' visible='true'}"
        cellObject = waitForObject(rnCell, 5000)

        # Click on Name field button
        if singleOrDouble == "single":
            mouseClick(cellObject, 5, 5, 0, Button.Button1)
        elif singleOrDouble == "double":
            doubleClick(cellObject, 5, 5, 0, Button.Button1)
        else:
            mouseClick(cellObject, 5, 5, 0, Button.Button1)

    @classmethod
    def clickBitFieldComboBox(cls, table, row, value, start_value=False, end_value=False):
        """
        This method is used for clicks on radio button box

        @param table [sring] name of table
        @param row [string] name of row
        @param value [bool] If value == False, only open the combo box, without performing input action
        @return no return

        Usage:
        InputActions.clickBitFieldRadioButton(registerMapObj.getBitFieldTable(), row, "48k isochronous stream")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + \
                            "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' " \
                            "visible='true'}"
        comboBox = "{container=" + bitFieldTableCell + " styletype='combo-box-base combo-box' visible='true'}"
        comboBoxObject = waitForObject(comboBox, 5000)
        snooze(0.5)
        mouseClick(comboBoxObject, 5, 5, 0, Button.Button1)
        snooze(0.5)
        if value is not False:
            try:
                listScrollBar = None
                try:
                    popupControl = "{basetype='javafx.scene.control.PopupControl' visible='true'}"
                    waitForObject(popupControl)
                except LookupError:
                    test.fail("FAIL", "Unexpectedly failed to find the object")
                try:
                    listView = "{container=" + popupControl + " id='list-view' styletype='list-view' visible='true'}"
                    waitForObject(listView)
                    listScrollBar = "{container=" + listView + " styletype='scroll-bar' visible='true'}"
                except LookupError:
                    test.fail("FAIL", "Unexpectedly failed to find the object")

                listCell = "{caption='" + value + "' container=" + listView + " styletype='cell indexed-cell list-cell' visible='true'}"
                downArrow = "{container=" + listView + " styletype='increment-arrow' visible='true'}"
                # if start_value and scroll bar is found,the scroll the combo box to start position
                # elif end_value and scroll bar is found,the scroll the combo box to bottom position
                if start_value and listScrollBar and object.exists(listScrollBar):
                    setValue(listScrollBar, 0)
                elif end_value and listScrollBar and object.exists(listScrollBar):
                    setValue(listScrollBar, 1)
                else:
                    while not object.exists(listCell):
                        mousePress(downArrow)
                        snooze(1)
                        mouseRelease()
                waitForObject(listCell)
                listText = "{caption='" + value + "' container=" + listCell + " styletype='text' visible='true'}"
                listTextObject = waitForObject(listText)
                cls.mouseClickOnItem(listTextObject)
                snooze(0.5)
                combo_box_val = ReadActions.checkComboBoxFromTable(table, row, None, True)
                if combo_box_val != value:
                    mouseClick(comboBoxObject, 5, 5, 0, Button.Button1)
                    mousePress(downArrow)
                    snooze(0.5)
                    mouseRelease()
                    waitForObject(listTextObject)
                    cls.mouseClickOnItem(listTextObject)

                snooze(0.5)
            except LookupError:
                test.fail("FAIL", "List item can not be found")


    @classmethod
    def dragBitFieldSlider(cls, table, row, tx, ty):
        """
        This method is used for clicks on radio button box

        @param table [sring] name of table
        @param row [string] name of row
        @param tx [int] position on x axis of target_object we want to drop
        @param ty [int] position on y axis of target_object we want to drop
        @return no return

        Usage:
        InputActions.dragBitFieldSlider(registerMapObj.getBitFieldTable(), row, "48k isochronous stream")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        slider = "{container=" + bitFieldTableCell + " styletype='slider' visible='true'}"
        thumb = "{container=" + slider + " styletype='thumb' visible='true'}"

        try:
            dragAndDrop(thumb, 2, 2, slider, tx, ty, DnD.DropCopy)
        except LookupError:
            test.fail("FAIL", "Unexpectedly failed to find the object")

    @classmethod
    def clickBitFieldChackBox(cls, table, row, value):
        """
        This method is used for clicks on chack box in bit field

        @param table [sring] name of table
        @param row [string] name of row
        @param value [bool] If value == False, only open the combo box, without performing input action
        @return no return

        Usage:
        InputActions.clickBitFieldChackBox(registerMapObj.getBitFieldTable(), row, "Enabled")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        field = "{caption='" + value + "' container=" + bitFieldTableCell + " styletype='check-box' visible='true'}"
        mark = "{container=" + field + " styletype='mark' visible='true'}"
        try:
            mouseClick(mark, 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "There is no " + value)

    @classmethod
    def scrollBitFieldComboBox(cls, position):
        """
        This method is used for scrolling in bitfield combo box

        @param position [float] Position is a number from 0 to 1, where 0 corresponds to the beginning of scroll bar, and 1 to the end.
        @return no return

        Usage:
        InputActions.scrollBitFieldComboBox(1)
        """
        popupControl = "{basetype='javafx.scene.control.PopupControl' visible='true'}"
        waitForObject(popupControl)
        listView = "{container=" + popupControl + " id='list-view' styletype='list-view' visible='true'}"
        waitForObject(listView)
        listScroll = "{container=" + listView + " styletype='scroll-bar' visible='true'}"
        snooze(0.5)
        setValue(waitForObject(listScroll), position)
        snooze(0.5)

    @classmethod
    def scrollRegisterTable(cls, container, position):
        """
        This method is used for scrolling in register map table

        @param position [float] Position is a number from 0 to 1, where 0 corresponds to the beginning of scroll bar, and 1 to the end.
        @return no return

        Usage:
        InputActions.scrollRegisterTable(registerMapObj.getRegisterTable(), 1)
        """

        rnScrollBar = "{container=" + container + " styletype='scroll-bar' visible='true' orientation = 'VERTICAL'}"

        try:
            setValue(waitForObject(rnScrollBar), position)
            snooze(0.5)
        except LookupError:
                test.log("Scroll bar '" + rnScrollBar + "' not found")

    @classmethod
    def clickClearFilter(cls, regMapObj):
        """
        This method is used for clicking on clear in filter box
        @param regMapObj [object] reg map table object
        @return no return

        Usage:
        InputActions.clickClearFilter(regMapObj)
        """
        width = __builtin__.int(waitForObject(regMapObj.getSearch()).width)
        x = width - 5
        try:
            mouseClick(waitForObject(regMapObj.getSearch()), x, 5, 0, Button.Button1)
        except LookupError:
            test.log("Can't click on item")

    @classmethod
    def scrollPageComboBox(cls, position):
        """
        Scrolls in Page combo box
        Position is a number from 0 to 1, where 0 corresponds to the beginning of scroll bar, and 1 to the end.
        Usage example:
        InputActions.scrollPageComboBox(1)
        """
        popupControl = "{type='javafx.stage.Popup' visible='true'}"
        waitForObject(popupControl)
        listScroll = "{container=" + popupControl + " styletype='scroll-bar' visible='true'}"
        snooze(0.5)
        setValue(waitForObject(listScroll), position)
        snooze(0.5)

    @classmethod
    def clickPageComboBoxItem(cls, page):
        """
        Clicks on page in Page combo box
        Usage:
        InputActions.clickPageComboBoxItem("0x2A")
        """
        popupControl = "{type='javafx.stage.Popup' visible='true'}"
        waitForObject(popupControl)
        pageLabel = "{caption='" + page + "' container=" + popupControl + " styletype='label label-name' visible='true'}"
        snooze(0.5)
        success = False
        try:
            pageLabelObject = waitForObject(pageLabel)
            mouseClick(pageLabelObject, 5, 5, 0, Button.Button1)
            success = True
        except LookupError:
            test.fail("FAIL", "Unable to click on link '" + link + "'")
        return success

    @classmethod
    def closeAllOpenedTabs(cls):
        """
        This method first creates a list of all tabs that are available in SounClear Studio, iterates true that list and if any tab is opened it closes it
        Usage:
        InputActions.closeAllOpenedTabs()
        """
        root_list = []
        all_tabls_list = []
        snooze_time = 0.5
        InputActions.activateMenuItem("Window->Show View->Other...")
        addViewsShellObj = AddViewsShell()

        # Create a list of all root elements
        try:
            string_root_list = str(waitForObject(addViewsShellObj.getAddViewSheet()).childrenunmodifiable)
            root_list = re.findall(r'\'(.*?)\'', string_root_list)
        except LookupError:
            test.fail("Fail", "Can not find object or property")
        snooze(snooze_time)

        # Click on each non null element from the root list and append its tree item children to a common list
        # This will be the list of all tabs in SounClear Studio
        for option in root_list:
            if option != 'null':
                    try:
                        string_option_list = str(waitForObject(addViewsShellObj.getAddViewCell(option)).treeitem.children)

                        # Isolate elements needed to form a list of all tabs in SoundClear Studio
                        start_sep = ': '
                        end_sep = ' ]'
                        tmp = string_option_list.split(start_sep)
                        for par in tmp:
                            if end_sep in par:
                                all_tabls_list.append(par.split(end_sep)[0])
                        snooze(snooze_time)
                    except LookupError:
                        test.fail("Fail", "Can not find object or property")
            else:
                pass
        test.log("Close Add Views window")
        InputActions.mouseClickOnItem(addViewsShellObj.getAddViewCloseLabel())
        test.log("Navigate true tabs list and if there is a tab opened in SoundClear GUI, close it")
        for i in range(len(all_tabls_list)):
            if object.exists(addViewsShellObj.getGenericCTabItem(all_tabls_list[i])):
                    InputActions.closeTabOnMouseClick(all_tabls_list[i])
                    snooze(3)
        test.log("All opened tabs closed")

    @classmethod
    def checkContextMenuOptionIsDisabled(cls, whoseMenu, contextOptionName):
        """
        This method is used for checking if context menu options is Disabled.

        @param object for which we need to open context menu
        @param what option do we need to check if it's Disabled
        @return no return

        Usage:
        InputActions.checkContextMenuOptionIsDisabled(panelObj.getRoot(), "Copy")
        """
        InputActions.mouseClickOnItem(whoseMenu, "right")
        snooze(0.5)
        InputActions.mouseClickOnItem(ContextMenuShell().getContextLabel(contextOptionName))
        snooze(0.5)
        ReadActions.checkObjectExists(ContextMenuShell().getContextLabel(contextOptionName))
        nativeType("<Escape>")

    @classmethod
    def checkContextMenuOptionIsEnabled(cls, whoseMenu, contextOptionName):
        """
        This method is used for checking if context menu options is Enabled.
        NOTE: This does not include case when option in context menu opens another context menu.

        @param object for which we need to open context menu
        @param what option do we need to check if it's Enabled
        @return no return

        Usage:
        InputActions.checkContextMenuOptionIsEnabled(panelObj.getWidget(widget, widget_ID), "Copy")
        """
        InputActions.mouseClickOnItem(whoseMenu, "right")
        snooze(0.5)
        InputActions.mouseClickOnItem(ContextMenuShell().getContextLabel(contextOptionName))
        snooze(0.5)
        ReadActions.checkObjectNotExist(ContextMenuShell().getContextLabel(contextOptionName))

    @classmethod
    def mousePressItem(cls, item):
        """
        This method performs a mouse press
        @param item [string] real name of item which will be pressed

        Usage:
        InputActions.mousePressItem(PanelEditor(name).getDotFromConnection())
        """
        try:
            mousePress(waitForObject(item))
        except LookupError:
            test.fail("FAIL", "Can not press " + item)

    @classmethod
    def mouseReleaseItem(cls, item):
        """
        This method performs a mouse release
        @param item [string] real name of item which will be released

        Usage:
        InputActions.mouseReleaseItem(PanelEditor(name).getDotFromConnection())
        """
        try:
            mouseRelease(waitForObject(item))
        except LookupError:
            test.fail("FAIL", "Can not press " + item)

    @classmethod
    def dragItemToNewPosition(cls, item, x, y, dx, dy):
        """
        This method performs drag item to new position
        @param item[string]  real name of item
        @param x [integer] starting at position x
        @param y [integer] starting at position y
        @param dx [integer] dragged by pixels horizontally
        @param dy [integer] dragged by pixels vertically

        Usage:
        panel = "DMC.bdf"
        panelEditorObj = PanelEditor(panel)
        InputActions.mouseReleaseItem(panelEditorObj.getRectangleFromConnection("1"), -5, 5, 0, 30)
        """
        try:
            dragItemBy(waitForObject(item), x, y, dx, dy, Modifier.None, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Can not drag " + item)

    @classmethod
    def set_slider_value(cls, slider_real_name, slider_value):
        """
        Move slider nob to new position
        @param slider_real_name: Slider real name
        @param slider_value: slider value to move
        """
        status = False
        try:
            # Handle setting long int slider value
            if __builtin__.isinstance(slider_value, __builtin__.long):
                slider_object = waitForObject(slider_real_name)
                slider_width = __builtin__.int(slider_object.styleableparent.width)
                InputActions.dragItemToNewPosition(slider_real_name, 5, 5, slider_width, 0)
            else:
                waitForObject(slider_real_name).styleableparent.value = slider_value
            status = True
        except LookupError:
            test.fail("FAIL", "Cannot set %s value to slider %s" % (slider_value, slider_real_name))
        return status

    @classmethod
    def typeText(cls, realName, text):
        """
        This method types text to real name
        """
        InputActions.mouseClickOnItem(realName)
        machine = platform.system()
        if "Darwin" in machine:
            nativeType("<Command+a>")
            nativeType("<Delete>")
        else:
            nativeType("<Ctrl+a>")
            nativeType("<Delete>")
        nativeType(text)
        nativeType("<Return>")
        snooze(1)
        # TODO: removing because no RT-Exec snooze(0.5)
