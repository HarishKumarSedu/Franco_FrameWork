# Copyright (c) 2017 Cirrus Logic, Inc and
# Cirrus Logic International Semiconductor Ltd.  All rights reserved.
#
# This software as well as any related documentation is furnished under
# license and may only be used or copied in accordance with the terms of the
# license.  The information in this file is furnished for informational use
# only, is subject to change without notice, and should not be construed as
# a commitment by Cirrus Logic.  Cirrus Logic assumes no responsibility or
# liability for any errors or inaccuracies that may appear in this document
# or any software that may be provided in association with this document.
#
# Except as permitted by such license, no part of this document may be
# reproduced, stored in a retrieval system, or transmitted in any form or by
# any means without the express written consent of Cirrus Logic.
#
# Warning
#   This software is specifically written for Cirrus Logic devices.
#   It may not be used with other devices.
#
## @file   read_actions.py
## @brief  Operations for reading properies of objects from AUT

# Examples: read text; read state of buttons (enable, disable), check box...

import builtins
source(findFile("scripts", "real_names.py"))


class ReadActions:
    @classmethod
    def checkSysTypeInComboBox(cls, name, comboBox):
        """
        This method is used for checking type in combo box

        @param name [string] name of board
        @param comboBox [string] real name of combo box
        @return answer [bool] True if item with name "name" exists and mouseClick works on him

        Usage:
        ReadActions.checkSysTypeInComboBox("ClearwaterLochnagar", AddSystemStage().getAddComboBox())
        """
        answer = False
        item = "{caption?='" + "*" + name + "*" + "' styletype='text' visible='true'}"

        try:
            InputActions.mouseClickOnButton(SystemDiscovery().getAddButton())
            snooze(0.5)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + SystemDiscovery().getAddButton() + "'")

        counter = 0
        try:
            """ Click on combo box """
            mouseClick(waitForObject(comboBox), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + comboBox + "'")
        """ Select item from combo box """
        snooze(0.5)
        try:
            listLenght = findObject(comboBox).items.length
        except LookupError:
            test.fail("FAIL", "Can not find object '" + comboBox + "'")
        while not object.exists(item):
            nativeType("<Down>")
            counter += 1
            if counter > listLenght:
                test.fail("FAIL", "End of list. Item " + item + " does not exist")
        try:
            mouseClick(waitForObject(item, 5000), 5, 5, 0, Button.Button1)
            answer = True
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + item + "'")
        try:
            mouseClick(waitForObject(AddSystemStage().getAddSysCancelButton(), 5000), 5, 5, 0, Button.Button1)
            snooze(0.5)
            return answer
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + AddSystemStage().getAddSysCancelButton() + "'")

    @classmethod
    def checkObjectExists(cls, name):
        """
        This method checks if object exists

        @param name [string] real name of item we check
        @return no return

        Usage:
        ReadActions.checkObjectExists(registerMapObjCS.getRegisterTable())
        """
        if object.exists(name):
            test.passes("Pass", name + " found")
        else:
            test.fail("Fail", name + " not found")

    @classmethod
    def checkObjectNotExist(cls, name):
        """
        This method checks if object not exist

        @param name [string] real name of item we check
        @return no return

        Usage:
        ReadActions.checkObjectNotExist(registerMapObjCS.getRegisterTable())
        """
        if not object.exists(name):
            test.passes("Pass", name + " not found")
        else:
            test.fail("Fail", name + " found")

    @classmethod
    def checkText(cls, name):
        """
        This method is used for checking text existence

        @param name [string] text we check
        @return no return

        Usage:
        ReadActions.checkText("System_1")
        """
        rnSystem1 = "{caption='" + name + "' styletype='text' visible='true'}"
        testSys = ""
        if object.exists(rnSystem1):
            testSys = findObject(rnSystem1).text
            test.log(testSys)
        if testSys == name:
            test.passes("Pass", name + " found")
        else:
            test.fail("Fail", name + " not found")

    @classmethod
    def checkWindow(cls, name):
        """
        This method return if window object

        @param name [string]
        @return [bool] True if window exist, else False

        Usage:
        ReadActions.checkWindow(device)
        """
        window = "{caption?='" + name + "' parent.visible='true' type='org.eclipse.swt.custom.CTabItem' window=" + MainShell().getMainWindow() + "}"
        if object.exists(window):
            return True
        else:
            return False

    @classmethod
    def checkTextExist(cls, name):
        """
        This method check if some text exist and return true or false

        @param name [string] text we check
        @return [bool] True if exists

        Usage:
        ReadActions.checkTextExist("System_1")
        """
        rnSystem1 = "{caption='" + name + "' styletype='text' visible='true'}"
        testSys = ""
        if object.exists(rnSystem1):
            testSys = findObject(rnSystem1).text
            test.log(testSys)
        if testSys == name:
            return True
        else:
            return False

    @classmethod
    def checkTextFromTable(cls, column, row, container, name, fullname=False, nonDefaultType=False,
                           readOnly=False, return_value=False):
        """
        This method is used for checking text from table

        @param column [string] name of column
        @param row [string] name of row
        @param conteiner [string] name of conteiner
        @param name [string] name of item we check
        @param fullname [bool]
        @param nonDefaultType [bool]
        @param readOnly [bool]
        @return [bool] True if test pass, otherwise False

        Usage:
        ReadActions.checkTextFromTable("Value", "0", "*History*" ,"1")
        ReadActions.checkTextFromTable("Value", "0", RegisterMap("System_1", "USB Audio Module").getRegisterTable() ,"0x00", True)
        ReadActions.checkTextFromTable("Value", "0", RegisterMap("System_1", "USB Audio Module").getRegisterTable(), "0x01", True, True)
        """
        if readOnly == True:
            cell = "{column='Value' container=" + container + " row ='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
            if nonDefaultType == False:
                valueTextField = "{container=" + cell + " styletype='text-input text-field scs-regmap-is_internal' visible='true'}"
            else:
                valueTextField = "{container=" + cell + " styletype='text-input text-field scs-regmap-is_internal scs-regmap-non_default' visible='true'}"
        elif fullname == True:
            cell = "{column='" + column + "' container=" + container + " row ='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
            if nonDefaultType == False:
                valueTextField = "{container=" + cell + " styletype='text-input text-field' visible='true'}"
            else:
                valueTextField = "{container=" + cell + " styletype='text-input text-field scs-regmap-non_default' visible='true'}"
        else:
            valueTextField = "{caption='" + name + "' column='" + column + "' container?='" + container + "' row ='" + row + "' styletype='cell indexed-cell table-cell table-column' visible='true'}"

        if column == "Bit":
            cell = "{container=" + container + " styletype='cell indexed-cell table-row-cell' visible='true'}"
            valueTextField = "{caption='" + name + "' column='" + column + "' container=" + cell + " row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-firstColumn' visible='true'}"

        if column == "Address":
            cell = "{container=" + container + " styletype='cell indexed-cell table-row-cell' visible='true'}"
            valueTextField = "{caption='" + name + "' column='" + column + "' container=" + cell + " row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-firstColumn' visible='true'}"

        testSys = ""
        if object.exists(valueTextField):
            try:
                testSysObj = waitForObject(valueTextField)
            except LookupError:
                test.fail("FAIL", "Unexpectedly failed to find the object")
            try:
                testSys = str(testSysObj.text)
            except LookupError:
                test.fail("FAIL", "Unexpectedly failed to find the property")
        if return_value:
            return testSys
        else:
            if testSys == name:
                test.passes("Pass", name + " found")
                return True
            else:
                test.fail("Fail", name + " not found")
                return False

    @classmethod
    def readValueFromRegMapTable(cls, reg_name, column, moduleName, container, fullname=False, nonDefaultType=False, readOnly=False):
        """
        This method is used for checking text from table

        @param name [string] name of register we check
        @param column [string] name of column
        @param moduleName [string] name of module we check e.g. "cs42l42 (CS42L42)"
        @param conteiner [string] name of conteiner
        @param fullname [bool]
        @param nonDefaultType [bool]
        @param readOnly [bool]
        @return [bool] register value

        Usage:
        module = "cs42l42 (CS42L42)"
        registerMapObj = RegisterMap(module)

        ReadActions.readValueFromRegMapTable("Page Select", "Value", module, registerMapObj.getRegisterTable(), True)
        ReadActions.readValueFromRegMapTable("Page Select", "Value", module, RegisterMap(module).getRegisterTable(), True, True)
        """
        InputActions.mouseClickOnItem(RegisterMap(moduleName).getSearch())
        nativeType(reg_name)
        snooze(1)

        if readOnly == True:
            cell = "{column='Value' container=" + container + " id='registerTableValueColumn' row ='0' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
            valueTextField = "{container=" + cell + " styletype='text-input text-field scs-regmap-non_writable' visible='true'}"
        elif fullname == True:
            cell = "{column='" + column + "' container=" + container + " row ='0' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
            if nonDefaultType == False:
                valueTextField = "{container=" + cell + " styletype='text-input text-field' visible='true'}"
            else:
                valueTextField = "{container=" + cell + " styletype='text-input text-field scs-regmap-non_default' visible='true'}"
        else:
            valueTextField = "{column='" + column + "' container?='" + container + "' row ='0' styletype='cell indexed-cell table-cell table-column' visible='true'}"

        if column == "Bit":
            cell = "{container=" + container + " styletype='cell indexed-cell table-row-cell' visible='true'}"
            valueTextField = "{column='" + column + "' container=" + cell + " id='bitfieldTableBitColumn' row='0' styletype='cell indexed-cell table-cell table-column scs-table-view-firstColumn' visible='true'}"

        if column == "Address":
            cell = "{container=" + container + " styletype='cell indexed-cell table-row-cell' visible='true'}"
            valueTextField = "{column='" + column + "' container=" + cell + " id='registerTableAddressColumn' row='0' styletype='cell indexed-cell table-cell table-column scs-table-view-firstColumn' visible='true'}"

        if object.exists(valueTextField):
            value = findObject(valueTextField).text
            return value
        else:
            value = ""
            return value

    @classmethod
    def readTextFromTable(cls, column, row, container, sys_name=None, history_prop_type='text'):
        """
        This module is used for reading text from table

        @param column [string] name of column
        @param row [string] name of row
        @param container [string] container that contain table
        @return testSys [string] text from table if exist

        Usage:
        ReadActions.readTextFromTable("Value", "0", "*History*")
        """
        history_scroll = "{container={container={caption='History: %s' parent.visible='true' " \
                         "type='org.eclipse.swt.custom.CTabItem' window={caption='SoundClear Studio' " \
                         "isvisible='true' type='org.eclipse.swt.widgets.Shell'}} id='historyTableView' " \
                         "styletype='table-view scs-history-table' visible='true'} styletype='scroll-bar' " \
                         "visible='true'}" % sys_name

        if object.exists(history_scroll):
            setValue(waitForObject(history_scroll), 1)
        tab = "{caption?='*" + container + "*' parent.visible='true' type='org.eclipse.swt.custom.CTabItem' window=" \
              + MainShell().getMainWindow() + "}"
        rnSystem1 = "{column='" + column + "' row='" + row + "' container=" + tab + \
                    " styletype='cell indexed-cell table-cell table-column' visible='true'}"
        testSys = ""
        row_exists = object.exists(rnSystem1)
        if not row_exists:
            snooze(1)
            row_exists = object.exists(rnSystem1)
        if row_exists:
            InputActions.mouseClickOnItem(rnSystem1)
            snooze(2)
            if history_prop_type is 'text':
                testSys = str(findObject(rnSystem1).text)
            else:
                testSys = str(findObject(rnSystem1).item)
            return testSys
        else:
            return "Real name doesn't exist"

    @classmethod
    def checkBoardExist(cls, testBoardName):
        """
        This module is for checking existence of certain board

        @param testBoardName [string] name of the board (this can be used from globals)
        @return [bool] True if board exist, false otherwise

        Usage:
        ReadActions.checkBoardExist(Directory().getBoardName(boardName)))
        """
        DiscoveryObj = Directory()
        cell = "{caption='" + testBoardName + "' container=" + DiscoveryObj.getSystemDirectoryTree() + " styletype='cell indexed-cell tree-cell' visible='true'}"
        if object.exists(cell):
            return True
        else:
            return False

    @classmethod
    def getNumberOfHistoryRows(cls, system):
        """
        This method returns number of History rows

        @param system [string] name of system
        @return numberOfRows [int] returns number of history rows

        Usage:
        ReadActions.getNumberOfHistoryRows(system)
        """
        historyObj = History(system)
        numberOfRows = 0
        try:
            numberOfRows = waitForObject(historyObj.getTable()).items.length
        except Lookuperror:
            test.fail("Fail", "History object or property not exist")
        return numberOfRows

    @classmethod
    def checkHistoryTabExists(cls, system):
        """
        This method checks if the history tab exists

        @param system [string] name of system
        @return no return

        Usage:
        ReadActions.historyTabExists(system)
        """
        histName = "{caption?='" + system + "' type='org.eclipse.swt.custom.CTabItem'}"
        hist = object.exists(histName)
        if hist:
            test.passes("Pass", "History window for " + system + " is opened")
        else:
            test.fail("Fail", "History windows for " + system + " is not opened")

    @classmethod
    def getHistoryCellCaptions(cls, row, simOrReal):
        """
        Reads values of desired row from history table and returns those values in one list.

        @param row [string] name of row
        @param simOrReal [string] name of system
        @return cell [list] list of fields from operation column

        Usage:
        readActionsObj.getHistoryCellCaptions("0", "CS42L42")
        readActionsObj.getHistoryCellCaptions("0", "System_1")
        """
        historyObj = History(simOrReal)

        #columns from history table, Time stamp is intentionally excluded
        columns = ["Op",
                   "Device Addr",
                   "Page",
                   "Field/Reg",
                   "Address",
                   "Data",
                   "Status"]
        cell = []
        for column in columns:
            field = "{column='" + column + "' container=" + historyObj.getTable() + " row='" + row + "' styletype='cell indexed-cell table-cell table-column' visible='true'}"
            InputActions.mouseClickOnItem(field)
            try:
                fieldObj = waitForObject(field)
            except LookupError:
                test.fail("Fail", "Can not find object")
            try:
                cell.append(str(fieldObj.item).rstrip())
            except AttributeError:
                test.fail("Fail", "Can not find item property")

        return cell

    @classmethod
    def getHistoryColumns(cls, simOrReal, list=[]):
        """
        This method returns list of columns from History table

        @param simOrReal [string] name of simulated or real system
        @param list [list] list of columns that will be searched in History table
        @return columns [list] list of columns from History table

        Usage:
        historyColumns = ReadActions.getHistoryColumns(system, ['Operation', 'Page', 'Field/Reg'])
        """
        historyObj = History(simOrReal)
        row = 0
        historyLength = 0
        columns = []
        InputActions.doubleClickOnTab("History: " + simOrReal, window=MainShell().getMainWindow())
        InputActions.mouseClickOnItem(historyObj.getHistoryCell(str(row), "Device"))
        try:
            historyLength = waitForObject(History(simOrReal).getTable()).items.length
        except LookupError:
            test.fail("Fail", "Can not find object or property")
        while(row < historyLength):
            try:
                if "History" in str(waitForObject(historyObj.getHistoryRow(row)).cell):
                    for column in list:
                        columnContent = str(waitForObject(historyObj.getHistoryCell(str(row), column)).item)
                        columns.append(columnContent)
                    row += 1
                else:
                    try:
                        mouseClick(findObject(historyObj.getHistoryRow(row)), 5, 5, 0, Button.Button1)
                    except LookupError:
                        test.fail("Fail", "Can not find object on row: " + row)
            except LookupError:
                test.fail("Fail", "Can not find object or property")
        InputActions.doubleClickOnTab("History: " + simOrReal, window=MainShell().getMainWindow())
        return columns

    @classmethod
    def checkSimpleContextMenuExisting(cls):
        '''
        This method checks if simple Context Menu exist

        @return [bool] True if window exist, else False

        Usage:
        ReadActions.checkSimpleContextMenuExisting()
        '''

        if object.exists("{type='com.cirrus.scs.ide.ui.javafx.controls.SCSContextMenu' visible='true'}"):
            test.log("Context menu exist!")
            return True
        else:
            test.log("Context menu NOT exist!")
            return False

    @classmethod
    def checkHistoryOperations(cls, simOrReal, readOperation, blockReadOperation, writeOperation, blockWriteOperation):
        '''
        This method checks if History window is populated with operations

        @param simOrReal [string] name of simulated or real system
        @param readOperation [string] search read operation in History window
        @param blockReadOperation [string] search block read operation in History window
        @param writeOperation [string] search write operation in History window
        @param blockWriteOperation [string] search block read operation in History window
        @return no return

        Usage:
        ReadActions.checkHistoryOperations("CDB42L42_0", True, False, False, False)
        '''
        historyObj = History(simOrReal)
        row = 0
        historyLength = 0
        readFound = False
        blockReadFound = False
        writeFound = False
        blockWriteFound = False
        InputActions.doubleClickOnTab("History: " + simOrReal)
        InputActions.mouseClickOnItem(historyObj.getHistoryCell(str(row), "Op"))
        try:
            tableObj = waitForObject(historyObj.getTable())
        except LookupError:
            test.fail("Fail", "Can not find object")
        try:
            historyLength = tableObj.items.length
        except AttributeError:
            test.fail("Fail", "Can not find property")
        """ Check if operations are found """
        while(row < historyLength):
            nativeType("<Down>")
            try:
                hisoryCellObj = waitForObject(historyObj.getHistoryCell(str(row), "Op"))
            except LookupError:
                test.fail("Fail", "Can not find object")
            try:
                operation = hisoryCellObj.item
            except AttributeError:
                test.fail("Fail", "Can not find property")
            if operation == "R":
                if readOperation == False:
                    test.fail("Fail", "History window is populated with Read operation")
                    break
                else:
                    readFound = True
                    test.log(str(operation) + " operation exist in History")
            if operation == "BR":
                if blockReadOperation == False:
                    test.fail("Fail", "History window is populated with Block Read operation")
                    break
                else:
                    blockReadFound = True
                    test.log(str(operation) + " operation exist in History")
            if operation == "W":
                if writeOperation == False:
                    test.fail("Fail", "History window is populated with Write operation")
                    break
                else:
                    writeFound = True
                    test.log(str(operation) + " operation exist in History")
            if operation == "BW":
                if blockWriteOperation == False:
                    test.fail("Fail", "History window is populated with Block Write operation")
                    break
                else:
                    blockWriteFound = True
                    test.log(str(operation) + " operation exist in History")
            row += 1
        if readOperation == True and readFound == False:
            test.fail("Fail", "History window is not populated with Read operation")
        elif blockReadOperation == True and blockReadFound == False:
            test.fail("Fail", "History window is not populated with Block Read operation")
        elif writeOperation == True and writeFound == False:
            test.fail("Fail", "History window is not populated with Write operation")
        elif blockWriteOperation == True and blockWriteFound == False:
            test.fail("Fail", "History window is not populated with Block Read operation")
        else:
            test.passes("Pass", "History window is populated with all expected operations")
        InputActions.doubleClickOnTab("History: " + simOrReal)

    @classmethod
    def checkIfHistoryEmpty(cls, deviceOrSysName, notExist=False):
        '''
        This method check if history table is empty

        @param deviceOrSysName [string] device or simulated system name
        @param notExist [bool] if True history should be not empty, if False history should be empty
        @return no return

        Usage:
        ReadActions.checkIfHistoryEmpty("System_1")
        ReadActions.checkIfHistoryEmpty("System_1", True)
        '''
        historyObj = History(deviceOrSysName)
        if notExist == False:
            if object.exists(historyObj.getHistoryCell("0", "Address")):
                if str(findObject(historyObj.getHistoryCell("0", "Address")).item) != "<null>":
                    test.fail("FAIL", "History is not empty")
                else:
                    test.passes("PASS", "History table is empty")
            else:
                test.passes("PASS", "History table is empty")
        else:
            if object.exists(historyObj.getHistoryCell("0", "Address")):
                test.passes("PASS", "History is not empty")
            else:
                test.fail("FAIL", "History table is empty")

    @classmethod
    def checkHistoryFilterCheckComboBox(cls, device, item, columns=False):
        """
        This method check if History filter combo box item is checked

        @param device [string] name of device or system
        @param item [string] name of item (Write, Read, Unsolicited Message, Error, Filter by last write, Usb Audio Module...)
        @return [bool] True if item is checked in drop down menu

        Usage:
        ReadActions.checkHistoryFilterCheckComboBox(system, "Filter by last write")
        """
        if columns == False:
            InputActions.mouseClickOnItem(History(device).getFilterDropDown())
            chechBoxItems = History(device).getHistoryDropDownName()
        else:
            InputActions.mouseClickOnItem(History(device).getColumnsDropDown())
            chechBoxItems = History(device).getHistoryColumsDropDownName()
        items = re.split(", ", chechBoxItems)
        if item in items:
            return True
        else:
            return False

    @classmethod
    def checkHistoryExportButton(cls, device, state=True):
        """
        This method is for checking the status of export button

        @param device [string] name of device
        @param state [bool]
        @return no return

        Usage:
        ReadActions.checkHistoryExportButton(system, False)
        """
        buttonDisabled = findObject(History(device).getHistoryExportImage()).disabled
        if state == True:
            if buttonDisabled == False:
                test.passes("PASS", "Button is enabled")
            else:
                test.fail("FAIL", "Button is disabled")
        else:
            if buttonDisabled == True:
                test.passes("PASS", "Button is disabled")
            else:
                test.fail("FAIL", "Button is enabled")

    @classmethod
    def checkCheckComboBoxName(cls, checkComboBox, expectedName):
        """
        This method checks name of CheckComboBox
        PASS if name is correct, FAIL if name is not correct

        @param checkComboBox [string] name of combo box
        @param expectedName [string] string with names
        @return no return

        Usage:
        expectedNames = "Operation, Device Addr, Field/Reg, Address, Value, Status"
        ReadActions.checkCheckComboBoxName(History("System_1").getColumnsDropDown(), expectedNames)
        """
        try:
            if waitForObject(checkComboBox).value == expectedName:
                test.passes("PASS", "CheckComboBox is correct")
            else:
                test.fail("FAIL", "CheckComboBox is not correct")
        except LookupError:
                test.fail("FAIL", "Object or property is not correct")

    @classmethod
    def checkHistoryCellName(cls, system, name, row, column):
        """
        This method checks if history cell name is correct

        @param system [string] name of system
        @param name [string] cell name
        @param row [string] row number
        @param column [string] column name
        @return no return

        Usage:
        ReadActions.checkHistoryCellName("System_1", "Page Select", 0, "Field/Reg")
        """
        historyObject = History(system)
        try:
            register = str(waitForObject(historyObject.getHistoryCell(str(row), column)).item)
            if register == name:
                test.passes("PASS", "Cell name is correct")
            else:
                test.fail("FAIL", "Cell name is " + register + ", expected " + name)
        except LookupError:
            test.fail("FAIL", "Object or property is not correct")

    @classmethod
    def checkDirectoryTree(cls, name, exist=True, status=False):
        """
        This method check if Directory content is displayed in Directory tree.

        @param name [string] Name of the file/folder/panel/system/device/register map...
        @param exist [bool] if True will search if object exist, False will do the inverse logic
        @param status [bool] if true test will be fail
        @return [bool] True if "exist" is true and object with name "name" exists or if "exist" is False
                        and object with name "name" do not exists. False will be returned in all other cases

        Usage:
        ReadActions.checkDirectoryTree(vSystem, False, True)
        """
        pName = "{caption='" + name + "' container=" + Directory().systemDirectoryTree + " styletype='text' visible='true'}"
        if exist is True:
            if object.exists(pName):
                test.log("Folder/File '" + name + "' is displayed!")
                return True
            else:
                if status != False:
                    test.fail("FAIL", "Folder/File '" + name + "' is not displayed!")
                return False
        else:
            if object.exists(pName):
                if status != False:
                    test.fail("FAIL", "Folder/File '" + name + "' is displayed!")
                return False
            else:
                test.log("Folder/File '" + name + "' is not displayed!")
                return True

    @classmethod
    def checkExpendedDirectoryTree(cls, location):
        """
        This method checks the Directory Tree to desired location.

        @param location [strong] location of desired content(conteins ->)
        @return True if location exists, False if location does not exist

        Usage:
        ReadActions.checkExpendedDirectoryTree("My Projects->project1")
        ReadActions.checkExpendedDirectoryTree("Virtual CS47L60 Emulation Board->CS47l60->Global USB Settings")
        """
        directoryObj = Directory()
        exist = True
        temp = location.split("->")
        for item in temp:
            try:
                waitForObject(directoryObj.getProjectName(item))
            except LookupError:
                test.fail("FAIL", "Object does not exist " + item)
                exist = False
        return exist

    @classmethod
    def checkRegisterOrBitFieldValue(cls, nameOfRegister, registerMapObj, checkRegValue=None,
                                     nameOfBitFieldRegister=None, bitFieldValueType=None, checkBitFieldValue=None,
                                     return_value=False):
        """
        @param nameOfRegister [string] name of Register
        @param registerMapObj [string] object of register map(Ex.RegisterMap("cs42l75 (CS42L42)"))
        @param checkRegValue [string] value that we check if exist on Register map in nameOfRegister register
        @param nameOfBitFieldRegister [string] name of bit field register
        @param bitFieldValueType [string] can be "Radio Button", "Combo Box" or "Value"
        @param checkBitFieldValue [string] value that we check if exist on bit field register with name nameOfBitFieldRegister
        @return no return

        Usage:
        ReadActions.checkRegisterOrBitFieldValue("ASP1 LRCK Period", RegisterMap("CS42L75 (CS42L75)"), "0xffffffff")
        ReadActions.checkRegisterOrBitFieldValue("Page Select", RegisterMap("cs42l42 (CS42L42)"), None, "PAGE", "Value", "0x5")
        """
        try:
            mouseClick(waitForObject(registerMapObj.getRegisterFromRegTable(nameOfRegister)), 50, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click")

        if nameOfBitFieldRegister == None and checkBitFieldValue == None:
            row = str(waitForObject(registerMapObj.getRegisterFromRegTable(nameOfRegister)).cell.parent.index)
            ReadActions.checkTextFromTable("Value", row, registerMapObj.getRegisterTable(), checkRegValue, True, True)
            test.log("Check register value is executed")
        elif nameOfBitFieldRegister != None and (return_value or checkBitFieldValue != None):
            bit_field_value = None
            InputActions.mouseClickOnItem(registerMapObj.getRegisterFromBitFieldTable(nameOfBitFieldRegister))
            row = str(waitForObject(registerMapObj.getRegisterFromBitFieldTable(nameOfBitFieldRegister)).cell.parent.index)
            if bitFieldValueType == "Value":
                bit_field_value = ReadActions.checkValueFromBitFieldTable(registerMapObj.getBitFieldTable(), row,
                                                                          checkBitFieldValue, return_value)
            elif bitFieldValueType == "Combo Box":
                bit_field_value = ReadActions.checkComboBoxFromTable(registerMapObj.getBitFieldTable(), row,
                                                                     checkBitFieldValue, return_value)
            elif bitFieldValueType == "Radio Button":
                bit_field_value = ReadActions.checkRadioButtonFromTable(registerMapObj.getBitFieldTable(), row,
                                                                        checkBitFieldValue, return_value)
            elif bitFieldValueType == "Check Box":
                bit_field_value = ReadActions.checkCheckBoxFromTable(registerMapObj.getBitFieldTable(), row,
                                                                     checkBitFieldValue, return_value)
            elif bitFieldValueType == "Slider":
                bit_field_value = ReadActions.checkSliderValueFromBitFieldTable(registerMapObj.getBitFieldTable(), row,
                                                                                checkBitFieldValue, return_value)
            elif bitFieldValueType == None:
                test.fail("FAIL", "Type of bit field value is not entered")
            else:
                test.fail("FAIL", "Type of bit field value is not entered right")
            test.log("Check bit field value is executed")
            if bitFieldValueType != 'Value':
                InputActions.mouseClickOnItem(registerMapObj.getBitfieldToggleButton('NUM'))
                bit_field_value = ReadActions.checkValueFromBitFieldTable(registerMapObj.getBitFieldTable(), row,
                                                                          checkBitFieldValue, return_value)
                InputActions.mouseClickOnItem(registerMapObj.getBitfieldToggleButton('DEF'))
        else:
            test.fail("FAIL", "Check Register value is not executed")
        if return_value:
            return bit_field_value
    @classmethod
    def readRegisterByName(cls, register_name, reg_map):
        InputActions.mouseClickOnItem(reg_map.getRegisterFromRegTable(register_name))
        row = str(findObject(reg_map.getRegisterFromRegTable(register_name)).cell.parent.index)
        register = findObject(reg_map.getRegisterCellArea("Value", row, reg_map.getRegisterTable()))
        value_from_reg_map = register.parent.item.lastsavedvalue
        return value_from_reg_map

    @classmethod
    def checkRegisterValueUsingSearch(cls, register, registerMapObj, value, realNameParams=[False, False, True]):
        """
        This method checks if register value is as expected
        @param register [string] name of Register
        @param registerMapObj [string] object of register map(Ex.RegisterMap("CS47L60_MEMORY (CS47L60_MEMORY)"))
        @param value [string] value which is expected in register value field
        @param realNameParams [list] list of params which determine which real name will be used for valueTextField from method ReadActions.checkTextFromTable
        @return no return

        Usage:
        registerMapObj = RegisterMap("CS47L60_MEMORY (CS47L60_MEMORY)")
        ReadActions.checkRegisterValueUsingSearch("CHIPCONFIG", registerMapObj, "0x00000000")
        """
        InputActions.mouseDoubleClickOnItem(registerMapObj.getSearch())
        nativeType(register)
        snooze(1)
        found = ReadActions.checkTextFromTable("Value", "0", registerMapObj.getRegisterTable(), value, realNameParams[0], realNameParams[1], realNameParams[2])
        if found == True:
            test.passes("PASS", "Register value is as expected")
        else:
            test.fail("FAIL", "Register value is not as expected")

    @classmethod
    def checkSearchComboBoxValue(cls, name, checked=True):
        """
        This method checks if system type is checked

        @param name [string] Name of system type
        @param checked [string] If True system should be checked, if False system should not be checked
        @return no return

        Usage:
        ReadActions.checkSearchComboBoxValue("All Systems")
        """
        try:
            checkBox = waitForObject(Directory().getComboCheckBoxText())
            checkedItems = str(checkBox.text)
            listOfNames = re.split(", ", checkedItems)
            if checked == True:
                if name in listOfNames or "All Systems" in listOfNames:
                    test.passes("PASS", "System type is checked")
                else:
                    test.fail("FAIL", "System type is not checked")
            else:
                if name not in listOfNames and "All Systems" not in listOfNames:
                    test.passes("PASS", "System type is not checked")
                else:
                    test.fail("FAIL", "System type is checked")
        except LookupError:
            test.fail("FAIL", "Can not find object or property")

    @classmethod
    def checkRadioButtonFromTable(self, table, row, expected, return_value=False):
        """
        This method check if radio button is checked.
        Variable 'expected' corresponds to the index of expected checked radio button in cell, starts from 0.

        @param table [string] real name of table
        @param row [string] name of row
        @param expected [string] thing what we expect(can be 0 or 1)
        @return [bool] True if test pass

        Usage:
        ReadActions.checkRadioButtonFromTable(registerMapObj.getBitFieldTable(), row, "1")
        """
        radioCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        try:
            obtained = str(waitForObject(radioCell).item)
            if return_value:
                return obtained
            else:
                if obtained == expected:
                    test.passes("PASS", "Radio button with index " + expected + " in row " + row + " is checked")
                    return True
                else:
                    test.fail("FAIL", "Radio button with index " + expected + " in row " + row + " is checked")
                    return False
        except LookupError:
            test.fail("FAIL", "Can not find object '" + radioCell + "'")

    @classmethod
    def checkCheckBoxFromTable(cls, table, row, value, return_value=False):
        """
        This method check if radio button is checked.
        Variable 'expected' corresponds to the index of expected checked radio button in cell, starts from 0.

        @param table [string] real name of table
        @param row [string] name of row
        @param expected [string] thing what we expect(can be 0 or 1)
        @return [bool] True if test pass

        Usage:
        ReadActions.checkCheckBoxFromTable(registerMapObj.getBitFieldTable(), row, "1")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        field = "{caption='" + value + "' container=" + bitFieldTableCell + " styletype='check-box' visible='true'}"
        mark = str(waitForObject(field).selected)
        test.log(mark)
        if return_value:
            return mark
        else:
            if mark == "True":
                test.log(value + " is marked")
                return True
            else:
                test.log(value + " is not marked")
                return False

    @classmethod
    def checkComboBoxFromTable(self, table, row, expected, return_value=False):
        """
        This method check if combo box has the expected text.
        Variable 'expected' corresponds to the expected text.

        @param table [string] real name of the table
        @param row [string] name of row
        @param expected [string] string that  we expect
        @return [bool] True if test pass

        Usage:
        ReadActions.checkComboBoxFromTable(registerMapObj.getBitFieldTable(), row, "512 ms")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        comboBox = "{container=" + bitFieldTableCell + " styletype='combo-box-base combo-box' visible='true'}"
        cellText = "{caption?='*' container=" + comboBox + " styletype='cell indexed-cell list-cell' visible='true'}"
        try:
            obtained = str(waitForObject(cellText).text)
            if return_value:
                return obtained
            else:
                if expected in obtained:
                    test.passes("PASS", "Combo box in row " + row + " contains " + expected)
                    return True
                else:
                    test.fail("FAIL", "Combo box in row " + row + " does not contain " + expected)
                    return False
        except LookupError:
            test.fail("FAIL", "Can not find object '" + cellText + "'")

    @classmethod
    def checkNotComboBoxFromTable(self, table, row, expected):
        """
        This method check if combo box does not have the expected text.
        Variable 'expected' corresponds to the expected text.

        @param table [string] real name of the table
        @param row [string] name of row
        @param expected [string] string that  we expect
        @return [bool] True if test pass

        Usage:
        ReadActions.checkNotComboBoxFromTable(registerMapObj.getBitFieldTable(), row, "512 ms")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        comboBox = "{container=" + bitFieldTableCell + " styletype='combo-box-base combo-box' visible='true'}"
        cellText = "{caption?='*' container=" + comboBox + " styletype='cell indexed-cell list-cell' visible='true'}"
        try:
            obtained = str(waitForObject(cellText).text)
            if obtained != expected:
                test.passes("PASS", "Combo box in row " + row + " does not contain " + expected)
                return True
            else:
                test.fail("FAIL", "Combo box in row " + row + " contains " + expected)
                return False
        except LookupError:
            test.fail("FAIL", "Can not find object '" + cellText + "'")

    @classmethod
    def checkNoVisibleComboboxInBitfield(cls, table, row):
        '''
        This method check if combo box in bit field table does not exist.

        @param table [string] real name of the table
        @param row [string] name of row
        @return no return

        Usage:
        ReadActions.checkNoVisibleComboboxInBitfield(registerMapObj.getBitFieldTable(), row)
        '''
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        comboBox = "{container=" + bitFieldTableCell + " styletype='combo-box-base combo-box' visible='true'}"
        if object.exists(comboBox):
            test.fail("FAIL", "Combo box in row " + row + " exists")
        else:
            test.passes("PASS", "Combo box in row " + row + "does not exist")

    @classmethod
    def checkCellInTableGrayedOut(cls, row, container):
        """
        This method checks if the cell is grayed out

        @param row [string] name of the row in table
        @param container [string] real name of table
        @return no return

        Usage:
        ReadActions.checkCellInTableGrayedOut(row, registerMapObj.getRegisterTable())
        """
        snooze(0.5)
        rnTableRow = "{caption='TableRow" + row + "' container=" + container + " type='com.froglogic.squish.jfx.TableRowProxy'}"
        try:
            tableRowObject = waitForObject(rnTableRow, 5000)
            if not tableRowObject.cell.item.writable:
                test.passes("PASS", "Cell in row " + row + " is grayed out.")
            else:
                test.fail("FAIL", "Cell in row " + row + " is not grayed out.")

        except LookupError:
            test.fail("FAIL", "Unable to find on cell '" + rnCell + "'")

    @classmethod
    def checkRegisterValueTextColor(cls, row, container, value, hexColor):
        """
        This method checks if the text n register table is of expected color

        @param row [string] name of the row in table
        @param container [string] real name of table
        @param value [string] value of register
        @param hexColor [string] expected hexadecimal color code for the text
        @return no return

        Usage:
        ReadActions.checkRegisterValueTextColor(row, registerMapObj.getRegisterTable(), "0x0108", "0x41d6c3ff")
        """
        snooze(0.5)
        rnIndexedCell = "{column='Value' container=" + container + " id='registerTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        rnInputTextField = "{container=" + rnIndexedCell + " styletype='text-input text-field scs-regmap-non_default' visible='true'}"
        rnText = "{caption='" + value + "' container=" + rnInputTextField + " styletype='text' visible='true'}"
        try:
            textObject = waitForObject(rnText, 5000)
            test.log(str(textObject.fill))
            if str(textObject.fill) == hexColor:
                test.passes("PASS", "Cell in row " + row + " is of " + hexColor + " color.")
            else:
                test.fail("FAIL", "Cell in row " + row + " is not of " + hexColor + " color.")

        except LookupError:
            test.fail("FAIL", "Unable to find '" + rnText + "'")

    @classmethod
    def readAllNamesFromRegMap(cls, regMapObject, bitField=False):
        """
        This method returns list of all names from Register map

        @param regMapObject [string] real name of register map
        @param bitField [bool] default False(names from register map), True(names from bit field)
        @return listOfRegNames [list] list of names from register map

        Usage:
        ReadActions.readAllNamesFromRegMap(RegisterMap("cs42l42 (CS42L42)"))
        """
        if bitField == False:
            regTable = waitForObject(regMapObject.getRegisterTable())
        elif bitField == True:
            regTable = waitForObject(regMapObject.getBitFieldTable())
        properties = object.properties(regTable)
        elementsOfValue = []
        listOfRegNames = []
        for name, value in properties.items():
            if name == "items":
                names = str(value)  # names = "[0 : Page Select : 42, 1 : Device ID A and B : 66....."
                if bitField == False:
                    posOfDots = []
                    posOfComma = []
                    positionToSplit = []
                    for i in range(len(names)):
                        if ":" == names[i]:
                            posOfDots.append(i)
                        if "," == names[i]:
                            posOfComma.append(i)
                    j = 1
                    for i in range(len(posOfComma)):
                        if posOfComma[i] > posOfDots[j] and posOfComma[i] < posOfDots[j + 1]:
                            positionToSplit.append(posOfComma[i])
                            j += 2
                    positionToSplit.append(len(names))
                    previusValue = 0
                    for position in positionToSplit:
                        names1 = names[previusValue:position]
                        elementsOfValue.append(names1)
                        previusValue = position
                else:
                    elementsOfValue = re.split(",", names)
        for element in elementsOfValue:  # element = 0 : Page Select : 42
            if element.count(':') < 2:
                element += " : 0 : 0"
            list1 = re.split(" : ", element)  # list1 = ["0","Page Select","42"]
            listOfRegNames.append(list1[1])  # list1[1] = Page Select
        return listOfRegNames

    @classmethod
    def optionOfferedInComboBox(cls, table, row, value):
        """
        This method checks if the option is offered in a combo box.
        Variable 'index' corresponds to the desired button index, starts from 0.

        @param table [string] real name of the table
        @param row [string] name of the row
        @param value [string] we check whether this value exists
        @return [bool] True if option is offered in a combo box

        Usage:
        ReadActions.optionOfferedInComboBox(registerMapObj.getBitFieldTable(), row, "reserved")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        comboBox = "{container=" + bitFieldTableCell + " styletype='combo-box-base combo-box' visible='true'}"
        comboBoxObject = waitForObject(comboBox, 5000)
        snooze(1)
        mouseClick(comboBoxObject, 5, 5, 0, Button.Button1)
        snooze(1)
        popupControl = "{basetype='javafx.scene.control.PopupControl' visible='true'}"
        waitForObject(popupControl)
        listView = "{container=" + popupControl + " id='list-view' styletype='list-view' visible='true'}"
        waitForObject(listView)
        listCell = "{caption='" + value + "' container=" + listView + " styletype='cell indexed-cell list-cell' visible='true'}"
        listText = "{caption='" + value + "' container=" + listCell + " styletype='text' visible='true'}"
        #listTextObject = waitForObject(listText)
        snooze(0.5)
        if object.exists(listText):
            return True
        else:
            return False

    @classmethod
    def IDERunning(cls):
        """
        This method checks if the SoundClearStudio process is running

        @return flag [bool] True if SCS IDE is ran

        Usage:
        ReadActions.IDERunning()
        """
        flag = False
        if platform.system() == "Windows":
            cmd = 'WMIC PROCESS get Caption,Commandline,Processid'
            proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            for line in proc.stdout:
                if "SoundClearStudio.exe" in line:
                    print("SCS IDE running")
                    flag = True
        elif platform.system() == "Darwin":
            cmd = 'top'
            proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            snooze(1)
            proc.kill()
            for line in proc.stdout:
                print(line)
                if "SoundClear Studio" in line:
                    print("SCS IDE running")
                    flag = True
                    break
        return flag

    @classmethod
    def checkScsAndBspVersion(cls):
        """
        This Method check all version of bsp and version of SoundClear Studio

        @return listOfVersions [string] all version of bsp and version of SoundClear Studio

        Usage:
        ReadActions.checkScsAndBspVersion()
        """
        HelpAboutShellObs = HelpAboutShell()
        version = HelpAboutShellObs.getVersionShell()
        if object.exists(version):
            listOfVersions = findObject(version).text
            return listOfVersions
        else:
            test.fail("FAIL", "Could not find object" + version)

    @classmethod
    def checkLengthOfDevicesInNewProjectShell(cls):
        """
        This method returns the length of devices from new project device wizard shell

        @return length [int] length of devices from new project device wizard shell

        Usage:
        ReadActions.checkLengthOfDevicesInNewProjectShell()
        """
        rnVirtualSystemList = NewDeviceProjectShell().getVirtualSystemsListView()
        length = ""
        if object.exists(rnVirtualSystemList):
            length = findObject(rnVirtualSystemList).items.length
            test.log(str(length))
            return length

    @classmethod
    def availableSystemsListLenghtInNewProjectShell(cls):
        """
        This method returns the length of available systems from new project device wizard shell

        @return length [int] length of list containing the available systems from new project device wizard shell

        Usage:
        ReadActions.availableSystemsListLenghtInNewProjectShell()
        """
        newDeviceProjectShellObj = NewDeviceProjectShell()
        rnAvailableSystemList = newDeviceProjectShellObj.getAvailableSystemsListView()
        length = ""
        if object.exists(rnAvailableSystemList):
            length = findObject(rnAvailableSystemList).items.length
            test.log(str(length))
            return length

    @classmethod
    def readBitFieldRadioButtonValues(cls, table, row):
        """
        This method returns names of radio buttons.

        @param table [string] real name of the table
        @param row [string] name of the row
        @return items [string] names of radio buttons

        Usage:
        ReadActions.readBitFieldRadioButtonValues(registerMapObj.getBitFieldTable(), row)
        """
        #radioCell = "{column='Value' container=" + table + " row= '" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        radioCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        radioGroup = "{container=" + radioCell + " type='com.cirrus.scs.ide.registermap.ui.controls.RadioGroup' visible='true'}"
        radioGroupObject = waitForObject(radioGroup, 5000)
        items = str(radioGroupObject.items)
        return items

    @classmethod
    def readWidgetProperties(cls, panel, widget, widget_ID, id, type):
        """
        @param panel [string]: Name of panel
        @param widget [string]: Name of widget
        @param widget_ID [string]: Widget ID
        @param id [string]: Name of properties
        @param type [string]: Type of cell to edit ["combo-box", "text-field", "check-box", "text-combo-box"]
        @return [string] if successfull returns the widget property value, False otherwise

        Usage:
        panel = "Blank.panel"
        widget1 = "Rounded Button"
        button1_ID = "rounded_button_0"
        properties = "Color"
        type = "combo-box"

        ReadActions.readWidgetProperties(panel, widget1, button1_ID, properties, type)
        """
        if object.exists(WidgetProperties(widget).getWidgetPropertiesTab()) == False:
            try:
                mouseClick(findObject(PanelEditor(panel).getWidget(widget, widget_ID)), 10, 10, 0, Button.Button1)
                test.log("Successfully clicked on widget: " + widget + "( " + widget_ID + " )")
            except LookupError:
                test.fail("FAIL", "Couldn't click on " + widget + "( " + widget_ID + " )")
                return False
        snooze(0.5)

        if type != "check-box":
            return findObject(WidgetProperties(widget).getFieldProperties(id, type)).text
        elif type == "check-box":
            return findObject(WidgetProperties(widget).getFieldProperties(id, type)).selected

    @classmethod
    def checkPerspective(cls, perspective, welcome=False):
        """
        This method check the current user perspective
        @param perspective: name of desirable user perspective (string)
        @param welcome: if true check perspective on Welcome Screen, if false check on Main window

        Usage:
        ReadActions.checkPerspective("Panel Developer")
        ReadActions.checkPerspective("Configure")
        ReadActions.checkPerspective("Panel Developer", True)
        ReadActions.checkPerspective("Configure", True)
        """
        snooze(1)
        if welcome == True:
            currentPerspective = str(waitForObject(Welcome().getPerspectiveComboBox()).value)
            if perspective == currentPerspective:
                test.passes("PASS", "User perspective is: " + perspective)
            else:
                test.fail("FAIL", "User perspective is not: " + perspective)
        else:
            if object.exists(MainShell().getCLabel(perspective)):
                test.passes("PASS", "User perspective is: " + perspective)
            else:
                test.fail("FAIL", "User perspective is not: " + perspective)

    @classmethod
    def checkFormatComboBox(cls, device, format):
        """
        This method reads what format is used at the moment and compares it with given format

        @param devide[string] name of tab
        @param format [string] format of data (dec, hex, bin)
        @return no return

        Usage:
        ReadActions.checkFormatComboBox(RegisterMap("cs42l42 (CS42L42)"), "dec")
        """
        rnSystem1 = device.getFormatComboBox()
        formatValue = ""
        if object.exists(rnSystem1):
            formatValue = findObject(rnSystem1).value
            formatValue = str(formatValue)
        if formatValue == format:
            test.passes("Pass", format + " found")
        else:
            test.fail("Fail", format + " not found")

    @classmethod
    def getRegisterAddressOrPage(cls, registerMapObj, registerName, option, returnObj=False):
        """
        @param regmapObj [object] RegisterMap class object
        @param registerName [string] name of register
        @param option [string] "Page", "Address" or "Name
        @param returnObj [boolean] False or True depending on returning "Page", "Address" or "Page", "Address", "Name" object
        @returns "Page", "Address" or "Page", "Address", "Name" object depending on parameters
        Usage:
        RegisterMapObj = RegisterMap("cs42l42 (CS42L42)")
        pageOfFreezeControlRegister = RegisterMapObj.getRegisterAddressOrPage(RegisterMapObj, "Freeze Control", "Page")
        freezeControlRegisterPageObj = RegisterMapObj.getRegisterAddressOrPage(RegisterMapObj, "Freeze Control", "Address", True)
        """
        #registerMapObj = RegisterMap("cs42l42 (CS42L42)")
        InputActions.mouseClickOnItem(registerMapObj.getRegisterFromRegTable(registerName))
        cellTableRowRealname = waitForObject(registerMapObj.getRegisterFromRegTable(registerName)).cell.parent
        obj = waitForObject(cellTableRowRealname)
        children = object.children(obj)
        for child in children:
            if "registerTablePageColumn" in str(child):
                registerPageObj = child
                #test.log("Registers page is " + registerPageObj.text)
            elif "registerTableAddressColumn" in str(child):
                registerAddressObj = child
                #test.log("Registers address is " + registerAddressObj.text)
            elif "registerTableNameColumn" in str(child):
                registerNameObj = child
                #test.log("Registers name is " + registerNameObj.text)

        if option == "Page":
            if returnObj == False:
                return registerPageObj.text
            else:
                return registerPageObj
        elif option == "Address":
            if returnObj == False:
                return registerAddressObj.text
            else:
                return registerAddressObj
        elif option == "Name":
            return registerNameObj

    @classmethod
    def checkValueFromBitFieldTable(self, table, row, expected, return_value=False, reattempt=20):
        """
        This method check if value has the expected text.
        Variable 'expected' corresponds to the expected text.

        @param table [string] real name of the table
        @param row [string] name of row
        @param expected [string] string that  we expect
        @return [bool] True if test pass

        Usage:
        ReadActions.checkValueFromBitFieldTable(registerMapObj.getBitFieldTable(), row, "512 ms")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        valueField = "{container=" + bitFieldTableCell + " styletype='text-input text-field' visible='true'}"
        cellText = "{caption?='*' container=" + valueField + " styletype='text' visible='true'}"
        while reattempt > 0:
            try:
                obtained = str(waitForObject(cellText).text)
                obtained = builtins.hex(builtins.int(obtained, 16))
                if return_value:
                    return obtained
                if obtained == expected:
                    test.passes("PASS", "Text field in row " + row + " contains " + expected)
                    return True
                else:
                    test.fail("FAIL", "Text field in row " + row + " does not contain " + expected)
                    return False
            except LookupError:
                if reattempt == 1:
                    test.fail("FAIL", "Can not find object '" + cellText + "'")
                    return
                else:
                    test.warning("Warning", "Can not find object %s, try again" % cellText)
                    reattempt -= 1
                    snooze(0.5)

    @classmethod
    def checkSliderValueFromBitFieldTable(self, table, row, expected, return_value=False):
        """
        This method check if value has the expected text.
        Variable 'expected' corresponds to the expected text.

        @param table [string] real name of the table
        @param row [string] name of row
        @param expected [string] string that  we expect
        @return [bool] True if test pass

        Usage:
        ReadActions.checkValueFromBitFieldTable(registerMapObj.getBitFieldTable(), row, "512 ms")
        """
        bitFieldTableCell = "{column='Value' container=" + table + " id='bitfieldTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        labelField = "{container=" + bitFieldTableCell + " styletype='label' visible='true'}"
        sliderLabel = "{caption?='*' container=" + labelField + " styletype='text' visible='true'}"
        try:
            obtained = str(waitForObject(sliderLabel).text)
            if return_value:
                return obtained
            else:
                if expected in obtained:
                    test.passes("PASS", "Slider in row " + row + " contains " + expected)
                    return True
                else:
                    test.fail("FAIL", "Slider in row " + row + " does not contain " + expected)
                    return False
        except LookupError:
            test.fail("FAIL", "Can not find object '" + cellText + "'")

    @classmethod
    def checkRedRectangleAroundValue(cls, registerMapObj, nameOfRegister, bitField=False):
        """
        This method checks if the red rectangle is around value in register table

        @param registerMapObj [string] register map object ex. RegisterMap("cs42l42 (CS42L42)")
        @param nameOfRegister [string] name of register we check value
        @return [bool] True if it is red rectangle around register value
                       False if it is not

        Usage:
        ReadActions.checkRedRectangleAroundValue(RegisterMap("cs42l42 (CS42L42)"), "Page Select")
        """

        try:
            mouseClick(waitForObject(registerMapObj.getRegisterFromRegTable(nameOfRegister)), 50, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click")

        if bitField == False:
            row = str(waitForObject(registerMapObj.getRegisterFromRegTable(nameOfRegister)).cell.parent.index)
            test.log("row: " + row)
            valueColumn = "{column='Value' container=" + registerMapObj.getRegisterTable() + " id='registerTableValueColumn' row='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
            regularValue = "{container=" + valueColumn + " styletype='text-input text-field scs-regmap-non_default' visible='true'}"
            valueWithRedRictangle = "{container=" + valueColumn + " styletype='text-input text-field scs-regmap-has_error scs-regmap-non_default' visible='true'}"

        if bitField:
            InputActions.mouseClickOnItem(registerMapObj.getRegisterFromBitFieldTable(nameOfBitFieldRegister))
            row = str(waitForObject(registerMapObj.getRegisterFromBitFieldTable(nameOfBitFieldRegister)).cell.parent.index)

        if object.exists(valueColumn):
            return True
            test.log("valueColumn object exists")

        if object.exists(valueWithRedRictangle):
            return True
            test.passes("PASS", "Red rectangle is around value box")
        elif object.exists(regularValue):
            return False
            test.fail("FAIL", "Red rectangle is not around value box")
        else:
            test.fail("FAIL", "Register with name " + nameOfRegister + " does not exist")

    @classmethod
    def checkPreferencesFilter(cls, string):
        """
        This method checks if Preferences filter works as expected
        @param string [string] Text that is entered in Preferences filter
        @return no return

        Usage:
        ReadActions.checkPreferencesFilter(text)
        """
        preferencesObj = Preferences()
        InputActions.mouseClickOnItem(preferencesObj.getTextFiltar())
        testMachine = platform.system()
        if "Windows" in testMachine:
            nativeType("<Ctrl+a>")
        elif "Darwin" in testMachine:
            nativeType("<command+a>")
        elif "Linux" in testMachine:
            nativeType("<Ctrl+a>")

        nativeType("<Delete>")
        nativeType(string)
        snooze(1)

        try:
            prefTreeItems = object.children(findObject(preferencesObj.getPreferencesTreeItems()))
            for prefTreeItem in prefTreeItems:
                if ((prefTreeItem.text).lower()).find(string.lower()) != -1:
                    test.passes("PASS", "Items that have chosen text are only shown (filter works).")
                else:
                    test.fail("FAIL", "Items that have chosen some other text are shown (filter does not work).")
        except LookupError as lue:
            test.fail("FAIL", "Didn't find items object. Error: " + str(lue))

        if "Windows" in testMachine:
            nativeType("<Ctrl+a>")
        elif "Darwin" in testMachine:
            nativeType("<command+a>")
        elif "Linux" in testMachine:
            nativeType("<Ctrl+a>")

        nativeType("<Delete>")

    @classmethod
    def listAllVirtualSystems(cls):
        """
        This method takes all virtual and real systems and puts them on the list

        @return listOfSystem


        Usage:
        ReadActions.listAllVirtualSystems()


        """
        listOfSystem = []
        Common.showDiscoveredSystem()

        if not object.exists(Directory().getDiscoveredSystems()):
            test.log("There are no created system.")
            return listOfSystem

        try:
            systemObj = waitForObject(Directory().getDiscoveredSystems())
        except LookupError:
            test.fail("FAIL", "Discovered Systems does not exist")
        discoveredSystems = str(systemObj.item.observables)
        if discoveredSystems != "[]":
            discoveredSystems = discoveredSystems.replace("[", "")
            discoveredSystems = discoveredSystems.replace("]", "")
            systems = re.split(",", discoveredSystems)
            for system in systems:
                tempSystem = re.split(":", system)
                if object.exists(Directory().getBoardOrSystem(tempSystem[0].strip())):
                    listOfSystem.append(tempSystem[0].strip())
        return listOfSystem

    @classmethod
    def checkLockedCheckBoxValue(cls, expectedValue, result=False):
        """
        This method check value of check box
        @param expectedValue [boolean] expectedValue - if True check box is checked, if false check box is not checked
        @param result [boolean] result = if True use pass/fail criterium
        @return True if expected value of combo box is found or False if expected value of combo box is not found

        Usage:
        ReadActions.checkLockedCheckBoxValue()
        ReadActions.checkLockedCheckBoxValue(True)
        ReadActions.checkLockedCheckBoxValue(True, True)
        """
        blockPropertiesObj = BlockProperties()
        currentValue = False
        try:
            currentValue = waitForObject(blockPropertiesObj.getLockedCheckBox()).selected
        except LookupError:
            test.fail("Fail", "Can not find object or property")
        if expectedValue == currentValue:
            if result == True:
                test.passes("PASS", "State of check box: expected " + str(expectedValue) + ", got " + str(currentValue))
            return True
        else:
            if result == False:
                test.fail("FAIL", "State of check box: expected " + str(expectedValue) + ", got " + str(currentValue))
            return False

    @classmethod
    def getPanelItemID(cls, item):
        """
        This method return ID of block, widget, connection... from panel
        @param item [string] item real name - can be real name of block, widget, connection...
        @return ID of panel item

        Usage:
        ReadActions.getPanelItemID(item)
        """
        ID = 0
        try:
            ID = waitForObject(item).id
        except LookupError:
            test.fail("FAIL", "Can not find object or property")
        return ID

    @classmethod
    def readCoordinates(cls, item, type="max"):
        """
        This method return max or min coordinates of object
        @param item [string] real name of object
        @param type [string] can be max or min
        @return maxx and maxy or minx and miny coordinates

        Usage:
        ReadActions.readCoordinates(item, "max")
        ReadActions.readCoordinates(item, "min")
        """
        try:
            if type == "max":
                xCoordinate = waitForObject(item).boundsinparent.maxx
                yCoordinate = waitForObject(item).boundsinparent.maxy
            elif type == "min":
                xCoordinate = waitForObject(item).boundsinparent.minx
                yCoordinate = waitForObject(item).boundsinparent.miny
            else:
                test.fail("FAIL", "Wrong second parameter")
                return None
        except LookupError:
            test.fail("FAIL", "Can not find object or property")
            return None
        return xCoordinate, yCoordinate

    @classmethod
    def parseObjectPropertyValue(cls, real_name, property, start, end):
        """
        This module is used for reading text from table

        @param real_name [object] Real name of object
        @param property [string] Property of object
        @param start [string] String starts with
        @param end [string] String ends with
        @return find_value [list] Return string of first element of list from found strings

        Usage:
        panel = "Blank.panel"
        widget1 = "Diagram Link"
        text_area1_ID = "diagram_link_0"

        ReadActions.parseObjectPropertyValue(PanelEditor(panel).getWidget(widget1, text_area1_ID), "childrenunmodifiable", "stroke=0x", ",")
        """
        try:
            obj_string = str(getattr(waitForObjectExists(real_name), property))
            test.log("Parsing property value : " + obj_string)
        except:
            test.fatal("Can not find object or property of the object", "Object: " + real_name + "\nProperty: " + property)

        test.log("Find string that starts with \'" + start + "\' and ends with \'" + end + "\'")
        pattern = '(?<=' + start + ')(.*)(?=' + end + ')'
        find_string = re.findall(pattern, obj_string)
        test.log("Found string: " + str(find_string))
        if len(find_string) > 0:
            return find_string[0]
        else:
            return "Can't parse string"

    @classmethod
    def checkIfBlocksAreConnected(cls, panel, firstBlock, secondBlock, connection, portSideFirstBlock,
                                  portSideSecondBlock, portNumberFirstBlock, portNumberSecondBlock):
        """
        This method checks if two blocks are connected
        @param panel [string] panel name
        @param firstBlock [string] real name of the first block
        @param secondBlock [string] real name of the second block
        @param connection [string] real name of the connection
        @param portSideFirstBlock [string] port side of the first block
        @param portSideSecondBlock [string] port side of the second block
        @param portNumberFirstBlock [integer] port number of the first block
        @param portNumberSecondBlock [integer] port number of the second block
        @return no return

        Usage:
        panel = "Event Handling"
        panelEditorObj = PanelEditor(panel)
        firstBLockID = panelEditorObj.getBorderPaneOrConnectionID("BorderPane", 3)
        firstBlock = panelEditorObj.getBlockBorderPane(firstBLockID)
        connectionID = panelEditorObj.getBorderPaneOrConnectionID("Connection", 1)
        connection = panelEditorObj.getConnection(connectionID)
        secondBlockID = panelEditorObj.getBorderPaneOrConnectionID("BorderPane", 6)
        secondBlock = panelEditorObj.getBlockBorderPane(secondBlockID)
        ReadActions.checkIfBlocksAreConnected(panel, firstBlock, secondBlock, connection, "right", "left", 1, 1)
        """
        panelEditorObj = PanelEditor(panel)
        """ Get port ID of the first block"""
        try:
            outputPortID = waitForObject(panelEditorObj.getPort(firstBlock, portSideFirstBlock, portNumberFirstBlock)).id
        except LookupError:
            test.fail("FAIL", "Can not find object or property for the first block")
        """ Get port ID of the block where the connection starts"""
        try:
            startPortID = waitForObject(connection).startanchor.anchorage.id
        except LookupError:
            test.fail("FAIL", "Can not find object or property for the connection")
        """ Get port ID of the second block"""
        try:
            inputPortID = waitForObject(panelEditorObj.getPort(secondBlock, portSideSecondBlock, portNumberSecondBlock)).id
        except LookupError:
            test.fail("FAIL", "Can not find object or property for the second block")
        """ Get port ID of the block where the connection ends"""
        try:
            endPortID = waitForObject(connection).endanchor.anchorage.id
        except LookupError:
            test.fail("FAIL", "Can not find object or property for the connection")

        if outputPortID == startPortID and inputPortID == endPortID:
            test.passes("PASS", "Blocks are connected")
        else:
            if outputPortID != startPortID:
                test.fail("FAIL", "The first block is not connected")
            if inputPortID != endPortID:
                test.fail("FAIL", "The second block is not connected")

    @classmethod
    def getBlocksFromXML(cls, blockType, fileName):
        """
        This method checks if blocks are written to xml
        @param blockType [string] can be "events" or "actions"
        @param fileName [string] name of file
        @return list of blocks

        Usage:
        ReadActions.getBlocksFromXML("events", "configuration.xml")
        ReadActions.getBlocksFromXML("actions", "configuration.xml")
        """
        import xml.etree.ElementTree as ET
        configurationFile = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + fileName
        list = []
        tree = ET.parse(configurationFile)
        root = tree.getroot()
        if blockType == "events":
            for events in root.findall(".//eventConfiguration//events//source"):
                list.append(events.text)
        elif blockType == "actions":
            for actions in root.findall(".//eventConfiguration//actions"):
                for i in actions:
                    list.append(i.tag)
        else:
            test.fail("FAIL", "Wrong the first parameter")
        return list

    @classmethod
    def getObjectLayout(cls, object, coordinate):
        """
        This method return object coordinate
        @param object [string]  real name of object
        @param coordinate [string] x or y coordinate

        Usage:
        panel = "DMC.bdf"
        panelEditorObj = PanelEditor(panel)
        ReadActions.getObjectLayout(panelEditorObj.getRectangleFromConnection("1"), "x")
        ReadActions.getObjectLayout(panelEditorObj.getRectangleFromConnection("1"), "y")
        """
        try:
            if coordinate == "x":
                layout = waitForObject(object).layoutx
            elif coordinate == "y":
                layout = waitForObject(object).layouty
            else:
                test.fail("FAIL", "Wrong second parameter")
            return layout
        except LookupError:
            test.fail("FAIL", "Can not find object or property")
            return None

    @classmethod
    def getPropertyOfObject(cls, realName, property):
        """
        This method returns value of object property

        @param object [string] real name of object
        @param property [string] name of property
        @return value of property

        Usage:
        ReadActions.getPropertyOfObject(panelEditorObj.getWidgetEditor("Blank_dial_0", dial), "value")
        """
        value = ""
        try:
            value = str(getattr(waitForObjectExists(realName), property))
            test.log("Parsing property value : " + value)
        except:
            test.fail("Can not find object or property of the object", "Object: " + realName + "\nProperty: " + property)

        return value


    @classmethod
    def listAllDevicesWriteSettings(cls, systemName, systemType):
        """
        This method compare two lists.
        The first list contains devices that are visible in Write Settings dialog
        The second list contains all the devices that are in the installed package

        @param systemName [string] name of virtual system
        @param systemType [string] type of virtual system

        Usage:
        systemName = "Virtual_system"
        ReadActions.listAllDevicesWriteSettings(system, "cdb42l42")

        """

        testMachine = currentMachine.getItem("operating_system")
        if "Windows" in testMachine:
            pathToPackage = "C:\\Users\\All Users\\Cirrus Logic" + os.sep + SuiteGlobals.SCS_VERSION_SHORT + os.sep + "systems"
        if "OS X" in testMachine:
            pathToPackage = "/Users/Shared/Cirrus Logic" + os.sep + SuiteGlobals.SCS_VERSION_SHORT + os.sep + "systems"

        listOfVirtualSystem = []
        listOfPackage = []
        try:
            systemObj = waitForObject(Preferences().getTreeDialogItem(systemName))
        except LookupError:
            test.fail("FAIL", "Virtual System List does not exist")
        test.log("Get all devices in virtual system (Write Settings dialog page)")
        virtualSystem = str(systemObj.item.devices)
        if virtualSystem != "[]":
            virtualSystem = virtualSystem.replace("[", "")
            virtualSystem = virtualSystem.replace("]", "")
            systems = re.split(",", virtualSystem)
            for system in systems:
                listOfVirtualSystem.append(system.strip())
        test.log("Get all devices in virtual system (in package)")
        tree = ET.parse(pathToPackage + os.sep + systemType + os.sep + systemType + ".xml")
        root = tree.getroot()
        for name in root.findall(".//Devices//Device//Name"):
            listOfPackage.append(name.text)
        test.log("Compare lists")
        for i in range(0, len(listOfPackage)):
            if listOfPackage[i] in listOfVirtualSystem:
                test.passes("PASS", listOfPackage[i] + " is listed in Write Settings page.")
            else:
                test.fail("FAIL", listOfPackage[i] + " is not listed in Write Settings page.")


    @classmethod
    def checkIfTabIsFocused(cls, tabRealName, state=True):
        """
        This method checks if tab is focused/selected

        @param tabRealName [string] tab real name
        @param state [bool] state equals True for positive or False for negative scenario

        Usage:
        ReadActions.checkIfTabIsFocused(tabRealName)
        ReadActions.checkIfTabIsFocused(tabRealName, False)
        """
        try:
            if state:
                if str(waitForObject(tabRealName).selected) == "True":
                    test.passes("PASS", tabRealName + " tab is selected")
                else:
                    test.fail("FAIL", tabRealName + " tab is NOT selected")
            else:
                if str(waitForObject(tabRealName).selected) == "True":
                    test.fail("FAIL", tabRealName + " tab is selected")
                else:
                    test.passes("PASS", tabRealName + " tab is NOT selected")
        except Exception, e:
            test.fail("FAIL", str(e))

    @classmethod
    def checkIfRadioButtonSelected(cls, radioButtonRealName, state=True):
        """
        This method checks if radio button is selected

        @param radioButtonRealName [string] radio button real name
        @param state [bool] state equals True for positive or False for negative scenario

        Usage:
        ReadActions.checkIfRadioButtonSelected(radioButtonRealName)
        ReadActions.checkIfRadioButtonSelected(radioButtonRealName, False)
        """
        try:
            if state:
                if waitForObject(radioButtonRealName).selected:
                    test.passes("PASS", radioButtonRealName + " is selected")
                else:
                    test.fail("FAIL", radioButtonRealName + " is NOT selected")
            else:
                if waitForObject(radioButtonRealName).selected == True:
                    test.fail("FAIL", radioButtonRealName + " is selected")
                else:
                    test.passes("PASS", radioButtonRealName + " is NOT selected")
        except Exception, e:
            test.fail("FAIL", str(e))

    @classmethod
    def checkIfiWidgetIsEnabled(cls, widgetRealName, state=True):
        """
        This method checks if widget is enabled

        @param widgetRealName [string] widget real name
        @param state [bool] state equals True for positive or False for negative scenario

        Usage:
        ReadActions.checkIfiWidgetIsEnabled(widgetRealName)
        ReadActions.checkIfiWidgetIsEnabled(widgetRealName, False)
        """
        try:
            if state:
                if waitForObject(widgetRealName).globalenabled:
                    test.passes("PASS", widgetRealName + " is enabled")
                    return True
                else:
                    test.fail("FAIL", widgetRealName + " is NOT enabled")
                    return False
            else:
                if waitForObject(widgetRealName).globalenabled == True:
                    test.fail("FAIL", widgetRealName + " is enabled")
                    return False
                else:
                    test.passes("PASS", widgetRealName + " is NOT enabled")
                    return True
        except Exception, e:
            test.fail("FAIL", str(e))
            return False

    @classmethod
    def checkCheckBoxValue(cls, checkBox, expectedValue=True, testIt=True):
        """
        This method check value of check box
        @param checkBox [string] - real name of checkbox whose value will be checked
        @param expectedValue [boolean] - if True check box is checked, if false check box is not checked
        @param testIt [boolean] - if True, test pass criteria is enabled
        @return True if expected value of combo box is found or False if expected value of combo box is not found

        Usage:
        ReadActions.checkCheckBoxValue(checkbox)
        ReadActions.checkCheckBoxValue(checkbox, True)
        ReadActions.checkCheckBoxValue(checkbox, True, False)
        """

        currentValue = False
        try:
            currentValue = waitForObject(checkBox).model.value
        except Exception, e:
            test.fail("FAIL", str(e))
        if expectedValue == currentValue:
            if testIt:
                test.passes("PASS", "State of check box: expected " + str(expectedValue) + ", got " + str(currentValue))
                if expectedValue:
                    return True
                else:
                    return False
        else:
            if testIt:
                test.fail("FAIL", "State of check box: expected " + str(expectedValue) + ", got " + str(currentValue))
            return False

    @classmethod
    def readFullNameOfSystemOrBoard(cls, name):
        """
        This method returns full name of System or Board from Discovered Systems
        Example: ReadActions.readFullNameOfSystemOrBoard("CDB46L06") will return "CDB46L06(USBDFU-Port_6-Bus_1)"

        @param name [string] part of the name of system or board you want to get from this method

        Usage:
        ReadActions.readFullNameOfSystemOrBoard("CDB46L06")
        """
        fullName = ""
        timeout = 1200000
        directoryObj = Directory()
        Common.showDiscoveredSystem()
        try:
            systemObj = waitForObject(directoryObj.getDiscoveredSystems(), timeout)
        except LookupError:
            test.fail("FAIL", "Discovered Systems does not exist")
        discoveredSystems = str(systemObj.item.children)
        if discoveredSystems != "[]":
            discoveredSystems = discoveredSystems.replace("[", "")
            discoveredSystems = discoveredSystems.replace("]", "")
            systems = re.split(",", discoveredSystems)
            for system in systems:
                tempSystem = re.split(":", system)
                if name in tempSystem[0].strip():
                    fullName = tempSystem[0].strip()
        return fullName
