"""
Base class for panel verification.
"""
import builtins
import re
from collections import namedtuple, OrderedDict

source(findFile("scripts", "base_bsp_squish.py"))
source(findFile("scripts", "device_xml_parser.py"))
source(findFile("scripts", "base_register_map.py"))

register_attr = namedtuple('RegisterAttr', 'Name DisplayName Access DefaultValue Address BitFields')
REG_ATTR = register_attr('Name', 'DisplayName', 'Access', 'DefaultValue', 'Address', 'BitFields')
bitfield_attr = namedtuple('BitFieldAttr', 'Name RegisterName Access DefaultValue Address '
                                           'Values Units Start End FieldType '
                                           'TextField RadioButton ComboBox Slider Value BitFieldLocation')
BIT_FIELD_ATTR = bitfield_attr('Name', 'RegisterName', 'Access', 'DefaultValue', 'Address', 'Values', 'Units',
                                       'Start', 'End', 'FieldType', 'text_field', 'radio_button', 'combo_box',
                                       'slider', 'Value', 'BitFieldLocation')

regmap_field_type = namedtuple('REG_MAP_FIELD_TYPE', 'TextField RadioButton ComboBox Slider')
REG_MAP_FIELD_TYPE = regmap_field_type('Value', 'Radio Button', 'Combo Box', 'Slider')

model_name_prefix = namedtuple('MODEL_NAME_PREFIX',
                               'NumericField TextField RadioButton ComboBox Slider CheckBox Button ToggleButton')
MODEL_NAME_PREFIX = model_name_prefix('numeric_field_', 'tf_', 'radio_group_', 'combo_box_', 'slider_', 'check_box_',
                                      'button_', 'toggle_button_')

slider_named_tuple = namedtuple('SLIDER_ATTRIBUTES',
                                'Start End Mid Base Multiplier Description StartReserveBit EndReserveBit Position Value')
SLIDER_ATTRIBUTES = slider_named_tuple('Start', 'End', 'Mid', 'Base', 'Multiplier', 'Description', 'StartReserveBit',
                                       'EndReserveBit', 'Position', 'Value')
scs_version = SuiteGlobals.SCS_VERSION_SHORT.split("_")[1]


class PanelBitFieldDetails:
    """
    Data structure to store bit field details in a panel.
    """
    def __init__(self, **panel_bit_field_details):
        field_name = panel_bit_field_details.get('FieldName')
        field_type = panel_bit_field_details.get('FieldType')
        self.set_attribute('Name', field_name)
        self.set_attribute('DefaultValue', panel_bit_field_details.get('DefaultValue'))
        self.set_attribute('RegisterName', panel_bit_field_details.get('RegisterName'))
        self.set_attribute('RegisterDefault', panel_bit_field_details.get('RegisterDefault'))
        field_type, model_name = self.get_realname_details(field_type, field_name)
        self.set_attribute('FieldType', field_type)
        self.set_attribute('ModelName', model_name)
        self.set_attribute('Address', panel_bit_field_details.get('Address'))
        self.set_attribute('Values', panel_bit_field_details.get('Values'))
        self.set_attribute('BitFieldLocation', panel_bit_field_details.get('BitFieldLocation'))
        self.set_attribute('Units', panel_bit_field_details.get('Units', None))
        self.set_attribute('RegWidth', panel_bit_field_details.get('RegWidth'))
        self.set_attribute('RegMapName', panel_bit_field_details.get('RegMapName'))
        self.set_attribute('RegisterData', panel_bit_field_details.get('RegisterData'))

    def set_attribute(self, attr_name, attr_value):
        setattr(self, attr_name, attr_value)

    @staticmethod
    def get_realname_details(field_type, field_name):
        if field_type == BIT_FIELD_ATTR.RadioButton:
            model_name = MODEL_NAME_PREFIX.RadioButton + field_name
            return REG_MAP_FIELD_TYPE.RadioButton, model_name
        elif field_type == BIT_FIELD_ATTR.TextField:
            model_name = MODEL_NAME_PREFIX.TextField + field_name
            return REG_MAP_FIELD_TYPE.TextField, model_name
        elif field_type == BIT_FIELD_ATTR.Slider:
            model_name = MODEL_NAME_PREFIX.Slider + field_name
            return REG_MAP_FIELD_TYPE.Slider, model_name
        elif field_type == BIT_FIELD_ATTR.ComboBox:
            model_name = MODEL_NAME_PREFIX.ComboBox + field_name
            return REG_MAP_FIELD_TYPE.ComboBox, model_name


class BasePanelVerify(BaseSquish):
    def parse_xml_populate_data(self, bit_field_names, reg_map_name):
        """
        Parse the device definition xml file
        Populates attributes required to verify a panel widget.
        """
        self.default_checks = {HISTORY: PASS_STEP, REG_MAP: PASS_STEP}
        test.log("self.squish_config %s" % self.squish_config.__dict__)
        self.parse_xml_and_reg_width()
        self.bit_field_data = {}
        for field_name in bit_field_names:
            reg_name = self.device_xml_parser.get_regname_for_field(field_name)
            reg_data = self.register_class_dict[reg_name]
            for bit_field in reg_data.BitFields:
                if bit_field.Name == field_name or bit_field.Name.startswith(field_name + " ["):
                    if reg_data.DisplayName:
                        register_name = reg_data.DisplayName
                    else:
                        register_name = reg_data.Name
                    panel_details = {'FieldName': field_name,
                                     'DefaultValue': bit_field.DefaultValue,
                                     'RegisterName': register_name,
                                     'RegisterDefault': reg_data.DefaultValue,
                                     'FieldType': bit_field.FieldType,
                                     'Address': bit_field.Address,
                                     'RegWidth': self.reg_width,
                                     'RegMapName': reg_map_name,
                                     'BitFieldLocation': bit_field.BitFieldLocation,
                                     'Units': bit_field.Units,
                                     'Description': bit_field.Description,
                                     'Values': bit_field.Values,
                                     'RegisterData': reg_data}
                    panel_data = PanelBitFieldDetails(**panel_details)
                    break
            self.bit_field_data[field_name] = panel_data
        for field_name, data in self.bit_field_data.items():
            test.log("name:%s, reg map type %s, model name:%s,"
                     "reg name:%s, reg default:%s, field address:%s,"
                     "field default:%s,Location: %s,Values: %s" % (field_name, data.FieldType, data.ModelName,
                                                                   data.RegisterName, data.RegisterDefault,
                                                                   data.Address, data.DefaultValue,
                                                                   data.BitFieldLocation, data.Values))

    def parse_xml_and_reg_width(self):
        self.device_xml_parser = DeviceXmlParser(device_xml_file=self.squish_config.squish_config['dev_def_file'])
        self.register_class_dict = self.device_xml_parser.get_register_class_dict()
        self.reg_width = self.device_xml_parser.get_register_width()

    @staticmethod
    def calculate_expected_value(prev_reg_value, bit_field_val, reg_width, bit_field_addr):
        return BaseRegisterMap.calculate_expected_value(prev_reg_value, bit_field_val, reg_width, bit_field_addr)

    def verify_register_value_and_write_default_value(self, panel_bit_field_details, bit_field_value):
        if isinstance(bit_field_value, str) and "0x" in bit_field_value:
            bit_field_value = builtins.int(bit_field_value, 16)
        reg_exp_value = self.calculate_expected_value(panel_bit_field_details.RegisterDefault, bit_field_value,
                                                      panel_bit_field_details.RegWidth,
                                                      panel_bit_field_details.Address)
        expected_value = builtins.hex(builtins.int(reg_exp_value))
        expected_value = "".join([expected_value[0:2],
                                  expected_value[2:].rjust(builtins.int(panel_bit_field_details.RegWidth)/4, '0')])
        expected_value = expected_value.replace("L", "")
        self.verify_register_value(self.device_name, panel_bit_field_details.RegisterName, expected_value,
                                   reg_map_name=panel_bit_field_details.RegMapName)
        self.write_register_and_verify(self.device_name, panel_bit_field_details.RegisterName,
                                       panel_bit_field_details.RegisterDefault,
                                       reg_map_name=panel_bit_field_details.RegMapName, verify_reg=False)

    def open_panel_clear_history(self, panel=None, device_name=None):
        """
        Method to perform open panel and clear history steps
        """
        self.open_panel(panel, device_name)
        self.close_panel(panel)
        Common.clearHistory(self.sys_name)

    @staticmethod
    def get_history_row_data(row_number, sys_name,history_prop_type='text'):
        """
        Method to get specific row data from history table
        """
        history_rows = ReadActions.getNumberOfHistoryRows(sys_name)
        row_number = builtins.int(row_number)
        history_rows -= row_number
        value_in_table = ReadActions.readTextFromTable("Data", str(history_rows), "History",
                                                       history_prop_type=history_prop_type)
        return value_in_table

    def verify_slider(self, slider_name, slider_txt_field_real_name, slider_real_names, label_real_name=None,
                      out_of_range=False, slider_actions=None, verify_reserve_bits=True, panel=None,
                      device_name=None, unfriendly_slider_info=None):
        """
        Method to verify panel slider field and slider numeric field
        @param slider_name: [str] Slider bit field name
        @param slider_txt_field_real_name: [str] panel slider numeric field real name
        @param slider_real_names: [str] Slider real names(ex: slider knob and slider reserved)
        @param label_real_name: [str] Real name of label
        @param out_of_range: [boolean] False for positive tests, True for Negative tests.
        """
        slider_knob = 'slider_knob'
        slider_textbox = 'slider_textbox'
        empty_defaults = {"_".join([slider_knob, SLIDER_ATTRIBUTES.Start]): {},
                          "_".join([slider_knob, SLIDER_ATTRIBUTES.Mid]): {},
                          "_".join([slider_knob, SLIDER_ATTRIBUTES.End]): {},
                          "_".join([slider_textbox, SLIDER_ATTRIBUTES.Start]): {},
                          "_".join([slider_textbox, SLIDER_ATTRIBUTES.Mid]): {},
                          "_".join([slider_textbox, SLIDER_ATTRIBUTES.End]): {},
                          "_".join([slider_textbox, SLIDER_ATTRIBUTES.StartReserveBit]): {},
                          "_".join([slider_textbox, SLIDER_ATTRIBUTES.EndReserveBit]): {},
                          }
        overall_result = empty_defaults
        expected_results = empty_defaults
        slider_widget = self.bit_field_data[slider_name]
        test.log("slider_widget %s" % str(slider_widget))
        if not out_of_range:
            try:
                slider_start_value = builtins.int(slider_widget.Values[0][0][SLIDER_ATTRIBUTES.Start], 16)
                slider_end_value = builtins.int(slider_widget.Values[0][0][SLIDER_ATTRIBUTES.End], 16)
            except KeyError:
                slider_start_value = builtins.int(slider_widget.Values[0][0][SLIDER_ATTRIBUTES.Value], 16)
                slider_end_value = builtins.int(slider_widget.Values[-1][0][SLIDER_ATTRIBUTES.Value], 16)
            except IndexError:
                slider_start_value = slider_actions[0]
                slider_mid_value = slider_actions[1]
                slider_end_value = slider_actions[2]
                start_value = slider_start_value
                end_value = slider_end_value
            for value_list in slider_widget.Values:
                for value in value_list:
                    try:
                        start_value = builtins.int(value[SLIDER_ATTRIBUTES.Start], 16)
                        end_value = builtins.int(value[SLIDER_ATTRIBUTES.End], 16)
                        if start_value < slider_start_value:
                            slider_start_value = start_value
                        if end_value > slider_end_value:
                            slider_end_value = end_value
                    except KeyError:
                        pass
                    except IndexError:
                        pass
            if slider_actions is None:
                slider_mid_value = builtins.hex(abs(slider_end_value - slider_start_value) / 2)
                slider_start_value = builtins.hex(slider_start_value)
                slider_end_value = builtins.hex(slider_end_value)
            values_to_test = OrderedDict()

            values_to_test[SLIDER_ATTRIBUTES.End] = slider_end_value
            values_to_test[SLIDER_ATTRIBUTES.Start] = slider_start_value
            values_to_test[SLIDER_ATTRIBUTES.Mid] = slider_mid_value
            for range_key, value_to_test in values_to_test.items():
                # Get the register current value
                reg_current_val = self.read_register_value(self.device_name, slider_widget.RegisterName,
                                                           reg_map_name=slider_widget.RegMapName)
                self.open_panel(panel, device_name)
                if not self.set_slider_value(slider_real_names[0], range_key):
                    self.set_slider_value(slider_real_names[1], range_key)
                text_box_check = self._verify_slider_text_box(slider_txt_field_real_name,
                                                              value_to_test, slider_widget)
                if slider_widget.FieldType == BIT_FIELD_ATTR.Slider:
                    slider_label_val = self.get_expected_slider_label(slider_widget.Values, value_to_test)
                    if label_real_name and slider_actions is None:
                        label_check = self._verify_label(label_real_name, slider_label_val, slider_widget)
                        overall_result["_".join([slider_knob, range_key])]['label'] = label_check
                        expected_results["_".join([slider_knob, range_key])]['label'] = PASS_STEP
                    if slider_actions is not None:
                        slider_label_val = value_to_test
                else:
                    slider_label_val = None
                self.close_panel(panel)
                self.scroll_history_window(self.sys_name)
                history_regmap_results = self.check_slider(slider_name, slider_widget, reg_current_val,
                                                           value_to_test, slider_label=slider_label_val)
                overall_result["_".join([slider_knob, range_key])]['history_regmap'] = history_regmap_results
                expected_results["_".join([slider_knob, range_key])]['history_regmap'] = self.default_checks
                overall_result["_".join([slider_knob, range_key])]['text_box'] = text_box_check
                expected_results["_".join([slider_knob, range_key])]['text_box'] = PASS_STEP

            if verify_reserve_bits:
                bit_field_location = slider_widget.BitFieldLocation
                bit_width = self.get_bit_width(bit_field_location)
                min_val = 0
                max_val = (2 ** bit_width) - 1
                if start_value > min_val:
                    values_to_test[SLIDER_ATTRIBUTES.StartReserveBit] = builtins.hex(
                        builtins.int(slider_start_value, 16) - 1)
                if end_value < max_val:
                    values_to_test[SLIDER_ATTRIBUTES.EndReserveBit] = builtins.hex(
                        builtins.int(slider_end_value, 16) + 1)

            for range_key, value_to_test in values_to_test.items():
                # Get the register current value
                reg_current_val = self.read_register_value(self.device_name, slider_widget.RegisterName,
                                                           reg_map_name=slider_widget.RegMapName)
                self.open_panel(panel, device_name)
                if slider_widget.Values:
                    if range_key == SLIDER_ATTRIBUTES.Start and SLIDER_ATTRIBUTES.Position \
                            in list(slider_widget.Values[0][0].keys()):
                        break_loop = False
                        for value_list in slider_widget.Values:
                            for value in value_list:
                                try:
                                    if value[SLIDER_ATTRIBUTES.Position] == "1":
                                        value_to_test = value[SLIDER_ATTRIBUTES.Start]
                                        break_loop = True
                                        break
                                except (IndexError, KeyError):
                                    pass
                            if break_loop:
                                break
                InputActions.typeText(slider_txt_field_real_name, value_to_test)
                slider_label_val = self.get_expected_slider_label(slider_widget.Values, value_to_test)
                if label_real_name and slider_actions is None:
                    label_check = self._verify_label(label_real_name, slider_label_val, slider_widget)
                    overall_result["_".join([slider_textbox, range_key])]['label'] = label_check
                    expected_results["_".join([slider_textbox, range_key])]['label'] = PASS_STEP
                if unfriendly_slider_info:
                    for unfriendly_label_real_name, unfriendly_label_values in unfriendly_slider_info.items():
                        label_val = self.get_widget_value(unfriendly_label_real_name)
                        label_val = str(label_val)
                        label_val = str(re.search('\d+', str(label_val)).group())
                        label_check = label_val in unfriendly_label_values
                        self.assert_true(label_check, "Check if expected Unfriendly slider label is equal to real"
                                                      "value ")
                if slider_actions is not None:
                    slider_label_val = value_to_test
                # Verify slider widget value
                slider_widget_val = self.get_slider_value(slider_real_names[0])
                if slider_widget_val is None:
                    slider_widget_val = self.get_slider_value(slider_real_names[1])
                slider_knob_check = builtins.int(slider_widget_val) == builtins.int(value_to_test, 16)
                test.log("Slider widget %s knob check outcome:%s" % (slider_widget.Name, slider_knob_check))
                slider_knob_check = PASS_STEP if slider_knob_check else FAIL_STEP
                self.close_panel(panel)
                self.scroll_history_window(self.sys_name)
                history_regmap_results = self.check_slider(slider_name, slider_widget, reg_current_val, value_to_test,
                                                           slider_label=slider_label_val)
                overall_result["_".join([slider_textbox, range_key])]['history_regmap'] = history_regmap_results
                expected_results["_".join([slider_textbox, range_key])]['history_regmap'] = self.default_checks
                overall_result["_".join([slider_textbox, range_key])]['knob'] = slider_knob_check
                expected_results["_".join([slider_textbox, range_key])]['knob'] = PASS_STEP

            self.assert_equal(overall_result, expected_results,
                              "Check overall result for widget %s for bit field %s in "
                              "register %s" % (slider_widget.ModelName,
                                               slider_name,
                                               slider_widget.RegisterName))
        else:
            bit_field_location = slider_widget.BitFieldLocation
            bit_width = self.get_bit_width(bit_field_location)
            value_to_test = 2 ** bit_width
            warning_message = "Value needs to be between 0.0 and %.1f" % (value_to_test - 1)
            self.open_panel(panel, device_name)
            InputActions.typeText(slider_txt_field_real_name, value_to_test)
            self.check_warning_message(slider_txt_field_real_name, None, warning_message, check_warning_only=True)
            self.close_panel(panel)

    def get_expected_slider_label(self, values_list, value_written):
        value_written = builtins.int(value_written, 16)
        expected_slider_label = None
        for value_list in values_list:
            for value in value_list:
                if SLIDER_ATTRIBUTES.Start in list(value.keys()):
                    start_value = builtins.int(value[SLIDER_ATTRIBUTES.Start], 16)
                    end_value = builtins.int(value[SLIDER_ATTRIBUTES.End], 16)
                    if 'Description' in list(value.keys()) and start_value <= value_written <= end_value:
                        expected_slider_label = value[SLIDER_ATTRIBUTES.Description]
                    else:
                        try:
                            multiplier = builtins.float(value[SLIDER_ATTRIBUTES.Multiplier])
                            base = builtins.float(value[SLIDER_ATTRIBUTES.Base])
                            if start_value == value_written:
                                try:
                                    expected_slider_label = base
                                except ValueError:
                                    expected_slider_label = value['Base']
                            elif value_written == end_value:
                                expected_slider_label = ((end_value - start_value) * multiplier) + base
                                expected_slider_label = builtins.int(expected_slider_label)
                            elif start_value < value_written < end_value:
                                expected_slider_label = ((value_written - start_value) * multiplier) + base
                                expected_slider_label = builtins.int(expected_slider_label)
                        except KeyError:
                            pass
        if expected_slider_label is None:
            expected_slider_label = 'Reserved'
        if expected_slider_label == 0.0:
            expected_slider_label = 0
        return expected_slider_label

    def get_widget_value(self, widget_real_name):
        """
        Gets the widget model value

        :param widget_real_name: [string] real name for widget
        :return: Returns value of the widget
        """
        if object.exists(widget_real_name):
            return waitForObject(widget_real_name).model.value

    def verify_widget_is_enabled(self, widget_real_name, panel=None, device_name=None):
        """
        Verifies if the widget is enabled

        :param widget_real_name: [string] real name for widget
        :return: None
        """
        self.open_panel(panel_name=panel, device_name=device_name)
        status = ReadActions.checkIfiWidgetIsEnabled(widget_real_name)
        self.assert_true(status, "Check if widget is enabled")
        self.close_panel(panel_caption=panel)

    def verify_widget_is_disabled(self, widget_real_name, panel=None, device_name=None):
        """
        Verifies if the widget is disabled

        :param widget_real_name: [string] real name for widget
        :return: None
        """
        self.open_panel(panel_name=panel, device_name=device_name)
        status = ReadActions.checkIfiWidgetIsEnabled(widget_real_name, False)
        self.assert_true(status, "Check if widget is disabled")
        self.close_panel(panel_caption=panel)

    def _verify_slider_text_box(self, realname, val_to_test, slider_widget):
        """
        Verifies the Slider text box value with expected value

        :param realname: [string] Real name of the slider text box
        :param val_to_test: [string] value in hex format - Eg: '0x8'
        :return: None
        """
        slider_text_box_val = self.get_widget_value(realname)
        text_box_check = builtins.int(slider_text_box_val) == builtins.int(val_to_test, 16)
        test.log("Slider widget %s text box check outcome:%s" % (slider_widget.Name, text_box_check))
        text_box_check = PASS_STEP if text_box_check else FAIL_STEP
        return text_box_check

    def _verify_label(self, real_name, expected_value, slider_widget):
        """
        Verifies the label text with expected value

        :param real_name: [string] Real name of the label
        :return: None
        """
        label_val = self.get_widget_value(real_name)
        label_val = str(label_val)
        if isinstance(expected_value, int):
            label_val = str(re.search('\d+', str(label_val)).group())
        expected_value = str(expected_value)
        label_check = expected_value in label_val
        test.log("Slider widget %s label check outcome:%s" % (slider_widget.Name, label_check))
        label_check = PASS_STEP if label_check else FAIL_STEP
        return label_check

    def get_bit_width(self, bit_field_location):
        _bit_field_loc_match = re.search(r'\[(\d+(:\d+)?)\]', bit_field_location)
        bit_field_location = _bit_field_loc_match.group(1)
        if ':' in bit_field_location:
            bit_field_locations = [builtins.int(index) for index in bit_field_location.split(':')]
            bit_field_locations.sort()
            bit_width = (bit_field_locations[1] - bit_field_locations[0]) + 1
        else:
            bit_width = 1
        return bit_width

    def check_slider(self, slider_name, slider_widget, previous_reg_val, value_written, slider_label):
        export_srs = False
        register_data = slider_widget.RegisterData
        reg_exp_value = self.calculate_expected_value(str(previous_reg_val), value_written,
                                                      slider_widget.RegWidth,
                                                      slider_widget.Address)
        reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(slider_widget.RegWidth) / 4) + 2)
        if register_data.CommonRegisters:
            reg_exp_value = self.return_reg_value_in_bytes(reg_exp_value,
                                                           len(register_data.CommonRegisters))
            reg_exp_value = tuple(reg_exp_value)
            export_srs = True
        results = self.check_history_and_reg_map(slider_widget.RegMapName, slider_widget.RegisterName,
                                                 reg_exp_value, slider_name,
                                                 slider_widget.FieldType, str(value_written),
                                                 slider_label_value=slider_label, print_assertion=False,
                                                 reg_expected_value=reg_exp_value,
                                                 export_srs=export_srs)
        self.write_register_and_verify(self.device_name, slider_widget.RegisterName,
                                       slider_widget.RegisterDefault,
                                       reg_map_name=slider_widget.RegMapName, verify_reg=False)
        return results

    def verify_combo_box(self, combo_box_name, combo_box_real_name, num_of_values_to_test=5, combo_box_actions=None,
                         scroll_real_name=None, panel=None, device_name=None, verify_all_combo_box_actions=False):
        """
        This method sets required values in combo-box and verifyes them against expected values.
        It covers following scenarios:
           a. Verifies all possible values where combo box widget not having start and end attributes or
              values of combo box are less than num_of_values_to_test
           b. Verifies min, max and mid values of combo box if combo box widget having start and end attributes
              or values of combo box are more than "num_of_values_to_test"
        :param combo_box_name: [string] name of the bit field
        :param combo_box_real_name: [string] real name of the radio button w/o caption
        :param num_of_values_to_test: [integer] Number of values to be verified
        :return: None
        """
        overall_result = {}
        expected_results = {}
        export_srs = False
        combo_box = self.bit_field_data[combo_box_name]
        combo_values = combo_box.Values
        register_data=combo_box.RegisterData
        Common.clearHistory(self.sys_name)
        values_to_test = []
        combo_values_to_test = []
        combo_description_to_test = []
        description_to_test = []
        radio_values = ['0', '1']
        if combo_box_actions is not None:
            values_to_test = combo_box_actions
        else:
            for combo_value_list in combo_values:
                for combo_value in combo_value_list:
                    try:
                        start_value = combo_value[SLIDER_ATTRIBUTES.Start]
                        end_value = combo_value[SLIDER_ATTRIBUTES.End]
                        values_to_test.append(start_value)
                        #Check if multiple values are required to be verified on the attached bit field
                        #as some combo box items might represent just a range value instead of all the combo box values
                        if SLIDER_ATTRIBUTES.Base in combo_value:
                            base = eval(builtins.str(combo_value[SLIDER_ATTRIBUTES.Base]))
                            multiplier = eval(builtins.str(combo_value[SLIDER_ATTRIBUTES.Multiplier]))
                            mid_value = builtins.hex((builtins.int(end_value, 16) -
                                                         builtins.int(start_value, 16))/2)
                            values_to_test.append(mid_value)
                            values_to_test.append(end_value)
                            description_to_test = \
                                [builtins.int(val, 16) * multiplier + base for val in values_to_test]
                        else:
                            description_to_test.append(combo_value[SLIDER_ATTRIBUTES.Description])
                    except KeyError:
                        combo_values_to_test.append(combo_value[BIT_FIELD_ATTR.Value])
                        combo_description_to_test.append(combo_value[SLIDER_ATTRIBUTES.Description])
            if verify_all_combo_box_actions:
                values_to_test=combo_values_to_test
                description_to_test=combo_description_to_test
            elif len(combo_values_to_test) > num_of_values_to_test:
                mid_value = len(combo_values_to_test)/2
                values_to_test.append(combo_values_to_test[0])
                values_to_test.append(combo_values_to_test[mid_value])
                values_to_test.append(combo_values_to_test[-1])
                description_to_test.append(combo_description_to_test[0])
                description_to_test.append(combo_description_to_test[mid_value])
                description_to_test.append(combo_description_to_test[-1])
            elif len(combo_values_to_test) > 0:
                values_to_test = combo_values_to_test
                description_to_test = combo_description_to_test
            elif len(combo_values_to_test) < num_of_values_to_test:
                test.log('Invalid value given for num_of_values_to_test: %s' % num_of_values_to_test)
        if combo_box_actions:
            values_to_test = [index_values_to_test for index_values_to_test in enumerate(combo_box_actions)]
        else:
            values_to_test = [index_values_to_test for index_values_to_test in enumerate(values_to_test)]
        if register_data.CommonRegisters:
            export_srs=True
            cur_regs_value=OrderedDict()
            com_regs=register_data.CommonRegisters
            com_regs.reverse()
            for com_reg in com_regs:
                _reg_name=re.sub(r'\[.*\]', '', com_reg)
                cur_regs_value[_reg_name]=str(self.read_register_value(self.device_name,_reg_name))
        for index, value_to_test in values_to_test:
            combo_box = self.bit_field_data[combo_box_name]
            cur_reg_value = self.read_register_value(
                self.device_name, combo_box.RegisterName, reg_map_name=combo_box.RegMapName,)
            self.open_panel(panel_name=panel, device_name=device_name)
            if combo_box_actions:
                combo_box_element = str(combo_box_actions[index][1])
                value_to_test = combo_box_actions[index][0]
            else:
                combo_box_element = str(description_to_test[index])
            if scroll_real_name is not None:
                self.set_scroll_bar(scroll_real_name,1)
            return_val = Common.selectFromComboBox(combo_box_real_name, combo_box_element)
            self.close_panel(panel_caption=panel)
            if str(return_val) == 'option_not_found':
                continue
            reg_exp_value = self.calculate_expected_value(
                str(cur_reg_value), value_to_test, combo_box.RegWidth, combo_box.Address)
            reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(combo_box.RegWidth) / 4) + 2)
            if export_srs:
                cur_regs_value[combo_box.RegisterName]=str(reg_exp_value)
                reg_exp_value=tuple(builtins.hex(builtins.int(v,16))for v in list(cur_regs_value.values()))
            self.scroll_history_window(self.sys_name)
            if combo_box.FieldType == 'Radio Button':
                results = self.check_history_and_reg_map(combo_box.RegMapName, combo_box.RegisterName, reg_exp_value,
                                                         combo_box_name, combo_box.FieldType, str(radio_values[index]),
                                                         print_assertion=False,export_srs=export_srs)
            elif combo_box.FieldType == BIT_FIELD_ATTR.Value:
                results = self.check_history_and_reg_map(combo_box.RegMapName, combo_box.RegisterName, reg_exp_value,
                                                         combo_box_name, combo_box.FieldType, str(value_to_test),
                                                         print_assertion=False,export_srs=export_srs)
            else:

                if combo_box_actions and len(combo_box_actions[index]) == 3:
                    combo_box_element = str(combo_box_actions[index][2])
                    results = self.check_history_and_reg_map(combo_box.RegMapName, combo_box.RegisterName,
                                                             reg_exp_value, combo_box_name, combo_box.FieldType,
                                                             bitfield_expected=None,
                                                             reg_map_field_value=combo_box_element,
                                                             print_assertion=False,export_srs=export_srs)
                else:
                    results = self.check_history_and_reg_map(combo_box.RegMapName, combo_box.RegisterName,
                                                             reg_exp_value, combo_box_name, combo_box.FieldType,
                                                             combo_box_element, print_assertion=False,export_srs=export_srs)
            overall_result[combo_box_element] = results
            expected_results[combo_box_element] = self.default_checks
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (combo_box.ModelName,
                                                                             combo_box_name,
                                                                             combo_box.RegisterName))

    def combo_box_action(self, combo_box_name, combo_box_real_name, combo_option, radio_value='1', verify_reg=True,
                         panel=None, device_name=None):
        """
        This method sets given values in combo-box and verifies them against expected values.
        :param combo_box_name: [string] name of the bit field
        :param combo_box_real_name: [string] real name of the radio button w/o caption
        :param combo_option: [string] Combo box Option to set
        :param radio_value: [String] If regmap widget for combox is radio button, need to provide radio value
        :param verify_reg: [boolean] True for reg verification, False for no reg verification
        :return: None
        """
        overall_result = {}
        expected_results = {}
        Common.clearHistory(self.sys_name)
        self.open_panel(panel_name=panel, device_name=device_name)
        Common.selectFromComboBox(combo_box_real_name, combo_option)
        self.close_panel(panel_caption=panel)
        if verify_reg:
            combo_box = self.bit_field_data[combo_box_name]
            cur_reg_value = self.read_register_value(
                self.device_name, combo_box.RegisterName, reg_map_name=combo_box.RegMapName,)
            reg_exp_value = self.calculate_expected_value(
                str(cur_reg_value), str(radio_value), combo_box.RegWidth, combo_box.Address)
            reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(combo_box.RegWidth) / 4) + 2)
            self.scroll_history_window(self.sys_name)
            if combo_box.FieldType == 'Radio Button':
                results = self.check_history_and_reg_map(
                    combo_box.RegMapName, combo_box.RegisterName, reg_exp_value, combo_box_name, combo_box.FieldType,
                    str(radio_value), print_assertion=False)
            else:
                results = self.check_history_and_reg_map(combo_box.RegMapName, combo_box.RegisterName, reg_exp_value,
                                                         combo_box_name, combo_box.FieldType, str(combo_option),
                                                         print_assertion=False)

            overall_result[combo_option] = results
            expected_results[combo_option] = self.default_checks
            self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                                "register %s" % (combo_box.ModelName,
                                                                                 combo_box_name,
                                                                                 combo_box.RegisterName))

    def verify_radio_button(self, bit_field_name, real_name, actions=["Disabled", "Enabled"], exp_values=None,
                            scroll_real_name=None, panel=None, device_name=None):
        """
        Verifies Radio button enable disable actions.

        :param bit_field_name: [string] name of the bit field
        :param real_name: [string] real name of the radio button w/o caption
        :param actions: [list] Display names of radio buttons as list.
        :return: None
        """
        print_assertion = False
        overall_result = {}
        expected_results = {}
        self.open_panel_clear_history(panel, device_name)

        # The following if .. else is to flip the actions based on the radio button current/default state.
        # If the current/default state is disable and if you click on disable, nothing shows in history window, hence
        # we can't verify it, so this takes care of if current/default state is disable we start doing action with
        # enable and disable and if current/default state is enable, then we start with disable and enable operations.
        radio_btn = self.bit_field_data[bit_field_name]
        reg_current_val = self.read_register_value(self.device_name, radio_btn.RegisterName,
                                                   reg_map_name=radio_btn.RegMapName)
        if len(actions) == 2:
            if builtins.int(reg_current_val, 16) == 0x0 or radio_btn.DefaultValue == "0x0":
                actions = list(reversed(actions))
                values = ["1", "0"]
            else:
                values = ["0", "1"]
        elif len(actions) > 2:
            values = []
            for i in list(range(0, len(actions))):
                values.append(builtins.str(i))
            if radio_btn.DefaultValue == "0x0":
                values = list(reversed(values))
                actions = list(reversed(actions))
        for action, value in zip(actions, values):
            radio_btn_real_name = "{caption?='%s*' %s" % (action, real_name)
            # Get the register current value
            reg_current_val = self.read_register_value(self.device_name, radio_btn.RegisterName,
                                     reg_map_name=radio_btn.RegMapName)
            Common.clearHistory(self.sys_name)
            self.open_panel(panel, device_name)
            if scroll_real_name is not None:
                self.set_scroll_bar(scroll_real_name, 1)
            InputActions.mouseClickOnItem(radio_btn_real_name)
            self.close_panel(panel)
            reg_exp_value = self.calculate_expected_value(str(reg_current_val), value,
                                                          radio_btn.RegWidth,
                                                          radio_btn.Address)
            test.log("Register Value after writing: %s" % reg_exp_value)
            reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(radio_btn.RegWidth)/ 4) + 2)
            if len(actions) > 2:
                if exp_values is not None:
                    action = exp_values[builtins.int(value)]
                results = self.check_history_and_reg_map(radio_btn.RegMapName, radio_btn.RegisterName,
                                                         reg_exp_value, bit_field_name,
                                                         radio_btn.FieldType, action, print_assertion=print_assertion)
            else:
                results = self.check_history_and_reg_map(radio_btn.RegMapName, radio_btn.RegisterName,
                                                         reg_exp_value, bit_field_name,
                                                         radio_btn.FieldType, value, print_assertion=print_assertion)
            overall_result[action] = results
            expected_results[action] = self.default_checks
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (radio_btn.ModelName,
                                                                             bit_field_name,
                                                                             radio_btn.RegisterName))

    def radio_btn_action(self, bit_field_name, real_name, action="Enabled", enable=True):
        """
        Click the desired radio button and verifies it.

        :param bit_field_name: [string] name of the bit field
        :param real_name: [string] real name of the radio button w/o caption
        :param action: [string] Radio button action name
        :param enable: is enable radio button
        :return: None
        """
        radio_btn = self.bit_field_data[bit_field_name]
        default_value = radio_btn.DefaultValue

        def click_radio_btn(value):
            radio_btn_real_name = "{caption='%s' %s" % (action, real_name)
            # Get the register current value
            reg_current_val = self.read_register_value(self.device_name, radio_btn.RegisterName,
                                                       reg_map_name=radio_btn.RegMapName)
            Common.clearHistory(self.sys_name)
            self.open_panel()
            InputActions.mouseClickOnItem(radio_btn_real_name)
            self.close_panel()

            reg_exp_value = self.calculate_expected_value(str(reg_current_val), value,
                                                          radio_btn.RegWidth,
                                                          radio_btn.Address)
            reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(radio_btn.RegWidth) / 4) + 2)
            self.check_history_and_reg_map(radio_btn.RegMapName, radio_btn.RegisterName,
                                           reg_exp_value, bit_field_name,
                                           radio_btn.FieldType, value)
        if enable:
            if default_value == "0x0":
                click_radio_btn("1")
            else:
                test.log("Radio button is already enabled.")
        else:
            if default_value == "0x0":
                test.log("Radio button is already disabled.")
            else:
                click_radio_btn("0")

    def verify_release_button(self, release_btn_name, real_name, panel=None, device_name=None,
                              close_panel_real_name=None):
        """
        Verify Release Button functionality.

        :param release_btn_name: [string] realese button bit field name
        :param real_name: [string] Real name of release button.
        :return: None
        """
        release_btn = self.bit_field_data[release_btn_name]
        release_btn_default_val = str(builtins.int(release_btn.DefaultValue, 16))
        release_btn_vals = release_btn.Values
        release_btn_second_val = str(builtins.int(release_btn_vals[1][0][BIT_FIELD_ATTR.Value], 16))
        history_row_from_end = 2

        # Get the register current value
        reg_current_val = self.read_register_value(self.device_name, release_btn.RegisterName,
                                                   reg_map_name=release_btn.RegMapName)
        self.open_panel(panel, device_name)
        InputActions.mouseClickOnItem(real_name)
        if close_panel_real_name:
            InputActions.mouseClickOnItem(close_panel_real_name)
        else:
            self.close_panel(panel)
        reg_exp_value = self.calculate_expected_value(str(reg_current_val), release_btn_second_val,
                                                      release_btn.RegWidth,
                                                      release_btn.Address)
        reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(release_btn.RegWidth) / 4) + 2)

        # Check the last but one row value in History window. This is to check the enabled case, we can't
        # verify this in RegMap because the bit field quickly went to enable and then disable state.
        # also the history window has to scroll and it takes a second to update data rows (hence the snooze)
        # and sometimes it just returns a '<null>' value instead of the requested Data value
        self.scroll_history_window(self.sys_name)
        retries = 3
        for retry in list(range(retries)):
            last_but_one_row_val = self.get_history_row_data(history_row_from_end, self.sys_name,
                                                             self.history_prop_type)
            snooze(0.2)
            if '<null>' not in last_but_one_row_val:
                break
        self.assert_equal(builtins.int(last_but_one_row_val, 16), builtins.int(reg_exp_value, 16),
                          "Check register value only in History Table")

        # Get the register current value
        reg_current_val = self.read_register_value(self.device_name, release_btn.RegisterName,
                                                   reg_map_name=release_btn.RegMapName)
        reg_exp_value = self.calculate_expected_value(str(reg_current_val), release_btn_default_val,
                                                      release_btn.RegWidth,
                                                      release_btn.Address)
        reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(release_btn.RegWidth) / 4) + 2)
        self.scroll_history_window(self.sys_name)
        self.check_history_and_reg_map(release_btn.RegMapName, release_btn.RegisterName,
                                       reg_exp_value, release_btn_name,
                                       release_btn.FieldType, release_btn_default_val)

    def verify_check_box(self, check_box_name, check_box_real_name, panel=None, device_name=None,
                         scroll_real_name=None):
        print_assertion = False
        overall_result = {}
        expected_results = {}
        export_srs = False
        check_box = self.bit_field_data[check_box_name]
        register_data=check_box.RegisterData
        if register_data.CommonRegisters:
            export_srs=True
            cur_regs_value=OrderedDict()
            com_regs=register_data.CommonRegisters
            com_regs.reverse()
            for com_reg in com_regs:
                _reg_name=re.sub(r'\[.*\]', '', com_reg)
                cur_regs_value[_reg_name]=str(self.read_register_value(self.device_name,_reg_name))
        for check_action in ["check", "uncheck"]:
            Common.clearHistory(self.sys_name)
            self.open_panel(panel, device_name)
            if self.get_check_box_state(check_box_real_name):
                value = "0"
            else:
                value = "1"

            # Get the register current value
            reg_current_val = self.read_register_value(self.device_name, check_box.RegisterName,
                                                       reg_map_name=check_box.RegMapName)
            self.open_panel(panel, device_name)
            if scroll_real_name is not None:
                self.set_scroll_bar(scroll_real_name, 1)
            InputActions.mouseClickOnItem(check_box_real_name)
            self.close_panel(panel)

            reg_exp_value = self.calculate_expected_value(str(reg_current_val), value,
                                                          check_box.RegWidth,
                                                          check_box.Address)
            reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(check_box.RegWidth) / 4) + 2)
            if export_srs:
                cur_regs_value[check_box.RegisterName]=str(reg_exp_value)
                reg_exp_value=tuple(builtins.hex(builtins.int(v,16))for v in list(cur_regs_value.values()))
            results = self.check_history_and_reg_map(check_box.RegMapName, check_box.RegisterName,
                                                     reg_exp_value, check_box_name,
                                                     check_box.FieldType, value,
                                                     print_assertion=print_assertion,export_srs=export_srs)
            overall_result[check_action] = results
            expected_results[check_action] = self.default_checks
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (check_box.ModelName,
                                                                             check_box_name,
                                                                             check_box.RegisterName))

    def check_box_enable_disable(self, check_box_name, check_box_real_name, enable=True, close_panel_real_name=None,
                                 scroll_real_name=None):
        """
        This method is to check or un-check the checkbox as per the enable option
        :param check_box_name: [string] check box bit field name
        :param check_box_real_name: [string] check box real name
        :param enable: True -> Check, False -> Un-check
        :return: None
        """
        check_box = self.bit_field_data[check_box_name]
        self.open_panel()
        if scroll_real_name is not None:
            self.set_scroll_bar(scroll_real_name, 1)
        check_box_state = self.get_check_box_state(check_box_real_name)
        test.log("check_box_state: %s" % check_box_state)

        def click_check_box(value):
            # Get the register current value
            reg_current_val = self.read_register_value(self.device_name, check_box.RegisterName,
                                                       reg_map_name=check_box.RegMapName)
            Common.clearHistory(self.sys_name)
            self.open_panel()
            if scroll_real_name is not None:
                self.set_scroll_bar(scroll_real_name, 1)
            InputActions.mouseClickOnItem(check_box_real_name)
            if close_panel_real_name:
                InputActions.mouseClickOnItem(close_panel_real_name)
            else:
                self.close_panel()

            reg_exp_value = self.calculate_expected_value(str(reg_current_val), value,
                                                          check_box.RegWidth,
                                                          check_box.Address)
            reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(check_box.RegWidth) / 4) + 2)
            self.scroll_history_window(self.sys_name)
            self.check_history_and_reg_map(check_box.RegMapName, check_box.RegisterName,
                                           reg_exp_value, check_box_name,
                                           check_box.FieldType, value)

        if enable:
            if check_box_state:
                test.log("Checkbox is already enabled.")
            else:
                click_check_box("1")
        else:
            if check_box_state:
                click_check_box("0")
            else:
                test.log("Checkbox is already disabled.")

    @staticmethod
    def get_check_box_state(check_box):
        check_box_state = None
        try:
            check_box_state = waitForObject(check_box).model.value
        except AttributeError:
            check_box_state = waitForObject(check_box).parent.model.value
        return check_box_state

    @staticmethod
    def get_button_state(button):
        button_state = waitForObject(button).value
        return button_state

    def check_radio_button_state(self, radio_button, enabled=True, open_close_panel=False):
        radio_btn_real_name = "{%s" % (radio_button)
        if open_close_panel:
            self.open_panel()
            radio_btn_state = waitForObject(radio_btn_real_name).selected
            self.close_panel()
        else:
            radio_btn_state = waitForObject(radio_btn_real_name).selected
        radio_btn_state = enabled and radio_btn_state
        return radio_btn_state

    def verify_text_field(self, text_field_name, text_field_real_name, values_to_write=None, out_of_range=True,
                          scroll_real_name=None, panel=None, device_name=None, warning_message=None):
        """
        Verifies the numeric text field.

        :param text_field_name: [string] text bit field name
        :param text_field_real_name: [string] text field real name
        :param values_to_write: values to write to text box, if not given it tests for
                                bit field min, mid, max, out of range and invalid string values.
        :param out_of_range: True for out of range otherwise False.
        :param scroll_real_name: [string] scroll bar real name
        :param panel: [string] panel name
        :param device_name: [string] device name
        :param warning_message: [string] warning message template eg: "Value needs to be between 0 and %s"
        :return: None
        """
        overall_result = {}
        expected_results = {}
        invalid_values = list()
        valid_values = list()
        values_to_write_dict = {}
        export_srs = False
        text_field_widget = self.bit_field_data[text_field_name]
        bit_field_location = text_field_widget.Address
        register_data = text_field_widget.RegisterData
        bit_field_length = self.get_bit_width(bit_field_location)
        if values_to_write is None:
            min_value = 0
            max_value = builtins.int(2 ** bit_field_length) - 1
            # TODO It couldn't write 0, so just writing 1
            valid_values.append(builtins.int((max_value - min_value) / 2))
            valid_values.append(max_value)
            valid_values.append(1)
            values_to_write_dict['valid_inputs'] = valid_values
            if out_of_range:
                bit_width = self.get_bit_width(text_field_widget.Address)
                values = 2 ** bit_width
                invalid_values.append(values)
                invalid_values.append(-1)
                values_to_write_dict['invalid_inputs'] = invalid_values
                if warning_message:
                    warning_message = warning_message % (values - 1)
                else:
                    warning_message = "Value needs to be between 0.0 and %s.0" % (values - 1)
        else:
            if builtins.type(values_to_write) is list or builtins.type(values_to_write) is tuple:
                values_to_write_dict['valid_inputs'] = values_to_write
            else:
                values_to_write_dict = values_to_write
        for values_key, write_values in values_to_write_dict.items():
            for value_to_write in write_values:
                prev_register_val = self.read_register_value(self.device_name, text_field_widget.RegisterName,
                                                             reg_map_name=text_field_widget.RegMapName)

                self.open_panel(panel, device_name)
                if scroll_real_name is not None:
                    self.set_scroll_bar(scroll_real_name,1)
                InputActions.typeText(text_field_real_name, value_to_write)
                if values_key is 'valid_inputs':
                    self.close_panel(panel)
                    reg_exp_value = self.calculate_expected_value(str(prev_register_val), value_to_write,
                                                                  text_field_widget.RegWidth,
                                                                  text_field_widget.BitFieldLocation)
                    # Convert to value_to_write to hex format
                    width = bit_field_length % 4
                    bitfield_hex_width = bit_field_length / 4
                    if width:
                        bitfield_hex_width += 1
                    value_to_write = "{0:#0{1}x}".format(value_to_write, bitfield_hex_width + 2)
                    reg_exp_value = "{0:#0{1}x}".format(reg_exp_value,
                                                        (builtins.int(text_field_widget.RegWidth) / 4) + 2)
                    if register_data.CommonRegisters:
                        reg_exp_value = self.return_reg_value_in_bytes(reg_exp_value,
                                                                       len(register_data.CommonRegisters))
                        reg_exp_value = tuple(reg_exp_value)
                        export_srs = True
                    self.scroll_history_window(self.sys_name)
                    results = []
                    if text_field_widget.FieldType == REG_MAP_FIELD_TYPE.TextField:
                        results = self.check_history_and_reg_map(text_field_widget.RegMapName,
                                                                 text_field_widget.RegisterName,
                                                                 reg_exp_value, text_field_name,
                                                                 text_field_widget.FieldType, value_to_write,
                                                                 value_to_write, print_assertion=False,
                                                                 export_srs=export_srs)
                    elif text_field_widget.FieldType == REG_MAP_FIELD_TYPE.Slider:
                        slider_label = self.get_expected_slider_label(text_field_widget.Values, value_to_write)
                        results = self.check_history_and_reg_map(text_field_widget.RegMapName,
                                                                 text_field_widget.RegisterName,
                                                                 reg_exp_value, text_field_name,
                                                                 text_field_widget.FieldType,
                                                                 value_to_write, slider_label,
                                                                 print_assertion=False)
                else:
                    results = self.check_warning_message(text_field_real_name, None, warning_message,
                                                         check_warning_only=True,
                                                         print_assertion=False, time_to_wait=3)
                    self.close_panel(panel)
                overall_result[value_to_write] = results
                if values_key is 'valid_inputs':
                    expected_results[value_to_write] = self.default_checks
                else:
                    expected_results[value_to_write] = {REG_MAP: PASS_STEP}
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (text_field_widget.ModelName,
                                                                             text_field_name,
                                                                             text_field_widget.RegisterName))

    @staticmethod
    def return_reg_value_in_bytes(reg_hex_value, number_of_registers):
        reg_hex_value = builtins.int(reg_hex_value, 16)
        reg_hex_value = builtins.hex(reg_hex_value)
        reg_val_in_bytes = []
        while len(reg_hex_value) > 3:
            reg_val_in_bytes.append('0x' + reg_hex_value[-2:])
            reg_hex_value = reg_hex_value[:-2]
        if reg_hex_value != '0x':
            reg_val_in_bytes.append(reg_hex_value)
        while len(reg_val_in_bytes) != number_of_registers:
            reg_val_in_bytes.append('0x0')
        return reg_val_in_bytes

    def set_slider_value(self, slider_real_name, range_key):
        """
        Move slider nob to new position
        @param slider_real_name: Slider real name
        @param range_key: slider value to move
        """
        status = False
        try:
            if object.exists(slider_real_name):
                max_v = waitForObject(slider_real_name).styleableparent.styleableparent.styleableparent.model.maxvalue
                min_v = waitForObject(slider_real_name).styleableparent.styleableparent.styleableparent.model.minvalue
                if SLIDER_ATTRIBUTES.Start == range_key:
                    waitForObject(slider_real_name).styleableparent.styleableparent.styleableparent.model.value = min_v
                elif SLIDER_ATTRIBUTES.End == range_key:
                    waitForObject(slider_real_name).styleableparent.styleableparent.styleableparent.model.value = max_v
                elif SLIDER_ATTRIBUTES.Mid == range_key:
                    if min_v > 0:
                        mid_v = (max_v - min_v) / 2
                    else:
                        mid_v = - ((max_v - min_v) / 2) + max_v
                    waitForObject(slider_real_name).styleableparent.styleableparent.styleableparent.model.value = mid_v
        except LookupError:
            test.fail("FAIL", "Cannot set %s value to slider %s" % (range_key, slider_real_name))
        return status

    def get_slider_value(self, slider_real_name):
        """
        Gets the slider widget value

        :param slider_real_name: [string] slider real value
        :return: Returns the slider value.
        """
        try:
            if object.exists(slider_real_name):
                return waitForObject(slider_real_name).styleableparent.styleableparent.styleableparent.model.value
        except LookupError:
            test.fail("FAIL", "Cannot get value to slider %s" % slider_real_name)

    def set_scroll_bar(self, scroll_bar, val):
        try:
            if 'increment-button' in scroll_bar:
                reattempt = builtins.int(waitForObject(scroll_bar).width)
                while reattempt > 0:
                    if object.exists(scroll_bar):
                        InputActions.mouseClickOnItem(scroll_bar)
                    else:
                        test.log("Scroll_bar_real_name not found")
                    reattempt -= 1
            else:
                if object.exists(scroll_bar):
                    setValue(waitForObject(scroll_bar), val)
        except LookupError:
            test.log("FAIL", "Scroll bar is not found")

    def toggle_button_action(self, toggle_name, toggle_real_names=[], toggle_action="Enabled"):
        print_assertion = False
        overall_result = {}
        expected_results = {}
        self.open_panel_clear_history()
        toggle_button = self.bit_field_data[toggle_name]
        reg_current_val = self.read_register_value(self.device_name, toggle_button.RegisterName,
                                       reg_map_name=toggle_button.RegMapName)
        self.open_panel()
        for toggle_real_name in toggle_real_names:
            if object.exists(toggle_real_name):
                if 'button-on' in toggle_real_name:
                    radio_value = '0'
                else:
                    radio_value = '1'
                try:
                    InputActions.mouseClickOnItem(waitForObject(toggle_real_name))
                    self.close_panel()
                    reg_exp_value = self.calculate_expected_value(str(reg_current_val), radio_value,
                                                                  toggle_button.RegWidth,
                                                                  toggle_button.Address)
                    reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(toggle_button.RegWidth)/ 4) + 2)
                    self.scroll_history_window(self.sys_name)
                    results = self.check_history_and_reg_map(toggle_button.RegMapName, toggle_button.RegisterName,
                                                             reg_exp_value, toggle_name,
                                                             toggle_button.FieldType, radio_value,
                                                             print_assertion=print_assertion)
                    overall_result[toggle_action] = results
                    expected_results[toggle_action] = self.default_checks
                except LookupError:
                    test.log("FAIL", "Toggle button is not found")
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (toggle_button.ModelName,
                                                                             toggle_name,
                                                                             toggle_button.RegisterName))

    def verify_toggle_button(self, toggle_name, toggle_real_names=[], toggle_actions=["Disabled", "Enabled"]):
        print_assertion = False
        overall_result = {}
        expected_results = {}
        self.open_panel_clear_history()
        toggle_button = self.bit_field_data[toggle_name]
        radio_values = ['1', '0']
        for toggle_action, value in zip(toggle_actions, radio_values):
            reg_current_val = self.read_register_value(self.device_name, toggle_button.RegisterName,
                                                       reg_map_name=toggle_button.RegMapName)
            self.open_panel()
            for toggle_real_name in toggle_real_names:
                if object.exists(toggle_real_name):
                    try:
                        InputActions.mouseClickOnItem(waitForObject(toggle_real_name))
                        self.close_panel()
                        reg_exp_value = self.calculate_expected_value(str(reg_current_val), value,
                                                                      toggle_button.RegWidth,
                                                                      toggle_button.Address)
                        test.log("Register Value after writing: %s" % reg_exp_value)
                        reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(toggle_button.RegWidth)/ 4)
                                                            + 2)
                        self.scroll_history_window(self.sys_name)
                        results = self.check_history_and_reg_map(toggle_button.RegMapName, toggle_button.RegisterName,
                                                                 reg_exp_value, toggle_name,
                                                                 toggle_button.FieldType, value,
                                                                 print_assertion=print_assertion)
                        overall_result[toggle_action] = results
                        expected_results[toggle_action] = self.default_checks
                    except LookupError:
                        test.log("FAIL", "Toggle button is not found")
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (toggle_button.ModelName,
                                                                             toggle_name,
                                                                             toggle_button.RegisterName))

    def verify_combo_box_options(self, combo_real_name, combo_options=[]):
        self.open_panel()
        comboBox = waitForObject(combo_real_name)
        options = comboBox.model.members
        ops_flag = True
        list_of_options = (str(options))[1:-1].split(", ")
        if combo_options is not []:
            if len(list_of_options) == len(combo_options):
                for list_option in list_of_options:
                    if list_option not in combo_options:
                        ops_flag = False
                        break
            else:
                ops_flag = False
        self.close_panel()
        self.assert_true(ops_flag, "Check if expected combo options matches with available options")

    def click_button_and_check_for_rounded_button(self, bit_field_name, button_real_name,
                                                  rounded_button_real_name, enable_rounded_button,
                                                  exp_rounded_button_color_code,
                                                  panel_name=None, device_name=None, get_last_row=True):
        """
        Method to click on a button and check button state indicated by corresponding rounded button

        @param bit_field_name: [str] Corresponding button bit field name
        @param button_real_name: [str] button real name
        @param rounded_button_real_name: [str] rounded button real name
        @param enable_rounded_button: [bool] Indicated whether button must be set to enable or not
        @param exp_rounded_button_color_code: [<str>] Expected Model.color property value of the widget
        @param panel_name: [str] panel name
        @param device_name: [str] device name/folder as appeared in navigator
        @param get_last_row: [bool] check last row in history
        """
        print_assertion = False
        overall_result = {}
        expected_results = {}
        bit_field = self.bit_field_data[bit_field_name]
        reg_current_val = self.read_register_value(self.device_name, bit_field.RegisterName,
                                                   reg_map_name=bit_field.RegMapName)
        self.open_panel(panel_name, device_name)
        if LooseVersion(scs_version) > LooseVersion("1.5"):
            rounded_btn_color = str(waitForObject(rounded_button_real_name).model.color.displayablenamedark)
        else:
            rounded_btn_color = str(waitForObject(rounded_button_real_name).model.color)
        if rounded_btn_color != exp_rounded_button_color_code:
            if enable_rounded_button:
                InputActions.mouseClickOnItem(button_real_name)
                bit_field_value = '0x1'
            else:
                InputActions.mouseClickOnItem(button_real_name)
                bit_field_value = '0x0'
            if LooseVersion(scs_version) > LooseVersion("1.5"):
                current_btn_color = str(waitForObject(rounded_button_real_name).model.color.displayablenamedark)
            else:
                current_btn_color = str(waitForObject(rounded_button_real_name).model.color)
        else:
            current_btn_color = rounded_btn_color
            bit_field_value = '0x1' if enable_rounded_button else '0x0'
        self.close_panel(panel_name)
        reg_exp_value = self.calculate_expected_value(str(reg_current_val), bit_field_value,
                                                      bit_field.RegWidth,
                                                      bit_field.Address)
        reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(bit_field.RegWidth) / 4)
                                            + 2)
        results = self.check_history_and_reg_map(bit_field.RegMapName, bit_field.RegisterName,
                                                 reg_exp_value, bit_field_name,
                                                 bit_field.FieldType, bit_field_value,
                                                 print_assertion=print_assertion, get_last_row=get_last_row)
        overall_result[bit_field_name] = results
        expected_results[bit_field_name] = self.default_checks
        overall_result[bit_field_name]['rounded_btn_color'] = current_btn_color
        expected_results[bit_field_name]['rounded_btn_color'] = exp_rounded_button_color_code
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (bit_field.ModelName,
                                                                             bit_field_name,
                                                                             bit_field.RegisterName))

    def verify_button_and_rounded_button(self, bit_field_name, button_real_name, rounded_button_real_name,
                                         rounded_button_default_state, rounded_btn_states_with_colors,
                                         panel_name=None, device_name=None, get_last_row=True):
        """
        Method to verify button and associated rounded button indicating button state

        @param bit_field_name: [str] Corresponding button bit field name
        @param button_real_name: [str] button real name
        @param rounded_button_real_name: [str] rounded button real name
        @param rounded_button_default_state: [bool] Default state of rounded button
        @param rounded_btn_states_with_colors: [dict] Key: button state, Value: Model.color property value of the widget
        @param panel_name: [str] panel name
        @param device_name: [str] device name/folder as appeared in navigator
        @param get_last_row: [bool] check last row in history
        """
        non_default_state = not rounded_button_default_state
        self.click_button_and_check_for_rounded_button(bit_field_name, button_real_name, rounded_button_real_name,
                                                       non_default_state,
                                                       rounded_btn_states_with_colors[non_default_state],
                                                       panel_name, device_name, get_last_row)
        self.click_button_and_check_for_rounded_button(bit_field_name, button_real_name, rounded_button_real_name,
                                                       rounded_button_default_state,
                                                       rounded_btn_states_with_colors[rounded_button_default_state],
                                                       panel_name, device_name, get_last_row)

    def verify_button(self, bit_field_name, button_real_name, bit_field_value=None, scroll_real_name=None, panel=None,
                      device_name=None, close_panel_real_name=None):
        """
        Verify Button functionality.
        :param bit_field_name: [string] name of the bit field
        :param button_real_name: [string] real name of the button
        :param bit_field_value: bit field value
        :param scroll_real_name: [string] real name of scroll
        :param panel: [string] panel name
        :param device_name: [string] device name
        :param close_panel_real_name: real name of close panel
        """
        print_assertion = False
        self.open_panel_clear_history(panel, device_name)
        button = self.bit_field_data[bit_field_name]
        if bit_field_value is None:
            btn_vals = button.Values
            bit_field_value = str(builtins.int(btn_vals[1][0][BIT_FIELD_ATTR.Value], 16))
        # Get the register current value
        reg_current_val = self.read_register_value(self.device_name, button.RegisterName,
                                                   reg_map_name=button.RegMapName)
        Common.clearHistory(self.sys_name)
        self.open_panel(panel, device_name)
        if scroll_real_name is not None:
            self.set_scroll_bar(scroll_real_name, 1)
        InputActions.mouseClickOnItem(button_real_name)
        if close_panel_real_name:
            InputActions.mouseClickOnItem(close_panel_real_name)
        else:
            self.close_panel(panel)
        reg_exp_value = self.calculate_expected_value(str(reg_current_val), bit_field_value,
                                                      button.RegWidth,
                                                      button.Address)
        test.log("Register Value after writing: %s" % reg_exp_value)
        reg_exp_value = "{0:#0{1}x}".format(reg_exp_value, (builtins.int(button.RegWidth) / 4) + 2)
        results = self.check_history_and_reg_map(button.RegMapName, button.RegisterName,
                                                 reg_exp_value, bit_field_name,
                                                 button.FieldType, bit_field_value, print_assertion=print_assertion)
        overall_result = results
        expected_results = self.default_checks
        self.assert_equal(overall_result, expected_results, "Check overall result for widget %s for bit field %s in "
                                                            "register %s" % (button.ModelName,
                                                                             bit_field_name,
                                                                             button.RegisterName))
