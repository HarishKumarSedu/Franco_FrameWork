"""
Module to parser device definition xml file
"""
import builtins
import sys
import xmltodict
import json
import re
import copy

from lxml import etree
from collections import OrderedDict
if sys.version_info[0] == 2:
    import importlib



class ElementNotFoundException(Exception):
    """
    Exception class if requested element is not found in the XML
    """

    def __init__(self, message):
        super(ElementNotFoundException, self).__init__(message)


class BitFieldTypeError(Exception):
    """
    Exception class for bit field type
    """

    def __init__(self, message=None):
        super(BitFieldTypeError, self).__init__(message)


class Register:
    """
    Class for Device Registers
    """

    def __init__(self, name, display_name, address, default_value, access, bit_fields):
        self.set_attribute('Name', name)
        self.set_attribute('DisplayName', display_name)
        self.set_attribute('Address', address)
        self.set_attribute('DefaultValue', default_value)
        self.set_attribute('Access', access)
        self.set_attribute('CommonRegisters', None)
        self.set_attribute('BitFields', bit_fields)

    def set_attribute(self, attr_name, attr_value):
        setattr(self, attr_name, attr_value)

    def __str__(self):
        bit_fields_str = ""
        for bit_field in self.BitFields:
            bit_fields_str += str(bit_field) + ", "
        return "Address: %s, Def val: %s, Access: %s, Bit Fields: %s" \
               % (self.Address, self.DefaultValue,
                  self.Access, bit_fields_str)

    def __getitem__(self, reg_item):
        return self[reg_item]


class BitField:
    """
    Class for Device Bit fields
    """
    def __init__(self, field_name, default_value, access, address, field_description, software_access, values=[],
                 units=None,
                 in_registers=[]):
        self.set_attribute('Address', address)
        self.set_attribute('RegisterName', address.split('[')[0])
        self.set_attribute('DefaultValue', default_value)
        self.set_attribute('Access', access)
        self.set_attribute('SoftwareAccess', software_access)
        self.set_attribute('Name', field_name)
        self.set_attribute('Values', values)
        self.set_attribute('Units', values)
        self.set_attribute('Description', field_description)
        self.set_attribute('InRegisters', in_registers)
        self.set_attribute('BitFieldLocation', re.search(r'(\[.*\])', address).group(1))
        if values:
            self.set_attribute('FieldType', self.get_field_type(address, values))
        else:
            self.set_attribute('FieldType', 'text_field')
        tmp_values = []
        for value in self.Values:
            tmp_dict = {}
            for values_dict in value:
                for key, val in values_dict.items():
                    tmp_dict[key] = val
            if tmp_dict != {}:
                tmp_values.append([tmp_dict])
        self.Values = tmp_values

    def set_attribute(self, attr_name, attr_value):
        setattr(self, attr_name, attr_value)

    def __str__(self):
        self.Values = [str(val) for val in self.Values if val is not None]
        if not self.Values:
            return "Field Name : %s, Def Val: %s, Access: %s, Address: %s, FieldType: %s" % (
                self.Name, self.DefaultValue, self.Access, self.Address, self.FieldType)
        else:
            return "Field Name : %s, Def Val: %s, Access: %s, Address: %s, FieldType: %s," \
                   " Values: %s" % (self.Name, self.DefaultValue, self.Access,
                                    self.Address, self.FieldType, self.Values)

    @staticmethod
    def get_field_type(address, values):
        """
        Gets the type of BitField(Can be RadioButton, ComboBox, TextField, Slider)

        @param address: [str] address of bit field
        @param values: [list] values list of bit field
        @return: [str] type of bit field(Can be RadioButton, ComboBox, TextField, Slider)
        """
        bit_width_pattern = re.search('\[(\d+):?(\d+)?\]', address)
        try:
            bit_width = builtins.int(bit_width_pattern.group(1)) - builtins.int(bit_width_pattern.group(2))
        except TypeError:
            bit_width = builtins.int(bit_width_pattern.group(1))
        if bit_width == 0:
            bit_width = 1
        num_of_values = len(values)
        if num_of_values == 2:
            attributes = [attr_key for val in values[0] for attr_key in list(val.keys())]
            if all(i in attributes for i in ['End', 'Start', 'Multiplier']):
                bit_type = 'slider'
            else:
                bit_type = 'radio_button'
        elif bit_width >= 1 and num_of_values > 2:
            is_slider_checks = []
            is_slider = False
            for value in values:
                for value_dict in value:
                    value_keys = list(value_dict.keys())
                    value_keys.sort()
                    if cmp(['End', 'Start'], value_keys) == 0 or cmp(['End', 'Position', 'Start'], value_keys) == 0 or \
                            cmp(['Position', 'Value'], value_keys) == 0:
                        is_slider = True
                is_slider_checks.append(is_slider)
            if all(is_slider_checks):
                bit_type = 'slider'
            else:
                bit_type = 'combo_box'
        elif num_of_values == 1:
            attributes = [attr_key for val in values[0] for attr_key in list(val.keys())]
            if all(i in attributes for i in ['End', 'Start', 'Multiplier']):
                bit_type = 'slider'
            else:
                bit_type = 'text_field'
        else:
            raise BitFieldTypeError('Unable to get bit field type of : %s' % address)
        return bit_type


class DeviceXmlParser:
    """
    Generic parser for all Device definition files.
    """

    def __init__(self, device_xml_file):
        """
        Initialise
        """
        self.etree_root = None
        self.reg_width = None
        xml_con = open(device_xml_file, 'rU')
        self.etree_root = etree.XML(xml_con.read())

    def get_device_info(self):
        """
        Gets the information matching with device tag and returns device type value
        @return System Device Information
        """
        try:
            find_text = etree.XPath("//DeviceInfo/*")
        except IndexError:
            raise ElementNotFoundException("Device Info element is not present")
        dev_info_tags = find_text(self.etree_root)
        device_info_xml = dev_info_tags[0].getparent()
        str_xml = etree.tostring(device_info_xml)
        device_info_ord_dict = xmltodict.parse(str_xml)
        device_info_json = (json.dumps(device_info_ord_dict))
        device_info_dict = json.loads(device_info_json)
        dev_info = device_info_dict['DeviceInfo']
        return dev_info

    def construct_reg_class_dict(self, all_reg_info_dict, all_fields_info_dict, reg_map_test=False):
        """
        Construct a register class dictionary,with key as register name and value as register
        object,register object has some of the attributes of register and also bit field objects
        associated with value of that register.
        @param all_reg_info_dict All registers info
        @param all_fields_info_dict All bit fields info
        @return constructed register class dictionary
        """
        register_class_dict = OrderedDict()
        common_bit_fields = {}
        bit_field_dict={}
        common_field=False
        common_registers={}
        for reg_dict in all_reg_info_dict:
            reg_address = reg_dict.get('Address')
            reg_default_value = reg_dict.get('DefaultValue')
            if reg_default_value is None:
                reg_default_value = '0x' + '0' * (self.get_register_width() / 4)
            reg_access = reg_dict.get('Access')
            display_name = reg_dict.get('DisplayName', None)
            reg_name = reg_dict.get('Name')
            bit_field_objects = []
            for bit_field in all_fields_info_dict:
                bit_field_pattern = re.compile(r'^%s\[.*\]$' % reg_name)
                if bit_field_pattern.search(str(bit_field.get('Address'))):
                    field_address = bit_field.get('Address')
                    field_default_value = bit_field.get('DefaultValue')
                    software_access = bit_field.get('SoftwareAccess')
                    if field_default_value is None:
                        field_default_value = '0x' + '0' * self.get_bit_width(":".join(field_address))
                    field_access = bit_field.get('Access')
                    field_name = bit_field.get('Name')
                    field_description = bit_field.get('Description')
                    possible_values = []
                    try:
                        possible_values = bit_field.get('Values', None)
                        if possible_values is None:
                            possible_values = []
                    except:
                        pass
                    field_obj = BitField(field_name, field_default_value, field_access,
                                         field_address, field_description, software_access,
                                         possible_values)
                    bit_field_dict[field_name]=field_obj
                    bit_field_objects.append(field_obj)
                    if "+" in str(bit_field.get('Address')):
                        common_registers[field_name]=bit_field.get('Address').split("+")
                        common_field=True

            register_obj = Register(reg_name, display_name, reg_address, reg_default_value, reg_access,
                                    bit_field_objects)
            register_class_dict[reg_name] = register_obj
        if common_field:
            common_bit_fields=self.get_common_bit_fields(all_reg_info_dict, all_fields_info_dict, bit_field_dict, common_registers)
        register_class_dict = self.update_common_bit_fields(common_bit_fields, register_class_dict,reg_map_test)
        return register_class_dict

    @staticmethod
    def get_bit_width(bit_field_location):
        """
        This method returns bit field width based on bit field location
        """
        bit_width = None
        if ':' in bit_field_location:
            bit_field_locations = [builtins.int(index) for index in bit_field_location.split(':')]
            bit_field_locations.sort()
            if bit_field_locations[0] == 0:
                bit_width = bit_field_locations[1] + 1
            else:
                bit_width = (bit_field_locations[1] - bit_field_locations[0]) + 1
        else:
            bit_width = 1
        return bit_width

    def get_register_class_dict(self,reg_map_test=False):
        """
        Populates the register_class dictionary with register name as key and
        register class object as value.
        @return register class dictionary
        """
        reg_info_dict = self.get_each_register_info()
        bit_field_info = self.get_each_bit_field_info()
        self.register_class_dict = self.construct_reg_class_dict(reg_info_dict, bit_field_info,reg_map_test)
        return self.register_class_dict

    def get_each_register_info(self):
        """
        Gets all Information of every register by its name.
        @return list of dictionaries,each has info of corresponding register.
        """
        reg_info_dict = []
        find_text = etree.XPath('//Registers/*')
        register_tags = find_text(self.etree_root)
        for index, register_tag in enumerate(register_tags):
            device_reg_dict = {}
            for register_children in register_tag.getchildren():
                device_reg_dict[register_children.tag] = register_children.text
            for reg_key in list(device_reg_dict.keys()):
                if builtins.str(builtins.type(reg_key)) == "<type 'cython_function_or_method'>":
                    del device_reg_dict[reg_key]
            reg_info_dict.append(device_reg_dict)
        return reg_info_dict

    def get_each_bit_field_info(self):
        """
        Gets all Information of every register by its name.
        @return list of dictionaries,each has info of corresponding register.
        """
        if sys.version_info[0] == 3:
            reload(sys)
        elif sys.version_info[0] == 2:
            importlib.reload(sys)

        sys.setdefaultencoding('utf8')
        reg_info_dict = []
        find_text = etree.XPath('//Fields/*')
        register_tags = find_text(self.etree_root)
        for index, register_tag in enumerate(register_tags):
            device_reg_dict = {}
            for register_children in register_tag.getchildren():
                if register_children.getchildren():
                    device_reg_dict[register_children.tag] = []
                    values = register_children.getchildren()
                    for value_child in values:
                        values_children = [{ch.tag: ch.text} for ch in value_child.getchildren()]
                        value = dict(value_child.attrib)
                        if value:
                            values_children.append(value)
                        device_reg_dict[register_children.tag].append(values_children)
                else:
                    device_reg_dict[register_children.tag] = register_children.text
            reg_info_dict.append(device_reg_dict)
        return reg_info_dict

    def get_register_width(self):
        """
        Returns the width of the register
        """
        find_text = etree.XPath("//Registers")
        try:
            matched_text = find_text(self.etree_root)[0]
        except IndexError:
            raise ElementNotFoundException("Register width not found")
        return builtins.int(matched_text.attrib.get('Width'))

    def get_regname_for_field(self, field_name):
        for reg_name, reg_ob in self.register_class_dict.items():
            for bit_field in reg_ob.BitFields:
                if bit_field.Name == field_name:
                    return reg_name

    @staticmethod
    def field_etree_to_dict(field_etree_element):
        """
        Converts Bit field lxml etree element to dictionary
        @param field_etree_element: [lxml.etree]
        @return [dict] bit field dictionary
        """
        bitfield_dict = {}
        for field_etree_element in field_etree_element.getchildren():
            if field_etree_element.getchildren():
                bitfield_dict[field_etree_element.tag] = []
                values = field_etree_element.getchildren()
                for value_child in values:
                    values_children = [{str(ch.tag): str(ch.text)} for ch in value_child.getchildren()]
                    attribute_values = dict(value_child.attrib)
                    if attribute_values:
                        values_children.append(attribute_values)
                    values_children_dict = {}
                    for value_dict in values_children:
                        values_children_dict.update(value_dict)
                    bitfield_dict[field_etree_element.tag].append(values_children_dict)
            else:
                bitfield_dict[field_etree_element.tag] = field_etree_element.text
        return bitfield_dict

    def update_common_bit_fields(self, common_bit_fields, register_class_dict,reg_map_test=False):
        """
        Updates register and bit fields objects with common bit fields
        @param common_bit_fields: [list] Common bit fields among registers
        @param register_class_dict: [dict] Register class dictionary
        @return: [dict] Register class dictionary
        """
        for reg_name, reg_ob in register_class_dict.items():
            for bit_field in reg_ob.BitFields:
                bit_field_name = bit_field.Name
                bit_field_address=bit_field.Address
                if bit_field_name in list(common_bit_fields.keys()):
                    bit_field_info = common_bit_fields[bit_field_name][0]
                    registers = common_bit_fields[bit_field_name][1]
                    bit_field_len = self.cal_bit_width(registers)
                    for register in registers:
                        bit_field_loc = re.search(r'\[.*\]', register).group()
                        _register_name = re.search(r'(.*)\[.*\]', register).group(1)
                        field_present = False
                        if '+' in bit_field_address:
                            for index, _bit_field in enumerate(register_class_dict[_register_name].BitFields):
                                if bit_field_name == _bit_field.Name:
                                    _bit_field.Address = _register_name + bit_field_loc
                                    _bit_field.BitFieldLocation = bit_field_loc
                                    _bit_field.Name = self.get_field_name(registers,
                                                                          _bit_field.Address,
                                                                          _bit_field.Name,reg_map_test)
                                    _bit_field.Address = _register_name + bit_field_len
                                    _bit_field.InRegisters = registers
                                    field_present = True
                                    register_class_dict[_register_name].BitFields[index] = _bit_field
                            if not field_present:
                                bit_field_info.Address = _register_name + bit_field_loc
                                bit_field_info.BitFieldLocation = bit_field_loc
                                bit_field_info.InRegisters = registers
                                bit_field_info.Name = self.get_field_name(registers,
                                                                          bit_field_info.Address,
                                                                          bit_field_info.Name,reg_map_test)
                                bit_field_info.Address = _register_name + bit_field_len
                                register_class_dict[_register_name].BitFields.append(bit_field_info)
                            register_class_dict[_register_name].CommonRegisters = registers
                            register_class_dict = copy.deepcopy(register_class_dict)
                        else:
                            for index, _bit_field in enumerate(register_class_dict[_register_name].BitFields):
                                if bit_field_name == _bit_field.Name:
                                    _bit_field.InRegisters = registers
                                    register_class_dict[_register_name].BitFields[index] = _bit_field
                            register_class_dict[_register_name].CommonRegisters = registers
                            register_class_dict = copy.deepcopy(register_class_dict)
        return register_class_dict

    def cal_bit_width(self, field_addresses):
        """
        Calculate bit field width for a bit field which spans multiple registers
        @param field_addresses: [str] bit field address tag
        @return: Bit width of bit field
        """
        # Calculating the number of locations occupied by bit field through its
        # Address value, going through each register name and parsing the number
        # locations,summing up the address and form bit field address
        mat = re.search(r'\[(\d+(:\d+)?)\]', field_addresses[0])
        wid_str = mat.group(1)
        if ":" in wid_str:
            wid_str = [builtins.int(index) for index in wid_str.split(':')]
            wid_str.sort()
            strt_index = wid_str[0]
            bit_w = wid_str[1] - strt_index
        else:
            strt_index = builtins.int(wid_str)
            bit_w = strt_index
        for index in range(1, len(field_addresses)):
            mat = re.search(r'\[(\d+(:\d+)?)\]', field_addresses[index])
            wid_str = mat.group(1)
            if ":" in wid_str:
                wid_str = [builtins.int(index) for index in wid_str.split(':')]
                wid_str.sort()
                bit_w += wid_str[1] - wid_str[0]
            else:
                strt_index = builtins.int(wid_str)
                bit_w += strt_index
            bit_w += 1
        return '[%s:%s]' % (bit_w, strt_index)

    def get_field_name(self, field_addresses, field_addr, field_name,reg_map_test=False):
        """
        Returns the updated file name in case a field exists among registers
        @param field_addresses: [list] list of register address in which the field exists
        @param field_addr: [str] Bit field address
        @param field_name: [str] Bit field name
        @return: [str] Updated Bit field name.
        """
        field_addresses = copy.deepcopy(field_addresses)
        field_addresses.reverse()
        field_name = re.sub(r'\[([\d:]+)\]', '', field_name)
        field_name = re.sub(r'\s*$', '', field_name)
        addr_index = field_addresses.index(field_addr)
        if addr_index == 0:
            mat = re.search(r'\[([\d:]+)\]', field_addr)
            if reg_map_test:
                wid_str=mat.group(1)
                wid_str = [builtins.int(index) for index in wid_str.split(':')]
                wid_str.sort()
                bit_w = wid_str[1] - wid_str[0]
                updated_field_name = field_name + ' [%s:0] ' % (bit_w)
            else:
                updated_field_name = field_name + ' [%s]' % (mat.group(1))
        else:
            l_bit_w = 0
            for _index in range(addr_index):
                mat = re.search(r'\[([\d:]+)\]', field_addresses[_index])
                l_bit_w += self.get_bit_width(mat.group(1))
            mat = re.search(r'(\d+):\d+', field_addresses[addr_index])
            if mat is None:
                mat = re.search(r'\[(\d+)\]', field_addresses[addr_index])
            m_bit_w = builtins.int(mat.group(1)) + 1
            if reg_map_test:
                updated_field_name = field_name + ' [%s:%s] ' % (m_bit_w + l_bit_w - 1,
                                                            l_bit_w)
            else:
                updated_field_name = field_name + ' [%s:%s]' % (m_bit_w + l_bit_w - 1,
                                                            l_bit_w)
        return updated_field_name

    def get_common_bit_fields(self, all_reg_info_dict, all_fields_info_dict, bit_field_dict, common_registers):
        """
        Returns all bit_field which are combined with multiple register
        @param all_reg_info_dict All registers info
        @param all_fields_info_dict All bit fields info
        @param bit_field_dict dictionary of all bit_field with details
        @param common_registers dictionary of all common_bit_field with registers name
        @return all_bit_field class dictionary
        """
        common_bit_fields={}
        for reg_dict in all_reg_info_dict:
            reg_name = reg_dict.get('Name')
            for bit_field in all_fields_info_dict:
                bit_field_pattern = re.compile(r'^%s\[.*\]$' % reg_name)
                if bit_field_pattern.search(str(bit_field.get('Address'))):
                    field_name = bit_field.get('Name')
                    field_address=bit_field.get('Address')
                    for field_n,registers in common_registers.items():
                        for register in registers:
                            register_name = re.sub(r'\[.*\]', '', register)
                            if reg_name == register_name and '+' not in field_address:
                                common_bit_fields[field_name]=[bit_field_dict[field_name],registers]
        for field_n,registers in common_registers.items():
            common_bit_fields[field_n]=[bit_field_dict[field_n],registers]
        return common_bit_fields
