"""
Base script for Register Map operations
"""
import builtins
import os
import re
import traceback
from collections import namedtuple
import yaml

source(findFile("scripts", "base_bsp_squish.py"))
source(findFile("scripts", "device_xml_parser.py"))


class BaseRegisterMapError(Exception):
    """Error class for BaseRegisterMap"""
    pass


# Named tuple for Register access modes
access_modes = namedtuple('AccessModes', 'R_O R_W W_O W1C')
ACCESS_MODE = access_modes('R/O', 'R/W', 'W/O', 'W1C')

# Named tuple for Register attributes
register_attr = namedtuple('RegisterAttr', 'Name DisplayName Access DefaultValue Address BitFields')
REG_ATTR = register_attr('Name', 'DisplayName', 'Access', 'DefaultValue', 'Address', 'BitFields')

# Named tuple for Bit field attributes
bitfield_attr = namedtuple('BitFieldAttr', 'Name RegisterName Access DefaultValue Address '
                                           'Values Units Start End FieldType '
                                           'TextField RadioButton ComboBox Slider Value BitFieldLocation '
                                           'SoftwareAccess Volatile Test')
BIT_FIELD_ATTR = bitfield_attr('Name', 'RegisterName', 'Access', 'DefaultValue', 'Address', 'Values', 'Units',
                               'Start', 'End', 'FieldType', 'text_field', 'radio_button', 'combo_box',
                               'slider', 'Value', 'BitFieldLocation', 'SoftwareAccess', 'Volatile', 'Test')

# Named tuple for Bit field representation in GUI
bit_field_gui_repr = namedtuple('BitFieldRepr', 'DEF NUM')
BIT_FIELD_GUI_REPR = bit_field_gui_repr('DEF', 'NUM')

# Named tuple for Widgets in register map
regmap_field_type = namedtuple('RegMapFieldType', 'TextField RadioButton ComboBox Slider')
REG_MAP_FIELD_TYPE = regmap_field_type('Value', 'Radio Button', 'Combo Box', 'Slider')


def exception_handler(func):
    def handler(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except Exception as e:
            test.fail("FAIL", "Exception while running function:%s, %s: %s, %s" % (
                func.__name__, e.__class__.__name__, e, str(traceback.format_exc())))

    return handler


class BaseRegisterMap(BaseSquish):
    """
    Common methods for Register map operations
    """
    def parse_and_populate_xml_content(self, reg_map_name):
        """
        Parse the device definition xml file
        Populates each_register_info with all registers info in device xml file
        Populates register_class_dict with all registers and bit fields corresponding to registers
        Opens the register map
        """
        # Default to 5 registers
        self.sanity_reg_count = 5
        self.wc_bit_fields = []
        self.soak = self.test_inputs_dict['soak']
        self.device_xml_parser = DeviceXmlParser(device_xml_file=self.squish_config.squish_config['dev_def_file'])

        self.each_register_info = self.device_xml_parser.get_each_register_info()
        self.register_class_dict = self.device_xml_parser.get_register_class_dict(reg_map_test=True)
        self.reg_width = self.device_xml_parser.get_register_width()
        self.register_not_validate = self.get_register_not_validate()
        self.rw_total, self.ro_total, self.wo_total = self.calculate_expected_register_counter()

        [self.bit_wo_total, self.bit_ro_total,
         self.combo_total, self.text_total,
         self.radio_total, self.slider_total] = self.calculate_expected_bit_fields_counter()

        test.log("Totals: self.rw_total %s, self.ro_total %s, self.wo_total %s"
                 "self.bit_wo_total %s, self.bit_ro_total %s, self.combo_total %s, self.text_total %s, "
                 "self.radio_total %s, self.slider_total %s" % (self.rw_total, self.ro_total, self.wo_total,
                                                                self.bit_wo_total, self.bit_ro_total, self.combo_total,
                                                                self.text_total,
                                                                self.radio_total, self.slider_total))
        self.set_inputs(reg_map_test=True)
        try:
            self.close_tab(reg_map_name, check_tab_exists=True)
        except LookupError:
            pass
        Common.openRegisterMap(self.sys_name, self.device_name)
        Common.clearHistory(self.sys_name)
        self.default_checks = {REG_MAP: PASS_STEP}

    def set_reg_or_fields_not_to_validate(self):
        """
        Parses skip registers yml and sets registers and bit field which are not need to validate.
        """
        device_name = self.device_name.replace('CS', '')
        if " " in device_name:
            device_name = device_name.split(" ")[0]
        try:
            self.device_type = list(self.BSP_DEVICE_MAPPING.keys())[list(self.BSP_DEVICE_MAPPING.values()).index(device_name)]
        except ValueError:
            self.device_type = None

        skip_registers_yml = self.squish_config.squish_config['skip_registers']
        with open(skip_registers_yml, 'r') as stream:
            skip_registers = yaml.safe_load(stream)
        yaml_variables = namedtuple('yaml_variables', 'registers address_range wc_bit_fields bit_fields')
        self.skip_reg_keys = yaml_variables('registers', 'address_range', 'wc_bit_fields', 'bit_fields')
        self.reg_not_validate = None
        self.address_range = None
        self.wc_bit_fields = None
        self.skip_bit_fields = None
        try:
            self.reg_not_validate = skip_registers[self.skip_reg_keys.registers]
        except KeyError:
            test.warning("No registers skipped for device %s" % self.device_name)
        # Reading all project specific skip_registers and updating them to self.reg_not_validate and self.address_range
        # variables
        try:
            self.address_range = skip_registers[self.skip_reg_keys.address_range]
        except KeyError:
            pass
        try:
            # These are applicable only with real hardware. With Simulated system, WC registers check will fail
            self.wc_bit_fields = skip_registers[self.skip_reg_keys.wc_bit_fields]
        except KeyError:
            pass
        try:
            self.skip_bit_fields = skip_registers[self.skip_reg_keys.bit_fields]
        except KeyError:
            pass

    @staticmethod
    def calculate_expected_value(prev_reg_value, bit_field_val, reg_width, bit_field_addr):
        """
        Calculating the expected register value based on change in bit field

        @param prev_reg_value: Previous register value
        @param bit_field_val: Bit field value
        @param reg_width: Width of the Register
        @param bit_field_addr: Address of Field
        @return: [int] expected register value
        """
        last_index = None
        if isinstance(prev_reg_value, str) and '0x' in prev_reg_value:
            prev_reg_value = builtins.int(prev_reg_value, 16)
        else:
            prev_reg_value = builtins.int(prev_reg_value)
        prev_reg_value_bin = bin(prev_reg_value)[2:]
        if isinstance(bit_field_val, str) and '0x' in bit_field_val:
            bit_field_val_bin = builtins.bin(builtins.int(bit_field_val, 16))[2:]
        else:
            bit_field_val_bin = builtins.bin(builtins.int(bit_field_val))[2:]
        indexes = re.search('\[(\d+(:\d+)?)\]', bit_field_addr)

        if ":" in indexes.group(1):
            indexes = [builtins.int(index) for index in indexes.group(1).split(":")]
            indexes.sort()
        else:
            if indexes is not None:
                indexes = [builtins.int(indexes.group(1))]
            else:
                indexes = [0, reg_width]
        prev_reg_value_bin = list(prev_reg_value_bin.zfill(reg_width))
        if len(indexes) == 1:
            index = builtins.abs(indexes[0] - reg_width) - 1
            prev_reg_value_bin[index] = bit_field_val_bin
        else:
            if not indexes[0] == 0:
                last_index = -indexes[0]
            bit_field_width = -(indexes[1] + 1)
            bit_field_val_bin = bit_field_val_bin.zfill(indexes[1] - indexes[0] + 1)
            prev_reg_value_bin[bit_field_width:last_index] = bit_field_val_bin
        expected_value = builtins.int('0b' + "".join(prev_reg_value_bin), 2)
        return expected_value

    @exception_handler
    def check_if_reg_is_ro(self, reg_map_obj, register_name):
        """
        Checks if the given register is read only
        @param reg_map_obj: [RegisterMap] register map object
        @param register_name: [str] Register name
        """
        # Click on the register in register map
        InputActions.mouseClickOnItem(reg_map_obj.getRegisterFromRegTable(register_name))
        # Get the row number of given register from register table
        row = str(findObject(reg_map_obj.getRegisterFromRegTable(register_name)).cell.parent.index)
        register_row = "{caption='TableRow%s' container=%s type='com.froglogic.squish.jfx.TableRowProxy'}" % (
                            row, reg_map_obj.getRegisterTable())
        register_object = waitForObject(register_row)
        # Check if table row is writable
        self.assert_true(not register_object.cell.item.writable,
                         "Check if Register: %s is grayed out" % register_name)
        InputActions.mouseClickOnItem(reg_map_obj.refreshRegister)

    @exception_handler
    def check_if_bit_field_is_ro(self, reg_map_obj, bit_field_name):
        """
        Verifies if the given bit field is Read only.
        @param reg_map_obj: [RegisterMap] Register map object
        @param bit_field_name: [str] Bit field name
        """
        bit_field_real_name = reg_map_obj.getRegisterFromBitFieldTable(bit_field_name)
        # Click on the bit field in Bit field table on register map
        InputActions.mouseClickOnItem(bit_field_real_name)
        # Get the row number of given bit field from bit field table
        bit_field_obj = waitForObject(bit_field_real_name)
        row = str(bit_field_obj.cell.parent.index)
        bit_field_row = "{caption='TableRow%s' container=%s type='com.froglogic.squish.jfx.TableRowProxy'}" % (
                              row, reg_map_obj.getBitFieldTable())
        bit_field_row = waitForObject(bit_field_row)
        # Check if table row is writable
        field_read_only = not bit_field_row.cell.item.writable
        self.assert_true(field_read_only,
                         "Check if BitField: %s is grayed out" % bit_field_name)
        InputActions.mouseClickOnItem(reg_map_obj.refreshRegister)

    def rw_dev_def_registers(self, mode_to_test="R/W", reg_map_name=None, out_of_range=False,
                             log_msg=None):
        """
        Reading each register and if particular register access is Read/write
        writing a value to it.
        """
        reg_counter = 0
        self.exp_reg_updates = []
        failed_registers = []
        not_tested_registers = []
        if not reg_map_name:
            reg_map_name = "%s (%s)" % (self.device_name, self.device_name)
        reg_map_obj = RegisterMap(reg_map_name)
        Common.clearHistory(self.sys_name)
        for register in self.each_register_info:
            if not self.soak and reg_counter >= self.sanity_reg_count:
                break
            register_name = register.get(REG_ATTR.DisplayName, register[REG_ATTR.Name])
            access_mode = register[REG_ATTR.Access]
            register_address = register[REG_ATTR.Address]
            try:
                xml_default = register[REG_ATTR.DefaultValue]
            except KeyError as key_error:
                xml_default = '0x' + '0' * (self.reg_width / 4)
            if register_name in self.reg_not_validate:
                test.log("Verifying register: %s is skipped" % register_name)
                continue
            if self.BSP.Cornell in self.device_type and builtins.int(register_address, 16) > self.address_range:
                continue
            if mode_to_test == access_mode:
                overall_result = {}
                expected_results = {}
                if access_mode == ACCESS_MODE.R_W:
                    verify_register = True
                    if out_of_range:
                        register_value = hex(2 ** self.reg_width)
                        register_value = register_value.replace("L", "")
                        verify_register = False
                    else:
                        register_value = xml_default
                        _register_value = builtins.hex(builtins.int(register_value, 16))
                        _register_value = _register_value.replace("L", "")
                        _register_address = register_address.lower()
                        reg_struct = self.register_class_dict[register[REG_ATTR.Name]]
                        if reg_struct.CommonRegisters:
                            _reg_name = re.sub(r'\[.*\]', '',
                                               reg_struct.CommonRegisters[-1])
                            _register_address = self.register_class_dict[_reg_name].Address
                            _register_address = _register_address.lower()
                            common_regs = reg_struct.CommonRegisters
                            common_regs.reverse()
                            val = []
                            for _reg in common_regs:
                                _reg = re.sub(r'\[.*\]', '', _reg)
                                val.append(builtins.hex(
                                    builtins.int(self.register_class_dict[_reg].DefaultValue,
                                                    16)))
                            self.exp_reg_updates.append({_register_address: tuple(val)})
                        else:
                            self.exp_reg_updates.append({_register_address: _register_value})
                    results = self.write_register_and_verify(self.device_name, register_name, register_value,
                                                             reg_map_name=reg_map_name, verify_reg=verify_register,
                                                             print_assertion=False)
                    if not out_of_range:
                        overall_result[register_name] = results
                        expected_results[register_name] = self.default_checks
                        self.assert_equal(overall_result, expected_results,
                                          "Check overall result for register %s,register type %s, "
                                          "updated with value %s" % (register_name, access_mode, register_value))
                    if out_of_range:
                        warning_message = "Value needs to be between 0 and %s" % (builtins.int(register_value, 16)
                                                                                  - 1)
                        register_obj = reg_map_obj.getRegisterFromRegTable(register_name)
                        row = str(findObject(register_obj).cell.parent.index)
                        register_txt_box = reg_map_obj.getRegisterCellArea('Value', row,
                                                                           reg_map_obj.getRegisterTable())
                        results = self.check_warning_message(register_txt_box, register_value, warning_message,
                                                             check_warning_only=True, print_assertion=False)
                        overall_result[register_name] = results
                        expected_results[register_name] = self.default_checks
                        self.assert_equal(overall_result, expected_results,
                                          "Check overall result for register %s,register type %s, "
                                          "updated with value %s" % (register_name, access_mode, register_value))
                        if self.scs_version >= 1.7:
                            results = self.write_register_and_verify(self.device_name, register_name, xml_default,
                                                                reg_map_name=reg_map_name, verify_reg=False,
                                                                print_assertion=False)
                    reg_counter += 1
                elif access_mode == ACCESS_MODE.R_O:
                    self.check_if_reg_is_ro(reg_map_obj, register_name)
                    reg_counter += 1
                elif access_mode == ACCESS_MODE.W_O:
                    verify_register = True
                    register_value = xml_default
                    open_history_table = False
                    if reg_counter == 0:
                        open_history_table = True
                    results = self.write_register_and_verify(self.device_name, register_name, register_value,
                                                             reg_map_name=reg_map_name, verify_reg=verify_register,
                                                             open_history_table=open_history_table,
                                                             verify_history=True, print_assertion=False)
                    overall_result[register_name] = results
                    expected_results[register_name] = {REG_MAP: PASS_STEP, HISTORY: PASS_STEP}
                    self.assert_equal(overall_result, expected_results,
                                      "Check overall result for register %s,register type %s,updated with value %s" % (
                                      register_name, access_mode, register_value))
                    reg_counter += 1
                if len(self.step_outcome()) > 1 and self.step_outcome()[-1] == FAIL_STEP and mode_to_test == access_mode:
                    failed_registers.append(register_name)
        log_msg = log_msg + " register count: " + str(reg_counter)
        if self.soak:
            if mode_to_test == ACCESS_MODE.R_O:
                reg_counter = self.ro_total
            elif mode_to_test == ACCESS_MODE.R_W:
                reg_counter = self.rw_total
            elif mode_to_test == ACCESS_MODE.W_O:
                reg_counter = self.wo_total
            self.assert_equal(self.step_outcome().count(PASS_STEP), reg_counter, log_msg)
        else:
            self.assert_equal(self.step_outcome().count(PASS_STEP), reg_counter, log_msg)
        failed_registers = set(failed_registers)
        self.assert_equal(len(failed_registers), 0,
                          log_msg + ", failed registers count %s, failed registers %s" % (len(failed_registers),
                                                                                          failed_registers))
        if mode_to_test == ACCESS_MODE.R_W and not out_of_range and not mode_to_test == ACCESS_MODE.W_O:
            if Common.getHistoryLength(self.sys_name) != 0:
                Common.selectAllInHistory(self.sys_name)
                srs_file_name = self.__class__.__name__ + "_registers_updated.srs"
                srs_file_path = Common.exportAllHistory(self.sys_name, srs_file_name)
                # exporting may take time
                snooze(2)
                srs_file_path = os.path.realpath(srs_file_path)
                srs_file_con = self.parse_history_file(srs_file_path)
                self.assert_diff_in_dict_and_history(self.exp_reg_updates, srs_file_con,
                                                 "Verifying in history window: " + log_msg)
        elif mode_to_test == ACCESS_MODE.R_O:
            self.check_for_read_entries_in_history(reg_counter)
        self.assert_equal(not_tested_registers, [], "Check if all registers are tested")

    def check_for_read_entries_in_history(self, read_updates_count):
        """
        Check if all entries in history window are of Operation Read
        """
        non_read_reg_updates = []
        Common.selectAllInHistory(self.sys_name)
        srs_file_name = self.__class__.__name__ + "_registers_updated.csv"
        srs_file_path = Common.exportAllHistory(self.sys_name, srs_file_name)
        snooze(2)
        srs_file_path = os.path.realpath(srs_file_path)
        his_con = self.parse_history_file(srs_file_path)
        read_updates = 0
        for register_update in his_con:
            if register_update['Op'] != 'R' and register_update['Op'] != 'BR':
                non_read_reg_updates.append(register_update)
            else:
                read_updates += 1
        self.assert_equal(non_read_reg_updates, [], "Check if there are no Non Read register updates")
        self.assert_equal(read_updates, read_updates_count, "Check for only Read operations register updates in "
                                                            "history")

    def verify_register_value_and_write_default_value(self, reg_default_value, bit_field_value, reg_width,
                                                      bit_field_address, register_name, reg_map_name, register_address,
                                                      expected_value=None, bit_field_struct=None):
        """
        Verifies register value and writes default value.

        @param reg_default_value: [int] Default value of the register
        @param bit_field_value: [int|hex] bit field default value
        @param reg_width: [int] Register width in bits
        @param bit_field_address: [hex] bit field address
        @param register_name: [str] Register name
        @param reg_map_name: [str] Register map caption
        @param register_address: [hex] Register map address
        @param expected_value: [hex] Register expected value
        @return: [dict] Status of Verification of register value in register map and history
        """
        register_address = register_address.lower()
        reg_with_common_bit_fields = bit_field_struct.InRegisters
        if all(v is not None for v in [bit_field_value, reg_width, bit_field_address]):
            if isinstance(bit_field_value, str) and "0x" in bit_field_value:
                bit_field_value = bit_field_value.rstrip("L")
                bit_field_value = builtins.int(bit_field_value, 16)
            expected_value = self.calculate_expected_value(prev_reg_value=reg_default_value,
                                                           bit_field_val=bit_field_value,
                                                           reg_width=reg_width,
                                                           bit_field_addr=bit_field_address)
            expected_value_unpadded = builtins.hex(builtins.int(expected_value))
            expected_value_unpadded = expected_value_unpadded.replace("L", "")
            expected_value = "".join([expected_value_unpadded[0:2],
                                      expected_value_unpadded[2:].rjust(reg_width/4, '0')])
            expected_value = expected_value.replace("L", "")
            if reg_with_common_bit_fields:
                _register_name = re.sub(r'\[.*\]', '', reg_with_common_bit_fields[-1])
                register_address = self.register_class_dict[_register_name].Address
                register_address = register_address.lower()
                exp_val_list = self.update_expected_value(expected_value_unpadded,
                                                          reg_with_common_bit_fields,
                                                          register_name)
                updated_reg = {register_address: exp_val_list}
            else:
                updated_reg = {register_address: expected_value_unpadded}
            self.exp_reg_updates.append(updated_reg)
        elif expected_value is not None:
            updated_reg = {register_address: expected_value}
            self.exp_reg_updates.append(updated_reg)
        else:
            raise BaseRegisterMapError("Expected value is neither calculated nor passed as parameter")
        results = self.verify_register_value(self.device_name, register_name, expected_value,
                                             reg_map_name=reg_map_name, print_assertion=False)
        self.write_register_and_verify(self.device_name, register_name, reg_default_value,
                                       reg_map_name=reg_map_name, verify_reg=False)
        if expected_value != reg_default_value:
            reg_default_value = builtins.hex(builtins.int(reg_default_value, 16))
            reg_default_value = reg_default_value.replace("L", "")
            if reg_with_common_bit_fields:
                reg_val = []
                _lsb_register_name = re.sub(r'\[.*\]', '', reg_with_common_bit_fields[-1])
                register_address = self.register_class_dict[_lsb_register_name].Address
                register_address = register_address.lower()
                for _reg_name in reg_with_common_bit_fields:
                    _register_name = re.sub(r'\[.*\]', '', _reg_name)
                    reg_default_value = builtins.hex(
                        builtins.int(self.register_class_dict[_register_name].DefaultValue,
                                        16))
                    reg_val.append(reg_default_value)
                reg_val.reverse()
                updated_reg = {register_address: tuple(reg_val)}
                self.exp_reg_updates.append(updated_reg)
            else:
                updated_reg = {register_address: reg_default_value}
                self.exp_reg_updates.append(updated_reg)
        return results

    def update_expected_value(self, expected_value_unpadded,
                              reg_with_common_bit_field, register_name):
        """
        Returns expected value after performing register operation
        @param expected_value_unpadded: [hex] Expected value
        @param reg_with_common_bit_field: [list] list of registers with common bit field
        @param register_name: [str] register name
        @return: [str|list] Expected value(s)
        """
        reg_index = None
        for index, _reg in enumerate(reg_with_common_bit_field):
            if "[" in _reg:
                _reg = re.sub(r'\[.*\]', '', _reg)
                reg_with_common_bit_field[index] = _reg
            if register_name == _reg:
                reg_index = index
                break
        exp_val_list = []
        if reg_index is not None:
            for index, _reg in enumerate(reg_with_common_bit_field):
                if index != reg_index:
                    _reg_name = re.sub(r'\[.*\]', '', reg_with_common_bit_field[index])
                    val = builtins.hex(builtins.int(
                        self.register_class_dict[_reg_name].DefaultValue, 16))
                    exp_val_list.append(val)
                else:
                    exp_val_list.append(expected_value_unpadded)
        exp_val_list.reverse()
        exp_val_list = tuple(exp_val_list)
        return exp_val_list

    @staticmethod
    def get_bit_width(bit_field_location):
        """
        Calculates the Width of the bit field in bits
        @param bit_field_location: [str] Indexes of the bit field
        @return: [int] Width of bit field in bits
        """
        _bit_field_location = re.search(r'\[(\d+(:\d+)?)\]', bit_field_location)
        if _bit_field_location:
            bit_field_location = _bit_field_location.group(1)
        bit_width = None
        if ':' in bit_field_location:
            bit_field_locations = [builtins.int(index) for index in bit_field_location.split(':')]
            bit_field_locations.sort()
            if bit_field_locations[0] == 0:
                bit_width = bit_field_locations[1] + 1
            else:
                bit_width = (bit_field_locations[1] - bit_field_locations[0]) + 1
        else:
            bit_width = 1
        return bit_width

    @exception_handler
    def test_bit_field(self, reg_map_obj, register_name, register_address, bit_field_struct, values_to_test,
                       reg_default_value, reg_map_name, bit_field_type, neg_case=False, num_of_values_to_test=5):
        """
        Method to test bit field widgets like TextField,RadioButton,Combobox,Slider.
        @param reg_map_obj: [RegisterMap] Register map instance
        @param register_name: [str] Name of the register
        @param register_address: [hex] Register address
        @param bit_field_struct: [BitField] Bit field data structure
        @param values_to_test: [list] list of RadioButton or Combobox or slider options
        @param reg_default_value: [hex] Default value of the Register
        @param reg_map_name: [str] Register map caption
        @param bit_field_type: [str] Type of the bit field, bit field widget type
        @param neg_case: [bool] Test case type(valid, invalid)
        @param num_of_values_to_test: [int] Number of values to test in Combobox
        """
        bit_field_name = bit_field_struct.Name
        bit_field_address = bit_field_struct.Address
        bit_field_location = bit_field_struct.BitFieldLocation
        bit_field_real_name = reg_map_obj.getRegisterFromBitFieldTable(bit_field_name)
        InputActions.mouseClickOnItem(bit_field_real_name)
        if bit_field_type == BIT_FIELD_ATTR.TextField:
            warning_message = None
            verify_register = False
            bit_width = self.get_bit_width(bit_field_location)
            if neg_case:
                bit_field_value = hex(2 ** bit_width).rstrip('L')
                warning_message = "Value needs to be between 0 and %s" % (builtins.int(bit_field_value, 16) - 1)
            else:
                bit_field_value = hex((2 ** bit_width) - 1)
                verify_register = True
            results = {}
            expected_result = {bit_field_value: {REG_MAP: PASS_STEP}}
            neg_results = self.test_text_field(reg_map_obj, bit_field_name, bit_field_value, neg_case=neg_case,
                                               warning_message=warning_message)
            if neg_case:
                results[bit_field_value] = neg_results
            if verify_register:
                if bit_field_name in self.wc_bit_fields:
                    reg_map_obj = RegisterMap(reg_map_name)
                    InputActions.mouseClickOnItem(reg_map_obj.refreshRegister)
                    bit_field_value = 0
                    expected_result = {bit_field_value: {REG_MAP: PASS_STEP}}
                results[bit_field_value] = self.verify_register_value_and_write_default_value(reg_default_value,
                                                bit_field_value, self.reg_width, bit_field_location, register_name,
                                                reg_map_name, register_address, bit_field_struct=bit_field_struct)
            self.assert_equal(results, expected_result,
                              "Check overall result for access mode %s for widget %s for bit field %s in "
                              "register %s" % (ACCESS_MODE.R_W,
                                               bit_field_type,
                                               bit_field_name,
                                               register_name))
        elif bit_field_type == BIT_FIELD_ATTR.Slider:
            results = {}
            expected_result = {}
            start_values = []
            end_values = []
            description_values = []
            descriptions = []
            min_values = []
            number_of_positions = None
            position_values = {}
            if 'Position' in list(values_to_test[0].keys()):
                number_of_positions = len(values_to_test)
                mid_position = number_of_positions / 2
            num_of_start = number_of_positions
            if 'Start' in list(values_to_test[0].keys()):
                num_of_start = sum(1 for key in values_to_test if 'Start' in key)
            reg_width_in_bytes = self.reg_width / 4
            for value_to_test in values_to_test:
                if 'Position' in list(value_to_test.keys()):
                    if value_to_test['Position'] == '1':
                        if "Start" in list(value_to_test.keys()):
                            position_values[1] = value_to_test['Start'].lower()
                        else:
                            position_values[1] = value_to_test['Value'].lower()
                        padded_value = position_values[1].replace('0x', '').rjust(reg_width_in_bytes, '0')
                        position_values[1] = '0x' + padded_value
                        start_values.append(builtins.int(position_values[1], 16))
                    elif value_to_test['Position'] == str(mid_position):
                        if not "Start" and "End" in list(value_to_test.keys()):
                            position_values[mid_position] = value_to_test['Value'].lower()
                            value = builtins.int(position_values[mid_position], 16)
                            test.log(" position_values[mid_position] == %s" % position_values[mid_position])
                            padded_value = position_values[mid_position].replace('0x', '').rjust(reg_width_in_bytes,
                                                                                                 '0')
                            position_values[mid_position] = '0x' + padded_value
                    elif value_to_test['Position'] == str(number_of_positions):
                        if "End" in list(value_to_test.keys()):
                            position_values[number_of_positions] = value_to_test['End'].lower()
                        else:
                            position_values[number_of_positions] = value_to_test['Value'].lower()
                        value = builtins.int(position_values[number_of_positions], 16)
                        if "End" in list(value_to_test.keys()):
                            if value == 0:
                                value = 2 ** self.get_bit_width(bit_field_location)
                                position_values[number_of_positions] = '0x' + '0' * reg_width_in_bytes
                        test.log(" position_values[number_of_positions] == %s" % position_values[number_of_positions])
                        padded_value = position_values[number_of_positions].replace('0x', '').rjust(reg_width_in_bytes,
                                                                                                    '0')
                        position_values[number_of_positions] = '0x' + padded_value
                        end_values.append(value)
                if 'Start' in list(value_to_test.keys()):
                    start_values.append(builtins.int(value_to_test['Start'], 16))
                    end_values.append(builtins.int(value_to_test['End'], 16))
                else:
                    description_values.append(value_to_test['Value'])
                    if value_to_test['Type'] == "Label":
                        descriptions.append(value_to_test['Description'])
                    elif value_to_test['Type'] == "Scaled":
                        descriptions.append(value_to_test['Multiplier'])
            start_value = min(start_values)
            end_value = max(end_values)
            mid_value = ((end_value - start_value) / 2)
            if start_value > 1:
                mid_value += start_value
            slider_values_to_test = [("max", end_value), ("min", start_value), ("mid", mid_value)]
            for st_val, en_val in zip(start_values, end_values):
                if st_val <= mid_value <= en_val:
                    break
                else:
                    mid_value = ((start_value - end_value) / 2)
                    if "Start" and "End" in list(value_to_test.keys()):
                        slider_values_to_test = [("max", end_value), ("min", start_value)]
                    else:
                        slider_values_to_test = [("max", end_value), ("mid", mid_value), ("min", start_value)]
            if number_of_positions is None:
                if descriptions and description_values:
                    for desc, desc_val in zip(descriptions, description_values):
                        desc_val = builtins.int(desc_val, 16)
                        slider_values_to_test.append((desc, desc_val))
            for index, slider_value in enumerate(slider_values_to_test):
                if slider_value[0] not in ['min', 'mid', 'max']:
                    if slider_value[1] < start_value:
                        min_values.append(slider_value[1])
            if len(min_values) > 0:
                min_value = min(min_values)
            else:
                min_value = start_value
            min_count = 0
            if len(min_values) != start_value:
                min_count = len(min_values)
                min_value = start_value
            for values in slider_values_to_test:
                _hex_value = builtins.hex(values[1])
                expected_result[_hex_value] = {REG_MAP: {BIT_FIELD_GUI_REPR.DEF: PASS_STEP,
                                                         BIT_FIELD_GUI_REPR.NUM: PASS_STEP}}
                results[_hex_value] = {}
                results[_hex_value][REG_MAP] = {}
                num_verification = self.test_slider(reg_map_obj, bit_field_name, value_range=values,
                                                    min_value=min_value, min_count=min_count,
                                                    bit_field_location=bit_field_location)
                if bit_field_name in self.wc_bit_fields:
                    bit_field_value = 0
                else:
                    bit_field_value = values[1]
                if number_of_positions and num_of_start == number_of_positions:
                    if values[0] == "min":
                        expected_value = position_values[1]
                    elif values[0] == "mid":
                        if start_value > end_value:
                            if start_value > 0:
                                expected_value = number_of_positions // 2
                            expected_value = builtins.hex(expected_value)
                            expected_value = '0x' + expected_value.replace('0x', '').rjust(reg_width_in_bytes, '0')
                        else:
                            bit_width = self.get_bit_width(bit_field_location)
                            value = 2 ** bit_width
                            expected_value = (value - builtins.int(position_values[1], 16)) / 2
                            if start_value > 0:
                                expected_value = expected_value + start_value
                            expected_value = builtins.hex(expected_value)
                            expected_value = '0x' + expected_value.replace('0x', '').rjust(reg_width_in_bytes, '0')
                    else:
                        expected_value = position_values[number_of_positions]
                    def_verification = self.verify_register_value_and_write_default_value(reg_default_value,
                                                                                          bit_field_value,
                                                                                          None,
                                                                                          None,
                                                                                          register_name,
                                                                                          reg_map_name,
                                                                                          register_address,
                                                                                          expected_value=expected_value,
                                                                                          bit_field_struct=bit_field_struct)
                else:
                    def_verification = self.verify_register_value_and_write_default_value(reg_default_value,
                                                                                          bit_field_value,
                                                                                          self.reg_width,
                                                                                          bit_field_address,
                                                                                          register_name,
                                                                                          reg_map_name,
                                                                                          register_address,
                                                                                          bit_field_struct=bit_field_struct)
                results[_hex_value][REG_MAP][BIT_FIELD_GUI_REPR.DEF] = def_verification[REG_MAP]
                results[_hex_value][REG_MAP][BIT_FIELD_GUI_REPR.NUM] = PASS_STEP if num_verification else FAIL_STEP
            self.assert_equal(results, expected_result,
                              "Check overall result for access mode %s for widget %s for bit field %s in "
                              "register %s" % (ACCESS_MODE.R_W,
                                               bit_field_type,
                                               bit_field_name,
                                               register_name))
        elif bit_field_type == BIT_FIELD_ATTR.ComboBox:
            values_to_test_list = []
            combo_values_to_test = []
            combo_description_to_test = []
            description_to_test = []
            results = {}
            # This flag is used in order to scroll to start and end to set start and end values
            scroll_flag = False
            expected_result = {}
            for value_to_test in values_to_test:
                try:
                    start_value = value_to_test['Start']
                    end_value = value_to_test['End']
                    base = eval(builtins.str(value_to_test['Base']))
                    multiplier = eval(builtins.str(value_to_test['Multiplier']))
                    mid_value = builtins.hex((builtins.int(end_value, 16) - builtins.int(start_value, 16))/2)
                    values_to_test_list.append(end_value)
                    values_to_test_list.append(start_value)
                    values_to_test_list.append(mid_value)
                    description_to_test = [builtins.int(val, 16) * multiplier + base for val in values_to_test_list]
                except KeyError:
                    if 'Value' in value_to_test:
                        combo_values_to_test.append(value_to_test['Value'])
                    elif 'Start' in value_to_test:
                        combo_values_to_test.append(value_to_test['Start'])
                    combo_description_to_test.append(value_to_test['Description'])
            len_combo_values_to_test = len(combo_values_to_test)
            # if combo box has values less that num_of_values_to_test
            # elif combo box has values more than num_of_values_to_test
            if 0 < len_combo_values_to_test < num_of_values_to_test:
                values_to_test_list = combo_values_to_test
                description_to_test = combo_description_to_test
            elif len_combo_values_to_test > num_of_values_to_test:
                mid_value = len_combo_values_to_test/2
                values_to_test_list.append(combo_values_to_test[0])
                values_to_test_list.append(combo_values_to_test[mid_value])
                values_to_test_list.append(combo_values_to_test[-1])
                description_to_test.append(combo_description_to_test[0])
                description_to_test.append(combo_description_to_test[mid_value])
                description_to_test.append(combo_description_to_test[-1])
                # As len_combo_values_to_test > num_of_values_to_test,assuming there is scroll bar in combo box,
                # so setting scroll_flag as True
                scroll_flag = True

            for index, value_to_test_verify in enumerate(values_to_test_list):
                combo_start_value = False
                combo_end_value = False
                # If scroll_flag and index is 0,set combo_start_value to True,to directly scroll the combo box to top
                # and set that value
                # If scroll_flag and index is 2,set combo_end_value to True,to directly scroll the combo box to down
                # and set that value
                if scroll_flag and index == 0:
                    combo_start_value = True
                elif scroll_flag and index == 2:
                    combo_end_value = True
                combo_value_desc = str(description_to_test[index])
                results[combo_value_desc] = {}
                results[combo_value_desc][REG_MAP] = {}
                num_verification = self.test_combo_box(reg_map_obj, bit_field_name, combo_value_desc,
                                                       value_to_test_verify, combo_start_value, combo_end_value)
                if bit_field_name in self.wc_bit_fields:
                    value_to_test_verify = 0
                expected_result[combo_value_desc] = {REG_MAP: {BIT_FIELD_GUI_REPR.DEF: PASS_STEP,
                                                               BIT_FIELD_GUI_REPR.NUM: PASS_STEP}}
                def_verification = self.verify_register_value_and_write_default_value(reg_default_value,
                                            value_to_test_verify, self.reg_width, bit_field_address,
                                            register_name, reg_map_name, register_address,
                                                                                      bit_field_struct=bit_field_struct)
                results[combo_value_desc][REG_MAP][BIT_FIELD_GUI_REPR.DEF] = def_verification[REG_MAP]
                results[combo_value_desc][REG_MAP][BIT_FIELD_GUI_REPR.NUM] = num_verification
            self.assert_equal(results, expected_result,
                              "Check overall result for access mode %s for widget %s for bit field %s in "
                              "register %s" % (ACCESS_MODE.R_W,
                                               bit_field_type,
                                               bit_field_name,
                                               register_name))
        elif bit_field_type == BIT_FIELD_ATTR.RadioButton:
            results = {}
            expected_result = {}
            radio_default = bit_field_struct.DefaultValue
            radio_inputs = {'Description': [],
                            'Value': []}
            for value_to_test in values_to_test:
                bit_field_title = value_to_test['Description']
                bit_field_value = value_to_test['Value']
                if bit_field_value != radio_default:
                    radio_inputs['Value'].insert(0, bit_field_value)
                    radio_inputs['Description'].insert(0, bit_field_title)
                else:
                    radio_inputs['Value'].append(bit_field_value)
                    radio_inputs['Description'].append(bit_field_title)

            for bit_field_title, bit_field_value in zip(radio_inputs['Description'], radio_inputs['Value']):
                expected_result[bit_field_title] = {REG_MAP: {BIT_FIELD_GUI_REPR.DEF: PASS_STEP,
                                                              BIT_FIELD_GUI_REPR.NUM: PASS_STEP}}
                results[bit_field_title] = {}
                results[bit_field_title][REG_MAP] = {}
                test.log("Writing bit_field_title:%s, Value:%s to field:%s, field type: %s " %
                         (bit_field_title, bit_field_value, bit_field_name, bit_field_type))
                InputActions.mouseClickOnItem(reg_map_obj.maximize)
                num_verification = self.test_radio_button(reg_map_obj, register_name, bit_field_name,
                                                          bit_field_title, bit_field_value)
                InputActions.mouseClickOnItem(reg_map_obj.minimize)
                if bit_field_name in self.wc_bit_fields:
                    bit_field_value = 0
                def_verification = self.verify_register_value_and_write_default_value(reg_default_value,
                                        bit_field_value, self.reg_width, bit_field_address,
                                        register_name, reg_map_name, register_address,
                                                                                      bit_field_struct=bit_field_struct)
                results[bit_field_title][REG_MAP][BIT_FIELD_GUI_REPR.DEF] = def_verification[REG_MAP]
                results[bit_field_title][REG_MAP][BIT_FIELD_GUI_REPR.NUM] = num_verification
            self.assert_equal(results, expected_result,
                              "Check overall result for access mode %s for widget %s for bit field %s in "
                              "register %s" % (ACCESS_MODE.R_W,
                                               bit_field_type,
                                               bit_field_name,
                                               register_name))

    def test_slider(self, reg_map_obj, bit_field_name, value_range, min_value, min_count, bit_field_location):
        """
        Method to test slider bit field, it verifies slider by setting min,mid and max values
        @param reg_map_obj: [RegisterMap] RegisterMap object instance
        @param bit_field_name: [str] Name of the bit field
        @param value_range: [tuple] Ex ("min", '0x0')
        @param min_value: [int] Minimum value of the slider
        @param min_count: [int] Minimum position of the slider
        @param bit_field_location: [str] Bit field location indexes
        @return: [dict] Slider bit field num representation status.
        """
        row = str(waitForObject(reg_map_obj.getRegisterFromBitFieldTable(bit_field_name)).cell.parent.index)
        slider = reg_map_obj.getSlider(reg_map_obj.getBitfieldCellArea("Value", row))
        w_val = value_range[1]
        if value_range[0] == "min":
            if value_range[1] == min_value and min_count > 0:
                w_val = value_range[1] - min_value
            elif min_count:
                w_val = value_range[1] - min_value + min_count
            elif min_value != 0:
                w_val = 0
        elif value_range[0] == "mid":
            if min_value > 0 and min_count != 0:
                w_val = value_range[1] - min_value
            elif min_count == 0 and min_value > value_range[1]:
                w_val = value_range[1]
            else:
                w_val = value_range[1] - min_value + min_count
        elif value_range[1] == min_value:
            w_val = value_range[1] - min_value
        elif min_value > value_range[1]:
            w_val = value_range[1] + min_value
            w_val = builtins.long(w_val)
        elif min_value > 0:
            w_val = value_range[1] - min_value + min_count
        slider_hex_val = builtins.hex(value_range[1])
        if 'L' in slider_hex_val:
            w_val = builtins.int(w_val)
        InputActions.set_slider_value(slider, w_val)
        # wait for slider to move
        slider_hex_val = slider_hex_val.split('x')
        bit_width = builtins.int(self.get_bit_width(bit_field_location) / 2)
        slider_hex_val[1] = slider_hex_val[1].rjust(bit_width, '0')
        slider_hex_val = 'x'.join(slider_hex_val)
        return BaseRegisterMap.check_bit_field_num_representation(reg_map_obj, bit_field_name, slider_hex_val)

    def test_radio_button(self, reg_map_obj, register_name, bit_field_name, bit_field_title, bit_field_value):
        """
        Set radio button to label bit field title
        @param reg_map_obj: [RegisterMap] RegisterMap object instance
        @param register_name: [str] Name of the register
        @param bit_field_name: [str] Name of the bit field
        @param bit_field_title: [str] Radio button value title
        @param bit_field_value: [hex] Bit field value to set
        @return: [dict] RadioButton bit field num representation status.
        """
        if len(bit_field_title) > 50:
            bit_field_title = bit_field_title[:50]
        InputActions.mouseClickOnItem(findObject(reg_map_obj.getRadioButton(reg_map_obj, register_name,
                                                                            bit_field_name, bit_field_title)),
                                      wait=False)
        return BaseRegisterMap.check_bit_field_num_representation(reg_map_obj, bit_field_name, bit_field_value)

    @staticmethod
    def check_bit_field_num_representation(reg_map_obj, bit_field_name, bit_field_value):
        """
        Verifies bit field num representation
        @param reg_map_obj: [RegisterMap] RegisterMap object instance
        @param bit_field_name: [str] Name of the bit field
        @param bit_field_value: [hex] Bit field value to set
        @return: [bool] Bit field num verification status
        """
        bit_field_obj = reg_map_obj.getRegisterFromBitFieldTable(bit_field_name)
        row = str(findObject(bit_field_obj).cell.parent.index)
        BaseRegisterMap.set_bit_field_toggle_state(reg_map_obj, BIT_FIELD_GUI_REPR.NUM)
        bit_field_value = bit_field_value.rstrip('L')
        bit_field_value = builtins.hex(builtins.int(bit_field_value, 16))
        return_value = ReadActions.checkValueFromBitFieldTable(reg_map_obj.getBitFieldTable(), row,
                                                               bit_field_value, return_value=True)
        BaseRegisterMap.set_bit_field_toggle_state(reg_map_obj, BIT_FIELD_GUI_REPR.DEF)
        num_verification = PASS_STEP if return_value == bit_field_value else FAIL_STEP
        return num_verification

    @staticmethod
    def set_bit_field_toggle_state(reg_map_obj, set_to_state, retries=30):
        """
        Method to set toggle Bit field toggle button to state 'NUM' or 'DEF'

        @param reg_map_obj: [RegisterMap] Register map class object
        @param set_to_state: [str] It can be 'NUM' or 'DEF'
        @param retries: [int] Number of times to retry setting bit field state
        """
        _retry = 0
        while _retry < retries:
            InputActions.mouseClickOnItem(reg_map_obj.getBitfieldToggleButton(set_to_state))
            snooze(0.2)
            if BaseRegisterMap.get_bit_field_toggle_state(reg_map_obj) != set_to_state:
                snooze(1)
                _retry += 1
            else:
                break

    @staticmethod
    def get_bit_field_toggle_state(reg_map_obj):
        """
        Method to get selected toggle string of bit field toggle button

        @param reg_map_obj: [RegisterMap] Register map class object
        @return [bool] returns selected state string of bit field toggle button
        """
        num_toggle_btn = reg_map_obj.getBitfieldToggleButton(BIT_FIELD_GUI_REPR.NUM)
        toggle_state = waitForObject(num_toggle_btn).getToggleGroup().getSelectedToggle().text
        return toggle_state

    def test_combo_box(self, reg_map_obj, bit_field_name, combo_box_item_caption, value_to_test_verify,
                       combo_start_value, combo_end_value):
        """
         Set combo box to a value which is in possible values list of combo box

        @param reg_map_obj: [RegisterMap] RegisterMap object instance
        @param bit_field_name: [str] Name of the bit field
        @param combo_box_item_caption: [str] Caption of the combobox element
        @param value_to_test_verify: [str] Expected bit field value
        @param combo_start_value: [str] Starting value of the Combobox
        @param combo_end_value: [str] Ending value of the Combobox
        @return: [bool] Combo box bit field num verification status
        """
        row = str(findObject(reg_map_obj.getRegisterFromBitFieldTable(bit_field_name)).cell.parent.index)
        InputActions.clickBitFieldComboBox(reg_map_obj.getBitFieldTable(), row, combo_box_item_caption,
                                           start_value=combo_start_value, end_value=combo_end_value)
        return BaseRegisterMap.check_bit_field_num_representation(reg_map_obj, bit_field_name,
                                                                  value_to_test_verify.lower())

    def test_text_field(self, reg_map_obj, bit_field_name, text_field_value, neg_case=False, warning_message=None):
        """
        Set text field with a value on register map

        @param reg_map_obj: [RegisterMap] RegisterMap object instance
        @param bit_field_name: [str] Name of the bit field
        @param text_field_value: [str] Text field value to written
        @param neg_case: [bool] writes invalid value to text field if true,else writes the value which is passed
        @param warning_message: [str] Tooltip message which is expected to be displayed on writing invalid value
        @return: [dict] Textfield bit field result status.
        """
        results = {}
        bit_field_obj = reg_map_obj.getRegisterFromBitFieldTable(bit_field_name)
        row = str(findObject(bit_field_obj).cell.parent.index)
        Common.changeRegisterValue("Value", row, reg_map_obj.getBitFieldTable(), text_field_value)
        if neg_case:
            text_box_real_name = reg_map_obj.getBitfieldCellArea('Value', row)
            results = self.check_warning_message(text_box_real_name, None, warning_message, check_warning_only=True,
                                                 print_assertion=False)
        return results

    def rw_dev_def_bit_fields(self, mode_to_test='R/W', reg_map_name=None, bit_field_type=None, neg_case=False,
                              num_of_values_to_test=5, log_msg=None):
        """
        This Method test all bit fields with access modes R/W,R/O,W/O

        @param mode_to_test: [ACCESS_MODE] Bit field access mode
        @param reg_map_name: [str] Register map caption
        @param bit_field_type: [str] Bit field widget type
        @param neg_case: [bool] Test case type
        @param num_of_values_to_test: [int] Number of values to test in Combo box
        @param log_msg: [str] log message for the test case

        """
        if not reg_map_name:
            reg_map_name = "%s (%s)" % (self.device_name, self.device_name)
        reg_map_obj = RegisterMap(reg_map_name)
        reg_counter = 0
        bit_field_counter = 0
        decrement_count = 0
        failed_bit_fields = []
        self.exp_reg_updates = []
        not_tested_registers = []
        Common.clearHistory(self.sys_name)
        for reg_name, reg_object in self.register_class_dict.items():
            if not self.soak and reg_counter >= self.sanity_reg_count:
                break
            bit_fields = reg_object.BitFields
            register_address = reg_object.Address
            register_name = reg_object.DisplayName
            if not register_name:
                register_name = reg_object.Name
            reg_default_value = reg_object.DefaultValue
            if reg_default_value is None and mode_to_test != ACCESS_MODE.R_O:
                fail_msg = "Couldn't test register: %s because default value is: %s" % (register_name,
                                                                                        reg_default_value)
                not_tested_registers.append({'register_name': register_name,
                                             'DefaultValue': fail_msg})
                test.fail(fail_msg)
                continue
            if register_name in self.reg_not_validate:
                test.log("Verifying register: %s is skipped" % register_name)
                continue
            selected_register = False
            increment_reg_counter = False
            for bit_field in bit_fields:
                bit_field_name = bit_field.Name
                if self.skip_bit_fields and bit_field_name in self.skip_bit_fields:
                    test.log('Bit field %s skipped' % bit_field_name)
                    increment_reg_counter = False
                    continue
                if bit_field.SoftwareAccess == ACCESS_MODE.W1C:
                    test.log('Skipped verifying Bit field %s because its '
                             'SoftwareAccess is "WIC"' % bit_field_name)
                    continue
                if bit_field.Access == mode_to_test:
                    if mode_to_test == ACCESS_MODE.R_O:
                        if not selected_register:
                            self.search_and_select_register(reg_map_name, register_name)
                            selected_register = True
                        increment_reg_counter = True
                        bit_field_counter += 1
                        self.check_if_bit_field_is_ro(reg_map_obj, bit_field_name)
                    elif mode_to_test == ACCESS_MODE.R_W:
                        values_to_test = [bit_field_value for bit_field_values in bit_field.Values
                                          for bit_field_value in bit_field_values]
                        if bit_field_type == bit_field.FieldType == BIT_FIELD_ATTR.RadioButton:
                            if self.BSP.Cornell == self.device_type:
                                if(builtins.bool(re.match('SWIRE[1-2]_DP[1-6]_PREPARE_CHANNEL[1-6]',
                                                             bit_field_name)
                                                    or bit_field_name == 'INTEXTCLK_SEL')):
                                    decrement_count += 1
                                    continue
                            if not selected_register:
                                self.search_and_select_register(reg_map_name, register_name)
                                selected_register = True
                            increment_reg_counter = True
                            bit_field_counter += 1
                            self.test_bit_field(reg_map_obj=reg_map_obj, register_name=register_name,
                                                register_address=register_address,
                                                bit_field_struct=bit_field, values_to_test=values_to_test,
                                                reg_default_value=reg_default_value, reg_map_name=reg_map_name,
                                                bit_field_type=BIT_FIELD_ATTR.RadioButton)
                        elif bit_field_type == bit_field.FieldType == BIT_FIELD_ATTR.ComboBox:
                            if not selected_register:
                                self.search_and_select_register(reg_map_name, register_name)
                                selected_register = True
                            increment_reg_counter = True
                            bit_field_counter += 1
                            self.test_bit_field(reg_map_obj=reg_map_obj, register_name=register_name,
                                                register_address=register_address,
                                                bit_field_struct=bit_field, values_to_test=values_to_test,
                                                reg_default_value=reg_default_value, reg_map_name=reg_map_name,
                                                bit_field_type=BIT_FIELD_ATTR.ComboBox,
                                                num_of_values_to_test=num_of_values_to_test)
                        elif bit_field_type == bit_field.FieldType == BIT_FIELD_ATTR.TextField:
                            if not selected_register or neg_case:
                                self.search_and_select_register(reg_map_name, register_name)
                                selected_register = True
                            increment_reg_counter = True
                            bit_field_counter += 1
                            self.test_bit_field(reg_map_obj=reg_map_obj, register_name=register_name,
                                                register_address=register_address,
                                                bit_field_struct=bit_field, values_to_test=values_to_test,
                                                reg_default_value=reg_default_value, reg_map_name=reg_map_name,
                                                bit_field_type=BIT_FIELD_ATTR.TextField, neg_case=neg_case)
                        elif bit_field_type == bit_field.FieldType == BIT_FIELD_ATTR.Slider:
                            if not selected_register:
                                self.search_and_select_register(reg_map_name, register_name)
                                selected_register = True
                            increment_reg_counter = True
                            bit_field_counter += 1
                            self.test_bit_field(reg_map_obj=reg_map_obj, register_name=register_name,
                                                register_address=register_address,
                                                bit_field_struct=bit_field, values_to_test=values_to_test,
                                                reg_default_value=reg_default_value, reg_map_name=reg_map_name,
                                                bit_field_type=BIT_FIELD_ATTR.Slider)
                    if(len(self.step_outcome()) > 1 and self.step_outcome()[-1] == FAIL_STEP
                            and bit_field_type == bit_field.FieldType):
                        failed_bit_fields.append(bit_field_name)
            if increment_reg_counter:
                reg_counter += 1
        if self.soak:
            if mode_to_test == ACCESS_MODE.R_O:
                field_count_rw = self.bit_ro_total
            elif mode_to_test == ACCESS_MODE.W_O:
                field_count_rw = self.bit_wo_total
            elif mode_to_test == ACCESS_MODE.R_W:
                if bit_field_type == BIT_FIELD_ATTR.TextField:
                    field_count_rw = self.text_total
                elif bit_field_type == BIT_FIELD_ATTR.RadioButton:
                    field_count_rw = self.radio_total
                elif bit_field_type == BIT_FIELD_ATTR.ComboBox:
                    field_count_rw = self.combo_total
                elif bit_field_type == BIT_FIELD_ATTR.Slider:
                    field_count_rw = self.slider_total
        else:
            field_count_rw = bit_field_counter
        field_count_rw = field_count_rw - decrement_count
        log_msg = log_msg + " field count %s" % str(field_count_rw)
        self.assert_equal(self.step_outcome().count(PASS_STEP), field_count_rw, log_msg)
        failed_bit_fields = set(failed_bit_fields)
        self.assert_equal(len(failed_bit_fields), 0,
                          log_msg + ", failed bit field count %s,failed bit fields %s" % (len(failed_bit_fields),
                                                                                          failed_bit_fields))
        if mode_to_test != ACCESS_MODE.R_O and bit_field_type != BIT_FIELD_ATTR.Slider and not neg_case:
            if Common.getHistoryLength(self.sys_name) != 0:
                Common.selectAllInHistory(self.sys_name)
                srs_file_name = self.__class__.__name__ + "_registers_updated.srs"
                srs_file_path = Common.exportAllHistory(self.sys_name, srs_file_name)
                # exporting may take time
                snooze(2)
                srs_file_path = os.path.realpath(srs_file_path)
                srs_file_con = self.parse_history_file(srs_file_path)
                self.assert_diff_in_dict_and_history(self.exp_reg_updates, srs_file_con,
                                                 "Verifying in history window: " + log_msg)
        elif mode_to_test == ACCESS_MODE.R_O:
            self.check_for_read_entries_in_history(field_count_rw)
        self.assert_equal(not_tested_registers, [], "Check if all registers are tested")

    def calculate_expected_bit_fields_counter(self):
        """
        Returns the R/O,W/O,Combo box,text field,radio button,slider bit fields count
        """
        combo_counter = 0
        text_field_counter = 0
        radio_button_counter = 0
        slider_counter = 0
        bit_wo_counter = 0
        bit_ro_counter = 0
        for register in self.register_not_validate:
            del self.register_class_dict[register]
        for reg_name, reg_object in self.register_class_dict.items():
            bit_fields = reg_object.BitFields
            for bit_field in bit_fields:
                if bit_field.Access == ACCESS_MODE.W_O:
                    bit_wo_counter += 1
                elif bit_field.Access == ACCESS_MODE.R_O:
                    bit_ro_counter += 1
                elif bit_field.Access == ACCESS_MODE.R_W and bit_field.SoftwareAccess != ACCESS_MODE.W1C:
                    if bit_field.FieldType == BIT_FIELD_ATTR.ComboBox:
                        combo_counter += 1
                    elif bit_field.FieldType == BIT_FIELD_ATTR.RadioButton:
                        radio_button_counter += 1
                    elif bit_field.FieldType == BIT_FIELD_ATTR.Slider:
                        slider_counter += 1
                    elif bit_field.FieldType == BIT_FIELD_ATTR.TextField:
                        text_field_counter += 1
        return bit_wo_counter, bit_ro_counter, combo_counter, text_field_counter, radio_button_counter, slider_counter

    def get_register_not_validate(self):
        """
        Returns a list of register names which are not recommended to be tested
        """
        registers_not_to_validate = []
        for register in self.each_register_info:
            register_name = register[REG_ATTR.Name]
            register_display_name = register.get(REG_ATTR.DisplayName)
            if register_name in self.reg_not_validate or register_display_name in self.reg_not_validate:
                registers_not_to_validate.append(register_name)
            if self.BSP.Cornell in self.device_type and \
                    builtins.int(register[REG_ATTR.Address], 16) > self.address_range:
                registers_not_to_validate.append(register_name)
        return registers_not_to_validate

    def calculate_expected_register_counter(self):
        """
        Returns the R/W,R/O,W/O registers counts
        """
        rw_counter = 0
        ro_counter = 0
        wo_counter = 0
        for register in self.each_register_info:
            register_name = register[REG_ATTR.Name]
            if register_name in self.register_not_validate:
                continue
            else:
                access_mode = register[REG_ATTR.Access]
                if access_mode == ACCESS_MODE.R_W:
                    rw_counter += 1
                elif access_mode == ACCESS_MODE.R_O:
                    ro_counter += 1
                elif access_mode == ACCESS_MODE.W_O:
                    wo_counter += 1
        return rw_counter, ro_counter, wo_counter

    def check_no_fields_in_ro_register(self, field_type, log_msg):
        """
        Checks if there are no fields with given widget type in R/O register
        @param field_type: [str] Widget type of the bit field
        @param log_msg: [str] log message for the test case
        """
        reg_counter = 0
        bit_field_counter = 0
        field_type_names = []
        for reg_name, reg_object in self.register_class_dict.items():
            if not self.soak and reg_counter >= self.sanity_reg_count:
                break
            bit_fields = reg_object.BitFields
            register_name = reg_object.DisplayName
            if not register_name:
                register_name = reg_object.Name
            if register_name in self.reg_not_validate:
                test.log("Verifying register: %s is skipped" % register_name)
                continue
            if reg_object.Access == ACCESS_MODE.R_O:
                reg_counter += 1
                for bit_field in bit_fields:
                    bit_field_counter += 1
                    if bit_field.FieldType == field_type:
                        field_type_names.append(bit_field.Name)
        self.assert_equal(field_type_names, [], "Tested Registers: %s, Bit fields: %s,"
                                                "%s" % (reg_counter, bit_field_counter, log_msg))
