# Copyright (c) 2017 Cirrus Logic, Inc and
# Cirrus Logic International Semiconductor Ltd.  All rights reserved.
#
# This software as well as any related documentation is furnished under
# license and may only be used or copied in accordance with the terms of the
# license.  The information in this file is furnished for informational use
# only, is subject to change without notice, and should not be construed as
# a commitment by Cirrus Logic.  Cirrus Logic assumes no responsibility or
# liability for any errors or inaccuracies that may appear in this document
# or any software that may be provided in association with this document.
#
# Except as permitted by such license, no part of this document may be
# reproduced, stored in a retrieval system, or transmitted in any form or by
# any means without the express written consent of Cirrus Logic.
#
# Warning
#   This software is specifically written for Cirrus Logic devices.
#   It may not be used with other devices.
#
## @file   bsp.py
## @brief  All BSP functions

# Examples: read name of xml, read name of pdf in installed folder, install bsp,...

import os
import sys
import re
import subprocess
import shutil
import errno
import fnmatch
import zipfile
import xml.etree.ElementTree as ET
import builtins

source(findFile("scripts", "squish_config.py"))
source(findFile("scripts", "input_actions.py"))
source(findFile("scripts", "projects.py"))
source(findFile("scripts", "read_actions.py"))
source(findFile("scripts", "real_names.py"))


class Bsp:

    @classmethod
    def addVirtualSystem(cls, vSystem, deuceDevice, timeToWait=40):
        """
        This method adds new white Virtual System
        Reads flag if white system Deuce or General Market and create system with given name
        @param vSystem[string] the name of the system
        @param timeToWait [int] time to wait for the creating virtual system
        @return deuceDevice[string] name of device

        """
        Common.addSimulatedSystem(vSystem, deuceDevice)
        while timeToWait > 0:
            if ReadActions.checkDirectoryTree(vSystem):
                return deuceDevice
                break
            else:
                timeToWait -= 1
                snooze(1)

    @classmethod
    def click_on_panel(self, panel_name, system, device=None, expand_dir_tree=False):
        test.log("Open %s panel" % panel_name)
        directory = Directory()
        panel = directory.getProjectName(panel_name)
        if object.exists(panel)and not expand_dir_tree:
            doubleClick(waitForObject(panel), 5, 5, 0, Button.Button1)
        else:
            ProjectOperation.expandAndCollapseAll("collapse")
            root_path = "Discovered systems"
            if device:
                panel_path = "->".join([root_path, system, device, panel_name])
            else:
                panel_path = "->".join([root_path, system, panel_name])
            ProjectOperation.expandDirectoryTree(panel_path)

    @classmethod
    def close_panel(cls, close_button_real_name):
        InputActions.mouseClickOnItem(close_button_real_name)

    @classmethod
    def execute_script(cls, system_name, script_path):
        return Common.execute_script_btn(system_name, script_path)

    @classmethod
    def check_for_reg_in_history(cls, system_name, register_addr, register_value):
        regs_updated = Common.parseHistoryTabAddressValue(system_name)

        for register in regs_updated:
            if register_addr in list(register.keys()):
                if register[register_addr] != register_value:
                    return False
                else:
                    return True
        Common.closeHistoryWindows()

    @classmethod
    def installPackage(cls, all_board_type, path_to_bsp, WORKING_PERSPECTIVE=False, checkingModality=False):
        """
        Install Board Support Package from Welcome Screen or from Tools->Install Package
        @param all_board_type  [string]  all board types witch bsp will be installed
        @param path_to_bsp [string]  path to the bsp
        @param WORKING_PERSPECTIVE [bool] default False(if Install Package Hyperlink exists)
                                             if it is True(Browse and select BSP that needs to be installed from Tools->Isntall package)
        @param checkingModality [bool] default False(modality of confirmation dialog will not be checked)
                                               True(modality of confirmation dialog will be checked)
        @return no return

        Steps:
        1) Browse and select BSP that needs to be installed
        2) Installation Successful pop up should be displayed
        3) <bsp name>.xml should be available in systems folder
        Usage:
        Bsp.installPackage("cdb42l42", "d:/SCS/install/board_support_package")
        Bsp.installPackage("cdb42l42", "d:/SCS/install/board_support_package", True)
        Bsp.installPackage("cdb42l42", "d:/SCS/install/board_support_package", True, True)
        Bsp.installPackage("cdb42l42 cdb46l41 ee42l75-apps-mb ee-sktamp-apps-l26-mono ee-sktamp-apps-l36-mono", "d:/SCS/install/board_support_package", True)
        """
        BSPConfirmShellObj = BSPConfirmShell()
        welcomeObj = Welcome()
        listOfBoardNames = all_board_type.split()
        bspPath = ""
        xmlPath = ""
        checkBoxValues = ["Install", "Reinstall", "Downgrade", "Upgrade"]
        status_flag = True
        for board_type in listOfBoardNames:
            board_type_copy = board_type
            if "_" in board_type:
                board_type = board_type.split("_")[0]
            snooze(0.5)
            for root, _, filenames in os.walk(path_to_bsp):
                for filename in fnmatch.filter(filenames, board_type + '*.scspkg'):
                    bspPath = os.path.join(root, filename)
                    if board_type_copy == "cs46l41" or board_type_copy == "cs46l06" or board_type_copy == "cs47l60":
                        xmlPath = SquishConfig().BSP_PATH + "systems" + os.sep + "cdb" + board_type[2:] + os.sep + "cdb" + board_type_copy[2:] + ".xml"
                    else:
                        xmlPath = SquishConfig().BSP_PATH + "systems" + os.sep + board_type + os.sep + board_type_copy + ".xml"

            if WORKING_PERSPECTIVE == True:

                """Browse and select BSP that needs to be installed """
                InputActions.activateMenuItem("Tools->Install Package")
                chooseFile(waitForObject(":SWT"), bspPath)

                for checkbox in checkBoxValues:
                    test.log("Checkbox: %s" % checkbox)
                    if object.exists(BSPConfirmShellObj.getCheckbox(checkbox)):
                        if ReadActions.getPropertyOfObject(BSPConfirmShellObj.getCheckbox(checkbox), "selected") == \
                                "False":
                            InputActions.mouseClickOnButton(BSPConfirmShellObj.getCheckbox(checkbox))
                            break
                    else:
                        test.log("%s checkbox not present" % checkbox)

                """Installation Successful pop up should be displayed """
                try:
                    waitForObject(BSPConfirmShellObj.getConfirmShellButton("INSTALL"), 10000)
                    InputActions.mouseClickOnButton(BSPConfirmShellObj.getConfirmShellButton("INSTALL"))
                    waitForObject(BSPConfirmShellObj.getConfirmShellButton("DONE"), 90000)
                    test.passes("PASS", "Message: 'Package installation successful' is shown")
                    InputActions.mouseClickOnButton(BSPConfirmShellObj.getConfirmShellButton("DONE"))
                except LookupError:
                    test.fail("FAIL", "Message: 'Package installation successful' is not shown")
                    status_flag = False

                """<bsp name>.xml should be available in systems folder"""
                if board_type != "internal":
                    if os.path.exists(xmlPath):
                        test.passes("PASS", "Package is installed successfully. " + board_type_copy + ".xml exists in system folder")
                    else:
                        test.fail("FAIL", "Can not find " + board_type_copy + ".xml")
                        status_flag = False
            else:
                """ if Install Package Hyperlink exists """
                if object.exists(welcomeObj.getInstallPackageHyperlinkLink()):
                    """ Browse and select BSP that needs to be installed """
                    InputActions().mouseClickOnItem(welcomeObj.getInstallPackageHyperlinkLink())
                    snooze(0.5)
                    chooseFile(waitForObject(":SWT"), bspPath)

                    """ Installation Successful pop up should be displayed """
                    if object.exists(BSPConfirmShellObj.getConfirmShellButton("INSTALL")):
                        if checkingModality:
                            ReadActions.checkObjectExists(welcomeObj.getWelcomeWindow())
                            InputActions.mouseClickOnItem(MainShell().getMainWindow(), "middle", False)
                            nativeType("<Escape>")
                            test.passes("PASS", "confirmation (or error) dialog is modal")
                        else:
                            snooze(0.5)
                            InputActions.mouseClickOnButton(BSPConfirmShellObj.getConfirmShellButton("INSTALL"))
                            snooze(0.5)
                            InputActions.mouseClickOnButton(BSPConfirmShellObj.getConfirmShellButton("OK"))
                        test.passes("PASS", "Message: 'Package installation successful' is shown")
                    else:
                        test.fail("FAIL", "Message: 'Package installation successful' is not shown")
                        status_flag = False

                    """ <bsp name>.xml should be available in systems folder """
                    print(xmlPath)
                    if os.path.exists(xmlPath):
                        test.passes("PASS", "Package is installed successfully. " + board_type_copy + ".xml exists in system folder")
                        """ Wait 3 seconds, after that message NO INSTALLED PACKAGES should be removed"""
                        snooze(3)
                        if object.exists(welcomeObj.getNoInstallPackageLabel()):
                            test.fail("FAIL", "message NO INSTALLED PACKAGES still exists")
                    else:
                        test.fail("FAIL", "Can not find " + board_type_copy + ".xml")
                        status_flag = False
                else:
                    test.fail("FAIL", welcomeObj.getInstallPackageHyperlinkLink() + " does not exist")
                    status_flag = False
        return status_flag

    @classmethod
    def removePackage(cls):
        """
        Removes all installed packages

        @return no return

        Usage:
        Bsp.removePackage()
        """
        testMachine = platform.system()
        pathSystem = SquishConfig().BSP_PATH + "systems"
        pathToPackageXML = SquishConfig().BSP_PATH + "package_manager" + os.sep + "SCS_Packages.xml"
        pathToVerson = SquishConfig().BSP_PATH + "version"
        if "Windows" in testMachine:
            if os.path.isdir(pathSystem):
                shutil.rmtree(pathSystem, ignore_errors=True)
            if os.path.isfile(pathToPackageXML):
                os.remove(pathToPackageXML)
            if os.path.isdir(pathToVerson):
                shutil.rmtree(pathToVerson, ignore_errors=True)
        elif "Darwin" in testMachine:
            password = SuiteGlobals.getPassword()
            pathSystem = os.sep + pathSystem
            pathToVerson = os.sep + pathToVerson
            pathToPackageXML = os.sep + pathToPackageXML
            cmd = "echo " + "'" + password + "'" + " | " + "sudo -S rm -rdf " + "'" + pathSystem + "'"
            proc = subprocess.call(cmd, shell=True)
            cmd = "echo " + "'" + password + "'" + " | " + "sudo -S rm -rdf " + "'" + pathToVerson + "'"
            proc = subprocess.call(cmd, shell=True)
            cmd = "echo " + "'" + password + "'" + " | " + "sudo -S rm -rdf " + "'" + pathToPackageXML + "'"
            proc = subprocess.call(cmd, shell=True)

    @classmethod
    def registerElementsFromXml(cls, devicesOrSystems, deviceOrSystem):
        """
        Read name element from xml file and returns

        @param devicesOrSystems [string] can be devices or systems
        @param deviceOrSystem   [string] name of system or device

        @return lineInComment [string] system/device description for name/type

        Usage:
        Bsp.registerElementsFromXml("devices", "cs42l42")
        Bsp.registerElementsFromXml("systems", "cdb42l42")
        """
        pathToXmlFolder = SuiteGlobals.getItemFromInstalledBsp(devicesOrSystems, deviceOrSystem)
        for root, dirnames, filenames in os.walk(pathToXmlFolder):
                for filename in fnmatch.filter(filenames, deviceOrSystem + '*.xml'):
                    pathToXmlFile = pathToXmlFolder + filename
                    tree = ET.parse(pathToXmlFile)
                    root = tree.getroot()

                    if devicesOrSystems == "systems":
                        for name in root.findall('Name'):
                            name = (name.text).upper()
                            lineInComment = "== @brief  System description for " + name
                            return lineInComment
                    elif devicesOrSystems == "devices":
                        for deviceInfo in root.findall('DeviceInfo'):
                            for type in deviceInfo.findall('Type'):
                                type = (type.text).upper()
                                lineInComment = "== @brief  Device description for " + type
                                return lineInComment

    @classmethod
    def checkBSPVersion(cls, path_to_dir, fileName):
        """
        Read the version of BSP from system explorer

        @param path_to_dir [string] path to bsp dir
        @param fileName   [string] name of the bsp file

        @return fullVersion [string] return nameOfFile:versionOfFile

        Usage:
        Bsp.checkBSPVersion(SuiteGlobals.getBspVersionPath(), "CDB42L42 BSP.xml")
        """
        fileName = fileName + ".xml"
        fileNameWithoutExtenstion = fileName[:fileName.rfind(".xml")]

        os.chdir(path_to_dir)
        for file in glob.glob(fileName):
            openedFiles = ET.parse(file)
            root = openedFiles.getroot()
            for bspInfo in root.findall('bspCreationInfo'):
                bspName = bspInfo.find('packageName').text
                bspVersion = bspInfo.find('packageVersion').text

            fullVersion = bspName + ": " + bspVersion
            return fullVersion

    @classmethod
    def checkPdfInInstalledBsp(cls, devicesOrSystems, deviceOrSystem):
        """
        Read the name of pdf in device

        @param devicesOrSystems [string] this can be devices or systems
        @param deviceOrSystem [string] this contains name of device or system

        @return filename [string] name of the pdf file with extension

        Usage:
        Bsp.checkPdfInInstalledBsp("devices", "cs42l42")
        """
        pathToPdf = SuiteGlobals.getItemFromInstalledBsp(devicesOrSystems, deviceOrSystem)
        nameOfPdf = deviceOrSystem.upper()
        for root, dirnames, filenames in os.walk(pathToPdf):
            for filename in fnmatch.filter(filenames, nameOfPdf + '*.pdf'):
                return filename

    @classmethod
    def checkPdfFromScspkgFile(cls, device):
        """
        Read the name of pdf file in .scspkg file

        @param device [string] name of device

        @return filename [string] name of the pdf file with extension

        Usage:
        Bsp.checkPdfFromScspkgFile("cs42l42")
        """
        pathToPdf = SuiteGlobals.getPdfFromScspkgFile(device)
        nameOfPdf = device.upper()
        for root, dirnames, filenames in os.walk(pathToPdf):
            for filename in fnmatch.filter(filenames, nameOfPdf + '*.pdf'):
                return filename

    @classmethod
    def checkSuiteBoardName(cls):
        """
        Read the name of suite in bsp suite.

        @return filename [string] returns name of .scspkg file with extension

        Usage:
        Bsp.checkSuiteBoardName()
        """
        pathToSuiteBoardname = SuiteGlobals.PATH_TO_REFDATA_FOLDER
        for root, dirnames, filenames in os.walk(pathToSuiteBoardname):
            for filename in fnmatch.filter(filenames, '*.scspkg'):
                return filename

    @classmethod
    def checkXmlInInstalledBsp(cls, devicesOrSystems, deviceOrSystem, splitName=False):
        """
        Read the name of xml in device

        @param devicesOrSystems [string] this can be devices or systems
        @param deviceOrSystem [string] name of devices of system
        @param splitName [bool] default False (file name will not be splited)
                                        True (file name will be splitet)
        @return filename [string] return name of xml with extension
        @return file [string] return only name of xlm without extension
        Usage:
        Bsp.checkXmlInInstalledBsp("devices", "cs42l42")
        Bsp.checkXmlInInstalledBsp("systems", "cdb42l42", True)
        """
        pathToXml = SuiteGlobals.getItemFromInstalledBsp(devicesOrSystems, deviceOrSystem)
        if(os.path.exists(pathToXml)):
            if splitName == False:
                for root, dirnames, filenames in os.walk(pathToXml):
                    for filename in fnmatch.filter(filenames, deviceOrSystem + '*.xml'):
                        return filename

            elif splitName == True:
                for root, dirnames, filenames in os.walk(pathToXml):
                    for filename in fnmatch.filter(filenames, deviceOrSystem + "*.xml"):
                        file = filename.split(".")[0]
                        return file
        else:
            return None

    @classmethod
    def readLineFromCommentInXmlFile(cls, devicesOrSystems, deviceOrSystem, lineStartsWith):
        """
        Reads the exact line that starts with parameter "lineStartsWith" from xml file

        @param devicesOrSystems [string] this can be devices or systems
        @param deviceOrSystem [string] name of devices of system
        @param lineStartsWith [string] line that is in our interests should starts with this string

        @return line [string] return line that start with lineStartsWith, 
                              if there is no line that starts with lineStartsWith return "Fail"

        Usage:
        Bsp.readLineFromCommentInXmlFile("systems", "cdb42l42", "== @file")
        """
        pathToXml = SuiteGlobals.getItemFromInstalledBsp(devicesOrSystems, deviceOrSystem)
        for root, dirnames, filenames in os.walk(pathToXml):
            for filename in fnmatch.filter(filenames, deviceOrSystem + "*.xml"):
                path = os.path.join(root, filename)
                with open(path) as opened_file:
                    line_in_file = opened_file.readlines()
                for line in line_in_file:
                    if re.match(lineStartsWith, line):
                        if line[11] != " " and line[2] == " ":
                            return line
                        else:
                            return "FAIL"

    @classmethod
    def unzipScskpgFile(cls, scspkgFile):
        """
        This method unzip a zipped file

        @param scspkgFile [file] file that will be extract

        @return no return

        Usage:
        Bsp.unzipScskpgFile(scspkgFile)
        """
        path_to_scspkg = SuiteGlobals.getItemFromRefData(scspkgFile)
        extractedFolder = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + "extractedFolder"

        if not os.path.exists(extractedFolder):
            os.makedirs(extractedFolder)
        snooze(3)
        file = open(path_to_scspkg, 'rb')
        zip = zipfile.ZipFile(file)
        for name in zip.namelist():
            outpath = (extractedFolder)
            zip.extract(name, outpath)
        file.close()

    @classmethod
    def devicesFromSystemXml(cls, system, type=None, nameOfDevice=None):
        """
        Read name or type or folder name of device() from system xml file

        @param system [string] name of the system
        @param type [string] default is None, type of the system
        @param nameOfDevice [string] default is None, name of device

        @return lstOfDevicesFromXml [list] list of devices from xml

        Usage:
        Bsp.devicesFromSystemXml("cdb42l42")
        Bsp.devicesFromSystemXml("cdb42l42", "cs42l42")
        Bsp.devicesFromSystemXml("cdb42l42", "usb_audio_module")
        Bsp.devicesFromSystemXml("cdb42l42", None, "UBS Audio Module")
        """
        lstOfDevicesFromXml = []
        systems = "systems"
        pathToXmlFolder = SuiteGlobals.getItemFromInstalledBsp(systems, system)
        for root, dirnames, filenames in os.walk(pathToXmlFolder):
            for filename in fnmatch.filter(filenames, system + '*.xml'):
                pathToXmlFile = pathToXmlFolder + filename
                tree = ET.parse(pathToXmlFile)
                root = tree.getroot()
                if type != None:
                    for devices in root.findall('Devices'):
                        for device in devices.findall('Device'):
                            for name in device.findall('Name'):
                                if name.text == type:
                                    for definitionPath in device.findall('DefinitionPath'):
                                        definitionPath = definitionPath.text
                                        words = definitionPath.split("/")
                                        lstOfDevicesFromXml.append(words[3])
                elif nameOfDevice != None:
                    for devices in root.findall('Devices'):
                        for device in devices.findall('Device'):
                            for name in device.findall('Name'):
                                lstOfDevicesFromXml.append(name.text)
                else:
                    for devices in root.findall('Devices'):
                        for device in devices.findall('Device'):
                            for definitionPath in device.findall('DefinitionPath'):
                                definitionPath = definitionPath.text
                                words = definitionPath.split("/")
                                lstOfDevicesFromXml.append(words[3])
        return lstOfDevicesFromXml

    @classmethod
    def searchForValueInBitField(cls, deviceName, bitFieldName, valueToFind):
        """
        Search for value in a bit field in description xml

        @param deviceName  [string] name of device
        @param bitFieldName [string] name in bit field
        @param valueToFind [string] value to find in bitFieldName

        @return no return

        Usage:
        Bsp.searchForValueInBitField("cs42l42", "OSC_SW_SEL_STAT" , "Reserved")
        """

        xmlPath = SuiteGlobals.getBspPath() + "devices" + os.sep + deviceName + os.sep + deviceName + ".xml"
        tree = ET.parse(xmlPath)
        root = tree.getroot()
        failFlag = False

        for fields in root.findall("Fields"):
            for field in fields.findall("Field"):
                for name in field.findall("Name"):
                    if bitFieldName == name.text:
                        for values in field.findall("Values"):
                            for value in values.findall("Value"):
                                for description in value.findall("Description"):
                                    if description.text == valueToFind:
                                        failFlag = True
        if failFlag:
            test.fail("FAIL", "Value '" + valueToFind + "' found in " + bitFieldName + " in bit field " + xmlPath)
        else:
            test.passes("PASS", "Value '" + valueToFind + "' not found in " + bitFieldName + " in bit field " + xmlPath)

    @classmethod
    def removeTemporaryAndRestorePackages(cls, removeOrRestore):
        """
        This method removes (rename systems and version folders - add "_" to folder name) or
        restore packages (restore folder names - delete "_" from folder name)

        @param removeOrRestore [Bool] if true remove packages, if false restore packages
        @return no return

        Usage:
        Bsp.removeTemporaryAndRestorePackages(True)
        Bsp.removeTemporaryAndRestorePackages(False)
        """
        testMachine = platform.system()
        if "Windows" in testMachine:
            systemsPath = SuiteGlobals.getBspPath() + "systems"
            newSystemsPath = SuiteGlobals.getBspPath() + "_systems"
            pathToVerson = SuiteGlobals.getBspPath() + "version"
            newPathToVerson = SuiteGlobals.getBspPath() + "_version"
        elif "Darwin" in testMachine:
            systemsPath = os.sep + SuiteGlobals.getBspPath() + "systems"
            newSystemsPath = os.sep + SuiteGlobals.getBspPath() + "_systems"
            pathToVerson = os.sep + SuiteGlobals.getBspPath() + "version"
            newPathToVerson = os.sep + SuiteGlobals.getBspPath() + "_version"
        else:
            sys.exit("OS not found")

        if removeOrRestore == True:
            """ rename systems folder """
            if os.path.isdir(systemsPath):
                os.rename(systemsPath, newSystemsPath)
                test.log(systemsPath + "changed to ", newSystemsPath)
            else:
                test.log(systemsPath + " does not exist")
            """ rename version folder """
            if os.path.isdir(pathToVerson):
                os.rename(pathToVerson, newPathToVerson)
                test.log(pathToVerson + "changed to ", newPathToVerson)
            else:
                test.log(pathToVerson + " does not exist")
        else:
            """ restore systems folder name"""
            if os.path.isdir(newSystemsPath):
                os.rename(newSystemsPath, systemsPath)
                test.log(newSystemsPath + "changed to ", systemsPath)
            else:
                test.log(newSystemsPath + " does not exist")
            """ restore version folder name"""
            if os.path.isdir(newPathToVerson):
                os.rename(newPathToVerson, pathToVerson)
                test.log(newPathToVerson + "changed to ", pathToVerson)
            else:
                test.log(newPathToVerson + " does not exist")

    @classmethod
    def uninstallPackage(cls, all_board_type, path_to_bsp, WORKING_PERSPECTIVE=False, checkingModality=False):
        """
        @param all_board_type  [string]  all board types witch bsp will be uninstalled
        @param path_to_bsp [string]  path to the bsp
        @param WORKING_PERSPECTIVE [bool] default False
                                             if it is True(Browse and select BSP that needs to be uninstalled from Tools->Unisntall package)
        @param checkingModality [bool] default False(modality of confirmation dialog will not be checked)
                                               True(modality of confirmation dialog will be checked)
        @return no return

        Usage:
        Bsp.uninstallPackage("cdb42l42", "d:/SCS/board_support_package")
        Bsp.uninstallPackage("cdb42l42", "d:/SCS/board_support_package", True)
        Bsp.uninstallPackage("cdb42l42", "d:/SCS/board_support_package", True, True)
        Bsp.uninstallPackage("cdb42l42 cdb46l41 ee42l75-apps-mb ee-sktamp-apps-l26-mono ee-sktamp-apps-l36-mono", "d:/SCS/board_support_package", True)
        """
        BSPConfirmShellObj = BSPConfirmShell()
        BSPUnistanShellObj = BSPUninstallShell()
        welcomeObj = Welcome()
        listOfBoardNames = all_board_type.split()
        bspPath = ""
        xmlPath = ""
        bspUninstallPath = ""
        path_to_bsp_package_manager = SuiteGlobals.getBspPath() + "package_manager" + os.sep + "bsps"
        for board_type in listOfBoardNames:
            snooze(0.5)
            for root, dirnames, filenames in os.walk(path_to_bsp):
                for filename in fnmatch.filter(filenames, board_type + '*.scspkg'):
                    bspPath = os.path.join(root, filename)
                    if board_type == "cs46l41":
                        xmlPath = SuiteGlobals.getBspPath() + "systems" + os.sep + "cdb" + board_type[2:] + os.sep + "cdb" + board_type[2:] + ".xml"
                    else:
                        xmlPath = SuiteGlobals.getBspPath() + "systems" + os.sep + board_type + os.sep + board_type + ".xml"
                for filename in os.listdir(path_to_bsp_package_manager):
                    bspUninstallPath = path_to_bsp_package_manager + os.sep + filename

            if WORKING_PERSPECTIVE == True:

                """Browse and select BSP that needs to be uninstalled """
                InputActions.activateMenuItem("Tools->Uninstall Package")
                chooseFile(waitForObject(":SWT"), bspUninstallPath)

                """Uninstallation Successful pop up should be displayed """
                try:
                    waitForObject(BSPUnistanShellObj.getUninstallShellButton("OK"), 10000)
                    test.passes("PASS", "BSP uninstallation shell poped up.")
                    InputActions.mouseClickOnButton(BSPUnistanShellObj.getUninstallShellButton("OK"))
                except LookupError:
                    test.fail("FAIL", "BSP uninstallation shell did not pop up.")

                """<bsp name>.xml should not be available in systems folder"""
                if os.path.exists(xmlPath):
                    test.fail("FAIL", "Package is not uninstalled " + board_type + ".xml exists in system folder")
                else:
                    test.passes("PASS", "Package is uninstalled! Could not find " + board_type + ".xml")

    @classmethod
    def uninstallPackageError(cls, all_board_type, path_to_bsp, WORKING_PERSPECTIVE=False, checkingModality=False):
        """
        @param all_board_type  [string]  all board types witch bsp will be uninstalled
        @param path_to_bsp [string]  path to the bsp
        @param WORKING_PERSPECTIVE [bool] default False
                                             if it is True(Browse and select BSP that needs to be uninstalled from Tools->Unisntall package)
        @param checkingModality [bool] default False(modality of confirmation dialog will not be checked)
                                               True(modality of confirmation dialog will be checked)
        @return no return

        Usage:
        Bsp.uninstallPackage("cdb42l42", "d:/SCS/board_support_package")
        Bsp.uninstallPackage("cdb42l42", "d:/SCS/board_support_package", True)
        Bsp.uninstallPackage("cdb42l42", "d:/SCS/board_support_package", True, True)
        Bsp.uninstallPackage("cdb42l42 cdb46l41 ee42l75-apps-mb ee-sktamp-apps-l26-mono ee-sktamp-apps-l36-mono", "d:/SCS/board_support_package", True)
        """

        listOfBoardNames = all_board_type.split()
        errorShellObj = ErrorShell()
        bspPath = ""
        xmlPath = ""
        bspUninstallPath = ""
        path_to_bsp_package_manager = SuiteGlobals.getBspPath() + "package_manager" + os.sep + "bsps"
        for board_type in listOfBoardNames:
            snooze(0.5)
            for root, dirnames, filenames in os.walk(path_to_bsp):
                for filename in fnmatch.filter(filenames, board_type + '*.scspkg'):
                    bspPath = os.path.join(root, filename)
                    if board_type == "cs46l41":
                        xmlPath = SuiteGlobals.getBspPath() + "systems" + os.sep + "cdb" + board_type[2:] + os.sep + "cdb" + board_type[2:] + ".xml"
                    else:
                        xmlPath = SuiteGlobals.getBspPath() + "systems" + os.sep + board_type + os.sep + board_type + ".xml"
                for filename in os.listdir(path_to_bsp_package_manager):
                    bspUninstallPath = path_to_bsp_package_manager + os.sep + filename

            if WORKING_PERSPECTIVE == True:

                """Browse and select BSP that needs to be uninstalled """
                InputActions.activateMenuItem("Tools->Uninstall Package")
                chooseFile(waitForObject(":SWT"), bspUninstallPath)
                try:
                    waitForObject(errorShellObj.getErrorShellButton("OK"), 10000)
                    test.passes("PASS", "BSP uninstallation shell poped up.")
                    InputActions.mouseClickOnButton(errorShellObj.getErrorShellButton("OK"))
                except LookupError:
                    test.fail("FAIL", "BSP uninstallation shell did not pop up.")

    @classmethod
    def uninstallBSP(cls, bsp):
        """
        This method unistalles passed bsp
        @param bsp  [string]  board type witch bsp will be uninstalled

        @return no return

        Usage:
        Bsp.uninstallBSP("cdb42l42")
        """
        timeToWait = 30
        timer = 0
        uninstallPackagesShellObj = UninstallPackagesShell()
        packageUninstallSuccessfulObj = PackageUninstallSuccessful()
        InputActions.activateMenuItem("Tools->Uninstall Package")
        
        try:
            if object.exists(uninstallPackagesShellObj.getUninstallBSPCheckBox(bsp.upper())):
                InputActions.mouseClickOnItem(uninstallPackagesShellObj.getUninstallBSPCheckBox(bsp.upper()))
                InputActions.mouseClickOnItem(uninstallPackagesShellObj.getButton("OK"))
                test.passes("PASS", "BSP is found in the Uninstall packages list")
                snooze(2)
            else:
                test.fail("FAIL", "Uninstall list is empty")
        except:
                test.fail("FAIL", "Unable to find object")

        while timer < timeToWait:
            if object.exists(packageUninstallSuccessfulObj.getButton("OK")):
                InputActions.mouseClickOnItem(packageUninstallSuccessfulObj.getButton("OK"))
                test.passes("PASS", "BSP uninstallation is successful.")
                timer = 0
                break
            elif object.exists(errorShellObj.getTitleLabel("Error")):
                InputActions.mouseClickOnItem(errorShellObj.getErrorShellButton("OK"))
                test.fail("FAIL", "BSP uninstallation was NOT successful.")
                timer = 0
                break
            else:
                timer += 1
                snooze(1)
                
    @classmethod
    def uninstallBSPWithLowerCaracters(cls, bsp):
        """
        This method unistalles passed bsp
        @param bsp  [string]  board type witch bsp will be uninstalled

        @return no return

        Usage:
        Bsp.uninstallBSP("CS47L6x INTERNAL")
        """
        uninstallPackagesShellObj = UninstallPackagesShell()
        packageUninstallSuccessfulObj = PackageUninstallSuccessful()
        errorShellObj = ErrorShell()
        InputActions.activateMenuItem("Tools->Uninstall Package")
        InputActions.mouseClickOnItem(uninstallPackagesShellObj.getUninstallBSPCheckBox(bsp))
        InputActions.mouseClickOnItem(uninstallPackagesShellObj.getButton("OK"))
        snooze(5)
        if object.exists(packageUninstallSuccessfulObj.getButton("OK")):
            InputActions.mouseClickOnItem(packageUninstallSuccessfulObj.getButton("OK"))
        elif object.exists(errorShellObj.getErrorShell()):
            test.fail("FAIL", bsp + " is not instaled correctly")
            InputActions.mouseClickOnButton(errorShellObj.getErrorShellButton("OK"))
        else:
            test.fail("FAIL", "There is no shel about instalation package")

    @classmethod
    def getFolderPathsFromMetadataXml(cls, xmlPath):
        """
        @param xmlPath  [string]  path to .xml metadata file from bsp.pkg package
        @return list of paths to folders listed in metadata .xml file

        Usage:
        Bsp.getFolderPathsFromMetadataXml(xmlPath)
        """
        paths = []
        folderPaths = []
        tree = ET.parse(xmlPath)
        root = tree.getroot()
        bspResources = None
        for child in root:
            if child.tag == "bspResources":
                bspResources = child
        for bspResource in bspResources:
            for bspResourceChild in bspResource:
                if bspResourceChild.tag == "path":
                    paths.append(str(bspResourceChild.text))

        for path in paths:
            directoryPath = os.path.dirname(path)
            directoryName = directoryPath.split("/")
            folderPaths.append(str(directoryName[len(directoryName) - 1]))

        return folderPaths

    @classmethod
    def checkUninstalledBSP(cls, bsp):
        """
        This method tries to unistall passed bsp
        @param bsp  [string]  board type witch bsp will be uninstalled

        @return no return

        Usage:
        Bsp.checkUninstalledBSP("cdb42l42")
        """
        uninstallPackagesShellObj = UninstallPackagesShell()
        packageUninstallSuccessfulObj = PackageUninstallSuccessful()
        InputActions.activateMenuItem("Tools->Uninstall Package")
        try:
            #InputActions.mouseClickOnItem(uninstallPackagesShellObj.getUninstallBSPCheckBox(bsp.upper()))
            if object.exists(uninstallPackagesShellObj.getUninstallBSPCheckBox(bsp.upper())):
                test.fail("FAIL", "Uninstall list is not empty")
            else:
                test.passes("PASS", "Uninstall list is empty")
        except:
                test.fail("FAIL", "Unable to find object")

        InputActions.mouseClickOnItem(uninstallPackagesShellObj.getButton("OK"))
        if object.exists(packageUninstallSuccessfulObj.getButton("OK")):
            InputActions.mouseClickOnItem(packageUninstallSuccessfulObj.getButton("OK"))

    @classmethod
    def checkIfPackageInstalled(cls, boardName, packageName, install=True, reset=False):
        """
        This method checks if packageName is installed or not. This method can uninstall or install package given
        by package name. For more information read @param install

        @param packageName [string] name of package you want to check if its installed
        @param reset [bool] if reset is True, SCS will restart.
        @param install [bool] if install is True, method will install package. If False, method will uninstall package

        Usage:
        Bsp.checkIfPackageInstalled("cdb47l50", "internal")
        Bsp.checkIfPackageInstalled("cdb47l50", "internal", True, True)
        Bsp.checkIfPackageInstalled("cdb47l50", "internal", False, True)
        """
        aboutObj = HelpAboutShell()
        helpLabel = ""

        if "Windows" in platform.system():
            InputActions.activateMenuItem("Help->About")
        elif "Darwin" in platform.system():
            InputActions.activateMenuItem("SoundClear Studio->About SoundClear Studio")
        elif "Linux" in platform.system():
            pass
        else:
            sys.exit("OS not found.")

        try:
            helpLabel = str(getattr(waitForObjectExists(aboutObj.getBspVersionShell(packageName)), "text"))
        except Exception as e:
            test.log("Unable to find the package name due to: "+str(e))

        test.log("Closing About window")
        InputActions.mouseClickOnItem(aboutObj.getCloseAboutSCS())

        if packageName.lower() not in (helpLabel.lower()):
            if install:
                Bsp.installPackage(boardName, SuiteGlobals.PATH_TO_BSP_PACKAGE, True)
                if reset == True:
                    test.log("Restarting SoundClear Studio")
                    Common.endAUT()
                    Common.startAUT()
                else:
                    pass
        else:
            if install == False:
                test.log("uninstalling BSP...")
                Bsp.uninstallBSP(packageName)
                if reset == True:
                    test.log("Restarting SoundClear Studio")
                    Common.endAUT()
                    Common.startAUT()
                else:
                    pass
            else:
                pass

    @classmethod
    def getVersionInformationFromSCS(cls, bspPackage):
        """
        This method reads the installed BSP version from SCS about shell and returns the information

        @return: return BSP version

        Usage example:
        bsp_version = BSP.getVersionInformationFromSCS('CS47L5x')
        """
        aboutObj = HelpAboutShell()

        if "Windows" in platform.system():
            InputActions.activateMenuItem("Help->About")
        elif "Darwin" in platform.system():
            InputActions.activateMenuItem("SoundClear Studio->About SoundClear Studio")
        elif "Linux" in platform.system():
            pass
        else:
            sys.exit("OS not found.")

        bsp_version_label = ReadActions.getPropertyOfObject(aboutObj.getBspVersionShell(bspPackage), "text")
        InputActions.mouseClickOnItem(aboutObj.getCloseAboutSCS())
        return bsp_version_label

