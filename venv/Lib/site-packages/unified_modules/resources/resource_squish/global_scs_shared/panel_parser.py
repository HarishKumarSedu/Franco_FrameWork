"""
SCS Panel file parser

Parses a .panel file and extracts the Widget structure, properties of the
widget, and gives access to the Squish realnames of widgets for use
"""
from __future__ import print_function
import json


class WidgetInfoTypes(object):
    """Creates a mapping for class types within the panel between a string and
    python representation, and also gives access to a mapping to their Java
    class types for generating real names.
    """

    ButtonWidgetModel = "ButtonWidgetModel"
    CheckBoxWidgetModel = "CheckBoxWidgetModel"
    FileChooserWidgetModel = "FileChooserWidgetModel"
    LabelWidgetModel = "LabelWidgetModel"
    ComboBoxWidgetModel = "ComboBoxWidgetModel"
    TextFieldWidgetModel = "TextFieldWidgetModel"
    NumericFieldWidgetModel = "NumericFieldWidgetModel"
    RadioButtonWidgetModel = "RadioButtonWidgetModel"
    ToggleButtonWidgetModel = "ToggleButtonWidgetModel"
    SliderWidgetModel = "SliderWidgetModel"
    BlankContainerModel = "BlankContainerModel"

    type_to_java_class = {
        ButtonWidgetModel : "javafx.scene.control.Button",
        CheckBoxWidgetModel : "javafx.scene.control.CheckBox",
        FileChooserWidgetModel : "javafx.scene.control.Button",
        LabelWidgetModel : "javafx.scene.control.Label",
        ComboBoxWidgetModel : "com.cirrus.scs.ide.paneleditor.ui.widget.ComboBoxWidget",
        ToggleButtonWidgetModel : "com.cirrus.scs.ide.paneleditor.ui.widget.ToggleButtonWidget",
        RadioButtonWidgetModel : "com.cirrus.scs.ide.paneleditor.ui.widget.RadioButtonWidget",
        TextFieldWidgetModel : "com.cirrus.scs.ide.ui.javafx.controls.SCSSimpleTextField",
        NumericFieldWidgetModel : "com.cirrus.scs.ide.ui.javafx.controls.SCSSimpleTextField",
        SliderWidgetModel : "com.cirrus.scs.ide.paneleditor.ui.widget.SliderWidget",
        BlankContainerModel : "com.cirrus.scs.ide.paneleditor.ui.container.BlankContainer"
    }

    type_to_java_class_part = {
        RadioButtonWidgetModel : "javafx.scene.control.RadioButton",
        ToggleButtonWidgetModel : "javafx.scene.control.Button",
        SliderWidgetModel : {
            "text" : "com.cirrus.scs.ide.ui.javafx.controls.SCSSimpleTextField",
            "slider" : "javafx.scene.shape.Line"}
    }


class Part(object):
    def __init__(self):
        self.real_name  = ""
    

class RealNameGenerator(object):
    """A collection of static/class methods used to help generate real names
    for different types of widget. This class should not be instantiated.
    
    Args:
        object ([type]): [description]
    """

    @staticmethod
    def id_string_from_widget(panel_name, widget_name):
        """Create a string of the widgets JavaFX ID property from the panel and widget names

        Args:
            panel_name (string): Name of the panel the widget is in
            widget_name (string): Name of the widget

        Returns:
            The id property of the widget
        """
        return "{}_{}".format(panel_name, widget_name)

    @staticmethod
    def identifier_string(id_string, class_string):
        """Creates a Squish 'real name' identifier string for a widget

        Args:
            id_string (string): The widget's id property
            class_string (string): The java class of the widget

        Returns:
            The Squish 'real name' identifier string for the widget
        """

        return "{{type='{}' id='{}'}}".format(class_string, id_string)


    @staticmethod
    def radio_identifier_string(id_string, class_string, caption):
        """Creates a Squish 'real name' identifer string for part of a radio widget

        Args:
            id_string (string): The widget's id property
            class_string (string): The java class of the widget
            caption (string): The text caption of the individual radio button

        Returns:
            The Squish 'real name' identifier string for the radio widget part
        """
        return "{{type='{}' id='{}' caption='{}'}}".format(
            class_string, id_string, caption)

    @staticmethod
    def toggle_identifier_string(id_string, class_string, caption):
        """Creates a Squish 'real name' identifier string for part of a toggle button widget

        Args:
            id_string (string): The widget's id property
            class_string (string): The java class of the widget
            caption (string): The text caption on the individual button

        Returns:
            The Squish 'real name' identifier string for the toggle widget part
        """
        return "{{type='{}' id='{}' caption='{}'}}".format(
            class_string, id_string, caption)

    @staticmethod
    def slider_text_identifier_string(id_string, text_part_class_string, class_string):
        """Creates a Squish 'real name' identifier string for the text part of the slider widget

        This is a little more involved and needs some hard coded values as the id
        property doesn't propagate down into the component controls of the widget.
        If this issue is fixed in SCS later, this code could be simplified.
        
        Args:
            id_string (string): The widget's id property
            text_part_class_string (string): The java class of the text field bit of the widget
            class_string (string): The java class of the main widget
        """
        return ("{{type='{}' container={{container={{id='{}' type='{}'}} " 
                "type='com.cirrus.scs.ide.paneleditor.ui.widget.SliderWidget$1'}}}}"
                ).format(text_part_class_string, id_string, class_string)
        
    @staticmethod
    def slider_slider_identifier_string(id_string, slider_part_class_string, class_string):

        return ("{{type='{}' container={{id='{}' type='{}'}}}}"
                ).format(slider_part_class_string, id_string, class_string)
        

    @classmethod
    def generate_standard_identifier_strings(cls, id_string, widget_info):
        """Gets a real name for a normal control (not a complex one)

        Args:
            id_string (string): The widget's id property
            widget_info (WidgetInfo): The widget's information
        Return:
            The real name of the widget
        """
        return cls.identifier_string(
                id_string,
                WidgetInfoTypes.type_to_java_class[widget_info.widget_type])


    @classmethod
    def generate_radio_identifier_strings(cls, id_string, widget_info):
        """Creates a real name set for a radio button widget

        Args:
            id_string (string): The id property of the widget
            widget_info (WidgetInfo): the widget's information

        Return:
            A tuple of the real name of the entire widget, and a dictionary of
            the real names of the individual radio button settings that make up
            the widget
        """
        sub_button_count = 0
        while True:
            if hasattr(widget_info, "radio_name_{}".format(sub_button_count)):
                sub_button_count += 1
            else:
                break

        # create real name for overarching widget
        real_name = cls.identifier_string(
                id_string,
                WidgetInfoTypes.type_to_java_class[widget_info.widget_type])

        # create real names for the individual parts
        part_real_names = {}

        for i in range(0, sub_button_count):
            radio_caption = getattr(widget_info, "radio_name_{}".format(i))
            ident_string = cls.radio_identifier_string(
                id_string,
                WidgetInfoTypes.type_to_java_class_part[widget_info.widget_type],
                radio_caption)
            part_real_names[radio_caption] = ident_string
            # add the radio bits as properties with a respective realname property
            radio_part = Part()
            radio_part.real_name = ident_string
            widget_info.__setattr__("radio_{}".format(i), radio_part)

        return (real_name, part_real_names)


    @classmethod
    def generate_toggle_identifier_strings(cls, id_string, widget_info):
        """Creates a real name set for a toggle button widget

        Args:
            id_string (string): The id property of the widget
            widget_info (WidgetInfo): The widget's information

        Returns:
            A tuple of the real name of the entire widget, and a dictionary of
            the real names of the individual toggleable buttons that make up the
            widget
        """
        # create real name for overarching widget
        real_name = cls.identifier_string(
                id_string,
                WidgetInfoTypes.type_to_java_class[widget_info.widget_type])

        # create real names for the individual parts
        part_real_names = {}

        part_texts = [widget_info.toggleButtonTextOn,
                      widget_info.toggleButtonTextOff]
        on_text = widget_info.toggleButtonTextOn
        off_text = widget_info.toggleButtonTextOff

        for caption in part_texts:
            part_real_names[caption] = cls.toggle_identifier_string(
                id_string,
                WidgetInfoTypes.type_to_java_class_part[widget_info.widget_type],
                caption)
        
        # add the toggle buttons as properties with a respective realname property
        on_part = Part()
        on_part.real_name = part_real_names[on_text]
        off_part = Part()
        off_part.real_name = part_real_names[off_text]
        widget_info.__setattr__("on_button", on_part)
        widget_info.__setattr__("off_button", off_part)

        return (real_name, part_real_names)

    @classmethod
    def generate_slider_identifier_strings(cls, id_string, widget_info):

        # create real name for overarching widget
        real_name = cls.identifier_string(
                id_string,
                WidgetInfoTypes.type_to_java_class[widget_info.widget_type])

        # create real names for the individual parts
        part_real_names = {}

        part_real_names['text'] = cls.slider_text_identifier_string(
            id_string,
            WidgetInfoTypes.type_to_java_class_part[widget_info.widget_type]['text'],
            WidgetInfoTypes.type_to_java_class[widget_info.widget_type])

        part_real_names['slider'] = cls.slider_slider_identifier_string(
            id_string,
            WidgetInfoTypes.type_to_java_class_part[widget_info.widget_type]['slider'],
            WidgetInfoTypes.type_to_java_class[widget_info.widget_type])

        # add the toggle buttons as properties with a respective realname property
        text_part = Part()
        text_part.real_name = part_real_names['text']
        slider_part = Part()
        slider_part.real_name = part_real_names['slider']
        widget_info.__setattr__("text", text_part)
        widget_info.__setattr__("slider", slider_part)

        return (real_name, part_real_names)

    @classmethod
    def generate_real_names(cls, panel_name, widget_info):
        """Creates a real name for a given WidgetInfo instance

        Args:
            panel_name (string): The name of the panel the Widget is in
            widget_info (WidgetInfo): The widget's information

        Returns:
            A tuple of the real name of the entire widget, and a dictionary of
            widget parts for complex widgets, or an empty dictionary for
            standard widgets
        """

        id_string = cls.id_string_from_widget(panel_name, widget_info.name)

        if widget_info.widget_type == WidgetInfoTypes.RadioButtonWidgetModel:
            return cls.generate_radio_identifier_strings(id_string, widget_info)
        elif widget_info.widget_type == WidgetInfoTypes.ToggleButtonWidgetModel:
            return cls.generate_toggle_identifier_strings(id_string, widget_info)
        elif widget_info.widget_type == WidgetInfoTypes.SliderWidgetModel:
            return cls.generate_slider_identifier_strings(id_string, widget_info)
        elif widget_info.widget_type in list(WidgetInfoTypes.type_to_java_class.keys()):
            return (cls.generate_standard_identifier_strings(id_string,
                        widget_info),
                    {})
        else:
            return ("", {})


class WidgetInfo(object):
    """A class to provide a mocked version of an SCS widget.

    This is a general implementation of a widget, and should adequately mock
    the functionality used by the panel scripts to allow the state of the
    widgets to be interrogated by the test suite.
    """

    def __init__(self, panel_name, **kwargs):
        """Initialize the widget info.

        Args:
            kwargs (keyword argument dictionary): The initial properties of the widget.
            panel_name (string): Name of the parent panel
        """
        for key, val in kwargs.items():
            self.__setattr__(key, val)

        self.real_name, self.part_real_names = \
            RealNameGenerator.generate_real_names(panel_name, self)

        self.widgets = []

    def __getattr__(self, attribute):
        """Retrieve a getter or setter if applicable.

            If ``attribute`` starts with set or get, return a function to get or
            set the value of the WidgetInfo's ``attribute[3:].lower()`` attribute.

            For example, ``getValue`` will return a getter for the ``value``
            attribute.

            If ``attribute`` doesn't start with set or get, return an
            AttributeError.

        Args:
            attribute (string): The attribute to get, should start with get or set.
        """

        # handle the fact that options are coded as content
        if attribute == 'options':
            return getattr(self, 'content')
        elif attribute.startswith('set'):
            return lambda value: setattr(self, attribute[3:].lower(), value)
        elif attribute.startswith('get'):
            return lambda: getattr(self, attribute[3:].lower())
        raise AttributeError("no attribute for '%s'" % attribute)

class PanelInfo(object):
    """A class to provide a mocked version of an SCS panel.

    This parses a .panel file to create WidgetInfos for use when testing the
    panel.
    """

    def __init__(self, panel_file):
        """Initialize the panel info.

        This method may raise any exception that json.load may raise in the case
        that the contents of panel_file is malformed

        The file can be safely closed once the constructor returns

        Args:
            path (file like object): A file like object representing the .panel 
                                     file to get the info from. The caller is
                                     responsible for closing this file.
        """
        panel = json.load(panel_file)

        self.widgets = []

        self.unique_name = panel["Panel"]["Name"]
        self.add_widget(panel["Panel"], "Panel", None)


    def add_widget(self, widget, widget_type, parent):
        """Add a widget and its children to the panel info.

        This function looks at the given widget, and if it has a name adds an
        attribute to the panel pointing at a WidgetInfo to represent it.

        It then iterates over the children of the widget, and recursively calls
        this function on each of them.

        Args:
            widget (Dictionary): The widget definition to parse and add to the panel
            widget_type (string): The type of the widget as in the JSON file
            parent (widget_info): The parent of this widget
        """
        if parent is not None:
            widget_properties = dict()

            for prop in widget['properties']['entry']:
                key = prop['key']

                # can happen with for example 'tooltip'
                try:
                    val = prop['value']['value']
                except KeyError:
                    if key in ('tooltip', 'linkedPanel'):
                        val = ''
                    else:
                        raise

                widget_properties[key] = val

                if key == 'name':
                    # sanity check, note: val here is the name of the widget
                    if hasattr(self, val):
                        raise ValueError("multiple widgets with the name '%s'"
                                         % val)

                if widget_properties.get(key, val) != val:
                    raise ValueError("multiple values for attribute '%s' in "
                                     "widget ('%s' and '%s')"
                                     % (widget_properties[key], val))

            if 'name' not in widget_properties:
                raise ValueError("no name for widget")
            name = widget_properties['name']

            # add unique name
            if "unique_name" in widget_properties:
                raise AttributeError(
                    ("{} already has a unique_name").format(name))
            # add unique name
            unique_name = "{}.{}".format(parent.unique_name, name)
            widget_properties["unique_name"] = unique_name
            widget_properties["widget_type"] = widget_type
            widget_obj = WidgetInfo(self.unique_name, **widget_properties)
            # add to the top level widget array and make accessible with . syntax
            setattr(self, name, widget_obj)
            self.widgets.append(widget_obj)
            # add to the parent's widget array and make accessible with . syntax
            if not self == parent:
                setattr(parent, name, widget_obj)
                parent.widgets.append(widget_obj)
        else:
            # at root of tree
            unique_name = self.unique_name
            widget_obj = self

        children = widget.get('widgets', {})
        # go down and add any child widgets to the main widget list - these
        # are not stored heirarchically but all sit at the top 'level'
        for kind, widgets in children.items():
            for child in widgets:
                self.add_widget(child, kind, widget_obj)

    def print_tree(self):
        """Prints the widgets in the panel in a tree structure to show how
        widgets can be addressed as the sit in containers
        """

        # find what widgets are children of others so we don't start walking
        # the tree from them
        children = set()

        def get_children(widget_info):
            """Recursively finds the children of a widget, and all further
            descendants

            Args:
                widget_info (WidgetInfo): The widget to find the children of
            """
            for widget in widget_info.widgets:
                get_children(widget)
                children.add(widget)

        for widget in self.widgets:
            get_children(widget)

        def print_widget_tree(widget_info, depth):
            """Recursively prints out a widget and it's descendants as a tree
            structure

            Args:
                widget_info (WidgetInfo): The widget to print the children of
                depth (int): The current depth of the tree for printing
            """
            print("{}{}".format("\t" * depth, widget_info.name))
            depth += 1
            for child in widget_info.widgets:
                print_widget_tree(child, depth)

        # look at only the top level widgets and print them and their children
        # as a tree structure
        for widget in self.widgets:
            if widget not in children:
                print_widget_tree(widget, 0)

    def print_flat(self):
        """Prints the widgets in the panel in a flat structure to show how
        widgets can all be addressed at the top level
        """
        for widget in self.widgets:
            print(widget.name)
