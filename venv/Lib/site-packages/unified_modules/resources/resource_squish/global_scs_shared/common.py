# Copyright (c) 2017 Cirrus Logic, Inc and
# Cirrus Logic International Semiconductor Ltd.  All rights reserved.
#
# This software as well as any related documentation is furnished under
# license and may only be used or copied in accordance with the terms of the
# license.  The information in this file is furnished for informational use
# only, is subject to change without notice, and should not be construed as
# a commitment by Cirrus Logic.  Cirrus Logic assumes no responsibility or
# liability for any errors or inaccuracies that may appear in this document
# or any software that may be provided in association with this document.
# Except as permitted by such license, no part of this document may be
# reproduced, stored in a retrieval system, or transmitted in any form or by
# any means without the express written consent of Cirrus Logic.
#
# Warning
#   This software is specifically written for Cirrus Logic devices.
#   It may not be used with other devices.
#
## @file   common.py
## @brief  All general functions

# Examples: build project, clean project, replace file, search file, search folder...

import os
import sys
from xml.dom import minidom
import re
import subprocess
import shutil
import errno
import json
import xml.etree.ElementTree as ET
import filecmp
import platform
from subprocess import PIPE
import builtins
from distutils.version import LooseVersion

source(findFile("scripts", "squish_config.py"))
source(findFile("scripts", "input_actions.py"))
source(findFile("scripts", "projects.py"))
source(findFile("scripts", "read_actions.py"))
source(findFile("scripts", "real_names.py"))
source(findFile("scripts", "bsp.py"))

class SquishTestAbortException(Exception):
    """Exception class for Squish exceptions"""
    pass


class Common:

    @classmethod
    def selectFromComboBoxList(cls, comboBox, item):
        """
        This method selects item from combo box list

        @param comboBox [string] real name of combo box
        @param item [string] real name of item from combo box list
        @return no return

        Usage:
        Common.selectFromComboBoxList(addSystemStageObj.getAddComboBox(), rnSystem)
        """
        counter = 0
        itemPosition = 0
        itemObj = ""
        itemText = ""
        comboboxItems = ""
        """ Click on combobox """
        InputActions.mouseClickOnItem(comboBox)
        try:
            itemObj = findObject(item)
        except:
            test.fail("FAIL", "Can not find object '" + item + "'")
        try:
            itemText = itemObj.text
        except AttributeError:
            test.fail("FAIL", "Can not find object property '" + item + "'")

        """ Select item from combo box """
        try:
            comboboxObj = waitForObject(comboBox)
        except:
            test.fail("FAIL", "Can not find object '" + comboBox + "'")
        try:
            comboboxItems = str(comboboxObj.options)
        except:
            test.fail("FAIL", "Can not find object property '" + comboBox + "'")
        if comboboxItems != "":
            comboboxItems = comboboxItems[1:-1]
            if "," in comboboxItems:
                listOFComboboxItems = comboboxItems.split(", ")
                if itemText in listOFComboboxItems:
                    itemPosition = listOFComboboxItems.index(itemText)
                else:
                    test.fail("FAIL", itemText + " does not exist")
            else:
                itemPosition = 0
        else:
            test.fail("FAIL", "Can not find item in combobox")

        while (counter != itemPosition and itemPosition != 0):
            nativeType("<Down>")
            counter += 1
            # TODO: removing because no RT-Exec snooze(0.3)
        if object.exists(item):
            InputActions.mouseClickOnItem(item, "left", True, 1, 1)
        else:
            test.fail("FAIL", "Can not click on object " + item)

    @classmethod
    def selectFromComboBox(cls, comboBoxWidget, option):
        """
        This method selects option from combo box

        @param comboBoxWidget [string] real name of combo box
        @param option [string] option in combo box
        @return no return

        Usage:
        Common.selectFromComboBox(gpioObj.getComboBox("cmbPinBeingConfigured"), "B9: CC2 / HVO4")
        Common.selectFromComboBox(gpioObj.getComboBox("cmbPinBeingConfigured"), "A8: CC4 / HVO3")
        Common.selectFromComboBox(gpioObj.getComboBox("cmbPinBeingConfigured"), "A9: CC3 / HVO2")
        Common.selectFromComboBox(gpioObj.getComboBox("cmbPinBeingConfigured"), "C9: CC1 / HVO1")
        """
        import re
        optionPosition = 0
        popupObj = PopupListView()
        comboBox = None
        listOfOptions = []
        try:
            comboBox = waitForObject(comboBoxWidget)
            options = comboBox.model.options
            listOfOptions = (re.sub('[=]\d+','',str(options))).split("|")

            #if option in listOfOptions:
                #optionPosition = listOfOptions.index(option)
            found = False
            for line in listOfOptions:
                option_match = re.escape(option)
                matchObj = re.match(option_match, line)
                if matchObj is not None:
                    optionPosition = listOfOptions.index(matchObj.string)
                    found = True
                    break
                elif matchObj is None and option == line:
                    optionPosition = listOfOptions.index(line)
                    found = True
                    break
            if not found:
                if [re.match(option, val) for val in listOfOptions]:
                    return 'option_not_found'
                test.fail("FAIL", option + " option does not exist in combo box.")

        except Exception as e:
            test.fail("FAIL", "Error message: " + str(e))

        InputActions.mouseClickOnItem(comboBoxWidget)
        # TODO: removing because no RT-Exec snooze(1)
        try:
            InputActions.mouseClickOnItem(popupObj.getPopupItem(listOfOptions[0]))
            # TODO: removing because no RT-Exec snooze(1)
            Common.selectComboBoxItem(comboBox, optionPosition)
        except Exception as e:
            test.fail("FAIL", str(e))

    @classmethod
    def selectOptionFromComboBox(cls, comboBoxWidget, option):
        """
        This method selects option from combo box

        @param comboBoxWidget [string] real name of combo box
        @param option [string] option in combo box
        @return no return

        Usage:
        Common.selectOptionFromComboBox(gpioObj.getComboBox("comboBox"), "Option1")
        Common.selectOptionFromComboBox(gpioObj.getComboBox("comboBox"), "Option2")
        """
        import re
        optionPosition = 0
        popupObj = PopupListView()
        comboBox = None
        listOfOptions = []
        try:
            comboBox = waitForObject(comboBoxWidget)
            options = comboBox.options
            listOfOptions = (str(options))[1:-1].split(", ")

            found = False
            for line in listOfOptions:
                option_match = re.escape(option)
                matchObj = re.match(option_match, line)
                if matchObj is not None:
                    optionPosition = listOfOptions.index(matchObj.string)
                    found = True
                    break
                elif matchObj is None and option == line:
                    optionPosition = listOfOptions.index(line)
                    found = True
                    break
            if not found:
                if [re.match(option, val) for val in listOfOptions]:
                    return 'option_not_found'
                test.fail("FAIL", option + " option does not exist in combo box.")

        except Exception as e:
            test.fail("FAIL", "Error message: " + str(e))

        InputActions.mouseClickOnItem(comboBoxWidget, x=75)
        try:
            InputActions.mouseClickOnItem(popupObj.getPopupItem(listOfOptions[optionPosition]))
        except Exception as e:
            test.fail("FAIL", str(e))

    @classmethod
    def selectComboBoxItem(cls, comboBox, down):
        """
        This method selects item from combo box list. Similar to method selectFromComboBoxList

        @param comboBox [string] real name of combo box
        @param down [int] position in list
        @return no return

        Usage:
        Common.selectComboBoxItem(RegisterMap().getPageComboBox(), 2)
        """
        counter = 0
        try:
            """ Click on combo box """
            mouseClick(waitForObject(comboBox), 5, 5, 0, Button.Button1)
            # TODO: removing because no RT-Exec snooze(0.5)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + comboBox + "'")
        """ Select item from combo box """
        while counter < down:
            nativeType("<Down>")
            counter += 1
        nativeType("<Return>")

    @classmethod
    def deleteAllVirtualSystems(cls):
        """
        This method delete all virtual systems.

        @return no return

        Usage:
        Common.deleteAllVirtualSystems()
        """
        Common.showDiscoveredSystem()
        try:
            systemObj = waitForObject(Directory().getDiscoveredSystems())
        except LookupError:
            test.fail("FAIL", "Discovered Systems does not exist")
        discoveredSystems = str(systemObj.item.children)
        if discoveredSystems != "[]":
            discoveredSystems = discoveredSystems.replace("[", "")
            discoveredSystems = discoveredSystems.replace("]", "")
            systems = re.split(",", discoveredSystems)
            vitualSys = ""
            for system in systems:
                tempSystem = re.split(":", system)
                if object.exists(Directory().getBoardOrSystem(tempSystem[0].strip())):
                    try:
                        vitualSys = waitForObject(Directory().getBoardOrSystem(tempSystem[0].strip())).tooltip.text
                    except LookupError:
                        test.fail("FAIL", "Virtual system does not exist")
                    if "VIRTUAL" in vitualSys:
                        ProjectOperation.contextMenuSystemDirectory(Directory().getBoardOrSystem(tempSystem[0].strip()), "Delete")

    @classmethod
    def addSimulatedSystem(cls, name, system=None, context=False, link=False):
        """
        This method add simulated system

        @param name [string] name of system
        @param system [string] full name of the system
        @param context [bool] default False(add virtual system from file menu)
                                      True(add system)
        @param link [bool] default False(links project with existing system)
                                   True(links project with new system)
        @return [bool] True if system is added, False otherwise

        Usage:
        Common.addSimulatedSystem("System_1", "CS42L42 Customer Demonstration Board")
        Common.addSimulatedSystem("System_1", "EE42L75-APPS-MB Customer Demonstration Board")
        Common.addSimulatedSystem("System_1", "CS42L42 Customer Demonstration Board", True, True)
        """
        addSystemStageObj = AddSystemStage()
        informationShellObj = InformationShell()
        directoryObj = Directory()
        timeOut = 5000

        if not context:
            InputActions.activateMenuItem("File->New->Virtual System")
        # TODO: removing because no RT-Exec snooze(0.5)
        try:
            """ Add name of system """
            mouseClick(waitForObject(addSystemStageObj.getAddSysTextField(), timeOut), 5, 5, 0, Button.Button1)
            # TODO: removing because no RT-Exec snooze(1)
            type(waitForObject(addSystemStageObj.getAddSysTextField(), timeOut), name)
            # TODO: removing because no RT-Exec snooze(1)
        except LookupError:
            test.fail("FAIL", "Unable to click text field '" + addSystemStageObj.getAddSysTextField() + "'")
            # TODO: removing because no RT-Exec snooze(0.5)
        """ Select simulated system """
        if system is None:
            try:
                """ Confirm adding"""
                mouseClick(waitForObject(addSystemStageObj.getAddSysOkButton(), timeOut), 5, 5, 0, Button.Button1)
                # TODO: removing because no RT-Exec snooze(1.5)
                return True
            except LookupError:
                test.fail("FAIL", "Unable to click on button '" + addSystemStageObj.getAddSysOkButton() + "'")
                return False
        else:
            normal_comm_state = addSystemStageObj.getCommStateNameLabel('NORMAL')
            if not object.exists(normal_comm_state):
                snooze(1)
                if not object.exists(normal_comm_state):
                    snooze(5)
                    if not object.exists(normal_comm_state):
                        raise SquishTestAbortException("Failed to created Virtual %s system" % system)
            rnSystem = "{caption?='" + "*" + system + "*" + "' container = " + addSystemStageObj.getPopUp() + " styletype='label label-name' visible='true'}"
            snooze(2)
            Common.selectFromComboBoxList(addSystemStageObj.getAddComboBox(), rnSystem)
            if name is "":
                mouseClick(waitForObject(addSystemStageObj.getAddSysTextField(), timeOut), 5, 5, 0, Button.Button1)
                # TODO: removing because no RT-Exec snooze(1.5)
                testMachine = platform.system()
                if "Windows" in testMachine:
                    nativeType("<Ctrl+a>")
                elif "Linux" in testMachine:
                    sys.exit("Linux")
                elif "Darwin":
                    nativeType("<Command+a>")
                else:
                    sys.exit("OS not found")
                # TODO: removing because no RT-Exec snooze(1.5)
                nativeType("<Backspace>")
            else:
                pass
            try:
                """ Check if OK button enabled"""
                okButton = waitForObject(addSystemStageObj.getAddSysOkButton())
                while okButton.disable == True:
                    counter = 0
                    # TODO: removing because no RT-Exec snooze(counter)
                    if okButton.disable != True:
                        break
                    counter += 1
                    if counter > timeout:
                        test.fail("FAIL", "Unable to click on button '" + okButton + "'")
                        break
                """ Confirm adding"""
                mouseClick(okButton, 5, 5, 0, Button.Button1)
                # TODO: removing because no RT-Exec snooze(1.5)
                return True
            except LookupError:
                test.fail("FAIL", "Unable to click on button '" + addSystemStageObj.getAddSysOkButton() + "'")
                # TODO: removing because no RT-Exec snooze(0.5)
                return False
            if object.exists(informationShellObj.getInformationShellButton("OK")):
                InputActions.mouseClickOnButton(informationShellObj.getInformationShellButton("OK"))
            try:
                waitForObject(directoryObj.getDirectoryTreeItem(name))
                test.log("Virtual system " + name + " is created")
            except:
                test.fail("FAIL", "Virtual system " + system + str(i) + " is not created")
            return True

    @classmethod
    def get_number_of_systems(cls):
        """
        This method returns the list for systems discovered in SCS
        """
        Common.setComboCheckBoxSysDirectory("Network", False)
        try:
            system_obj = waitForObject(Directory().getDiscoveredSystems())
        except LookupError:
            test.fail("FAIL", "Discovered Systems does not exist")
        discovered_systems = str(system_obj.item.children)
        if discovered_systems != "[]":
            discovered_systems = discovered_systems.replace("[", "")
            discovered_systems = discovered_systems.replace("]", "")
            list_of_systems = re.split(",", discovered_systems)
            return list_of_systems

    @classmethod
    def execute_script_btn(cls, system_name, script_path):
        execute_script = ExecuteScript()
        execute_script_dailog = "{styletype='scs-commonDialogBackground scs-dialogRoot' visible='true' " \
                                "window={caption='Script execution' isvisible='true' " \
                                "type='org.eclipse.swt.widgets.Shell'}}"
        timeout = 5000
        number_of_systems = cls.get_number_of_systems()
        test.log("Number of systems are %s" % str(number_of_systems))
        InputActions.activateMenuItem("File->Execute Script")
        test.log("Number of systems are %s" % str(number_of_systems))
        test.log("Number of systems are %s" % len(number_of_systems))
        if len(number_of_systems) > 1:
            rn_system = "{caption?='" + "*" + system_name + "*" + "' container = " + execute_script.getPopUp() \
                       + " styletype='label label-name' visible='true'}"
            Common.selectFromComboBoxList(execute_script.getComboBox(), rn_system)
            ok_button = waitForObject(execute_script.getOkBtn())
            #while ok_button.disable == True:
            while ok_button.disable:
                counter = 0
                # TODO: removing because no RT-Exec snooze(counter)
                #if ok_button.disable != True:
                if ok_button.disable is not True:
                    break
                counter += 1
                if counter > timeout:
                    test.fail("FAIL", "Unable to click on button '" + ok_button + "'")
                    break
            mouseClick(ok_button, 5, 5, 0, Button.Button1)

        ok_button = waitForObject(execute_script.getChooseFileWindow())
        chooseFile(waitForObject(ok_button),
                   script_path)
        while(object.exists(execute_script_dailog)):
             pass
        # TODO: removing because no RT-Exec snooze(1.5)
        return True

    @classmethod
    def changeRollingLogNumber(cls, number):
        """
        This method is used for changing number of rolling log numbers

        @param number [string] number that will be set as number of roling logs
        @return no return

        Usage:
        Common.changeRollingLogNumber("7")
        """
        try:
            mouseClick(waitForObject(Preferences().getTreeItem("Logging")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getTreeItem("Logging") + "'")
        try:
            doubleClick(waitForObject(Preferences().getHistoryPane()), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getTextBox() + "'")
        nativeType(number)
        try:
            mouseClick(waitForObject(Preferences().getButton("Apply")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("Apply") + "'")
        try:
            mouseClick(waitForObject(Preferences().getButton("OK")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("OK") + "'")

    @classmethod
    def changeMaximumLogFileSize(cls, number):
        """
        This method is used for changing number of Maximum Log File Size

        @param number [string] number that will be set as number of Maximum Log File Size
        @return no return

        Usage:
        Common.changeMaximumLogFileSize("7")
        """
        layoutbounds = str(waitForObject(Preferences().getMaximumLogFileSizeLabel()).layoutbounds)
        width = layoutbounds.index("width:") + 6
        widthNum = layoutbounds[width:(width + 3)]
        x = builtins.int(widthNum) + 10
        try:
            mouseClick(waitForObject(Preferences().getTreeItem("Logging")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getTreeItem("Logging") + "'")
        try:
            doubleClick(waitForObject(Preferences().getMaximumLogFileSizeLabel()), x, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getTextBox() + "'")
        nativeType(number)
        try:
            mouseClick(waitForObject(Preferences().getButton("Apply")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("Apply") + "'")
        try:
            mouseClick(waitForObject(Preferences().getButton("OK")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("OK") + "'")

    @classmethod
    def setDebugLoggingState(cls, state):
        """
        This method set debug logging state

        @param state [bool] True (to tick) and False (to untick)
        @return no return

        Usage:
        Common.setDebugLoggingState(False)
        """
        try:
            mouseClick(waitForObject(Preferences().getTreeItem("Logging")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getTreeItem("Logging") + "'")
        if findObject(Preferences().getDebugLogging()).selection != state:
            try:
                mouseClick(waitForObject(Preferences().getDebugLogging()), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on '" + Preferences().getDebugLogging() + "'")
        try:
            mouseClick(waitForObject(Preferences().getButton("OK")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("OK") + "'")

    @classmethod
    def setDebugLevel(cls, itemToClick):
        """
        This method is for setting debug level

        @param itemToClick [string] item thet will be clicked in list view from debug level combo box
        @return no return

        Usage:
        Common.setDebugLevel("Info")
        """
        listItem = "{caption='" + itemToClick + "' container=" + PopupListView().getListView() + " styletype='cell indexed-cell list-cell' visible='true'}"
        try:
            mouseClick(waitForObject(Preferences().getTreeItem("Logging")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getTreeItem("Logging") + "'")
        try:
            mouseClick(waitForObject(Preferences().getThemeComboBox()), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + PopupListView().getListView() + "'")
        # TODO: removing because no RT-Exec snooze(0.3)
        try:
            mouseClick(waitForObject(listItem), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + listItem + "'")
        try:
            mouseClick(waitForObject(Preferences().getButton("Apply")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("Apply") + "'")
        try:
            mouseClick(waitForObject(Preferences().getButton("OK")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("OK") + "'")

    @classmethod
    def setLogToFileCheckBox(cls, checkBox=True):
        """
        This method is for selecting/deselecting checkBox

        @param checkBox [bool] True if we want to select check box, False if we want to deselect check box
        @return no return

        Usage:
        Common.setLogToFileCheckBox()
        Common.setLogToFileCheckBox(False)
        """
        try:
            mouseClick(waitForObject(Preferences().getTreeItem("Logging")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getTreeItem("Logging") + "'")
        stateOfChackBox = waitForObject(Preferences().getGeneralCheckBox("Log to file")).selected
        if stateOfChackBox != checkBox:
            try:
                mouseClick(waitForObject(Preferences().getCheckBox("Log to file")), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on '" + Preferences().getCheckBox("Log to file") + "'")
        else:
            test.log("state of checkbox is as we expect")

        try:
            mouseClick(waitForObject(Preferences().getButton("Apply")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("Apply") + "'")
        try:
            mouseClick(waitForObject(Preferences().getButton("OK")), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on '" + Preferences().getButton("OK") + "'")

    @classmethod
    def selectRowInTable(cls, column, container, row):
        """
        This method select row in table

        @param column [string] name of column
        @param container [string] real name of container
        @param row [string] name of the row
        @return no return

        Usage:
        Common.selectRowInTable("Value", RegisterMap("System_1", "USB Audio Module").getRegisterTable(), row)
        """
        rnCell = "{column='" + column + "' container=" + container + " row ='" + row + "' styletype='cell indexed-cell table-cell table-column table-view-lastColumn' visible='true'}"
        try:
            mouseClick(waitForObject(rnCell, 5000), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on cell '" + rnCell + "'")

    @classmethod
    def closeWindow(cls, window):
        """
        This method is for closing window

        @param window [string] real name of the window we want to close
        @return mo return

        Usage:
        Common.closeWindow()
        """
        rnWindow = "{caption='" + window + "' parent.visible='true' type='org.eclipse.swt.custom.CTabItem' window=" + MainShell().getMainWindow() + "}"
        if object.exists(rnWindow):
            """ if Window exists """
            try:
                mouseClick(waitForObject(rnWindow), 5, 5, 0, Button.Button2)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + rnWindow + "'")

    @classmethod
    def closeWelcomeWindow(cls):
        """
        Switch to working perspective

        @return no return

        Usage:
        Common.closeWelcomeWindow()
        """
        welcomeObj = Welcome()
        mainShelObj = MainShell()
        if object.exists(welcomeObj.getCloseWelcomeLabel()):
            """ if Welcome Window exists """
            try:
                # TODO: removing because no RT-Exec snooze(1)
                obj = waitForObject(welcomeObj.getWelcomeWindow())
                # TODO: removing because no RT-Exec snooze(1)
                obj.forceActive()
                # TODO: removing because no RT-Exec snooze(3)
                mouseClick(waitForObject(welcomeObj.getCloseWelcomeLabel()))
                """ Adding workaround for case when mouse click does not close Welcome Window """
                if object.exists(welcomeObj.getCloseWelcomeLabel()):
                    nativeType("<Escape>")
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + welcomeObj.getCloseWelcomeLabel() + "'")
        else:
            nativeType("<Escape>")
            # TODO: removing because no RT-Exec snooze(1)
            try:
                obj = waitForObject(mainShelObj.getMainWindow())
                obj.forceActive()
            except LookupError:
                test.fail("FAIL", "Can not access '" + mainShelObj.getMainWindow() + "'")

    @classmethod
    def showDiscoveredSystem(cls):
        """
        This method expands Discovered systems in Directory view

        @return no return

        Usage:
        Common.showDiscoveredSystem
        """

        """ Check if Directory view is opened"""
        if not ReadActions.checkWindow("Navigator"):
            InputActions.activateMenuItem("Window->Show View->Navigator")
            # TODO: removing because no RT-Exec snooze(0.5)
        ProjectOperation.expandAndCollapseAll("collapse")
        # TODO: removing because no RT-Exec snooze(0.5)

        """ Expand Discovered systems """
        discoveredSystemsLabel = "{caption='Discovered systems' container=" + Directory().getDiscoveredSystems() + " styletype='text' visible='true'}"
        doubleClick(waitForObject(discoveredSystemsLabel), 5, 5, 0, Button.Button1)
        # TODO: removing because no RT-Exec snooze(0.5)

    @classmethod
    def openSimpleContextMenuAndChoose(cls, object_real_name, option=None, x=None, y=None):
        """
        This method is used for checking type in combo box
        @param object_real_name: Real name of window (on which you want to open context menu)
        @param option: Choose option from context menu [Copy, Select All, Clear, ...] or only open context menu without option argument

        Usage:
        Common.openSimpleContextMenuAndChoose(ScriptingConsole().getConsoleArea())
        or
        Common.openSimpleContextMenuAndChoose(ScriptingConsole().getConsoleArea(), "Clear")
        """
        if x == None:
            x = 5
        if y == None:
            y = 5

        if option == None:
            try:
                mouseClick(waitForObject(object_real_name), x, y, 0, Button.Button3)
            except LookupError:
                test.fail("FAIL", "Unable to open context menu!")
        else:
            try:
                mouseClick(waitForObject(object_real_name), x, y, 0, Button.Button3)
                # TODO: removing because no RT-Exec snooze(2)
                activateItem(waitForObjectItem("{type='com.cirrus.scs.ide.ui.javafx.controls.SCSContextMenu' visible='true'}", option))
            except LookupError:
                test.fail("FAIL", "Unable to open or select \"" + option + "\" from context menu!")

    @classmethod
    def openRegisterMap(cls, system, device):
        """
        This method opens Register map from Directory view

        @param system [string] system name
        @param device [string] device name
        @return no return

        Usage:
        Common.openRegisterMap("System_1", "cs42l42")
        """
        Common.showDiscoveredSystem()
        systemName = Directory().getBoardName(system)
        if systemName != None:
            """ Expand Device or Simulated system"""
            systemNameLabel = "{caption='" + Directory().getBoardName(system) + "' container=" + Directory().getBoardOrSystem(Directory().getBoardName(system)) + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(systemNameLabel), 5, 5, 0, Button.Button1)
                snooze(0.5)
                # TODO: removing because no RT-Exec snooze(0.5)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + systemNameLabel + "'")
            # TODO: removing because no RT-Exec snooze(0.5)

            """ Expand module"""
            registerMapLable = "{caption='Register maps' container=" + Directory().getRegisterMap() + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(registerMapLable), 5, 5, 0, Button.Button1)
                snooze(0.5)
                # TODO: removing because no RT-Exec snooze(0.5)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + registerMapLable + "'")
            # TODO: removing because no RT-Exec snooze(0.5)

            """ Open Register map"""
            deviceNameLabel = "{caption='" + device + "' container=" + Directory().getDevice(device) + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(deviceNameLabel), 5, 5, 0, Button.Button1)
                snooze(0.5)
                # TODO: removing because no RT-Exec snooze(0.5)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + deviceNameLabel + "'")
            # TODO: removing because no RT-Exec snooze(0.5)

            if " " in device:
                device_name = device.split(" ")[0]
            else:
                device_name = device
            reg_map_label = "{caption='%s' container={caption='%s' container={caption='%s (%s)' " \
                            "parent.visible='true' type='org.eclipse.swt.custom.CTabItem' window={" \
                            "caption='SoundClear Studio' isvisible='true' type='org.eclipse.swt.widgets.Shell'}}" \
                            " id='deviceLabel' styletype='label' visible='true'} " \
                            "styletype='text' visible='true'}" % (device_name, device_name, device, device_name)
            if object.exists(reg_map_label):
                test.log("%s regmap is opened" % device)

    @classmethod
    def closeRegisterMap(cls, device):
        """
        This method close Register map from

        @param device [string] device name
        @return no return

        Usage:
        Common.closeRegisterMap("cs42l42")
        """

        reg_map_close_button = "{container={caption?='%s (*' parent.visible='true' " \
                               "type='org.eclipse.swt.custom.CTabItem' window={caption='SoundClear Studio' " \
                               "isvisible='true' type='org.eclipse.swt.widgets.Shell'}} " \
                               "type='com.froglogic.squish.swt.CTabCloseBox'}" % device
        try:
            mouseClick(waitForObject(reg_map_close_button), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on item '" + reg_map_close_button + "'")

    @classmethod
    def openRegisterMapOneClick(cls, system, device):
        '''
        This method opens Register map from Directory view with one click

        @param system [string] system name
        @param device [string] device name
        @return no return

        Usage:
        Common.openRegisterMapOneClick("System_1", "cs42l42")
        '''
        Common.showDiscoveredSystem()
        systemName = Directory().getBoardName(system)
        if systemName != None:
            """ Expand Device or Simulated system"""
            systemNameLabel = "{caption='" + Directory().getBoardName(system) + "' container=" + Directory().getBoardOrSystem(Directory().getBoardName(system)) + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(systemNameLabel), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + systemNameLabel + "'")

            """ Expand module"""
            registerMapLable = "{caption='Register maps' container=" + Directory().getRegisterMap() + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(registerMapLable), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + registerMapLable + "'")

            """ Open Register map"""
            deviceNameLabel = "{caption='" + device + "' container=" + Directory().getDevice(device) + " styletype='text' visible='true'}"
            try:
                mouseClick(waitForObject(deviceNameLabel), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + deviceNameLabel + "'")

    @classmethod
    def openRegisterMapInNewTab(cls, system, device):
        '''
        This method opens Register map in new tab from Directory view

        @param system [string] system name
        @param device [string] device name
        @return no return

        Usage:
        Common.openRegisterMapInNewTab("System_1", "cs42l42")
        '''
        Common.showDiscoveredSystem()

        systemName = Directory().getBoardName(system)
        if systemName != None:
            """ Expand Device or Simulated system"""
            systemNameLabel = "{caption='" + Directory().getBoardName(system) + "' container=" + Directory().getBoardOrSystem(Directory().getBoardName(system)) + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(systemNameLabel), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + systemNameLabel + "'")

            """ Expand module"""
            registerMapLable = "{caption='Register maps' container=" + Directory().getRegisterMap() + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(registerMapLable), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + registerMapLable + "'")

            """ Open Register map"""
            ProjectOperation.contextMenuSystemDirectory(Directory().getBoardOrSystem(device), "Open in new tab")

    @classmethod
    def openRegisterMapInSameTab(cls, system, device):
        """
        This method opens Register map in new tab from Directory view

        @param system [string] system name
        @param device [string] device name
        @return no return

        Usage:
        Common.openRegisterMapInSameTab(system, "cs42l42")
        """
        Common.showDiscoveredSystem()

        systemName = Directory().getBoardName(system)
        if systemName != None:
            """ Expand Device or Simulated system"""
            systemNameLabel = "{caption='" + Directory().getBoardName(system) + "' container=" + Directory().getBoardOrSystem(Directory().getBoardName(system)) + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(systemNameLabel), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + systemNameLabel + "'")

            """ Expand module"""
            registerMapLable = "{caption='Register maps' container=" + Directory().getRegisterMap() + " styletype='text' visible='true'}"
            try:
                doubleClick(waitForObject(registerMapLable), 5, 5, 0, Button.Button1)
            except LookupError:
                test.fail("FAIL", "Unable to click on item '" + registerMapLable + "'")

            """ Open Register map"""
            ProjectOperation.contextMenuSystemDirectory(Directory().getBoardOrSystem(device), "Open in same tab")

    @classmethod
    def selectRegister(cls, registerMapName, registerName):
        """
        This method adds register name in Search and selects register in Register Map

        @param registerMapName [string] name of Register map
        @param registerName [string] name of register
        @return no return

        Usage:
        Common.selectRegister("cs42l42 (CS42L42)", "Page Select")
        """
        regMapObj = RegisterMap(registerMapName)
        InputActions.mouseClickOnItem(regMapObj.getSearch())
        nativeType(registerName)
        register = regMapObj.getRegisterFromRegTable(registerName)
        snooze(0.1)
        InputActions.mouseClickOnItem(register, "left", True, 50, 5)

    @classmethod
    def changeRegisterValue(cls, column, row, container, newName):
        """
        This method change register value

        @param column [string] name of column
        @param row [string] name of row
        @param container [string] real name of container
        @param newName [string] new name of register
        @return no return

        Usage:
        Common.changeRegisterValue("Value", "0", RegisterMap("System_1", "USB Audio Module").getRegisterTable(), "0x01")
        """
        # TODO: removing because no RT-Exec snooze(0.5)
        rnCell = "{column='" + column + "' container=" + container + " row ='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        rnScrollBar = "{container=" + container + " styletype='scroll-bar' visible='true' orientation = 'HORIZONTAL'}"
        InputActions.mouseClickOnItem(rnCell, "left", True, 15, 15)
        # TODO: removing because no RT-Exec snooze(0.5)
        try:
            if object.exists(rnScrollBar):
                setValue(waitForObject(rnScrollBar), 99)
            # TODO: removing because no RT-Exec snooze(0.5)
        except LookupError:
                test.log("Scroll bar '" + rnScrollBar + "' not found")

        InputActions.mouseClickOnItem(rnCell, "left", True, 15, 15)
        # TODO: removing because no RT-Exec snooze(0.5)
        InputActions.mouseDoubleClickOnItem(rnCell, "left", True, 15, 15)
        # TODO: removing because no RT-Exec snooze(0.5)
        nativeType(newName)
        # TODO: removing because no RT-Exec snooze(0.5)
        nativeType("<Return>")
        # TODO: removing because no RT-Exec snooze(0.5)

    @classmethod
    def changeRegisterValueKeyboardArrows(cls, column, row, container, direction, number):
        """
        This method change value of registay with arrow

        @param column [string] name of column
        @param row [string] name of row
        @param container [string] real name of container
        @param direction [string] arrow direction
        @param number [int] new name of register
        @return no return

        Usage:
        Common.changeRegisterValue("Value", "0", RegisterMap("System_1", "USB Audio Module").getRegisterTable(), "Up", 5)
        Common.changeRegisterValue("Value", "0", RegisterMap("System_1", "USB Audio Module").getRegisterTable(), "Down", 7)
        """
        # TODO: removing because no RT-Exec snooze(0.5)
        rnCell = "{column='" + column + "' container=" + container + " row ='" + row + "' styletype='cell indexed-cell table-cell table-column scs-table-view-lastColumn' visible='true'}"
        try:
            mouseClick(waitForObject(rnCell, 5000), 15, 15, 0, Button.Button1)
            doubleClick(waitForObject(rnCell, 5000), 15, 15, 0, Button.Button1)
            # TODO: removing because no RT-Exec snooze(0.5)
            c = 0
            while (c <= number):
                nativeType("<" + direction + ">")
                c += 1
                # TODO: removing because no RT-Exec snooze(0.5)
            nativeType("<Return>")
            # TODO: removing because no RT-Exec snooze(0.5)
        except LookupError:
            test.fail("FAIL", "Unable to click on cell '" + rnCell + "'")

    @classmethod
    def openHistory(cls, deviceOrSysName):
        '''
        This method opens History view for selected device or simulated system

        @param deviceOrSysName[string] device or simulated system name
        @return no return

        Usage:
        Common.openHistory(system)
        '''
        historyObj = History(deviceOrSysName)
        InputActions.activateMenuItem("Window->Show View->History")
        # TODO: removing because no RT-Exec snooze(1)
        InputActions.mouseClickOnItem(historyObj.getHistoryDropDown(), "left", True, 10, 10)
        # TODO: removing because no RT-Exec snooze(0.5)
        InputActions.mouseClickOnItem(PopupListView().getPopupItem(deviceOrSysName))
        # TODO: removing because no RT-Exec snooze(0.5)
        InputActions.mouseClickOnButton(historyObj.getHistoryOkButton())
        # TODO: removing because no RT-Exec snooze(0.5)

    @classmethod
    def closeHistoryWindows(cls):
        '''
        This method close all History windows

        @return no return

        Usage:
        Common.closeHistoryWindows()
        '''
        # TODO: removing because no RT-Exec snooze(1)
        historyWindow = "{caption?='History:*' parent.visible='true' type='org.eclipse.swt.custom.CTabItem' window=" + MainShell().getMainWindow() + "}"
        while object.exists(historyWindow):
            try:
                mouseClick(waitForObject(historyWindow), 5, 5, 0, Button.Button2)
            except LookupError:
                test.fail("FAIL", "Unable to click on tab '" + historyWindow + "'")
        try:
            mouseClick(waitForObject(MainShell().getMainWindow()))
        except LookupError:
            test.fail("FAIL", "Unable to click on tab '" + MainShell().getMainWindow() + "'")

    @classmethod
    def getSystemsFromNewHistoryWindow(cls):
        """
        This method returns system from history window

        @return no return

        Usage:
        Common.getSystemsFromNewHistoryWindow()
        """
        systems = ""
        try:
            systems = str(waitForObject(History().getHistoryDropDown()).items)
        except LookupError:
            test.fail("FAIL", "Can not read propery")
        systemsList = re.split(", |\[|\]", systems)
        return systemsList

    @classmethod
    def selectAllInHistory(cls, system):
        """
        This method select all entries in History

        @param system [string] name of system
        @return no return

        Usage:
        Common.selectAllInHistory("System_1")
        """
        historyObject = History(system)
        # Click on first operation and select all
        zerothCell = historyObject.getHistoryCell("0", "Op")
        InputActions.mouseClickOnItem(zerothCell)

        testMachine = platform.system()
        if "Windows" in testMachine:
            nativeType("<Ctrl+a>")
        elif "Linux" in testMachine:
            sys.exit("Linux")
        elif "Darwin":
            nativeType("<Command+a>")
        else:
            sys.exit("OS not found")

    @classmethod
    def exportEmptyHistory(cls, system, fileName):
        """
        This method exports the history to a file to test data folder

        @param system [string] name of system
        @param fileName [string] name of file
        @return no return

        Usage example:
        Common.exportEmptyHistory(system, "new_file.py")
        """
        historyObject = History(system)

        try:
            # Full path with file name and extension
            fullPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + fileName

            # Click on export button
            InputActions.mouseClickOnItem(historyObject.getHistoryExport())

            # Click on export button
            test.log(fullPath)

            chooseFile(waitForObject(":SWT"), fullPath)
        except LookupError:
            test.fail("FAIL", "Couldn't click on " + History.getHistoryExport())

    @classmethod
    def exportHistoryRow(cls, system, fileName, row_number="0"):
        """
        This method exports the history row to a file to testdata folder

        @param system [string] name of system
        @param fileName[string] name of file
        @return no return

        Usage:
        Common.exportAllHistory(system, "new_file.py")
        """
        historyObject = History(system)

        try:
            # Full path with file name and extension
            testdata_fullPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + fileName

            # Click on first operation and select all
            historyDeviceCell = historyObject.getHistoryCell(row_number, "Device")
            InputActions.mouseClickOnItem(historyDeviceCell)

            # Click on export button
            InputActions.mouseClickOnItem(historyObject.getHistoryExport())

            # Click on export button
            test.log(testdata_fullPath)

            chooseFile(waitForObject(":SWT"), testdata_fullPath)
            return testdata_fullPath
        except LookupError:
            test.fail("FAIL", "Couldn't click on " + History.getHistoryExport())

    @classmethod
    def checkObjectProperty(cls, objProperty, value):
        """
        This method check if the object property has expected value.

        @param objProperty: the object property (e.g. <object real name>.<property name>)
        @param value: property value which should be string
        @return [bool] True if test passm False otherwise

        Usage:
        registerMap = waitForObject(Directory().getBoardOrSystem("Register map"))
        Common.checkObjectProperty(registerMap.index, "3")
        """
        if str(objProperty) == value:
            test.log("Property value '" + value + "' is valid")
            return True
        else:
            test.fail("FAIL", "Property value '" + value + "' is NOT valid")
            return False

    @classmethod
    def maximizeOrMinimizeWindow(cls, window):
        """
        This method double clicks on tab in order to maximize or minimize it.

        @param window[string] name of the window or tab
        @return no return

        Usage:
        Common.maximizeOrMinimizeWindow(window)
        """
        rnWindow = "{caption?='" + window + "' type='org.eclipse.swt.custom.CTabItem'}"
        try:
            doubleClick(waitForObject(rnWindow, 5000), 5, 5, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Couldn't find '" + window + "' window")

    @classmethod
    def setComboCheckBoxSysDirectory(cls, item, checked=True):
        """
        This method filters the systems in System Directory using combo-check-box.

        @param item [string] type of system (Local, Virtual, Network)
        @param checked [bool] decides whether to check or uncheck the desired system type
        @return no return

        Usage:
        Common.setComboCheckBoxSysDirectory("Local")
        Common.setComboCheckBoxSysDirectory("Virtual", False)
        """
        if not object.exists(Directory().getFilterCheckBox(item)):
            InputActions.mouseClickOnButton(Directory().getComboCheckBoxSearch())
        try:
            checkBox = waitForObject(Directory().getComboCheckBoxText())
            checkedItems = str(checkBox.text)
        except LookupError:
            test.fail("FAIL", "Can not find object or property")
        temp = re.split(", ", checkedItems)
        if checked == True:
            if checkedItems == "All Systems":
                pass
            elif item not in temp:
                InputActions.mouseClickOnButton(Directory().getFilterCheckBox(item))
                # There is a bug for combo checkbox - SCS-4533
                # When this bug will be fixed change next two lines
                #InputActions.mouseClickOnButton(Directory().getComboCheckBoxSearch())
                InputActions.mouseClickOnButton(Directory().getCTabItem())
        else:
            if checkedItems == "":
                pass
            elif checkedItems == "All Systems":
                InputActions.mouseClickOnButton(Directory().getFilterCheckBox(item))
                InputActions.mouseClickOnButton(WarningShell().getButton("YES"))
            elif item in temp:
                InputActions.mouseClickOnButton(Directory().getFilterCheckBox(item))
                InputActions.mouseClickOnButton(WarningShell().getButton("YES"))

    @classmethod
    def setComboCheckBoxFilterSystems(cls, item, checked=True):
        """
        This method filters the systems in Preferences -> Filter systems using combo-check-box.

        @param item [string]type of system (Local, Virtual, Network)
        @param checked [bool] decides whether to check or uncheck the desired system type

        Usage:
        Common.setComboCheckBoxSysDirectory("Local")
        Common.setComboCheckBoxSysDirectory("Virtual", False)
        """
        preferencesObj = Preferences()
        InputActions.activateMenuItem("Window->Preferences")
        InputActions.mouseClickOnItem(preferencesObj.getTreeItem("Filter systems"))
        InputActions.mouseClickOnButton(preferencesObj.getFilterSystemsComboBoxSearch())
        try:
            checkBox = waitForObject(Directory().getComboCheckBoxText())
            checkedItems = str(checkBox.text)
        except LookupError:
            test.fail("FAIL", "Can not find object or property")
        temp = re.split(", ", checkedItems)
        if checked == True:
            if checkedItems == "All Systems":
                pass
            elif item not in temp:
                InputActions.mouseClickOnButton(Directory().getFilterCheckBox(item))
        else:
            if checkedItems == "":
                pass
            elif checkedItems == "All Systems":
                InputActions.mouseClickOnButton(Directory().getFilterCheckBox(item))
                #InputActions.mouseClickOnButton(WarningShell().getButton("YES"))
            elif item in temp:
                InputActions.mouseClickOnButton(Directory().getFilterCheckBox(item))
                #InputActions.mouseClickOnButton(WarningShell().getButton("YES"))
        InputActions.mouseClickOnButton(preferencesObj.getFilterSystemsComboBoxSearch())
        InputActions.mouseClickOnButton(preferencesObj.getButton("OK"))

    @classmethod
    def checkDuplicateSystem(cls):
        """
        This method checks if there are duplicate system names displayed in System Directory
        under Discovered systems tab.

        @return no return

        Usage:
        Common.checkDuplicateSystem
        """
        systems = []
        temp = str(waitForObject(Directory().getDiscoveredSystems()).item.observables)
        temp = temp.replace("[", "")
        temp = temp.replace("]", "")
        temp = temp.replace("[", "")
        temp = temp.replace(", ", "")
        itemList = re.split(" : ", temp)
        for system in itemList:
            if "CirrusLink" in system:
                systems.append(system)
        for sys in systems:
            if systems.count(sys) > 1:
                test.fail("FAIL", "System '" + sys + "' is duplicate!")
            else:
                test.passes("PASS", "There are no duplicate systems.")

    @classmethod
    def exportAllHistory(cls, system, fileName):
        """
        This method exports the history to a file to testdata folder

        @param system [string] name of system
        @param fileName[string] name of file
        @return no return

        Usage:
        Common.exportAllHistory(system, "new_file.py")
        """
        historyObject = History(system)

        try:
            # Full path with file name and extension
            fullPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + fileName

            # Click on first operation and select all
            zerothCell = historyObject.getHistoryCell("0", "Op")
            InputActions.mouseClickOnItem(zerothCell)

            testMachine = platform.system()
            if "Windows" in testMachine:
                nativeType("<Ctrl+a>")
            elif "Linux" in testMachine:
                sys.exit("Linux")
            elif "Darwin":
                InputActions.mouseClickOnItem(zerothCell)
                nativeType("<Command+a>")
            else:
                sys.exit("OS not found")

            # Click on export button
            snooze(2)
            InputActions.mouseClickOnItem(historyObject.getHistoryExport())

            # Click on export button
            test.log(fullPath)

            chooseFile(waitForObject(":SWT"), fullPath)
            return fullPath
        except LookupError:
            test.fail("FAIL", "Couldn't click on " + History.getHistoryExport())

    @classmethod
    def filterHistory(cls, device, operation, deviceAdr):
        """
        This method check if operation presented in History Window

        @param device [string] name of device
        @param operation [string] operation
        @param deviceAdr [list] list of adres elements
        @return no return

        Usage:
        Common.filterHistory("System_1", "Read", ["cs42l42 (0x90)"])
        """
        InputActions.mouseClickOnItem(History(device).getFilterDropDown())
        # TODO: removing because no RT-Exec snooze(1)
        chechBoxItems = History(device).getHistoryDropDownName()
        items = re.split(", ", chechBoxItems)
        filterDefaultState = []
        print(items)
        for i in items:
            filterDefaultState.append(i)
        if operation in filterDefaultState:
            filterDefaultState.remove(operation)
        else:
            InputActions.mouseClickOnItem(History(device).getCheckBox(operation))
        for i in deviceAdr:
            if i in filterDefaultState:
                filterDefaultState.remove(i)
            else:
                InputActions.mouseClickOnItem(History(device).getCheckBox(i))
        for i in filterDefaultState:
            InputActions.mouseClickOnItem(History(device).getCheckBox(i))

    @classmethod
    def changeCheckBoxInHistoryCheckComboBox(cls, system, operation, columns=False):
        """
        This method change value in History check combo box

        @param system [string] system name
        @param operation [list] list of items in History check combo box (for example: [Write, Read])
        @param columns [bool] default False(change "All Operations, Status and Devices" combo check boxes)
                              True(change "All History Table Columns" check boxes)
        @return no return

        Usage:
        Common.changeCheckBoxInHistoryCheckComboBox("CDB42L42_0", ["Filter by last write", "Filter by last write", "Filter by last write", "Filter by last write"])
        Common.changeCheckBoxInHistoryCheckComboBox("CDB42L42_0", ["Page"], True)
        """
        scrollBar = "{container=" + PopupListView().getListView() + " styletype='scroll-bar' visible='true'}"
        tScroll = False
        if columns == False:
            InputActions.mouseClickOnItem(History(system).getFilterDropDown())
        else:
            InputActions.mouseClickOnItem(History(system).getColumnsDropDown())
        for op in operation:
            # TODO: removing because no RT-Exec snooze(1)
            if op == "Timestamp":
                try:
                    setValue(waitForObject(scrollBar), 1)
                except LookupError:
                    test.fail("FAIL", "Unable to click on cell '" + scrollBar + "'")
                # TODO: removing because no RT-Exec snooze(0.5)
                tScroll = True
            InputActions.mouseClickOnItem(History(system).getCheckBox(op))
            if tScroll:
                try:
                    setValue(waitForObject(scrollBar), 1)
                except LookupError:
                    test.fail("FAIL", "Unable to click on cell '" + scrollBar + "'")
                tScroll = False

    @classmethod
    def importHistory(cls, system, fileName, fromRefdata=True):
        """
        This method exports the history to a file to testdata folder

        @param system [string] name of system
        @param fileName [string] name of file
        @param fromRefdata [bool] if True import history file from refdata
                                  if False import history from testdata
        @return no return

        Usage:
        Common.importHistory(system, "new_file.py")
        """
        historyObject = History(system)

        try:
            # Full path with file name and extension
            if fromRefdata == True:
                fullPath = SuiteGlobals.PATH_TO_REFDATA_FOLDER + os.sep + fileName
            else:
                fullPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + fileName
            # TODO: removing because no RT-Exec snooze(1)

            # Click on import button
            InputActions.mouseClickOnItem(historyObject.getHistoryImport())

            # Import the file using full path with file name and extension
            chooseFile(waitForObject(":SWT"), fullPath)
        except LookupError:
            test.fail("FAIL", "Couldn't click on " + History.getHistoryImport())

    @classmethod
    def clearHistory(cls, system):
        """
        This method clicks on Clear button on History window

        @param system [string] name of system
        @retutn no return

        Usage:
        Common.clearHistory(system)
        """
        historyObject = History(system)

        try:
            # Click on close button
            # TODO: removing because no RT-Exec snooze(1)
            InputActions.mouseClickOnItem(historyObject.getHistoryClear())
        except LookupError:
            test.fail("FAIL", "Couldn't click on " + History.getHistoryClear())

    @classmethod
    def parseSrsFile(cls, fullPath):
        '''
        This method reads srs file and returns a list with
        following content:
        [{address0:value0}, {address1:value1}, ...]
        Common.parseSrsFile("D:\\file.srs")

        @param fullPath [string] contains path to srs file
        @retutn outputList [list] a list with following content:
                                  [{address0:value0}, {address1:value1}, ...]
                                  Common.parseSrsFile("D:\\file.srs")

        Usage:
        Common.parseSrsFile(path)
        '''
        outputList = []
        tempDict = {}
        srsFile = open(fullPath, "r")

        while True:
            line = srsFile.readline()
            if not line:
                break
            if line[0:2] == "0x":
                address, value = line.split(" = ")
                value = value.strip()
                if len(address) == 3:
                    address = "0x0" + address[2]
                if len(value) == 3:
                    value = "0x0" + value[2]
                tempDict[address] = value.strip()
                outputList.append(tempDict)
                tempDict = {}

        return outputList
        srsFile.close()

    @classmethod
    def parseHistFile(cls, fullPath):
        """
        This method parses the hist file

        @param fullPath [string] contains path to hist file
        @return outputList [list] list of elements from xml

        Usage:
        Common.verifyFileSaved(SuiteGlobals.PATH_TO_TESTDATA_FOLDER + filenameHist + "new_file.py")
        """
        from xml.parsers.expat import ExpatError
        import builtins

        xmldoc = minidom.parse(fullPath)
        try:
            historyElements = xmldoc.getElementsByTagName("HistoryItems")
            tempDict = {}
            outputList = []
            i = 0
            for historyElement in historyElements:
                    numberOfItems = historyElement.getElementsByTagName("addr").length
                    while i < numberOfItems:
                        address = historyElement.getElementsByTagName("addr")[i]
                        value = historyElement.getElementsByTagName("value")[i]
                        address = address.firstChild.data
                        value = value.firstChild.data
                        address = builtins.int(address)
                        value = builtins.int(value)
                        address = builtins.hex(address)
                        value = builtins.hex(value)
                        address = str(address)
                        value = str(value)
                        if len(address) == 3:
                            address = "0x0" + address[2]
                        if len(value) == 3:
                            value = "0x0" + value[2]
                        tempDict[address] = value
                        outputList.append(tempDict)
                        tempDict = {}
                        i += 1
            return outputList
        except ExpatError:
            test.fail("FAIL", "File is not XML based")

    @classmethod
    def getHistoryLength(cls, system):
        """
        Method to read number of entries in history window
        param system [str] System name as it appears in Navigator
        return [int] number of entries in history window
        """
        history_length = waitForObject(History(system).getTable()).items.length
        return history_length

    @classmethod
    def get_history_prop(cls):
        """
        This method returns history window property type
        """
        if LooseVersion(get_scs_version()) >= LooseVersion("1.7.8"):
            history_prop_type = 'text'
        else:
            history_prop_type = 'item'
        return history_prop_type

    @classmethod
    def parseHistoryTabAddressValue(cls, system):
        '''
        This method reads history tab and returns a list with
        following content:
        [{address0:value0}, {address1:value1}, ...]

        @param system [string] name of system
        @return outputList [list] list with following content:
                                    [{address0:value0}, {address1:value1}, ...]

        Usage:
        Common.parseHistoryTabAddressValue("System_1")
        '''
        row = 0
        historyLength = 0
        tempDict = {}
        outputList = []
        InputActions.doubleClickOnTab("History: " + system)
        try:
            historyLength = waitForObject(History(system).getTable()).items.length
        except LookupError:
            test.fail("Fail", "Can not find object or property")
        while(row < historyLength):
            address = ReadActions.readTextFromTable("Address", str(row), "History",
                                                    history_prop_type=cls.get_history_prop())
            value = ReadActions.readTextFromTable("Data", str(row), "History",
                                                  history_prop_type=cls.get_history_prop())
            address = address.replace("(...)", "")
            address = address.replace(" ", "")
            value = value.replace("(...)", "")
            value = value.replace(" ", "")
            tempDict[address] = value
            outputList.append(tempDict)
            tempDict = {}
            nativeType("<Down>")
            row += 1
        InputActions.doubleClickOnTab("History: " + system)
        return outputList

    @classmethod
    def parseHistoryTabOperationValue(cls, system, text_type="Op"):
        '''
        This method reads history tab and returns a list with
        following content:
        [{address0:value0}, {address1:value1}, ...]

        @param system [string] name of system
        @return outputList [list] list with following content:
                                    [{address0:value0}, {address1:value1}, ...]

        Usage:
        Common.parseHistoryTabOperationValue("System_1")
        '''
        row = 0
        historyLength = 0
        tempDict = {}
        outputList = []
        InputActions.doubleClickOnTab("History: " + system)
        try:
            historyLength = waitForObject(History(system).getTable()).items.length
        except LookupError:
            test.fail("Fail", "Can not find object or property")
        while(row < historyLength):
            operation = ReadActions.readTextFromTable(text_type, str(row), "History",
                                                      history_prop_type=cls.get_history_prop())
            value = ReadActions.readTextFromTable("Data", str(row), "History",
                                                  history_prop_type=cls.get_history_prop())
            operation = operation.replace(" ", "")
            value = value.replace("(...)", "")
            value = value.replace(" ", "")
            tempDict[operation] = value
            outputList.append(tempDict)
            tempDict = {}
            nativeType("<Down>")
            row += 1
        InputActions.doubleClickOnTab("History: " + system)
        return outputList
    
    @classmethod
    def parseHistoryTabAndAddressValues(cls, system, text_type="Op"):
        '''
        This method reads history tab and returns a list with
        following content:
        [{address0:value0}, {address1:value1}, ...]

        @param system [string] name of system
        @return outputList [list] list with following content:
                                    [{address0:value0}, {address1:value1}, ...]

        Usage:
        Common.parseHistoryTabAndAddressValues("System_1")
        Common.parseHistoryTabAndAddressValues("System_1", "Data")
        '''
        row = 0
        historyLength = 0
        tempDict = {}
        outputList = []
        InputActions.doubleClickOnTab("History: " + system)
        try:
            historyLength = waitForObject(History(system).getTable()).items.length
        except LookupError:
            test.fail("Fail", "Can not find object or property")
        while(row < historyLength):
            operation = ReadActions.readTextFromTable(text_type, str(row), "History",
                                                      history_prop_type=cls.get_history_prop())
            value = ReadActions.readTextFromTable("Address", str(row), "History",
                                                  history_prop_type=cls.get_history_prop())
            operation = operation.replace(" ", "")
            value = value.replace("(...)", "")
            value = value.replace(" ", "")
            tempDict[value] = operation
            outputList.append(tempDict)
            tempDict = {}
            nativeType("<Down>")
            row += 1
        InputActions.doubleClickOnTab("History: " + system)
        return outputList

    @classmethod
    def SearchInHistory(cls, system, text, row, column):
        """
        This method search some text in History table

        @param system [string] system name
        @param text [string] text to search in History
        @param row [string] row number
        @param column [string] column name
        @return no return

        Usage:
        Common.SearchInHistory(boardName, "Block Read", "1", "Operation")
        """
        historyObj = History(system)
        InputActions.mouseClickOnButton(historyObj.getHistorySearch())
        nativeType(text)
        snooze(0.2)
        # TODO: removing because no RT-Exec snooze(2)
        highlighted = "{caption='" + text + "' container=" + historyObj.getHistoryCell(row, column) \
                      + " styletype='label scs-label-highlighted' visible='true'}"
        if object.exists(highlighted):
            test.passes("PASS", text + " exists in History table")
        else:
            test.fail("FAIL", text + " not exist in History table")

    @classmethod
    def _typeInFilter(cls, system, filter_text):
        historyObj = History(system)
        snooze(0.5)
        InputActions.mouseDoubleClickOnItem(historyObj.getHistoryFilter())
        InputActions.mouseClickOnItem(historyObj.getHistoryFilter())
        snooze(2)
        nativeType(filter_text)
        snooze(3)

    @classmethod
    def clearHistoryFilter(cls, system):
        historyObj = History(system)
        InputActions.mouseDoubleClickOnItem(historyObj.getHistoryFilter())
        InputActions.mouseClickOnItem(historyObj.getHistoryFilter())
        snooze(0.5)
        machine = platform.system()
        if "Darwin" in machine:
            nativeType("<Command+a>")
            nativeType("<Delete>")
        elif 'Windows' in machine:
            nativeType("<Ctrl+a>")
            nativeType("<Delete>")
        snooze(0.5)

    @classmethod
    def searchInFilter(cls, system, filter_text, operation, get_last_row=False, delete_filter=True,
                       history_prop_type='text'):
        historyObj = History(system)
        Common._typeInFilter(system, filter_text)
        row = 0
        try:
            historyLength = waitForObject(historyObj.getTable()).items.length
            if historyLength == 0:
                test.fail("Fail", "history length is : %s" % historyLength)
                return
        except LookupError:
            test.fail("Fail", "Can not find object or property")
            return
        if historyLength > 7:
            row = historyLength - 6
        ret_values = []
        if get_last_row:
            operation_val = ReadActions.readTextFromTable(operation, str(historyLength - 1), "History", system,
                                                          history_prop_type=cls.get_history_prop())
            ret_values.append(operation_val)
        else:
            while(row < historyLength):
                operation_val = ReadActions.readTextFromTable(operation, str(row), "History", system,
                                                              history_prop_type=cls.get_history_prop())
                ret_values.append(operation_val)
                row += 1
        InputActions.mouseDoubleClickOnItem(historyObj.getHistoryFilter())
        InputActions.mouseClickOnItem(historyObj.getHistoryFilter())
        machine = platform.system()
        if "Darwin" in machine and delete_filter:
            nativeType("<Command+a>")
            nativeType("<Delete>")
        elif 'Windows' in machine and delete_filter:
            nativeType("<Ctrl+a>")
            nativeType("<Delete>")
        return ret_values

    @classmethod
    def compareSrsFileToTab(cls, fullPathToFile, system):
        '''
        This method compares the contents of a srs file
        to the contents of the history tab

        @param fullPathToFile [path to file] path to srs file
        @param system [string] name of system
        @return no return
        Usage:
        Common.compareSrsFileToTab("D:\\file.srs", "System_1")
        '''
        fileMatchesTab = False
        listFromFile = Common.parseSrsFile(fullPathToFile)
        listFromTab = Common.parseHistoryTabAddressValue(system)

        if listFromFile == listFromTab:
            fileMatchesTab = True

        if fileMatchesTab:
            test.passes("PASS", "History matches the file")
        else:
            test.fail("FAIL", "History does not match the file")

    @classmethod
    def checkConnectionStatus(cls, system):
        """
        This method checks and return the system status.

        @param system: the system name
        @return no return

        Usage:
        Common.checkConnectionStatus("System1")
        """
        status = ""
        directoryObj = Directory()
        boardRealName = directoryObj.getBoardOrSystem(system)
        itemconnectionstatus = ""
        if object.exists(boardRealName):
            try:
                itemconnectionstatus = str(waitForObject(boardRealName).item.itemconnectionstatus)
            except Exception as e:
                    test.fail("FAIL", str(e))

            if itemconnectionstatus == "AVAILABLE":
                status = "available"
            elif itemconnectionstatus == "CONNECTED":
                status = "connected"
            elif itemconnectionstatus == "NOT_AVAILABLE":
                status = "unavailable"
            elif itemconnectionstatus == "IN_STASIS":
                status = "stasis"
            else:
                status = False
            return status
        else:
            test.fail("FAIL", "There is no " + system + " in navigator")

    @classmethod
    def checkRegistersState(cls, deviceList, systemOrDevice):
        """
        This method check the default values of registers.

        @param deviceList [list] list which contains the names of xml files for devices
        @param systemOrDevice [string] the name of system or device (in IDE) which will be tested
        @note:  deviceList should be given in the same order as in IDE (example: for cdb42l42 system order is: cs42l42, usb_audio_module)
        @return no return

        Usage:
        deviceList = ["cs42l42", "usb_audio_module"]
        Common.checkRegistersState(deviceList, vSystem)
        """
        set1 = False
        set2 = False
        temp1 = ""
        temp2 = ""
        refRegisterList = []
        refPath = os.getcwd()
        refPath = os.path.dirname(refPath) + os.sep + "shared"

        for device in deviceList:
            pageList = []
            tempList = []

            filePath = refPath + os.sep + "refdata" + os.sep + device + ".xml"
            fileXML = minidom.parse(filePath)
            registers = fileXML.getElementsByTagName("Register")
            for register in registers:
                page = register.getElementsByTagName("Page")[0]
                if str(page.firstChild.data) not in pageList:
                    pageList.append(str(page.firstChild.data))

            pageList.sort()
            i = len(pageList)
            for page in pageList:
                filePath = refPath + os.sep + "refdata" + os.sep + device + ".xml"
                fileXML = minidom.parse(filePath)
                registers = fileXML.getElementsByTagName("Register")
                for register in registers:
                    if str(register.getElementsByTagName("Page")[0].firstChild.data) == page:
                        address = register.getElementsByTagName("Address")[0]
                        val = register.getElementsByTagName("DefaultValue")[0]
                        if len(address.firstChild.data) == 3:
                            temp1 = address.firstChild.data = '0x0' + address.firstChild.data[2]
                            set1 = True
                        if len(val.firstChild.data) == 3:
                            temp2 = val.firstChild.data = '0x0' + val.firstChild.data[2]
                            set2 = True
                        if set1 and set2:
                            tempList.append(str(temp1) + " = " + str(temp2))
                            set1 = False
                            set2 = False
                        elif not set1 and set2:
                            tempList.append(str(address.firstChild.data) + " = " + str(temp2))
                            set2 = False
                        elif set1 and not set2:
                            tempList.append(str(temp1) + " = " + str(val.firstChild.data))
                            set1 = False
                        else:
                            tempList.append(str(address.firstChild.data) + " = " + str(val.firstChild.data))

            for i in list(range(len(tempList))):
                refRegisterList.append(tempList[i])

            del tempList
            del pageList

        FilePath = refPath + os.sep + "testdata" + os.sep + systemOrDevice + "_registers.srs"
        with open(FilePath, 'rb') as file:
            currentState = file.readlines()

        for element in currentState:
            if len(element) > 20:
                currentState.remove(element)
        for element in currentState:
            if element[0] != '0':
                currentState.remove(element)
        for element in currentState:
            if element == '\n':
                currentState.remove(element)

        del currentState[0]
        currentState = [s.strip() for s in currentState]

        for i in list(range(len(currentState))):
            temp = currentState[i].split(" = ")
            if len(temp[0]) == 3:
                temp[0] = "0x0" + temp[0][2]
            if len(temp[1]) == 3:
                temp[1] = "0x0" + temp[1][2]
            currentState[i] = temp[0] + " = " + temp[1]

        for i in list(range(len(currentState))):
            if len(currentState) == len(refRegisterList):
                if currentState[i] != refRegisterList[i]:
                    test.fail("FAIL", "Current register value on address: '" + currentState[i] +
                              "' is not set to default: '" + refRegisterList + "'!")
            else:
                test.fail("FAIL", "Number of registers doesn't fit the number from register description in xml file")
                break

    @classmethod
    def changeHistorySize(cls, value, error=False):
        """
        This method change history size

        @param value [int] history size
        @param error [bool] If True, it is expected that value is correct.
                      If False, it is expected that value causes error and apply and OK buttons should be disabled
        @retutn no return

        Usage:
        Common.changeHistorySize(5000)
        Common.changeHistorySize(5, True)
        """
        InputActions.activateMenuItem("Window->Preferences")
        preferencesObj = Preferences()
        InputActions.mouseClickOnItem(preferencesObj.getTreeItem("History"))
        try:
            doubleClick(waitForObject(preferencesObj.getHistoryPane()), 5, 5, 0, Button.Button1)
            nativeType(value)
        except LookupError:
            test.fail("FAIL", "Unable to double click on text box")
        if error == False:
            InputActions.mouseClickOnButton(preferencesObj.getButton("OK"))
        else:
            # TODO: removing because no RT-Exec snooze(0.5)
            try:
                applyObj = findObject(preferencesObj.getButton("APPLY"))
            except LookupError:
                test.fail("FAIL", "Object does not exist")
            try:
                okObj = findObject(preferencesObj.getButton("OK"))
            except LookupError:
                test.fail("FAIL", "Object does not exist")
            try:
                if applyObj.disabled == True and okObj.disabled == True:
                    test.passes("PASS", "Apply and OK buttons are disabled")
            except AttributeError:
                test.fail("FAIL", "Property does not exist")
            InputActions.mouseClickOnButton(preferencesObj.getButton("CANCEL"))

    @classmethod
    def check_if_scs_link_is_running(cls):
        """
        If scs_link.exe is running this function will log it out

        @return no return

        Usage:
        Common.check_if_scs_link_is_running()
        """
        if platform.system() == "Windows":
            i = 0
            cmd = 'WMIC PROCESS get Caption'
            try:
                proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            except Exception as err:
                test.fail("FAIL", "Unable to open processes from terminal, " + str(err))
            for line in proc.stdout:
                if "scs_link.exe" in line:
                    test.log("scs_link.exe exists")
                    i += 1
                    return True
            if i == 0:
                test.log("scs_link.exe doesn't exist")
                return False

        elif platform.system() == "Darwin":
            cmd = 'top'
            proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            # TODO: removing because no RT-Exec snooze(1)
            proc.kill()
            flag = False
            for line in iter(proc.stdout.readline, ''):
                print(line.rstrip())
                if "MacLink" in line.rstrip():
                    test.log("MacLink running")
                    flag = True
            if flag != True:
                test.log("MacLink is not running")
            return flag
        elif platform.system() == "Linux":
            cmd = 'top'
            try:
                proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            except LookupError:
                test.fail("FAIL", "Unable to open processes from terminal")
            for line in proc.stdout:
                if "scs_link.exe" in line:
                    test.log("scs_link.exe exists")
                    return True
            os.system("killall top")

    @classmethod
    def check_if_scs_process_is_running(cls):
        """
        If SoundClearStudio.exe is running this function will log it out

        @return no return

        Usage:
        Common.check_if_scs_process_is_running()
        """
        if platform.system() == "Windows":
            i = 0
            cmd = 'WMIC PROCESS get Caption'
            try:
                proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            except LookupError:
                test.fail("FAIL", "Unable to open processes from terminal")
            for line in proc.stdout:
                if "SoundClearStudio.exe" in line:
                    test.log("SoundClearStudio.exe exists")
                    i += 1
                    return True
            if i == 0:
                test.log("SoundClearStudio.exe doesn't exist")
                return False

        elif platform.system() == "Darwin":
            cmd = 'top'
            proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            # TODO: removing because no RT-Exec snooze(1)
            proc.kill()
            flag = False
            for line in iter(proc.stdout.readline, ''):
                print(line.rstrip())
                if "SoundClearSt" in line.rstrip():
                    test.log("SoundClearSt running")
                    flag = True
            if flag != True:
                test.log("SoundClearSt is not running")
            return flag

        elif platform.system() == "Linux":
            cmd = 'top'
            try:
                proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
            except LookupError:
                test.fail("FAIL", "Unable to open processes from terminal")
            for line in proc.stdout:
                if "SoundClearStudio.exe" in line:
                    test.log("SoundClearStudio.exe exists")
                    return True
            os.system("killall top")

    @classmethod
    def kill_scs_link(cls):
        """
        This method is used for killing scs link

        @return no return

        Usage:
        Common.kill_scs_link()
        """

        if platform.system() == "Windows":

            while Common.check_if_scs_link_is_running() == True:
                os.system("TASKKILL /F /IM scs_link.exe")
                # TODO: removing because no RT-Exec snooze(3)
                test.log("scs_link killed")

        elif platform.system() == "Darwin":

            while Common.check_if_scs_link_is_running() == True:
                os.system("pkill MacLink")
                # TODO: removing because no RT-Exec snooze(3)
                test.log("MacLink killed")

        elif platform.system() == "Linux":

            while Common.check_if_scs_link_is_running() == True:
                os.system("killalll LinuxLink")
                test.log("LinuxLink killed")

    @classmethod
    def kill_scs_process(cls):
        """
        This method is used for killing scs process

        @return no return

        Usage:
        Common.kill_scs_process()
        """

        if platform.system() == "Windows":

            while Common.check_if_scs_process_is_running() == True:
                os.system("TASKKILL /F /IM SoundClearStudio.exe")
                # TODO: removing because no RT-Exec snooze(3)
                test.log("SoundClearStduio.exe killed")

        elif platform.system() == "Darwin":

            while Common.check_if_scs_process_is_running() == True:
                os.system("pkill SoundClearSt")
                # TODO: removing because no RT-Exec snooze(3)
                test.log("SoundClearSt killed")

        elif platform.system() == "Linux":

            while Common.check_if_scs_process_is_running() == True:
                os.system("killalll LinuxLink")
                test.log("LinuxLink killed")

    @classmethod
    def check_if_scs_is_running(cls):
        """
        This method check if scs is running

        @return no return

        Usage:
        Common.check_if_scs_is_running()
        """
        try:
            waitForObject(MainShell().getMainWindow())
            if ReadActions().IDERunning():
                test.passes("PASS", "SoundClearStudio is running")
            else:
                test.fail("FAIL", "SoundClearStudio is not running")
        except LookupError:
            test.fail("FAIL", "SoundClearStudio is not running")

    @classmethod
    def killSCS(cls):
        """
        This method is used for killing SoundClear Studio process
        @return no return

        Usage:
        Common.killSCS()
        """
        if platform.system() == "Windows":
            while ReadActions.IDERunning() == True:
                os.system("TASKKILL /F /IM SoundClearStudio.exe")
                # TODO: removing because no RT-Exec snooze(3)
                test.log("SoundClear Studio killed")
        elif platform.system() == "Darwin":
            while ReadActions.IDERunning() == True:
                os.system("pkill SoundClear Studio")
                # TODO: removing because no RT-Exec snooze(3)
                test.log("SoundClear Studio killed")
        else:
            test.fail("FAIL", "No system found")

    @classmethod
    def waitForAnimation(cls):
        """
        Check if animation is running

        @return no return

        Usage:
        Common.waitForAnimation()
        """
        running = True
        time = 0
        if platform.system() == "Windows":
            cmd = 'wmic process get Caption,ExecutablePath'
            while (running == True):
                running = False
                try:
                    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
                except LookupError:
                    test.fail("FAIL", "Unable to open processes from terminal")
                for line in proc.stdout:
                    if SuiteGlobals.getSCSJavaPath() in line:
                        running = True
                if running == False:
                    test.log("animation is not running/is finished")
                    break
                # GUI tests need this snooze to wait and poll again
                snooze(0.5)
                time += 0.5
                if time > 300:
                    test.fail("FAIL", "Animation is still active after 300s")

        elif platform.system() == "Darwin":
            cmd = 'ps ax'
            # Putting snooze because on Austin 1st Jenkins mac machine taking time
            snooze(15)
            while (running == True):
                running = False
                try:
                    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
                    # Wait for process to start
                    snooze(0.5)
                except LookupError:
                    test.fail("FAIL", "Unable to open processes from terminal")
                for line in proc.stdout:
                    if os.sep + "Contents" + os.sep + "splash" + os.sep + "SoundClearStudio.app/Contents/MacOS/SoundClearStudio" in line:
                        running = True
                if running == False:
                    test.log("animation is not running/is finished")
                    break
                # GUI tests need this snooze to wait and poll again
                snooze(0.5)
                time += 0.5
                if time > 300:
                    test.fail("FAIL", "Animation is still active after 300s")

        while(not object.exists(Welcome().getWelcomeWindow()) or not object.exists(MainShell().getMainWindow())):
            snooze(0.5)


    @classmethod
    def searchDirectoryContent(cls, name):
        """
        This method search the Directory content using text-box.

        @param name: the name of content
        @return no return

        Usage:
        Common.searchDirectoryContent("Project1")
        Common.searchDirectoryContent("System1")
        """
        try:
            mouseClick(waitForObject(Directory().getSearchTextField()), 5, 5, 0, Button.Button1)
            if "Windows" in SuiteGlobals.testMachine:
                nativeType("<Ctrl+a>")
            elif "Linux" in SuiteGlobals.testMachine:
                sys.exit("Linux")
            elif "Darwin":
                nativeType("<Command+a>")
            else:
                sys.exit("OS not found")
            # TODO: removing because no RT-Exec snooze(0.5)
            nativeType("<Delete>")
            type(waitForObject(Directory().getSearchTextField(), 5000), name)
            nativeType("<Return>")
        except LookupError:
            test.fail("FAIL", "Unable to click on tab '" + Directory().getSearchTextField() + "'")

    @classmethod
    def closeIDE(cls, killLink=True):
        """
        This method closes SCS and kills link

        @param killLink [bool] default True(link will be killed)
                                        False(link will not be killed)
        @return no return

        Usage:
        Common.closeIDE(False)
        """
        testMachine = platform.system()
        if "Windows" in testMachine:
            exit = InputActions.activateMenuItem("File->Quit")
        elif "Darwin" in testMachine:
            exit = InputActions.activateMenuItem("SoundClear Studio->Quit SoundClear Studio")
        else:
            test.log("No system found")
        if exit:
            confirm_yes_button = ConfirmShell().getConfirmShellButton("YES")
            if object.exists(confirm_yes_button):
                InputActions.mouseClickOnButton(confirm_yes_button)
            test.log("Closed SoundClear Studio")
        else:
            Common.killSCS()
            test.fail("FAIL", "SoundClear Studio is closed by forse using task kill command")
        if killLink == True:
            Common.kill_scs_link()

    @classmethod
    def setToDefault(cls):
        """
        This method sets the IDE to a default state

        @return no return

        Usage:
        Common.setToDefault()
        """
        # TODO: removing because no RT-Exec snooze(1)
        Common.closeHistoryWindows()
        regMap = "{caption?='*' type='org.eclipse.swt.custom.CTabItem' item.tooltiptext?='*/*'}"
        if object.exists(regMap):
            try:
                mouseClick(waitForObject(regMap), 5, 5, 0, Button.Button3)
                nativeType("<Up>")
                nativeType("<Return>")
            except LookupError:
                test.fail("FAIL", "Unable to click on tab '" + middleWindow + "'")

    @classmethod
    def startSCSLink(cls, background=False):
        """
        This method start scs link

        @return no return

        Usage:
        Common.startSCSLink
        """
        testMachine = platform.system()
        if "Windows" in testMachine:
            if background == True:
                cmd = SuiteGlobals.getLinkPath() + SuiteGlobals.getLinkName()
                try:
                    subprocess.Popen(cmd, shell=True)
                except Exception as err:
                    test.fail("FAIL", str(err))
            else:
                os.system("start " + SuiteGlobals.getLinkPath() + SuiteGlobals.getLinkName())
        elif "Darwin" in testMachine:
            cmd = "\'" + SuiteGlobals.getLinkPath() + SuiteGlobals.getLinkName() + "\'" + " -target"
            test.log(cmd)
            try:
                subprocess.Popen(cmd, shell=True)
            except Exception as err:
                    test.fail("FAIL", str(err))

    @classmethod
    def startAUT(cls, welcome=False, perspective="Configure", delete_testdata=True):

        """
        This method starts or attaches to AUT,
        depending on the state of CODE_COVERAGE
        variable from globals.py

        @param welcome [bool] default False(close Welcome)
                                      True (do not close Welcome)
        @return no return

        Usage:
        Common.startAUT()
        Common.startAUT(True)
        """
        mainShelObj = MainShell()
        welcomeObj = Welcome()
        testSettings.logScreenshotOnError = True
        Bsp.removeTemporaryAndRestorePackages(False)
        scs_version = get_scs_version()
        scs_major_ver = 0
        scs_version = scs_version.split('.')
        if scs_version > 2:
            scs_major_ver = float('.'.join(scs_version[:2]))
        if SuiteGlobals.CODE_COVERAGE:
        # Attach to SCS IDE
            attachToApplication("javaw.exe")
            # TODO: removing because no RT-Exec snooze(3)
            if welcome == False:
                if delete_testdata:
                    Common.deleteTestdataContent()
                # TODO: removing because no RT-Exec snooze(0.5)
                if scs_major_ver < 1.7:
                    Common.checkAndChangePerspective(perspective)
                else:
                    Common.ResetPerspective()
                # TODO: removing because no RT-Exec snooze(0.5)
                Common.deleteAllVirtualSystems()
                ProjectOperation.deleteAllProjects()
        else:
        # Start SoundClear Studio
            """ Start SCS ide"""
            scsIde = SuiteGlobals.getSCSIdeName()
            startApplication(scsIde)
            scs_object = waitForObject("{type='org.eclipse.swt.widgets.Shell' visible='true'}")
            scs_object.forceActive()
            snooze(5)
            # attachToApplication(scsIde.split(".")[0])
            """ Check if animation is running """
            Common.waitForAnimation()
            """ Close Welcome Screen """
            # TODO: removing because no RT-Exec snooze(5)
            if welcome == False:
                Common.closeWelcomeWindow()
                # TODO: removing because no RT-Exec snooze(1)
                """ Maximize SCS Window"""
                InputActions.maximizeWindow(window=mainShelObj.getMainWindow())
                # TODO: removing because no RT-Exec snooze(1)
                if delete_testdata:
                    Common.deleteTestdataContent()
                # TODO: removing because no RT-Exec snooze(0.5)
                if scs_major_ver < 1.7 :
                    Common.checkAndChangePerspective(perspective)
                else:
                    Common.ResetPerspective()
                # TODO: removing because no RT-Exec snooze(0.5)
                if not ReadActions.checkWindow("Navigator"):
                    InputActions.activateMenuItem("Window->Show View->Navigator")
                    # TODO: removing because no RT-Exec snooze(0.5)
                """ Be sure that all system types are checked"""
                try:
                    checkBox = waitForObject(Directory().getComboCheckBoxText())
                    checkedItems = str(checkBox.text)
                except LookupError:
                    test.fail("FAIL", "Can not find object or property")
                if checkedItems == "All Systems":
                    pass
                else:
                    Common.setComboCheckBoxSysDirectory("Local")
                    Common.setComboCheckBoxSysDirectory("Virtual")
                    Common.setComboCheckBoxSysDirectory("Network", checked=False)
                # TODO: removing because no RT-Exec snooze(0.5)
                # Common.deleteAllVirtualSystems()
                # ProjectOperation.deleteAllProjects()
            else:
                if object.exists(welcomeObj.getCloseWelcomeLabel()):
                    try:
                        obj = waitForObject(welcomeObj.getWelcomeWindow())
                        obj.forceActive()
                    except LookupError:
                        test.fail("FAIL", "Can not access '" + welcomeObj.getWelcomeWindow() + "'")
                else:
                    try:
                        obj = waitForObject(mainShelObj.getMainWindow())
                        obj.forceActive()
                    except LookupError:
                        test.fail("FAIL", "Can not access '" + mainShelObj.getMainWindow() + "'")

    @classmethod
    def endAUT(cls, killSCS=True):
        """
        This method closes or sets the AUT to default state,
        depending on the state of CODE_COVERAGE
        variable from globals.py
        @param killSCS [bool] default True(SoundClearStudio.exe process and scs_link will be killed)
                                        False(SoundClearStudio.exe process will not be killed)
        @return no return

        Usage:
        Common.endAUT()
        """
        if SuiteGlobals.CODE_COVERAGE:
            # Set the IDE to default state
            Common.setToDefault()
        else:
            # Close IDE and kill link process
            Common.closeIDE(killLink=killSCS)

    @classmethod
    def verifyFileSaved(cls, filename):
        """
        This method checks if the file is saved to testdata folder

        @param fileName [string] name of file
        @return no return

        Usage:
        Common.verifyFileSaved("new_file.py")
        """
        # TODO: removing because no RT-Exec snooze(0.5)
        fullPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + filename
        if os.path.exists(fullPath):
            test.passes("PASS", fullPath + " exists")
        else:
            test.fail("FAIL", fullPath + " does not exist")

    @classmethod
    def verifyFileXMLBased(cls, fullPath):
        """
        This method checks if the file is XMLBased

        @param fullPath [string] contains path to file
        @return no return

        Usage:
        Common.verifyFileSaved(SuiteGlobals.PATH_TO_TESTDATA_FOLDER + filenameHist + "new_file.py")
        """
        from xml.parsers.expat import ExpatError

        try:
            minidom.parse(fullPath)
            test.passes("PASS", "File is XML based")
        except ExpatError:
            test.fail("FAIL", "File is not XML based")

    @classmethod
    def verifyFilePython(cls, fullPath):
        """
        This method checks if the file is a Python file

        @param fullPath [string] path to file
        @return no return

        Usage:
        Common.verifyFilePython(SuiteGlobals.PATH_TO_TESTDATA_FOLDER + filenameHist + "new_file.py")
        """
        filename, fileExtension = os.path.splitext(fullPath)

        if fileExtension == ".py":
            test.passes("PASS", fullPath + " is a Python file")
        else:
            test.fail("FAIL", fullPath + " is not a Python file")

    @classmethod
    def verifyFileSrs(cls, fullPath):
        """
        This method checks if the file is a srs file

        @param fullPath [string] path to file
        @return no return

        Usage:
        Common.verifyFileSrs(SuiteGlobals.PATH_TO_TESTDATA_FOLDER + filenameHist + "new_file.srs")
        """
        filename, fileExtension = os.path.splitext(fullPath)

        if fileExtension == ".srs":
            test.passes("PASS", fullPath + " is a srs file")
        else:
            test.fail("FAIL", fullPath + " is not a srs file")

    @classmethod
    def checkControlState(cls, path, widget, value):
        """
        This method checks if the control state for system is saved in txt file correctly.

        @param path [string] path to txt file
        @param widget [string] ControlID of the widget
        @param value [string] widget value
        @return status [bool]

        Usage:
        filePath = os.getcwd()
        filePath = os.path.dirname(filePath) + os.sep + "shared" + os.sep + "testdata" + os.sep + txtFile
        Common.checkControlState(filePath, "Slider_0", "30")
        """
        status = False
        with open(path, 'rb') as file:
            tempList = file.readlines()

        for line in tempList:
            if widget in line:

                if value in line:
                    status = True

        if status:
            test.passes("PASS", "Contorl state of system is stored in txt file correctly")
            return status
        else:
            test.fail("FAIL", "Contorl state of system is NOT stored in txt file correctly")
            return status

    @classmethod
    def checkAndChangePerspective(cls, perspective):
        """
        This method check the current user perspective and if necessary (which depends on param 'perspective') changes into another perspective.

        @param perspective [string] name of desirable user perspective
        @return no return

        Usage:
        Common.checkAndChangePerspective("Panel Developer")
        Common.checkAndChangePerspective("Configure")
        """
        # TODO: removing because no RT-Exec snooze(1)
        if object.exists(MainShell().getCLabel(perspective)):
            test.log("User perspective", perspective)
        else:
            InputActions.activateMenuItem("Window->Change Perspective->" + perspective)
            test.log("User perspective is set to '" + perspective + "'.")

    @classmethod
    def ResetPerspective(cls):
        """
        This method resets perspective.
        """
        InputActions.activateMenuItem("Window->Reset Perspective")
        test.log("User perspective is reset")

    @classmethod
    def setWelcomePerspectiveComboBoxItem(cls, perspective):
        """
        This method sets perspective in perspective combo box on Welcome Screen
        @param perspective: name of perspective
        @return no return

        Usage:
        Common.setWelcomePerspectiveComboBoxItem("Panel Developer")
        Common.setWelcomePerspectiveComboBoxItem("Configure")
        """
        welcomeObj = Welcome()
        InputActions.mouseClickOnItem(welcomeObj.getPerspectiveComboBox())
        InputActions.mouseClickOnObjectItem(PopupListView().getListView(), perspective)

    @classmethod
    def getAvailableBoardName(cls, connectionStatus=None):
        """
        This method returns the name of the available board.

        @param connectionStatus [string] defoult None (can be None, LINKLOCAL or NETWORK)
        @return  if None(method will return name of board connected via USB or ETHERNET (from globals TEST_BOARD_3))
                 if LINKLOCAL(method will return name of board connected via USB (from globals TEST_BOARD_1))
                 if NETWORK (method will return name of board connected via ETHERNET (from globals TEST_BOARD_2))


        Usage :
        Common.getAvailableBoardName()
        Common.getAvailableBoardName("LINKLOCAL")
        Common.getAvailableBoardName("NETWORK")
        """
        bName = ""

        if connectionStatus is "LINKLOCAL":
            bName = SuiteGlobals.TEST_BOARD_1
        elif connectionStatus is "NETWORK":
            bName = SuiteGlobals.TEST_BOARD_2
        else:
            SuiteGlobals.TEST_BOARD_3

        ProjectOperation.expandAndCollapseAll("collapse")
        try:
            ProjectOperation.expandDirectoryTree("Discovered systems")
            systemObj = waitForObject(Directory().getDiscoveredSystems())
            properties = object.properties(systemObj)
        except LookupError:
            test.fail("FAIL", "Discovered Systems does not exist")
        discoveredSystems = str(systemObj.item.children)
        realSys = ""
        if discoveredSystems != "[]":
            discoveredSystems = discoveredSystems.replace("[", "")
            discoveredSystems = discoveredSystems.replace("]", "")
            systems = re.split(",", discoveredSystems)
            for system in systems:
                tempSystem = re.split(":", system)
                if bName in tempSystem[0].strip():
                    try:
                        realSys = waitForObject(Directory().getBoardOrSystem(tempSystem[0].strip()))
                    except LookupError:
                        test.fail("FAIL", "There are no discovered systems.")
                    if connectionStatus == None and ("LINKLOCAL" in realSys.tooltip.text or "NETWORK" in realSys.tooltip.text) and str(realSys.item.connectionstatusproperty.value) == "AVAILABLE":
                        test.log("Board selected", tempSystem[0].strip())
                        return tempSystem[0].strip()
                    elif connectionStatus != None and connectionStatus in realSys.tooltip.text and str(realSys.item.connectionstatusproperty.value) == "AVAILABLE":
                        test.log("Board selected", tempSystem[0].strip())
                        return tempSystem[0].strip()

        if realSys == "" and connectionStatus == "LINKLOCAL":
            test.log("Board '" + bName + "' is not available or not connected via USB.")
            return "There are no available boards."

        if realSys == "" and connectionStatus == "NETWORK":
            test.log("Board '" + bName + "' is not available or not connected via ETHERNET.")
            return "There are no available boards."

        if realSys == "":
            test.log("Board '" + bName + "' is not available or not connected.")
            return "There are no available boards."

    @classmethod
    def deleteTestdataContent(cls):
        """
        This method delete test data content

        @return no return

        Usage:
        Common.deleteTestdataContent()
        """
        testdata = os.getcwd()
        testdata = os.path.dirname(testdata) + os.sep + "shared" + os.sep + "testdata"

        for content in os.listdir(testdata):
            content_path = os.path.join(testdata, content)
            try:
                if os.path.isfile(content_path):
                    if not content_path.endswith(".gitkeep"):
                        os.unlink(content_path)
                elif os.path.isdir(content_path):
                    shutil.rmtree(content_path)
            except Exception as e:
                print(e)

    @classmethod
    def copyDirectory(cls, src, dest):
        """
        This method copies files from one directory to another

        @param src [string] path to sorce
        @param dest [string] path to destination
        @return no return

        Usage:
        Common.copyDirectory(SuiteGlobals.getItemFromTools("suite_additional", "cdb10l10"), SuiteGlobals.getItemFromInstalledBsp("systems", "cdb10l10"))
        """
        if os.path.exists(dest):
            shutil.rmtree(dest)
        try:
            shutil.copytree(src, dest)
        # Directories are the same
        except OSError as exc:  # python >2.5
            if exc.errno == errno.ENOTDIR:
                shutil.copy(src, dst)
            else:
                raise

    @classmethod
    def devicesOfSystem(cls, systemName):
        """
        This method returns list of devices from system

        @param systemName [string] name of system
        @return lstOfDevices [list] list of devices

        Usage:
        Common.devicesOfSystem()
        """
        rnSystemName = Directory().getBoardOrSystem(systemName)
        if object.exists(rnSystemName):
            directoryItems = findObject(rnSystemName).item.devices
        if directoryItems != "":
            devices = str(directoryItems)
            devices = devices.replace("[", "")
            devices = devices.replace("]", "")
            listOfDevices = re.split(", ", devices)
        return listOfDevices

    @classmethod
    def setWelcomeScreenOnStartup(cls, location="Welcome", check=True):
        """
        This method set Welcome Screen to start (or not) on startup
        @param location: if "Welcome" go to Welcome, if "Preferences" go to Preferences
        @param check: if true check in "Launch welcome screen on start-up" or "Always show at startup"
                      if false check out "Launch welcome screen on start-up" or "Always show at startup"
        usage examples:
        Common.setWelcomeScreenOnStartup("Welcome", True)
        Common.setWelcomeScreenOnStartup("Welcome", False)
        Common.setWelcomeScreenOnStartup("Preferences", True)
        Common.setWelcomeScreenOnStartup("Preferences", False)
        """
        welcomeObj = Welcome()
        preferencesObj = Preferences()

        if location == "Welcome":
            if check == True:
                if waitForObject(welcomeObj.getWelcomeCheckBox()).selected == False:
                    InputActions.mouseClickOnItem(welcomeObj.getWelcomeCheckBox())
            else:
                if waitForObject(welcomeObj.getWelcomeCheckBox()).selected == True:
                    InputActions.mouseClickOnItem(welcomeObj.getWelcomeCheckBox())
        elif location == "Preferences":
            InputActions.activateMenuItem("Window->Preferences")
            InputActions.mouseClickOnItem(preferencesObj.getTreeItem("General"))
            if check == True:
                if waitForObject(preferencesObj.getGeneralCheckBox("Launch welcome screen on start-up")).selected == False:
                    InputActions.mouseClickOnItem(preferencesObj.getGeneralCheckBox("Launch welcome screen on start-up"))
            else:
                if waitForObject(preferencesObj.getGeneralCheckBox("Launch welcome screen on start-up")).selected == True:
                    InputActions.mouseClickOnItem(preferencesObj.getGeneralCheckBox("Launch welcome screen on start-up"))
        else:
            test.fail("FAIL", "Wrong first parameter")
        InputActions.mouseClickOnButton(preferencesObj.getButton("OK"))

    @classmethod
    def rebootBoard(cls):
        testMachine = currentMachine.getItem("operating_system")
        path_to_reboot = currentMachine.getItem("path_to_tests") + os.sep + "shared" + os.sep + "tools" + os.sep + "reboot"
        if "Windows" in testMachine:
            cmd1 = path_to_reboot[0:2]
            cmd2 = "cd " + path_to_reboot
            cmd3 = "python rebootBoard.py"
            return subprocess.Popen(cmd1 + " & " + cmd2 + " & " + cmd3, shell=True)
        if "OS X" in testMachine:
            cmd1 = "cd " + path_to_reboot
            cmd2 = "python rebootBoard.py"
            return subprocess.Popen(cmd1 + " ; " + cmd2, shell=True)

    @classmethod
    def deleteLinkLogs(cls):
        """
        This method delete content of link log folder

        @return no return

        Usage:
        Common.deleteLinkLogs()
        """
        Common.kill_scs_link()
        # TODO: removing because no RT-Exec snooze(1)
        path = SuiteGlobals.getSCSLogsPath()
        for root, dirs, files in os.walk(path):
            for f in files:
                os.unlink(os.path.join(root, f))
            for d in dirs:
                shutil.rmtree(os.path.join(root, d))

    @classmethod
    def deleteConfigFiles(cls):
        """
        This method delete content of folders:
        ...\SoundClearStudio\v_"version"\config_files
        ...\SoundClearStudio\v_"version"\temp
        @return no return

        Usage:
        Common.deleteConfigFiles()
        """
        path = SuiteGlobals.getSCSConfigPath("config_files")
        for root, dirs, files in os.walk(path):
            for f in files:
                os.unlink(os.path.join(root, f))
            for d in dirs:
                shutil.rmtree(os.path.join(root, d))
        path = SuiteGlobals.getSCSConfigPath("temp")
        for root, dirs, files in os.walk(path):
            for f in files:
                os.unlink(os.path.join(root, f))
            for d in dirs:
                shutil.rmtree(os.path.join(root, d))

    @classmethod
    def mouseDragSCSWindow(cls, dx, dy):
        """
        @param dx [int] number of pixels x we want widget to move window
        @param dy [int] number of pixels y we want widget to move widnow
        @return no return

        Usage:
        Common.mouseDragSCSWindow(500, 500)
        """
        testMachine = platform.system()
        try:
            if "Darwin" in testMachine:
                mouseDrag(waitForObject(MainShell().getMainWindow()), 400, -10, dx, dy, Modifier.None, Button.Button1)
            else:
                mouseDrag(waitForObject(MainShell().getMainWindow()), 400, -40, dx, dy, Modifier.None, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to move SoundClear Studio Window.")

    @classmethod
    def deleteMetadataLog(cls):
        """
        This method delete metadata log file

        @return no return

        Usage:
        Common.deleteMetadataLog()
        """
        logFileLocation = SuiteGlobals.getSCSworkspace() + ".metadata" + os.sep
        logFileName = ".log"
        if os.path.isfile(logFileLocation + logFileName):
            os.unlink(os.path.join(logFileLocation, logFileName))

    @classmethod
    def changePerspectiveUsingButton(cls, perspective):
        """
        @parem name [string] Name of the perspective

        @return [bool] True or False depending on if the click on button was successfull

        Usage:
        Common.changePerspectiveUsingButton("Configure)
        """
        if perspective == "Panel Developer":
            result = InputActions.mouseClickOnItem(Directory().getPanelDevPerspectiveButton())
        elif perspective == "Configure":
            result = InputActions.mouseClickOnItem(Directory().getConfigurePerspectiveButton())

        if result == False:
            test.log("Chosen perspective is allready active.")
        else:
            test.log("Switched to " + perspective + " perspective.")

        return result

    @classmethod
    def changeWidgetProperties(cls, panel, widget, widget_ID, id, type, value=""):
        """
        This method changes the properties of of any widget, panel, device etc. in properties tab.

        @param panel [string]: Name of panel
        @param widget [string]: Name of widget
        @param widget_ID [string]: Widget ID
        @param id [string]: Name of properties
        @param type [string]: Type of cell to edit ["combo-box", "text-field", "check-box", "text-combo-box"]
        @param value [string]: Type new value

        Usage:
        panel = "Blank.panel"
        widget1 = "Rounded Button"
        button1_ID = "rounded_button_0"
        properties = "Color"
        type = "combo-box"
        color = "Blue: #2f63f4"

        Common.changeWidgetProperties(panel, widget1, button1_ID, properties, type, color)
        """
        if object.exists(WidgetProperties(widget).getWidgetPropertiesTab()) == False:
            try:
                mouseClick(findObject(PanelEditor(panel).getWidget(widget, widget_ID)), 10, 10, 0, Button.Button1)
                test.log("Successfully clicked on widget: " + widget + "( " + widget_ID + " )")
            except LookupError:
                test.fail("FAIL", "Couldn't click on " + widget + "( " + widget_ID + " )")
                return False
        # TODO: removing because no RT-Exec snooze(0.5)

        if (value == "") and (type == "check-box"):
            try:
                mouseClick(findObject(WidgetProperties(widget).getFieldProperties(id, type)), 10, 10, 0, Button.Button1)
                test.log("Successfully clicked on widget properties: " + id)
            except LookupError:
                test.fail("FAIL", "Couldn't click on " + widget + " Properties" + " -- ID: " + id)
                return False

        elif (value != "") and (type == "check-box"):
            test.fatal("Can not write string to check box ( " + id + " )!!!")
            return False

        elif (value != "") and (type != "check-box"):
            try:
                mouseClick(findObject(WidgetProperties(widget).getFieldProperties(id, type)), 10, 10, 0, Button.Button1)
                test.log("Successfully clicked on widget properties: " + id)
            except LookupError:
                test.fail("FAIL", "Couldn't click on " + widget + " Properties" + " -- ID: " + id)
                return False

            if type != "combo-box":
                machine = platform.system()
                if "Darwin" in machine:
                    nativeType("<Command+a>")
                    nativeType("<Delete>")
                else:
                    nativeType("<Ctrl+a>")
                    nativeType("<Delete>")
                # TODO: removing because no RT-Exec snooze(0.5)

                nativeType(value)
                nativeType("<Return>")
            else:
                try:
                    mouseClick(waitForObject(PopupListView().getListCell(value)), 10, 10, 0, Button.Button1)
                    test.log("Successfully clicked on popup list value: " + value + " from properties" + id)
                except LookupError:
                    test.fail("FAIL", "Couldn't click on value: " + value + " from properties: " + id)
                    return False
        else:
            return False

    @classmethod
    def unzipFile(cls, pathToFile):
        """
        This method unzip .zip file to testdata folder

        @param pathToFile [string] path to zip file we want to unzip
        @param mode [string] mode of reading (r,r:gz..)
        @return no return

        Usage:
        Common.unzipFile(pathToFile, pathToExtract)
        """
        zip_ref = zipfile.ZipFile(pathToFile, "r")
        zip_ref.extractall(SuiteGlobals.PATH_TO_TESTDATA_FOLDER)
        zip_ref.close()

    @classmethod
    def openPreferencesWindow(cls, page=None):
        """
        This method opens Preferences SCS Window
        @param page [string] page of Preferences Window
        @return no return

        Usage:
        Common.openPreferencesWindow()
        """
        preferencesObj = Preferences()
        InputActions.activateMenuItem("Window->Preferences")
        # TODO: removing because no RT-Exec snooze(1)
        if page != None:
            InputActions.mouseClickOnItem(preferencesObj.getTreeItem(page))

    @classmethod
    def buildAndOpenPanelInRuntime(self, projectName, system, device, panelRuntime):
        """
        This method build project, and opens certain panel in runtime
        @param projectName [string] name of the projec that will be builded
        @param system [string] name of the system under which device and panel in runtime will be shown
        @param device [string] name of device under which panel in runtime will be shown(ex.CS48LX50, CS42L42...)
        @param panelRuntime [string] name of panel in run time that will be opened(ex.DMC, Blank...)

        Usage:
        Common.buildAndOpenPanelInRuntime("Project1", "System1", "CS48LX50", "DMC")
        """
        directoryObj = Directory()
        mainShellObj = MainShell()
        flag = True
        flag1 = True
        counter1 = 0
        counter2 = 0

        if ReadActions.checkDirectoryTree(projectName):
            test.log(projectName + " is visible")
        else:
            ProjectOperation.expandAndCollapseAll("collapse")
            ProjectOperation.expandDirectoryTree("My Projects->" + projectName)

        ProjectOperation.contextMenuSystemDirectory(directoryObj.getProjectName(projectName), "Build")
        # TODO: removing because no RT-Exec snooze(1)

        ProjectOperation.expandAndCollapseAll("collapse")
        while (flag and counter1 < 150):
            if (object.exists(mainShellObj.getProgressBar())) == False:
                ProjectOperation.expandDirectoryTree("Discovered systems->" + system)
                while (flag1 and counter2 < 150):
                    if ReadActions.checkDirectoryTree(device):
                        ProjectOperation.expandDirectoryTree(device + "->" + panelRuntime)
                        flag1 = False
                    else:
                        # TODO: removing because no RT-Exec snooze(0.3)
                        counter2 += 1
                flag = False
            else:
                # TODO: removing because no RT-Exec snooze(0.3)
                counter1 += 1
        if flag:
            test.fail("FAIL", "Project is not built")
        else:
            test.passes("PASS", "Project is built sucessfuly")
        if flag1:
            test.fail("FAIL", "Panel is not opened in runtime")
        else:
            test.passes("PASS", "Panel is opened in runtime")

    @classmethod
    def getNumberOfPorts(cls, borderPane, side):
        """
        This method is only for non composite blocks
        @param borderPane - real name of border pane
        @param side [string] side of port - can be top, bottom, right or left
        @return  numberOfPorts [int] number of ports

        Usage:
        Common.getNumberOfPorts(borderPane, side)
        """
        portList = []
        if side == "top":
            try:
                portList = str(waitForObject(borderPane).top.children)
            except LookupError:
                test.fail("FAIL", "Object or propery does not exist")
        elif side == "bottom":
            try:
                portList = str(waitForObject(borderPane).bottom.children)
            except LookupError:
                test.fail("FAIL", "Object or propery does not exist")
        elif side == "right":
            try:
                portList = str(waitForObject(borderPane).right.children)
            except LookupError:
                test.fail("FAIL", "Object or propery does not exist")
        elif side == "left":
            try:
                portList = str(waitForObject(borderPane).left.children)
            except LookupError:
                test.fail("FAIL", "Object or propery does not exist")
        else:
            test.fail("FAIL", "Wrong second parameter")
        numberOfPorts = portList.count("SVGPath")
        return numberOfPorts


    @classmethod
    def exportEQData(cls, fileName, path, eqObj):
        """
        This method exports Playback Equalizer Data to csv file

        @param fileName[string] name of file
        @return no return

        Usage:
        Common.exportEQData(system, "Band1.csv")
        """

        try:
            # Full path with file name and extension
            fullPath = SuiteGlobals.PATH_TO_TOOLS_FOLDER + os.sep + path + os.sep + fileName
            refPath = SuiteGlobals.PATH_TO_REFDATA_FOLDER + os.sep + path + os.sep + fileName
            testDirectory = SuiteGlobals.PATH_TO_TOOLS_FOLDER + os.sep + path

            if not os.path.exists(testDirectory):
                os.makedirs(testDirectory)

            # Click on export button
            InputActions.mouseClickOnItem(eqObj.getExport())

            test.log(fullPath)
            chooseFile(waitForObject(":SWT"), fullPath)
            # TODO: removing because no RT-Exec snooze(0.5)

            if not os.path.isfile(fullPath):
                test.fail("FAIL", "File " + fullPath + " doesn't created")
            else:
                if filecmp.cmp(fullPath, refPath):
                    test.passes("PASS", "File " + fullPath + " created and same as referent file")
                else:
                    test.fail("FAIL", "File " + fullPath + " doesn't match with referent file")
        except LookupError:
            test.fail("FAIL", "Couldn't click on " + eqObj.getExport())

    @classmethod
    def exportImportSEP(cls, exportImport, panelRuntime, fileName, path=SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep):
        """
        This method exports Secure Endpoints to file or imports Secure Endpoints from file

        @param exportImport [string] can be "export" or "import"
        @param fileName[string] name of file
        @param path [string] path to file
        @return no return

        Usage:
        Common.exportImportSEP("export", "Secure Endpoints", "SECT.bin")
        Common.exportImportSEP("import", "Secure Endpoints", "SECT.bin")
        """

        panelRuntimeObj = PanelRuntime(panelRuntime)
        try:
            # Full path with file name and extension
            fullPath = path + fileName

            # Click on export/import button
            if exportImport == "export":
                InputActions.mouseClickOnButton(panelRuntimeObj.getButton("EXPORT"))
            elif exportImport == "import":
                InputActions.mouseClickOnButton(panelRuntimeObj.getButton("IMPORT"))
            else:
                test.fail("FAIL", "Wrong the first method parameter")

            # Export to file/Import from file
            test.log(fullPath)
            chooseFile(waitForObject(":SWT"), fullPath)
        except LookupError:
            test.fail("FAIL", "Can not export Secure Endpoints")

    @classmethod
    def checkGraphAxisRange(cls, axis, minVal, maxVal, children):
        """
        This method check if min and max elements of axis are as expected

        @param axis[string] X or Y axis
        @param min[string] expected min element of axis
        @param max[string] expected max element of axis
        @param list of graph numbers
        @return no return

        Usage:
        Common.exportEQData(system, "Band1.csv")
        """

        dict = {}
        if axis == 'X':
            for child in children:
                if (str(child.typeselector) == "Text"):
                    dict[child.layoutx] = str(child.text)
        elif axis == 'Y':
            for child in children:
                if (str(child.typeselector) == "Text"):
                    dict[child.layouty] = str(child.text)
        else:
            test.fail("FAIL", "Couldn't click on " + eqObj.getExport())

        keysList = list(dict.keys())
        minValue = min(keysList)
        maxValue = max(keysList)

        if str(dict[minValue]) == minVal:
            test.passes("PASS", "Min Element of " + axis + " is ok")
        else:
            test.passes("PASS", "Min Element of " + axis + " is NOT ok")

        if str(dict[maxValue]) == maxVal:
            test.passes("PASS", "Max Element of " + axis + " is ok")
        else:
            test.passes("PASS", "Max Element of " + axis + " is NOT ok")

    @classmethod
    def addRemoveRestoreToken(cls, action, tokenName):
        """
        This method is used for adding/removing/restoring a Token

        @return no return
        @param action [string] name of the action to be performed: adding or removing a token
        @param tokenName [string] name of the token to be added, removed or restored

        Usage:
        Common.addRemoveRestoreToken("add", "newMethod()")
        Common.addRemoveRestoreToken("remove","restoreHandler()")
        Common.addRemoveRestoreToken("restore", "restoreHandler()")
        """
        row = 0
        tokensLength = 0
        Common.openPreferencesWindow("PyDev")
        preferencesObj = Preferences()
        InputActions.mouseClickOnItem(preferencesObj.getTreeItem("Auto-Complete Syntax"))

        if action == "add":
            test.log("Click on text box to write the token name...")
            InputActions.mouseClickOnItem(preferencesObj.getTokenListTextBox())
            nativeType(tokenName)
            test.log("Click on ADD button...")
            InputActions.mouseClickOnButton(preferencesObj.getPreferencesButton("ADD"))
            # TODO: removing because no RT-Exec snooze(0.5)
            test.log("Verify that " + tokenName + " entry appeared in Tokens to use table")
            if object.exists(preferencesObj.getTokenListItem(tokenName)):
                test.passes("PASS", "Method added to list")
            else:
                test.fail("FAIL", "Method is not added to list")
                # TODO: removing because no RT-Exec snooze(0.5)

        elif action == "remove":
            test.log("From Tokens to use table select " + tokenName + " option and press Remove button")
            try:
                tokensLength = waitForObject(preferencesObj.getPreferencesListView()).items.length
            except LookupError:
                test.fail("Fail", "Can not find object or property")
            test.log("Navigate through Preferences Tokens List to find the token: " + tokenName + " and remove it.")
            InputActions.mouseClickOnItem(preferencesObj.getPreferencesListView())
            while(row < tokensLength):
                try:
                    if object.exists(preferencesObj.getTokenListItem(tokenName)):
                        InputActions.mouseClickOnItem(preferencesObj.getTokenListItem(tokenName))
                        InputActions.mouseClickOnButton(preferencesObj.getPreferencesButton("REMOVE"))
                        break
                    else:
                        nativeType("<Down>")
                        # TODO: removing because no RT-Exec snooze(0.1)
                    row += 1
                except LookupError:
                    test.fail("Fail", "Can not find object or property")

            test.log("Verify that " + tokenName + " entry is removed from Tokens to use table")
            if object.exists(preferencesObj.getTokenListItem(tokenName)):
                test.fail("FAIL", "Method not removed from list")
            else:
                test.passes("PASS", "Method removed from list")
                # TODO: removing because no RT-Exec snooze(0.5)

        elif action == "restore":
            test.log("Press RESTORE button")
            InputActions.mouseClickOnButton(preferencesObj.getPreferencesButton("RESTORE"))
            try:
                tokensList = str(waitForObject(preferencesObj.getPreferencesListView()).items)
            except LookupError:
                test.fail("FAIL", "Can not find object or property")
            if tokenName in tokensList:
                test.passes("PASS", "Method restored to list")
                # TODO: removing because no RT-Exec snooze(0.5)
            else:
                test.fail("FAIL", "Method is not restored to list")

        """Need to close the PyDev three menu because it stays opened next time you open Preferences window
        and this method starts by expanding the Pydev three menu"""
        InputActions.mouseClickOnButton(preferencesObj.getPreferencesButton("APPLY"))
        # TODO: removing because no RT-Exec snooze(2)
        InputActions.mouseClickOnItem(preferencesObj.getTreeItem("PyDev"))
        # TODO: removing because no RT-Exec snooze(2)
        InputActions.mouseClickOnButton(preferencesObj.getPreferencesButton("OK"))
        # TODO: removing because no RT-Exec snooze(2)

    @classmethod
    def programGrayDevice(cls, system, grayDevice, pathToConfigFile, numberOfIterations, timeToWait=60):
        """
        This method programs the Gray device with provided configuration and numberOfIterations
        number of times

        @param system[string] the name of the system
        @param grayDevice[string] Gray device used
        @param pathToConfigFile [string] path to configuration template file
        @param numberOfIterations [int] number of iterations of programming device
        @param timeToWait [int] time to wait for the button to appear or becomes enabled
        @return no return

        Usage:
        Common.programGrayDevice(system, grayDevice, pathToConfigFile, 5)
        """
        directoryObj = Directory()
        programAndSaveObj = ProgramAndSave()
        informationShellObj = InformationShell()
        errorShellObj = ErrorShell()
        timer = 0
        iterationCounter = 0
        buttonEnabled = ""

        ProjectOperation.expandAndCollapseAll("collapse")
        ProjectOperation.expandDirectoryTree("Discovered systems->" + system + "->" + grayDevice + "->" + "Overview")
        # TODO: removing because no RT-Exec snooze(5)

        realNameSystem = directoryObj.getBoardOrSystem(system)
        InputActions.mouseClickOnItem(realNameSystem, "right")

        try:
            activateItem(waitForObjectItem(directoryObj.getContextMenu(), "Load control state"))
        except LookupError as lue:
            test.fail("FAIL", str(lue))

        # TODO: removing because no RT-Exec snooze(2)
        try:
            chooseFile(waitForObject(":SWT"), pathToConfigFile)
            # TODO: removing because no RT-Exec snooze(2)
        except LookupError as lue:
            test.fail("FAIL", str(lue))

        ProjectOperation.expandDirectoryTree("Program and Save")

        while iterationCounter < numberOfIterations:
            # Clicking on Program Device immediately after its enabled
            while timer < timeToWait:
                try:
                    buttonEnabled = str(waitForObject(programAndSaveObj.getButton("PROGRAM DEVICE")).globalenabled)
                    if buttonEnabled == "True":
                        # TODO: removing because no RT-Exec snooze(1)
                        InputActions.mouseClickOnItem(programAndSaveObj.getButton("PROGRAM DEVICE"))
                        timer = 0
                        break
                    else:
                        timer += 1
                        # TODO: removing because no RT-Exec snooze(1)
                except LookupError as lue:
                    test.fail("FAIL", str(lue))
                    timer = 0
                    break

            # Clicking on OK button on Information or Error dialog immediately after it appears
            while timer < timeToWait:
                if object.exists(informationShellObj.getTitleLabel("Information")):
                    InputActions.mouseClickOnItem(informationShellObj.getInformationShellButton("OK"))
                    test.passes("PASS", "Iteration " + str(iterationCounter + 1) + ": Programming was successful.")
                    timer = 0
                    break
                elif object.exists(errorShellObj.getTitleLabel("Error")):
                    InputActions.mouseClickOnItem(errorShellObj.getErrorShellButton("OK"))
                    test.fail("FAIL", "Iteration " + str(iterationCounter + 1) + ": Programming was NOT successful.")
                    timer = 0
                    break
                else:
                    timer += 1
                    # TODO: removing because no RT-Exec snooze(1)

            iterationCounter += 1

    @classmethod
    def programDevice(cls, system, device, typeOfPrograming, pathToConfigFile=None, usbIdentifiersList=[None, None, None], numberOfIterations=1, timeToWait=60, comboBoxType=None, comboBoxValue=None, programmingShouldBeSuccessful=True):
        """
        This method programs the device with provided configuration and numberOfIterations
        number of times

        @param system[string] the name of the system
        @param device[string] device used
        @param typeOfPrograming [string] type of programing otp or sotp
        @param pathToConfigFile [string] path to configuration template file
        @param usbIdentifiersList [list] contains three elements [vid, pid, dfu pid]
                                        if some value need to be changed, it will be sended in list
        @param numberOfIterations [int] number of iterations of programming device
        @param timeToWait [int] time to wait for the button to appear or becomes enabled
        @param programmingShouldBeSuccessful[bool] defoult True if we expect programing be successfull,
                                                           False if we expect programming to be unsuccessful
        @return no return

        Usage:
        Common.programDevice(system, device, pathToConfigFile, 5)
        Common.programDevice(system, device,"Simulated OTP on External Flash")
        """
        directoryObj = Directory()
        programAndSaveObj = ProgramAndSave()
        informationShellObj = InformationShell()
        errorShellObj = ErrorShell()
        confirmShellObj = ConfirmShell()

        message = ""
        flagList = []
        timer = 0
        iterationCounter = 0
        buttonEnabled = ""

        ProjectOperation.expandAndCollapseAll("collapse")
        ProjectOperation.expandDirectoryTree("Discovered systems->" + system + "->" + device + "->" + "Overview")
        # TODO: removing because no RT-Exec snooze(2)
        if usbIdentifiersList != [None, None, None]:
            if usbIdentifiersList[0] != None:
                PanelOperation.changeNumericFieldWidgetTextUSBSettings("VID", usbIdentifiersList[0])
            else:
                test.log("VID is defoult")
            if usbIdentifiersList[1] != None:
                PanelOperation.changeNumericFieldWidgetTextUSBSettings("PID", usbIdentifiersList[1])
            else:
                test.log("PID is defoult")
            if usbIdentifiersList[2] != None:
                PanelOperation.changeNumericFieldWidgetTextUSBSettings("DFU PID", usbIdentifiersList[2])
            else:
                test.log("DFU PID is defoult")
        # TODO: removing because no RT-Exec snooze(1)
        if pathToConfigFile != None:
            realNameSystem = directoryObj.getBoardOrSystem(system)
            InputActions.mouseClickOnItem(realNameSystem, "right")
            try:
                activateItem(waitForObjectItem(directoryObj.getContextMenu(), "Load control state"))
            except Exception as err:
                test.fail("FAIL", "Message " + str(err))
            try:
                chooseFile(waitForObject(":SWT"), pathToConfigFile)
                # TODO: removing because no RT-Exec snooze(2)
            except Exception as err:
                test.fail("FAIL", "Message " + str(err))
        else:
            test.log("Program device without config file")
        ProjectOperation.expandDirectoryTree("Program and Save")
        """Clicking on combo box if it is necessary"""
        if comboBoxType != None:
            if object.exists(programAndSaveObj.getComboBox(comboBoxType)):
                Common.selectFromComboBox(programAndSaveObj.getComboBox(comboBoxType), comboBoxValue)
                test.log("Value in " + comboBoxValue + " is selected")
                # TODO: removing because no RT-Exec snooze(2)
            else:
                test.fail("FAIL", "There is no " + comboBoxType + " combo box")
        while iterationCounter < numberOfIterations:
            # Clicking on Program Device immediately after its enabled
            while timer < timeToWait:
                try:
                    buttonEnabled = str(waitForObject(programAndSaveObj.getButton("PROGRAM DEVICE")).globalenabled)
                    if buttonEnabled == "True":
                        # TODO: removing because no RT-Exec snooze(1)
                        InputActions.mouseClickOnItem(programAndSaveObj.getRadioButton(typeOfPrograming))
                        InputActions.mouseClickOnItem(programAndSaveObj.getButton("PROGRAM DEVICE"))
                        timer = 0
                        break
                    else:
                        timer += 1
                        # TODO: removing because no RT-Exec snooze(1)
                except LookupError as lue:
                    test.fail("FAIL", str(lue))
                    timer = 0
                    break

            # Clicking on OK button on Information or Error dialog immediately after it appears
            if programmingShouldBeSuccessful == True:
                while timer < timeToWait:
                    if object.exists(confirmShellObj.getTitleLabel("Confirmation")):
                        InputActions.mouseClickOnItem(confirmShellObj.getConfirmShellButton("YES"))
                        test.log("Confirmation Shell window is shown")

                    if object.exists(informationShellObj.getTitleLabel("Information")):
                        InputActions.mouseClickOnItem(informationShellObj.getInformationShellButton("OK"))
                        test.passes("PASS", "Iteration " + str(iterationCounter + 1) + ": Programming was successful and programmingShouldBeSuccessful = " + str(programmingShouldBeSuccessful))
                        flagList.append(True)
                        timer = 0
                        break
                    elif object.exists(errorShellObj.getTitleLabel("Error")):
                        try:
                            message = str(waitForObject(errorShellObj.getTitleLabel("Error")).parent.children)
                            test.log(message)
                        except Exception as e:
                            test.log(str(e))
                        InputActions.mouseClickOnItem(errorShellObj.getErrorShellButton("OK"))
                        test.fail("FAIL", "Iteration " + str(iterationCounter + 1) + ": Programming was NOT successful and programmingShouldBeSuccessful = " + str(programmingShouldBeSuccessful))
                        flagList.append(False)
                        timer = 0
                        break
                    elif object.exists(errorShellObj.getTitleLabel("Warning")):
                        try:
                            message = str(waitForObject(errorShellObj.getTitleLabel("Warning")).parent.children)
                            test.log(message)
                        except Exception as e:
                            test.log(str(e))
                        InputActions.mouseClickOnItem(errorShellObj.getErrorShellButton("OK"))
                        test.fail("FAIL", "Iteration " + str(iterationCounter + 1) + ": Programming was NOT successful and programmingShouldBeSuccessful = " + str(programmingShouldBeSuccessful))
                        flagList.append(False)
                        timer = 0
                        break
                    else:
                        timer += 1
                        # TODO: removing because no RT-Exec snooze(1)

                    if object.exists(errorShellObj.getTitleLabel("Error")):
                        try:
                            message = str(waitForObject(errorShellObj.getTitleLabel("Error")).parent.children)
                        except Exception as e:
                            test.log(str(e))
                        InputActions.mouseClickOnItem(errorShellObj.getErrorShellButton("OK"))
                        test.fail("FAIL", "Error mesage shown: " + message)
                        flagList.append(False)
                    else:
                        flagList.append(True)
            else:
                while timer < timeToWait:
                    if object.exists(confirmShellObj.getTitleLabel("Confirmation")):
                        InputActions.mouseClickOnItem(confirmShellObj.getConfirmShellButton("YES"))
                        test.log("Confirmation Shell window is shown")

                    if object.exists(informationShellObj.getTitleLabel("Information")):
                        InputActions.mouseClickOnItem(informationShellObj.getInformationShellButton("OK"))
                        test.fail("FAIL", "Iteration " + str(iterationCounter + 1) + ": Programming was successful and programmingShouldBeSuccessful = " + str(programmingShouldBeSuccessful))
                        flagList.append(False)
                        timer = 0
                        break
                    elif object.exists(errorShellObj.getTitleLabel("Error")):
                        try:
                            message = str(waitForObject(errorShellObj.getTitleLabel("Error")).parent.children)
                            test.log(message)
                        except Exception as e:
                            test.log(str(e))
                        InputActions.mouseClickOnItem(errorShellObj.getErrorShellButton("OK"))
                        test.passes("PASS", "Iteration " + str(iterationCounter + 1) + ": Programming was NOT successful and programmingShouldBeSuccessful = " + str(programmingShouldBeSuccessful))
                        flagList.append(True)
                        timer = 0
                        break
                    elif object.exists(errorShellObj.getTitleLabel("Warning")):
                        try:
                            message = str(waitForObject(errorShellObj.getTitleLabel("Warning")).parent.children)
                            test.log(message)
                        except Exception as e:
                            test.log(str(e))
                        InputActions.mouseClickOnItem(errorShellObj.getErrorShellButton("OK"))
                        test.passes("PASS", "Iteration " + str(iterationCounter + 1) + ": Programming was NOT successful and programmingShouldBeSuccessful = " + str(programmingShouldBeSuccessful))
                        flagList.append(True)
                        timer = 0
                        break
                    else:
                        timer += 1
                        # TODO: removing because no RT-Exec snooze(1)

            iterationCounter += 1
        if False in flagList or len(flagList) == 0:
            return False
        else:
            return True

    @classmethod
    def deleteSoundClearStudioMetadata(cls):
        """
        This method is used for deleting the matadata of SoundClear Studio

        @return no return

        Usage:
        Common.deleteSoundClearStudioMetadata()
        """
        test.log("Deleting metadata...")
        if os.path.isdir(SuiteGlobals.getPathToSoundClearStudio()):
            # TODO: removing because no RT-Exec snooze(1.5)
            try:
                shutil.rmtree(SuiteGlobals.getPathToSoundClearStudio())
                test.log("Metadata deleted.")
            except Exception as e:
                test.log(str(e))

    @classmethod
    def addDriverToWindows(cls):
        """
        This method copy oem file to Windows\inf folder

        Usage:
        Common.addDriverToWindows()
        """
        if platform.system() == "Windows" and platform.release() == "7":
            dst = "c:" + os.sep + "Windows" + os.sep + "inf" + os.sep + "oem9999.inf"
            src = SuiteGlobals.PATH_TO_REFDATA_FOLDER + os.sep + "oem9999.inf"
            try:
                shutil.copy(src, dst)
                test.passes("PASS", "oem file is copied")
            except:
                test.fail("FAIL", "Can not copy oem file")

    @classmethod
    def setDarkLightImageForDiagramImage(cls, projectName, diagramImageContainerID, darkPictureName, lightPictureName, darkPicturePath, lightPicturePath, addNewImageDark=False, addNewImageLight=False):
        """
        This method is used for setting both the dark and light images for Diagram Image container.
        This method calls the setImageForDiagramImage() method which sets the Diagram Image for one theme.
        @param projectName [string] name of the device or system project
        @param diagramImageContainerID [string] name of the ID of the Diagram Image container
        @param darkPictureName [string] name of the picture that will be set for the dark theme
        @param lightPictureName [string] name of the picture that will be set for the light theme
        @param darkPicturePath [string] path to dark picture in file system
        @param lightPicturePath [string] path to light picture in file system
        @param addNewImageDark [bool] If this parameter is set to False, the picture for the Dark theme is chosen from the projects folder
                                      If this parameter  is set to True, the picture for the Dark theme is chosen from some other non project folder
        @param addNewImageLight [bool] If this parameter is set to False, the picture for the Light theme is chosen from the projects folder
                                       If this parameter is set to True, the picture for the Light theme is chosen from some other non project folder
        @return no return

        Usage:
        Common.setDarkLightImageForDiagramImage("deviceProject', diagram_image_0, "one.jpg", "two.jpg")
        Common.setDarkLightImageForDiagramImage("deviceProject', diagram_image_0, "one.jpg", "two.jpg", True)
        Common.setDarkLightImageForDiagramImage("deviceProject', diagram_image_0, "one.jpg", "two.jpg", True, False)
        Common.setDarkLightImageForDiagramImage("deviceProject', diagram_image_0, "one.jpg", "two.jpg", False, True)
        """
        diagramImageContainer = "Diagram Image"

        tableCellPositionDark = WidgetProperties(diagramImageContainer).getTableViewCellByPosition(1, 2)
        tableCellPositionLight = WidgetProperties(diagramImageContainer).getTableViewCellByPosition(1, 1)

        Common.setImageForDiagramImage(projectName, tableCellPositionDark, darkPictureName, darkPicturePath, addNewImageDark)
        Common.setImageForDiagramImage(projectName, tableCellPositionLight, lightPictureName, lightPicturePath, addNewImageLight)

    @classmethod
    def setImageForDiagramImage(self, projectName, tableCellPosition, pictureName, pathToPicture, addNewImage):
        """
        This method is used for setting the Diagram Image for one theme.
        It can be used on its own or called from setDarkLightImageForDiagramImage() method
        @param projectName [string] name of the device or system project
        @param tableCellPosition [string] the position of the folder icon
                                           e.g. tableCellPosition_dark = WidgetProperties(diagramImageContainer).getTableViewCellByPosition(1, 2)
        @param pictureName [string] the name of the picture that will be set for Diagram image
        @param pathToPicture [string] the path to picture
        @param addNewImage [bool] If this parameter is set to False, the picture for the Dark theme is chosen from the projects folder
                                  If this parameter is set to True, the picture for the Light theme is chosen from some other non project folder
        @return no return

        Usage
        Common.setImageForDiagramImage('deviceProject', tableCellPosition, "SuiteGlobals.PATH_TO_REFDATA_FOLDER + os.sep + "pictures" + os.sep + darkPictureName", "one.jpg", True)
        Common.setImageForDiagramImage('deviceProject', tableCellPosition, "SuiteGlobals.PATH_TO_REFDATA_FOLDER + os.sep + "pictures" + os.sep + darkPictureName", "one.jpg", False)
        """
        selectImageShellObj = SelectImageShell()
        diagramImageContainer = "Diagram Image"
        # TODO: removing because no RT-Exec snooze_time = 1

        test.log("Click on image folder icon")
        InputActions.mouseClickOnItem(WidgetProperties(diagramImageContainer).getTableViewCellItem(tableCellPosition))
        # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)

        if addNewImage == False:
            test.log("Double click on project name from Select Image File shell")
            InputActions.mouseDoubleClickOnItem(selectImageShellObj.getProjectNameTreeItem(projectName), "left", True, 225, 15)
            # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
            test.log("Double click on picture name from Select Image File shell")
            InputActions.mouseDoubleClickOnItem(selectImageShellObj.getProjectNameTreeItem(pictureName), "left", True, 225, 15)
            # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
            test.log("Click on OK button")
            InputActions.mouseClickOnButton(selectImageShellObj.getImageShellButton("OK"))
            # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
        else:
            test.log("Click on ADD NEW IMAGE button")
            InputActions.mouseClickOnButton(selectImageShellObj.getImageShellButton("ADD NEW IMAGE"))
            # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
            chooseFile(waitForObject(":SWT"), pathToPicture)

    @classmethod
    def closePaletteAndPropertiesTabs(cls):
        """
        This method closes Palette and Properties Tabs
        @return no return
        Usage
        Common.closePaletteAndPropertiesTabs()
        """
        paletteObj = Palette()
        propertiesObj = Properties("Properties")
        if object.exists(paletteObj.getCTabItem()):
            InputActions.mouseClickOnItem(paletteObj.getCTabItem(), "middle")
        if object.exists(propertiesObj.getcTabItem()):
            InputActions.mouseClickOnItem(propertiesObj.getcTabItem(), "middle")

    @classmethod
    def openPaletteAndPropertiesTabs(cls):
        """
        This method opens Palette and Properties Tabs
        @return no return
        Usage
        Common.openPaletteAndPropertiesTabs()
        """
        InputActions.activateMenuItem("Window->Show View->Palette")
        InputActions.activateMenuItem("Window->Show View->Properties")

    @classmethod
    def checkErrorLevelCmd(cls):
        """
        This method has criterium of pass or fail wether error level is 0 or not
        @return no return

        Usage
        Common.checkErrorLevelCmd()
        """
        if "Windows" in platform.system():
            proc = subprocess.Popen("echo %ERRORLEVEL%", stdout=PIPE, shell=True)
        else:
            proc = subprocess.Popen("echo $?", stdout=PIPE, shell=True)
        proc.wait()
        stdout, stderr = proc.communicate()

        test.log("Check if error level is 0")
        if "0" in stdout:
            test.passes("PASS", "Error level is 0.")
        else:
            test.fail("FAIL", "Error level is not 0.")

    @classmethod
    def commandLineTool(cls, cmd, logging=True):
        """
        This method runs the command(cmd) in command line on every platform
        @param cmd [string] command for command line tool
        @return stdout[string] message after executing command line tool

        Usage
        Common.commandLineTool("c:\\Users\\All Users\\Cirrus Logic\\SCS_1.1\\devices\\cs46l06\\tools\\patchdownloader.bat -a")
        """
        if "Windows" in platform.system():
            if logging:
                test.log("Running: " + cmd)
            if not "-p" in cmd:
                proc = subprocess.Popen(cmd, stdout=PIPE)
            else:
                proc = subprocess.Popen(cmd, shell=True, stdout=PIPE)
        else:
            if logging:
                test.log("Running: " + cmd)
            proc = subprocess.Popen(cmd, shell=True, stdout=PIPE)
        if "patchdownloader" and "-a" in cmd or "patchdownloader" and "-d" in cmd:
            # TODO: removing because no RT-Exec snooze(15)
            # we do not need this method. so just pass it or delete this whole method.
            pass
        proc.wait()
        stdout, _ = proc.communicate()
        if logging:
            test.log("Console output:\n" + stdout)
        return stdout

    @classmethod
    def addOtherViews(cls, viewCategoryName, vSystem):
        """
        This method is used for opening all avalilable views within the given view category

        @return no return
        @param viewCategoryName [string] name of category from which you whish to add: SCS Views, Debug Views
        @param vSystem [string] name of the virtual system

        Usage:
        Common.addOtherViews("SCS Views", vSystem)
        Common.addOtherViews("Debug Views", vSystem)
        """
        addViewsShellObj = AddViewsShell()
        historyObj = History(vSystem)
        popupListViewObj = PopupListView()
        options_list = []
        # TODO: removing because no RT-Exec snooze_time = 0.5

        InputActions.activateMenuItem("Window->Show View->Other...")
        # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
        # TODO: removing because no RT-Exec snooze(1)
        InputActions.mouseDoubleClickOnItem(addViewsShellObj.getAddViewCell(viewCategoryName), "left", True, 211, 16)
        # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
        try:
            string_option_list = str(waitForObject(addViewsShellObj.getAddViewCell(viewCategoryName)).treeitem.children)
            #test.log(string_option_list)

            # Isolate elements needed to form a list thru which you'll iterate
            start_sep = ': '
            end_sep = ' ]'
            tmp = string_option_list.split(start_sep)
            for par in tmp:
                if end_sep in par:
                    options_list.append(par.split(end_sep)[0])

            test.log("List of all options to iterate true: " + str(options_list))
            # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
        except LookupError:
            test.fail("Fail", "Can not find object or property")
        # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
        test.log("Iterate thru all options: select the option, click ADD button ")
        for i in range(len(options_list)):
            if i == 0:
                nativeType("<Down>")
            else:
                InputActions.mouseDoubleClickOnItem(addViewsShellObj.getAddViewCell(viewCategoryName), "left", True, 211, 16)
                for _ in range(i + 1):
                    nativeType("<Down>")
            # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
            test.log(options_list[i])
            InputActions.mouseClickOnButton(addViewsShellObj.getAddViewShellButton())
            if options_list[i] == "History":
                InputActions.mouseClickOnItem(historyObj.getHistoryDropDown())
                # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
                InputActions.mouseClickOnObjectItem(popupListViewObj.getListView(), vSystem)
                # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
                InputActions.mouseClickOnButton(historyObj.getHistoryOkButton())
                # TODO: removing because no RT-Exec snooze(# TODO: removing because no RT-Exec snooze_time)
            else:
                pass

            # Verify that window opened
            if options_list[i] == "History":
                if object.exists(addViewsShellObj.getGenericCTabItem(options_list[i] + ": " + vSystem)):
                    test.passes("PASS", options_list[i] + ": " + vSystem + " window opened")
                else:
                    test.fail("FAIL", options_list[i] + ": " + vSystem + " window did not open")
            else:
                if object.exists(addViewsShellObj.getGenericCTabItem(options_list[i])):
                    test.passes("PASS", options_list[i] + " window opened")
                else:
                    test.fail("FAIL", options_list[i] + " window did not open")

            # Close window
            InputActions.closeTabOnMouseClick(options_list[i])
            if i != len(options_list) - 1:
                InputActions.activateMenuItem("Window->Show View->Other...")
            else:
                pass

    @classmethod
    def setConsoleBufferLength(cls, maxNumberOfCharacters):
        """
        This method is used for setting the maximum number of characters for Console Buffer length form General section on Preferences page

        @return no return
        @param maxNumberOfCharacters [string] maximum number of characters for Console Buffer length

        Usage:
        Common.setConsoleBufferLength("1000")
        """
        preferencesObj = Preferences()
        machine = platform.system()
        Common.openPreferencesWindow("General")
        InputActions.mouseClickOnItem(preferencesObj.getGeneralConsoleBufferLengthTextBox())
        if "Darwin" in machine:
            nativeType("<Command+a>")
        else:
            nativeType("<Ctrl+a>")
        # TODO: removing because no RT-Exec snooze(0.5)
        nativeType("<Backspace>")
        # TODO: removing because no RT-Exec snooze(0.5)
        nativeType(maxNumberOfCharacters)
        InputActions.mouseClickOnButton(preferencesObj.getPreferencesButton("OK"))
        # TODO: removing because no RT-Exec snooze(1)

    @classmethod
    def checkConsoleContent(cls, consoleTextEnding, consoleTextBeginningWin=None, consoleTextBeginningMac=None,
                            open_console=True):
        """
        This method is used for checking the Console content
        It checks if a specified content is present in Console
        There is a diference in content begining on Mac and on Win so it is checked separately
        Both parameters consoleTextBeginningWin and consoleTextBeginningMac must be specified or ommitted

        @return no return
        @param consoleTextEnding [string] expected Console text
        @param consoleTextBeginningWin [string] expected beginning of Console output on Windows
        @param consoleTextBeginningMac [string] expected beginning of Console output on Mac

        Usage:
        Common.checkConsoleContent(consoleTextEnding)
        Common.checkConsoleContent(consoleTextEnding, consoleTextBeginningWin, consoleTextBeginningMac)
        """
        test.log("Verify Console output")
        if open_console:
            InputActions.activateMenuItem("Window->Show View->Console")
        consoleObj = Console()
        machine = platform.system()
        try:
            pyDevConsoleTextArea = waitForObject(consoleObj.getTextArea()).text
        except LookupError as lue:
            test.fail("FAIL", "Unable to find object " + str(lue))
        matchObj = re.search(consoleTextEnding, pyDevConsoleTextArea, re.I)
        if matchObj is not None:
            test.passes("PASS", "Expected content: '" + matchObj.group(0) + "' found")
            if consoleTextBeginningWin != None and consoleTextBeginningMac != None:
                if "Darwin" in machine:
                    if consoleTextBeginningMac in pyDevConsoleTextArea:
                        test.passes("PASS", "Expected content: '" + consoleTextBeginningMac + "' found")
                    else:
                        test.fail("FAIL", "Expected content: '" + consoleTextBeginningMac + "' not found")
                else:
                    if consoleTextBeginningWin in pyDevConsoleTextArea:
                        test.passes("PASS", "Expected content: '" + consoleTextBeginningWin + "' found")
                    else:
                        test.fail("FAIL", "Expected content: '" + consoleTextBeginningWin + "' not found")
        else:
            test.fail("FAIL", "Expected content not found")
        # TODO: removing because no RT-Exec snooze(1)

    @classmethod
    def returnConsoleContent(cls):
        """
        This method is used for returning the Console content
        @return console text content

        Usage:
        Common.returnConsoleContent()
        """
        test.log("Verify Console output")
        InputActions.activateMenuItem("Window->Show View->Console")
        consoleObj = Console()
        try:
            content_list = waitForObject(consoleObj.getTextArea()).text
            content_list = content_list.replace('\r', '')
            content_list = content_list.split('\n')
            return content_list
        except LookupError as error:
            test.fail("Unable to find object %s" % error.message)

    @classmethod
    def appearanceColorOptionsChecker(cls, field, userColor):
        """
        This method is used for checking code color for 'Decorators', 'Numbers', 'Code',
        'Keywords', 'self', 'Bytes', 'Unicode'...from Editor inside Preferences window

        @return no return
        @param field [string] expected name of field from table in Editor
        @param userColor [string] expected color that need to be checed

        Usage:
        Common.appearanceColorOptionsChecker(field, userColor)
        """
        preferencesObj = Preferences()
        InputActions.mouseClickOnItem(preferencesObj.getColorEditor(field))
        InputActions.mouseClickOnItem(preferencesObj.getCustomColorPicker())
        InputActions.mouseClickOnItem(preferencesObj.getWebCustomColor())

        try:
            colorFromPicker = str(waitForObject(preferencesObj.getWebColorField()).text)
        except LookupError as lue:
            test.fails("FAIL", str(lue))

        if colorFromPicker == userColor:
            test.passes("PASS", "Correct color")
        else:
            test.fail("FAIL", "Incorrect color")

        InputActions.mouseClickOnItem(preferencesObj.getCustomColorFunctions("Cancel"))
        InputActions.mouseClickOnItem(preferencesObj.getColorEditor(field))

    @classmethod
    def loadScripts(cls, system, fileName, button=True):
        """
        This method exports the history to a file to testdata folder

        @param system [string] name of system
        @param fileName [string] name of file in testdata
        @param button [bool] if True Load button will be clicked, if false File->Load scripts will be executed
        @return no return

        Usage:
        Common.loadScripts(system, "test.srs")
        Common.loadScripts(system, "test.srs", False)
        """
        mainShellObj = MainShell()

        try:
            # Full path with file name and extension
            fullPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + fileName
            # TODO: removing because no RT-Exec snooze(1)

            # Click on load Scripts
            if button:
                InputActions.mouseClickOnItem(mainShellObj.getToolbarButton("Load scripts"))
            elif button == False:
                InputActions.activateMenuItem("File->Load Scripts")
            else:
                test.fail("FAIL", "Button can be True or False only")

            # Import the file using full path with file name and extension
            chooseFile(waitForObject(":SWT"), fullPath)
        except LookupError:
            test.fail("FAIL", "Couldn't click on Load Scripts")

    @classmethod
    def checkPaletteContent(cls, items, letter=None):
        """
        This method checks if widgets and containers from @param items are present in palette

        @param items [list] list of widgets and containers from palette
        @param letter [string] string from filter bar
        @return no return

        Usage:
        Common.checkPaletteContent(["Diagram Image", "Blank Container", "One Column Container"])
        Common.checkPaletteContent(["Diagram Image", "Blank Container", "One Column Container"], "Cont")
        """
        paletteObj = Palette()
        for item in items:
            if letter == None:
                try:
                    nativeType("<Down>")
                    findObject(paletteObj.getWidgetFromPalette(item))
                    ReadActions.checkObjectExists(paletteObj.getWidgetFromPalette(item))
                    # TODO: removing because no RT-Exec snooze(0.5)
                except LookupError:
                    test.fail("FAIL", "Widget " + item + " not found")
            else:
                if letter in item:
                    try:
                        nativeType("<Down>")
                        findObject(paletteObj.getWidgetFromPalette(item))
                        ReadActions.checkObjectExists(paletteObj.getWidgetFromPalette(item))
                        # TODO: removing because no RT-Exec snooze(0.2)
                    except LookupError:
                        test.fail("FAIL", "Widget " + item + " not found")

    @classmethod
    def checkCompiledFileContent(cls, filePath, component, **dataDict):
        """
        This method check the content of compiled files such as .libraryc, .devicec, .systemc.

        @param filePath [string]: the path to the compiled file
        @param component [string]: the component from the content inside the compiled file [panels,
                                                                                            scripts,
                                                                                            Hierarchy,
                                                                                            editors,
                                                                                            libraryList,
                                                                                            Project and images]
        @param **dataDict [dictionary]: dictionary with the values of the properties of given component (keys should be the same as in compiled file)
        @return [boolean]: return True if content is correct, False otherwise

        Usage:
        panelProperty = {"RelativePath": libFolder, "Name": libPanel}
        compiledFilePath = projectPath + os.sep + libProject + os.sep + "Output" + os.sep + libProject + "_1.0.0.libraryc"
        Common.checkCompiledFileContent(compiledFilePath, "panels", **panelProperty)

        NOTE:
        For checking the widget properties inside the compiled file, use method checkCompiledFileWidget.
        """
        re = False
        with open(filePath, 'r') as f:
            json_obj = json.load(f)

        if ".libraryc" in filePath:
            compiledProject = "CompiledLibrary"
        elif ".devicec" in filePath:
            compiledProject = "CompiledDevice"
        else:
            compiledProject = "CompiledSystem"

        projectContent = json_obj[compiledProject]
        componentDict = projectContent[component]
        if component == "panels":
            dictValues = list(componentDict.values())[0]
            for i in range(len(dictValues)):
                if dataDict.items() <= dictValues[i].items():
                    re = True

        elif component == "libraryList":
            temp = componentDict["CompiledLibrary"]
            for i in range(len(temp)):
                libPanels = temp[0]
                dictValues = list(libPanels["panels"].values())[0]
                for j in range(len(dictValues)):
                    if dataDict.items() <= dictValues[j].items():
                        re = True

        elif component == "scripts":
            temp = projectContent[component]
            scriptProperties = temp["Script"]
            for i in range(len(scriptProperties)):
                if dataDict.items() <= scriptProperties[i].items():
                    re = True
        else:
            projectProperties = projectContent[component]
            if dataDict.items() <= projectProperties.items():
                re = True
        return re

    @classmethod
    def checkCompiledFileWidget(cls, filePath, component, widget, propertyList):
        """
        This method check the widgets content of compiled files such as .libraryc, .devicec, .systemc.

        @param filePath [string]: the path to the compiled file
        @param component [string]: the component from the content inside the compiled file [panels,
                                                                                            scripts,
                                                                                            Hierarchy,
                                                                                            editors,
                                                                                            libraryList,
                                                                                            Project and images]
        @param widget [string]: the name of widget [Button, Label, ToggleButton, CheckBox...]
        @param propertyList [list]: the list of properties for widget
        @return [boolean]: return True if content is correct, False otherwise

        Usage:
        buttonProperty = [{'value': {'type': 'string', 'value': widgetText}, 'key': 'buttonText'},
                          {'value': {'type': 'string', 'value': widget_ID}, 'key': 'name'}]
        compiledFilePath = projectPath + os.sep + libProject + os.sep + "Output" + os.sep + libProject + "_1.0.0.libraryc"
        Common.checkCompiledFileWidget(compiledFilePath, "panels", "Button", buttonProperty)
        """
        re = True
        with open(filePath, 'r') as f:
            json_obj = json.load(f)

        if ".libraryc" in filePath:
            compiledProject = "CompiledLibrary"
        elif ".devicec" in filePath:
            compiledProject = "CompiledDevice"
        else:
            compiledProject = "CompiledSystem"

        projectContent = json_obj[compiledProject]
        dict = projectContent[component]

        if component == "panels":
            componentList = list(dict.values())[0][0]
            widgetList = componentList["widgets"]
            temp = widgetList[widget + "WidgetModel"]
            for i in range(len(temp)):
                widgetProperties = temp[i]["properties"]
                for j in range(len(propertyList)):
                    if propertyList[j] in widgetProperties["entry"]:
                        pass
                    else:
                        re = False

        else:
            compiledLib = dict["CompiledLibrary"]
            for i in range(len(compiledLib)):
                libPanels = compiledLib[0]
                dictValues = list(libPanels["panels"].values())[0][0]
                widgetList = dictValues["widgets"]
                temp = widgetList[widget + "WidgetModel"]
                for i in range(len(temp)):
                    widgetProperties = temp[i]["properties"]
                    for j in range(len(propertyList)):
                        if propertyList[j] in widgetProperties["entry"]:
                            pass
                        else:
                            re = False
        return re

    @classmethod
    def linkingLibraryPanel(cls, libraryPanel, availableSys=None, virtualSys=None, device=None):
        """
        This method is used to linking Library panel with system.

         It has 4 parameters and you need to:

         1. name of library panel
         2. define available or virtual system (availableSys or virtualSys), set value for one and set None for the other
         3. set value for template you will use
         4. set value for device that will be used
         #TODO if needed - change the destination folder

        @param libraryPanel [string] name of library panel

        @param availableSys [string] default None(click on virtual system)
                                                 (click on available system)
        @param virtualSys [string] default None(click on available system)
                                               (click on virtual system)
        @param device [string] default None(device will be default from scs)
                                           (value for device that will be used)
        @return [bool] False if can not click on device, template, system that mouse try to click

        Usage:
        libPanelName = "Panel.panel"
        Common.linkingLibraryPanel(libPanelName, None, "cdb42L42", "cs42l42")
        Common.linkingLibraryPanel(libPanelName, None, None, None)
        Common.linkingLibraryPanel(libPanelName, None, "cdb42L42", None)
        """

        """ Click on icon next to library panel """
        try:
            if object.exists(Directory().getLinkIconState(libraryPanel, "chain")):
                mouseClick(waitForObject(Directory().getLinkIconState(libraryPanel, "chain")), 9, 10, 0, Button.Button1)
            elif object.exists(Directory().getLinkIconState(libraryPanel, "unchain")):
                mouseClick(waitForObject(Directory().getLinkIconState(libraryPanel, "unchain")), 9, 10, 0, Button.Button1)
            else:
                test.fail("FAIL", "Link Icon is not found")
        except LookupError:
            test.fail("FAIL", "Unable to click on Link Icon")
            # TODO: removing because no RT-Exec snooze(0.5)
            return False

        """ Select Available or Virtual System"""
        if availableSys != None:
            try:
                mouseClick(waitForObject(LinkingPanelShell().getAvailableSystem(availableSys), 5000), 12, 1, 0, Button.Button1)
                test.log("Available system selected", availableSys)
                # TODO: removing because no RT-Exec snooze(0.5)
            except LookupError:
                test.fail("FAIL", "Unable to click on Available System '" + availableSys + "'")
                # TODO: removing because no RT-Exec snooze(0.5)
                return False
        elif virtualSys != None:
            if not (object.exists(LinkingPanelShell().getVirtualSystem(virtualSys))):
                mouseClick(waitForObject(LinkingPanelShell().getVirtualSystemsListView(), 5000), 10, 10, 0, Button.Button1)
                length = ReadActions.checkLengthOfDevicesInNewProjectShell()
                counter = 0
                while (not object.exists(LinkingPanelShell().getVirtualSystem(virtualSys))):
                    nativeType("<Down>")
                    # TODO: removing because no RT-Exec snooze(0.3)
                    counter += 1
                    if counter == length:
                        break
            else:
                try:
                    # TODO: removing because no RT-Exec snooze(0.5)
                    mouseClick(waitForObject(LinkingPanelShell().getVirtualSystem(virtualSys), 5000), 1, 1, 0, Button.Button1)
                    test.log("Virtual system selected", virtualSys)
                    # TODO: removing because no RT-Exec snooze(0.5)
                except LookupError:
                    test.fail("FAIL", "Unable to click on Virtual System '" + virtualSys + "'")
                    # TODO: removing because no RT-Exec snooze(0.5)
                    return False
        else:
            try:
                mouseClick(waitForObject(LinkingPanelShell().getCheckBoxSystem(), 5000), 9, 6, 0, Button.Button1)
                # TODO: removing because no RT-Exec snooze(0.5)
                """" Finish """
                InputActions().mouseClickOnButton(LinkingPanelShell().getButton("Done"))
                test.log("Panel", libraryPanel + " is successfully linked")
                # TODO: removing because no RT-Exec snooze(3)
                return True
            except LookupError:
                test.fail("FAIL", "Unable to click on Check box")
                # TODO: removing because no RT-Exec snooze(0.5)
                return False

        if availableSys != None or virtualSys != None:
            """ Go to Next Screen"""
            InputActions().mouseClickOnButton(LinkingPanelShell().getButton("Next"))
            # TODO: removing because no RT-Exec snooze(1)

        """ If device is defined select it"""
        if device != None:
            try:
                mouseClick(waitForObject(LinkingPanelShell().getDevice(device), 5000), 12, 10, 0, Button.Button1)
                test.log("device selected", device)
                # TODO: removing because no RT-Exec snooze(0.5)
            except LookupError:
                test.fail("FAIL", "Unable to click on Device '" + device + "'")
                # TODO: removing because no RT-Exec snooze(0.5)
                return False
        else:
            try:
                mouseClick(waitForObject(LinkingPanelShell().getCheckBoxDevice(), 5000), 9, 6, 0, Button.Button1)
                # TODO: removing because no RT-Exec snooze(0.5)
            except LookupError:
                test.fail("FAIL", "Unable to click on Check box")
                # TODO: removing because no RT-Exec snooze(0.5)
                return False

        """" Finish """
        InputActions().mouseClickOnButton(LinkingPanelShell().getButton("Done"))
        test.log("Panel", libraryPanel + " is successfully linked")
        # TODO: removing because no RT-Exec snooze(3)
        return True

    @classmethod
    def checkContentLinkingPanel(cls, libraryProject, libraryPanel, systemName):
        """
        This method is used to check content linking Library panel wizard page.

          @param libraryProject [string] name of library project

          @param libraryPanel [string] name of library panel

          @param systemName [string] (click on virtual system)

          Usage:
          libProject = "LibraryProject"
          libPanelName = "Panel.panel"
          Common.checkContentLinkingPanel(libProject, libPanelName, "cdb42L42")

        """

        testMachine = currentMachine.getItem("operating_system")
        if "Windows" in testMachine:
            pathToPackage = "C:\\Users\\All Users\\Cirrus Logic" + os.sep + SuiteGlobals.SCS_VERSION_SHORT + os.sep + "systems"
        if "OS X" in testMachine:
            pathToPackage = "/Users/Shared/Cirrus Logic" + os.sep + SuiteGlobals.SCS_VERSION_SHORT + os.sep + "systems"
        """ Get list all installed package """
        test.log("Get list all installed package")
        listOfPackage = []
        for root, dirs, files in os.walk(pathToPackage):
            for file in files:
                if file.endswith(".xml"):
                    system = file.replace(".xml", "")
                    listOfPackage.append(system)
        """ Get all devices in virtual system """
        test.log("Get all devices in virtual system")
        tree = ET.parse(pathToPackage + os.sep + systemName + os.sep + systemName + ".xml")
        root = tree.getroot()
        listOfDevice = []
        for name in root.findall(".//Devices//Device//Name"):
            listOfDevice.append(name.text)
        """ Get all systems visible in Discovered systems """
        test.log("Get all systems visible in Discovered systems")
        discoverSystemList = ReadActions.listAllVirtualSystems()
        """ Click on icon next to library panel """
        test.log("Click on icon next to library panel")
        ProjectOperation.expandDirectoryTree("My Projects->" + libraryProject)
        try:
            mouseClick(waitForObject(Directory().getLinkIconState(libraryPanel, "unchain")), 9, 10, 0, Button.Button1)
        except LookupError:
            test.fail("FAIL", "Unable to click on Link Icon")
            # TODO: removing because no RT-Exec snooze(0.5)
            return False
        listOfAvailable = []
        """ Get list all discovered system visible in linking Library panel wizard page """
        test.log("Get list all discovered system visible in linking Library panel wizard page")
        try:
            systemObj = waitForObject(LinkingPanelShell().getAvailableSystemListView())
        except LookupError:
            test.fail("FAIL", "Available System List does not exist")
        availableSystem = str(systemObj.items)
        if availableSystem != "[]":
            availableSystem = availableSystem.replace("[", "")
            availableSystem = availableSystem.replace("]", "")
            systems = re.split(",", availableSystem)
            for system in systems:
                tempSystem = re.split(":", system)
                listOfAvailable.append(tempSystem[0].strip())

        """ Get list all virtual system visible in linking Library panel wizard page """
        test.log("Get list all virtual system visible in linking Library panel wizard page")
        listOfVirualSystem = []
        try:
            virtualSystemObj = waitForObject(LinkingPanelShell().getVirtualSystemsListView())
        except LookupError:
            test.fail("FAIL", "Available System List does not exist")
        for c in object.children(virtualSystemObj):
            if hasattr(c, "cell"):
                virtualSystem = str(c.cell.item.name).lower()
                listOfVirualSystem.append(virtualSystem)

        """ Select Virtual System"""
        test.log("Select Virtual System")
        if not (object.exists(LinkingPanelShell().getVirtualSystem(systemName))):
            mouseClick(waitForObject(LinkingPanelShell().getVirtualSystemsListView(), 5000), 10, 10, 0, Button.Button1)
            length = ReadActions.checkLengthOfDevicesInNewProjectShell()
            counter = 0
            while (not object.exists(LinkingPanelShell().getVirtualSystem(systemName))):
                nativeType("<Down>")
                # TODO: removing because no RT-Exec snooze(0.3)
                counter += 1
                if counter == length:
                    break
        else:
            try:
                # TODO: removing because no RT-Exec snooze(0.5)
                mouseClick(waitForObject(LinkingPanelShell().getVirtualSystem(systemName), 5000), 1, 1, 0, Button.Button1)
                test.log("Virtual system selected", systemName)
                # TODO: removing because no RT-Exec snooze(0.5)
            except LookupError:
                test.fail("FAIL", "Unable to click on Virtual System '" + systemName + "'")
                # TODO: removing because no RT-Exec snooze(0.5)

        """ Go to Next Screen"""
        test.log("Go to Next Screen")
        InputActions().mouseClickOnButton(LinkingPanelShell().getButton("Next"))
        # TODO: removing because no RT-Exec snooze(1)

        """ Get list all device visible in linking Library panel wizard page """
        test.log("Get list all device visible in linking Library panel wizard page")
        listOfAvailableDevice = []
        try:
            deviceObj = waitForObject(LinkingPanelShell().getDevicesListView())
        except LookupError:
            test.fail("FAIL", "Available System List does not exist")
        availableDevice = str(deviceObj.items)
        if availableDevice != "[]":
            availableDevice = availableDevice.replace("[", "")
            availableDevice = availableDevice.replace("]", "")
            devices = re.split(",", availableDevice)
            for device in devices:
                listOfAvailableDevice.append(device)
        InputActions.mouseClickOnItem(LinkingPanelShell().getCloseLinkingPanelWindow())

        """ Compare lists"""
        test.log("Compare lists")
        CompareVirtualSystem = cmp(listOfPackage, listOfVirualSystem)
        CompareAvailableDevice = cmp(listOfPackage, listOfVirualSystem)
        CompareDiscoverSystem = cmp(listOfAvailable, discoverSystemList)
        if CompareDiscoverSystem == 0:
            test.passes("PASS", "All system are listed in linking wizard page.")
        else:
            test.fail("FAIL", "Not all system are listed in linking wizard page.")

        if CompareVirtualSystem == 0:
            test.passes("PASS", "All systems known to SCS are listed in linking wizard page.")
        else:
            test.fail("FAIL", "Not all systems known to SCS are listed in linking wizard page.")

        if CompareAvailableDevice == 0:
            test.passes("PASS", "All virtual device are listed in linking wizard page.")
        else:
            test.fail("FAIL", "Not all virtual device are listed in linking wizard page.")

    @classmethod
    def checkExportToLibraryProject(cls, navigatorPath):
        """
        This method check if export panel to library option from context menu is executed correctly.

        @param navigatorPath [string] relative path (path in navigator tree) of panel which will be exported
        @return [boolean] returns True is export is successfully executed, False otherwise

        Usage:
        deviceProject = "device_project"
        devicePanel = "DevicePanel"
        panelPath = deviceProject + "/" + devicePanel + ".panel"
        Common.checkExportToLibraryProject(panelPath)
        """
        temp = re.split("/", navigatorPath)
        panel = temp[len(temp) - 1]
        panelProperty = "item.resource.fullpath='" + "/" + navigatorPath + "'"
        panelContainer = Directory().getBoardOrSystem(panel, panelProperty)
        realNamePanel = "{caption='" + panel + "' container=" + panelContainer + " styletype='text' visible='true'}"
        libList = ProjectOperation.listNavigatorProjects("Library")
        libDict = {}
        for lib in libList:
            try:
                tempObj = waitForObject(Directory().getBoardOrSystem(lib))
            except:
                test.fail("FAIL", "Couldn't find library project '" + lib + "'.")
                # TODO: removing because no RT-Exec snooze(0.5)
                return False
            pathToProject = str(tempObj.item.resource.location)
            pathToProject = pathToProject.replace("\\", "\\\\")
            pathToProject = pathToProject.replace("/", "//")
            libDict[lib] = ProjectOperation.listProjectDirectories(pathToProject)
        # TODO: removing because no RT-Exec snooze(0.5)

        if object.exists(realNamePanel):
            pass
        else:
            ProjectOperation.expandAndCollapseAll("collapse")
            # TODO: removing because no RT-Exec snooze(0.5)
            ProjectOperation.expandDirectoryTree("My Projects->" + str(navigatorPath.replace("/", "->")))
            # TODO: removing because no RT-Exec snooze(0.5)

        InputActions.mouseClickOnItem(realNamePanel, "right")
        # TODO: removing because no RT-Exec snooze(0.5)
        activateItem(waitForObjectItem(Directory().getContextMenu(), "Export"))
        # TODO: removing because no RT-Exec snooze(0.5)
        activateItem(waitForObjectItem(Directory().getContextMenu("Export"), "To Library Project"))
        # TODO: removing because no RT-Exec snooze(0.5)

        libsInComboBox = str(ExportPanelToLibraryProjectShell().getListOfComboBoxElements())
        libsInComboBox = libsInComboBox.replace("[", "")
        libsInComboBox = libsInComboBox.replace("]", "")
        libsInComboBox = libsInComboBox.replace(" ", "")
        listOfLibs = re.split(",", libsInComboBox)

        if set(libList) == set(listOfLibs):
            test.passes("PASS", "All created library projects are listed in combo-box.")
        else:
            test.fail("FAIL", "Not all created library projects are listed in combo-box.")
            InputActions.mouseClickOnItem(ExportPanelToLibraryProjectShell().getCloseDialog())
            return False

        for key, values in libDict.items():
            if len(values) != 0:
                Common.checkFoldersInExportLibDialog(key, values)

        InputActions.mouseClickOnItem(ExportPanelToLibraryProjectShell().getCloseDialog())
        # TODO: removing because no RT-Exec snooze(0.5)
        return True

    @classmethod
    def checkFoldersInExportLibDialog(cls, libName, folderList):
        """
        This method check if all folders from folderList are presented on Export panel dialog under the libName project.

        @param libName [string] name of the library project
        @param folderList [list] list of string (list of folder names)
        @return [boolean] returns True if all folders from the list are presented, False otherwise

        Usage:
        libraryProject = "library_project_1"
        folderList = ["folder1", "folder2", "folder3"]
        Common.checkFoldersInExportLibDialog(libraryProject, folderList)
        """
        re = True
        if object.exists(ExportPanelToLibraryProjectShell().getMainShell()):
            pass
        else:
            test.fail("FAIL", "'Export Panel to Library Project' dialog is not opend.")
            return False

        try:
            mouseClick(waitForObject(ExportPanelToLibraryProjectShell().getLibraryComboBox()), 157, 10, 0, Button.Button1)
            # TODO: removing because no RT-Exec snooze(0.5)
        except:
            test.fail("FAIL", "Couldn't click on combo-box.")
            InputActions.mouseClickOnItem(ExportPanelToLibraryProjectShell().getCloseDialog())
            # TODO: removing because no RT-Exec snooze(0.5)
            return False
        try:
            mouseClick(waitForObjectItem(ExportPanelToLibraryProjectShell().getLibraryFromComboBox(), libName), 65, 12, 0, Button.Button1)
            # TODO: removing because no RT-Exec snooze(0.5)
        except:
            test.fail("FAIL", "Couldn't click on combo-box item.")
            # TODO: removing because no RT-Exec snooze(0.5)
            return False

        for folder in folderList:
            if object.exists(ExportPanelToLibraryProjectShell().getTreeVievelEment(folder)):
                test.passes("PASS", "Folder '" + folder + "' is displayed in Export Library Dialog under the library project '" + libName + "'.")
            else:
                test.fail("FAIL", "Folder '" + folder + "' is not displayed in Export Library Dialog under the library project '" + libName + "'.")
                re = False
        if re:
            return True
        else:
            return False

    @classmethod
    def parseSCSlibrary(cls, filePath, addedPanels=[], modifiedPath=False):
        """
        This method checks if .scslibrary file is generated correctly for given project.

        @param filePath [string] path to .scslibrary file
        @param addedPanels [list] of all added (not exported) panels to the library project which needs to be parsed
        @param modifiedPath [boolean] if False path of the referenced panel is not changed, True otherwise
        @return [boolean] returns True if .scslibrary file is generated correctly, False otherwise

        Usage:
        projectPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER
        libProject = "LibraryProject"
        folder1 = "folder_1"
        exportedPanel = exporterd_panel
        libPanels = [{"key": folder1 + "/" + exportedPanel + ".panel",
                      "value": {"HardwareType": "CS42L42",
                                "ProjectType": "DEVICE_PROJECT"}}]

        Common.parseSCSlibrary(projectPath os.sep + libProject + os.sep + ".scslibrary")
        Common.parseSCSlibrary(projectPath os.sep + libProject + os.sep + ".scslibrary", libPanels)

        NOTE:
        When using this method, the main shell of SoundClear Studio must be in focus.
        """
        testMachine = platform.system()
        entry = []

        if os.path.exists(filePath):
            pass
        else:
            test.fail("FAIL", "File couldn't be found on path '" + filePath + "'.")
            return False

        if "Windows" in testMachine:
            sep = os.sep + os.sep
            temp = re.split(sep, filePath)
        else:
            temp = re.split(os.sep, filePath)

        libraryProject = str(temp[len(temp) - 2])
        with open(filePath, 'r') as f:
            json_obj = json.load(f)
        libraryProjectProperties = json_obj["LibraryProject"]["SystemOrDeviceNamePanelMap"]["entry"]

        if object.exists(Directory().getProjectName(libraryProject)):
            pass
        else:
            ProjectOperation.expandAndCollapseAll("collapse")
            ProjectOperation.expandDirectoryTree("My Projects")
            if object.exists(Directory().getProjectName(libraryProject)):
                pass
            else:
                test.fail("FAIL", "Project '" + libraryProject + "' is not displayed in Navigator.")

        if not modifiedPath:
            ProjectOperation.contextMenuSystemDirectory(Directory().getProjectName(libraryProject), "Build")
            deviceProjectList = ProjectOperation.listNavigatorProjects("Device")
            systemProjectList = ProjectOperation.listNavigatorProjects("System")
            if len(deviceProjectList) != 0:
                for deviceProject in deviceProjectList:
                    tempPath, tempDeviceType = Common.getProjectProperties(deviceProject)
                    panelEntry = Common.panelsProperties(tempPath, tempDeviceType, "DEVICE_PROJECT", libraryProject)
                    for element in panelEntry:
                        entry.append(element)

            if len(systemProjectList) != 0:
                for systemProject in systemProjectList:
                    tempPath, tempSystemType = Common.getProjectProperties(systemProject)
                    panelEntry = Common.panelsProperties(tempPath, tempSystemType, "SYSTEM_PROJECT")
                    for element in panelEntry:
                        entry.append(element)

        if addedPanels != []:
            for panel in addedPanels:
                entry.append(panel)

        if sorted(libraryProjectProperties) == sorted(entry):
            test.passes("PASS", "Content of .scslibrary file for library project '" + libraryProject + "' is correclty generated.")
            return True
        else:
            test.fail("FAIL", "Content of .scslibrary file for library project '" + libraryProject + "' is not correclty generated.")
            return False

    @classmethod
    def getProjectProperties(cls, projectName):
        """
        This method returns the project absolute path and device/system type.

        @param projectName [string] name of project
        @return [strings] project path and project device/system type

        Usage:
        Common.getProjectProperties("Project_1")
        """
        if object.exists(Directory().getProjectName(projectName)):
            InputActions.mouseClickOnItem(Directory().getProjectName(projectName))
        else:
            ProjectOperation.expandAndCollapseAll("collapse")
            ProjectOperation.expandDirectoryTree("My Projects")
            InputActions.mouseClickOnItem(Directory().getProjectName(projectName))
        try:
            tempPathObj = waitForObject(Properties("Device Properties").getField("Path"))
        except:
            test.fail("FAIL", "Couldn't find the object '" + Properties("Device Properties").getField("Path") + "'.")
        try:
            tempDeviceTypeObj = waitForObject(Properties("Device Properties").getField("Device Type"))
        except:
            test.fail("FAIL", "Couldn't find the object '" + Properties("Device Properties").getField("Device Type") + "'.")

        try:
            projectPath = str(tempPathObj.text)
            projectPath = projectPath.replace("/", os.sep)
        except:
            test.fail("FAIL", "Couldn't find object '" + tempPathObj + "' property 'text'.")
        try:
            projectDeviceType = str(tempDeviceTypeObj.text)
        except:
            test.fail("FAIL", "Couldn't find object '" + tempDeviceTypeObj + "' property 'text'.")
        # TODO: removing because no RT-Exec snooze(0.5)
        return projectPath, projectDeviceType

    @classmethod
    def panelsProperties(cls, projectPath, deviceOrSystemType, projectType, libraryProject):
        """
        This method retuns the list of properties (panel relative path, project type and hardware type)
        for all panels under the project from the 'projectPath'.

        @param projectPath [string] path where the project is located
        @param deviceOrSystemType [string] type of device/system for whcich project is created
               device type could be: CS42L42, USB_AUDIO_MODULE...
               system type could be: cdb42L42, CDB42L75...
        @param projectType [string] type of project (e.g. "DEVICE_PROJECT", "SYSTEM_PROJECT" or "LIBRARY_PROJECT")
        @param libraryProject [string] the name of the library project which needs to be in projectPath
        @return [list] returns the list of mentioned properties for all panels under the project
                       from the given 'projectPath'

        Usage:
        panelEntry = []
        projectPath = SuiteGlobals.PATH_TO_TESTDATA_FOLDER + os.sep + "Project_1"
        deviceType = "CS42L42"
        panelEntry = Common.panelsProperties(projectPath, deviceType)
        """
        panelProperties = []
        testMachine = platform.system()
        if "Windows" in testMachine:
            temp = re.split(os.sep + os.sep, projectPath)
            separator = temp[len(temp) - 2] + os.sep + os.sep
        else:
            temp = re.split(os.sep, projectPath)
            separator = temp[len(temp) - 2] + os.sep
        paths = [os.path.join(projectPath, file) for file in next(os.walk(projectPath))[2]]
        removedPaths = 0
        for i in range(len(paths)):
            if not ".panel" in paths[i - removedPaths]:
                del paths[i - removedPaths]
                removedPaths += 1
        # TODO: removing because no RT-Exec snooze(0.5)
        for path in paths:
            pathToPanel = re.split(separator, path)
            if "Windows" in testMachine:
                relativePath = re.split(os.sep + os.sep, pathToPanel[1])
            else:
                relativePath = re.split(os.sep, pathToPanel[1])
            # TODO: removing because no RT-Exec snooze(0.5)

            for dir in relativePath:
                ProjectOperation.expandDirectoryTree(dir)
                if ".panel" in dir:
                    openedPanel = dir

            try:
                tempPanelPropertyObj = waitForObject(Properties("Panel Properties").getField("Referenced panels"))
            except:
                test.fail("FAIL", "Couldn't find the object '" + Properties("Panel Properties").getField("Referenced panels") + "'.")

            try:
                tempPanelProperty = tempPanelPropertyObj.text
                projectName = re.split("/", tempPanelProperty)[0] + "/"
            except:
                test.fail("FAIL", "Couldn't find object '" + tempPanelProperty + "' property 'text'.")

            # TODO: removing because no RT-Exec snooze(0.5)
            if tempPanelProperty != "None" and libraryProject in projectName:
                panelProperties.append({"key": tempPanelProperty.replace(projectName, ""),
                                        "value": {"HardwareType": deviceOrSystemType,
                                                  "ProjectType": projectType}})
            # TODO: removing because no RT-Exec snooze(0.5)

            Common.closeWindow(openedPanel)
            for dir in reversed(relativePath):
                if not ".panel" in dir:
                    ProjectOperation.expandDirectoryTree(dir)
        return panelProperties

    @classmethod
    def changePropertyField(cls, widget, text, deviceOrField):
        """
        This method is used to change field or device property for widget.

        @param widget [string] name widget
        @param text [string] text which will be written into field or device (text could be name of device or bit(s) name)
        @param deviceOrField [string] name of the widget property (device or field)

        usage example:
        Common.changePropertyField("Button", "ANC_ADC_EN", "Field")
        Common.changePropertyField("Button", "AudioHUB FPGA", "Device")

        NOTE:
        Widget should be in focus in order to use this method correctly.
        When choosing 'Device' or 'Field' property add in caption field/device name + string text (deviceOrField = FieldText, deviceOrField = DeviceText).
        """
        machine = platform.system()
        if object.exists(Properties(widget + " Properties").getField(deviceOrField)):
            InputActions.mouseClickOnItem(Properties(widget + " Properties").getField(deviceOrField))
        else:
            InputActions.mouseClickOnItem(WidgetProperties(widget).getTextField("Field"))
        if "Darwin" in machine:
            nativeType("<Command+a>")
        else:
            nativeType("<Ctrl+a>")
        # TODO: removing because no RT-Exec snooze(0.5)
        nativeType("<Delete>")
        if object.exists(Properties(widget + " Properties").getField(deviceOrField)):
            InputActions.mouseClickOnItem(Properties(widget + " Properties").getField(deviceOrField))
        else:
            InputActions.mouseClickOnItem(WidgetProperties(widget).getTextField("Field"))
        if object.exists(Properties(widget + " Properties").getField(deviceOrField)):
            try:
                type(waitForObject(Properties(widget + " Properties").getField(deviceOrField)), text)
                nativeType("<Down>")
            except LookupError:
                test.fail("FAIL", "Could not type: " + text)
        else:
            try:
                type(waitForObject(WidgetProperties(widget).getTextField("Field")), text)
                nativeType("<Down>")
            except LookupError:
                test.fail("FAIL", "Could not type: " + text)
        nativeType("<Return>")

    @classmethod
    def waitForEnabledButton(cls, buttonsRealName, timeToWait=15):
        """
        This method waits for the button to become enabled for timeToWait seconds
        @param buttonsRealName [string] real name of the button
        @param timeToWait [int] max time to wait for button to become enabled
        @return [boolean] returnValue True if button became enabled or False if not

        Usage:
        Common.waitForEnabledButton(ProgramAndSave().getButton("PROGRAM DEVICE"))
        Common.waitForEnabledButton(ProgramAndSave().getButton("PROGRAM DEVICE"), 10)
        """
        returnValue = False
        buttonEnabled = ""
        while timeToWait > 0:
            try:
                buttonEnabled = str(waitForObject(buttonsRealName).globalenabled)
                if buttonEnabled == "True":
                    returnValue = True
                    break
                else:
                    timeToWait -= 1
                    # TODO: removing because no RT-Exec snooze(1)
            except Exception as e:
                test.fail("FAIL", str(e))
                break

        return returnValue

    @classmethod
    def openProjectsListContentCheck(cls, option, expectedContent):
        """
        This method is used for checking the content of the list that openes when you select any of the File -> Open Project(s) option


        @param option [string] this parameter indicates if you want to open System/Device project, Library project or a Plugin project
                               the allowed values are: System/Device Project(s), Library Project(s) and Plugin Projects(s)
        @param expectedContent [string] this represents a set of project names expected in Open Project(s) window

        Usage:
        Common.openProjectsListContentCheck("Plugin Project(s)", pluginProjectSet)
        Common.openProjectsListContentCheck("System/Device Project(s)", systemDeviceProjectSet)
        """

        InputActions.activateMenuItem("File->" + option)
        if option == "Plugin Project(s)":
            openPluginProjectObj = OpenPluginProject()
            try:
                openProjectsList = str(waitForObject(openPluginProjectObj.getSheet()).children)
            except LookupError:
                test.fail("FAIL", "Can not find object or property")

        elif option == "Library Project(s)":
            openLibraryProjectObj = OpenLibraryProject()
            try:
                openProjectsList = str(waitForObject(openLibraryProjectObj.getSheet()).children)
            except LookupError:
                test.fail("FAIL", "Can not find object or property")

        elif option == "Open project(s)":
            openSystemDeviceProjectObj = OpenProject()
            try:
                openProjectsList = str(waitForObject(openSystemDeviceProjectObj.getSheet()).children)
            except LookupError:
                test.fail("FAIL", "Can not find object or property")

        start_sep = ']\''
        end_sep = ' ('
        parsingResultSet = set()
        tmp = openProjectsList.split(start_sep)
        for par in tmp:
            if end_sep in par:
                parsingResultSet.add(par.split(end_sep)[0])
        test.log("Parsing result: " + str(parsingResultSet))
        # TODO: removing because no RT-Exec snooze(1)

        if parsingResultSet == expectedContent:
            test.passes("PASS", "Open project(s) list contains only expected projects")
        else:
            test.fail("FAIL", "Open project(s) list doesn't contain only expected projects")

    @classmethod
    def selectPanelFromOverview(cls, widgetLabel, panelName):
        """
        @param widgetLabel [string] name of bubble buten under whitch is panel
        @param panelName [string] name of panel that shoud be opened
        @return no return

        Usage:
        Common.selectPanelFromOverview("Audio Function", "MIC Routing")
        """
        overviewObj = Overview()
        mainShellObj = MainShell()
        counter = 0
        InputActions.mouseClickOnItem(overviewObj.getWidgetLabel(widgetLabel))
        while counter < 10:
            InputActions.mouseClickOnTab(panelName)
            try:
                if str(waitForObject(mainShellObj.getCTab(panelName)).selected) == "True":
                    test.log(panelName + " is selected")
                    break
                elif counter == 9:
                    test.fail("FAIL", panelName + " is not selected")
                    break
                else:
                    test.log(panelName + " is not selected yet")
                    counter += 1
                    # TODO: removing because no RT-Exec snooze(1)
            except Exception as err:
                test.fail("FAIL", "Message " + str(err))
                break

    @classmethod
    def waitWithWhileLoop(cls, obj, timer=10, objectShouldExist=True):
        """
        This method is used for waiting object in while loop, from objectShouldExist
        depend if we wait for object to show or disappear

        @param obj object that we are witing to show or disappear
        @param timer [int] waximum time of wait
        @param objectShouldExist [bool] If it is True, Object does not exist and we wait it to show
                                                 False, Object exist and we wait it to disappear
        @return no return

        Usage:
        Common.waitWithWhileLoop(directoryObj.getBoardOrSystem(whiteSystem), objectShouldExist=False)
        """
        status = None
        counter = 0
        while counter < timer:
            if objectShouldExist:
                if object.exists(obj) == False:
                    # TODO: removing because no RT-Exec snooze(1)
                    counter += 1
                else:
                    status = True
                    break
            else:
                if object.exists(obj):
                    # TODO: removing because no RT-Exec snooze(1)
                    counter += 1
                else:
                    status = False
                    break

        if objectShouldExist == True and status == True:
            test.passes("PASS", obj + " is shown")
        elif objectShouldExist == False and status == False:
            test.passes("PASS", obj + " is disappear")
        elif objectShouldExist == True and status == None:
            test.fail("FAIL", obj + " is not shown in period of " + timer + " seconds")
        elif objectShouldExist == False and status == None:
            test.fail("FAIL", obj + " is not disappeared in period of " + timer + " seconds")
        else:
            test.fail("FAIL", "Waiting for object to shown/disappear in " + timer + " second is not executed successfully")

    @classmethod
    def waitForObjectToAppear(cls, objectsRealName, timeToWait=30):
        """
        This method waits for object to appear in SCS for timeToWait seconds
        @param objectsRealName [string] real name of the object
        @param timeToWait [int] max time to wait for object to appear
        @return [boolean] returnValue True if object appeared or False if not

        Usage:
        Common.waitForObjectToAppear(InformationShell().getTitleLabel("Information"))
        Common.waitForObjectToAppear(InformationShell().getTitleLabel("Information"), 10)
        """
        returnValue = False
        while timeToWait > 0:
            if object.exists(objectsRealName):
                returnValue = True
                break
            else:
                timeToWait -= 1
                snooze(1)

        return returnValue

    @classmethod
    def connect_to_studio_bridge(cls, ip_address, port_number):
        """
        This methods connects hardware by Studio bridge connection
        @param ip_address: [str] ip address of the hardware
        @param port_number: [str] port number
        @return:
        """
        InputActions.activateMenuItem("Tools->StudioBridge Connection")
        studio_bridge = StudioBridgeConnection()
        InputActions.typeText(studio_bridge.get_ip_field(), ip_address)
        InputActions.typeText(studio_bridge.get_port_field(), port_number)
        InputActions.mouseClickOnButton(studio_bridge.get_connect_btn())
        scs_shell = "{caption='' isvisible='true' type='org.eclipse.swt.widgets.Shell'}"
        error_shell = "{styletype='scs-SimpleDialogRoot scs-dialogRoot' visible='true' window=" + scs_shell+ "}"
        if waitForObject(error_shell, 10*1000):
            ok_btn = "{caption='OK' styletype='button scs-button' visible='true' window=" + scs_shell + "}"
            InputActions.mouseClickOnButton(ok_btn)
            test.log("Failed to establish Studio bridge to ip: %s, port: %s" % (ip_address, port_number))
        else:
            InputActions.mouseClickOnItem(studio_bridge.get_close_btn())
