# Base classes for BSP GUI Squish tests
import builtins
import os
import platform
import re
import json
import csv
import paramiko
import traceback
import yaml
from distutils.version import LooseVersion

from collections import namedtuple


source(findFile("scripts", "bsp.py"))
source(findFile("scripts", "common.py"))
source(findFile("scripts", "real_names_panels.py"))
source(findFile("scripts", "real_names_bsp.py"))

reg_map_data = namedtuple('RegisterMapItems', 'Register BitField')
RegMapItem = reg_map_data('Register', 'BitField')

bit_field_struct = namedtuple('BitFields', 'TextField RadioButton ComboBox CheckBox Slider')
BitFieldType = bit_field_struct('Value', 'Radio Button', 'Combo Box', 'Check Box', 'Slider')


class SquishError(Exception):
    """
    Custom Exception
    """

    def __init__(self, message=None):
        super(SquishError, self).__init__(message)


# pass/fail bools and abort state is the same as abort step because abort step leads to abort state.
PASS_STATE = True
FAIL_STATE = False
ABORT_STATE = "A"
# pass/fail/abort test step outcome
PASS_STEP = "P"
FAIL_STEP = "F"
ABORT_STEP = "A"
# pass/fail/abort strings
PASS = "PASS"
FAIL = "FAIL"
ABORT = "ABORT"
HISTORY = 'HISTORY'
REG_MAP = 'REG_MAP'

def rawstring(input_string):
    """Returns a raw string representation of text"""
    escape_dict = {'\a': r'\a',
                   '\b': r'\b',
                   '\c': r'\c',
                   '\f': r'\f',
                   '\n': r'\n',
                   '\r': r'\r',
                   '\t': r'\t',
                   '\v': r'\v',
                   '\'': r'\'',
                   '\"': r'\"',
                   '\0': r'\000',
                   '\1': r'\001',
                   '\2': r'\002',
                   '\3': r'\003',
                   '\4': r'\004',
                   '\5': r'\005',
                   '\6': r'\006'}

    new_string = ''
    for char in input_string:
        try:
            new_string += escape_dict[char]
        except KeyError:
            new_string += char
    return new_string


def read_yaml(yml_file):
    """
    Function to read yaml file
    @param yml_file [str] Configuration yml file path
    @return [dict] yml content in dictionary format
    """
    with open(yml_file, "r") as yml_file_handle:
        yml_content = yaml.safe_load(yml_file_handle)
    return yml_content


class BspSquishConfig:
    def __init__(self, config_yml="squish_resource_config.yml"):
        config_yml = rawstring(os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..",
                                                            "project_shared", config_yml)))
        if not os.path.exists(config_yml):
            raise OSError('File : %s not found ' % config_yml)
        self.squish_config = {}
        self.squish_config.update(read_yaml(config_yml)['config'])


class RegMapCheck:
    def __init__(self, reg_name, expected_val, reg_map_item, bit_field_name=None, bit_field_type=None,
                 values_enum=None):
        self.reg_name = reg_name
        self.expected_val = expected_val
        self.item_type = reg_map_item
        self.bit_field_name = bit_field_name
        self.bit_field_type = bit_field_type
        self.values_enum = values_enum


class BaseSquish:
    def __init__(self):
        self.system = ""
        self.squish_config = BspSquishConfig()
        self.device_name = ""
        self.sys_name = ""
        self.test_inputs_dict = {}
        self.overall_outcome = FAIL
        self.outcomes = []
        self.assertions = []
        self.quiet_asserts = False
        self.bsp_mapping = self.squish_config.squish_config['bsp_mapping']
        self.BSP_NAME = self.read_bsp_name()
        self.BSP, self.BSP_DEVICE_MAPPING = self.read_bsp_and_bsp_mapping()
        self.scs_version = get_scs_version()
        self.history_prop_type = self.get_history_prop()

    def read_bsp_name(self):
        """
        Read BSP names as keys and dev id as values from bsp_mapping configuration
        @return: [namedtuple] BSP name namedtuple
        """
        bsp_dev_id_keys = list(self.bsp_mapping['BSP'].keys())
        _BSP_NAMES = namedtuple('BspNames', ' '.join(bsp_dev_id_keys))
        return _BSP_NAMES(*list(self.bsp_mapping['BSP_DEVICE_MAPPING'].values()))

    def read_bsp_and_bsp_mapping(self):
        """
        Read BSP names and corresponding device id
        @return: [namedtuple, dict] BSP names namedtuple and BSP Mapping dictionary
        """
        bsp_dev_id_keys = list(self.bsp_mapping['BSP'].keys())
        _BSP = namedtuple('BspProjects', ' '.join(bsp_dev_id_keys))
        return _BSP(*list(self.bsp_mapping['BSP'].values())), self.bsp_mapping['BSP_DEVICE_MAPPING']

    def set_inputs(self, skip_reset=None, reg_map_test=False):
        self.history_obj = None
        self.device_name = self.test_inputs_dict.get('device_name')
        if not reg_map_test:
            self.panel = self.test_inputs_dict.get('panel_name')
        self.device_postfix = self.device_name[-1:]
        source(findFile("scripts", "jython_execute.py"))
        if self.BSP_NAME.Cornell in self.device_name:
            source(findFile("scripts", "cornell.py"))
            self.reg_map_name = ''.join([self.device_name, " (", self.device_name, ")"])
            self.cornell = Cornell(self)
        elif self.BSP_NAME.Berry in self.device_name:
            source(findFile("scripts", "berry.py"))
            self.reg_map_name = ''.join([self.device_name, " (", self.device_name.split()[0], ")"])
            if not skip_reset:
                self.berry = Berry(self, self.reg_map_name, self.device_name)
        elif self.BSP_NAME.Becker in self.device_name:
            source(findFile("scripts", "becker.py"))
            self.reg_map_name = ''.join([self.device_name, " (", self.device_name.split(' ')[0], ")"])
            self.becker = Becker()
        elif self.BSP_NAME.Trucks in self.device_name:
            source(findFile("scripts", "trucks.py"))
            self.reg_map_name = ''.join([self.device_name, " (", self.device_name.split(' ')[0], ")"])
            self.trucks = Trucks(self, self.reg_map_name, self.device_name)
        elif self.BSP_NAME.Domino in self.device_name:
            source(findFile("scripts", "domino.py"))
            mode = builtins.bin(builtins.int(self.device_name.split(" ")[2]))[2:].zfill(2)
            self.reg_map_name = ''.join([self.device_name, " (", self.device_name.split(' ')[0], "_", mode, ")"])
            self.domino = Domino()
        elif self.BSP_NAME.Dollar in self.device_name:
            source(findFile("scripts", "dollar.py"))
            self.reg_map_name = ''.join([self.device_name, " (", self.device_name, ")"])
            self.dollar = Dollar()
        elif self.BSP_NAME.Sterling in self.device_name:
            source(findFile("scripts", "sterling.py"))
            self.reg_map_name = ''.join([self.device_name, " (", self.device_name, ")"])
            self.sterling = Sterling(self, self.reg_map_name, self.device_name)
        # self.open_register_map_and_history()

    def setup(self, delete_test_data=True, system_required=True, regmap_history_open=True,
              studio_bridge_ip=None):
        self.bsp_real_names = BspRealNames()

        test.log("Deleting SCS metadata...")
        Common.deleteSoundClearStudioMetadata()

        test_input_path = os.path.abspath(os.path.join(os.path.dirname(__file__),
                                          "..", "..", "project_shared", "test_inputs.yml"))
        if not os.path.exists(test_input_path):
            raise OSError('File : %s not found ' % test_input_path)
        self.test_inputs_dict.update(read_yaml(test_input_path)['config'])

        self.system = self.test_inputs_dict['system_name']
        if re.search("CS[4|3][4|5|7|0]L[9|2|6][0|1|2|7]", self.system) is not None:
            system = self.system.split(' ')
            sys_elem_length = len(system)
            if sys_elem_length == 3:
                self.system = ' '.join([system[0], system[2]])
            elif sys_elem_length == 4:
                self.system = ' '.join([system[0], system[3]])
        real_sys = self.test_inputs_dict['real_system']
        # Run SoundClear Studio
        # Close Welcome Screen if it is active in the beginning of SoundClear Studio
        test.log("Starting SoundClear Studio...")
        Common.startAUT(delete_testdata=delete_test_data)

        # Create virtual system or discover the real board if this test is not a BSP install test.
        # For BSP installation we do not need to discover a board because we may not have any BSP already installed
        # in the system
        if system_required:
            if not real_sys:
                test.log("Creating virtual system...")
                self.sys_name = "Simulated " + self.system
                Bsp.addVirtualSystem(self.sys_name, self.system)
            elif studio_bridge_ip:
                Common.connect_to_studio_bridge(self.squish_config.squish_config['studio_bridge_ip'],
                                                self.squish_config.squish_config['studio_bridge_port'])
            else:
                # Real system
                self.sys_name = self.system
                if not self.discover_board():
                    cirruslink_present = self.squish_config.squish_config['cirruslink_present']
                    
                    # AudioHub present and not EMU systems, this code block is only for CDB 
                    if cirruslink_present and "EMU" not in self.sys_name:
                        self.cirruslink_restart(self.squish_config.squish_config['cirruslink_ip'])
                        if platform.system() == 'Darwin':
                            snooze(10)
                        if not self.discover_board():
                            raise SquishError("Unable to discover system %s" % self.sys_name)
                    else:
                        raise SquishError("Unable to discover system %s" % self.sys_name)
        self.device_name = self.test_inputs_dict.get('device_name')
        if regmap_history_open:
            self.open_register_map_and_history()

    def discover_board(self, timeout=30):
        counter = 0
        discover_board = ReadActions.checkBoardExist(self.sys_name)
        while not discover_board and counter < timeout:
            snooze(1)
            discover_board = ReadActions.checkBoardExist(self.sys_name)
            counter += 1
        return discover_board

    def run(self):
        pass

    def teardown(self):
        self.print_result_metrics()
        test.log("Set SCS to default state")
        Common.deleteAllVirtualSystems()
        Common.endAUT()
        test.log("Deleting SCS metadata...")
        Common.deleteSoundClearStudioMetadata()

    def run_test(self, delete_test_data=True, system_required=True, regmap_history_open=True):
        try:
            self.setup(delete_test_data, system_required, regmap_history_open)
            self.run()
        except Exception:
            self.assert_true(False, "Exception while running test case: \n %s" % (
                traceback.format_exc(traceback.extract_stack())))
        self.teardown()

    def set_quiet_assertions(self, quiet=True):
        self.quiet_asserts = quiet

    def record_fail(self, assertion_message):
        """Record assertion and outcome on failure.
        @param assertion_message log msg for failed assertion
        @return bool - outcome of the assertion
        """
        fail_state = FAIL_STATE
        self.outcomes.append(FAIL_STEP)
        self.assertions.append(assertion_message)
        # if self.overall_outcome == PASS:
        #     self.overall_outcome = FAIL
        return fail_state

    def record_pass(self, assertion_message):
        """Record assertion and outcome on pass.
        @param assertion_message log msg for pass assertion
        @return bool - outcome of the assertion
        """
        pass_state = PASS_STATE
        self.outcomes.append(PASS_STEP)
        self.assertions.append(assertion_message)
        return pass_state

    def get_overall_outcome(self):
        """return overall squish test outcome"""
        if len(self.outcomes) == 0 or FAIL_STEP not in self.outcomes:
            self.overall_outcome = PASS
        return self.overall_outcome

    def print_result_metrics(self):
        log_msg = "Overall Squish Test Result: %s \nRESULT_METRICS:\n%s" % (self.get_overall_outcome(),
                                                                             '\n'.join(self.assertions))
        if self.overall_outcome == PASS:
            test.passes(log_msg)
        else:
            test.fail(log_msg)

    def step_outcome(self):
        """return a list of test step outcomes.
        @return string that indicates the outcome of each step in a string (string made of P or F)
        """
        outstr = "".join(self.outcomes)
        return outstr

    def assert_equal(self, actual, expected, assert_message):
        """Assert if actual value is equal to the expected value
        @param actual Actual measured value of any type
        @param expected Expected measured value of any type
        """
        if actual == expected:
            assertion_message = "Assert Equal - %s, got expected value %s" % (assert_message, actual)
            self.record_pass(assertion_message)
        else:
            assertion_message = "Assert Equal - %s, actual value: %s(%s) does NOT equal expected value: %s(%s)" % (
                assert_message, actual, builtins.type(actual), expected, builtins.type(expected))
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def print_asserts(self, assertions_msg):
        if not self.quiet_asserts:
            if self.outcomes[-1] == PASS_STEP:
                test.passes(assertions_msg)
            else:
                test.fail(assertions_msg)

    def assert_not_raises(self, method, expected_message, *args, **kwargs):
        """
        Assert if exception is not raised while executing the given method
        """
        exception_raised = None
        assertion_message = "Assert Not Raises - %s" % expected_message
        try:
            ret_val = method(*args, **kwargs)
            if ret_val is False:
                raise Exception
            else:
                self.record_pass(assertion_message)
        except Exception as e:
            exception_raised = e
            self.record_fail(assertion_message)
        if exception_raised:
            return exception_raised
        self.print_asserts(assertion_message)

    def assert_contains(self, actual, expected, assert_message):
        """Assert if actual value is equal to the expected value
        @param actual Actual measured value of any type
        @param expected Expected measured value of any type
        """
        if expected in actual:
            assertion_message = "Assert Contains - %s, %s contains expected value %s" % (assert_message,
                                                                                         actual, expected)
            self.record_pass(assertion_message)
        else:
            assertion_message = "Assert Contains - %s, %s(%s) does NOT contain %s(%s)" % (assert_message, actual,
                                builtins.type(actual), expected, builtins.type(expected))
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def assert_contains_in_list(self, expected_list, actual_list, assert_message):
        state = True
        for item in expected_list:
            if item not in actual_list:
                state = False
        if state:
            assertion_message = "Assert Contains - %s, %s contains expected value %s" % (assert_message, actual_list,
                                                                                         expected_list)
            self.record_pass(assertion_message)
        else:
            assertion_message = "Assert Contains - %s, %s(%s) does NOT contain %s(%s)" % (
                assert_message, actual_list, builtins.type(actual_list), expected_list,
                builtins.type(expected_list))
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def assert_not_contains(self, actual, not_expected, assert_message):
        """
        Check if a content is not present in the expected content
        @param actual: Actual content
        @param not_expected: Content not expected to be present
        @param assert_message: Assertion message
        """
        if not isinstance(not_expected, list):
            not_expected = [not_expected]

        if all(not_exp not in actual for not_exp in not_expected):
            assertion_message = "Assert Not Contains - %s, %s does not contain value %s" % (assert_message,
                                                                                                      actual,
                                                                                                      not_expected)
            self.record_pass(assertion_message)
        else:
            assertion_message = "Assert Not Contains - %s, %s contains %s" % (assert_message, actual, not_expected)
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def assert_true(self, state, assert_message):
        """Assert if state is true.
        @param state to compare with True (any type)
        @param assert_message assertion description message
        """
        assertion_message = "Assert_True - %s" % assert_message
        if state:
            self.record_pass(assertion_message)
        else:
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def assert_false(self, state, assert_message):
        """Assert if state is true.
        @param state to compare with True (any type)
        @param assert_message assertion description message
        """
        assertion_message = "Assert_False - %s" % assert_message
        if not state:
            self.record_pass(assertion_message)
        else:
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def assert_object_exists(self, object_real_name, name):
        waitForObject(object_real_name)
        if object.exists(object_real_name):
            assertion_message = "Assert_Object_Exists - Object %s exists" % name
            self.record_pass(assertion_message)
        else:
            assertion_message = "Assert_Object_Exists - Object %s does NOT exists" % name
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def assert_object_not_exists(self, object_real_name, name):
        if not object.exists(object_real_name):
            assertion_message = "Assert_Object_Not_Exists - Object %s Not exists" % name
            self.record_pass(assertion_message)
        else:
            assertion_message = "Assert_Object_Exists - Object %s exists" % name
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def assert_diff_in_dict_and_history(self, dict_list_a, srs_file_con, assertion_message):
        tuple_a = [reg_addr_val_tuple for reg_addr_and_value in dict_list_a
                   for reg_addr_val_tuple in list(reg_addr_and_value.items())]
        tuple_hist = [reg_addr_val_tuple for reg_addr_and_value in srs_file_con
                      for reg_addr_val_tuple in list(reg_addr_and_value.items())]
        multiple_reg_updated_in_hist = False
        # Multiple registers are updated if the tuple_hist values have list of values
        # in string format
        # Ex: (0x12, "[0x43, 0x56]")
        for reg_update in tuple_hist:
            if "[" in reg_update[1]:
                multiple_reg_updated_in_hist = True
        # If multiple registers are updated then go through each register update
        # in history entries and if value has list of values then converting the
        # list of values in string format to list
        # Ex: Register update (0x12, "[0x43, 0x56]") is converted to
        # (0x12, [0x43, 0x56])
        if multiple_reg_updated_in_hist:
            for index in range(len(tuple_hist)):
                tuple_hist[index] = list(tuple_hist[index])
                list_b = tuple_hist[index][1].strip('][').split(', ')
                if len(list_b) > 1:
                    tuple_hist[index][1] = tuple(tuple_hist[index][1].strip('][').split(', '))
                tuple_hist[index] = tuple(tuple_hist[index])
        differences = set(tuple_a) - set(tuple_hist)
        self.assert_equal(len(differences), 0, assertion_message + ", assertion for length of differences in lists")
        if len(differences) == 0:
            self.record_pass(assertion_message)
        else:
            assertion_message = "Differences %s between history files " % differences
            self.record_fail(assertion_message)
            self.assert_true(False, assertion_message)
        self.print_asserts(assertion_message)

    def assert_within_percentage(self, actual, expected, percentage, assert_message):
        """@Test and record if a value is within a range of another value

        Test and assert that the supplied measured value is within +/-percentage
        of the expected value. A numeric comparison is performed: actual,
        expected and percent parameters must look like numbers, otherwise the
        assertion fails. The percent parameter must be in the interval [0, 100],
        otherwise the assertion fails.

        @param actual Actual value measured, must be a numeric value
        @param expected Expected value, must be a numeric value
        @param percentage tolerance either side of the expected value, must be a
        numeric value in the interval [0, 100]
        @param assert_message String description of check
        @return Boolean indicating the outcome of the check
        """
        # Prerequisite check that all values are numbers and percentage is in [0, 100]
        if 0 <= percentage <= 100:
            within = (percentage * abs(expected)) / 100.0
            if (abs(expected) - within) <= abs(actual) <= (abs(expected) + within):
                assertion_message = ("PASS, Assert Within Percentage - %s, %s is within %s%% of %s") % (assert_message,
                                                                                                        actual,
                                                                                                        percentage,
                                                                                                        expected)
                self.record_pass(assertion_message)
            else:
                assertion_message = ("FAIL, Assert Within Percentage - %s, %s is NOT within %s%% of %s") % (assert_message,
                                                                                                            actual,
                                                                                                            percentage,
                                                                                                            expected)
                self.record_fail(assertion_message)
        else:
            assertion_message = ("FAIL, Assert Within Percentage - %s, "
                                 "percentage value is not in [0, 100], %s") % (assert_message, percentage)
            self.record_fail(assertion_message)
        self.print_asserts(assertion_message)

    def verify_register_or_bitfield(self, device_name, reg_map_checks, reg_map_name=None, print_assertion=True):
        """
        Verifies the register or bit field value given against value in register map
        @param device_name: [str] Device name
        @param reg_map_checks: [RegMapCheck] list of register map checks objects
        @param reg_map_name: [str] register map name Ex: "CS42L77 (CS42L77)"
        """
        if not reg_map_name:
            reg_map_name = '%s (%s)' % (device_name, device_name)
        reg_map = RegisterMap(reg_map_name)
        if isinstance(reg_map_checks, RegMapCheck):
            reg_map_checks = [reg_map_checks]
        else:
            raise SquishError("Unsupported input data %s" % reg_map_checks)
        for reg_map_check in reg_map_checks:
            register_name = reg_map_check.reg_name
            tested_field = register_name
            if reg_map_check.item_type == RegMapItem.Register:
                cur_reg_value = ReadActions.readRegisterByName(register_name, reg_map)
                # Converting unicode value to string
                current_val = str(cur_reg_value)
            elif reg_map_check.item_type == RegMapItem.BitField:
                bit_field_name = reg_map_check.bit_field_name
                tested_field = bit_field_name
                current_val = ReadActions.checkRegisterOrBitFieldValue(register_name,
                                                                       reg_map,
                                                                       nameOfBitFieldRegister=bit_field_name,
                                                                       bitFieldValueType=reg_map_check.bit_field_name,
                                                                       return_value=True)
            else:
                raise SquishError("Unsupported type of register map check %s" % reg_map_check.item_type)
            if reg_map_check.values_enum:
                current_val = reg_map_check.values_enum(builtins.int(current_val, 16))
                reg_map_check.expected_val = reg_map_check.values_enum(builtins.int(reg_map_check.expected_val, 16))
            else:
                reg_map_check.expected_val = builtins.str(reg_map_check.expected_val).lower()
            if print_assertion:
                self.assert_equal(current_val, reg_map_check.expected_val,
                                  "Check if %s %s is set as expected" % (reg_map_check.item_type, tested_field))
            reg_map_verification = current_val == reg_map_check.expected_val
            reg_map_verification = PASS_STEP if reg_map_verification else FAIL_STEP
        results = {REG_MAP: reg_map_verification}
        return results

    def open_register_map_and_history(self):
        """
        Opens history window and register map
        """
        if self.is_reg_map_open():
            self.close_reg_map()
        if self.is_history_window_open():
            self.close_history_window()
        test.log("Open History")
        Common.openHistory(self.sys_name)
        test.log("Open Reg Map")
        Common.openRegisterMap(self.sys_name, self.device_name)

    def open_panel(self, panel_name=None, device_name=None, expand_dir_tree=False):
        """
        Opens the panel window
        """
        if panel_name is None:
            panel_name = self.panel
        if device_name is None:
            device_name = self.device_name
        panel_tab = "{caption='" + panel_name + "' type='org.eclipse.swt.custom.CTabItem' window=" + \
                    MainShell().getMainWindow() + "}"
        if object.exists(panel_tab):
            InputActions.mouseClickOnItem(panel_tab)
        else:
            if not self.is_panel_open():
                test.log("Open %s panel" % panel_name)
                Bsp.click_on_panel(panel_name, self.sys_name, device_name, expand_dir_tree)

    def close_panel(self, panel_caption=None):
        # Uses panels in its own shell
        scs_version = SuiteGlobals.SCS_VERSION_SHORT.split("_")[1]
        if LooseVersion(scs_version) >= LooseVersion("1.5"):
            close_btn = "{caption='X' styletype='label scs-closeLabel' visible='true' " \
                "window={caption?='*' isvisible='true' type='org.eclipse.swt.widgets.Shell'}}"
        else:
            if panel_caption is None:
                panel_caption = self.device_name
            main_win = "{caption?='%s*' isvisible='true' type='org.eclipse.swt.widgets.Shell'}" \
                % panel_caption
            close_btn = "{caption='X' styletype='label scs-closeLabel' visible='true' window=" \
                        + main_win + "}"
        if self.is_panel_open(panel_caption):
            InputActions.mouseClickOnItem(close_btn)
        else:
            InputActions.mouseClickOnItem(close_btn)

    def close_tab(self, tab_title, check_tab_exists=False):
        close_btn = "{container={caption='%s' parent.visible='true' " \
                    "type='org.eclipse.swt.custom.CTabItem' window={caption='SoundClear Studio' " \
                    "isvisible='true' type='org.eclipse.swt.widgets.Shell'}} " \
                    "type='com.froglogic.squish.swt.CTabCloseBox'}" % tab_title
        if check_tab_exists:
            if object.exists(close_btn):
                InputActions.mouseClickOnItem(close_btn)
        else:
            InputActions.mouseClickOnItem(close_btn)

    def is_panel_open(self, panel_caption=None):
        """
        Return True if Panel is open else returns False
        :return: True | False
        """

        scs_version = SuiteGlobals.SCS_VERSION_SHORT.split("_")[1]
        if LooseVersion(scs_version) >= LooseVersion("1.5"):
            close_btn = "{caption='X' styletype='label scs-closeLabel' visible='true' " \
                        "window={caption?='*' isvisible='true' type='org.eclipse.swt.widgets.Shell'}}"
        else:
            if panel_caption is None:
                panel_caption = self.device_name
            main_win = "{caption?='%s*' isvisible='true' type='org.eclipse.swt.widgets.Shell'}" % panel_caption
            close_btn = "{caption='X' styletype='label scs-closeLabel' visible='true' window=" \
                        + main_win + "}"
        if object.exists(close_btn):
            return True
        else:
            return False

    def is_reg_map_open(self):
        """
        Return True if register map is open else returns False
        :return: True | False
        """
        self.reg_map_close_btn = "{container={caption?='[^CS*]' " \
                                 "parent.visible='true' type='org.eclipse.swt.custom.CTabItem' " \
                                 "window={caption='SoundClear Studio' isvisible='true' " \
                                 "type='org.eclipse.swt.widgets.Shell'}} " \
                                 "type='com.froglogic.squish.swt.CTabCloseBox'}"

        return object.exists(self.reg_map_close_btn)

    def is_history_window_open(self):
        """
        Return True if history window is open else returns False
        :return: True | False
        """
        self.history_window_close_btn = "{container={caption?='History: *' " \
                                        "parent.visible='true' type='org.eclipse.swt.custom.CTabItem' " \
                                        "window={caption='SoundClear Studio' isvisible='true' " \
                                        "type='org.eclipse.swt.widgets.Shell'}} " \
                                        "type='com.froglogic.squish.swt.CTabCloseBox'}"
        return object.exists(self.history_window_close_btn)

    def close_reg_map(self):
        """
        Closes the Register map window
        """
        while(object.exists(self.reg_map_close_btn)):
            InputActions.mouseClickOnItem(self.reg_map_close_btn)

    def close_history_window(self):
        """
        Closes the history window
        """
        while(object.exists(self.history_window_close_btn)):
            InputActions.mouseClickOnItem(self.history_window_close_btn)

    def get_history_prop(self):
        """
        This method returns history window property type
        """
        if LooseVersion(self.scs_version) >= LooseVersion("1.7.8"):
            history_prop_type = 'text'
        else:
            history_prop_type = 'item'
        return history_prop_type

    def check_history_and_reg_map(self, reg_map_name, register_name, expected_value,
                                  bitfield_name, bitfield_type, bitfield_expected, slider_label_value=None,
                                  reg_map_field_value=None, print_assertion=True, reg_expected_value=False,
                                  get_last_row=True, export_srs=False):
        """
        To cross verify history and register map values against expected values
        """
        if export_srs:
            Common._typeInFilter(self.sys_name, register_name)
            hist_len = Common.getHistoryLength(self.sys_name)
            self.scroll_history_window(self.sys_name)
            hist_file_path = Common.exportHistoryRow(self.sys_name,
                                                     "temp_register_update.srs",
                                                     str(hist_len - 1))
            Common.clearHistoryFilter(self.sys_name)
            snooze(0.5)
            srs_con = self.parse_history_file(hist_file_path)
            reg_value = self.convert_srs_to_tuple(srs_con)
            reg_value = reg_value[0][1]
            history_check = reg_value == expected_value
        else:
            reg_value = Common.searchInFilter(self.sys_name, register_name, "Data", get_last_row=get_last_row,
                                              history_prop_type=self.history_prop_type)
            reg_value = [str(each_reg_val).rstrip() for each_reg_val in reg_value]
            history_check = expected_value in reg_value

        history_check = PASS_STEP if history_check else FAIL_STEP
        test.log("history window check: %s, Register: %s, "
                 "actual reg value %s in expected value %s " % (history_check, register_name,
                                                                reg_value, expected_value))

        Common.clearHistory(self.sys_name)
        # register map check
        test.log("Read value from Register Map and compare with expected value")
        reg_map_obj = RegisterMap(reg_map_name)
        InputActions.mouseClickOnItem(reg_map_obj.getRegisterFromRegTable(register_name))
        row = str(findObject(reg_map_obj.getRegisterFromRegTable(register_name)).cell.parent.index)
        register = findObject(reg_map_obj.getRegisterCellArea("Value", row, reg_map_obj.getRegisterTable()))
        value_from_reg_map = register.parent.item.lastsavedvalue
        if reg_expected_value:
            expected_value = reg_expected_value
        if isinstance(expected_value, tuple):
            value_from_reg_map = builtins.int(value_from_reg_map, 16)
            value_from_reg_map = builtins.hex(value_from_reg_map)
            reg_map_check = str(value_from_reg_map) in expected_value
        else:
            reg_map_check = str(value_from_reg_map) == str(expected_value)
        reg_map_check = PASS_STEP if reg_map_check else FAIL_STEP
        test.log("Register map check outcome: %s, Register: %s, "
                 "Bit field: %s, field type: %s, bitfield_expected: %s, "
                 "actual value %s is equal to expected value %s" % (reg_map_check, register_name, bitfield_name,
                                                                    bitfield_type, bitfield_expected,
                                                                    value_from_reg_map, expected_value))
        results = {HISTORY: history_check, REG_MAP: reg_map_check}
        if print_assertion:
            self.assert_equal(list(results.values()), [PASS_STEP, PASS_STEP],
                              "Check if both history and register map check PASSED for register %s,"
                              " bit field %s, field type %s" % (register_name, bitfield_name, bitfield_type))

        if slider_label_value is not None:
            bitfield_expected = str(slider_label_value)
        elif reg_map_field_value:
            bitfield_expected = str(reg_map_field_value)
        if not export_srs:
            ReadActions.checkRegisterOrBitFieldValue(
                register_name, RegisterMap(reg_map_name), None, bitfield_name, bitfield_type, bitfield_expected,
                return_value=True)
        return results

    def convert_srs_to_tuple(self, srs_con):
        tuple_hist = [reg_addr_val_tuple for reg_addr_and_value in srs_con
                      for reg_addr_val_tuple in list(reg_addr_and_value.items())]
        for index in range(len(tuple_hist)):
            tuple_hist[index] = list(tuple_hist[index])
            list_b = tuple_hist[index][1].strip('][').split(', ')
            if len(list_b) > 1:
                tuple_hist[index][1] = tuple(tuple_hist[index][1].strip('][').split(', '))
            tuple_hist[index] = tuple(tuple_hist[index])
        return tuple_hist

    def check_warning_message(self, real_name, invalid_entry, poup_message, check_warning_only=False,
                              print_assertion=True, time_to_wait=2):
        preferences_obj = Preferences()
        if not check_warning_only:
            self.open_panel()
            test.log("For text entry: %s pop-up need to be displayed" % invalid_entry)
            InputActions.typeText(real_name, invalid_entry)
        obj_width = builtins.int(waitForObject(real_name).width)
        obj_height = builtins.int(waitForObject(real_name).height)
        warning_msg_exists = None
        for value in builtins.range(2, 10):
            if not warning_msg_exists:
                mouseMove(waitForObject(real_name), obj_width/value, obj_height/value)
                warning_msg_exists = preferences_obj.getTooltipText(poup_message) is not None
            else:
                break
        reg_map_check = PASS_STEP if warning_msg_exists else FAIL_STEP
        results = {REG_MAP: reg_map_check}
        if print_assertion:
            self.assert_true(warning_msg_exists, "%s Warning pop-up is displayed" % poup_message)
        return results

    def read_register_value(self, device_name, register_name, reg_map_name=None):
        """
        Reads the given register value from register map and returns it
        """
        if self.is_panel_open():
            self.close_panel()
        if not reg_map_name:
            reg_map_name = "%s (%s)" % (device_name, device_name)
        cur_reg_value = ReadActions.readRegisterByName(register_name, RegisterMap(reg_map_name))
        return cur_reg_value

    def write_register_and_verify(self, device_name, register_name, register_value, reg_map_name=None, verify_reg=True,
                                  open_history_table=False, verify_history=False, print_assertion=True):
        """
        Writing a value to register map and checking if that value if written
        """
        result = {}
        if open_history_table:
            Common.openHistory(self.sys_name)
            Common.clearHistory(self.sys_name)
        if not reg_map_name:
            reg_map_name = "%s (%s)" % (device_name, device_name)
        register_map_obj = RegisterMap(reg_map_name)
        InputActions.mouseClickOnItem(register_map_obj.getRegisterFromRegTable(register_name))
        row = str(findObject(register_map_obj.getRegisterFromRegTable(register_name)).cell.parent.index)
        Common.changeRegisterValue("Value", row, register_map_obj.getRegisterTable(), register_value)
        if verify_reg:
            result = self.verify_register_value(device_name, register_name, register_value,
                                                reg_map_name=reg_map_name, verify_history=verify_history,
                                                print_assertion=print_assertion)
        return result

    def verify_register_value(self, device_name, register_name, register_value,
                              reg_map_name=None, verify_history=False, print_assertion=True, history_row=None):
        """
        Method to verify a register value against register map
        """
        if not reg_map_name:
            reg_map_name = "%s (%s)" % (device_name, device_name)
        verify_reg_update = RegMapCheck(register_name, register_value, RegMapItem.Register)
        result = self.verify_register_or_bitfield(device_name, verify_reg_update, reg_map_name=reg_map_name,
                                                  print_assertion=print_assertion)
        if verify_history:
            history_result = self.verify_history_data(self.sys_name, register_name, register_value,
                                                      print_assertion=print_assertion, history_row=history_row)
            result[HISTORY] = history_result
        return result

    def search_and_select_register(self, reg_map_name, reg_name):
        """
        Method to search and select for a register in register map
        """
        reg_map_obj = RegisterMap(reg_map_name)
        InputActions.mouseDoubleClickOnItem(reg_map_obj.getSearch())
        InputActions.mouseClickOnItem(reg_map_obj.getSearch())
        machine = platform.system()
        if "Darwin" in machine:
            nativeType("<Command+a>")
            nativeType("<Delete>")
        elif 'Windows' in machine:
            nativeType("<Ctrl+a>")
            nativeType("<Delete>")
        Common.selectRegister(reg_map_name, reg_name)

    def verify_history_data(self, sys_name, register_name, register_value, print_assertion=True, history_row=None):
        """
        Method to search and get the register value from history table
        """
        history_rows = ReadActions.getNumberOfHistoryRows(sys_name)
        history_rows -= 1
        if history_row:
            history_rows -= history_row
        value_in_table = ReadActions.readTextFromTable("Data", str(history_rows), "History", sys_name=self.sys_name,
                                                       history_prop_type=self.history_prop_type)
        value_in_table = value_in_table.rstrip()
        if print_assertion:
            self.assert_equal(str(value_in_table), str(register_value),
                              "Check history window for register value, Register: %s" % register_name)
        history_verification = str(value_in_table) == str(register_value)
        history_verification = PASS_STEP if history_verification else FAIL_STEP
        Common.clearHistory(self.sys_name)
        return history_verification

    def device_reset(self, device_real_name, reg_map_name, panel_close, register_name, register_value,
                     bit_field_name, bit_field_value, history_value):
        bit_field_type = 'Value'
        self.open_panel(panel_name='Device Overview')
        Common.clearHistory(self.sys_name)
        InputActions.mouseClickOnItem(device_real_name)
        snooze(0.5)
        InputActions.mouseClickOnItem(panel_close)
        self.check_history_and_reg_map(reg_map_name, register_name, history_value, bit_field_name, bit_field_type,
                                       bit_field_value, reg_expected_value=register_value)

    def cirruslink_restart(self, ipaddress, port=22):
        """
        Given the audio hub ip address, this method creates a ssh connection to connect to audio hub,
        and issues a cirruslink service restart.
        @param: ipaddress: IP address of the audio hub hardware extracted from the system name.
        @param: port, default port number 22 is used.
        """
        username = 'root'
        password = 'crus'
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(ipaddress, port=port, username=username, password=password)
        stdin, _, _ = ssh.exec_command('service cirruslink stop')
        stdin.flush()
        snooze(0.5)
        stdin, _, _ = ssh.exec_command('service cirruslink start')
        stdin.flush()
        snooze(0.5)
        ssh.close()

    @staticmethod
    def parse_history_file(history_file_path):
        """
        Parse srs file and populate it into list of dictionaries

        @param history_file_path: srs file path
        @raises [SquishError] If history file type is neither srs nor csv

        @return: [list] srs file content as list of dictionaries
        """
        history_data_list = []
        if history_file_path.endswith('.srs'):
            srs_file_handle = open(history_file_path, "r")
            srs_file_con = srs_file_handle.readlines()
            for srs_updated in srs_file_con:
                srs_data = {}
                if srs_updated[0:2] != '0x':
                    continue
                else:
                    address, value = srs_updated.split(" = ")
                    value = value.strip()
                    srs_data[address] = value
                history_data_list.append(srs_data)
        elif history_file_path.endswith('.csv'):
            with open(history_file_path, 'r') as history_file_handle:
                reader = csv.DictReader(history_file_handle)
                for register_update in reader:
                    history_data_list.append(dict(register_update))
        else:
            raise SquishError('Parsing not implemented for file type: %s' % history_file_path.split(".")[1])
        return history_data_list

    def compare_history_files(self, history_file_path_1, history_file_path_2, columns=['Address', 'Data']):
        """
        Compares two register updates history files

        @param history_file_path_1: [str] first history file path
        @param history_file_path_2:[str] first history file path
        @param columns:[list<str>] column values to compare if history file type is csv
        @raises [SquishError] If history file type is neither srs nor csv

        @return [bool] True when history files are equal else False
        """
        history_data_list_1 = self.parse_history_file(history_file_path_1)
        history_data_list_2 = self.parse_history_file(history_file_path_2)
        if history_file_path_1.endswith('.srs'):
            pass
        elif history_file_path_1.endswith('.csv'):
            history_data_list_1 = [{history_data[columns[0]]: history_data[columns[1]]}
                                    for history_data in history_data_list_1]
            history_data_list_2 = [{history_data[columns[0]]: history_data[columns[1]]}
                                   for history_data in history_data_list_2]
        else:
            raise SquishError('Comparision for history not implemented for file type: %s' %
                              history_file_path_1.split(".")[1])
        self.assert_diff_in_dict_and_history(history_data_list_1,
                                             history_data_list_2,
                                         'Comparsion of history files %s, %s' % (history_file_path_1,
                                                                                 history_file_path_2))

    def scroll_history_window(self, sys_name, value=1):
        """
        Scrolling History window
        :param sys_name: system name
        :param value: scroll value 0-begin, 1-end
        :return:
        """
        history_scroll = "{container={container={caption='History: %s' parent.visible='true' " \
                         "type='org.eclipse.swt.custom.CTabItem' window={caption='SoundClear Studio' " \
                         "isvisible='true' type='org.eclipse.swt.widgets.Shell'}} id='historyTableView' " \
                         "styletype='table-view scs-history-table' visible='true'} styletype='scroll-bar' " \
                         "visible='true'}" % sys_name
        if object.exists(history_scroll):
            setValue(waitForObject(history_scroll), value)