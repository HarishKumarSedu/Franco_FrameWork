"""
Resource library for GUI automation using Squish

@Description:
This resource library provides wrapper methods for Squish executables to configure squish and
run a squish test case

Supported features:
- Adding Global scripts path
- Adding Mapped AUT
- Ini File Parser
- Start squish server
- Stop squish server
- run a squish test case
- analyse squish results

@b Usage
@code
res_squish = ResourceSquish()
res_squish.set_server_inputs({squish_path: <squish_path>,
aut_path: <aut_path>, server_port: <server_port>, runner_host:<runner_host>,
python_path: <python_path>, global_scripts_path:<global_scripts_path>})
res_squish.run_test_case(<test_case_name>, <test_suite_path>)
@endcode
"""
import os
import platform
import re
import time
import subprocess
import sys
import traceback
import socket
from threading import Thread
from time import sleep
import psutil
import yaml
import queue
import threading

from configparser import *

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


# Constants for OS platforms
WINDOWS = "Windows"
DARWIN = "Darwin"


class ResourceSquishError(Exception):
    """Define ResourceSquishError Exception type"""
    pass


class ParserIniError(Exception):
    """Define ParserIniError Exception type"""
    pass


class SquishTestResult(object):
    """
    Class for holding test case information
    """
    def __init__(self):
        self.test_name = None
        self.test_logs = []
        self.result_metrics = []
        self.result = 'FAIL'

    def __str__(self):
        return '%s:{\'result\': %s,\'test_logs\': %s, \'result_metrics\': %s}' % (
            self.test_name, self.result, "\n".join(self.test_logs), "\n".join(self.result_metrics))


class ParserIni:
    """
    This class holds functionality ini file parser
    """
    def __init__(self, file_name):
        self.file = file_name
        self.parser = SafeConfigParser()
        self.parser.optionxform = str
        self.parser.read(self.file)

    def get_str_value(self, *args):
        """
        Function get the value from the ini file
        """
        try:
            return self.parser.get(*args)
        except ParsingError as err:
            raise ParserIniError('Could not get value of String :%s, %s' % ("".join(args), err))

    def set_str_value(self, *args):
        """
        Function set the value in the ini file
        """
        try:
            return self.parser.set(*args)
        except ParsingError as err:
            raise ParserIniError('Could not set value of String :%s, %s' % ("".join(args), err))

    def add_section(self, *args):
        """
        Function adds a new section in the ini file
        """
        try:
            return self.parser.add_section(*args)
        except ParsingError as err:
            raise ParserIniError('Could not add section :%s, %s' % ("".join(args), err))

    def remove_section(self, *args):
        """
        Function remove the section from the ini file
        """
        try:
            return self.parser.remove_section(*args)
        except ParsingError as err:
            raise ParserIniError('Could not remove section :%s, %s' % ("".join(args), err))

    def write_value(self, *args):
        """
        Function write in the ini file
        """
        try:
            return self.parser.write(*args)
        except ParsingError as err:
            raise ParserIniError('Could not write value :%s, %s' % ("".join(args), err))


class ThreadWithReturnValue(object):
    """
    Class for thread running a thread and get its return value
    """
    def __init__(self, target=None, args=(), **kwargs):
        self._que = queue.Queue()
        self._t = threading.Thread(target=lambda q,arg1,kwargs1: q.put(target(*arg1, **kwargs1)),
                                   args=(self._que, args, kwargs),)
        self._t.start()

    def join(self):
        self._t.join()
        return self._que.get()


class ResourceSquish:
    """
    Implementation of wrapper methods for Squish configuration,starting,stopping squish server and
    running squish test case
    """
    def __init__(self):
        self.log = logging.getLogger(ResourceSquish.__name__)
        self.squish_server_app = None
        self.squish_runner_app = None
        self.runner_host = None
        self.server_port = None
        self.squish_runner = None
        self.squish_server = None
        self.testcase = None
        self.testsuite = None
        self.squish_config = None
        self.machine = platform.system()
        self.server_started = False
        self.tst_cases_info = []
        self.squish_java_aut_app = None
        self.additional_shared_dir = None
        self.test_controller_resource = False
        self.write_logs_to_file = True
        self.log_file_handle = None

    def _get_unique_unused_port(self):
        """
        Get the unique unused port number
        return: [int] Unused port number
        """
        tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tcp.bind(('', 0))
        _, unique_port = tcp.getsockname()
        tcp.close()
        return unique_port

    def set_server_inputs(self, runner_host, squish_config, global_shared_folder, additional_shared_dir=None):
        """
        Set the server input host and port.
        Configure squish add Global script path and add add AUT
        """
        self.squish_config = squish_config
        self.additional_shared_dir = additional_shared_dir
        squish_path = self.squish_config.get('path_to_squish')
        self.squish_server_app = '"' + self.rawstring(os.path.join(squish_path, "bin",
                                                              "squishserver")) + '"'
        self.squish_runner_app = '"' + self.rawstring(os.path.join(squish_path, "bin",
                                                              "squishrunner")) + '"'
        self.squish_java_aut_app = '"' + self.rawstring(os.path.join(squish_path, "bin",
                                                                "startjavaaut")) + '"'
        # self.runner_host = self.squish_config.get('runner_host')
        self.runner_host = runner_host
        self.server_port = self._get_unique_unused_port()
        self.configure_squish(global_shared_folder)
        self.log.info("Squish runner_host:%s, Squish server_port:%s", self.runner_host, self.server_port)

    def start_aut(self, aut_name, aut_port=9999, aut_host='localhost'):
        """
        Starting AUT before test case,so that we can use this AUT in our test cases.
        @param aut_name: [str] AUT name
        @param aut_port: [int] Port number on which AUT must be started
        @param aut_host: [str] host on which aut is running

        """
        start_aut_cmd = '%s --port=%s %s' % (self.squish_java_aut_app, aut_port, aut_name)
        try:
            self.start_aut = subprocess.Popen(start_aut_cmd, shell=True)
            time.sleep(10)
        except (OSError, subprocess.CalledProcessError, ValueError) as e:
            raise ResourceSquishError("Exception while starting aut " + e)
        self._register_started_aut(aut_name, aut_host, aut_port)

    def _register_started_aut(self, aut_name, aut_host, aut_port):
        """
        Registering the started AUT so that we can attach the started AUT in our test scripts
        @param aut_name: [str] AUT name
        @param aut_port: [int] Port number on which AUT must be started
        @param aut_host: [str] host on which aut is running
        """
        register_aut = '%s --config addAttachableAUT %s %s:%s' % (self.squish_server_app,
                                                                  aut_name,
                                                                  aut_host,
                                                                  aut_port)
        try:
            self.register_aut = subprocess.Popen(register_aut, shell=True)
        except (OSError, subprocess.CalledProcessError, ValueError) as e:
            raise ResourceSquishError("Exception while registering AUT " + e)

    def analyse_squish_results(self, squish_logs):
        """
        Analyse squish results based on squish logs and return the status
        """
        pattern_error = r'\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\s+ERROR'
        pattern_fail = r'Overall Squish Test Result: FAIL'
        pattern_pass = r'Overall Squish Test Result: PASS'

        find_errors = re.findall(pattern_error, squish_logs)
        find_fails = re.findall(pattern_fail, squish_logs)
        find_passes = re.findall(pattern_pass, squish_logs)

        if len(find_errors) > 0:
            tst_case_status = "ERROR"
        elif len(find_fails) > 0:
            tst_case_status = "FAIL"
        elif len(find_passes) > 0:
            tst_case_status = "PASS"
        else:
            tst_case_status = "ABORT"
        return tst_case_status

    def _log_stdout(self, _process):
        """
        Reads the process stdout and logs it to console and log file
        @param _process: [subprocess.Popen] Instance of subprocess.Popen
        @return: [str] Standard output of the process
        """
        stdout = ""
        for line in iter(_process.stdout.readline, ""):
            stdout += line
            print(line, end=' ')
            self.log_file_handle.write(line.replace('\n', ''))
        return stdout

    def _log_stderr(self, _process):
        """
        Reads the process stderr and logs it to console and log file
        @param _process: [subprocess.Popen] Instance of subprocess.Popen
        @return: [str] Standard error output of the process
        """
        stderr = ""
        for line in iter(_process.stderr.readline, ""):
            stderr += line
            print(line, end=' ')
            self.log_file_handle.write(line.replace('\n', ''))
        return stderr

    def _exec_cmd_log_stdout_stderr(self, command, join_threads=False):
        """
        Execute system command and log stdout and stderr to test log file
        @param command: [str] System command
        @param join_threads: [bool] join stdout and stderr threads
        """
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout_th = Thread(target=self._log_stdout, args=[process])
        stdout_th.start()
        stderr_th = Thread(target=self._log_stderr, args=[process])
        stderr_th.start()
        if join_threads:
            stdout_th.join()
            stderr_th.join()

    def start_squish_server(self):
        """
        Starting squish server
        """
        if not self.server_started:
            strt_squish_server = '%s --verbose --port %s' % (self.squish_server_app, self.server_port)
            try:
                if self.test_controller_resource:
                    log_file_name = logging.get_filename()
                    self.log_file_handle = open(log_file_name, 'a')
                    self._exec_cmd_log_stdout_stderr(strt_squish_server)
                else:
                    self.squish_server = subprocess.Popen(strt_squish_server, shell=True)
                timeout = 5
                timeout_start = time.time()
                while time.time() < timeout_start + timeout:
                    for process in psutil.process_iter():
                        try:
                            if 'squishserver' in process.name():
                                self.log.info("Squish server started successfully")
                                self.server_started = True
                                break
                        except psutil.Error:
                            pass
                    if self.server_started:
                        break
                    # Wait for 0.5 seconds and check again.
                    sleep(0.5)
            except (OSError, subprocess.CalledProcessError, ValueError) as e:
                raise ResourceSquishError("Exception while starting squish server " + e)
        else:
            self.log.warning("SquishServer already running on server_port %s", self.server_port)

    def stop_squish_server(self):
        """
        Stopping squish server
        """
        stop_squish_server = '%s --verbose --port %s --stop' % (
                               self.squish_server_app, self.server_port)
        try:
            if self.test_controller_resource:
                log_file_name = logging.get_filename()
                self.log_file_handle = open(log_file_name, 'a')
                self._exec_cmd_log_stdout_stderr(stop_squish_server, join_threads=True)
            else:
                subprocess.Popen(stop_squish_server, shell=True)
            self.server_started = False
        except (OSError, subprocess.CalledProcessError, ValueError) as e:
            raise ResourceSquishError("Exception while stopping Squish server " + e)

        if DARWIN in self.machine:
            kill_exe = ['_squishserver', '_squishrunner']
            for squish_process in kill_exe:
                process = subprocess.Popen('pgrep %s' % squish_process, shell=True, stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE)
                my_pid, err = process.communicate()
                if my_pid:
                    subprocess.Popen('kill -9 %s' % my_pid, shell=True)
        if self.test_controller_resource:
            self.log_file_handle.close()
        self.log.info("SquishServer successfully stopped")

    def run_test_case(self, testcase, testsuite):
        """
        Runs a testcase using squish runner and returns the status of the test case
        """
        if 'suite_register_map' in testsuite or 'suite_scs_bsp' in testsuite or 'suite_file_execute' in testsuite:
            self.testsuite = os.path.join(self.squish_config.get('test_inputs_common_path'), testsuite)
        else:
            self.testsuite = os.path.join(self.squish_config.get('test_inputs_path'), testsuite)
        self.testcase = testcase
        self.resultdir = os.path.join(self.testsuite, self.testcase)

        # SCS takes a very long time the first time when we open the IDE. We should set timeout to the max value.
        aut_timeout = 120

        self.log.info("SquishTest %s started", os.path.join(self.testsuite, self.testcase))
        tst_case_runner = '%s --host %s --port %s --testsuite "%s" --testcase %s --aut "%s" ' \
                          '--resultdir %s --config setAUTTimeout %s' % (self.squish_runner_app,
                                                                        self.runner_host,
                                                                        self.server_port,
                                                                        self.testsuite,
                                                                        self.testcase,
                                                                        self.squish_config.get('aut_path'),
                                                                        self.resultdir,
                                                                        aut_timeout)

        self.log.info("Squish runner command: %s", tst_case_runner)
        try:
            if self.test_controller_resource:
                process = subprocess.Popen(tst_case_runner, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                stdout_th = ThreadWithReturnValue(target=self._log_stdout, args=[process])
                stderr_th = ThreadWithReturnValue(target=self._log_stderr, args=[process])
                squish_runner_stdout = stdout_th.join()
                squish_runner_stderr = stderr_th.join()
            else:
                self.squish_runner = subprocess.Popen(tst_case_runner,
                                                      stdout=subprocess.PIPE,
                                                      stderr=subprocess.PIPE,
                                                      shell=True)
                squish_runner_stdout, squish_runner_stderr = self.squish_runner.communicate()
        except (OSError, subprocess.CalledProcessError, ValueError) as e:
            error_msg = "%s\n%s" % (e,
                                    "Error while running testcase %s in testsuite %s"
                                    % (self.testcase, self.testsuite))
            raise ResourceSquishError(error_msg)

        if squish_runner_stderr and not self.test_controller_resource:
            if("QSocketNotifier: Invalid socket 34 and type 'Read', disabling..."
                    in squish_runner_stderr):
                # for some reason on MAC the above message exists in stderr
                # this is a workaround
                error_msg = "%s\n%s" % (squish_runner_stderr,
                                        "SquishRunner - error occurred.")
                self.log.error(error_msg)
            else:
                self.log.error(squish_runner_stderr)

        self.tst_cases_info = self.get_tst_case_stdout(squish_runner_stdout,
                                                       log_to_console=not self.test_controller_resource)
        tst_case_status = self.analyse_squish_results(squish_runner_stdout)
        return tst_case_status

    def run_test_suite(self, testsuite, *exclude_tests_dir):
        """
        Runs a squish test suite
        @param testsuite: [str] test suite name
        @param exclude_tests_dir [list] List of test cases to exclude
        @return: [str] status of test suite
        """
        if 'suite_register_map' in testsuite:
            self.testsuite = os.path.join(self.squish_config.get('test_inputs_common_path'), testsuite)
        else:
            self.testsuite = os.path.join(self.squish_config.get('test_inputs_path'), testsuite)
        if exclude_tests_dir:
            exclude_str = ""
            for exc_tst in exclude_tests_dir:
                exclude_str += "--skip-testcase %s " % exc_tst
            tst_suite_runner = '%s --host %s --port %s --testsuite "%s" %s' \
                               '--aut "%s"' % (
                                    self.squish_runner_app, self.runner_host, self.server_port,
                                    self.testsuite, exclude_str, self.squish_config.get('aut_path'))
        else:
            tst_suite_runner = '%s --host %s --port %s --testsuite "%s" ' \
                               '--aut "%s"' % (self.squish_runner_app,
                                               self.runner_host,
                                               self.server_port,
                                               self.testsuite,
                                               self.squish_config.get('aut_path'))
        try:
            if self.test_controller_resource:
                process = subprocess.Popen(tst_suite_runner, shell=True, stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE)
                stdout_th = ThreadWithReturnValue(target=self._log_stdout, args=[process])
                stderr_th = ThreadWithReturnValue(target=self._log_stderr, args=[process])
                tst_suite_stdout = stdout_th.join()
                tst_suite_stderr = stderr_th.join()
            else:
                self.squish_runner = subprocess.Popen(tst_suite_runner, stdout=subprocess.PIPE,
                                                      stderr=subprocess.PIPE, shell=True)
                tst_suite_stdout, tst_suite_stderr = self.squish_runner.communicate()
        except (OSError, subprocess.CalledProcessError, ValueError) as e:
            error_msg = "%s\n%s" % (e, "Error while running testsuite %s" % self.testsuite)
            raise ResourceSquishError(error_msg)

        if tst_suite_stderr and not self.test_controller_resource:
            if ("QSocketNotifier: Invalid socket 34 and type 'Read', disabling..." in
                    tst_suite_stderr):
                # for some reason on MAC the above message exists in stderr
                # this is a workaround
                error_msg = "%s\n%s" % (tst_suite_stderr, "SquishRunner - error occurred.")
                self.log.error(error_msg)
            else:
                self.log.error(tst_suite_stderr)
        self.tst_cases_info = self.get_tst_case_stdout(tst_suite_stdout, not self.test_controller_resource)
        tst_suite_status = self.analyse_squish_results(tst_suite_stdout)
        return tst_suite_status

    @staticmethod
    def get_tst_case_stdout(tst_suite_stdout, log_to_console=True):
        """
        Parsers the suite stdout and populate tst case specific logs,result metrics and status
        in test_cases_info list,each object in list is of type SquishTestResult

        @param tst_suite_stdout: test suite stdout
        @log_to_console: [bool] Logging the test log onto console
        @return: [<SquishTestResult>] list of test cases stdout.
        """
        tst_cases_info = []
        tst_suite_stdout = tst_suite_stdout.split("\n")
        tst_strt_pattern = re.compile('START.*Start.*\((.*)\)')
        tst_end_pattern = re.compile('END_TEST_CASE.*')
        tst_case_info = None
        result_metrics = ['PASS:Assert', 'FAIL:Assert']
        for test_log in tst_suite_stdout:
            tst_strt = tst_strt_pattern.search(test_log)
            tst_end = tst_end_pattern.search(test_log)
            if tst_strt is not None:
                tst_case_name = tst_strt.group(1)
                tst_case_info = SquishTestResult()
                tst_case_info.test_name = tst_case_name
            if tst_end is not None:
                tst_case_info.test_logs.append(test_log)
                tst_cases_info.append(tst_case_info)
                tst_case_info = None
            if tst_case_info:
                filtered_log = re.match('.*(FAIL|PASS|LOG|ERROR)(.*)(:\d+:\s)(.*)', test_log)
                if not filtered_log:
                    continue
                log_index = len(filtered_log.groups())
                log_type = filtered_log.group(1)
                test_log = ":".join([log_type, filtered_log.group(log_index)])
                if log_to_console:
                    print(test_log)
                if any(result_metric in test_log for result_metric in result_metrics):
                    if 'PASS' in test_log:
                        tst_case_info.result = 'PASS'

                    tst_case_info.result_metrics.append(test_log)
                else:
                    tst_case_info.test_logs.append(test_log)
        return tst_cases_info

    def get_test_case_info(self, test_case_name):
        """
        Gets the test case info(stdout) of the test case
        param test_case_name: test case name
        @return [SquishTestResult] test case info object
        """
        if not self.tst_cases_info:
            raise ResourceSquishError("No test cases ran!")
        for tst_case_info in self.tst_cases_info:
            if test_case_name in str(tst_case_info):
                return tst_case_info
        raise ResourceSquishError("testcase info for :%s is not present" % test_case_name)

    def configure_squish(self, global_shared_folder):
        """
        Configure squish by adding python interpreter path,global scripts path and aut path
        """
        if self.machine not in [WINDOWS, DARWIN]:
            raise ResourceSquishError("Squish library for OS platform %s not supported" % self.machine)
        try:
            self.set_py_interpreter()
            self.add_global_scripts_path(global_shared_folder)
            self.add_aut_path()
        except Exception as e:
            raise ResourceSquishError(e)

    def add_aut_path(self):
        """
            Adding aut path to squish(Mapped AUT)
            @raises [ResourceSquishError] On Unsupported platform
        """
        aut_full_path = self.squish_config.get('aut_path', None)
        aut_path = os.path.split(aut_full_path)[0]
        aut_name = os.path.basename(aut_full_path).split(".")[0]
        if self.machine in WINDOWS or self.machine in DARWIN:
            add_aut = '%s --config addAppPath "%s"' % (self.squish_server_app,
                                                      aut_path)

            try:
                subprocess.Popen(add_aut, shell=True)
            except (OSError, subprocess.CalledProcessError, ValueError) as e:
                raise ResourceSquishError(e)
        else:
            raise ResourceSquishError("Squish not supported for platform %s" % self.machine)

    def add_global_scripts_path(self, global_shared_folder):
        """
            The function adds the globals script in Squish.
            Function writes a location to globals script in path.ini file.
            paths.ini file is located at c:\\Users\"username"\AppData\Roaming\froglogic\Squish\ver1\
            on Windows
            and Macintosh HD/Users/"username"/.squish/ver1/ on Mac OS
        """
        proj_specific_global = self.rawstring(os.path.abspath(os.path.join(self.squish_config.get('test_inputs_path'),
                                                                      "project_shared")))
        global_scs_shared = self.rawstring(os.path.abspath(os.path.join(os.path.dirname(__file__),
                                                                       global_shared_folder)))
        list_of_global_dirs = '%s,%s' % (global_scs_shared, proj_specific_global)
        if self.additional_shared_dir is not None:
            list_of_global_dirs = '%s,%s,%s' % (global_scs_shared, proj_specific_global, self.additional_shared_dir)

        global_script_path = '%s --config setGlobalScriptDirs "%s"' % (self.squish_runner_app, list_of_global_dirs)
        try:
            subprocess.Popen(global_script_path, shell=True)
        except (OSError, subprocess.CalledProcessError, ValueError) as e:
            raise ResourceSquishError(e)

    def set_py_interpreter(self):
        """
            The function change paths.ini file.
            Function replaces an @(SQUISH_PREFIX)\\python for C:\\Python27
            paths.ini file is located at c:/Users/"username"/Squish for Java 6.x.x/etc/paths.ini
        """
        squish_path = self.squish_config.get('path_to_squish', None)
        pathsini_path = os.path.join(squish_path, "etc", "paths.ini")
        python_path = self.squish_config.get('python_path')
        config = ParserIni(pathsini_path)
        if self.machine == WINDOWS:
            library_path = os.path.join(python_path, "Scripts")
            library_path = library_path.replace(os.sep, os.sep + os.sep)
            python_path = python_path.replace(os.sep, os.sep + os.sep)
            squish_prefix = '@(SQUISH_PREFIX)/bin;@(SQUISH_PREFIX)\\perl\\bin;@(SQUISH_PREFIX)\\ruby\\bin;' \
                            '@(SQUISH_PREFIX)\\tcl\\bin;'
        elif self.machine == DARWIN:
            library_path = os.path.join(python_path, "bin")
            squish_prefix = '@(SQUISH_PREFIX)/lib:@(SQUISH_PREFIX)/perl/lib/perl5/5.22.0/darwin-2level/CORE:' \
                            '@(SQUISH_PREFIX)/ruby/lib'
        config.set_str_value('Paths', 'Scripting/PythonHome', ''.join(['"', python_path, '"']))
        config_library_path = '%s%s' % (squish_prefix, library_path)
        config.set_str_value('Paths', 'LibraryPath', ''.join(['"', config_library_path, '"']))
        with open(pathsini_path, 'w') as configfile:
            config.write_value(configfile)

    def create_yml_file(self, test_case_inputs):
        try:
            squish_config_yml = self.rawstring(self.squish_config.get('squish_config'))
            test_inputs_yml = self.squish_config.get('test_inputs_path')
            test_inputs_yml = os.path.join(test_inputs_yml, "project_shared", 'test_inputs.yml')
            squish_common_config_yml = self.rawstring(self.squish_config.get('squish_common_config'))
            test_common_inputs_yml = self.squish_config.get('test_inputs_common_path')
            test_common_inputs_yml = os.path.join(test_common_inputs_yml, "project_shared", 'test_inputs.yml')
            self._create_config_yml(squish_config_yml, self.squish_config)
            self._create_config_yml(test_inputs_yml, test_case_inputs)
            self._create_config_yml(squish_common_config_yml, self.squish_config)
            self._create_config_yml(test_common_inputs_yml, test_case_inputs)
        except Exception as err:
            raise ResourceSquishError(err, traceback.format_exc(traceback.extract_stack()))

    @staticmethod
    def _create_config_yml(config_yml, config):
        _config = {'config': config}
        if not os.path.exists(os.path.split(config_yml)[0]):
            os.makedirs(os.path.split(config_yml)[0])
        with open(config_yml, 'w') as yaml_file_handle:
            yaml.dump(_config, yaml_file_handle, default_flow_style=False)

    @staticmethod
    def rawstring(input_string):
        """Returns a raw string representation of text"""
        escape_dict = {'\a': r'\a',
                       '\b': r'\b',
                       '\c': r'\c',
                       '\f': r'\f',
                       '\n': r'\n',
                       '\r': r'\r',
                       '\t': r'\t',
                       '\v': r'\v',
                       '\'': r'\'',
                       '\"': r'\"',
                       '\0': r'\000',
                       '\1': r'\001',
                       '\2': r'\002',
                       '\3': r'\003',
                       '\4': r'\004',
                       '\5': r'\005',
                       '\6': r'\006'}

        new_string = ''
        for char in input_string:
            try:
                new_string += escape_dict[char]
            except KeyError:
                new_string += char
        return new_string


if __name__ == '__main__':
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceSquishCli(ResourceSquish, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceSquish.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceSquish)

        RUN = ResourceSquishCli()
