#!/usr/bin/env python
"""
@brief
Utility for File transfer from Test head to test controller

@b Usage
@b Server Usage
@code
server = MyFtpServer()
# Run FTP server forever
server.run_server()
# Get ip address and port number of FTP Server
server.get_ftp_ip_and_port()
# Stop FTP server
server.stop_ftp_server()
@endcode

@b FTP Client Usage
@code
ftp_client = MyFTPClient(ftp_server_host, ftp_server_port)
ftp_client.download_file(filepath)
ftp_client.upload_file(filepath)
@endcode
"""
import os
import sys
import socket
import glob
import platform
import traceback

from pyftpdlib.authorizers import DummyAuthorizer
from pyftpdlib.handlers import FTPHandler
from pyftpdlib.servers import FTPServer
from threading import Thread
from ftplib import FTP, error_perm

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class ResourceFTPError(Exception):
    """ResourceFTPError exception class for ResourceFTP"""
    pass


class MyFtpServer(object):
    """
    FTP server implementation
    """
    def __init__(self):
        """
        Gets host name and unique unused port number and starts FTP server
        """
        self.log = logging.getLogger(MyFtpServer.__name__)
        self.server = None
        self.address = None
        self.handler = None
        self.server_thread = None
        self.home_directory = None

    def start_server(self, ip_address, user, password, working_dir):
        """
        Start Ftp server with username and password on provided working directory

        @param user: [str] username of ftp server
        @param password: [str] password of ftp server
        @param working_dir: [str] working directory of ftp server
        @param ip_address : IP address of host machine

        """
        if "Darwin" in platform.system():
            working_dir = working_dir.replace("\\", "/")
        self.home_directory = working_dir
        tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tcp.bind(('', 0))
        _, port = tcp.getsockname()
        tcp.close()
        self.address = (ip_address, port)
        authorizer = DummyAuthorizer()
        authorizer.add_user(str(user), str(password), working_dir, perm='elradfmw')
        self.handler = FTPHandler
        self.handler.authorizer = authorizer

        self.server = FTPServer(self.address, self.handler)
        self.server_thread = Thread(target=self.server.serve_forever)
        self.server_thread.start()

    def add_anonymous_user(self, home_directory):
        """
        Adding a anonymous user to FTP server started
        @param home_directory:  [str] home directory of anonymous user
        """
        if "Darwin" in platform.system():
            home_directory = home_directory.replace("\\", "/")
        self.handler.authorizer.add_anonymous(home_directory)

    def add_new_user(self, user, password, working_dir):
        """
        Add a new user to ftp server

        @param user: New user Username
        @param password: New user password
        @param working_dir: New user working directory
        """
        self.handler.authorizer.add_user(str(user), str(password), working_dir, perm='elradfmw')

    def stop_ftp_server(self):
        """
        Stop serving FTP service
        """
        self.server.close_all()

    def get_ftp_ip_and_port(self):
        """
        @return: FTP server host and port as tuple
        """
        return self.address

    def get_home_directory(self):
        """
        @return: home directory of FTP server
        """
        return self.home_directory

    @staticmethod
    def get_latest_file_in_path(path_of_files, file_prefix, file_extension):
        """
        Get latest file with prefix and extension from files path

        @param path_of_files:  [str] Directory in which file file exists
        @param file_prefix: [str] Prefix of file
        @param file_extension:[str] Extension file
        """
        files_with_extension = os.path.join(path_of_files, '%s*%s' % (file_prefix, file_extension))
        files_with_extension = glob.glob(files_with_extension)
        
        # If no files found return None
        latest_file = max(files_with_extension, key=os.path.getctime) if files_with_extension else None
        return latest_file


class MyFTPClient(object):
    """
    FTP Client Implementation
    """
    def __init__(self, host, port, user_name=None, password=None):
        """
        Creating an FTP Client
        @param host: Ip address of FTP server
        @param port: Port number of FTP Server
        """
        self.ftp = FTP('')
        self.ftp.connect(host, port)
        if user_name and password:
            self.ftp.login(user_name, str(password))
        else:
            self.ftp.login()

    def upload_file(self, filename):
        """
        Uploading a file to FTP server
        @param filename:
        @return:
        """
        self.ftp.storbinary('STOR ' + filename, open(filename, 'rb'))

    def check_for_file_on_server(self, download_filename, raise_error=True):
        """
        Checks if file is existing,raises an error if file is not existing
        @param download_filename: file name to be downloaded
        """
        file_exists = False
        self.ftp.sendcmd("TYPE i")
        try:
            self.ftp.size(download_filename)
            file_exists = True
        except error_perm:
            if raise_error:
                raise ResourceFTPError("%s file does not exists on FTP server,\n Stack trace: %s" % (
                    download_filename, self.get_stack_trace()))
        return file_exists

    def download_file(self, download_filename, file_name):
        """
        Downloading a file from ftp server.
        @param download_filename: Path of file must be relative with FTP server working directory path
        @param file_name : file name of download file
        """
        if "Darwin" in platform.system():
            file_name = file_name.replace("\\", "/")
        local_file = open(file_name, 'wb')
        if self.check_for_file_on_server(download_filename):
            self.ftp.retrbinary('RETR ' + download_filename, local_file.write, 1024)
        local_file.close()

    @staticmethod
    def get_stack_trace():
        """Provide the stack trace string"""
        return traceback.format_exc(traceback.extract_stack())


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class FtpServerCli(MyFtpServer, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                MyFtpServer.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, MyFtpServer)

        RUN = FtpServerCli()
