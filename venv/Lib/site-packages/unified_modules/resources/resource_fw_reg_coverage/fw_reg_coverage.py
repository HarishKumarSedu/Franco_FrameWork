"""
@brief
Generate FW register coverage Excel sheet

@b Usage
This module requires:-
1. latest IPX file(s) link from crystal site.
2. Jenkins jobs URL
"""
import re
import os
import sys
import requests
from getpass import getpass
from requests.auth import HTTPBasicAuth
from collections import OrderedDict

import xlsxwriter
from unified_modules.resources.resource_device_def_parser.resource_device_def_parser import ResourceDeviceDefParser
import unified_modules.test_support.testlogger as logging


class RegisterMapCoverageException(Exception):
    """
    RegisterMapCoverageException exception class
    """
    pass


class FwRegCoverage(object):
    """
    Class for FwRegCoverage
    """
    def __init__(self, username, password):
        self.covered_regs = dict()
        self.covered_bit_fields = set()
        self.reg_coverage_file = 'fw_reg_coverage.xlsx'
        self.device_xml_files_list = []
        self.jenkins_build_names = []
        self.workbook = None
        self.worksheet = None
        self.register_cell_format = None
        self.reg_dict = dict()
        self.reg_map_list = list()
        self.log = logging.getLogger()
        self.username = username
        self.password = password
        self.col_index_reg_name = 0
        self.col_index_reg_coverage = 1
        self.col_index_reg_value = 2
        self.col_index_bitfield_name = 3
        self.col_index_bitfield_coverage = 4
        self.reg_covered_string = ""
        self.reg_value = ""
        self.col_width_reg_name = 40
        self.col_width_reg_coverage = 12
        self.col_width_reg_value = 10
        self.col_width_bitfield_name = 40
        self.col_width_bitfield_coverage = 15

    def write_fw_registers(self, reg_dict=None):
        """
        Write Firmware registers
        :return:
        """
        # Set column widths and merge cells format
        self.merge_format = self.workbook.add_format({'align': 'top'})
        self.worksheet.col_sizes
        self.worksheet.set_column(self.col_index_reg_name, self.col_index_reg_name, self.col_width_reg_name)
        self.worksheet.set_column(self.col_index_reg_coverage, self.col_index_reg_coverage, self.col_width_reg_coverage)
        self.worksheet.set_column(self.col_index_reg_value, self.col_index_reg_value, self.col_width_reg_value)
        self.worksheet.set_column(self.col_index_bitfield_name, self.col_index_bitfield_name,
                                  self.col_width_bitfield_name)
        self.worksheet.set_column(self.col_index_bitfield_coverage, self.col_index_bitfield_coverage,
                                  self.col_width_bitfield_coverage)
        covered_bits = list()
        with open('register_bit_field_coverage.txt', 'r') as fh:
            covered_bits = fh.readlines()
            covered_bits = [bitfield.strip() for bitfield in covered_bits]
        row = 1
        # crystal file content
        for reg_name, reg_ob in list(reg_dict.items()):
            self.worksheet.write(row, self.col_index_reg_name, reg_name)
            if reg_name in covered_bits:
                self.reg_covered_string = "Y"
                self.reg_value = hex(int(self.covered_regs[reg_name]))
                # This write is required to compensate the merge warnings for single cell
                if len(reg_ob.BitFields) == 1:
                    self.worksheet.write(row, self.col_index_reg_value, self.reg_value)
            else:
                self.reg_covered_string = "N"
                self.reg_value = ""
            self.worksheet.write_column(row, self.col_index_reg_coverage, self.reg_covered_string)
            # Merge cells
            self.worksheet.merge_range(f"B{row + 1}:B{row + len(reg_ob.BitFields)}", self.reg_covered_string,
                                       self.merge_format)
            self.worksheet.merge_range(f"C{row + 1}:C{row + len(reg_ob.BitFields)}", self.reg_value, self.merge_format)

            if len(reg_ob.BitFields) > 1:
                bit_field_names = [bit_field.Name for bit_field in reg_ob.BitFields]
                _d = OrderedDict()
                for field_name in bit_field_names:
                    if field_name in covered_bits:
                        _d[field_name] = 'Y'
                    else:
                        _d[field_name] = 'N'
                self.worksheet.write_column(row, self.col_index_bitfield_name, bit_field_names)
                self.worksheet.write_column(row, self.col_index_bitfield_coverage, list(_d.values()))
                self.worksheet.merge_range("A%s:A%s" % (row + 1, row + len(bit_field_names)), reg_name,
                                           self.register_cell_format)
                row += len(bit_field_names)
            else:
                self.worksheet.write(row, self.col_index_bitfield_name, reg_ob.BitFields[0].Name)
                bit_field_names = [bit_field.Name for bit_field in reg_ob.BitFields]
                if bit_field_names[0] in covered_bits:
                    self.worksheet.write(row, self.col_index_bitfield_coverage, 'Y')
                else:
                    self.worksheet.write(row, self.col_index_bitfield_coverage, 'N')
                row += 1

    def res_dev_def_parser(self, path_to_device_xml):
        """
        :param path_to_device_xml: Device xml path
        :return:
        """
        # Parse device xml file
        res_parser = ResourceDeviceDefParser()
        if type(path_to_device_xml) is list:
            for ind, xml_path in enumerate(path_to_device_xml):
                res_parser.set_config_details(xml_path)
                res_parser.parse_dev_def_file()
                self.reg_map_list.append(os.path.basename(xml_path).split('.')[0])
                self.reg_dict[self.reg_map_list[ind]] = res_parser.get_register_class_dict()
        else:
            res_parser.set_config_details(path_to_device_xml)
            res_parser.parse_dev_def_file()

            self.reg_dict.update(res_parser.get_register_class_dict())

    def read_jenkins_logs(self, file_name):
        """
        Read jenkin logs
        :param file_name: File name
        :return:
        """
        with open(file_name) as file_handle:
            for line in file_handle:
                write_reg_match = re.search('Writing Register (.*), value (.*)', line)
                read_reg_match = re.search('Reading Register (.*), value (.*)', line)
                read_bit_match = re.search('Reading bitfield (.*),', line)
                write_bit_match = re.search('Writing bitfield (.*),', line)
                if write_reg_match:
                    self.covered_regs[write_reg_match.group(1)] = write_reg_match.group(2)
                elif read_reg_match:
                    self.covered_regs[read_reg_match.group(1)] = read_reg_match.group(2)
                elif read_bit_match:
                    self.covered_bit_fields.add(read_bit_match.group(1))
                elif write_bit_match:
                    self.covered_bit_fields.add(write_bit_match.group(1))

        with open('register_bit_field_coverage.txt', 'a') as fh:
            for reg_name in self.covered_regs:
                fh.write('%s\n' % reg_name)
            for bit_field_name in self.covered_bit_fields:
                fh.write('%s\n' % bit_field_name)
            self.log.info("Firmware register and bit-field coverage is generated for: %s" % (file_name))

    def create_reg_coverage(self):
        """
        Reg coverage
        :return:
        """
        # Create an Excel sheet
        self.workbook = xlsxwriter.Workbook(self.reg_coverage_file)
        for reg_map_worksheet in self.reg_map_list:
            self.worksheet = self.workbook.add_worksheet(reg_map_worksheet)
            self.register_cell_format = self.workbook.add_format({'align': 'left', 'valign': 'top'})
            # Populate Excel sheet with FW registers
            self.worksheet.write(0, self.col_index_reg_name, 'Register')
            self.worksheet.write(0, self.col_index_reg_coverage, 'Reg Coverage')
            self.worksheet.write(0, self.col_index_reg_value, 'Reg Value')
            self.worksheet.write(0, self.col_index_bitfield_name, 'Bit Fields')
            self.worksheet.write(0, self.col_index_bitfield_coverage, 'BitField Coverage')
            self.write_fw_registers(self.reg_dict[reg_map_worksheet])
        self.workbook.close()

    def process_response(self, resource, response):
        """
        Internal routine for processing responses from requests
        :param resource: Specify the resource
        :param response: Specify the response object from REST API call.

        :return:
        """
        if response.status_code == 200:
            return True
        if response.status_code == 401:
            raise RegisterMapCoverageException("Response code 401:User unauthorised. Check username/password")
        if response.status_code == 403:
            raise RegisterMapCoverageException("Response code 403:User Forbidden regardless of authorisation state")
        if response.status_code == 404:
            raise KeyError("Response code 404: Specified resource Not Found: {}".format(resource))

        self.log.info("Response status code: {}".format(response.status_code))
        raise RegisterMapCoverageException("Unknown/unhandled response: {}".format(str(sys.exc_info())))

    def file_download(self, url, file_name):
        """
        Download the specified URL .
        :param url: Specify the url
         :param url: Specify the file name

        :return:
        """
        response = requests.get(url, verify=False, stream=True, auth=HTTPBasicAuth(self.username, self.password))
        if self.process_response(url, response):
            with open(file_name, "wb") as fd:
                for chunk in response.iter_content(chunk_size=1024):
                    # writing one chunk at a time to file
                    if chunk:
                        fd.write(chunk)

    def get_latest_build(self, jenkins_job_url):
        """
        Get the latest build number from the specified Jenkins job
        :param jenkins_job_url: Specify the Jenkins job

        :return latest_build_number: Returns latest build number.
        """
        response = requests.get(jenkins_job_url + "/api/json?pretty=true", verify=False,
                                auth=HTTPBasicAuth(self.username, self.password))
        if self.process_response(jenkins_job_url, response):
            response_data = response.json()
            latest_build_number = response_data["builds"][0]["number"]
            return latest_build_number

    def download_device_xml(self, xml_list):
        """
        Download Device XML file(s) from Crystal
        :param xml_list: Device XML files list

        :return device_xml_files_list: Returns Device xml files.
        """
        for device_url in xml_list:
            device_url = device_url.rstrip('/')
            xml_file_name = os.path.basename(device_url)
            if xml_file_name.endswith('.xml'):
                self.device_xml_files_list.append(xml_file_name)
                self.file_download(device_url, xml_file_name)
            else:
                raise RegisterMapCoverageException("Looks like, missed the Device XML file name(s) "
                                                   "in specified UR: {}".format(device_url))
        return self.device_xml_files_list

    def download_jenkins_logs(self, builds):
        """
        Download Jenkins job logs
        :param builds: Jenkins builds list

        :return jenkins_build_names: Returns Jenkins build names
        """
        for build in builds:
            build_url = build.rstrip('/')
            base_string = os.path.basename(build_url)
            if base_string.isnumeric():
                build_number = base_string
                jenkins_job_path = os.path.dirname(build_url)
                jenkins_job_name = os.path.basename(jenkins_job_path)
                jenkins_url_resource = build_url + "/consoleText"
            else:
                jenkins_job_name = base_string
                build_number = self.get_latest_build(build_url)
                jenkins_url_resource = build_url + "/" + str(build_number) + "/consoleText"

            jenkins_file_name = jenkins_job_name + "_" + str(build_number) + ".text"
            self.file_download(jenkins_url_resource, jenkins_file_name)
            self.jenkins_build_names.append(jenkins_file_name)
        return self.jenkins_build_names

    def fw_reg_coverage(self, device_xml_list, jenkins_jobs):
        """
        FW Register Coverage
        :param device_xml_list: Device xml files list
        :param jenkins_jobs: Jenkins builds list

        :return:
        """
        reg_xmls = self.download_device_xml(device_xml_list)
        self.res_dev_def_parser(reg_xmls)

        jenkins_file_names = self.download_jenkins_logs(jenkins_jobs)
        for file_name in jenkins_file_names:
            self.read_jenkins_logs(file_name)
        self.create_reg_coverage()


if __name__ == "__main__":
    crystal_url1 = "http://crystal.cirrus.com/~fats/trunk/registers/latest/fats_mode00_external_regs_scs.xml"
    crystal_url2 = "http://crystal.cirrus.com/~fats/trunk/registers/latest/fats_mode11_external_regs_scs.xml"
    device_xml_files_list = [crystal_url1, crystal_url2]

    jenkins_url = "https://aus-jnkm-lin-08.ad.cirrus.com/job/Lynott_ST_EMU_A0/job/downstream_jobs/job/Lynott_ST_EMU_A0_Deployment/780"
    jenkins_build_jobs = [jenkins_url]

    try:
        jenkins_username = os.environ.get("JENKINS_USER")
    except KeyError:
        jenkins_username = input("Please enter your AD account user name: ")
    try:
        jenkins_password = os.environ.get("JENKINS_PASS")
    except KeyError:
        jenkins_password = getpass("Please enter your AD account password: ")
    reg_coverage = FwRegCoverage(jenkins_username, jenkins_password)
    reg_coverage.fw_reg_coverage(device_xml_files_list, jenkins_build_jobs)
