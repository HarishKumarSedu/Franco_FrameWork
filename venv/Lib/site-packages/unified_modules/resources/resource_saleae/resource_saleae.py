#!/usr/bin/env python
"""
@brief
A resource library to access and control the Saleae Logic [16] analyzer.

@Description:
This resource library provides a wrapper to the wrapper methods to access and the Saleae logic analyzer.
https://www.saleae.com/
Wrapper documentation: https://github.com/ppannuto/python-saleae

Supported features:
- Configure capture channel(s)
- Configure Logic Voltage Threshold
- Configure Sample Rate, record time
- Capture
- Process capture for UART

@b Usage
@code
logic_analyzer = ResourceSaleae()
logic_analyzer.set_config_details()
logic_analyzer.start_capture()
logic_analyzer.fetch_results_when_complete()
logic_analyzer.close_application()
@endcode
"""
import os
import socket
import subprocess
import sys
from time import sleep

import saleae

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class ResourceSaleaeError(Exception):
    """Define ResourceSaleaeLogicAnalyzerErrorError Exception type"""

    def __init__(self, message=None):
        super(ResourceSaleaeError, self).__init__(message)


class ResourceSaleae(object):
    """Class which encapsulates apis to deal with USB Saleae Logic [16] analyzer

            Saleae has 8 (or sometimes 16) channels, starting with 0
            Using the Python (high-level) saleae wrapper (pip install saleae)

     """

    def __init__(self):
        """
        Constructor
        """
        self.log = logging.getLogger(ResourceSaleae.__name__)
        self.socket_number = None  # tcp socket
        self.active_device_name = None
        self.data_export_dir = None  # Local path where captures will be saved
        self.saleae_handle = None  # saleae wrapper object
        return

    def set_config_details(self, tcp_socket=10429, digital_active_channels=[0],
                           analog_active_channels=[]):
        """
        This method is used to set config details for resource saleae logic analyzer
        active_channels/analog is a list of the physical channel numbers to capture
        """
        self.socket_number = tcp_socket
        self.enable_scripting_socket_server()
        self.saleae_handle = saleae.Saleae(port=self.socket_number)

        # Check for a connected Saleae
        try:
            self.saleae_handle.get_active_device()
        except NotImplementedError:
            self.log.error('Saleae not detected. Is there one connected?')
            raise ResourceSaleaeError('Saleae not detected.')

        self.active_device_name = self.saleae_handle.get_active_device().name
        self.set_voltage_level_1_8v()

        self.saleae_handle.set_active_channels(digital=digital_active_channels,
                                               analog=analog_active_channels)
        self.log.info('Saleae Initialized')
        return

    def set_voltage_level_1_8v(self):
        # sets the saleae for 1.8V digital operation
        # Configuring for 1.8V.
        if 'Pro' in self.active_device_name:
            # 0 for logic 16, 1 for 1.8V on Logic 16 pro.
            self.saleae_handle.set_digital_voltage_option(1)
        else:
            self.saleae_handle.set_digital_voltage_option(0)
        return

    def start_capture(self, capture_seconds=1):
        """Triggers a capture and returns immediately.
            Note: This just starts the capture, the data won't be ready until after the capture_time
            has elapsed."""

        self.saleae_handle.set_capture_seconds(capture_seconds)
        self.saleae_handle.capture_start()
        self.log.info('Saleae capture started')
        return

    def stop_capture(self):
        """Forces the end of a capture. Note: Captured data is still available"""
        data_captured_flag = self.saleae_handle.capture_stop()
        if data_captured_flag:
            self.log.info('Saleae capture stopped. Data Captured')
        else:
            self.log.info('Saleae capture stopped. No data Captured')
        return data_captured_flag

    def fetch_results_when_complete(self, export_data_filepath=None, analyzer_csv_filepath=None,
                                    capture_filepath=None, channel=0):
        """
        Saves the data from saleae to disk.
        The saleae SW saves 3 kinds of data: the raw data, the analyzer csv, and
        the Saleae logiccapture to disk (can be loaded into the saleae software)
        """
        complete_flag = self.saleae_handle.is_processing_complete()
        if not complete_flag:
            for i in range(100):  # Timeout condition
                sleep(.1)
                complete_flag = self.saleae_handle.is_processing_complete()
                if complete_flag:
                    break

        if export_data_filepath:
            if not export_data_filepath.endswith('.csv'):
                export_data_filepath = '{}.csv'.format(export_data_filepath)
            self.log.info('Saleae data export complete: {}'.format(export_data_filepath))
            self.saleae_handle.export_data2(export_data_filepath, digital_channels=[channel])
        if analyzer_csv_filepath:

            # Workaround because get_analyzers() API doesn't work correctly on the first call.
            analyzers = []
            try_count = 0
            while (not analyzers) and try_count < 5:  # buggy api, requires multiple tries.
                analyzers = self.saleae_handle.get_analyzers()
                if not analyzers:
                    sleep(.1)
                    self.log.info('Failed to retrieve analyzers from saleae on attempt {}'.format(
                        try_count + 1))
                    try_count += 1
                else:
                    self.log.info('Successfully retrieved saleae analyzer on attempt {}'.format(
                        try_count + 1))
            if not analyzers:
                self.log.error(
                    'Analyzer output requested but no analyzer is active. Must be done manually')
            else:
                if not analyzer_csv_filepath.endswith('.csv'):
                    analyzer_csv_filepath = '{}.csv'.format(analyzer_csv_filepath)

                self.saleae_handle.export_analyzer(analyzers[channel][1], analyzer_csv_filepath)

        if capture_filepath:
            if not capture_filepath.endswith('.logicdata'):
                capture_filepath = '{}.logicdata'.format(capture_filepath)
            self.log.info('Saleae capture save complete: {}'.format(capture_filepath))
            self.saleae_handle.save_to_file(capture_filepath)
        return

    def set_num_samples(self, samples):
        """
        Set the capture duration to a specific number of samples
        :param samples: Number of samples to capture (int)
        :return:
        """
        self.saleae_handle.set_num_samples(samples)

    def set_sample_rate(self, digital_sample_rate, analog_sample_rate):
        """
        Set the sample rate. Consider any sample rates from "get_supported_sample_rates" method
        :param digital_sample_rate: digital_sample_rate
        :param analog_sample_rate: analog_sample_rate
        :return:
        """
        self.saleae_handle.set_sample_rate((digital_sample_rate, analog_sample_rate))

    def get_supported_sample_rates(self):
        """
        Get available sample rate combinations for the current performance level and channel
        combinations
        :return: list of tuples. Each tuple is of format (<digital_sample_rate>, <analog_sample_rate>)
        """
        return self.saleae_handle.get_all_sample_rates()

    @staticmethod
    def close_application():
        """
        Close Saleae logic GUI instances
        """
        subprocess.call(["taskkill", "/F", "/IM", "Logic.exe"], shell=True)

    def enable_scripting_socket_server(self):
        """
        Enables scripting socket server
        """
        process = os.path.join("C:", os.sep, "Program Files", "Saleae Inc", "Logic.exe")
        if not os.path.exists(process):
            process = os.path.join("C:", os.sep, "Program Files", "Saleae LLC", "Logic.exe")
        os.startfile(process)
        # Wait for Saleae GUI to open
        sleep(3)
        if not self.connect_to_port(retries=3):
            self.log.info(
                "Closing existing Saleae instance and retrying by enabling scripting socket server")
            self.close_application()
            sleep(3)
            self.close_application()
            # Wait for Saleae GUI to close
            sleep(1)
            subprocess.Popen([process, '-socket'], shell=True)
            self.connect_to_port()

    def connect_to_port(self, retries=10):
        """
        Check if Saleae is running on given port number
        """
        sleep(5)
        connected = False
        for retry_count in range(retries):
            try:
                _s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                _s.connect(("localhost", self.socket_number))
                self.log.info("Connected to Port: {}".format(self.socket_number))
                _s.close()
                connected = True
                break
            except Exception as e:
                self.log.warning("Retry: %s, Exception: %s" % (retry_count + 1, e))
        return connected


class ResourceSaleaeDummy(ResourceSaleae):
    """ This serves as a sub-class of Saleae, but that does no actions.
    Can be inherited for when no captures are desired"""

    def set_config_details(self, **kwargs):
        pass

    def start_capture(self, capture_seconds=1):
        pass

    def stop_capture(self):
        pass

    def fetch_results_when_complete(self, export_data_filepath=None, analyzer_csv_filepath=None,
                                    capture_filepath=None):
        """Create a Dummy file"""
        f = open(export_data_filepath, 'w')
        f.write('Saleae Bypass!')
        f.close()

    def enable_scripting_socket_server(self):
        pass

    def set_voltage_level_1_8v(self):
        pass


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support


        class ResourceSaleaeLogicAnalyzerErrorCli(ResourceSaleaeError,
                                                  cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self):
                ResourceSaleaeError.__init__(self)
                cli_support.CliOptions.__init__(self, ResourceSaleaeError)


        # RUN = ResourceSaleaeLogicAnalyzerErrorCli()
        test_saleae = ResourceSaleae()
        test_saleae.set_config_details(digital_active_channels=[0])
        test_saleae.start_capture(1, "C:\\testing\saleae_temp\\1")
        test_saleae.fetch_results_when_complete("C:\\testing\saleae_temp\\2",
                                                "C:\\testing\saleae_temp\\3")
        test_saleae.close_application()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest


        class ResourceSaleaeErrorUnitTests(BaseTest):
            def __init__(self, result):
                super(ResourceSaleaeErrorUnitTests, self).__init__(result=result)
                self.saleae = None

            def setup(self):
                self.saleae = ResourceSaleae()
                self.saleae.set_config_details()

            def initiate(self):
                assert isinstance(self.saleae, ResourceSaleae)
                self.saleae.start_capture(capture_seconds=1)
                sleep(1)
                self.saleae.stop_capture()
                self.saleae.fetch_results_when_complete(
                    export_data_filepath=os.path.join(os.getcwd(), 'data'),
                    capture_filepath=os.path.join(os.getcwd(), 'capture'))

            def complete(self):
                pass

            def teardown(self):
                self.saleae.close_application()

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceSaleaeErrorUnitTests(result=RESULTS)
        TEST.run()
