"""
Resource Library for Numato relay
"""
import platform
import serial
import re
import serial.tools.list_ports
import sys

from collections import namedtuple

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

# Named tuple for relay state
RelayStateType = namedtuple('RelayStates', 'ON OFF')
RelayState = RelayStateType('on', 'off')

# Named tuple for relay operations
_RelayOperations = namedtuple('RelayOperations', 'READ WRITE RESET_ALL')
RelayOperations = _RelayOperations('read', 'write', 'resetall')


class ResourceNumatoRelayException(Exception):
    """Exception class for ResourceNumatoRelay"""
    pass


class ResourceNumatoRelay:
    """
    Resource Library for Numato relay
    """
    def __init__(self):
        self.log = logging.getLogger(self.__class__.__name__)
        self.config = None
        self.com_port = None
        self.ser_port = None
        self.baud_rate = 19200
        self.timeout = None
        os_platform = platform.system()
        if os_platform != "Windows":
            raise ResourceNumatoRelayException('Not Supported for %s platform' % os_platform)

    def set_config_details(self, config):
        self.config = config
        self.com_port = config['com_port']

    def read(self, channel_id, timeout=1):
        """
        Read state of a relay channel
        @param channel_id: Relay channel id
        @return: state of relay channel
        """
        # Open port for communication
        self.ser_port = serial.Serial(self.com_port, self.baud_rate, timeout=timeout)
        state = ''
        command = "relay read " + str(channel_id) + "\n\r"
        self.ser_port.write(command.encode())
        response_max_size = len(command) + len(RelayState.OFF + ' ')
        response =self.ser_port.read(response_max_size).decode()
        if response.find(RelayState.ON) > 0:
            state = RelayState.ON
        elif response.find(RelayState.OFF) > 0:
            state = RelayState.OFF
        # Close the port
        self.ser_port.close()
        return state

    def write(self, channel_id, state, timeout=1):
        """
        Set relay channel to ON/OFF state
        @param channel_id: Relay channel
        @param state: relay state
        """
        # Open port for communication
        self.ser_port = serial.Serial(self.com_port, self.baud_rate, timeout=timeout)

        command = ' '.join(['relay', state, str(channel_id) + '\n\r'])
        _command = re.sub('\n\r', '', command)
        self.log.info("Setting relay channel: %s to state: %s", _command, state)
        self.ser_port.write(command.encode())
        # Close the port
        self.ser_port.close()

    def read_channels(self, channel_ids, timeout=1):
        """
        Read states of multiple channels

        @param channel_ids: [list] list of channel ids
        @param timeout: [int] timeout for relay operation in seconds
        return: [dict] Returns dictionary with key as channel id and value as it state
        """
        ch_states = {}
        for ch_id in channel_ids:
            ch_states[ch_id] = self.read(ch_id, timeout)
        return ch_states

    def write_to_channels(self, channel_ids_and_states, timeout=1):
        """
        Set multiple channels with certain state

        @param channel_ids_and_states: [dict] Dictionary with key as channel id and value as its state
        @param timeout: [int] timeout for relay operation in seconds
        """
        for ch_id, ch_state in channel_ids_and_states.items():
            self.write(ch_id, ch_state, timeout)

    def resetall(self, timeout=1):
        """
        Set all relay channels to OFF state
        """
        # Open port for communication
        self.ser_port = serial.Serial(self.com_port, self.baud_rate, timeout=timeout)
        self.log.info("Command: reset is executed")
        command = "reset \n\r"
        self.ser_port.write(command.encode())
        # Close the port
        self.ser_port.close()

    def perform_operation(self, relay_operation, relay_num="0", relay_state=RelayState.OFF):
        """
        Performs READ,WRITE,RESET ALL on relay channel id

        @param relay_operation: It can be 'READ','WRITE','RESET ALL'
        @param relay_num: relay channel id
        @param relay_state: Optional relay channel state,only required for relay write operation
        @return: relay channel state
        """
        cur_relay_state = None
        if relay_operation == RelayOperations.READ:
            cur_relay_state = self.read(relay_num)
            self.log.info('Operation: %s is performed on relay channel %s', relay_operation, relay_num)
            self.log.info("Relay channel: %s, state: %s" % (relay_num, cur_relay_state))
        elif relay_operation == RelayOperations.WRITE:
            self.write(relay_num, relay_state)
            self.log.info('Operation: %s is performed on relay channel %s', relay_operation, relay_num)
            cur_relay_state = self.read(relay_num)
            self.log.info("Relay channel: %s, state: %s" % (relay_num, cur_relay_state))
        elif relay_operation == RelayOperations.RESET_ALL:
            self.resetall()
        else:
            raise ResourceNumatoRelayException('Invalid operation: %s given' % relay_operation)
        return cur_relay_state


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceNumatoRelayCli(ResourceNumatoRelay, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceNumatoRelay.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceNumatoRelay)

        RUN = ResourceNumatoRelayCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest


        class ResourceNumatoRelayUnittests(BaseTest):
            def __init__(self, result):
                super(ResourceNumatoRelayUnittests, self).__init__(result)
                self.numato_relay = ResourceNumatoRelay()
                self.channel_ids = ["0", "1", "2", "3"]

            def setup(self):
                self.record_test_name()
                self.config = {'com_port': 'COM6'}
                self.numato_relay.set_config_details(self.config)

            def test_read(self, channel_no):
                self.result.assert_equal(self.numato_relay.read(channel_no),
                                         RelayState.OFF,
                                         "Reading state of channel: %s" % channel_no)

            def test_write(self, channel_no, channel_state):
                self.numato_relay.write(channel_no, channel_state)
                self.result.assert_equal(self.numato_relay.read(channel_no),
                                         channel_state,
                                         "Set channel:%s to state: %s" % (channel_no, channel_state))

            def test_perform_operation(self, channel_num, operation, channel_state, assert_message):
                _channel_state = self.numato_relay.perform_operation(operation,
                                                                     channel_num)
                self.result.assert_equal(channel_state, _channel_state,
                                         assert_message)

            def test_read_channels(self, channel_ids):
                ch_states = self.numato_relay.read_channels(channel_ids)
                self.result.assert_equal(list(ch_states.values()), [RelayState.OFF] * len(ch_states),
                                         "Read multiple channels: %s" % ", ".join(ch_states))

            def test_write_channels(self, channel_ids_states):
                self.numato_relay.write_to_channels(channel_ids_states)
                _ch_ids_states = self.numato_relay.read_channels(list(channel_ids_states.keys()))
                self.result.assert_equal(list(_ch_ids_states.values()), list(channel_ids_states.values()),
                                         "Writing to multiple channels: %s" % ", ".join(
                                             list(channel_ids_states.keys())))

            def test_resetall(self):
                self.numato_relay.resetall()
                expected_states = [RelayState.OFF] * len(self.channel_ids)
                current_state = []
                for ch_id in self.channel_ids:
                    current_state.append(self.numato_relay.read(ch_id))
                self.result.assert_equal(expected_states, current_state,
                                         "Check for reset all")

            def initiate(self):
                self.test_resetall()
                self.test_read(self.channel_ids[1])
                self.test_write(self.channel_ids[1], RelayState.ON)
                self.test_perform_operation(self.channel_ids[1], RelayOperations.WRITE, RelayState.OFF,
                                            "Set channel:%s to state: %s" % (self.channel_ids[1], RelayState.OFF))
                self.test_perform_operation(self.channel_ids[2], RelayOperations.READ, RelayState.OFF,
                                            "Reading state of channel: %s" % self.channel_ids[2])
                channel_ids = ["1", "2", "0"]
                self.test_read_channels(channel_ids)
                channel_ids_states = {"1": RelayState.ON,
                                      "2": RelayState.OFF,
                                      "0": RelayState.ON}
                self.test_write_channels(channel_ids_states)
                self.test_resetall()

            def complete(self):
                self.result.assert_equal("PPPPPPPP : PASS",
                                         "%s : %s" % (self.result.step_outcome(),
                                                      self.result.get_overall_outcome()),
                                         "Expected Pass")

            def teardown(self):
                self.result.report_result_to_tf()

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceNumatoRelayUnittests(result=RESULTS)
        TEST.run()
