#!/usr/bin/env python
"""
@brief
A resource library to interact with ACRONAME USB Type-C Switch

@Description:
This resource library provides wrapper methods to perform operations using ACRONAME
Usb switch

Supported features:
- Check if device is connected to usb switch
- Turn ON a port (i.e Enable an OS platform)
- Turn OFF a port (i.e Disable an OS platform)
- Reset a port(First disables the port and then Enables it)
- Connect device to a port
- Disconnect USB Switch
- Reconnect USB Switch

@b Usage
@code
usb_switch = ResourceUsbSwitch()
@endcode
"""
import os
import sys
import brainstem

from time import sleep
from brainstem.result import Result
from collections import namedtuple

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


UsbSwitchSetup = namedtuple('UsbSwitchSetup', ['win7', 'win10', 'mac_high_sierra', 'mac_mojave'])

# For a reference about the error codes go here:  https://acroname.com/reference/_modules/brainstem/result.html
ERROR_DESCRIPTION = {
    0: 'No Error occurred',
    1: 'Memory allocation/de-allocation error',
    2: 'Invalid parameters given',
    3: 'Entity, module or information not found',
    4: 'File name is to long',
    5: 'Module or resource is currently busy',
    6: 'An Input/Output error occurred',
    7: 'Invalid Mode or mode not accessible for current state',
    8: 'Write error occurred',
    9: 'Read error occurred',
    10: 'Unexpected end of file encountered',
    11: 'Resource not ready',
    12: 'Insufficient permissions',
    13: 'Request is outside of valid range',
    14: 'Size is incorrect for resource',
    15: 'Buffer was overrun or will be',
    16: 'Unable to parse command',
    17: 'Configuration is invalid',
    18: 'Timeout occurred',
    19: 'Could not initialize resource',
    20: 'Version mismatch',
    21: 'Functionality unavailable or unimplemented',
    22: 'Duplicate request received',
    23: 'Request was canceled',
    24: 'packet was invalid or had invalid contents',
    25: 'connection is no longer valid, or was closed',
    26: 'Requested entity does not exist',
    27: 'Command to short, not enough data to parse',
    28: 'Entity is not available, or does not exist',
    29: 'Option for given entity is invalid',
    30: 'Error allocating or acquiring a resource',
    31: 'Media not found or not available',
    32: 'Unknown error encountered'
}

class ResourceUsbSwitchError(Exception):
    """Define ResourceUsbSwitchError Exception type"""
    pass


class ResourceUsbSwitch(object):
    """Class which encapsulates apis to interact with Acroname USB Type-C Switch """
    def __init__(self):
        """
        Constructor which sets the channel 0 as default channel for the switch.
        """
        self.log = logging.getLogger(ResourceUsbSwitch.__name__)
        self.switch_outputs = None
        self.common_port = 0
        self._retries = 5
        self._timeout = 2
        try:
            self.usbc_switch = brainstem.stem.USBCSwitch()
            self.stem = brainstem.stem.USBStem()
            self.mux = brainstem.stem.Mux(self.stem, 0)
            self.stem.discoverAndConnect(brainstem.link.Spec.USB)
            self.mux.setChannel(0)
        except Exception as e:
            raise ResourceUsbSwitchError("Error! ACRONAME is not working as expected : %s." % e)

    def set_retries_timeout(self, retries=10, timeout=1):
        self._retries=retries
        self._timeout=timeout

    def _call_acroname_function(self, acroname_function,*args):
        """
        This is a template function to handle and retry calls to acroname API functions
        @param acroname_function: The function to call
        @param args: The parameters for the given function
        @return: The result error code.
        """

        retries = self._retries
        result = acroname_function(*args)
        while result != Result.NO_ERROR and retries >0:
            self.log.warning("Error: %s, retries left: %d" %(result,retries))
            retries -= 1
            sleep(self._timeout)
            result = acroname_function(*args)

        return result

    def _set_port_enable(self):
        """
        This method tries to enable the common port.
        @return: If call fails it will raise a ResourceUsbSwitchError Exception
        """

        result =  self._call_acroname_function(self.usbc_switch.usb.setPortEnable, self.common_port)
        if result != Result.NO_ERROR:
            raise ResourceUsbSwitchError("Port %s not enabled, error code: %s " % (self.common_port, ERROR_DESCRIPTION[result]))


    def _set_port_disable(self):
        """
        This method tries to disable the common port.
        @return: If call fails it will raise a ResourceUsbSwitchError Exception
        """

        result =  self._call_acroname_function(self.usbc_switch.usb.setPortDisable, self.common_port)
        if result != Result.NO_ERROR:
            raise ResourceUsbSwitchError("Port %s not disabled, error code: %s " % (self.common_port, ERROR_DESCRIPTION[result]))


    def _discover_and_connect(self, transport = brainstem.link.Spec.USB):
        """
        This method will try to connect to the first available BrainStem found on the given transport
        and will try to create a link to the first link module found on the specified transport.
        @param: transport to create the connection
        @return: True if call is successful, otherwise it will raise a ResourceUsbSwitchError Exception
        """

        result = self._call_acroname_function( self.usbc_switch.discoverAndConnect, transport)
        if result != Result.NO_ERROR:
            raise ResourceUsbSwitchError("Failed to discover and connect, error %s " % ERROR_DESCRIPTION[result])
        return True

    def _get_port_current(self):
        """
        This method tries to get the current from the common port
        @return: True if there is a valid value,  otherwise it will raise a ResourceUsbSwitchError Exception
        """

        current = self.usbc_switch.usb.getPortCurrent(self.common_port)
        if current.value != 0:
            self.log.info("Device is using " + str(current.value) + " microAmp.")
            return True
        else:
            raise ResourceUsbSwitchError("There is no device connected to port %s" % self.common_port)

    def turn_on_port(self):
        """
        This method turns ON the device connected to ACRONAME USB Hub

        Usage:
        ResourceUsbSwitchObj = ResourceUsbSwitch()
        ResourceUsbSwitchObj.turn_on_port()
        """
        if self._discover_and_connect():
            self._set_port_enable()
            self._get_port_current()

    def turn_off_port(self):
        """
        This method turns OFF the device connected to ACRONAME USB Hub

        Usage:
        ResourceUsbSwitchObj = ResourceUsbSwitch()
        ResourceUsbSwitchObj.turn_off_port()
        """
        if self._discover_and_connect():
            self._set_port_disable()

    def reset_port(self, sleep_time=5):
        """
        This method resets the device connected to ACRONAME USB Hub
        @param sleep_time [int] time between turning OFF the board and turning ON the board
        @return [bool] True or False

        Usage:
        ResourceUsbSwitchObj = ResourceUsbSwitch()
        ResourceUsbSwitchObj.reset_port()
        """
        if self._discover_and_connect():
            self._set_port_disable()
            sleep(sleep_time)
            self._set_port_enable()

    def set_switch_outputs(self, switch_setup):
        """Logs the USb switching"""
        self.switch_outputs = switch_setup
        self.log.info("USB switch setup:%s", self.switch_outputs)

    def connect_to_host(self, os_port):
        """
        Connect the board to the given machine.
        @param os_port: os_port - machine os name that the hardware needs to be connected
        through switch.
        """
        self.log.info("Connecting DUT to %s host.." % os_port)
        try:
            self.mux.setChannel(self.switch_outputs.__dict__[os_port])
        except Exception as e:
            raise ResourceUsbSwitchError("Error! ACRONAME is not working as expected : %s." % e)

    def disconnect_switch(self):
        """Disconnects the USB Switch"""
        try:
            self.stem.disconnect()
        except Exception as e:
            raise ResourceUsbSwitchError("Error with disconnect ACRONAME : %s" % e)

    def reconnect_switch(self):
        """Reconnects the USB Switch"""
        try:
            self.stem.reconnect()
        except Exception as e:
            raise ResourceUsbSwitchError("Error with reconnect ACRONAME : %s" % e)

    def get_voltage(self, os_port):
        """
        Gets the voltage
        :param os_port: os name
        :return: voltage in V (float)
        """
        self.log.info("Connecting USB switch to %s" % os_port)
        self.mux.setChannel(self.switch_outputs.__dict__[os_port])

        voltage = abs(self.mux.getVoltage(0).value)
        string_voltage = str(voltage)
        voltage = float('.'.join([string_voltage[0], string_voltage[1:]]))
        self.log.info("Voltage: %.2fV" % voltage)
        return voltage

    def get_current(self, os_port):
        """
        Gets the Current

        :param os_port: os name
        :return: current in mA (float)
        """
        self.log.info("Connecting USB switch to %s" % os_port)
        self.mux.setChannel(self.switch_outputs.__dict__[os_port])

        current = abs(self.port.getPortCurrent(0).value)
        string_current = '0.0' + str(current)
        current = float(string_current) * 1000
        self.log.info("Current: %.2fmA" % current)
        return current


if __name__ == "__main__":
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceUsbSwitchCli(ResourceUsbSwitch, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""
            def __init__(self, *args, **kwargs):
                ResourceUsbSwitchCli.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceUsbSwitch)

        RUN = ResourceUsbSwitchCli()
    else:
        from unified_modules.test_support.testbaseclass import BaseTest

        class ResourceUsbSwitchUnitTests(BaseTest):
            """
            Unit test for ACRONAME USB Switch
            """
            def __init__(self, test_results):
                super(ResourceUsbSwitchUnitTests, self).__init__(test_results)
                self.usb_switch = None
                self.usb_switch_setup = None

            def setup(self):
                """
                Creating USB switch object and set the port numbers of different OS platforms
                """
                self.usb_switch = ResourceUsbSwitch()
                self.usb_switch_setup = UsbSwitchSetup(win7=0, win10=1, mac_high_sierra=2, mac_mojave=3)
                self.usb_switch.set_switch_outputs(self.usb_switch_setup)

            def initiate(self):
                """
                Connecting DUT to different OS platforms one after other
                """
                self.usb_switch.reset_port(sleep_time=2)
                self.usb_switch.connect_to_host('win7')
                self.usb_switch.reset_port(sleep_time=2)
                self.usb_switch.connect_to_host('win10')
                self.usb_switch.reset_port(sleep_time=2)
                self.usb_switch.connect_to_host('mac_high_sierra')
                self.usb_switch.reset_port(sleep_time=2)
                self.usb_switch.connect_to_host('mac_mojave')

            def complete(self):
                """
                Disconnecting DUT with USB switch
                """
                self.usb_switch.disconnect_switch()

            def teardown(self):
                pass

        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceUsbSwitchUnitTests(RESULTS)
        TEST.run()
