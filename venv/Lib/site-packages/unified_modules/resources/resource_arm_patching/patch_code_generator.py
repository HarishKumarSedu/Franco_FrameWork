"""
Supporting Module to generate a Patch Code binary
"""
import os
import json

# UM Core imports
import unified_modules.test_support.testutils as file_lib

# UM Resources imports
from unified_modules.resources.resource_arm_patching.c_header_files_parser \
    import CHeaderFilesParser as CHeaderParser


# Constants
PATCHABLE_FUNCS_EXCLUDE_LIST = [
    'mode_mgr_g_wdog_pet',
    'patch_hdr_t_apply_patch_ptr',
    'patcher_g_init',
    'patcher_g_detect',
    'patcher_g_is_dwnld_cmpt_blocking',
    'patcher_g_is_dwnld_cmpt_nonblocking',
    'patcher_g_verify',
    'patcher_g_apply',
    'patcher_g_post_apply'
]

BUILT_IN_DATA_TYPES = [
    'void',
    'bool',
    'uint8_t',
    'uint16_t',
    'uint32_t',
    'float',
    'long',
    'short',
    'const',
    'float_32',
    'int'
]
# Constants
SIGNATURE = 0x89ABCDEF
PATCH_SIG_INDEX = 0
# Signature increment is to update the signature to a new value
SIGNATURE_INCREMENT = 0x01

signature = hex(SIGNATURE)
signature = signature.rstrip('L')

WATCH_DOG_FUNC_HEADER = """
void mode_mgr_g_wdog_pet()
{{
    // Signature to Identify this patched function
    uint32_t signature = {signature};
    uint32_t index = {patch_sig_buff_index};
    // Place Signature word in RAM
    write_signature_to_ram(index, signature);

    // Call the next patchable function from the symbol table or from reference list created.

""".format(signature=signature, patch_sig_buff_index=PATCH_SIG_INDEX)

APPLY_FUNC_HEADER = """
void apply_patch(void)
{
    debug_printf(\"Executing apply_patch()!\\n\");
    // @revisit update jump tables and/or other global symbols here
    // as appropriate.
    mode_mgr_g->wdog_pet = &mode_mgr_g_wdog_pet;
"""

PATCH_FUNC_BODY = """
{
    // Place Signature word in RAM
    uint32_t signature = {function_signature};
    uint32_t index = {patch_sig_buff_index};
    write_signature_to_ram(index, signature);
}
"""

WATCH_DOG_FUNC_FOOTER = """
        //infinite loop
        while(1);
}
"""


class PatchCodeGen(object):
    def __init__(self):
        pass

    @staticmethod
    def generate_patch_file_template(header=''):
        """This function returns the patch file template."""
        template = ''
        current_dir = os.path.dirname(__file__)
        template_header_path = os.path.join(current_dir, 'patch_code_template_header.txt')
        template_body_path = os.path.join(current_dir, 'patch_code_template_body.txt')
        template += file_lib.read_from_file(template_header_path)
        template += header
        template += file_lib.read_from_file(template_body_path)
        return template

    @staticmethod
    def generate_new_patch_funcs_list(patchable_funcs_list):
        """Generate new patch functions list."""
        patch_functions = []
        for patchable_fun in patchable_funcs_list:
            patch_function_info = dict()
            patch_function_info['old_fn_name'] = patchable_fun['fn_name']
            patch_function_info['fn_name'] = "%s_%s" % (patchable_fun['st_name'], patchable_fun['fn_name'])
            patch_function_info['st_name'] = patchable_fun['st_name']
            patch_function_info['fn_type'] = patchable_fun['fn_type']
            patch_function_info['params'] = patchable_fun['params']
            patch_functions.append(patch_function_info)
        # removed the excluded functions from the list
        patch_functions = PatchCodeGen.exclude_patch_functions(patch_functions)
        return patch_functions

    @staticmethod
    def generate_apply_patch_func(patch_funcs):
        """This function generates apply patch function."""
        table_entries = []
        patch_function_footer = "}\n"
        # Append function header
        patch_function = APPLY_FUNC_HEADER
        patch_function.join("\n")

        # Add patchable functions
        for patch_fun in patch_funcs:
            patch_entry = "\t%s->%s = &%s;\n" % (patch_fun['st_name'],
                                                 patch_fun['old_fn_name'],
                                                 patch_fun['fn_name'])
            table_entries.append(patch_entry)
            patch_function += patch_entry
        # Append function footer
        patch_function += patch_function_footer
        return patch_function

    @staticmethod
    def generate_patch_funcs(patch_funcs):
        """This function generates patch functions."""
        patch_function = "\n"
        signature = SIGNATURE
        index = PATCH_SIG_INDEX
        functions_signature_list = []
        for patch_fun in patch_funcs:
            signature += SIGNATURE_INCREMENT
            index += 1
            signature_string = PatchCodeGen.get_signature_string(signature)
            patch_fun['params'] = PatchCodeGen.check_params(patch_fun['params'])
            patch_function_header = "%s %s(%s)" % (patch_fun['fn_type'],
                                                   patch_fun['fn_name'],
                                                   patch_fun['params'])
            patch_function += patch_function_header
            patch_function += PATCH_FUNC_BODY.replace('{function_signature}', signature_string)
            patch_function = patch_function.replace('{patch_sig_buff_index}', str(index))
            patch_function += "\n"
            functions_signature_list.append({'function_name': patch_fun['fn_name'],
                                             'signature': signature_string})
        return patch_function, functions_signature_list

    @staticmethod
    def generate_watch_dog_func(patch_funcs):
        """This function generates watch dog function."""
        functions_signature_list = []
        patch_function = WATCH_DOG_FUNC_HEADER
        signature = PatchCodeGen.get_signature_string(SIGNATURE)
        functions_signature_list.append({'function_name': 'mode_mgr_g_wdog_pet',
                                         'signature': signature})
        watch_dog_func_body = ""

        for patch_fun in patch_funcs:
            params = PatchCodeGen.generate_func_params(patch_fun)
            param_list = ','.join(params)
            watch_dog_func_body += "\t%s->%s(%s);\n" % (patch_fun['st_name'],
                                                        patch_fun['old_fn_name'],
                                                        param_list)
        patch_function += watch_dog_func_body
        patch_function += WATCH_DOG_FUNC_FOOTER
        return patch_function, functions_signature_list

    @staticmethod
    def check_params(params):
        new_param_list = []
        params = params.split(",")
        variable_index = 0
        for param in params:
            param_list = param.strip().split(" ")
            if len(param_list) == 1 and param == "void":
                param = ''
            elif param_list[-1] == '*':
                variable_index += 1
                param_list[-1] = ('*x{}'.format(variable_index))
                param = ' '.join(param_list)
            elif PatchCodeGen.is_a_builtin_data_type(param_list[-1]) or len(param_list) == 1:
                variable_index += 1
                param_list.append('x{}'.format(variable_index))
                param = ' '.join(param_list)
            new_param_list.append(param)
        new_params = ','.join(new_param_list)
        return new_params

    @staticmethod
    def is_a_builtin_data_type(param):
        return True if param.strip() in BUILT_IN_DATA_TYPES else False

    @staticmethod
    def convert_to_built_in_data_types(param):
        """This method type cast the to default data types."""
        if param == 'void':
            new_param = 'void'
        else:
            new_param = "(%s)0x01" % param
        return new_param

    @staticmethod
    def convert_to_pointer_data_types(param):
        """This method type cast to pointer data types."""
        split_param = param.split('*')
        new_param = None
        # extract the data type and type cast the
        if split_param[0].strip() in BUILT_IN_DATA_TYPES:
            new_param = "(%s *)0x01" % (split_param[0].strip())
        elif split_param[0].strip() not in BUILT_IN_DATA_TYPES:
            new_param = "(%s *)0x02" % (split_param[0].strip())
        return new_param

    @staticmethod
    def convert_to_derived_data_types(param):
        """This method type cast to derived data types."""
        split_param = param.split(' ')
        if split_param[0].strip() == 'const':
            new_param = "(%s %s)0x03" % (split_param[0].strip(), split_param[1].strip())
        elif split_param[0].strip() not in BUILT_IN_DATA_TYPES:
            # extract the data type and type cast the
            new_param = "(%s)0x03" % (split_param[0].strip())
        else:
            new_param = "(%s)0x00" % (split_param[0].strip())
        return new_param

    @staticmethod
    def generate_func_params(patch_func):
        """construct function parameters from the given list."""
        params = patch_func['params'].split(',')
        new_params_list = []

        if len(params) == 1 and params[0].strip() == 'void':
            return new_params_list

        for param in params:
            param = param.strip()
            # if param is a buit-in data type pointer, type cast and return it
            if param in BUILT_IN_DATA_TYPES:
                new_param = PatchCodeGen.convert_to_built_in_data_types(param)
            # if it is a pointer to built-in or derived data type
            elif '*' in param:
                new_param = PatchCodeGen.convert_to_pointer_data_types(param)
            # if it is a derived data type
            else:
                new_param = PatchCodeGen.convert_to_derived_data_types(param)

            if new_param != '':
                new_params_list.append(new_param)
        return new_params_list

    @staticmethod
    def exclude_patch_functions(patch_funcs_list):
        """Exclude the patch functions."""
        updated_patch_funcs_list = []
        for ex_patch in patch_funcs_list:
            if ex_patch['fn_name'] in PATCHABLE_FUNCS_EXCLUDE_LIST:
                continue
            if ex_patch['st_name'] == 'mode_mgr_g_wdog_pet':
                continue
            else:
                updated_patch_funcs_list.append(ex_patch)
        return updated_patch_funcs_list

    @staticmethod
    def generate_template_header(header_file_names):
        """generate code to include header file name."""
        template_header = ""
        for head_file in header_file_names:
            template_header += "\n#include \"%s\"" % head_file
        return template_header

    @staticmethod
    def generate_patch_file_from_source(firmware_code_dir_path, output_file_path):
        """
        This method generates the patch file from the Firmware code

        :param firmware_code_dir_paths: Path to FW code
        :param output_file_path: Output patch file path
        :return: no return
        """
        PatchCodeGen.generate_patches_with_nfunctions_in_a_file(firmware_code_dir_path, output_file_path,
                                                   functions_per_patch_file=None)

    @staticmethod
    def generate_patches_with_nfunctions_in_a_file(firmware_code_dir_path, output_file_path,
                                                   functions_per_patch_file=None):
        """
         This method generates the patch file with # functions from the Firmware code. If more than 1 file needs to be
         generated, output file name will be appended by index
        :param firmware_code_dir_path: path to the Firmware source code
        :param output_file_path: the path where the patch has to be generated
        :param functions_per_patch_file: how many functions should be there in each patch file.
        :return: None.
        """
        template, patch_func_list = PatchCodeGen.get_patch_generation_inputs(
            firmware_code_dir_path)
        total_patch_functions = len(patch_func_list)

        output_paths_list = PatchCodeGen.get_output_paths_for_all_patches(
            output_file_path, functions_per_patch_file, total_patch_functions)
        # To get the count of functions to be patched
        functions_count_in_each_patch_file = PatchCodeGen.get_patch_functions_count(
            functions_per_patch_file, 0, total_patch_functions)
        patch_functions_count_dict = {}
        output_paths = []
        for index, functions_start_index in \
                enumerate(range(0, total_patch_functions, functions_count_in_each_patch_file)):

            functions_count_to_patch = PatchCodeGen.get_patch_functions_count(
                functions_count_in_each_patch_file, functions_start_index, total_patch_functions)

            selected_patch_func_list = patch_func_list[functions_start_index:
                                                       functions_start_index + functions_count_to_patch]

            PatchCodeGen.generate_patch(output_paths_list[index], selected_patch_func_list, template)
            patch_file_name = os.path.basename(output_paths_list[index])
            output_paths.append(output_paths_list[index])
            patch_functions_count_dict[patch_file_name] = functions_count_to_patch
        return output_paths, patch_functions_count_dict

    @staticmethod
    def get_patch_generation_inputs(firmware_code_dir_path):
        """
        To get template and list of patch functions
        :param firmware_code_dir_path: Source code path
        :return:
        """
        header_file_names, patchable_functions, patch_modules = \
            CHeaderParser.get_all_patchable_funcs(firmware_code_dir_path)
        patch_func_list = PatchCodeGen.generate_new_patch_funcs_list(patchable_functions)
        template_header = PatchCodeGen.generate_template_header(header_file_names)
        template = PatchCodeGen.generate_patch_file_template(template_header)
        return template, patch_func_list

    @staticmethod
    def get_patch_functions_count(functions_to_patch, functions_start_index, total_patch_functions):
        """
        To get the count of functions to be patched. If None is passed, will return the count of all functions from
         current start index
        :param functions_to_patch: None or any number -> The functions count to be patched
        :param functions_start_index: Current start index
        :param total_patch_functions: Count of all patch functions
        :return: functions count to patch
        """
        if functions_to_patch > (total_patch_functions - functions_start_index) or functions_to_patch is None:
            functions_to_patch = (total_patch_functions - functions_start_index)
        return functions_to_patch

    @staticmethod
    def get_output_paths_for_all_patches(output_file_path, functions_per_patch_file, total_patch_functions):
        """
        returns list of output file paths, generated from a single output file path with an index append to name
        :param output_file_path:
        :param functions_per_patch_file:
        :param total_patch_functions:
        :return:
        """
        if functions_per_patch_file is None:
            return [output_file_path]

        output_paths_list = []
        count = (total_patch_functions / functions_per_patch_file) + 1
        file_path, extension = os.path.splitext(output_file_path)
        for index in range(1, count + 2):
            output_paths_list.append(file_path + '_' + str(index) + extension)
        return output_paths_list

    @staticmethod
    def generate_patch(output_file_path, patch_func_list, template):
        """
        Generates patch from the patch functions list and template
        :param output_file_path: the path to generate patch file
        :param patch_func_list: list of all patch functions
        :param template: reference template needed in the patch.
        :return:
        """
        watchdog_func, watchdog_signature_list = PatchCodeGen.generate_watch_dog_func(patch_func_list)
        patch_functions, patch_functions_signature_list = PatchCodeGen.generate_patch_funcs(patch_func_list)
        patch_table_headers = PatchCodeGen.generate_apply_patch_func(patch_func_list)
        PatchCodeGen.write_patch_code_to_file(output_file_path, template,
                                              watchdog_func, patch_functions, patch_table_headers)
        signature_list = watchdog_signature_list + patch_functions_signature_list
        PatchCodeGen.write_signature_to_file(signature_list)

    @staticmethod
    def write_signature_to_file(signatures):
        """
        To store functions names along with signatures
        :param signatures:
        :return:
        """
        file_patch_signature_log = "patch_func_signature.txt"
        file_operation_mode = 'w'
        if os.path.exists(file_patch_signature_log):
            file_operation_mode = 'a'

        with open(file_patch_signature_log, file_operation_mode) as file_pointer:
            signature_data = json.dumps(signatures)
            file_pointer.write(signature_data)

    @staticmethod
    def write_patch_code_to_file(output_file_path, template, watchdog_func,
                                 patch_functions, patch_table_headers):
        file_lib.write_to_file(output_file_path, template, 'w')
        file_lib.write_to_file(output_file_path, watchdog_func, 'a')
        file_lib.write_to_file(output_file_path, patch_functions, 'a')
        file_lib.write_to_file(output_file_path, patch_table_headers, 'a')

    @staticmethod
    def get_signature_string(signature):
        signature_hex = hex(signature).upper()
        signature_string = signature_hex.rstrip('L')
        return signature_string
