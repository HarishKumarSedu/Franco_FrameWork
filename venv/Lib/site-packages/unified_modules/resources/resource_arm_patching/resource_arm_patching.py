"""
Resource library to generate a patch binary
"""
import os
import shutil

# UM Core imports
import unified_modules.test_support.testlogger as logging
import unified_modules.test_support.testutils as file_lib

# UM Resources imports
from unified_modules.resources.resource_cli.resource_cli import ResourceCli
from unified_modules.resources.resource_arm_patching.meson_build_file_generator import MesonFileGenerator
from unified_modules.resources.resource_arm_patching.patch_code_generator import PatchCodeGen


class ResourceArmPatching(object):
    def __init__(self):
        self.log = logging.getLogger(self.__class__.__name__)
        self.patch_root_path = ""
        self.firmware_patch_path = ""
        self.patch_src_path = ""
        self.patch_out_dir = ""
        self.patch_builder_script = ""
        self.test_output_dir = ""
        self.meson_build_template_path = ""
        self.meson_build_config = ""
        self.res_cli = ResourceCli()

    def set_inputs(self, patching_config, meson_config):
        self.patch_root_path = patching_config.get('patch_root_path')
        self.patch_src_path = os.path.join(self.patch_root_path, 'src')
        self.firmware_patch_path = os.path.join(self.patch_root_path, 'src',
                                                'ex_fw_patches')
        self.patch_out_dir = os.path.join(self.patch_root_path, 'build', 'src',
                                          'ex_fw_patches')
        self.patch_builder_script = patching_config.get('patch_builder_script')
        self.test_output_dir = patching_config.get('test_output_dir')
        # self.meson_build_template_path = \
        #     patching_config.get('meson_build_template_path')
        self.meson_build_config = meson_config

    def generate_patch(self):
        self.delete_old_build_folder()
        self.copy_patch_sources()
        self.build_patch_axf()
        self.build_patch_bin_from_axf()

    def get_patchable_function_info(self):
        pass

    def delete_old_build_folder(self):
        build_folder = os.path.join(self.patch_root_path, 'build')
        if os.path.exists(build_folder):
            shutil.rmtree(build_folder)

    def copy_patch_sources(self):
        # Copy the source files (.c and corresponding meson.build file) to the fw_patches in src folder
        c_files_list = file_lib.get_files_by_extension(self.patch_src_path, '.c')
        meson_build_file_path = os.path.join(self.patch_src_path, 'meson.build')
        # Copy c files
        for patch_src_file in c_files_list:
            shutil.copy(patch_src_file, self.firmware_patch_path)
        # Copy meson.build
        shutil.copy(meson_build_file_path, self.firmware_patch_path)

    def build_patch_axf(self):
        """
        Build axf file
        """
        current_dir = os.getcwd()
        os.chdir(self.patch_root_path)
        # Run Meson build command
        meson_command = "meson --cross-file armcc.cross -Dbuild_patches=true build"
        self.log.info("Executing meson build command: %s" % meson_command)
        meson_out = self.res_cli.run_command(meson_command, stdout=True)
        self.log.info("Meson Output : \n", meson_out)
        # Run Ninja build command
        ninja_command = "ninja -C build"
        self.log.info("Executing Ninja build command: %s" % ninja_command)
        ninjaout = self.res_cli.run_command(ninja_command, stdout=True)
        self.log.info("Ninja Output : \n", ninjaout)
        os.chdir(current_dir)

    def build_patch_bin_from_axf(self):
        """
        Build Patch binary from axf
        """
        axf_file_path_list = file_lib.get_files_by_extension(self.patch_out_dir, '.axf')
        for axf_file_path in axf_file_path_list:
            bin_file_path = '.'.join(axf_file_path.split('.')[:-1])
            bin_file_path += '.bin'
            run_cmd = "python3 %s --axf %s --output %s" % (
                self.patch_builder_script, axf_file_path, bin_file_path)
            patch_builder_out = self.res_cli.run_command(run_cmd, stdout=True)
            self.log.info("Patch builder Output: \n %s" % patch_builder_out)

    def generate_c_patch_source(self, functions_per_patch=None):
        """
        Generate patch .c files and necessary meson build file based on the patch source file names
        :param functions_per_patch: how many functions should be there in each patch file
        :return: patch source and it's functions count as a dictionary
        """
        patch_cfile_destination_path = os.path.join(self.test_output_dir, 'sqa_patch_test.c')
        source_code_paths, patch_function_count_dict = \
            PatchCodeGen.generate_patches_with_nfunctions_in_a_file(self.patch_src_path,
                                                                    patch_cfile_destination_path,
                                                                    functions_per_patch)
        patch_c_file_names_list = self.get_c_file_names(source_code_paths)
        meson = MesonFileGenerator.get_instance(patch_c_file_names_list,
                                                self.meson_build_config)
        meson_build_file_path = os.path.join(self.test_output_dir, "meson.build")
        meson.generate_meson_build_file(meson_build_file_path)
        return patch_function_count_dict

    @staticmethod
    def get_c_file_names(source_code_path_list):
        c_file_names_list = []
        for source_code_path in source_code_path_list:
            c_file_name = os.path.basename(source_code_path)
            c_file_names_list.append(c_file_name)

        return c_file_names_list
