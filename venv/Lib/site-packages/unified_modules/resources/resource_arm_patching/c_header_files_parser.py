"""
Module to parser C Header Files
"""
import re
import os

# UM Core imports
import unified_modules.test_support.testlogger as logging
import unified_modules.test_support.testutils as file_lib


class CHeaderFilesParser(object):
    def __init__(self):
        self.log = logging.getLogger(self.__class__.__name__)

    def get_all_patchable_funcs(self, code_dir_path):
        """Get all the patchable functions from the list of directories."""
        patch_func_list = []
        header_file_names = []
        patch_modules = []

        # Get files by extension from all the given directories
        file_paths = self.get_all_header_files(code_dir_path)

        # get the content from all the files
        for file_path in file_paths:
            patch_functions = self.get_patchable_func_list(file_path)

            if len(patch_functions) > 0:
                # get the header file name
                file_name = os.path.basename(file_path)
                patch_func_list += patch_functions
                header_file_names.append(file_name)
                patch_module = {'patch_functions': patch_functions,
                                'header_path': file_path,
                                'source_path': file_path.replace('.h', '.c')}
                patch_modules.append(patch_module)

        return header_file_names, patch_func_list, patch_modules

    @staticmethod
    def get_all_header_files(dir_path):
        """Get all header files in a directory."""
        file_paths = []
        # Get files by extension from all the given directories
        file_paths += file_lib.get_files_by_extension(dir_path, ".h")
        return file_paths

    def get_patchable_func_list(self, file_path):
        """This method extracts all patchable function names from the given file."""
        struct_blocks = self.get_struct_blocks(file_path)
        patchable_funcs_list = []

        for struct_block in struct_blocks:
            struct_name, patchable_functions = self.get_patchable_funcs(struct_block)
            # update structure name
            if struct_name != '' and len(patchable_functions) != 0:
                # Update structure info
                patchable_functions = CHeaderFilesParser.update_structure_name(
                    patchable_functions, struct_name)
                # Append to patchable functions
                patchable_funcs_list += patchable_functions

        # update external struct names
        self.update_external_struct_names(file_path, patchable_funcs_list)

        return patchable_funcs_list

    def get_struct_blocks(self, file_path):
        """This method extract 'typedef struct' section from the given Header file."""
        struct_block = ''
        struct_blocks = []
        block_start = False
        start_count = 0
        end_count = 0

        with open(file_path) as f:
            for line in f:
                # starting reading from 'typedef struct' block
                if 'typedef struct' in line:
                    block_start = True

                # Count the number of open and close blocks to identify the block end
                struct_block, start_count, end_count = CHeaderFilesParser.get_block_info(
                    line, struct_block, block_start, start_count, end_count)

                # Count the number of open and close flower braces \
                #   to check the inner blocks in typdef struct block
                #   If start and end counts are >= 1 and start count is same as end count,
                #   i.e. equal number of start and end blocks
                if start_count == end_count and start_count > 0:
                    # add the block to list
                    struct_blocks.append(struct_block)
                    # Reset the block information
                    struct_block, block_start, start_count, end_count = \
                        CHeaderFilesParser.reset_block_info()
        f.close()

        return struct_blocks

    @staticmethod
    def get_block_info(line, struct_block, block_start, start_count, end_count):
        """This function extracts the code block."""
        if block_start:
            struct_block += line
        if '{' in line and block_start:
            start_count += 1
        if '}' in line and block_start:
            end_count += 1

        return struct_block, start_count, end_count

    @staticmethod
    def reset_block_info():
        """Reset block information."""
        block_start = False
        code_block = ''
        start_count = 0
        end_count = 0

        return code_block, block_start, start_count, end_count

    @staticmethod
    def get_patchable_function_info(line):
        """
        Get the patchable function name, it's return type \
            and parameters from the given line of code
        """
        data = {}
        line_text = line.strip()
        patchable_function_pattern = re.compile(r"\b([a-zA-Z0-9]+_?[a-zA-Z]?)\s+\(\*(.*)\)\((.*)\);")
        function_name_obj = patchable_function_pattern.search(line_text)

        if function_name_obj is not None:  # Search for the pattern. If the result is NOT false,
            data['fn_type'] = function_name_obj.group(1)
            data['fn_name'] = function_name_obj.group(2)
            data['params'] = function_name_obj.group(3)
        return data

    @staticmethod
    def get_struct_block_name(line):
        """Get the structure name from the given line of code."""
        struct_name_pattern = re.compile(r"(\}+\s)(([a-zA-Z]+_?)+);")
        struct_name_obj = struct_name_pattern.search(line.strip())
        struct_name = ''

        if struct_name_obj is not None:
            struct_name = struct_name_obj.group(2)
        return struct_name

    @staticmethod
    def get_extern_pointer_name(line):
        """Get the line containing 'extern' pointers."""
        extern_info = {}
        # Search for the extern pattern
        extern_pattern = re.compile(r"extern\s+(([a-zA-Z]+_?)+)\s+\*(([a-zA-Z]+_?)+);")
        extern_obj = extern_pattern.search(line.strip())

        # get the structure name and it'spointer
        if extern_obj is not None:
            extern_info['st_name'] = extern_obj.group(1)
            extern_info['st_pointer'] = extern_obj.group(3)
        return extern_info

    def get_extern_struct_pointers(self, file_path):
        """Get extern structure pointers from a file."""
        extern_pointers = []
        ext_pointers_dict = {}
        # Read all the external pointers from file
        try:
            with open(file_path) as f:
                for line in f:
                    ext_info = CHeaderFilesParser.get_extern_pointer_name(line)
                    if ext_info:
                        extern_pointers.append(ext_info)
            f.close()
        except IOError:
            self.log.error("IO Error while reading the file..")
        except Exception as ex:
            self.log.error("Error due to %s" % ex.message)

        if len(extern_pointers) != 0:
            for ext in extern_pointers:
                ext_pointers_dict[ext['st_name']] = ext['st_pointer']
            return ext_pointers_dict

    def update_external_struct_names(self, file_path, patchable_functions):
        # Get the external pointer names
        """Replace actual structure names with the extern names."""
        ext_struct_dict = self.get_extern_struct_pointers(file_path)

        if ext_struct_dict:
            ext_names = list(ext_struct_dict.keys())
            # iterate over all the patchable functions and check for the matching
            for patch_func in patchable_functions:
                # if the struct is name is found in extern pointer names,
                #   replace the sturct name with the extern pointer name
                struct_name = patch_func['st_name']
                # Replacing struct name with the extern pointer
                if struct_name in ext_names:
                    patch_func['st_name'] = ext_struct_dict[struct_name]

        return patchable_functions

    @staticmethod
    def get_patchable_funcs(struct_block):
        """Get patchable functions from struct block."""
        patchable_functions = []
        struct_name = ''
        for line in struct_block.splitlines():
            # get all patchable functions in the struct block
            data = CHeaderFilesParser.get_patchable_function_info(line)
            if data:
                patchable_functions.append(data)

            # Get the struct block name
            struct_name = CHeaderFilesParser.get_struct_block_name(line)
        return struct_name, patchable_functions

    @staticmethod
    def update_structure_name(patchable_functions, struct_name):
        """This method updates the structure name in the given list of patch functions"""
        for patch_function in patchable_functions:
            patch_function['st_name'] = struct_name
        return patchable_functions
