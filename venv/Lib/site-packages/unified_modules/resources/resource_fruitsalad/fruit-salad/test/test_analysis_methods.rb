################################################################################
### Copyright (c) 2016-2017 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International(UK) Ltd assumes no responsibility or liability for any errors
### or inaccuracies that may appear in this document or any software that may be
### provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   test_analysis_methods.rb
### @brief  Tests of analysis test methods definitions.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

# ensure that the gem version of test-unit is loaded
# otherwise the report generation will not occur.
gem 'test-unit'
require 'test/unit'

require_relative '../src/fruitsalad_env_setup.rb'
require_relative '../src/test_method_definitions/target_operations.rb'
require_relative '../src/test_method_definitions/analysis.rb'

require 'configuration'
require 'fruitsalad_utils'
require 'tone_generator'
require 'wavefile_analyzer.rb'
require 'wavefile'
require 'waveinfo'

include WavefileAnalyzer
include ToneGenerator

if __FILE__ == $0
    raise 'IP address not specified as argument' if ARGV.size < 1
end

# When test is executed individually with ip address as argument.
unless ARGV[0] =~ /.rb/
    $arg = ARGV[0]
# When test is invoked through rake file with ip address as argument.
else
    exit unless ENV['TARGET'] =~ /remote/i
    $arg = ENV['IP']
end

#######################################################################
# Class: TestFirmwareMethods
#
# Test case for testing analysis test method definitions.
#
#######################################################################
class TestAnalysisMethods < Test::Unit::TestCase
    include WaveFile

    ###########################################################################
    #
    # @function create_remote_salad
    #
    # Creates an instance of RemoteSalad with a given configuration.
    #
    # @param [String] config  Path to a configuration file.
    # @param [String] user    Remote user name.
    # @param [String] address IP address of a remote system.
    #
    # @return [RemoteSalad] An instance of RemoteSalad.
    #
    ###########################################################################
    def create_remote_salad( config, user, address )
        Conf.set_source( config )
        Conf.set( :Remote_User, user )
        Conf.set( :Remote_Address, address )
        # has to be required _after_ loading configuration
        require 'src/targets/RemoteSalad'
        device = FruitSalad::get_device()
        raise 'Device not connected.' unless device.device_connected?
        return device
    end

    #######################################################################
    # @function test_analysis_methods
    #
    # It should correctly convert DSP string identifers into indicies.
    # Pass through already converted numbers.
    # Raise an exception if the specifier does not conform to the expected format.
    #
    # (no parameters)
    #
    #######################################################################
    def test_analysis_methods
        ip_address = $arg
        device = create_remote_salad( 'configs/cirruslink_linux.yaml',
                                      'root',
                                      ip_address
                                    )
        device.setup

        filename = 'resources/silence.wav'
        assert_raise do
            verify_output_for_silence( filename, negotiate = true )
        end

        filename = 'resources/Hello_blueginee_440hz_sinetone.wav'
        assert_raise do
            verify_output_for_silence( filename, negotiate = false )
        end

        file = 'resources/Hello_blueginee_440hz_sinetone.wav'
        frequency = 440
        error = 1
        assert_nothing_raised do
            verify_output_has_frequency_peak( file, frequency, error )
        end

        frequency = 500
        assert_raise do
            verify_output_has_frequency_peak( file, frequency, error )
        end

        file = 'resources/sample_music.wav'
        assert_nothing_raised do
            check_output_has_pops_and_clicks( file )
        end

        file = 'resources/test_sample_music_pops.wav'
        assert_raise do
            check_output_has_pops_and_clicks( file )
        end

        file1 = 'resources/scp_spk_gold.wav'
        file2 = 'resources/scp_output.wav'
        assert_nothing_raised do
            audio_comparison( file1, file2 )
        end

        file1 = 'resources/scp_spk_gold.wav'
        file2 = 'resources/sample_music.wav'
        assert_raise do
            audio_comparison( file1, file2 )
        end

        #Finding average amplitude value for mono file.
        file = 'resources/sample_music_mono.wav'
        assert_nothing_raised do
            value = check_average_amplitude_value_of_output( file )
            $LOG.info "The average amplitude value is: #{value} dBFS"
        end

        file1 = 'resources/sample_music_mono.wav'
        file2 = 'resources/sample_music_mono.wav'
        assert_raise do
            value1 = check_average_amplitude_value_of_output( file1 )
            value2 = check_average_amplitude_value_of_output( file2 )
            $LOG.info "The average amplitude of file1 is: #{value1} dBFS and file2 is: #{value2} dBFS"
            if value1 == value2
                $LOG.info 'Both are equal'
                raise 'Both are equal'
            end
        end

        #Finding average amplitude value for stereo file.
        file = 'resources/sample_music.wav'
        assert_nothing_raised do
            value = check_average_amplitude_value_of_output( file )
            $LOG.info "The average amplitude value is: #{value} dBFS"
        end

        file1 = 'resources/sample_music.wav'
        file2 = 'resources/sample_music.wav'
        assert_raise do
            value1 = check_average_amplitude_value_of_output( file1 )
            value2 = check_average_amplitude_value_of_output( file2 )
            $LOG.info "The average amplitude of file1 is: #{value1} dBFS and file2 is: #{value2} dBFS"
            if value1[0] == value2[0] && value1[1] == value2[1]
                $LOG.info 'Both are equal'
                raise 'Both are equal'
            end
        end
    end

    ###########################################################################
    #
    # @function test_add_wave_header_to_pcm_file
    #
    # Sinetone is generated of given length and frequency. Upon the sinetone
    # the header has been re-written with given header values. Then the output
    # is matched with the input to check whether the header is over-written or
    # not.
    #
    # (no parameters)
    #
    ###########################################################################
    def test_add_wave_header_to_pcm_file
        # First set of values.
        channels = 2
        bits_per_sample = 16
        sample_rate = 48000
        track_length = 5
        frequency = 1000
        sine_file = generate_sinewave( frequency, track_length )

        track_length_mismatch = 'Length of track mismatches after writting the header'
        channel_mismatch = 'The given channel is not written in add_wave_header_to_pcm_file'
        sample_rate_mismatch = 'The given sample_rate is not written in add_wave_header_to_pcm_file'
        bits_per_sample_mismatch = 'The given bits_per_sample is not written in add_wave_header_to_pcm_file'

        WavefileAnalyzer::add_wave_header_to_pcm_file( sine_file,
                                                       channels,
                                                       bits_per_sample,
                                                       sample_rate
                                                     )
        info = WaveFile::Reader.info( sine_file )

        assert_equal( track_length, info.duration.seconds, track_length_mismatch )
        assert_equal( channels, info.channels, channel_mismatch )
        assert_equal( bits_per_sample, info.bits_per_sample, bits_per_sample_mismatch )
        assert_equal( sample_rate, info.sample_rate, sample_rate_mismatch )

        # Second set of values.
        channels = 1
        bits_per_sample = 24
        sample_rate = 48000
        track_length = 7
        frequency = 2000
        sine_file = generate_sinewave( frequency, track_length )

        WavefileAnalyzer::add_wave_header_to_pcm_file( sine_file,
                                                       channels,
                                                       bits_per_sample,
                                                       sample_rate
                                                     )
        info = WaveFile::Reader.info( sine_file )

        assert_equal( channels, info.channels, channel_mismatch )
        assert_equal( bits_per_sample, info.bits_per_sample, bits_per_sample_mismatch )
        assert_equal( sample_rate, info.sample_rate, sample_rate_mismatch )
        #
        # Note: we can't check the length of the file when we change
        # these header values. With respect to these header info length
        # may vary.
        #

    end

    ###########################################################################
    #
    # @function test_club_two_mono_to_stereo
    #
    # The method club_two_mono_to_stereo should correctly convert given two
    # mono channel streams into one stereo stream.
    #
    # (no parameters)
    #
    ###########################################################################
    def test_club_two_mono_to_stereo
        channels = 1
        frequency1 = 1000
        frequency2 = 2000
        error_threshold = 3
        duration1 = 7
        duration2 = 6
        error_message1 = 'There is a unexpected frequency found'
        error_message2 = 'The expected frequency is not found'

        sine_file1 = generate_sinewave( frequency1,
                                        duration1,
                                        channels:channels,
                                      )
        sine_file2 = generate_sinewave( frequency2,
                                        duration2,
                                        channels:channels,
                                      )

        out_file1 = File.join( ENV['FRUITSALAD_HOME'],
                                    'tmp/clubbed_stereo_file1.wav'
                             )

        out_file2 = File.join( ENV['FRUITSALAD_HOME'],
                                    'tmp/clubbed_stereo_file2.wav'
                                  )

        WavefileAnalyzer::club_two_mono_to_stereo( sine_file1,
                                                   sine_file2,
                                                   out_file1
                                                 )
        measured_frequencies = WavefileAnalyzer::dominant_frequencies out_file1
        puts "measured_frequencies::#{measured_frequencies}"

        count1 = 0
        count2 = 0

        measured_frequencies.each do |frequency|
            if ( frequency1 - frequency ).abs > error_threshold and
               ( frequency2 - frequency ).abs > error_threshold and
               ( frequency != 0 )
                assert( false, error_message1 )
            end
            if ( frequency.ceil == frequency1 ) or ( frequency.floor == frequency1 )
                count1 += 1
            end
            if ( frequency.ceil == frequency2 ) or ( frequency.floor == frequency2 )
                count2 += 1
            end
        end
        if count1 >= 1 and count2 >= 1
            puts "The input frequencies are available in the output."
        else
            assert( false, error_message2 )
        end

        # Parse mono channel streams with two different sample rate.
        corrupt_sample_rate = 16000
        channels = 1
        bits_per_sample = 16
        WavefileAnalyzer::add_wave_header_to_pcm_file( sine_file2,
                                                       channels,
                                                       bits_per_sample,
                                                       corrupt_sample_rate
                                                     )

        assert_raise do
            WavefileAnalyzer::club_two_mono_to_stereo( sine_file1,
                                                       sine_file2,
                                                       out_file2
                                                     )
        end

        # Parse mono channel streams with two different bit-depth.
        corrupt_bits_per_sample = 24
        channels = 1
        sample_rate = 48000
        WavefileAnalyzer::add_wave_header_to_pcm_file( sine_file2,
                                                       channels,
                                                       corrupt_bits_per_sample,
                                                       corrupt_sample_rate
                                                     )

        assert_raise do
            WavefileAnalyzer::club_two_mono_to_stereo( sine_file1,
                                                       sine_file2,
                                                       out_file2
                                                     )
        end

    end
end
################################### END OF FILE ###########################
