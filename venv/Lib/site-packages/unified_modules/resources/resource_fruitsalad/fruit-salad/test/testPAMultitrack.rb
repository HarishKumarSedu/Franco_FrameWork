#!/usr/bin/ruby
################################################################################
### Copyright (c) 2017 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   testPAMultitrack.rb
### @brief  TestCase for testing PAMultitrack Utility
###
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################
# ensure that the gem version of test-unit is loaded
# otherwise the report generation will not occur.
# Hardware Requirements :    TS2000 USB Streamer with SPDIF Loop Back Connection
gem 'test-unit'
require 'test/unit'

require_relative '../src/fruitsalad_env_setup'
require 'src/wavefile_analyzer'
require 'src/pa_multitrack'
require 'waveinfo'

class TestPAMultitrack < Test::Unit::TestCase

    include WavefileAnalyzer

    # State of thread when it is running.
    ThreadStatus = 'run'

    ###########################################################################
    #
    #    @function    end_recording
    #
    #    Kills PA multitrack if it exists in current tasklist.
    #
    ###########################################################################
    def end_recording
        task_list_exit_code = system( "tasklist /FI \"IMAGENAME eq pa_multitrack.exe\" "\
        "| find /I \"pa_multitrack.exe\" > nul" )
        if task_list_exit_code
            task_kill_exit_code = system( "taskkill /F /IM pa_multitrack.exe >"\
            " nul 2>&1" )
        end
    end

    ###########################################################################
    #
    #    @function    test_play_and_record
    #
    #    Play and record mono channel wave file using Pa multitrack utility,
    #    and testing Pa multitrack utility for wrong scenarios.
    #
    ###########################################################################
    def test_play_and_record
        play_file = 'resources/ok_google_440hz_sinetone_48k.wav'
        recorded_file = 'recorded_ok_google_440hz_sinetone_48k.wav'
        wave_info = WaveInfo.new( play_file )
        samples = ( wave_info.sample_rate * ( wave_info.duration + 2 ) ).to_i

        # Recording in Background, playback in foreground
        track_list_record = [ [ recorded_file, nil, 9 ] ]
        rec = true
        background = true
        pa_multitrack = PaMultitrack.new()
        Conf::set('Multitrack_SampleRate',48000)
        pa_multitrack.re_init_pa_multitrack
        pa_multitrack.play_tracklist( track_list_record,
                                      rec,
                                      samples,
                                      background
                                    )

        # Starting Playback
        track_list_play = [ [ play_file, 9, nil ] ]
        rec = false
        pa_multitrack.play_tracklist( track_list_play, rec )

        # Check for playback
        assert_equal( 0, $?.exitstatus, 'Playback is not Done' )

        # Check for recording
        while 1
            # Thread is in false state when it is done.
            if false == pa_multitrack.rec_thread.status
                assert_equal( 0, $?.exitstatus, 'Recording is not Done' )
                break
            # Thread is in run state when it is running.
            elsif ThreadStatus == pa_multitrack.rec_thread.status
                sleep(1)
            end
        end

        # end recording
        end_recording()

        # Updating wave header
        self.add_wave_header_to_pcm_file( 'tmp/' + recorded_file, 1, 16,48000 )

        # calculating peak frequency
        peak_frq_play_file = self.peak_frequency( play_file )
        peak_frq_rec_file = self.peak_frequency( 'tmp/' + recorded_file )

        # Check for Peak frequency
        assert_equal( peak_frq_rec_file, peak_frq_play_file,
                        'Peak Frequency should be equal' )

        #
        # Wrong Scenario for play params
        # Record in background ,playback in foreground
        #
        recorded_file = 'recorded_file_ok_google_440hz_sinetone_48k_1.wav'
        track_list_record = [ [ recorded_file, nil, 9 ] ]
        track_list_play = [ [ play_file, 9, 9 ] ]

        # Recording in Background
        rec = true
        wave_info = WaveInfo.new( play_file )
        samples = ( wave_info.sample_rate * ( wave_info.duration + 2 ) ).to_i
        PaMultitrack.new().play_tracklist( track_list_record,
                                           rec,
                                           samples,
                                           background
                                         )

        # Starting Playback
        rec = false
        # Pa multitrack Fails to read play_file as two channels are provided
        assert_raise do
            PaMultitrack.new().play_tracklist( track_list_play, rec )
        end

        # Check for playback
        assert_not_equal( 0, $?.exitstatus, 'Playback should not be Done' )

        # end recording
        end_recording()

        #
        # Wrong Scenario for record params
        # Record in background and play in foreground
        #
        recorded_file = 'recorded_file_ok_google_440hz_sinetone_48k_2.wav'
        track_list_record = [ [ recorded_file, 9, 9 ] ]
        track_list_play = [ [ play_file, 9, nil ] ]

        # Start Recording
        rec = true
        background = true
        samples = ( wave_info.sample_rate * ( wave_info.duration + 2 ) ).to_i
        pa_multitrack = PaMultitrack.new()

        # Pa multitrack Fails to record,as recorded_file has two channels
        pa_multitrack.play_tracklist( track_list_record,
                                      rec,
                                      samples,
                                      background
                                    )

        #
        # Check if thread is running or not
        # If thread is not running its status is false
        #
        assert( !pa_multitrack.rec_thread.status, 'Recording must be aborted' )

        # Starting Playback
        rec = false
        pa_multitrack.play_tracklist( track_list_play, rec )
        assert_equal( 0, $?.exitstatus, 'Playback is not Done' )

        #
        # Wrong Scenario for record params
        # Record and playback in foreground
        #
        recorded_file = 'recorded_file_ok_google_440hz_sinetone_48k_2.wav'
        track_list_record = [ [ recorded_file, 9, 9 ] ]
        track_list_play = [ [ play_file, 9, nil ] ]

        # Start Recording
        rec = true
        background = false
        samples = ( wave_info.sample_rate * ( wave_info.duration + 2) ).to_i
        pa_multitrack = PaMultitrack.new()
        # Pa multitrack Fails to record,as recorded_file has two channels
        assert_raise do
            pa_multitrack.play_tracklist( track_list_record,
                                        rec,
                                        samples,
                                        background
                                        )
        end

        # Check for record
        assert_not_equal( 0, $?.exitstatus, 'Recording should not be done' )

        # Starting Playback
        rec = false
        pa_multitrack.play_tracklist( track_list_play, rec )
        assert_equal( 0, $?.exitstatus, 'Playback is not Done' )
    end

    #######################################################################
    #
    #    @function    test_play_and_record_background
    #
    #    Play and record operations,both in background using Pa multitrack
    #    utility.
    #
    #######################################################################
    def test_play_and_record_background
        play_file = 'resources/ok_google_440hz_sinetone_48k.wav'
        recorded_file = 'recorded_file_ok_google_440hz_sinetone_48k_play_rec.wav'
        track_list_record = [ [ recorded_file, nil, 9 ] ]
        track_list_play = [ [ play_file, 9, nil ] ]

        # Recording in Background
        rec = true
        background = true
        wave_info = WaveInfo.new( play_file )
        samples = ( wave_info.sample_rate * ( wave_info.duration + 2 ) ).to_i
        pa_multitrack = PaMultitrack.new()
        Conf::set('Multitrack_SampleRate',48000)
        pa_multitrack.re_init_pa_multitrack
        pa_multitrack.play_tracklist( track_list_record,
                                      rec,
                                      samples,
                                      background
                                    )
        # Starting Playback
        rec = false
        pa_multitrack.play_tracklist( track_list_play, rec , nil, background )

        # Check for playback and record
        while 1
            # Thread is in false state when it is done.
            if ( false == pa_multitrack.play_thread.status  &&
                 false == pa_multitrack.rec_thread.status
               )
                assert_equal( 0, $?.exitstatus,
                                'Recording is not done' )
                break
            # Thread is in run state when it is running.
            elsif ThreadStatus == pa_multitrack.rec_thread.status
                sleep(1)
            end
        end

        # end recording
        end_recording()

        # Updating wave header
        self.add_wave_header_to_pcm_file( 'tmp/' + recorded_file, 1, 16,48000 )

        # calculating peak frequency
        peak_frq_play_file = self.peak_frequency( play_file )
        peak_frq_rec_file = self.peak_frequency( 'tmp/' + recorded_file )

        # Check for Peak frequency
        assert_equal( peak_frq_rec_file, peak_frq_play_file,
                        'Peak Frequency should be equal' )
    end

    ###########################################################################
    #
    #    @function    test_two_mono_files_play_and_record
    #
    #    Playing two mono wave files in two different channels and recording
    #    themin two mono wave files.
    #
    ###########################################################################
    def test_two_mono_files_play_and_record
        play_file = 'resources/ok_google_440hz_sinetone_48k.wav'
        recorded_file_ch_10 = 'recorded_ok_google_440hz_sinetone_48k_ch_10.wav'
        recorded_file_ch_9 = 'recorded_ok_google_440hz_sinetone_48k_ch_9.wav'

        track_list_record = [ [ recorded_file_ch_10, nil, 10 ],
                                [ recorded_file_ch_9, nil, 9] ]
        track_list_play = [ [ play_file, 10, nil ],[ play_file, 9, nil ] ]

        # Recording in Background
        rec = true
        background = true
        wave_info = WaveInfo.new( play_file )
        samples = ( wave_info.sample_rate * ( wave_info.duration + 2 ) ).to_i
        pa_multitrack = PaMultitrack.new()
        Conf::set('Multitrack_SampleRate',48000)
        pa_multitrack.re_init_pa_multitrack
        pa_multitrack.play_tracklist( track_list_record,
                                      rec,
                                      samples,
                                      background
                                    )

        # Starting Playback
        rec = false
        pa_multitrack.play_tracklist( track_list_play, rec )

        # Check for playback
        assert_equal( 0, $?.exitstatus, 'Playback is not Done' )

        # Check for record
        while 1
            # Thread is in false state when it is done.
            if false == pa_multitrack.rec_thread.status
                assert_equal( 0, $?.exitstatus, 'Recording is not Done' )
                break
            # Thread is in run state when it is running.
            elsif ThreadStatus == pa_multitrack.rec_thread.status
                sleep(1)
            end
        end

        # end recording
        end_recording()

        # Updating wave header
        self.add_wave_header_to_pcm_file( 'tmp/' + recorded_file_ch_9,
                                            1, 16, 48000
                                        )
        self.add_wave_header_to_pcm_file( 'tmp/' + recorded_file_ch_10,
                                            1, 16,48000
                                        )

        # calculating peak frequency
        peak_frq_play_file = self.peak_frequency( play_file )
        peak_frq_rec_ch_10 = self.peak_frequency( 'tmp/' + recorded_file_ch_10 )
        peak_frq_rec_ch_9 = self.peak_frequency( 'tmp/' + recorded_file_ch_9 )

        # Check for Peak frequency
        result = peak_frq_play_file == peak_frq_rec_ch_10 ?
        ( peak_frq_rec_ch_10 == peak_frq_rec_ch_9 ? true : false ) : false
        assert( result, "Recording is not done Successfully" )
    end

    ###########################################################################
    #
    #    @function    test_play_and_capture_simultaneous
    #
    #    Simultaneous Play and Capture Using Pa multitrack,and testing
    #    Pa multitrack for wrong scenarios.
    #
    ###########################################################################
    def test_play_and_capture_simultaneous
        # loading Config file for Sample Rate 44100 hz
        Conf::set_source( "configs/wisce_config_simulated.yaml" )
        play_file = 'resources/ok_google_440hz_sinetone_44k.wav'
        recorded_file = 'recorded_ok_google_440hz_sinetone_44k_simultaneous.wav'

        # Play and Capture simultaneously
        track_list = [ [ play_file, 9, nil ],
                                [ recorded_file, nil, 9 ] ]
        rec = true
        wave_info = WaveInfo.new( play_file )
        samples = ( wave_info.sample_rate * ( wave_info.duration ) ).to_i
        PaMultitrack.new().play_tracklist( track_list, rec, samples )

        # Check for playback and capture
        assert_equal( 0, $?.exitstatus, 'Playback and capture is not Done' )

        # calculating peak frequency
        peak_frq_play_file = self.peak_frequency( play_file )
        peak_frq_rec_file = self.peak_frequency( "tmp/" + recorded_file )

        # Check for Peak frequency
        assert_equal( peak_frq_rec_file ,
        peak_frq_play_file, 'Peak Frequency should be equal' )

        #
        # Wrong Scenario with samples of type float
        # Play and Capture simultaneously
        #
        recorded_file = 'recorded_ok_google_440hz_sinetone_44k.wav'

        # Play and Capture
        track_list = [ [ play_file, 9, nil ],
                        [ recorded_file, nil, 9 ] ]
        rec = true
        samples = ( wave_info.sample_rate * ( wave_info.duration ) )

        #
        # Pa multitrack raises format exception,as samples are of type float,
        # it must be of type integer.
        #
        assert_raise do
            PaMultitrack.new().play_tracklist( track_list, rec, samples )
        end

        # Check for playback and capture
        assert_not_equal( 0, $?.exitstatus,
                            'Play and capture should not be Done' )
    end

    ###########################################################################
    #
    #    @function    test_two_mono_files_play_capture_simultaneous
    #
    #    Simultaneously playing two mono wave files in two different channels
    #    and capturing them in two mono wave files.
    #
    ###########################################################################
    def test_two_mono_files_play_capture_simultaneous
        # loading Config file for Sample Rate 44100 hz
        Conf::set_source( "configs/wisce_config_simulated.yaml" )
        play_file = 'resources/ok_google_440hz_sinetone_44k.wav'
        recorded_file_ch_9 = 'recorded_ok_google_440hz_sinetone_44k_ch_9.wav'
        recorded_file_ch_10 = 'recorded_ok_google_440hz_sinetone_44k_ch_10.wav'

        # Play and Capture simultaneously
        rec = true
        wave_info = WaveInfo.new( play_file )
        samples = ( wave_info.sample_rate * ( wave_info.duration ) ).to_i
        track_list = [ [ play_file, 9, nil],[ recorded_file_ch_9, nil, 9 ],
                        [ play_file, 10, nil],[ recorded_file_ch_10, nil, 10 ] ]

        pa_multitrack = PaMultitrack.new()
        pa_multitrack.re_init_pa_multitrack
        pa_multitrack.play_tracklist( track_list, rec, samples )

        # Check for playback and capture
        assert_equal( 0, $?.exitstatus, 'Playback and capture is not done' )

        # calculating peak frequency
        peak_frq_play_file = self.peak_frequency( play_file )
        peak_frq_rec_ch_9 = self.peak_frequency( "tmp/" + recorded_file_ch_9 )
        peak_frq_rec_ch_10 = self.peak_frequency( "tmp/" + recorded_file_ch_10 )

        # Check for Peak frequency
        result = ( peak_frq_play_file == peak_frq_rec_ch_9 ) ?
        ( peak_frq_rec_ch_9 == peak_frq_rec_ch_10 ? true : false ) : false
        assert( result, 'Playback or Recording is not done Successfully' )
    end

    ###########################################################################
    #
    #    @function    test_play_and_capture_simultaneous_background
    #
    #    Simulataneous play and capture mono wave file in background.
    #
    ###########################################################################
    def test_play_and_capture_simultaneous_background
        # loading Config file for Sample Rate 44100 hz
        Conf::set_source( "configs/wisce_config_simulated.yaml" )
        play_file = 'resources/ok_google_440hz_sinetone_44k.wav'
        recorded_file = 'ok_google_440hz_sinetone_simultaneous_background.wav'

        track_list = [ [ play_file, 9, nil ],
                                [ recorded_file, nil, 9 ] ]
        rec = true
        wave_info = WaveInfo.new( play_file )
        samples = ( wave_info.sample_rate * ( wave_info.duration ) ).to_i
        background = true
        pa_multitrack = PaMultitrack.new()
        pa_multitrack.play_tracklist( track_list, rec, samples, background )

        # Check for playback and capture
        while 1
            # Thread is in false state when it is done.
            if false == pa_multitrack.rec_thread.status
                break
            # Thread is in run state when it is running.
            elsif ThreadStatus == pa_multitrack.rec_thread.status
                sleep(1)
            end
        end

        # calculating peak frequency
        peak_frq_play_file = self.peak_frequency( play_file )
        peak_frq_rec_file = self.peak_frequency( "tmp/" + recorded_file )

        # Check for Peak frequency
        assert_equal( peak_frq_rec_file ,
                        peak_frq_play_file, 'Peak Frequency should be equal' )
    end
end