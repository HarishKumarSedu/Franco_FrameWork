#!/usr/bin/ruby
################################################################################
### Copyright (c) 2014-2017 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   testWISCEAutomation.rb
### @brief  TestCase for WISCE automation functions used by Fruit Salad.
###
### @version \$Id: testWISCEAutomation.rb 1028 2015-05-06 16:58:21Z aangus $
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################
# ensure that the gem version of test-unit is loaded
# otherwise the report generation will not occur.
gem 'test-unit'
require 'test/unit'

require 'benchmark'

require_relative '../src/fruitsalad_env_setup.rb'
require 'targets/WISCESalad.rb'

unless ENV['TARGET'].nil?
    exit unless ENV['TARGET'] =~ /wisce/i
end

#######################################################################
#
# @note TestCase for WISCE™ automation functions used by Fruit Salad.
#
# This test suite mixes simulated device tests with those that require a lochnagar.
#
# Tests can be run individually using the -n <test name or with a regexp //>
#
# or by excluding tests (e.g. to stop the *_lochnagar): --ignore-name=/\w+lochnagar/
#
#
# Known Issues: 22/12/14
#    * Running all tests with a lochnagar attached will cause an error in the test case
#      test_WISCE_read_field_lochnagar (Object reference not set to an instance of an object)
#      instead of simply failing (clocking isn't quite right and still in progress).
#      However, running just this test causes no such error.
#      Similarly for a run with --ignore-name=/\w+lochnagar/.
#      i.e. there are unwanted interactions between tests that cause unexpected behaviour.
#
#    * The meaningful names used as part of these tests are provided by the algorithm description
#      files if these are not present in the WISCE install it will not be able to pass the tests.
#
#######################################################################
class TestWISCEAutomation < Test::Unit::TestCase
    #######################################################################
    # @function test_WISCE_device_load_firmware_simulated
    #
    # Establish a connection to a simulated device, load a firmware through a
    # wmfw file and check that it is was installed to the correct core.
    #
    # Tests are carried out on a simulated device, so there should be no
    # issues with incorrect memory clocking.
    #   i.e. firmware downloads but does not 'stick'.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_device_load_firmware_simulated
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect_simulated( 'SimulatedSystem', 'WM8280', 'WM8280_RegMap_RevD.wxd' )
        basic_test_firmware_load_usecase( wisce )
    end

    #######################################################################
    # @function test_WISCE_device_load_usecase_lochnagar
    #
    # Establish a connection to a simulated device, load a firmware through a usecase file and
    # check that it was installed to the correct core.
    #
    # This test will attempt to connect to the lochnagar system using Aardvark.
    #
    # Tests are carried out on a real device, so there could be
    # issues with incorrect memory clocking.
    #   i.e. firmware downloads but does not 'stick'.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_device_load_usecase_lochnagar
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect('Aardvark', 'WM8280')
        basic_test_firmware_load_usecase( wisce )
    end

    #######################################################################
    # @function test_WISCE_connect_lochnagar
    #
    # Ensure that connections can be established when named descriptions are absent (but a device is attached).
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_connect_lochnagar
        wisce = FruitSalad::WISCESalad.new( false, false )

        assert( wisce.devices_present?( 'WM5110' ), 'This test requires WM5110 descriptions to be present on the test system.' )
        message = wisce.connect('Aardvark', 'WM8280')
        assert_equal( 'Testing WM5110 on Aardvark.', message, 'Mismatch in the diagnostic message returned from WISCESaald::connect().' )
    end

    #######################################################################
    # @function test_WISCE_hide_restore_devices
    #
    # Test that device description files can be hidden and restored.
    #
    # Expects WM8280 and WM5110 descriptions to be present on the system
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_hide_restore_devices
        wisce = FruitSalad::WISCESalad.new( false, false )
        assert( wisce.devices_present?( 'WM8280' ) )
        assert( wisce.devices_present?( 'WM5110' ) )
        wisce.hide_devices( 'WM5110' )
        assert( !wisce.devices_present?( 'WM5110' ) )
        wisce.restore_devices( 'WM5110' )
        assert( wisce.devices_present?( 'WM5110' ) )
    end

    #######################################################################
    # @function basic_test_firmware_load_usecase
    #
    # Simple test for the DSP firmware loading using a usecase.
    # Used by the test methods:
    #    test_WISCE_device_load_usecase_simulated
    #    test_WISCE_device_load_usecase_lochnagar
    #
    # @param [WISCESalad] wisce instance pre-connected to a device
    #
    #######################################################################
    def basic_test_firmware_load_usecase( wisce )
        # setup the lookup hash
        algo_name = 'Ez2 Control'
        # NOTE: if no algorithm description is present this key should be set
        #       to 'Algorithm (0x4000D)' for the tests to pass (see known issues).
        Conf.set( :Firmware_names, {algo_name => 'FIRMWARE_FLORIDA_EZ2CONTROL'} )

        # reset the device
        wisce.usecase_from_file( 'Reset_paths' )

        # There is no firmware on a reset device, iterate through and check.
        is_loaded = wisce.is_firmware_loaded?(  algo_name,{ 'revision' => nil,
                                                            'version' => nil,
                                                            'dsp_core' => nil
                                                          }
                                             )
        assert( !is_loaded, 'There should be no firmware intially loaded after device reset.' )

        # load firmware onto device using a usecase file
        # For this test case it should load Ez2 Control 0.22.0 onto DSP2
        wisce.usecase_from_file( 'IN2LR_to_HPOUT1_147MHz' )
        wisce.load_firmware_from_usecase( 'dsp2_scc_firmware', 1 )

        # iterative check for firmware across cores
        is_loaded = wisce.is_firmware_loaded?( algo_name,{  'revision' => nil,
                                                            'version' => nil,
                                                            'dsp_core' => nil
                                                         }
                                             )
        assert( is_loaded, 'There should be firmware loaded on the device.' )

        # Check a specific core for firmware, in this case it should have firmware loaded.
        is_loaded = wisce.is_firmware_loaded?( algo_name, { 'revision' => nil,
                                                            'version' => nil,
                                                            'dsp_core' => 1
                                                          }
                                             )
        assert( is_loaded, 'There should be firmware loaded on DSP2 if the device.' )

        # Check a specific core for firmware, in this case it should have no firmware loaded.
        is_loaded = wisce.is_firmware_loaded?( algo_name, { 'revision' => nil,
                                                            'version' => nil,
                                                            'dsp_core' => 2
                                                          }
                                             )
        assert( !is_loaded, 'There should be no such firmware on DSP3.' )

        # versioning
        is_loaded = wisce.is_firmware_loaded?( algo_name,{  'revision' => nil,
                                                            'version' => '0.16.0',
                                                            'dsp_core' => 1
                                                         }
                                             )
        assert( !is_loaded, 'This revision should not be on the device.' )
        is_loaded = wisce.is_firmware_loaded?( algo_name,{  'revision' => nil,
                                                            'version' => '0.22.0',
                                                            'dsp_core' => 1
                                                         }
                                             )
        assert( is_loaded, 'This revision should be on the device.' )

        # None of the cores should be running.
        assert( !wisce.is_dspcore_running?( 0 ), 'DSP1 should not be running.' )
        assert( !wisce.is_dspcore_running?( 1 ), 'DSP2 should not be running.' )
        assert( !wisce.is_dspcore_running?( 2 ), 'DSP3 should not be running.' )
        assert( !wisce.is_dspcore_running?( 3 ), 'DSP4 should not be running.' )

        # Attempt to start a core with firmware loaded on it.
        assert( wisce.start_firmware( algo_name, nil, '0.22.0', 1 ),
                                'DSP2 should have started successfully.' )
        assert( wisce.is_dspcore_running?( 1 ), 'DSP2 should now be running.' )

        # Attempt to start a core with no firmware loaded on it.
        assert( !wisce.start_firmware( algo_name, nil, nil, 0 ),
                        'DSP1 should fail to start running (as no firmware loaded).' )
    end

    #######################################################################
    # @function test_WISCE_firmware_lookup
    #
    # Test that firmware names are correctly looked up from the config file.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_firmware_lookup
        wisce = FruitSalad::WISCESalad.new( false, false )
        algo_name = 'Ez2 Control'

        Conf.set( :Firmware_names, nil )
        assert_raise do
            Conf.hash_lookup_value( :Firmware_names, algo_name )
        end
        Conf.set( :Firmware_names, {} )
        assert_raise do
            Conf.hash_lookup_value( :Firmware_names, algo_name )
        end
        Conf.set( :Firmware_names, {algo_name => "FIRMWARE_FLORIDA_EZ2CONTROL"} )
        lookup = Conf.hash_lookup_value( :Firmware_names, algo_name )

        assert_equal( 'FIRMWARE_FLORIDA_EZ2CONTROL', lookup, "Lookup name should match." )
    end

    #######################################################################
    # @function test_base_firmware_pending
    #
    # Calling any of the firmware methods from the base class should result
    # in a Cucumber::pending exception.
    #
    # These methods are:
    #   is_firmware_loaded?
    #   load_firmware
    #   start_firmware
    #
    # (no parameters)
    #
    #######################################################################
    def test_base_firmware_pending
        base = FruitSaladBase::DeviceInterface.new

        assert_raise Cucumber::Pending do
            base.is_firmware_loaded?( '',{} )
        end
        assert_raise Cucumber::Pending do
            base.load_firmware( '', '' )
        end
        assert_raise Cucumber::Pending do
            base.start_firmware( '', '', '' )
        end
    end

    #######################################################################
    # @function test_meaningful_WMResult_codes
    #
    # Check that WISCE_CONST::WM_RESULT_WMR* codes are correctly indexed and
    # looked up for more meaningful error codes.
    #
    # There is a Wolfson.WMResult.WMResultString method that does this, but
    # it doesn't seem to be exposed through the automation API. It exists in
    # the OLE type library, but its methods are not callable.
    #
    # (no parameters)
    #
    #######################################################################
    def test_meaningful_WMResult_codes
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect_simulated( 'SimulatedSystem', 'WM8280', 'WM8280_RegMap_RevD.wxd' )

        assert_equal( 'WM_RESULT_WMR_SUCCESS', wisce.lookup_WMResult( 0 ) )
        assert_equal( 'WM_RESULT_WMR_REG_NOT_PRESENT', wisce.lookup_WMResult( -55 ) )
        assert_equal( 'WM_RESULT_WMR_READ_ONLY', wisce.lookup_WMResult( -57 ) )
    end

    #######################################################################
    # @function test_meaningful_WM_COMMS_PROTOCOL_codes
    #
    # Check that WISCE_CONST::WM_COMMS_PROTOCOL_* codes are correctly indexed and
    # looked up for more meaningful information.
    #
    # (no parameters)
    #
    #######################################################################
    def test_meaningful_WM_COMMS_PROTOCOL_codes
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect_simulated( 'SimulatedSystem', 'WM8280', 'WM5110_RegMap_RevD.wxd' )

        assert_equal( 'WM_COMMS_PROTOCOL_P_SMBUS_32INX_16DAT',    wisce.lookup_WMProtocol( 27 ) )
        assert_equal( 'WM_COMMS_PROTOCOL_P_SPI_32IX_16DAT_4WIRE', wisce.lookup_WMProtocol( 28 ) )
        assert_equal( 'WM_COMMS_PROTOCOL_P_UNKNOWN',              wisce.lookup_WMProtocol( 65535 ) )
    end

    #######################################################################
    # @function test_WISCE_read_element_simulated
    #
    # Testing element lookup on a simulated device.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_read_element_simulated
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect_simulated( 'SimulatedSystem', 'WM8280', 'WM8280_RegMap_RevD.wxd' )
        basic_element_lookup_check( wisce )
    end

    #######################################################################
    # @function test_WISCE_write_element_simulated
    #
    # Testing element write on a simulated device.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_write_element_simulated
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect_simulated( 'SimulatedSystem', 'WM8280', 'WM5110_RegMap_RevD.wxd' )
        basic_element_write_check( wisce )
    end

    #######################################################################
    # @function test_WISCE_write_element_lochnagar
    #
    # Testing element writes on a Lochnagar board.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_write_element_lochnagar
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect( 'Aardvark', 'WM8280' )
        basic_element_write_check( wisce )
    end

    #######################################################################
    # @function basic_element_write_check
    #
    # Simple test for writing element contents by name.
    #
    # Writes and reads values to the IN_RATE field.
    #
    # Tested with WM8280: may work with other devices with the expected element names available.
    #
    # Used by the test methods:
    #    test_WISCE_write_element_simulated
    #
    # @param [WISCESalad] wisce instance pre-connected to a device
    #
    #######################################################################
    def basic_element_write_check( wisce )
        # reset the device
        wisce.usecase_from_file( 'Reset_paths' )

        field_name = 'IN_RATE'
        str_value = wisce.read_element_value( field_name )
        assert_equal( '0', str_value, 'Default value of IN_RATE has changed from what was expected.' )

        wisce.write_element_value( field_name, 1 )

        str_value = wisce.read_element_value( field_name )
        assert_equal( '1', str_value, 'Default value of IN_RATE has changed from what was expected.' )

        wisce.write_element_value( field_name, 2 )

        str_value = wisce.read_element_value( field_name )
        assert_equal( '2', str_value, 'Default value of IN_RATE has changed from what was expected.' )

        assert_raise do
            wisce.write_element_value( field_name, 'ZZZ' )
        end

        field_name = 'SAMPLE_RATE_1'
        wisce.write_element_value( field_name, 'Bh' )
        str_value = wisce.read_element_value( field_name )
        assert_equal( '0B', str_value, 'Default value of SAMPLE_RATE_1 has changed from what was expected.' )
    end

    #######################################################################
    # @function test_WISCE_read_element_lochnagar
    #
    # Testing element lookup on a Lochnagar board.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_read_element_lochnagar
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect('Aardvark', 'WM8280')
        basic_element_lookup_check( wisce )
    end

    #######################################################################
    # @function test_WISCE_check_core_within_range
    #
    # Testing check_core_within_range correctly throws exceptions when given
    # out of bounds DSP core indices.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_check_core_within_range
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect_simulated( 'SimulatedSystem', 'WM8280', 'WM8280_RegMap_RevD.wxd' )

        # there are 4 cores on the device
        assert_nothing_raised 'Exception raised from valid core index.' do
            wisce.check_core_within_range( 0 )
        end
        assert_nothing_raised 'Exception raised from valid core index.' do
            wisce.check_core_within_range( 1 )
        end
        assert_nothing_raised 'Exception raised from valid core index.' do
            wisce.check_core_within_range( 2 )
        end
        assert_nothing_raised 'Exception raised from valid core index.' do
            wisce.check_core_within_range( 3 )
        end

        assert_raise('Invalid core selection did not throw an exception.') do
            wisce.check_core_within_range( nil )
        end
        assert_raise('Invalid core selection did not throw an exception.') do
            wisce.check_core_within_range( -1 )
        end
        assert_raise('Invalid core selection did not throw an exception.') do
            wisce.check_core_within_range( 4 )
        end
    end

    #######################################################################
    # @function basic_element_lookup_check
    #
    # Simple test for the lookup and read element contents by name.
    #
    # Checks for 'DRC2 ctrl1' and 'FIRMWARE_FLORIDA_EZ2CONTROL_TRIGGER_PHRASE_FOUND_COUNTER'
    #
    # Tested with WM8280: may work with other devices with the expected element names available.
    #
    # Used by the test methods:
    #    test_WISCE_read_element_simulated
    #    test_WISCE_read_element_lochnagar
    #
    # @param [WISCESalad] wisce instance pre-connected to a device
    #
    #######################################################################
    def basic_element_lookup_check( wisce )
        reg_name = 'DRC2 ctrl1'
        use_case = 'drc_settings'

        # reset the device
        wisce.usecase_from_file( 'Reset_paths' )

        str_value = wisce.get_default_element_value( reg_name )
        assert_equal( '0018', str_value, "Default value of #{reg_name} has changed from what was expected." )
        str_value = wisce.read_element_value( reg_name )
        assert_equal( '0018', str_value, "Value of #{reg_name} has changed from the default expected." )
        wisce.usecase_from_file( use_case )
        str_value = wisce.read_element_value( reg_name )
        assert_equal( 'C042', str_value, "drc_settings use case value for #{reg_name}" )

        # reset the device
        wisce.usecase_from_file( 'Reset_paths' )

        # Now look up the Trigger Phrase counter
        # Without algorithm descriptions present, this will not be found even if loaded
        # onto the device.
        field_name = 'FIRMWARE_FLORIDA_EZ2CONTROL_TRIGGER_PHRASE_FOUND_COUNTER'

        str_value = wisce.read_element_value( field_name )
        assert( str_value.nil?, 'Firmware not loaded yet, so this field should not yet exist.')
        str_value = wisce.read_element_value( field_name )
        assert( str_value.nil?, 'Element should not have been created when not found.')
        # setup clocking and load in firmware.
        wisce.usecase_from_file( 'IN2LR_to_HPOUT1_147MHz' )
        wisce.usecase_from_file( 'dsp3_clocking' )
        wisce.usecase_from_file( 'drc_settings' )
        wisce.load_firmware_from_usecase( 'dsp3_scc_firmware', 2 )

        str_value = wisce.read_element_value( field_name )
        assert( !str_value.nil?, "Requested field '#{field_name}' could not be found.")
        assert_equal( '000000', str_value, "drc_settings use case value for #{field_name}" )
    end

    #######################################################################
    # @function test_component_lochnagar
    #
    # Simple test of the soundclear_control component for encapsulating firmware.
    #
    # (no parameters)
    #
    #######################################################################
    def test_component_lochnagar
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect('Aardvark', 'WM8280')
        wisce.usecase( :reset )
        wisce.usecase( 'IN2LR_to_HPOUT1_147MHz' )
        dsp_core_index = 2
        wisce.soundclear_control.load( dsp_core_index )
        assert( !wisce.soundclear_control.triggered?, 'SoundClear Control should not have been triggered.' )
    end

    #######################################################################
    # @function test_WISCE_LoadFirmware_lochnagar
    #
    # Test that a firmware can be loaded directly using a wmfw file.
    #
    # Requires WISCE V3.3+ to resolve issues with dependencies of the
    # LoadFirmware automation method on System.Windows.Forms.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_LoadFirmware_lochnagar
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect('Aardvark', 'WM8280')
        wisce.usecase( :reset )
        # setup clocking and load in firmware.
        dsp_core_index = 2
        wisce.usecase_from_file( 'dsp3_clocking' )
        wisce.usecase_from_file( 'drc_settings' )
        firmware_filename = 'resources/florida-dsp3-ez2-control.wmfw'
        assert( wisce.load_firmware( firmware_filename, dsp_core_index ) )

        field_name = 'FIRMWARE_FLORIDA_EZ2CONTROL_TRIGGER_PHRASE_FOUND_COUNTER'
        str_value = wisce.read_element_value( field_name )
        assert( !str_value.nil?, "Requested field '#{field_name}' could not be found.")
        assert_equal( '000000', str_value, "drc_settings use case value for #{field_name}" )

        firmware_filename = 'test/no_such_file.wmfw'
        assert_raise('Firmware file does not exist.') do
            wisce.load_firmware( firmware_filename, dsp_core_index )
        end

    end

    #######################################################################
    # @function test_WISCE_SPI_reset_lochnagar
    #
    # Test that a device can be setup, enable SPI and trigger a re-detect.
    #
    # The device should not lose its settings.
    #
    # Resolution: It turns out this was due to bent pins on the Lochnagar board.
    #
    # N.B. This test is changing values on the FPGA (WM0050) that will not be
    # reset as standard by the :reset usecase (which software resets the device only).
    # Hence the rescue and re-throw of the assertion exception once SPI has been disabled.
    #
    # (no parameters)
    #
    #######################################################################
    def test_WISCE_SPI_reset_lochnagar
        wisce = FruitSalad::WISCESalad.new( false, false )
        wisce.connect('Aardvark', 'WM8280')

        #
        # Ensure that SPI is disabled or the bug will surface before a
        # known state can be established. Operates on the FPGA (WM0050).
        #
        wisce.usecase_from_file( 'DisableLochnagarSPI' )

        wisce.usecase( :reset )

        wisce.usecase_from_file( 'EnableLochnagarSPI' )
        wisce.usecase_from_file( 'IN2LR_to_HPOUT1_147MHz' )


        assert_field_equals( wisce, 'OUT1LMIX_SRC1', '12' )
        assert_field_equals( wisce, 'OUT1RMIX_SRC1', '13' )

        wisce.connect('Aardvark', 'WM8280')

        #
        # if the SPI bug is still present, these fields will be
        # reset to 00. If an incorrect, do not forget to turn SPI off.
        #
        exception = nil
        begin
            assert_field_equals( wisce, 'OUT1LMIX_SRC1', '12' )
            assert_field_equals( wisce, 'OUT1RMIX_SRC1', '13' )
        rescue Exception => e
            exception = e
        end

        wisce.usecase_from_file( 'DisableLochnagarSPI' )
        unless exception.nil?
            raise exception
        end
        wisce.usecase_from_file( 'EnableLochnagarSPI' )
    end

    #######################################################################
    # @function assert_field_equals
    #
    # Assert that a field should contain a specific value.
    #
    # @param wisce          WISCE™ instance to lookup from.
    # @param field_name     Field name to lookup.
    # @param expected_value Value that should be returned from the field.
    #
    # @raise Will propagate an assertion exception if condition is not met.
    #
    #######################################################################
    def assert_field_equals( wisce, field_name, expected_value )
        str_value = wisce.read_element_value( field_name )
        assert_equal( expected_value, str_value, "#{field_name} not set to expected value" )
    end
end
################################### END OF FILE ###########################