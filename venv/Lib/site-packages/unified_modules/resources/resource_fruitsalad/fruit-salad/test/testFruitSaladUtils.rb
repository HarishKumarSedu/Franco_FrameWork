################################################################################
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   testFruitSaladUtils.rb
### @brief  Tests of FruitSalad utility methods.
###
### @version \$Id: testFruitSaladUtils.rb 896 2015-02-25 14:19:47Z emmas $
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

# ensure that the gem version of test-unit is loaded
# otherwise the report generation will not occur.
gem 'test-unit'
require 'test/unit'

require_relative '../src/fruitsalad_env_setup.rb'
require 'fruitsalad_utils'
require 'tone_generator'
require 'wavefile_analyzer'

exit unless ENV['TARGET'].nil?

#######################################################################
# Class: TestFruitUtils
#
# Test case for the utility methods in the FruitSaladUtils module.
#
#######################################################################
class TestFruitUtils < Test::Unit::TestCase
    include ToneGenerator
    include WavefileAnalyzer

    #######################################################################
    # @function test_dBFS_to_f
    #
    # Check that the dBFS_to_f method converts values correctly.
    #
    # (no parameters)
    #
    #######################################################################
    def test_dBFS_to_f
        # full-scale, upper limit
        assert_equal(  1, FruitSaladUtils::dBFS_to_f( 0 ) )

        # scalar calculation
        expected = 0.1
        assert_equal( expected, FruitSaladUtils::dBFS_to_f( -20 ) )
        assert_equal( expected, FruitSaladUtils::dBFS_to_f( -20.0 ) )

        # fractional calculation
        expected = 1/Math.sqrt(10)
        assert_equal( expected, FruitSaladUtils::dBFS_to_f( -10 ) )
        assert_equal( expected, FruitSaladUtils::dBFS_to_f( -10.0 ) )
    end

    ###########################################################################
    #
    # @function test_calculate_noise_from_snr_and_signal
    #
    # When calculating the noise amplitude required to satisfy some desired SNR
    # relationship with a signal verify we get sensible answers.
    #
    # (no parameters)
    #
    ###########################################################################
    def test_calculate_noise_from_snr_and_signal
        # Given SNR_db = -1 and A_signal = 0.5. Then A_noise = 0.561...
        noise = FruitSaladUtils::noise_amplitude_from_snr( -1, 0.5 )
        assert_equal( 0.561, noise.round( 3 ) )

        # Given SNR_db = 0 and A_signal = 0.5. Then A_noise = 0.5
        noise = FruitSaladUtils::noise_amplitude_from_snr( 0, 0.5 )
        assert_equal( 0.5, noise )

        # Given SNR_db = 5 and A_signal = 0.5. Then A_noise = 0.281...
        noise = FruitSaladUtils::noise_amplitude_from_snr( 5, 0.5 )
        assert_equal( 0.281, noise.round( 3 ) )

        # Given SNR_db = 5 and A_signal = 0.2. Then A_noise = 0.112...
        noise = FruitSaladUtils::noise_amplitude_from_snr( 5, 0.2 )
        assert_equal( 0.112, noise.round( 3 ) )
    end

    ###########################################################################
    #
    # @function test_lead_in_lead_out_on_file
    #
    # Generate a 1 second sine wave. Then apply a lead in time of 3 seconds,
    # and a lead out time of 1 second. Then verify the overall length is 5 seconds.
    #
    # (no parameters)
    #
    ###########################################################################
    def test_lead_in_lead_out_on_file
        sine_file = generate_sinewave( 10, 1 )
        file = FruitSaladUtils::pad_with_lead_in_lead_out( sine_file, 3, 1 )

        assert_equal( 5, track_length( file ) )
    end

    ###########################################################################
    #
    # @function test_chop_at_random_location
    #
    # Generate a 10 second sine wave. Then chop that for 2 seconds
    # Then verify the chopped file length is 2 seconds. Also verifying
    # whether the start point is also taken correctly.
    #
    # (no parameters)
    #
    ###########################################################################
    def test_chop_at_random_location
        sine_file = generate_sinewave( 10, 10 )
        out_duration = 3
        duration_mismatch = 'Track length is not matching with input duration'
        start_point_mismatch = 'Track start point is not matching with given start point'

        # Check for generated output with given length
        filename1, start_point1 = FruitSaladUtils::chop_at_random_location(
                                  sine_file,
                                  out_duration:out_duration
                                 )
        assert_equal( out_duration, track_length( filename1 ), duration_mismatch )

        # Check for start_point taken correctly
        filename2, start_point2 = FruitSaladUtils::chop_at_random_location(
                                  sine_file,
                                  out_duration:out_duration,
                                  start_point:start_point1
                                 )
        assert_equal( start_point2, start_point1, start_point_mismatch )

        # Check for partial buffer start
        out_duration = 0.01
        start_point = 5150
        filename3, start_point3 = FruitSaladUtils::chop_at_random_location(
                                  sine_file,
                                  out_duration:out_duration,
                                  start_point:start_point
                                 )
        assert_equal( out_duration, track_length( filename3 ), duration_mismatch )

        # Check for partial buffer end
        out_duration = 3.02
        start_point = 5120
        filename4, start_point4 = FruitSaladUtils::chop_at_random_location(
                                  sine_file,
                                  out_duration:out_duration,
                                  start_point:start_point
                                 )
        assert_equal( out_duration, track_length( filename4 ), duration_mismatch )

        # Check for full buffer
        out_duration = 0.128
        start_point = 5120
        filename5, start_point5 = FruitSaladUtils::chop_at_random_location(
                                  sine_file,
                                  out_duration:out_duration,
                                  start_point:start_point
                                 )
        assert_equal( out_duration, track_length( filename5 ), duration_mismatch )

        # Check for Exception raise
        assert_raise RuntimeError do
            out_duration = 10.1
            FruitSaladUtils::chop_at_random_location(
                             sine_file,
                             out_duration:out_duration
                            )
        end
    end
end
################################### END OF FILE ###########################
