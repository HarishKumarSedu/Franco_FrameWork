#!/usr/bin/ruby
# encoding: utf-8
################################################################################
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   test_fft.rb
### @brief  Testing fft.
###
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################
# ensure that the gem version of test-unit is loaded
# otherwise the report generation will not occur.
gem 'test-unit'
require 'test/unit'

require_relative '../src/fruitsalad_env_setup.rb'
require 'wavefile_analyzer.rb'
require_relative '../src/fruitsalad_utils.rb'

include WavefileAnalyzer

exit unless ENV['TARGET'].nil?

class TestFFT < Test::Unit::TestCase
    ###########################################################################
    # @function generate_sinewave
    #
    # Helper method. Generates a sine wave.
    #
    # @param [Float] frequency   Frequency in Hz.
    # @param [Float] length      Length in seconds.
    # @param [Float] sample_rate Sample rate in Hz.
    #
    # @return [Array] An array representing the generated signal.
    #
    ###########################################################################
    def generate_sinewave( frequency, length, sample_rate )
        waveform = []

        (0...(sample_rate*length).to_i ).each do |i|
            waveform[i] = Math::sin( 2.0*Math::PI * (i+1).to_f * frequency.to_f / sample_rate.to_f )
        end

        waveform
    end

    ###########################################################################
    # @function calculate_frequency
    #
    # Helper method. Calculates frequency of a given waveform (assumed to be a
    # sine wave) based on it's fft.
    #
    # @param [Array] wave        An array representing a sine wave signal.
    # @param [Float] sample_rate Sample rate in Hz.
    #
    # @return [Float] Calculated frequency in Hz.
    #
    ###########################################################################
    def calculate_frequency( wave, sample_rate )
        window = WavefileAnalyzer::hamming_window( wave.length )
        wave = wave.zip( window )
        wave.map! { |xs| xs[0]*xs[1] }
        fft = NativeFFT::fft( wave )
        fft = fft[0...fft.length/2]
        fft.map! { |x| x.abs }
        k = WavefileAnalyzer.arg_max( fft )

        k.to_f * sample_rate.to_f / (fft.length.to_f*2.0)
    end

    ###########################################################################
    # @function perform_fft_test_for
    #
    # Helper method. Asserts if the calculated frequency of a generated
    # sine wave matches its original frequency within a tolerance of 0.5 Hz.
    #
    # @param [Float] frequency   Frequency in Hz.
    # @param [Float] length      Length in seconds.
    # @param [Float] sample_rate Sample rate in Hz.
    #
    # @return void
    #
    ###########################################################################
    def perform_fft_test_for( frequency, time, sample_rate)
        sinewave = generate_sinewave( frequency, time, sample_rate )
        fft_frequency = calculate_frequency( sinewave, sample_rate )

        assert_in_delta( frequency,
                         fft_frequency,
                         0.5,
                         "For a #{time} s #{frequency} Hz sinewave sampled at"\
                         " #{sample_rate} calculated frequency was "\
                         "#{fft_frequency} Hz"
                       )
    end

    ###########################################################################
    # @function testFFT
    #
    # Test method. Performs a series of FFT tests for sine waves sampled at
    # different sample rates and of different durations and frequencies.
    #
    # (no parameters)
    #
    ###########################################################################
    def testFFT
        sample_rates = [ 44100.0, 48000.0, 88200.0, 96000.0 ]
        times = [ 1.0, 5.0 ]
        frequencies = [ 100.0, 440.0, 1000.0, 3400.0, 10000.0 ]
        sample_rates.each do |sample_rate|
            times.each do |time|
                frequencies.each do |frequency|
                    perform_fft_test_for( frequency, time, sample_rate )
                end
            end
        end
    end

    ###########################################################################
    # @function test_convert_fft_options
    #
    #
    # Checks that FFT options are correct processed and that errors are raised when
    # no suitable options have been parsed from the string.
    #
    # (no parameters)
    #
    ###########################################################################
    def test_convert_fft_options
        # default set correctly
        options_hash = FruitSaladUtils::convert_fft_options( '' )
        assert_equal( {:error => 0.5}, options_hash )

        # valid options
        options_hash = FruitSaladUtils::convert_fft_options('with error 5 Hz' )
        assert_equal( {:error => 5}, options_hash )

        options_hash = FruitSaladUtils::convert_fft_options('with threshold -24 dB' )
        assert_equal( {:error => 0.5, :threshold => -24}, options_hash )

        options_hash = FruitSaladUtils::convert_fft_options('with error 5 Hz and threshold -12 dB' )
        assert_equal( {:error => 5, :threshold => -12}, options_hash )

        # non-negative error raises an exception
        assert_raise_with_message( RuntimeError, 'Error value should be non-negative, found: "-5.0"' ) do
            options_hash = FruitSaladUtils::convert_fft_options('with error -5 Hz')
        end

        # no valid options found in a non-whitespace input
        assert_raise_with_message( RuntimeError, 'No recognised FFT options in string "blah" matching regex "(?-mix:(?:and|with) (error|threshold) ((?-mix:-?\\d+(?:\\.\\d+)?(?:e[\\+-]?\\d+)?)) (?:Hz|dB)?)"') do
            options_hash = FruitSaladUtils::convert_fft_options( 'blah' )
        end
    end

    ###########################################################################
    # @function test_find_phase_diff
    #
    # Checks that the calculation of phase difference between the channels of the
    # stream is calculated correctly.
    #
    # (no parameters)
    #
    ###########################################################################
    def test_find_phase_diff
        phase_difference = find_phase_diff?( 'resources/sine_1000.wav' )
        assert( phase_difference <= 0.07, "The phase difference is too high" )
        phase_difference = find_phase_diff?( 'resources/sine_1000_high_phase.wav' )
        assert( phase_difference > 0.07, "The phase difference is too low" )
    end

    ###########################################################################
    # @function assert_raise_with_message
    #
    # Helper method to check that raised excpetions carry the expected error message.
    #
    # @param type The expected Exception type.
    # @param [String] message the expected error message
    # @yield Code block to execute and check for the expected exception.
    #
    # @raise Propagates assertion failures if an exception was not caught, or the expected message differs.
    #
    ###########################################################################
    def assert_raise_with_message( type, message, &block )
        caught = false
        begin
            block.call
        rescue type => e
            caught = true
            assert_equal( message, e.to_s, 'Expection message differed from what was expected.' )
        end
        assert(caught, 'Call failed to raise expected exception.')
    end
end
################################### END OF FILE ###############################