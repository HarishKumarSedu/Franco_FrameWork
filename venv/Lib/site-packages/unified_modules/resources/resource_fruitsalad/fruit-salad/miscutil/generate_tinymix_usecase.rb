#!/usr/bin/ruby
# encoding: utf-8
###############################################################################
###
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   generate_tinymix_usecase.rb
### @brief  A utility script generating a *.csv use case based on tinymix
###         output.
###
### @version \$Id: generate_tinymix_usecase.rb 1034 2015-05-08 13:00:08Z piotrs $
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

###############################################################################
#
# Encapsulates functionality needed to parse the output of invoking 'tinymix'
# without any parameters (i.e. current state of the entire mixer) and convert
# it into a *.csv use case file which can be used by Fruit Salad.
#
###############################################################################
class UsecaseGenerator
    CONTROL_PATTERN = /\d+\t(?<type>\w+)\t(?<count>\d+)\t(?<name>\S+          \
                      (?:[ ]\S+)*)\s+(?<value>.*)/x

    ###########################################################################
    #
    # @function enclose_in_quotes
    #
    # Encloses string in quotes if it contains spaces.
    #
    # @param [String] string A string.
    #
    # @return [String] The input string enclosed in quotes.
    #
    ###########################################################################
    def enclose_in_quotes( string )
        if string.include?( ' ' )
            "\"#{string}\""
        else
            string
        end
    end

    ###########################################################################
    #
    # @function parse_bool_value
    #
    # Parses a bool printed by tinymix.
    #
    # @param [String] value A string representing a valid bool control value.
    #
    # @return [Fixnum] A numeric representation of the input value.
    #
    # @raise [ArgumentError] An error is raised if the input value is not
    #                        a valid bool control value.
    #
    ###########################################################################
    def parse_bool_value( value )
        case value
        when /(?:[Oo]n)|1/, 1
            1
        when /(?:[Oo]ff)|0/, 0
            0
        else
            raise ArgumentError, "#{value} is not a valid BOOL control value."
        end
    end

    ###########################################################################
    #
    # @function split_value
    #
    # Splits a string along any number of whitespace characters.
    #
    # @param [String] value A string to be split.
    #
    # @return [Array<String>] An array of strings.
    #
    ###########################################################################
    def split_value( value )
        value.split( /\s+/ )
    end

    ###########################################################################
    #
    # @function split_byte_value
    #
    # Splits a byte control value into constituent bytes.
    #
    # @param [String] value A byte control value.
    #
    # @return [Array<String>] An array of strings representing each byte in the
    #                         control.
    #
    # @raise [ArgumentError] An error is raised if the input string does not
    #                        represent a valid byte control value.
    #
    ###########################################################################
    def split_byte_value( value )
        values = value.scan( /[\da-fA-F]{2}/ )
        if values.length != value.length/2.0
            raise ArgumentError, "Byte control value is expected to be a "    \
                                 "contiguous string of pairs of hex values."
        end
        values
    end

    ###########################################################################
    #
    # @function validate_count
    #
    # Validate that a given control has the expected amount of values.
    #
    # @param [Fixnum] expected control count.
    # @param [Fixnum] actual control count.
    # @param [String] control_name of the validated control.
    #
    # @raise [RuntimeError] An exception is raised if the expected count does
    #                       not match the actual.
    #
    ###########################################################################
    def validate_count( expected, actual, control_name )
        if expected != actual
            raise "Count of parsed values - #{actual} - for control "         \
                  "#{control_name} doesn't match the expected count "         \
                  "- #{expected}."
        end
    end

    ###########################################################################
    #
    # @function parse_control
    #
    # Parses a string representing a tinymix control.
    #
    # @param [String] string representing a tinymix control.
    #
    # @return [Array] An array containing the control name followed by its
    #                 values, or an empty array if the input string does not
    #                 represent a tinymix control.
    #
    # @raise [ArgumentError] An exception is raised if the input string looks
    #                        like a tinymix control but its type
    #                        is not recognized.
    #
    ###########################################################################
    def parse_control( string )
        control = []

        match = CONTROL_PATTERN.match( string )
        if !match.nil?
            name = match[:name]
            value = match[:value]
            count = match[:count].to_i
            control << enclose_in_quotes( name )
            case match[:type].to_sym
            when :ENUM
                control << enclose_in_quotes( value )
            when :INT
                values = split_value( value )
                validate_count( count, values.length, name )
                values.map! { |v| v.to_i }
                control.concat( values )
            when :BOOL
                values = split_value( value )
                validate_count( count, values.length, name )
                values.map! { |v| parse_bool_value( v ) }
                control.concat( values )
            when :BYTE
                values = split_byte_value( value )
                validate_count( count, values.length, name )
                values.map! { |v| v.hex }
                control.concat( values )
            else
                raise ArgumentError, 'Unknown control type.'
            end
        end

        control
    end

    ###########################################################################
    #
    # @function parse_tinymix_output
    #
    # Parses a file containing the result of calling `tinymix` and saves its
    # contents as a *.csv usecase
    #
    # @param [String] in_file_name  Name of the file to parse.
    # @param [String] out_file_name Name of the output file (if it does not
    #                               end in *.csv, the extension will
    #                               be appended).
    #
    ###########################################################################
    def parse_tinymix_output( in_file_name, out_file_name )
        tinymix_output = File.open( in_file_name, 'r' )
        unless out_file_name.end_with?( '.csv' )
            out_file_name += '.csv'
        end
        usecase = File.open( out_file_name, 'w' )

        tinymix_output.each_line do |line|
            control = parse_control( line )
            if !control.empty?
                usecase.write( "#{control.join( ',' )}\n" )
            end
        end

        usecase.close
        tinymix_output.close
    end
end

if __FILE__ == $0
    if 2 == ARGV.length
        in_file_name = ARGV[0]
        out_file_name = ARGV[1]
        generator = UsecaseGenerator.new
        generator.parse_tinymix_output( in_file_name, out_file_name )
    else
        puts "usage: ruby #{__FILE__} <in_file> <out_file>\n\n"               \
             "    <in_file>  - a file containing the output of `tinymix`\n"   \
             "    <out_file> - name of the usecase to save (if the name\n"    \
             "                 does not end in *.csv the extension will be\n" \
             "                 appended)"
    end
end
#################################### END OF FILE ##############################
