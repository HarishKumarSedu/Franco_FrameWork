###############################################################################
###
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   win_driver_test_api.rb
### @brief  FFI bindings for WinDriverTestAPI.DLL
###
### @version \$Id: win_driver_test_api.rb 972 2015-03-26 12:48:28Z aangus $
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################
#
# Includes
#
require 'ffi'
require 'portaudio_client'
require 'configuration'
require 'logfw'

###############################################################################
#
# Namespace for functionality common to both the remote and local WinDriverTestAPI
#
###############################################################################
module CommonWinDriverTestAPI

    # Milliseconds in a second
    Milliseconds = 1e3

    # Location into which files are uploaded by default.
    TempDir = Conf.property( :Remote_TempDir, 'C:/fruit_salad_temp/' )

    # Our SSH session, used to connect to and control the test target.
    attr_accessor :session

    ###########################################################################
    #
    # @function wait_until_state
    #
    # Wait until a transition to the named state has occured. If this does not
    # occur within the timeout period then a runtime exception will be generated.
    #
    # @param [Integer] state   The state you are expecting to transition into.
    # @param [Integer] timeout The maximum time to wait for a transition,
    #                          expressed in milliseconds.
    #
    ###########################################################################
    def wait_until_state(state, timeout)
        start = Time.new
        $LOG.info "Waiting"
        while state.to_i != codec_device_power_state.to_i do
            now = Time.new
            if (now - start).to_f*Milliseconds > timeout.to_f
                raise "Timeout reached, state is #{codec_device_power_state}"
            end
            sleep 1
            $LOG.info "."
        end
        $LOG.debug "State D#{codec_device_power_state.to_i} reached after #{Time.new-start} seconds."
        return
    end

    ###########################################################################
    #
    # @function get_channel_number
    #
    # Convert a user-friendly channel name string (e.g. 'left') into its system
    # enumeration.
    #
    # @param [String]   channel_names   Name of the property in the configuration
    #                                   file which defines the mappings from
    #                                   strings to integers.
    # @param [String]   channel         The user-friendly name of the channel.
    #
    # @return [Fixnum]  The enumeraton of the channel.
    #
    ###########################################################################
    def get_channel_number( channel_names, channel )
        channel_names = Conf::property( channel_names, nil )
        if channel.is_a? Fixnum
            channel_number = channel
        else
            channel_number = channel_names.fetch( channel.to_sym, nil )
            if nil == channel_number
                raise "Channel #{channel} is undefined."
            end
        end
        return channel_number
    end

    ###########################################################################
    #
    # @function codec_device_power_state
    #
    # Obtain the windows power-state of the CODEC device. Valid states are one
    # of D0 through D3, where D0 is the 'fully-on' state and subsequent states use
    # less power. More information is available here:
    # http://msdn.microsoft.com/en-us/library/windows/hardware/ff543162%28v=vs.85%29.aspx
    #
    # @return [Integer] One of 0 through 3 inclusive indicating the power state.
    #
    # @raise [RunTimeError] If an invalid power state is returned by the DLL function.
    #
    ###########################################################################
    def codec_device_power_state
        #
        # The value returned by CodecDevicePowerState is on the interval [1,4]
        # with mappings 1=>D0, 4=>D3. This is off-by-one from what we expect
        # to return here.
        #
        state = exec_binding( "CodecDevicePowerState", [] ) - 1
        raise "Invalid codec state #{state}" if state < 0 || 3 < state
        return state
    end

    ###########################################################################
    #
    # @function set_volume_on_playback_channel
    #
    # Set the volume of one channel of the default playback device.
    #
    # @note These changes persist only as long as the current PortaudioClient
    #       session is held open - once released with PortaudioClient::stop the
    #       per channel volumes will reset.
    #
    # @param [Integer]  channel  The id of the channel to modify. Must be >= 0.
    # @param [Float]    volume   The volume to set that channel to.
    #
    ###########################################################################
    def set_volume_on_playback_channel( channel, volume )
        channel = get_channel_number( "Playback_Channel_Names", channel )
        playback_device = exec_binding( "GetPlaybackDevice" )
        exec_binding( "SetChannelVolume", [playback_device, channel, volume] )
    end

    ###########################################################################
    #
    # @function set_volume_on_capture_channel
    #
    # Set the volume of one channel of the default recording device.
    #
    # @note These changes persist only as long as the current PortaudioClient
    #       session is held open - once released with PortaudioClient::stop the
    #       per channel volumes will reset.
    #
    # @param [Integer]  channel The id of the channel to modify. Must be >= 0.
    # @param [Float]    volume  The volume to set the channel to.
    #
    ###########################################################################
    def set_volume_on_capture_channel( channel, volume )
        channel = get_channel_number( "Recording_Channel_Names", channel )
        capture_device = exec_binding( "GetCaptureDevice" )
        exec_binding( "SetChannelVolume", [capture_device, channel, volume] )
    end

    ###########################################################################
    #
    # @function set_all_playback
    #
    # Set all playback channels to the same volume level.
    #
    # @param [Float] volume The new volume level.
    #
    ###########################################################################
    def set_all_playback( volume )
        playback_device = exec_binding( "GetPlaybackDevice" )
        number_of_channels = exec_binding( "GetChannelCount", [playback_device] )
        (0...number_of_channels).each do |channel|
            exec_binding( "SetChannelVolume", [playback_device, channel, volume] )
        end
    end

    ###########################################################################
    #
    # @function set_all_capture
    #
    # Set all capture channels to the same volume level.
    #
    # @param [Float] volume The new volume level.
    #
    ###########################################################################
    def set_all_capture( volume )
        capture_device = exec_binding( "GetCaptureDevice" )
        number_of_channels = exec_binding( "GetChannelCount", [capture_device] )
        (0...number_of_channels).each do |channel|
            exec_binding( "SetChannelVolume", [capture_device, channel, volume] )
        end
    end

    ###########################################################################
    #
    # @function hibernate_for_duration
    #
    # Trigger Windows into going into Hibernation.
    #
    # @note It takes considerably longer than the requested time to complete the
    #       entire request and patience is recommended.
    #
    # @param [Float] duration How long to remain powered down, in seconds.
    #
    ###########################################################################
    def hibernate_for_duration( duration )
        $LOG.info "Hibernating system. Please wait."
        duration = duration * Milliseconds
        success = exec_binding( "HibernateForDuration", [duration] )
        raise "Failed to complete request (are wake timers enabled?)." if 0 == success
    end

    ###########################################################################
    #
    # @function suspend_for_duration
    #
    # Trigger Windows into going into Suspend.
    #
    # @note It takes considerably longer than the requested time to complete the
    #       entire request and patience is recommended.
    #
    # @param [Float] duration How long to remain powered down, in seconds.
    #
    ###########################################################################
    def suspend_for_duration( duration )
        $LOG.info "Suspending system. Please wait."
        duration = duration * Milliseconds
        success = exec_binding( "SuspendForDuration", [duration] )
        raise "Failed to complete request (are wake timers enabled?)." if 0 == success
    end

    private

    ###########################################################################
    #
    # @function set_volume_on_channel
    #
    # Set the volume on a particular channel of a particular device. Performs
    # some basic bounds checking before calling SetChannelVolume.
    #
    # @param [Object] device    Opaque object specifying the device, as obtained
    #                           by Get<Playback|Capture>Device.
    # @param [Fixnum] channel   The channel to modify.
    # @param [Float]  volume    The new volume level.
    #
    ###########################################################################
    def set_volume_on_channel( device, channel, volume )
        exec_binding( "SetChannelVolume", [channel, volume] )
    end

    ###########################################################################
    #
    # @function third_party_playback
    #
    # Perform playback by launching a third-party program.
    #
    # @param [String]  program  The name of the program to use, i.e. "windows media player".
    # @param [String]  file     The name of the file to play.
    # @param [Integer] duration The length of the file in milliseconds.
    #
    # @raise [RunTimeError] If the program fails to invoke or close successfully.
    # @raise [RunTimeError] If program is not a supported program.
    #
    ###########################################################################
    def third_party_playback( program, file, duration )
        $LOG.debug "Playing #{file} with #{program}."
        case program
        when "wmp"
            program_identifier = exec_binding( "GetWMPIdentifier" )
        when "metro"
            program_identifier = exec_binding( "GetMetroIdentifier" )
        else
            raise "Program not known: #{program}"
        end

        success = 1 == exec_binding( "Playback", [program_identifier, duration, file] )
        raise "Third party playback failed" unless success
    end

    ###########################################################################
    #
    # @function: parse_binding_output
    #
    # Extracts the return value from the given function output. This additionally
    # does a dump of the function call and its entire output for debug purposes.
    #
    # @param [String]   function   The name of the function called.
    # @param [Array]    arguments  The arguments passed to our function.
    # @param [String]   output     The output received from our function.
    #
    # @return [Fixnum] The extracted return value
    #
    # @raise [RunTimeError] If the return value cannot be found in the captured
    #                       output.
    #
    ###########################################################################
    def parse_binding_output( function, arguments, output )
        $LOG.info "#{function} #{arguments}\n#{output}"
        return_value = /Program exited with status (-?\d+)/.match( output )
        raise "Return value not found (possible Segfault?)" unless return_value
        return_value = return_value[1].to_i
        return return_value
    end

end

###############################################################################
#
# Implementation connecting to a remote test target.
#
###############################################################################
module RemoteWinDriverTestAPI
    include CommonWinDriverTestAPI

    ###########################################################################
    #
    # @function: exec_binding
    #
    # Call our win client tool over our SSH session, passing the function name
    # and arguments. The standard out is written to the calling terminal
    # automatically.
    #
    # @param [String]   function_name  The name of the function, in our client tool binding.
    # @param [Array]    arguments_list A list of arguments to pass to the function. Optional.
    #
    # @return [Fixnum] The integer return value of the called binding.
    #
    ###########################################################################
    def exec_binding( function_name, arguments_list=[] )
        output = session.exec! "#{TempDir}windows_remote_client_tool.exe #{function_name} #{arguments_list.join( ' ' )}"
        return parse_binding_output( function_name, arguments_list, output )
    end
end

###############################################################################
#
# Implementation connecting to a local test target.
#
###############################################################################
module LocalWinDriverTestAPI
    include CommonWinDriverTestAPI

    ###########################################################################
    #
    # @function: exec_binding
    #
    # Call our win client tool on the local machine, paassing the function name
    # and arguments into the command line. The standard out is written out
    # automatically.
    #
    # @param [String]   function_name   The name of the function, in our client tool binding.
    # @param [Array]    arguments_list  A list of arguments to pass to the function. Optional.
    #
    # @return [Fixnum] The integer return value of the called binding.
    #
    ###########################################################################
    def exec_binding( function_name, arguments_list=[] )
        output = `windows_remote_client_tool.exe #{function_name} #{arguments_list.join( ' ' )}"`
        return parse_binding_output( function_name, arguments_list, output )
    end
end

###################################### END OF FILE ############################