###############################################################################
###
### Copyright (c) 2014-2017 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   WISCESalad.rb
### @brief  Basic implementation of fruit salad for the WISCE™ interface.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

#
# Includes
#
require 'win32ole'
require 'open3'

#Setting internal default encoding to utf-8
Encoding.default_internal = 'utf-8'

require 'fruitsalad_base'
require 'device_factory'
require 'wavefile_analyzer'
require 'portaudio_client'
require 'configuration'
require 'tone_generator'
require 'fruitsalad_utils'
require 'logfw'
# Algorithm testing components
require 'test_components/soundclear_control_wisce'
require 'wisce_host_buffer_read'
require 'pa_multitrack'
require "test_components/trace_wisce"

################################################################################
#
# Implementation of Fruit Salad for WISCE™ Automation.
#
################################################################################
module FruitSalad

    extend WavefileAnalyzer
    extend FruitSaladDeviceFactory
    extend ToneGenerator

    ############################################################################
    #
    # A module to hold the WISCE™ constants.
    #
    ############################################################################
    module WISCE_CONST
    end

    ############################################################################
    #
    # Device Specialisation
    #
    ############################################################################
    class WISCESalad < FruitSaladBase::DeviceInterface
        ########################################################################
        #
        # The location of the folder containing the WISCE scripts (.txt) that
        # define our usecases.
        #
        #########################################################################
        UsecasePath = Conf.property( :UsecasePath, File.join(ENV['FRUITSALAD_HOME'], 'targets', 'wisce') )
        # Connect to a real or simulated device?
        SimulatedSystem = Conf.property( :WISCE_Simulated, FALSE )
        # When defined, connect to a WISCEBridge host at the given address and port.
        WISCEBridgeAddress = Conf.property( :WISCEBridge_Address, nil )
        # The name of the system we wish to connect to.
        SystemName = Conf.property( :WISCE_SystemName, 'Aardvark' )
        # The name of the device we wish to connect to.
        DeviceNameLochnagar = Conf.property( :WISCE_DeviceNameLochnagar, 'WM0050' )
        # The name of the FPGA device we wish to connect to.
        DeviceNameFPGA = Conf.property( :WISCE_DeviceNameFPGA, nil )
        # The name of the DAXTER FPGA description file to load in for simulated devices.
        FPGAUseCaseFile = Conf.property(:FPGAUseCaseFile, nil)
        # DAXTER FPGA device description file with path.
        Conf.property( :FPGAUseCasePath,nil ) and FPGAUseCasePath = File.join( UsecasePath, Conf.property( :FPGAUseCasePath, nil ))
        # Name of the description file to load in for simulated devices.
        DescriptionNameLochnagar = Conf.property( :WISCE_DescriptionNameLochnagar, 'WM0050_RegMap_RevA.wxd' )
        # The name of the device we wish to connect to.
        DeviceName = Conf.property( :WISCE_DeviceName, 'CS47L35' )
        # The adress of the device we wish to connnect to
        DeviceAddress = Conf.property( :WISCE_DeviceAddress, nil )
        # Name of the description file to load in for simulated devices.
        DescriptionName = Conf.property( :WISCE_DescriptionName, 'CS47L35_RegMap_RevA1.wxd' )
        # Name of the Control Interface Type to set up the device.
        ControlInterfaceType = Conf.property( :WISCE_CONTROL_INTERFACE_TYPE, nil )

        # The list of default usecases to load if one is not specified as part
        # of the scenario. Can be overwritten with the DefaultUsecases config
        # variable.
        DefaultUsecases = Conf.property( :DefaultUsecases, [] )

        # The samplingrate of audio playback and recording.
        SampleRate = Conf.property( :SampleRate, nil )

        # The number of audio channels to open for playback.
        PlaybackChannels = Conf.property( :Playback_Channels, 2 )

        # The number of audio channels to open for recording.
        RecordingChannels = Conf.property( :Recording_Channels, 2 )

        attr_reader :analog_playback_active
        attr_reader :analog_recording_active
        attr_reader :digital_playback_active
        attr_reader :digital_recording_active
        attr_reader :core
        attr_reader :device

        attr_accessor :output
        attr_accessor :trace_output

        # Class variable to hold whether the WISCE™ constants have been loaded.
        @@constants_loaded = false

        # This MACRO is for flash accessDevice ID of Lochnagar2
        EXPECTED_SECONDARY_DEVICE_ID = 0xCB59

        # The size, in bytes, of a single sector of flash (4KB)
         FLASH_SECTOR_BYTE_COUNT = 4*1024

        #list of flash devices
        FLASH_DEVICES = [:MX25R6435F]

        # Constants for number of channels
        MONO_CHANNEL = 1
        STEREO_CHANNEL = 2

        #############################################################################
        # Class Variable
        #
        # Hash storing the WISCE™ Automation Interface Identifiers for interfaces
        # required in the step_definitions.
        # Used when using ole_query_interface methods to access inherited parameters.
        #
        #############################################################################
        @@ole_iid_hash = {  'IDSPAlgorithm' => '{C21556CB-6C53-38EA-BB53-CA6BC3250E72}',
                            'IDataRegion'   => '{707F2D1E-DAED-3168-8F75-02E672A6AEA2}'}

        #########################################################################
        #
        # @function initialize
        #
        # Default constructor.
        #
        # Initialises WISCEAutomation object and auto-detects connected systems.
        # It then sets @system and @device to point to the device we want to
        # test, and sets those as the default devices in WISCE™.
        #
        # As a final step the device will be reset, in preparation for a usecase
        # to be loaded.
        #
        # @param [Boolean] do_connect Attempt to connect to WISCE™ Core
        # @param [Boolean] load_usecases Attempt to load default use cases
        #
        #########################################################################
        def initialize( do_connect = true, load_usecases = true )
            $log_count = 0
            $time_stamp_array = []

            initialize_firmware_components()

            @playback_history = Array.new
            @analog_playback_active = false
            @analog_recording_active = false
            @digital_playback_active = false
            @digital_recording_active = false

            # Connect to the specified system and device
            if do_connect
                # If Simulated system enable_spi is not needed.
                if DeviceNameFPGA
                    #If FPGA device name is found it will connect to FPGA device
                    enable_spi( SystemName, DeviceNameFPGA ) unless SimulatedSystem == true
                else
                    enable_spi( SystemName, DeviceNameLochnagar ) unless SimulatedSystem == true
                end
                if SimulatedSystem
                    connect_simulated(SystemName, DeviceName, DescriptionName)
                elsif WISCEBridgeAddress
                    connect_to_wiscebridge( WISCEBridgeAddress, DeviceName )
                else
                    connect_target_device( :system_name => SystemName, :device_name => DeviceName, :device_address => DeviceAddress, :device_file => DescriptionName, :control_interface_type => ControlInterfaceType )
                end
            end

            # Signify that no usecase files have been loaded
            @usecase_loaded = false
            # Copy our config variable to an instance variable so the base class
            # can see it
            @default_usecases = DefaultUsecases

            usecase( :default ) if load_usecases
        end

        #######################################################################
        #
        # @function initialize_firmware_components
        #
        # Loads the testing component for SoundClear Control.
        #
        # (no parameters)
        #
        #######################################################################
        def initialize_firmware_components
            @soundclear_control = SoundClearControlForWISCE.new( self )
            @host_buffer_read = HostBufferReadForWISCE.new( self )
            @trace = TraceForWISCE.new( self )
        end

        ########################################################################
        # @function connect
        #
        # Establish a connection to the WISCE Automation OLE server and
        # setup the WISCE™ Core to connect to the specified device on
        # a given system.
        #
        # @param [String] system_name Name of the system to connect to.
        # @param [String] device_name Name of the device to connect to.
        # @param [options] optional arguments, this is required when we want
        #                  connect to other than codec device like amplifiers.
        #                  In such case, we can use optional arguments
        #                  :device_address - The address of the device,Ex:0x80
        #                  :device_file - Device file name,
        #                  Ex: CS35L34_RegMap_RevA_0x80.xml
        #                  :control_interface_type - Control interface type,
        #                  Ex: CONTROL_INTERFACE_CTRL_4WIRE
        #
        # @return [String] Diagnostic message of what device and system have
        #                  been connected to.
        #
        # @raise connect_core will raise an exception if it cannot connect
        #        to WISCE™ or the WISCE™ Core.
        #
        ########################################################################
        def connect( system_name, device_name, options={} )
            device_address = options[:device_address]
            description_file = options[:device_file]
            control_interface_type = options[:control_interface_type]
            connect_core
            $LOG.debug "WISCE API - Systems , DetectSystems() Called"
            @core.Systems.DetectSystems()
            $LOG.debug "WISCE API - Systems , Count Called"
            @system_count = @core.Systems.Count
            $LOG.debug "Connected to #{@system_count}  systems."
            raise_if_name_not_found = true
            is_system = true
            if 1 == @system_count
                @system = find_by_name( @core.Systems, system_name,
                                             raise_if_name_not_found, is_system )
            elsif 1 < @system_count
                @system = find_by_name( @core.Systems, system_name,
                                            raise_if_name_not_found, is_system, device_name )
            else
                raise "No System is connected" + $LOG.error("No System is connected").to_s
            end
            $LOG.debug "WISCE API - CurrentSystem Called"
            # Handling WIN32OLERuntimeError, to log the proper error message
            # to understand better about the issue
            begin
                @core.CurrentSystem = @system
            rescue WIN32OLERuntimeError => e
                $LOG.error("#{system_name} not found.")
                $LOG.error(e.to_s)
                raise e
            end
            $LOG.debug "WISCE API - DetectDevices() Called"
            @system.DetectDevices()
            # Find out if a device of this type already exists, if so do not add.
            if device_address != nil and description_file != nil
                $LOG.debug "WISCE API - GetStandardFolder() Called"
                deviceFolder = @core.GetStandardFolder( WISCE_CONST::FolderType_Device )
                raise('Couldn\'t get device folder') if nil == deviceFolder
                $LOG.debug "WISCE API - AddDeviceAt_2() Called"
                # setup other device.
                if 'CTRL_4WIRE' == control_interface_type
                    region = @system.AddDeviceAt_2( WISCE_CONST::CONTROL_INTERFACE_CTRL_4WIRE,
                                                    device_address,
                                                    deviceFolder + description_file
                                                  )
                else
                    region = @system.AddDeviceAt_2( WISCE_CONST::CONTROL_INTERFACE_CTRL_2WIRE,
                                                    device_address,
                                                    deviceFolder + description_file
                                                   )
                end
                raise("Couldn\'t add device #{description_file}") if nil == region
            end
            $LOG.debug "WISCE API - Devices Called"
            @device = find_by_name( @system.Devices, device_name )
            $LOG.debug "WISCE API - CurrentDevice Called"
            # Handling WIN32OLERuntimeError, to log the proper error message
            # to understand better about the issue
            begin
              @system.CurrentDevice = @device
            rescue WIN32OLERuntimeError => e
              $LOG.error("#{device_name} not found on the system #{system_name}")
              $LOG.error(e.to_s)
              raise e
            end
            $LOG.debug "WISCE API - Name Called"
            message = "Testing #{@device.Name} on #{@system.Name}."
            $LOG.debug message
            return message
        end

        #######################################################################
        #
        # @function connect_to_wiscebridge
        #
        # Connect to a WISCE™ Automation OLE instance and set up the WISCE™ Core
        # to connect to a WISCEBridge™ server running at the specified address
        # and port.
        #
        # @param [String] address     The address and port seperated by a ':' delimiter
        # @param [String] device_name Name of the device to connect to.
        #
        # @raise connect_core will raise an exception if it cannot connect to the
        #        WISCE™ Core.
        #
        #######################################################################
        def connect_to_wiscebridge( address, device_name )
            connect_core
            $LOG.debug "WISCE API - ConnectToSystem Called"
            @system = @core.Systems.ConnectToSystem( WISCE_CONST::SystemType_WISCEBridge, "", address )
            $LOG.debug "WISCE API - CurrentSystem Called"
            @core.CurrentSystem = @system
            $LOG.debug "WISCE API - DetectDevices Called"
            @system.DetectDevices()
            $LOG.debug "WISCE API - Devices Called"
            @device = find_by_name( @system.Devices, device_name )
            $LOG.debug "WISCE API - CurrentDevice Called"
            @system.CurrentDevice = @device

            $LOG.debug "Connected to #{address} via WISCEBridge™."
            $LOG.debug "Testing #{@device.Name} on #{@system.Name}."
        end

        ########################################################################
        # @function connect_core
        #
        # Establish a connection to the WISCE™ Automation OLE server.
        #
        # (no parameters)
        #
        # @raise if cannot connect to WISCE™ or the WISCE™ Core.
        # @raise if cannot create the simulated sytem.
        #
        ########################################################################
        def connect_core()
            if @automation.nil?
                @automation = WIN32OLE.new( "Wolfson.WISCE.WISCEAutomation" )
                raise( "Couldn't connect to WISCE™" ) if nil == @automation
                $LOG.debug "WISCE API - TheWISCECore Called."
                @core = @automation.TheWISCECore
                raise( "Couldn't connect to the WISCE™ Core" ) if nil == @core
                $LOG.info 'WISCE™ Connected.'
            end

            # Load Constants into WISCE_CONST (if currently WISCE_CONST unset)
            unless @@constants_loaded
                WIN32OLE::const_load( @core, WISCE_CONST )
                @@constants_loaded = true
                # for looking up meaningful messages, lookup result names.
                create_WMResult_hash()
                create_WM_COMMS_PROTOCOL_hash
            end
        end

        #######################################################################
        # @function create_WMResult_hash
        #
        # Create a lookup Hash of the keys that match the WMResult codes.
        #
        # (no parameters)
        #
        #######################################################################
        def create_WMResult_hash
            @@WMRESULT_CODES = Hash.new
            keys = WISCE_CONST.constants

            keys.select!{|name| name =~ /WM_RESULT_WMR_\w+/}

            keys.each do |k|
                val = WISCE_CONST.const_get(k.to_sym)
                @@WMRESULT_CODES[val] = k.to_sym
            end
        end

        #######################################################################
        # @function create_WM_COMMS_PROTOCOL_hash
        #
        # Create a lookup Hash of the keys that match the WM_COMMS_PROTOCOL codes.
        #
        # It looks like there are two constants with the same value:
        #   WM_COMMS_PROTOCOL_P_UNKNOWN - 65535
        #   WM_COMMS_PROTOCOL_P_SPI2    - 65535
        #
        # Keeping the first value in the list.
        #
        # (no parameters)
        #
        #######################################################################
        def create_WM_COMMS_PROTOCOL_hash
            @@WM_COMMS_PROTOCOL_CODES = Hash.new
            keys = WISCE_CONST.constants

            keys.select!{|name| name =~ /WM_COMMS_PROTOCOL_\w+/}

            keys.each do |k|
                val = WISCE_CONST.const_get( k.to_sym )
                # map to the first use key when sharing values.
                if @@WM_COMMS_PROTOCOL_CODES[val].nil?
                    @@WM_COMMS_PROTOCOL_CODES[val] = k.to_sym
                end
            end
        end

        #######################################################################
        # @function connect_simulated
        #
        # Setup a simulated system for testing.
        #
        # @param [String] system_name Name of the system to connect to.
        # @param [String] device_name Name of the device to connect to.
        # @param [String] description_file Name of the description file to load
        #
        # @raise connect_core will raise an exception if it cannot connect
        #        to WISCE™ or the WISCE™ Core.
        #
        #######################################################################
        def connect_simulated( system_name, device_name, description_file )
            connect_core
            # setup a simulated system
            $LOG.debug "WISCE API - ConnectToSystem() Called"
            @system = @core.Systems.ConnectToSystem( WISCE_CONST::SystemType_Simulated,
                                                    system_name,
                                                    "0"
                                                   )
            raise('Couldn\'t add system') if nil == @system
            $LOG.debug "WISCE API - CurrentSystem Called"
            @core.CurrentSystem = @system
                $LOG.debug "WISCE API - GetStandardFolder() Called"
            deviceFolder = @core.GetStandardFolder( WISCE_CONST::FolderType_Device )

            raise('Couldn\'t get device folder') if nil == deviceFolder

            # Find out if a device of this type already exists, if so do not add.
            @device = find_by_name( @system.Devices, device_name, false )
            if @device.nil?
                $LOG.debug "WISCE API - AddDeviceAt_2() Called"
                # setup the simulated device.
                region = @system.AddDeviceAt_2( WISCE_CONST::CONTROL_INTERFACE_CTRL_2WIRE,
                                                0x34,
                                                deviceFolder + description_file
                                              )
                raise("Couldn\'t add device #{description_file}") if nil == region
                $LOG.debug "WISCE API - Devices Called"
                @device = find_by_name( @system.Devices, device_name )
            end
            $LOG.debug "WISCE API - CurrentDevice Called"
            @system.CurrentDevice = @device
            message = "Testing #{@device.Name} on #{@system.Name}."
            $LOG.debug message
        end

        #######################################################################
        #
        # @function per_device_setup
        #
        # Device specific per-scenario set-up.
        #
        # (no parameters)
        #
        #######################################################################
        def per_device_setup
            PortaudioClient::terminate()
            FruitSalad::get_device.output = nil
            return
        end

        #########################################################################
        #
        # @function device_connected?
        #
        # Returns true iff the attributes @system and @device were initialised
        # correctly and FruitSalad was able to connect them to the Device/System
        # given by SystemName and DeviceName.
        #
        # (no parameters)
        #
        # @return [bool]
        #
        #########################################################################
        def device_connected?
            nil != @system and nil != @device
        end

        #########################################################################
        #
        # @function device_id
        #
        # Returns the Hardware Device ID read from register 0h
        #
        # (no parameters)
        #
        # @return [Integer|nil] Returns the Hardware Device ID
        #
        #########################################################################
        def device_id
            unless @device.nil?
               sw_rst_dev_id = read_element_value( 'SW_RST_DEV_ID' )
               return sw_rst_dev_id.hex
            else
               return nil
            end
        end

        #########################################################################
        #
        # @function hw_revision
        #
        # Returns the Hardware Revision read from register 1h
        #
        # (no parameters)
        #
        # @return [Integer|nil] Returns the Hardware Revision
        #
        #########################################################################
        def hw_revision
            unless @device.nil?
               hw_rev = read_element_value( 'HW_REVISION' )
               return hw_rev.hex
            else
               return nil
            end
        end


        ########################################################################
        #
        # @function read_dsp_sampling_freq_reg_value
        # It is used to get the sampling frequency value from the corresponding register.
        #
        # @param  [Integer] index It is used to select specific DSP.
        #
        # @return [Integer] The value which comes from the DSP register.
        ########################################################################
        def read_dsp_sampling_freq_reg_value( index )
            actual_value = nil
            value = read_element_value('DSP[index]_RATE')
            case value.to_i
               when 0
                   actual_value =  read_element_value('SAMPLE_RATE_1')
               when 1
                   actual_value =  read_element_value('SAMPLE_RATE_2')
               when 2
                   actual_value =  read_element_value('SAMPLE_RATE_3')
            end
            return actual_value.hex
        end

        ########################################################################
        #
        # @function read_dsp_sample_rate_value
        # This method is used for reading Sample Rate Value for a DSP.
        # It is obtained by converting Sample Rate Register value to sampling
        # rate
        #
        # @param  [Integer] index It is used to select specific DSP.
        #
        # @return [Integer] Sampling rate
        ########################################################################
        def read_dsp_sample_rate_value( index )
          actual_freq = nil
          device = FruitSalad::get_device
          actual_value = device.read_dsp_sampling_freq_reg_value( index )
          freq_value = Conf.property( :DSPSamplingFrequencies , {})
          sample_freq_value = Conf.property( :DSPSamplingFreqRegvalues , {})
          1.upto( freq_value.length ) do |number|
              sample_value = sample_freq_value[ "value#{number}" ]
              if ( sample_value == actual_value )
                 actual_freq = freq_value[ "actualFreq#{number}" ]
              end
          end
          return actual_freq
        end


        #########################################################################
        #
        # @function usecase_from_file
        #
        # Configure the playback/capture usecase by loading a usecase script.
        #
        # @param [String, symbol] script is either the name of the usecase to
        #                                invoke, or the :reset symbol.
        # @param [Hash]   opts Optional usecase_from_file arguments. This
        #                      supports: [Boolean] silent - indicates whether
        #                      prints should ON(false) or OFF(true) on console
        #                      (defaults to false). [String] type - indicates
        #                      the type of the use case file to be loaded.
        #                      (defaults to .txt)[String] source_path - location
        #                      of file to load (default value is nil).
        #                      [String] destination_path - only added in supported
        #                      opts but we are not using any where in this method
        #                      no need to pass any argument default vaule is nil.
        #
        #
        # @raise [RuntimeException] If the usecase script fails to load successfully
        #
        #########################################################################
        def usecase_from_file( script, opts = {} )
            supported_opts = [ :silent, :type , :source_path, :destination_path]
            validate_options( opts.keys, supported_opts, 'WISCESalad: (usecase_from_file)' )
            silent = opts.fetch( :silent, false )
            type = opts.fetch( :type, ".txt" )
            usecase_path = opts.fetch( :source_path, false )

            case script
                when 'Reset_paths'
                    $LOG.info '*** Resetting device.' unless silent
                    # Instead of running a script we perform a hardware reset.
                    $LOG.debug "WISCE API - Reset Called"
                    @device.Reset
                else
                    $LOG.debug "*** Loading usecase file '#{script}' device." unless silent
                    unless usecase_path
                        use_case_path = UsecasePath
                    else
                        use_case_path = usecase_path
                    end
                    $LOG.debug "WISCE API - LoadFile() Called"
                    val = @system.LoadFile( File.join( use_case_path, script + type ) )
                    $LOG.debug "*** Loading usecase file result: #{val} (#{lookup_WMResult( val )})." unless silent
                    unless WISCE_CONST::WM_RESULT_WMR_SUCCESS == val ||
                        WISCE_CONST::WM_RESULT_WMR_REG_NOT_PRESENT == val ||
                        WISCE_CONST::WM_RESULT_WMR_READ_ONLY == val
                        raise "Usecase #{File.join( use_case_path, script + type )} loading failed, error code: #{val} (#{lookup_WMResult( val )})."
                    end
            end
        end

        #######################################################################
        # @function lookup_WMResult( enum_const )
        #
        # Utility method to lookup a WMResult name from the enum result for
        # a more useful error message.
        #
        # There is a Wolfson.WMResult.WMResultString method that does this, but
        # it doesn't seem to be exposed through the automation API. It exists in
        # the OLE type library, but its methods are not callable.
        #
        # @param [Integer] enum_const The WMResult enum to lookup.
        #
        # @return [String] The name of the corresponding enum code.
        #
        #######################################################################
        def lookup_WMResult( enum_const )
            return @@WMRESULT_CODES[enum_const].to_s
        end

        #######################################################################
        # @function lookup_WMProtocol
        #
        # Utility method to lookup a WM_COMMS_PROTOCOL name from the enum result
        # for more meaningful messages.
        #
        # @param [Integer] enum_const The WM_COMMS_PROTOCOL enum to lookup.
        #
        # @return [String] The name of the corresponding enum code.
        #
        #######################################################################
        def lookup_WMProtocol( enum_const )
            return @@WM_COMMS_PROTOCOL_CODES[enum_const].to_s
        end

        #######################################################################
        # @function initialize_pa_multitrack
        #
        #  Initializes Pa Multitrack.
        #
        #######################################################################
        def initialize_pa_multitrack
            re_init_pa_multitrack
        end

        #######################################################################
        #
        # @function multitrack_playback
        #
        # Play and record multiple mono-channel WAV files to different playback device channels
        # using the pa_multitrack utility. Channel and record should be given as
        # zero-indexed integers.
        #
        # @note Input tracks are passed to the simulated_noise_model component
        #       which will automatically add simulated noise once configured.
        #
        # @param [Array<Array>]  track_list  Array of track tuples to play/record:
        #                                    of the form:
        #                                    [ track_file, playback_number, record_number ]
        # @param [Boolean]       rec         Boolean variable to tell the
        #                                    function whether to record or not.
        # @param [Integer]       samples     Record for the given number of samples
        # @param [Boolean]       background  Boolean variable to tell the function whether
        #                                    play or record in background or not.
        #
        #######################################################################
        def multitrack_playback( track_list, rec = true, samples = 480000, background = false )
            # Clone the track_list
            track_list = Marshal.load( Marshal.dump( track_list ) )
            track_list.map! do |track, channel, record|
                track = simulated_noise_model.mix_in_noise( track,
                                                            noise_channel:channel
                                                          )
                [track, channel, record]
            end
            if !rec
                @digital_playback_active = true
            else
                @digital_recording_active = true
            end
            $LOG.debug "Playing triggers: #{track_list.to_s}"
            @pa_multi = PaMultitrack.new()
            @pa_multi.play_tracklist( track_list, rec, samples, background )
            unless background
                if !rec
                    @digital_playback_active = false
                else
                    @digital_recording_active = false
                end
            end
        end

        #########################################################################
        #
        # @function playback
        #
        # Play a file over Lochnagar inputs.
        #
        # @note Input tracks are passed to the simulated_noise_model component
        #       which will automatically add simulated noise once configured.
        #
        # @param [String] file    is the path, relative or absolute, to the
        #                         test-file.
        # @param [Hash] opts      Options to play a file with.
        # @option opts [Integer] :channels Number of channels present in the
        #                                  file to play with, default set to
        #                                  PlaybackChannels given in config.
        # @option opts [Boolean] :blocking Blocks/Unblocks the playback method,
        #                                  default set to true.
        #
        #########################################################################
        def playback( file, opts = {} )
            info = Reader.info( file )
            sample_rate = info.sample_rate
            @playback_history << file

            supported_opts = [:channels, :blocking]
            validate_options( opts.keys, supported_opts, 'WISCESalad: (playback)' )

            blocking = opts.fetch( :blocking, true )
            channels = opts.fetch( :channels, PlaybackChannels )

            file = simulated_noise_model.mix_in_noise( file )
            PortaudioClient::start()
            start_time = Time.new.to_f
            PortaudioClient::start_playback( channels,
                                             sample_rate,
                                             file
                                           )
            @analog_playback_active = true
            if( true == blocking )
                PortaudioClient::wait_for_notification()
                end_playback()
            end
            end_time   = Time.new.to_f
            @playtime  = end_time - start_time
         end

        #########################################################################
        #
        # @function record_output
        #
        # Capture output from Lochnagar.
        #
        # The file-name used to save the captured output is stored in the
        # attribute @output.
        #
        # (no parameters)
        #
        #########################################################################
        def record_output
            if @output.nil?
                @output = "tmpfile_WISCESaladRecording.wav"
            end
            PortaudioClient::start()
            PortaudioClient::start_recording( RecordingChannels,
                                              SampleRate,
                                              @output
                                            )
            @analog_recording_active = true
        end

        #########################################################################
        #
        # @function end_playback
        #
        # Ends playback if playback is inactive, otherwise not.
        #
        # (no parameters)
        #
        #########################################################################
        def end_playback
            if @analog_playback_active
                PortaudioClient::StopPlayback()
                @analog_playback_active = false
            end
        end

        #########################################################################
        #
        # @function digital_playback_completed?
        #
        # Checks if digital playback is completed or not.
        #
        # @param [Boolean]    background    Either playback is in background or foreground.
        #                                        Defaults to false(foreground)
        #
        # returns true if digital playback is completed else false
        #
        #########################################################################
        def digital_playback_completed?( background = false )
            if background
                @digital_playback_active = @pa_multi.play_thread.status == false ? false : true
            end
            return !@digital_playback_active
        end

        #######################################################################
        #
        # @function playback_completed?
        #
        # Gives current status of playback whether it is completed or not.
        #
        # @param [String]     type       Type of Playback Analog or Digital.Defaults to
        #                                   Analog.
        # @param [Boolean] background  Either playback is in background or foreground.
        #                                   Defaults to false(foreground)
        #
        # @raise [Exception] Will raise an exception if playback type is not
        #                    supported.
        # @return [Boolean] True if playback has completed.
        #
        #######################################################################
        def playback_completed?( type = 'analog', background = false )
            if type == 'analog'
                return PortaudioClient::playback_completed?
            elsif type == 'digital'
                return digital_playback_completed?( background )
            else
                raise $LOG.error( 'Specified playback type is not supported' )
            end
        end

        #########################################################################
        #
        # @function end_capture
        #
        # Terminates any active recording.
        #
        # (no parameters)
        #
        #########################################################################
        def end_capture
            if @analog_recording_active
                PortaudioClient::StopRecording()
                PortaudioClient::terminate()
                @analog_recording_active = false
            end
        end

        #########################################################################
        # @function hide_devices
        #
        # Hides the description files associated with a given device name and places them
        # in a "hidden" directory.
        #
        # @param [String]  name Name of the device to hide.
        #
        # @return [Array<String>] A lsit of files that have been hidden.
        #
        #########################################################################
        def hide_devices( name )
            device_dir = get_device_dir_path
            hidden_dir = device_dir + '/hidden'

            unless File.exists?( hidden_dir )
                FileUtils.mkdir( hidden_dir )
            end

            entries = Dir.entries( device_dir )
            entries.select!{|file| file.match( name )}

            entries.each do |file|
                FileUtils.mv( device_dir + '/' + file, hidden_dir + '/' + file )
            end

            entries
        end

        #########################################################################
        # @function restore_devices
        #
        # Restore devices from the "hidden" directory to the standard devices folder.
        #
        # @param [String]  name Name of the device to hide.
        #
        # @return [Array<String>] A lsit of files that have been restored.
        #
        #########################################################################
        def restore_devices( name )
            device_dir = get_device_dir_path
            hidden_dir = device_dir + '/hidden'

            unless File.exists?( hidden_dir )
                FileUtils.mkdir( hidden_dir )
            end

            entries = Dir.entries( hidden_dir )
            entries.select!{|file| file.match( name )}

            entries.each do |file|
                FileUtils.mv( hidden_dir + '/' + file, device_dir + '/' + file  )
            end

            return entries
        end

        #########################################################################
        # @function get_device_dir_path
        #
        # Gets the path to the devices directory (standard WISCE™ folder).
        #
        # Calls connect_core if this has not already been called for this instance.
        #
        # (no parameters)
        #
        # @return [String] Path to the devices directory in WISCE™.
        #
        #########################################################################
        def get_device_dir_path()
            if @core.nil?
                connect_core
            end
            $LOG.debug "WISCE API - GetStandardFolder Called"
            device_dir = @core.GetStandardFolder( WISCE_CONST::FolderType_Device )
        end

        #########################################################################
        # @function devices_present?
        #
        # Check whether there are any devices matching the given name in the devices folder.
        #
        # @param [String]  name Name of the device to hide.
        #
        # @return [Boolean] Whether there are any devices of the requested name present.
        #
        #########################################################################
        def devices_present?( name )
            device_dir = get_device_dir_path

            entries = Dir.entries( device_dir )
            entries.select!{|file| file.match( name )}

            return !entries.empty?
        end

        #########################################################################
        # @function find_by_name
        #
        # Finds the first object in a WISCE OLE array that has a given Name
        # field. If not found will raise an exception unless the raise_if_name_not_found parameter
        # is set where it will return nil.
        #
        # This method has been extended to allow alternative WM|CS devices to be used if present
        # and the named device could not be found.
        #
        # @param           carray             is an OLE object that supports the methods
        #                                        Count and []
        # @param [String]  name               is the name to search for
        # @param [Boolean] raise_if_name_not_found
        #                                        raise exception if no such element found.
        # @param [Boolean] is_system          True if ole array is array of systems.
        # @param [String]  device_name        Device name can be given ,in case
        #                                         of multiple similar systems,the system
        #                                         connected to device_name is returned.
        #
        # @return [WIN32OLE] The first element from carray with matching name.
        # @return [nil] If carray does not contain an element with matching name
        #               (and raise_not_found has been unset).
        #
        # @raise Will raise an exception if the named element is not found.
        # @raise Will raise an exception device is not found on the system
        #
        #########################################################################
        def find_by_name( carray, name, raise_if_name_not_found = true, is_system = false, device_name = nil )
            found_element       = nil
            alternative_element = nil

            if is_system and @system_count > 1 and device_name
                similar_systems = Array.new
                carray.Count.times do |i|
                    if name.eql?( carray[i].Name )
                        similar_systems << carray[i]
                    end
                end
                similar_systems_len = similar_systems.length
                if 1 < similar_systems_len
                    ( 0... similar_systems_len ).each do |i|
                        system = similar_systems[i]
                        @core.CurrentSystem = system
                        system.DetectDevices()
                        connect_devices = Array.new
                        system.Devices.Count.times{ |i| connect_devices << system.Devices[i].Name }
                        return system if connect_devices.include?( device_name )
                    end
                    error_message = "#{device_name} is not found in #{count} systems"
                    raise error_message + $LOG.error( error_message ).to_s
                end
            end

            carray.Count.times do |i|
                element_name = carray[i].Name

                if alternative_element.nil?
                    match_data = element_name.match(/((CS|WM)\d\d\w?\d\d)/)
                    # do not consider the FPGA on the Lochnagar an alternative device.
                    unless match_data.nil? || 'WM0050' == match_data.to_s
                      alternative_element = carray[i]
                    end
                end

                if element_name == name
                    found_element = carray[i]
                    break
                end
            end

            if found_element.nil?
                unless alternative_element.nil?
                    $LOG.debug( "INFO: Unable to find #{name} in #{carray.ole_type} collection." \
                                   "Using alternative #{alternative_element.Name} instead." )
                end
                found_element = alternative_element
            elsif found_element.nil? and raise_if_name_not_found
                raise "Unable to find #{name} in #{carray.ole_type} collection."
            end

            return found_element
        end

        #######################################################################
        #
        # @function is_firmware_loaded?
        #
        # Reimplements the method from FruitSaladBase::DeviceInterface for the WISCE
        # target.
        #
        # Check whether the specified firmware is present on the target device.
        #
        # Algorithms are specified by their feature name (e.g. 'EZ2 Control'), this is
        # then mapped to the algorithm description name using the configuration hash
        # Firmware_names which can be specified and overriden by users in their configuration file.
        #
        # If algorithm descriptions are not present its hex id will returned instead:
        #   * with description:    FIRMWARE_FLORIDA_EZ2CONTROL
        #   * without description: Algorithm (0x4000D)
        #
        # @param [String] algo_name The feature name of the algorithm to check for.
        # @param [Hash]              opts     Firmware Information hash
        # @option opts [String]     :revision The revision of the algorithm to check for.
        # @option opts [String|nil] :version  Version string of the firmware that
        #                                     should be present (nil if unspecified).
        # @option opts [nil|String|Integer] :dsp_core Core Identifier string
        #                                    (e.g. 'DSP2') or integer index (1).
        # @return [Boolean] true if the specified firmware was present, otherwise returns false
        #
        #######################################################################
        def is_firmware_loaded?( algo_name, opts )
            supported_opts = ['revision','version', 'dsp_core']
            validate_options( opts.keys ,supported_opts, 'WISCESalad: (is_firmware_loaded?)')
            # TODO: this may introduce more slowdown than needed,
            # try refreshing only the specified core?
            $LOG.debug "WISCE API - RefreshAll Called"
            @device.RefreshAll
            revision = opts.fetch( 'revision', nil )
            version = opts.fetch( 'version', nil )
            dsp_core = opts.fetch( 'dsp_core', nil )

            # attempt to locate a core with the given properties,
            # will return nil if no such core is found.
            dsp_with_fw = locate_firmware_core( algo_name, revision, version, dsp_core )
            return !dsp_with_fw.nil?
        end

        #######################################################################
        #
        # @function locate_firmware_core
        #
        # Attempt to locate a DSP core with requested firmware loaded.
        #
        # A string specifying the requested version can be given, or nil for any version.
        # Where a DSP core identifier has been given, only that core will be checked, when nil
        # all of the available DSP cores will be iterated through until the first
        # DSP core with matching firmware is found.
        #
        # @param [String] firmware_name The name of the firmware to locate.
        # @param [String] revision The revision of the firmware to locate.
        # @param [String|nil] version Version string of the firmware that should be present (or nil if unspecified).
        # @param [nil|String|Integer] dsp_core Core Identifier string (e.g. 'DSP2') or integer index (1).
        #
        # @return [WIN32OLE::IDSPCore] dsp The first DSPCore object with the specified firmware loaded, otherwise nil.
        #
        # @raise [Exception] If requested core is out of range of the cores available on the device.
        #
        #######################################################################
        def locate_firmware_core( firmware_name, revision, version, dsp_core )
            $LOG.debug "WISCE API - DSPCores,Count Called"
            n_cores = @device.DSPCores.Count
            core_range = Range.new(0, n_cores-1)
            dsp_core_index = extract_dsp_index( dsp_core )

            # if the dsp_core is nil check all available cores,
            # otherwise can check the one specified.
            unless dsp_core.nil?
                # check_core_within_range will raise an exception if index is out of bounds.
                check_core_within_range( dsp_core_index )
                core_range = [dsp_core_index]
            end

            dsp_with_fw = nil
            core_range.each do |dsp_core_index|
               dsp = @device.DSPCores[dsp_core_index]
               tmp = is_firmware_loaded_for_core?( firmware_name, revision, version, dsp )
               if tmp
                   dsp_with_fw = dsp
                   break
               end
           end

           return dsp_with_fw
        end

        #######################################################################
        #
        # @function check_core_within_range
        #
        # Check that a given DSP core index lies within the range of cores available on the connected device.
        #
        # Cores are indexed from zero, i.e. 'DSP1' has index 0.
        #
        # @param [Integer] dsp_core_index DSP Core integer index (e.g. 1 for 'DSP2').
        #
        # @raise [Exception] If requested core is out of range of the cores available on the device.
        #
        #######################################################################
        def check_core_within_range( dsp_core_index )
            $LOG.debug "WISCE API - DSPCores,Count Called"
            n_cores = @device.DSPCores.Count
            core_range = Range.new(0, n_cores-1)

            # raise an exception if the core index is out of range.
            unless core_range.cover?( dsp_core_index )
                raise "Requested DSP core index #{dsp_core_index} out of range (there are #{n_cores} cores available)."
            end
        end

        #######################################################################
        #
        # @function get_IDSPAlgorithm_IDataRegion
        #
        # Searches for WISCE,then sets idsp_algorithm, i_data_region
        # with the corresponding IDSPAlgorithm, IDataRegion value for that
        # particular WISCE version.
        #
        # @param [String] wisce_path Path of WISCE folder.
        #
        # @return [String] idsp_algorithm IDSPAlgorithm for the corresponding WISCE version.
        #
        # @return [String] i_data_region IDataRegion for the corresponding WISCE version.
        #
        #######################################################################
        def get_IDSPAlgorithm_IDataRegion( wisce_path )
            wisce_path.gsub!(/[a-zA-Z]+\\$/,"").gsub!(/\\/,"\\\\\\\\")
            wisce_path = wisce_path + "bin\\\\WISCE.exe"
            stdout_str = Open3.capture3("WMIC DATAFILE WHERE name=\"#{wisce_path}\" get Version /format:Textvaluelist")
            i_data_region = nil
                if stdout_str[0].strip.match( /Version=(.+)/ )
                    wisce_version = $1
                    idsp_algorithm = @@ole_iid_hash['IDSPAlgorithm']
                    case wisce_version
                        when /3.[4,5].0.[3,27].+/
                            i_data_region = '{24BC76AF-7DA9-32B3-9E34-825F0849B32B}'
                        when /3.5.[1,2].0.+/
                            i_data_region = '{7CF1E66C-7E4A-3DAA-A3A7-F0C903534A12}'
                        when /3.6.[0,1].[0,4,5].+/
                            i_data_region = '{F80A8AE5-0C75-3556-98FA-9B229B1D1664}'
                        when /3.6.1.[1,2,3].+/
                            i_data_region = '{7CF1E66C-7E4A-3DAA-A3A7-F0C903534A12}'
                        when /3.[7,8,9,10].[0,1].[0,2,3,4,6,7,8]/
                            i_data_region = '{7CF1E66C-7E4A-3DAA-A3A7-F0C903534A12}'
                            idsp_algorithm = '{C21556CB-6C53-38EA-BB53-CA6BC3250E72}'
                        else
                            i_data_region = '{707F2D1E-DAED-3168-8F75-02E672A6AEA2}'
                    end
                end
            return idsp_algorithm, i_data_region
        end

        #######################################################################
        #
        # @function is_firmware_loaded_for_core?
        #
        # Check a specific core for the presence of firmware
        #
        # @param [String] firmware_feature_name The name of the firmware to
        #                                       check for.
        # @param [String] revision The revision of the firmware to check for
        # @param [String|nil] version Version string of the firmware that
        #                             should be present (nil if unspecified).
        # @param [WIN32OLE::IDSPCore] dsp       DSPCore object from the device.
        #
        # @raise [RunTimeError] If firmware ID is not defined for the firmware.
        #
        #######################################################################
        def is_firmware_loaded_for_core?( firmware_feature_name, revision, version, dsp )
            # Convert the firmware feature name into the name as known in the
            # firmware description.
            firmware_name = Conf::get_firmware_data( device_id,
                                                     hw_revision,
                                                     firmware_feature_name,
                                                     revision
                                                   )['id']
            if firmware_name.nil?
                raise "Firmware ID for #{firmware_feature_name} has not been defined in config file"
            end
            # is any firmware loaded?
            $LOG.debug "WISCE API - LoadedFirmware Called"
            loaded_fw = dsp.LoadedFirmware

            name_match = false
            version_match = false

            if !loaded_fw.nil?
                # OLE has no inheritance, need to check that the IDSPAlgorithm is supported.
                wisce_path = @core.GetStandardFolder( WISCE_CONST::FolderType_Device )
                @@ole_iid_hash['IDSPAlgorithm'], @@ole_iid_hash['IDataRegion'] = get_IDSPAlgorithm_IDataRegion( wisce_path )
                fw_alg = loaded_fw.ole_query_interface( @@ole_iid_hash['IDSPAlgorithm'] )
                $LOG.debug "WISCE API - Name Called"
                name_match = (fw_alg.Name == firmware_name)
                if version.nil?
                    version_match = true
                else
                    version_match = (version == fw_alg.Revision.ToString)
                end
                $LOG.debug "WISCE API - Prefix,Name,Revision Called"
                $LOG.debug "#{dsp.Prefix}: #{fw_alg.Name} - #{fw_alg.Revision.ToString}"
            else
                $LOG.debug "WISCE API - Prefix Called"
                $LOG.debug "#{dsp.Prefix}: No firmware loaded"
            end
            return !loaded_fw.nil? && name_match && version_match
        end

        #######################################################################
        #
        # @function load_firmware
        #
        # Reimplements the method from FruitSaladBase::DeviceInterface for the WISCE
        # target.
        #
        # Loads a firmware file onto the device to a specified core. Usable in WISCE
        # versions built with changes from revision 17240 (version 3.3+).
        #
        # @param [String] firmware_filename    File name of the firmware to load.
        # @param [nil|String|Integer] dsp_core Core Identifier string (e.g. 'DSP2') or integer index (1).
        #
        # @return [Boolean] success Whether firmware loading was successful.
        #
        # @raise [RunTimeException] If LoadFirmware fails to load the requested file.
        #
        #######################################################################
        def load_firmware( firmware_filename, dsp_core )
            max_tries = 2
            count = 0
            dsp_core_index = extract_dsp_index( dsp_core )
            $LOG.debug "WISCE API - DSPCores Called"
            dsp = @device.DSPCores[dsp_core_index]
            $LOG.debug "*** Loading firmware file: '#{firmware_filename}'"
            begin
                $LOG.debug "WISCE API - LoadFirmware() Called"
                loaded_fw = dsp.LoadFirmware( firmware_filename )
                $LOG.debug("Load firmware at: #{Time.now}")
                #if the loaded_fw returns nil then trying to reload the firmware
                raise if loaded_fw.nil?
            rescue
                count += 1
                if count <= max_tries
                    $LOG.debug "WISCE API - Prefix Called"
                    $LOG.error "Failed to load firmware on #{dsp.Prefix} try to reload again"
                    sleep 1
                    retry
                end
            end
            # OLE has no inheritance, need to check that the IDSPAlgorithm is supported.
            wisce_path = @core.GetStandardFolder( WISCE_CONST::FolderType_Device )
            @@ole_iid_hash['IDSPAlgorithm'], @@ole_iid_hash['IDataRegion'] = get_IDSPAlgorithm_IDataRegion( wisce_path )
            fw_alg = loaded_fw.ole_query_interface( @@ole_iid_hash['IDSPAlgorithm'] )
            $LOG.debug "WISCE API - Prefix,Name,Revision Called"
            $LOG.debug "#{dsp.Prefix}: #{fw_alg.Name} - #{fw_alg.Revision.ToString}"
            return true
        end

        #######################################################################
        #
        # @function load_firmware_from_usecase
        #
        # Loads firmware from a usecase file.
        #
        # As part of this method call the DSP core is refreshed to ensure
        # the fields have been loaded for the new firmware. This is due to WISCE failing
        # to auto-update for firmware loaded via a text file.
        # Note: a usecase is hardcoded to a particular core.
        #
        # @param [String] firmware_usecase_filename    File name of the firmware usecase to load.
        # @param [nil|String|Integer] dsp_core Core Identifier string (e.g. 'DSP2') or integer index (1).
        #
        #######################################################################
        def load_firmware_from_usecase( firmware_usecase_filename, dsp_core )
            usecase_from_file( firmware_usecase_filename )
            device_refresh_core( dsp_core )
        end

        #######################################################################
        #
        # @function start_firmware
        #
        # Locate and start the core with the requested firmware.
        #
        # @param [String] firmware_name The name of the firmware to start.
        # @param [String|nil] revision revision string of the firmware that should be present (nil if unspecified).
        # @param [String|nil] version Version string of the firmware that should be present (nil if unspecified).
        # @param [nil|String|Integer] dsp_core Core Identifier string (e.g. 'DSP2') or integer index (1).
        #
        # @return [Boolean] true if WMR_SUCCESS reported, false otherwise.
        #
        #######################################################################
        def start_firmware( firmware_name, revision = nil, version = nil, dsp_core )
            dsp_with_fw = locate_firmware_core( firmware_name, revision, version, dsp_core )
            unless dsp_with_fw.nil?
                $LOG.debug "WISCE API - StartCore Called"
                success = dsp_with_fw.StartCore()
                return WISCE_CONST::WM_RESULT_WMR_SUCCESS == success
            end
            return false
        end

        #######################################################################
        #
        # @function is_dspcore_running?
        #
        # Is the specified DSP core running?
        #
        # @param [Integer] dsp_core_index Index of the DSP core .
        #
        # @return [Boolean] Whether the core is running.
        #
        #######################################################################
        def is_dspcore_running?( dsp_core_index )
            $LOG.debug "WISCE API - IsCoreRunning() Called"
            @device.DSPCores[dsp_core_index].IsCoreRunning()
        end

        #######################################################################
        #
        # @function value_to_padded_hex_string
        #
        # Converts an integer value into a zero-padded hex string.
        #
        # @param [Integer] value     Value to be converted.
        # @param [Integer] bit_width Bit width of the element to represent (zero-padding).
        #
        # @return [String] Zero-padded hex representation of the requested element's value.
        #
        #######################################################################
        def value_to_padded_hex_string( value, bit_width )
            # calculate how many hex characters needed for the bit_width
            #   i.e. 0 is padded to 00 for an 8 bit number and 0000 for a 16 bit number
            no_chars = (bit_width.to_f / 4.to_f).ceil.to_i
            return "%0#{no_chars}X" % value
        end

        ########################################################################
        #
        # @function device_refresh_core
        #
        # Call RefreshAll on the currently connected device.
        #
        # @param [nil|String|Integer] dsp_core Core Identifier string
        #                                      (e.g. 'DSP2') or integer index (1).
        #
        # @raise [Exception] If requested core is out of range of the cores
        #                    available on the device.
        #
        ########################################################################
        def device_refresh_core( dsp_core )
            dsp_core_index = extract_dsp_index( dsp_core )
            check_core_within_range( dsp_core_index )
            $LOG.debug "WISCE API - DSPCores Called"
            dsp_core_ole = @device.DSPCores[dsp_core_index]

            #
            # As IDataRegion changes for WISCE versions,
            # Updating the IDataRegion interface of ole_iid_hash with the corresponding
            # IDataRegion of WISCE version used.
            #
            wisce_path = @core.GetStandardFolder( WISCE_CONST::FolderType_Device )
            @@ole_iid_hash['IDSPAlgorithm'], @@ole_iid_hash['IDataRegion'] = get_IDSPAlgorithm_IDataRegion( wisce_path )

            #
            # RefreshAll is inherited from the IDataRegion.
            # As OLE has no inheritance, need to check that the IDataRegion
            # is supported.
            #
            interface = @@ole_iid_hash['IDataRegion']
            data_region_ole = dsp_core_ole.ole_query_interface( interface )
            $LOG.debug "WISCE API - RefreshAll Called"
            data_region_ole.RefreshAll()
        end

        ########################################################################
        #
        # @function device_refresh_all
        #
        # Call RefreshAll on the currently connected device.
        #
        # (no parameters)
        #
        ########################################################################
        def device_refresh_all()
            $LOG.debug "WISCE API - RefreshAll() Called"
            @device.RefreshAll
        end

        ########################################################################
        #
        # @function read_element_value
        #
        # Reads a given element (register, field) from the device.
        #
        # @param [String]  element_name Name of an element (field, register)
        #                               to read from.
        #
        # @return [String] Zero-padded hex representation of the requested
        #                  element's value.
        # @return [nil]    If the requested element could not be found.
        #
        ########################################################################
        def read_element_value( element_name )
            $LOG.debug "WISCE API - LookupElement() Called"
            element = @device.LookupElement( element_name )
            if element.nil?
                return nil
            else
                $LOG.debug "WISCE API - Read() Called"
                value = element.Read()
                $LOG.debug "WISCE API - Width Called"
                return value_to_padded_hex_string( value, element.Width )
            end
        end

        ########################################################################
        #
        # @function read_block_data
        #
        # Reads a block of data from the arbitrary memory locations of the device.
        #
        # @param [Integer] start_address Starting address of the memory to read.
        #
        # @param [Integer] number_of_bytes Number of bytes to read.
        #
        # @param [Boolean] read_from_device True or False to read from device
        #                  or from cache.
        #
        # @return [Char Array[]] Returns requested memory data in Byte[]
        #                        format.
        #
        ########################################################################
        def read_block_data( start_address, number_of_bytes, read_from_device )
            $LOG.debug "WISCE API - GetBlockValues() Called"
            ret_bytes = @device.GetBlockValues( start_address,
                                                number_of_bytes,
                                                read_from_device
                                              )
            return ret_bytes
        end

        ########################################################################
        #
        # @function write_block_data
        #
        # Writes a block of data to the arbitrary memory locations of the device.
        #
        # @note OLE has type mismatch with the second argument, can't use this now.
        #
        # @param [Integer] start_address Starting address of the memory to write.
        #
        # @param [Char Array[]] values Byte array to write in to memory.
        #
        # @param [Boolean] read_from_device True or False to write in to device
        #                  or in to cache.
        #
        # @return [void] Returns none.
        #
        ########################################################################
        def write_block_data( start_address, values, read_from_device )
            type      = WIN32OLE::VARIANT::VT_UI1 | WIN32OLE::VARIANT::VT_ARRAY
            ole_array = WIN32OLE_VARIANT.new( values, type )
            $LOG.debug "WISCE API - SetBlockValues() Called"
            @device.SetBlockValues( start_address, ole_array, read_from_device )
        end

        ########################################################################
        #
        # @function write_element_value
        #
        # Writes a value to a given element (register, field) to the device.
        #
        # @param [String]        element_name Name of an element (field,
        #                                     register) to read from.
        # @param [String|Fixnum] value        Value to write to the register
        #                                     (strings can be hex or decimal
        #                                     representation).
        # @return [nil]                       Return nil, if given invalid
        #                                     element name.
        # @raise [RuntimeError]  If the given value is not a valid integer
        #                        or convertible string.
        #
        ########################################################################
        def write_element_value( element_name, value )
            $LOG.debug "WISCE API - LookupElement Called"
            element = @device.LookupElement( element_name )
            invalid = false

            if !value.is_a?(Fixnum) and !value.is_a?(String)
                invalid = true
            end

            if value.is_a? String
                match_data_dec = value.match( /^\d+$/ )
                match_data_hex = value.match( /^(?:0x)?([\da-f]+)h?$/i )

                if match_data_hex.nil? and match_data_dec.nil?
                    invalid = true
                end

                if match_data_hex
                    value = match_data_hex[1].to_i( 16 )
                end
            end

            if invalid
                raise 'Invalid number format for value parameter: ' + value
            end

            unless element.nil?
                #
                # no need to call Write, UserValue will write through to
                # the device by default.
                #
                $LOG.debug "WISCE API - UserValue Called"
                element.UserValue = value.to_i
            else
                #
                # return nil, if invalid register name is given.
                #
                return nil
            end

        end

        ########################################################################
        #
        # @function get_default_element_value
        #
        # Lookup the default value of a given element (register, field).
        #
        # @param [String]  element_name Name of an element (field, register)
        #                               to read from.
        #
        # @return [String] Zero-padded hex representation of the requested
        #                  element's  default value.
        # @return [nil] if the requested element could not be found.
        #
        ########################################################################
        def get_default_element_value( element_name )
            $LOG.debug "WISCE API - LookupElement Called"
            element = @device.LookupElement( element_name )
            if element.nil?
                return nil
            else
                $LOG.debug "WISCE API - DefaultValue() Called"
                value = element.DefaultValue()
                return value_to_padded_hex_string( value, element.Width )
            end
        end

        ########################################################################
        #
        # @function remove_device
        #
        # Removes a named device from the current system.
        #
        # @param [String]  device_name Name of the device to remove (e.g. WM5110).
        #
        ########################################################################
        def remove_device( device_name )
            $LOG.debug "WISCE API - devices Called"
            device = find_by_name(@system.devices, device_name )
            $LOG.debug "WISCE API - RemoveDevice Called"
            @system.RemoveDevice( device )
        end

        ########################################################################
        #
        # @function add_spi
        #
        # Re-add a device enabled for SPI.
        #
        # @note The transport type must be also be present in the device
        #       description or WISCE™ will not add the device.
        #
        # (no parameters)
        #
        ########################################################################
        def add_spi
            $LOG.debug "WISCE API - TransportType Called"
            # TODO: Support other modes of SPI communication.
            if WISCE_CONST::WM_TRANSPORT_TYPE_WM_PORT_FUSB_BOX == @system.TransportType
                $LOG.debug "WISCE API - DeviceAt() Called"
                device = @system.DeviceAt( WISCE_CONST::CONTROL_INTERFACE_CTRL_4WIRE, 0x2 )
            else
                $LOG.debug "WISCE API - DeviceAt() Called"
                device = @system.DeviceAt( WISCE_CONST::CONTROL_INTERFACE_CTRL_4WIRE, 0x0 )
            end
        end

        ########################################################################
        #
        # @function list_devices
        #
        # Debug method for displaying the connected devices and protocols
        # to the console.
        #
        # (no parameters)
        #
        ########################################################################
        def list_devices
            $LOG.debug "WISCE API - CommunicationsProtocol Called"
            @system.Devices.Count.times do |i|
                dev = @system.Devices[i]
                printed_name = dev.Name
                if printed_name.empty?
                    printed_name = 'Unknown Device'
                end
                $LOG.debug "index #{i}: '#{printed_name}' using #{lookup_WMProtocol(dev.CommunicationsProtocol)} (#{dev.CommunicationsProtocol})"
            end
        end

        ########################################################################
        #
        # @function find_by_name_with_protocol
        #
        # Finds a given device using the requested protocol if one exists on
        # the current system.
        #
        # @note WM_COMMS_PROTOCOL types are available once a system is connected.
        #       To display a list of the types available access
        #       @@WM_COMMS_PROTOCOL_CODES.
        #
        # @param [String]  device_name Name of the device to find (e.g. WM5110).
        # @param [Integer] protocol    The WM_COMMS_PROTOCOL to use.
        #
        # @return [WIN32OLE] The matching device or nil if not available.
        #
        ########################################################################
        def find_by_name_with_protocol( device_name, protocol )
            device = nil
            @system.Devices.Count.times do |i|
                dev = @system.Devices[i]
                if dev.Name == device_name and dev.CommunicationsProtocol == protocol
                    device = dev
                end
            end

            return device
        end

        ########################################################################
        #
        # @function connect_device
        #
        # Attempt to connect to a specific device and protocol (if possible).
        #
        # @note A system should have already been detected prior to calling
        #       this method.
        #
        # @note WM_COMMS_PROTOCOL types are available once a system is connected.
        #       To display a list of the types available access
        #       @@WM_COMMS_PROTOCOL_CODES.
        #
        # @param [String]  device_name Name of the device to connect to
        #                              (e.g. WM5110).
        # @param [Integer] protocol    The WM_COMMS_PROTOCOL to use.
        #
        # @return [Integer] The WM_COMMS_PROTOCOL used by the found device.
        #
        # @raise Will raise an exception if the named element is not found.
        #
        ########################################################################
        def connect_device( device_name, protocol )
            ret_protocol = nil
            device = find_by_name_with_protocol( device_name, protocol )

            unless device.nil?
                @device = device
            else
                $LOG.debug "WISCE API - Devices Called"
                @device = find_by_name( @system.Devices, device_name )
            end

            unless @device.nil?
                $LOG.debug "WISCE API - CommunicationsProtocol Called"
                ret_protocol = @device.CommunicationsProtocol
            end

            return ret_protocol
        end

        ########################################################################
        # @function playtime
        #
        # It gives the total playback time.
        #
        # @return [Float] The total playback time
        #
        ########################################################################
        def playtime
            return @playtime
        end

        ########################################################################
        #
        # @function enable_spi
        #
        # Connects to a system, enables SPI on the FPGA and allows both devices
        # to be found through detection.
        #
        # @note A system should have already been detected prior to calling
        #       this method.
        #
        # @note WM_COMMS_PROTOCOL types are available once a system is connected.
        #       To display a list of the types available access
        #       @@WM_COMMS_PROTOCOL_CODES.
        #
        # @param [String]  system_name Name of the system to connect to
        #                              (e.g. Aardvark).
        # @param [String]  device_name Name of the device to connect to
        #                              (e.g. WM5110).
        #
        ########################################################################
        def enable_spi( system_name, device_name )
            #
            # TODO: Ideally device detection should be altered such that all
            #       protocol methods for a device should show up without having
            #       to add, remove, re-detect devices.
            #
            connect( system_name, device_name )
            # Enable SPI on the FPGA if not already done
            spi_ctrl = read_element_value( 'SPI_CTRL' )
            i2c_ctrl = read_element_value( 'I2C_CTRL' )
            unless '81' == spi_ctrl and '01' == i2c_ctrl
                if(device_name == 'LN2 FPGA')
                    usecase_from_file( 'LN2EmulationSetupUSBStreaming' )
                elsif(device_name == 'CS40L30_EMU_FPGA')
                    # Check profile loading is enabled/disabled
                    if Conf.property( :Load_profile, true )
                        usecase_from_file( FPGAUseCaseFile , { :source_path => FPGAUseCasePath } )
                    end
                else
                    usecase_from_file( 'EnableLochnagarSPI' )
                end
            end
            remove_device( device_name )
            add_spi
            $LOG.debug "WISCE API - DetectDevices Called"
            @system.DetectDevices
        end
        ########################################################################
        #
        # @function playback_from_host
        #
        # @param [String] file play file name
        # @option opts [String]   :type    Type of play default set to 'analog'
        #
        # @option opts [Boolean] :blocking Blocks/Unblocks the playback method,
        #                                  default set to true.
        #
        # @option opts [Array] :track_list track list for playback and recording
        #                                   of analog or digital data.
        #
        # @raise if the specified type is invalid
        #
        ########################################################################
        def playback_from_host(file, opts = {} )
            supported_opts = [:blocking, :type, :track_list ]
            validate_options( opts.keys, supported_opts, 'WISCESalad: (playback)' )

            blocking = opts.fetch( :blocking, true )
            type = opts.fetch( :type, 'analog' )
            track_list = opts.fetch(:track_list, nil)
            wave = WaveInfo.new( file )
            if type == 'analog'
                playback( file, channels: wave.channels, blocking: blocking )
            elsif type == 'digital'
                record = false
                @digital_input = track_list[0][0]
                multitrack_playback( track_list, record )
            else
              raise $LOG.error( 'Specified playback type is not supported' )
            end
        end

        ########################################################################
        #
        # @function end_pa_multitrack
        #
        # This method ends the PaMultitrack.
        #
        # @return [Boolean]  true  When it successfully kills pa_multitrack.exe
        #                             otherwise false is returned.
        ########################################################################
        def end_pa_multitrack
            exit_code = system( "tasklist /FI \"IMAGENAME eq pa_multitrack.exe\" | find /I \"pa_multitrack.exe\" > nul" )
            if exit_code
                task_exit_code = system( "taskkill /F /IM pa_multitrack.exe > nul 2>&1" )
            end
            return task_exit_code
        end

        ########################################################################
        #
        # @function end_playback_at_host
        # This method invokes the 'end_playback' method
        #
        # @option opts [String]   :type    Type of play default set to 'analog'
        # @raise if the specified type is invalid
        #
        ########################################################################
        def end_playback_at_host(type = nil)
            if type == 'analog'
                end_playback
            elsif type == 'digital'
                if @digital_playback_active
                    end_pa_multitrack
                    @digital_playback_active = false
                end
            else
                raise $LOG.error( 'Specified playback type is not supported' )
            end
        end

        #########################################################################
        #
        # @function record_output_at_host
        #
        # Capture output through line-in.
        #
        # The file-name used to save the captured output is stored in the
        # attribute @output.
        #
        # @param [Integer] sample_rate     Recording sample rate
        #
        # @param [Integer] channels        Number of recording channels
        #
        # @param [String]  type            Type of recording either analog or
        #                                  digital.
        #
        # @param [String] record_file_name The name of the recording file and
        #                                  by default set to
        #                                  'tmpfile_digitalRecording.wav'
        #
        # @param [Integer] record_time     Optional parameter to specify record
        #                                  time.
        #
        # @param [Array] track_list        Optional parameter to give track list
        #                                  for recording of digital data.
        #
        #########################################################################
        def record_output_at_host( sample_rate,
                                   channels,
                                   type,
                                   record_file_name = 'tmpfile_digitalRecording.wav',
                                   record_time = nil,
                                   track_list = nil
        )
            if ( 'analog' == type )
                @output = record_file_name
                record_output
            elsif( 'digital' == type )
                # Clone the track_list
                background = true
                record = true
                samples = sample_rate * record_time
                multitrack_playback(track_list,record,samples,background)
            else
                raise 'Specified recording type is not supported'
            end
        end

        #########################################################################
        #
        # @function end_digital_capture_at_host
        #
        # Ends PaMultitrack and adds wave header to output file if
        # single channel,clubs two mono files to stereo and then adds wave header
        # for stereo.
        #
        # @param [String] record_file_name Name of file to which recording must be
        #                                  done.
        #
        # @param [Integer] channels Number of channels to record.
        #
        # @raise [Runtime error] At present recording can be done for only
        #                        maximum of 2 channels. More than 2 channels will raise
        #                        a run time exception.
        #
        #########################################################################
        def end_digital_capture_at_host( record_file_name, channels )
            temp_file1 = File.join( ENV['FRUITSALAD_HOME'],
                                    'tmp/temp_file1.wav'
            )
            temp_file2 = File.join( ENV['FRUITSALAD_HOME'],
                                    'tmp/temp_file2.wav'
            )
            if @digital_recording_active
                task_kill_exit_code = end_pa_multitrack
                if STEREO_CHANNEL == channels
                    if task_kill_exit_code
                        FruitSalad::club_two_mono_to_stereo( temp_file1,
                                                             temp_file2,
                                                             record_file_name
                        )
                    end
                elsif MONO_CHANNEL == channels
                    if task_kill_exit_code
                        info = WaveFile::Reader.info( @digital_input )
                        FruitSalad::add_wave_header_to_pcm_file(
                            record_file_name,
                            info.channels,
                            info.bits_per_sample,
                            info.sample_rate
                        )
                    end
                else
                    raise 'Recording for more than 2 channels not supported'
                end
                @digital_recording_active = false
            end
        end

        #########################################################################
        #
        # @function end_capture_at_host
        #
        # If type is analog,terminates any active recording.
        # If type is digital,ends PaMultitrack and adds wave header to output file
        # single channel,clubs two mono files to stereo and then adds wave header
        # for stereo
        #
        # @param [String] type Type of the recording whether it is digital or
        #                 analog.
        # @param [String] opts Optional playback arguments. This platform
        #                      supports:
        #                      [String] record_file_name The recorded file name.
        #                      [Integer] channels No of channels of the recording.
        #
        # @raise [Runtime error] At present recording can be done for only
        #                        maximum of 2 channels. More than 2 channels will raise
        #                        a run time exception.
        #
        #########################################################################
        def end_capture_at_host( type, opts={} )
            supported_opts = [:record_file_name, :channels]
            validate_options( opts.keys, supported_opts, 'WISCESalad: (playback)' )
            if ('analog' == type )
                end_capture
            elsif( 'digital' == type )
                record_file_name = opts.fetch( :record_file_name, nil )
                channels = opts.fetch( :channels, nil )
                end_digital_capture_at_host( record_file_name, channels )
            else
                raise 'Specified end recording type is not supported'
            end
        end

        ########################################################################
        #
        # @function start_dsp_core
        #
        # @param [Fix_num] core_index   firmware core_index to load
        # @return true if firmware core started successfully
        #
        ########################################################################
        def start_dsp_core( core_index )
            $LOG.debug "WISCE API - StartCore() Called"
            success = @device.DSPCores[ core_index ].StartCore()
            return WISCE_CONST::WM_RESULT_WMR_SUCCESS == success
        end
        ########################################################################
        #
        # @function stop_dsp_core
        #
        # @param [Fix_num] core_index   firmware core_index to load
        # @return true if firmware core stopped successfully
        #
        ########################################################################
        def stop_dsp_core( core_index )
            $LOG.debug "WISCE API - StopCore() Called"
            success = @device.DSPCores[core_index].StopCore()
            return WISCE_CONST::WM_RESULT_WMR_SUCCESS == success
        end

        ########################################################################
        #
        # @function get_current_device_name
        #
        # Gives current device name
        #
        # @return returns device name
        ########################################################################
        def get_current_device_name()
            $LOG.debug "WISCE API - CurrentDevice,Name Called"
            device = @system.CurrentDevice
            return device.Name
        end

        ########################################################################
        #
        # @function get_required_device
        #
        #   get the required device and checks for existance of the device.
        #
        # @param [string] device_name name of the device that need to be check
        # @return [win32ole]
        #
        ########################################################################
        def get_required_device( device_name )
            $LOG.debug "WISCE API - Devices,Count Called"
            @system.Devices.Count.times do |i|
                dev = @system.Devices[i]
                printed_name = dev.Name
                if printed_name.empty?
                    printed_name = 'Unknown Device'
                end
                if printed_name == device_name
                    return @system.Devices[i]
                end
            end
            $LOG.debug "#{device_name} not found in the given #{@system}"
            return nil
        end

        ########################################################################
        # @function connect_target_device
        #
        # Establish a connection to the given device on given system.
        #
        # @param [Hash]   opts     Key value pairs of system name, device name,
        #                          device address and device file. we have to
        #                          use arguments as
        #                          :system_name - Name of the system to connect to (Ex: Aardvark)
        #                          :device_name - Name of the device to connect to(Ex: WM8281)
        #                          :device_address - The address of the device,Ex:0x80
        #                          :device_file - Device file name,
        #                           Ex: CS35L34_RegMap_RevA_0x80.xml
        #                          :control_interface_type - Control interface type,
        #                           Ex: CONTROL_INTERFACE_CTRL_4WIRE
        #
        ########################################################################
        def connect_target_device( opts = {} )
            supported_opts = [ :system_name, :device_name, :device_address, :device_file, :control_interface_type ]
            validate_options( opts.keys, supported_opts, 'WISCESalad: (connect_target_device)' )
            device_address = opts.fetch( :device_address, nil )
            device_file = opts.fetch( :device_file, nil )
            control_interface_type = opts.fetch( :control_interface_type, nil )
            connect( opts[:system_name],
                     opts[:device_name],
                     :device_address => device_address,
                     :device_file => device_file,
                     :control_interface_type => control_interface_type
                   )
        end

        ########################################################################
        # @function lochnagar_reset
        #           This Function will Reset the lochnagar Devices
        # @param [String] device_name that need to need to be Reset
        #                   ex: 'LN2 FPGA'
        #
        ########################################################################
        def lochnagar_reset( device_name )
            device = get_required_device( device_name )
            $LOG.debug "WISCE API - GetElement Called"
            reset = device.GetElement( 'SW_RST_DEV_ID' )
            $LOG.debug "WISCE API - UserValue Called"
            reset.UserValue = 0
            # Time required to reset the lochnagar
            sleep 10
            $LOG.info "Successfully reseted the Device"
        end

        ########################################################################
        #
        # @function flash_open
        #
        # Open a connection to the specified type of flash memory, using the
        # specified SPI gadget.
        #
        # This will disable the transport used by WISCE and configure the SPI for
        # control by the Aardvark. flash_close should be used to restore WISCE
        # and the SPI to their initial states when operations have finished.
        #
        # @option opts [Symbol] :flash_type     The type of flash memory to open,
        #                                       currently only supports :MX25R6435F
        #                                       which is the default.
        # @option opts [Symbol] :spi_gadget     The type of device to use to access
        #                                       the SPI lines. Currently only supports
        #                                       :aardvark, which is the default.
        #
        # @raise Any HRESULTs returned if they indicate failure
        # @raise If the hardware could not be found
        # @raise If the flash_type is not supported
        #
        ########################################################################
        def flash_open( opts = {} )
            @flash_type = opts.fetch( :flash_type, :MX25R6435F )
            $LOG.info "opening the flash "
            raise "unsupported flash chip" unless FLASH_DEVICES.include? @flash_type
            $LOG.debug "Flash type is #{@flash_type}\n"
            @lochnagar2 = get_required_device( DeviceNameLochnagar )
            flash_set_mux( true )
            @flash_device = WIN32OLE.new 'Wolfson.WISCE.VegaFlashDevice'
            $LOG.debug "Flash device is #{@flash_device}\n"
            hresult = @flash_device.Open @lochnagar2
            raise "Flash open failed with HRESULT #{hresult}" if hresult < 0
            #
            # try to put the device into high performance mode.
            # However; do not raise an exception if we fail.
            # It could be that the device under test does not implement it.
            #
            @flash_device.SetDeviceFlags( 0x01 )
            @context_open = true
            $LOG.info "End of flash open\n"
        end

        ########################################################################
        #
        # @function get_ln2_plugin_version
        #
        # A method which gets the version of Lochnagar2 Plugin Installed.
        #
        # @raise if more than one LN2 Plugins are installed or if LN2 Plugin is not installed.
        # @return [String] Version Number of Lochnagar2 Plugin.
        #
        ########################################################################
        def get_ln2_plugin_version
            plugin_folder = @core.GetStandardFolder( WISCE_CONST::FolderType_Plugin )
            path = File.join(plugin_folder+"/Lochnagar2_VCOM_Setup_Rev*.msi")
            path.gsub!(/\\/,"/")
            msi_files = Dir[ path ]
            if msi_files.length > 1
                raise "More than one Lochnagar2 Plugins are installed,please uninstall the currently unused version."
            elsif msi_files.length == 0
                raise "Lochnagar2 Plugin is not installed"
            end
            info = msi_files[0].match(/Lochnagar2_VCOM_Setup_Rev(.*).msi/)
            ln2_version = info[1]
            return ln2_version
        end

        ########################################################################
        #
        # @function flash_set_mux
        #
        # The flash chip's SPI bus is usually connected to a MUX which is controlled
        # by I2C. The MUX allows connection to either the Vega IC or to the SPI gadget
        # used by this set of APIs. Call flash_set_mux to switch between the 2 MUX
        # positions.
        #
        # Set connect_to_spi_gadget to true to configure the MUX to connect the
        # flash to the SPI gadget, or false to connect the flash to Vega.
        #
        # This API requires that the SPI gadget used for the flash connection also
        # has I2C and that it is connected to the MUX on the Lochanagar 2 (6271-EV2)/
        # FPGA Interposer (1560-EV1).
        #
        # @param [Boolean] connect_to_spi_gadget False to connect the flash to Vega,
        #                                        else true to configure the MUX to
        #                                        connect flash to the SPI gadget
        #
        ########################################################################
        def flash_set_mux( connect_to_spi_gadget )
            version = '00'
            ln2_version = get_ln2_plugin_version
            major_version_num = ln2_version.split("_")[0]
            if major_version_num.eql?(version)
                comms_ctrl_2  = @lochnagar2.LookupElement( "COMMS_CTRL_2" )
                card_resets   = @lochnagar2.LookupElement( "CARD_RESETS" )
                gpio_cdc_8    = @lochnagar2.LookupElement( "GPIO_CDC_8" )
            else
                comms_ctrl_2  = @lochnagar2.LookupElement( "COMMS_CTRL2" )
                card_resets   = @lochnagar2.LookupElement( "MINICARD_RESETS" )
                gpio_cdc_8    = @lochnagar2.LookupElement( "GPIO_CODEC_GPIO8" )
            end

            gpio_channel1 = @lochnagar2.LookupElement( "GPIO_CHANNEL1" )
            if connect_to_spi_gadget
                comms_ctrl_2.UserValue  = 0x000E
                card_resets.UserValue   = 0x0001
                gpio_cdc_8.UserValue    = 0x0001
                gpio_channel1.UserValue = 0x80FF
            else
                comms_ctrl_2.UserValue  = 0
                gpio_cdc_8.UserValue    = 0
                gpio_channel1.UserValue = 0
            end
        end

        ########################################################################
        #
        # @function context_open?
        #
        # reports the open status of the device.
        #
        # returns true if the device is open
        # returns false if the device is closed
        #
        ########################################################################
        def context_open?()
            return @context_open
        end

        ########################################################################
        #
        # @function get_max_absolute_address
        #
        # returns the maximum absolute address.
        #
        # @raise Any HRESULTs returned if they indicate failure
        #
        # @return the size of the device in bytes
        #
        ########################################################################
        def get_max_absolute_address()
            capacity = WIN32OLE_VARIANT.new( "0", WIN32OLE::VARIANT::VT_BYREF | WIN32OLE::VARIANT::VT_UI4 )
            # capacity is now a pointer to 4 byte unsigned int; just what we want!
            hresult = @flash_device.GetCapacity( capacity )
            raise "Flash capacity request failed with HRESULT #{hresult}" if hresult < 0
            $LOG.debug " Flash Capacity is #{capacity.value}"
            return capacity.value
        end

        ########################################################################
        #
        # @function get_sector_size
        #
        # returns the size of a single sector.
        #
        # @return the size of a sector in bytes
        #
        ########################################################################
        def get_sector_size()
            return FLASH_SECTOR_BYTE_COUNT
        end

        ########################################################################
        #
        # @function flash_close
        #
        # Close a previously opened connection.
        #
        # Restores the Flash SPI to normal operation and reenables WISCE
        # communication. This is a noop if the connection is not open.
        #
        # @raise Any HRESULTs returned if they indicate failure
        #
        ########################################################################
        def flash_close()
            if @context_open
                hresult = @flash_device.Close()
                @flash_device.ole_free
                $LOG.debug "hresult in  flash_close #{hresult}"
                raise "Flash close failed with HRESULT #{hresult}" if hresult < 0
                flash_set_mux( false )
                @context_open = false
            end
        end

        ########################################################################
        #
        # @function flash_read_bytes
        #
        # Synchronously reads byte_count bytes from the flash, starting at offset.
        # offset is specified in bytes from the beginning of the flash, and there
        # are no alignment requirements.
        #
        # @param [Integer] offset       The offset to begin reading from, in bytes
        #                               from the beginning of the flash.
        # @param [Integer] byte_count   The number of bytes to read into the buffer
        #
        # @param [Array]   buffer       The buffer to receive the data
        #
        # @return           An HRESULT from the OLE method
        #
        ########################################################################
        def flash_read_bytes( offset, byte_count, buffer )
            ole_buffer = WIN32OLE_VARIANT.array( [byte_count],
                                                WIN32OLE::VARIANT::VT_UI1   |
                                                WIN32OLE::VARIANT::VT_ARRAY |
                                                WIN32OLE::VARIANT::VT_BYREF
                                            )
            $LOG.debug "The starting address from where the bytes Read from #{offset}"
            hresult = @flash_device.Read( offset, ole_buffer )
            if hresult >= 0
                # if the ole method succeeded transfer the data
                # to the caller's buffer. We need to unpack the
                # string data to enable the caller to treat it
                # as an array of bytes
                for n in ole_buffer.value.unpack( 'C*' )
                    buffer.push( n )
                end
            end
            return hresult
        end

        ########################################################################
        #
        # @function flash_read_hash
        #
        # Synchronously reads byte_count bytes from the flash, starting at offset.
        # offset is specified in bytes from the beginning of the flash, and there
        # are no alignment requirements.
        #
        # @param [Integer] offset       The offset to begin reading from, in bytes
        #                               from the beginning of the flash.
        # @param [Integer] byte_count   The number of bytes to read into the buffer
        #
        # @param [MD5]     digest       An md5 hash of the data
        #
        # @return           An HRESULT from the OLE method
        # @return [Array]  Elements that are read from the flash
        #
        ###########################################################################
        def flash_read_hash( offset, byte_count, digest )
            buffer = Array.new
            hresult = flash_read_hash_and_data( offset, byte_count, digest, buffer )
            return hresult,buffer
        end

        ########################################################################
        #
        # @function flash_read_hash_and_data
        #
        # Synchronously reads byte_count bytes from the flash, starting at offset.
        # offset is specified in bytes from the beginning of the flash, and there
        # are no alignment requirements.
        #
        # @param [Integer] offset       The offset to begin reading from, in bytes
        #                               from the beginning of the flash.
        # @param [Integer] byte_count   The number of bytes to read into the buffer
        #
        # @param [MD5]     digest       An md5 hash of the data
        #
        # @param [Array]   buffer       The buffer to receive the data
        #
        # @return           An HRESULT from the OLE method
        #
        ########################################################################
        def flash_read_hash_and_data( offset, byte_count, digest, buffer )
            ole_result = flash_read_bytes( offset, byte_count, buffer )
            if ole_result >= 0
                digest.update( buffer.pack( 'C*' ) )
            end
            return ole_result
        end

        ########################################################################
        #
        # @function flash_write_bytes
        #
        # Synchronously writes bytes from an Array to the flash, starting at address
        # offset. offset is specified in bytes from the beginning of the flash and
        # there are no alignment requirements.
        #
        # Flash can only write 0 bits, in order to write 1s a sector must be erased,
        # and the 0s overwritten. This function does not perform this erase, only
        # the write. The user is responsible for calling flash_erase_sectors().
        #
        # @param [Integer]  offset  The offset to begin writing from, in bytes from
        #                           the beginning of the flash
        # @param [Array]    buffer  The byte buffer to write from
        #
        # @return           An HRESULT from the OLE method
        #
        ########################################################################
        def flash_write_bytes( offset, buffer )
            type      = WIN32OLE::VARIANT::VT_UI1 | WIN32OLE::VARIANT::VT_ARRAY
            ole_array = WIN32OLE_VARIANT.new( buffer, type )
            hres =  @flash_device.Write( offset, ole_array )
            raise "Failed to write to the flash #{hres}" if hres != 0
            return hres
        end

        ########################################################################
        #
        # @function flash_erase_sectors
        #
        # Synchronously erase sector_count sectors so that all bits in those sectors
        # are set to 1s. The first sector is assumed to begin at offset, which is
        # specified in bytes but MUST be aligned to FLASH_SECTOR_BYTE_COUNT bytes.
        # An error is raised if this is not the case.
        #
        # @param [Integer]   offset         The offset to begin erasing from, in bytes
        #                                   from the beginning of the flash, aligned
        #                                   to FLASH_SECTOR_BYTE
        # @param [Integer]   sector_count   The number of sectors to erase
        #
        # @return           An HRESULT from the OLE method
        #
        ########################################################################
        def flash_erase_sectors( offset, sector_count )

            buffer = []
            if offset % FLASH_SECTOR_BYTE_COUNT > 0
                raise "Offset #{offset} must be aligned with #{FLASH_SECTOR_BYTE_COUNT}"
            end
            hresult = @flash_device.EraseSectors( offset, sector_count )
            raise "Fail to erase the Sectors:" unless hresult == 0
            flash_read_bytes( offset, sector_count * FLASH_SECTOR_BYTE_COUNT, buffer )

            for i in 0...sector_count * FLASH_SECTOR_BYTE_COUNT
                raise "Faied to erase properly" unless buffer[i] == 255
            end

            return hresult
        end

        ########################################################################
        #
        # @function flash_erase_bytes
        #
        # @brief Erases the specified number of bytes, starting at offset 0.
        #
        # @param [Integer]   byte_count     The number of bytes to erase
        #
        # @remark This method is currently wrapper for flash_erase_sectors().
        #
        # @return           An HRESULT from the OLE method
        #
        ########################################################################
        def flash_erase_bytes( offset, byte_count )
            sector_count = ( ( byte_count + ( FLASH_SECTOR_BYTE_COUNT-1 ) ) )/FLASH_SECTOR_BYTE_COUNT
            return flash_erase_sectors( offset, sector_count )
        end

        ########################################################################
        #
        # @function flash_erase_chip
        #
        # Erase the entire flash chip.
        #
        # @return           An HRESULT from the OLE method
        #
        ########################################################################
        def flash_erase_chip
            retun = @flash_device.ChipErase()
            $LOG.debug "return value after the flash erase is #{retun}"
            return retun
        end

    end
end

# Configure the Device Factory to use our specialised device.
FruitSalad.type = FruitSalad::WISCESalad

#################################### end #######################################