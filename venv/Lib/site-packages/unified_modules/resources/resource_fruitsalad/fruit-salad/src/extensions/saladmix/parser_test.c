///////////////////////////////////////////////////////////////////////////////
///
///Copyright (c) 2014 Wolfson Microelectronics plc.  All rights reserved.
///
/// This software as well as any related documentation is furnished under 
/// license and may only be used or copied in accordance with the terms of the 
/// license. The information in this file is furnished for informational use 
/// only, is subject to change without notice, and should not be construed as 
/// a commitment by Wolfson Microelectronics plc. Wolfson Microelectronics plc
/// assumes no responsibility or liability for any errors or inaccuracies that
/// may appear in this document or any software that may be provided in
/// association with this document. 
///
/// Except as permitted by such license, no part of this document may be 
/// reproduced, stored in a retrieval system, or transmitted in any form or by 
/// any means without the express written consent of Wolfson Microelectronics plc. 
///
/// @file   parser_test.c
/// @brief  Unit test for parsing of CSV usecase files.
///
/// @version \$Id: parser_test.c 177 2014-09-23 11:37:47Z emmas $
///
/// Warning
///   This software is specifically written for Wolfson devices. It may not be
///   used with other devices.
///
///////////////////////////////////////////////////////////////////////////////

//
// Includes
//
#include "saladmix.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

//
// Macros
//
#define ASSERT( condition )         if ( !condition ) { return -1; }

///////////////////////////////////////////////////////////////////////////////
///
//  Function: testRowFromCSV
///
/// @brief Test creating a Row struct from a C-String of CSV data.
///
/// @param void
///
/// @return 0 if successful. Non-zero otherwise.
///
///////////////////////////////////////////////////////////////////////////////
int testRowFromCSV( void )
{
    char string[20] = "\"foobar\", \"bar1\", \"bar2\"";
    struct Row* row = CreateRow( string );
    ASSERT( 0 == strcmp( row->key, "\"foobar\"" ) );
    ASSERT( 0 == strcmp( row->values->head, "\"bar1\"" ) );
    ASSERT( 0 == strcmp( row->values->next->head, "\"bar2\"") );
    
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: testValuesAppend
///
/// @brief Test the filling out of a Values struct manually with calls to
//         ValuesAppend.
//
/// @param void
///
/// @return 0 if successful. Non-zero otherwise.
///
///////////////////////////////////////////////////////////////////////////////
int testValuesAppend( void ) 
{
    // Allocate a Values list on the heap.
    struct Values* pTestFixture = calloc( 1, sizeof( struct Values ) );

    char* test_value_a = "test value A";
    char* test_value_b = "test value B";
    char* test_value_c = "test value C";

    // Append 3 strings to the list.
    ValuesAppend( pTestFixture, test_value_a );
    ValuesAppend( pTestFixture, test_value_b );
    ValuesAppend( pTestFixture, test_value_c );
    
    //Verify the length of the list is exactly 3.
    ASSERT( 3 == ValuesLength( pTestFixture ) );

    // Verify that all three elements match the strings we appended.
    struct Values* pointer = pTestFixture;
    ASSERT( 0 == strcmp( pointer->head, "test value A" ) );
    pointer = pointer->next;
    ASSERT( 0 == strcmp( pointer->head, "test value B" ) );
    pointer = pointer->next;
    ASSERT( 0 == strcmp( pointer->head, "test value C" ) );

    // Delete the list.
    ValuesDelete( pTestFixture );

    return 0;    
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: testValuesToArray
///
/// @brief Test the conversion of a Values list to an integer array.
///
/// @param void
///
/// @return 0 if successful. Non-zero otherwise.
///
///////////////////////////////////////////////////////////////////////////////
int testValuesToArray( void ) 
{
    // Allocate a Values list on the heap.
    struct Values* pTestFixture = calloc( 1, sizeof( struct Values ) );

    // Append the numbers 4,5,7,1
    ValuesAppend( pTestFixture, "4");
    ValuesAppend( pTestFixture, "5");
    ValuesAppend( pTestFixture, "7");
    ValuesAppend( pTestFixture, "1");

    // Convert the list into an Array.
    long* array = ValuesArray( pTestFixture, ValuesLength( pTestFixture ) );

    // Verify that the Array equals {4,5,7,1}.
    ASSERT( 4 == array[0] );
    ASSERT( 5 == array[1] );
    ASSERT( 7 == array[2] );
    ASSERT( 1 == array[3] );

    // Delete both the array and the list.
    free( array );
    ValuesDelete( pTestFixture );
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: testLoadUsecase
///
/// @brief Loads an example, valid, usecase.
///
/// @param void
///
/// @return 0 if successful. Non-zero otherwise.
///
///////////////////////////////////////////////////////////////////////////////
int testLoadUsecase( void )
{
    int error_val = LoadUsecase( "valid_usecase.csv" );

    ASSERT( 0 == error_val );

    return 0;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: main
///
/// @brief Runs a suite of tests and outputs the success of each.
///
/// @param void
///
/// @return The number of failing tests.
///
///////////////////////////////////////////////////////////////////////////////
int main( void ) 
{
    int failed_tests = 0;
    int error_val;

    printf( "Running testRowFromCSV... " );
    error_val = testRowFromCSV();
    !error_val? printf( "Success!\n" ): printf( "Fail!\n" );
    failed_tests += error_val? 1: 0;

    printf( "Running testValuesAppend... " );
    error_val = testValuesAppend();
    !error_val? printf( "Success!\n" ): printf( "Fail!\n" );
    failed_tests += error_val? 1: 0;

    printf( "Running testValuesToArray... " );
    error_val = testValuesToArray();
    !error_val? printf( "Success!\n" ): printf( "Fail!\n" );
    failed_tests += error_val? 1: 0;

    printf( "Running testLoadUsecase... " );
    error_val = testLoadUsecase();
    !error_val? printf( "Success!\n" ): printf( "Fail!\n" );
    failed_tests += error_val? 1: 0;

    printf( "%d tests failed.\n", failed_tests );

    return failed_tests;
}

//////////////////////////////// END OF FILE //////////////////////////////////
