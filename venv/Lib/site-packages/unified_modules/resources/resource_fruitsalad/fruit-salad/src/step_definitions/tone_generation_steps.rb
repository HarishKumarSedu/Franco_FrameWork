###############################################################################
###
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file tone_generation_steps.rb
### @brief cucumber steps definition for generation and playback of simple waveforms.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

#
# Requires
#
require 'fruitsalad_utils'
require 'KMeans'
require 'logfw'

###############################################################################
#
# @!method When_I_play_sine_wave
#
# Generate and play a sine wave of some specific frequency.
#
#       Usage:
#       When I play a <frequency> [k]Hz sine wave for <duration> seconds [using <program>]
#
# @example When I play a 700 Hz sine wave for 4 seconds
# @example When I play a 1.4 kHz sine wave for 11 seconds
# @example When I play a 440 Hz sine wave for 5 seconds using metro
# @example When I play a 300 Hz sine wave for 2 seconds using wmp
#
# @param frequency The frequency of the wave to generate
# @param duration  How long to play the tone for
# @param program   The program to use to play the media file. One of
#                  'wmp', 'metro' or portaudio. Optional.
#
###############################################################################

When( /^I play(?: a)?(?: an)? (#{Frequency}) sine wave for (#{Number}) seconds?(?: using (wmp|metro|portaudio))?$/ ) do |frequency, length, program|
    filename = FruitSalad::generate_sinewave( frequency, length )
    if program.nil?
        FruitSalad::get_device().playback( filename )
    else
        FruitSalad::get_device().playback( filename, program: program )
    end
end

###############################################################################
#
# @!method Then_the_output_has_frequency_peak
#
# The fundamental frequency should match some value. Assuming our captured
# output is a periodic signal, then it should have some defined fundamental
# frequency.
#
#       Usage:
#       Then the output has frequency spectrum with peak at <frequency> [k]Hz [with error <error> Hz]
#
# @example Then the output has frequency spectrum with peak at 440 Hz with error 0.5 Hz
# @example Then the output has frequency spectrum with peak at 1 kHz with error 0.2 Hz
# @example Then the output has peak at 1 kHz
#
# @param frequency The fundamental frequency measured
# @param error     The acceptable margin for error the measurement can fall within
#
###############################################################################
Then( /^(?:the )?output has(?: frequency spectrum)?(?: with)? peak(?: at)? (#{Frequency})(?:(?:,)?(?: with)? error (#{Frequency}))?$/) do
    |frequency, error|
    FruitSalad.get_device().end_capture()
    if nil == error
        error = Conf.property("Analyzer_FrequencyTolerance", 0.5)
    end
    measured_frequency = FruitSalad.peak_frequency( FruitSalad.get_device().output )
    $LOG.debug "Measured Frequency: #{measured_frequency}"
    unless measured_frequency <= frequency + error and measured_frequency >= frequency - error
        raise( "Measured peak frequency was #{measured_frequency}, expected #{frequency} +/- #{error}." )
    end
end

###############################################################################
#
# @!method Then_the_output_contains_tones
#
# Verify that the recorded output contains multiple expected frequencies.
#
# Supported FFT options:
#    (with|and) error <Number> Hz
#    (with|and) threshold <Number> dB
# where:
#    error     - tolerance needed to declare a frequency as found.
#    threshold - threshold (noise floor) under which a tone will be discarded.
#
#       Usage:
#       Then the output contains tones<FFT options>*:
#           | frequency     |
#           | <frequency 1> |
#           | <frequency 2> |
#           ...
#           | <frequency N> |
#
# @example Then the output contains tones with error 5 Hz:
# @example | frequency |
# @example | 1000 Hz   |
# @example | 2000 Hz   |
# @example | 3 kHz     |

# @example Then the output contains tones with threshold -12 dB and error 5 Hz:
# @example | frequency |
# @example | 1000 Hz   |
# @example | 2000 Hz   |
#
# @param fft_options Optional string to be processed further for FFT options.
# @param table       The table of frequencies to search for.
#
###############################################################################
Then( /^the output contains tones(.*):$/ ) do |fft_options, table|
    options_hash =  FruitSaladUtils::convert_fft_options( fft_options )
    error = options_hash[:error]

    device = FruitSalad::get_device
    device.end_capture()
    # Extract info from table
    expected_frequencies = table.rows.map do |row|
        FruitSaladUtils::string_to_frequency row[0]
    end
    # Calculate measured frequencies
    measured_frequencies = FruitSalad::dominant_frequencies device.output, options_hash
    # Find the expected frequencies
    missing = FruitSalad::verify_frequency_clusters(
                                                    expected_frequencies,
                                                    measured_frequencies,
                                                    error
                                                   )
    if missing.length > 0
        $LOG.debug "Missing frequencies: #{missing}"
        raise "Fourier transform does not match expected output."
    end

end

###############################################################################
#
# @!method Then_the_output_does_not_contain_tones
#
# Assert that the dominant frequencies do not include any bins in one or more
# ranges.
#
# Supported FFT options:
#    (with|and) threshold <Number> dB
# where:
#    threshold - threshold (noise floor) under which a tone will be discarded.
#
#       Usage:
#       Then the output does not contain tones in bands<FFT options>*:
#           | low                   | high                  |
#           | <range 1 lower bound> | <range 1 upper bound> |
#           | <range 2 lower bound> | <range 2 upper bound> |
#           ...
#           | <range N lower bound> | <range N upper bound> |
#
# @example Then the output does not contain tones in bands:
# @example | low | high |
# @example | 0 Hz | 995 Hz |
# @example | 1.1 kHz | 4 kHz |

# @example Then the output does not contain tones in bands with threshold -24 dB:
# @example | low | high |
# @example | 0 Hz | 995 Hz |
# @example | 1.1 kHz | 4 kHz |
#
# @param fft_options Optional string to be processed further for FFT options.
# @param table       The table of ranges to exclude. Should be labled as low and high.
#
###############################################################################
Then( /^the output does not contain tones in bands(.*):$/ ) do |fft_options, table|
    options_hash =  FruitSaladUtils::convert_fft_options( fft_options )

    device = FruitSalad::get_device
    device.end_capture
    table.map_headers!( /low/i => :low, /high/i => :high )
    measured_frequencies = FruitSalad::dominant_frequencies device.output, options_hash
    failed = false
    table.hashes.each do |range|
        low = FruitSaladUtils::string_to_frequency range[:low]
        high = FruitSaladUtils::string_to_frequency range[:high]
        measured_frequencies.each do |measured|
            if low <= measured && measured <= high
                failed = true
                $LOG.debug "Tone #{measured} Hz in range [#{low}, #{high}]"
            end
        end
    end
    raise 'Unacceptable tones found.' if failed
end

###############################################################################
#
# @!method When_I_play_white_noise
#
# Generation and playback of white noise.
#
#       Usage:
#       When I play <duration> seconds of white noise [using <program>]
#
# @example When I play 3 seconds of white noise
# @example When I play 2 seconds of white noise using wmp
# @example When I play 1 second of white noise using metro
# @example When I play 1 second of white noise using portaudio
#
# @param duration How long to play white noise for
# @param program  Which program to use for third party playback. This is one of
#                  'wmp', 'metro' or portaudio. Optional.
#
###############################################################################
When( /I play (#{Number}) seconds? of white noise(?: using (wmp|metro|portaudio))?/ ) do |length, program|
    length = length
    filename = FruitSalad::generate_mls_whitenoise( length )
    if program.nil?
        FruitSalad::get_device().playback( filename )
    else
        FruitSalad::get_device().playback( filename, program: program )
    end
end

###############################################################################
#
# @!method When_I_play_for_duration_the_sinewaves_table
#
# Generate multiple sine waves and assign each to a different playback channel.
#
#       Usage:
#       When I play for <duration> seconds the sinewaves:
#           | frequency     | channel           |
#           | <frequency 1> | <channel index 1> |
#           | <frequency 2> | <channel index 2> |
#           ...
#           | <frequency N> | <channel index N> |
#
# @example When I play for 5 seconds the sinewaves:
# @example | 1000 Hz | 0 |
# @example | 2000 Hz | 1 |
# @example | 3 kHz   | 2 |
#
###############################################################################
When( /^I play for,? (#{Number}) seconds?,? the sinewaves:$/ ) do |duration, table|
    device = FruitSalad::get_device
    table.map_headers!( /frequency/i => :frequency, /channel/i => :channel )
    list = table.hashes.map do |row|
        frequency = FruitSaladUtils::string_to_frequency( row[:frequency] )
        [ frequency, row[:channel].to_i ]
    end
    file = FruitSalad::mix_sinewaves_by_channel( list, duration )
    sleep 1 # Wait for buffers to flush.
    device.playback( file )
end

###############################################################################
#
# @!method When_I_play_for_the_sinewaves_of_given_amplitude
#
# Generate multiple sine waves of given amplitude and assign each to a different
# playback channel.
#
#       Usage:
#       When I play for <duration> seconds the sinewaves of given amplitudes:
#           | frequency     | channel           | amplitude     |
#           | <frequency 1> | <channel index 1> | <amplitude 1> |
#           | <frequency 2> | <channel index 2> | <amplitude 2> |
#           ...
#           | <frequency N> | <channel index N> | <amplitude N> |
#
# @example When I play for 5 seconds the sinewaves of given amplitudes:
# @example | 1000 Hz | 0 | 0.1 |
# @example | 2000 Hz | 1 | 0.1 |
#
###############################################################################
When( /^I play for,? (#{Number}) seconds?,? the sinewaves of given amplitudes:$/ ) do |duration, table|
    device = FruitSalad::get_device
    table.map_headers!( /frequency/i => :frequency, /channel/i => :channel,
                        /amplitude/i => :amplitude )
    list = table.hashes.map do |row|
        frequency = FruitSaladUtils::string_to_frequency( row[:frequency] )
        [ frequency, row[:channel].to_i, row[:amplitude].to_f ]
    end
    file = FruitSalad::mix_sinewaves_by_channel( list, duration )
    sleep 1 # Wait for buffers to flush.
    device.playback( file )
end

###############################################################################
#
# @!method Then_the_output_is_not_saturated_for_frequency
#
# Check that output is not saturated when sinewave of given amplitude is played.
#
#       Usage:
#       Then the output is not saturated for frequency:
#           | frequency     |
#           | <frequency 1> |
#           | <frequency 2> |
#           ...
#           | <frequency N> |
#
# @example Then the output is not saturated for frequency:
# @example | 1000 Hz   |
# @example | 2 kHz     |
#
###############################################################################
Then( /^the output is not saturated for frequency:$/ ) do |table|
    device = FruitSalad::get_device
    device.end_capture
    # Extract info from table
    expected_frequencies = table.rows.map do |row|
        FruitSaladUtils::string_to_frequency row[0]
    end
    saturation_flag = FruitSalad::saturation_check device.output, expected_frequencies
    if ( saturation_flag == true )
        raise 'Saturation occured in output. Playback and Record volume is too high. Adjust it'
    else
        $LOG.info 'Saturation not occured in output'
    end
end

#################################### END OF FILE ##############################