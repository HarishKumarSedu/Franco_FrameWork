################################################################################
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd. All rights
### reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   configuration.rb
### @brief  Loads configurable variables from a YAML file.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
###############################################################################

#
# Includes
#
require 'safe_yaml'
require 'fruitsalad_utils'
require 'defaults'

#
# Set up YAML engine
#
SafeYAML::OPTIONS[:default_mode] = :safe
SafeYAML::OPTIONS[:deserialize_symbols] = true

###############################################################################
#
# Singleton object which loads the contents of a YAML file as a hashmap
# dictionary.
#
###############################################################################
class Conf

    include Defaults

    @@filename = FruitSaladUtils::select_file_with_local_pref( File.join( 'configs', 'default_conf.yaml' ) )
    @@device_filename = nil
    @@open_config = nil

    # Dict is a Hash object that configuration variables are stored in.
    attr_reader :dict

    ###########################################################################
    #
    # Sets the file containing YAML key-value pairs which will make up our
    # configuration hashmap.
    #
    # @param [String] filename     The path to the YAML file.
    # @param [Boolean] device_yaml Flag to indicate whether the given filename
    #                              is for configuration file or device file.
    #
    ###########################################################################
    def self.set_source( filename, device_yaml = false )
        if( device_yaml == false )
            @@filename = filename
            @@open_config = nil
        else
            @@device_filename = filename
        end
    end

    ###########################################################################
    #
    # Gets the named configuration variable or a default value if not specified
    #
    # If the requested key is not already in the table it will be inserted, and
    # default_value assigned to it.
    #
    # @param [String, Symbol] key  The variable's name either as a symbol
    #                              or a string
    # @param [Integer]             default_value A value to be used if this key
    #                              is not already in the hashmap
    #
    # @return The value associated with the key
    #
    ###########################################################################
    def self.property( key, default_value )
        if nil == @@open_config
            @@open_config = self.new
        end
        key = key.to_s
        value = @@open_config.dict.fetch( key, nil )
        if value.nil? # Insert the first default key used, so subsequent
                      # references use the same key.
            @@open_config.dict[key] = default_value
            value = default_value
        end
        return value
    end

    ###########################################################################
    #
    # @function merge_defaults_into_map
    #
    # Merge the default values of an object into the object defined in the
    # config file.
    #
    # Where they cannot be merged (i.e. scalars or an array) the branch is kept
    # and the default ignored.
    #
    # @param [Hash]     branch      The object to merge defaults in to
    # @param [Hash]     defaults    The default object to merge underneath
    #
    # @return [Hash] The merged configuration tree.
    #
    ###########################################################################
    def merge_defaults_into_map( branch, defaults )
        if branch.nil?
            branch = defaults
        elsif branch.is_a? Hash and defaults.is_a? Hash
            defaults.each do |key, default|
                branch[key] = merge_defaults_into_map( branch[key], default )
            end
        end
        return branch
    end

    ###########################################################################
    #
    # @function dump_config
    #
    # Write the contents of the configuration to standard output.
    #
    # (no parameters)
    #
    ###########################################################################
    def self.dump_config
        puts "Config dump: #{@@open_config.dict}"
    end

    ###########################################################################
    #
    # Overwrite a key in the dictionary.
    #
    # @param [String, Symbol] key   The variable's name as either a symbol or
    #                               a string.
    # @param                  value The value to write into the dict.
    #
    ###########################################################################
    def self.set( key, value )
        if nil == @@open_config
            @@open_config = self.new
        end
        key = key.to_s
        @@open_config.dict[key] = value
    end

    ##############################################################################
    #
    # Default constructor.
    #
    ##############################################################################
    def initialize
        @dict = YAML.load_file( @@filename )
        unless @dict
            @dict = {}
        end

        # Write default values for empty keys.
        @@default_pairs.each do |pair|
            key = pair[0].to_s
            value = pair[1]
            dict[key] = dict.fetch( key, value )
        end
        # Load default firmware data
        dict["Firmware"] = merge_defaults_into_map( dict["Firmware"], @@firmware )

        unless @@device_filename.nil?
            store = YAML.load_file( @@device_filename )
            @dict = store.merge( @dict )
        end
    end

    #######################################################################
    # @function hash_lookup_value
    #
    # Looks up a symbol from the loaded config file, if this is a hash proceeds to
    # lookup the specified key and returns its value.
    #
    # e.g. in the yaml config file a lookup table for firmware names:
    #    Firmware_names: {Ez2 Control: FIRMWARE_FLORIDA_EZ2CONTROL}
    #
    # TODO: Is this the most appropriate format for providing implementation details to
    #       FruitSalad without convoluting the feature files? Alternatively dedicated support
    #       could be given for YAML/XML descriptions for firmwares, devices or other detail
    #       not wanted in the features.
    #
    # @param [Symbol] config_symbol Symbol of the Hash to lookup from the config.
    # @param [String] lookup_key The key to lookup in the hash.
    #
    # @return [Object] The value of the config hash for the given key
    #
    # @raise If no Hash available for name lookup or if lookup_key could not be found.
    #
    #######################################################################
    def self.hash_lookup_value( config_symbol, lookup_key )
        config_hash = property( config_symbol, nil )
        if config_hash.nil? || !config_hash.is_a?( Hash )
            raise "Unable to find Hash #{config_symbol}, has it been set in the config file?"
        end

        unless config_hash.has_key?( lookup_key )
            raise "No such key '#{lookup_key}' in config hash, check config file value for #{config_symbol}."
        end

        return config_hash[lookup_key]
    end

    ###########################################################################
    #
    # @function get_firmware_data
    #
    # Obtain the firmware data structure defined in the configuration file.
    # This will check for the firmware data using array of device id and
    # hw revision. If there is no configuration found, it will
    # check based on the device id. If it succeeds, it gets the firmware
    # information based on the algorithm.
    #
    # @param [Integer] device_id          Device ID
    # @param [Integer] hw_revision        Hardware Revision
    # @param [String]  firmware_name       The name of the firmware to retrieve the
    #                                     details for.
    # @param [String]  firmware_revision   The revision of the firmware.
    #
    # @return [Hash] The firmware object for this firmware defined in the
    #                config file.
    #
    # @raise [RuntimeError] If the firmware is not defined in the configuration
    #                       file or the defaults.
    #
    ###########################################################################
    def self.get_firmware_data( device_id, hw_revision, firmware_name, firmware_revision = nil )
        firmware_hash = Conf.property( :Firmware, {} )

        # Look up is done by using array of device id and hw_revision
        lookup_key1 = [device_id, hw_revision]

        # Fetch based on Device ID and HW Version
        device = firmware_hash.fetch( lookup_key1, nil )

        # If not found fetch based on Device ID
        if device.nil?
             lookup_key2 = [device_id]
             device = firmware_hash.fetch( lookup_key2, nil )
             device = firmware_hash if device == nil
        end

        if device.nil?
            raise "Firmware data for #{lookup_key1} or #{lookup_key2} not
                   found in #{firmware_hash}"
        end
        if !firmware_revision.nil?
            firmware_name = firmware_name.to_s + firmware_revision.to_s
        end
        firmware = device.fetch( firmware_name, nil )

        if firmware.nil?
           raise "Firmware data for #{firmware_name} not found in #{device}"
        end
        return firmware
    end

end

###############################################################################
#
# Utility class for representing nested properties. NestedProperty is designed
# to parse a nested hash map and represent it as an object so that each of its
# keys is mapped to a method returning the value corresponding to the given
# key (which will be either of type NestedProperty itself or of any other
# type). For example if you parse as 'properties':
#
# Ez2 Control: !{Trigger_Phrase_Found_Counter: {memory_offset: 64}}
#
# you will be able to access 'memory_offset' as:
#
# properties.Trigger_Phrase_Found_Counter.memory_offset
#
###############################################################################
class NestedProperty

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor.
    #
    # @param [String] property_name Name of the parsed property.
    # @param [Hash]   parameters    A hash containing parameters of a given
    #                               property (may be nested properties
    #                               themselves).
    #
    ###########################################################################
    def initialize( property_name, parameters )
        @property_name = property_name
        @parameters = {}
        parameters.each do |parameter, properties|
            if properties.is_a? Hash
                @parameters[parameter] = NestedProperty.new( parameter,
                                                             properties
                                                           )
            else
                @parameters[parameter] = properties
            end

            define_singleton_method( parameter ) do
                @parameters[parameter]
            end
        end
    end

    ###########################################################################
    #
    # @function method_missing
    #
    # Overrides standard implementation of method_missing.
    #
    # @param method_name Name of the missing method.
    # @param args        Arguments passed into the method.
    # @param block       Code block passed into the method.
    #
    # @raise [RuntimeError] An exception is thrown to indicate an unknown method
    #                       has been called.
    #
    ###########################################################################
    def method_missing( method_name, *args, &block )
        raise "Parameter '#{method_name}' is not configured for the "         \
              "'#{@property_name}' property."
    end
end
##################################### END OF FILE ###############################