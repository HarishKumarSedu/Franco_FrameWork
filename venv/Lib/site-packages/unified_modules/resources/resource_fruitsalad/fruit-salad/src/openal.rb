###############################################################################
###
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   openal.rb
### @brief  Bindings for the OpenAL implementation OpenAL Soft.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

#
# Requires
#
require 'ffi'
require 'configuration'
require 'logfw'

###############################################################################
#
# Provides a wrapper around OpenAL Soft with bindings for a subset of the library.
# This wrapper is written with our virtual room  feature in mind. Unit tests
# for this module can be found in 'test/test_openal.rb'.
#
###############################################################################
module OpenAL
    extend FFI::Library
    ffi_lib [ 'soft_oal', 'openal' ]

    #
    # Sample rate configuration variable. Controls the sample rate of both
    # the rendering buffer and the sample rate at which waveform data will be
    # loaded into OpenAL buffer objects.
    #
    SampleRate = Conf.property( :SampleRate, 48000 )
    #
    # Scales the attenuation with respect to distance and represents the distance
    # at which attenuation begins to occur (all distances less than this are
    # clamped)
    #
    ReferenceDistance = Conf.property( :VirtualRoom_ReferenceDistance, 200.0 )
    #
    # The maximum value for a sample encoded in a signed 16bit integer,
    # corresponding to +1.0.
    #
    INT16Max = 32767
    # Magic numbers found in alc.h and al.h
    ALC_FREQUENCY = 0x1007
    ALC_FORMAT_CHANNELS_SOFT = 0x1990
    ALC_FORMAT_TYPE_SOFT = 0x1991
    ALC_MONO_SOFT = 0x1500
    ALC_FLOAT_SOFT = 0x1406
    AL_POSITION = 0x1004
    AL_BUFFER = 0x1009
    AL_FORMAT_MONO16 = 0x1101
    AL_REFERENCE_DISTANCE = 0x1020

    ###########################################################################
    #
    # Encapsulates the pointer into which the Buffer and Source name is written
    # by OpenAL and can be used as an opaque handle when calling methods in this
    # wrapper.
    #
    ###########################################################################
    class OALName

        #
        # The underlying pointer data passed to the Native OpenAL functions.
        #
        attr_reader :pointer

        #######################################################################
        #
        # @function initialize
        #
        # Default constructor.
        #
        # (no parameters)
        #
        #######################################################################
        def initialize
            @pointer = FFI::MemoryPointer.new( :int, 1 )
        end

        #######################################################################
        #
        # @function name
        #
        # Returns the value stored at @pointer, which will be the integer name of
        # the buffer or source as written by the native code OpenAL functions.
        #
        # @return [Fixnum] The name of the buffer or source
        #
        #######################################################################
        def name
            return @pointer.get_int(0)
        end
    end

    ###########################################################################
    #
    # Specialisation of OALName specifically for Buffer objects.
    #
    ###########################################################################
    class Buffer < OALName
    end

    ###########################################################################
    #
    # Specialisation of OALName specifically for Source objects.
    #
    ###########################################################################
    class Source < OALName
    end

    ###########################################################################
    #
    # @function start
    #
    # Begins our OpenAL service by openning the software loopback device,
    # using it to create a global context, and then setting that as the current
    # context.
    #
    # (no parameters)
    #
    # @raise [RunTimeError] If either the device or context cannot be initialised
    #
    ###########################################################################
    def self.start
        device = alcLoopbackOpenDeviceSOFT( nil )
        raise "OpenAL could not open loopback device." if device.null?

        context = alcCreateContext( device, context_attribute_list )
        raise "OpenAL could not open context." if context.null?

        alcMakeContextCurrent( context )
        $LOG.info "OpenAL ready."
    end

    ###########################################################################
    #
    # @function stop
    #
    # Stops our OpenAL service, freeing the current context and the software
    # loopback device.
    #
    # (no parameters)
    #
    ###########################################################################
    def self.stop
        context = alcGetCurrentContext()
        device = alcGetContextsDevice( context )

        alcMakeContextCurrent( nil )
        alcDestroyContext( context )
        alcCloseDevice( device )
        $LOG.info "OpenAL closed."
    end

    ###########################################################################
    #
    # @function create_buffer
    #
    # Allocates a buffer and fills it with waveform data from a ruby array.
    #
    # @param [Array<Float>] waveform The waveform data this buffer should contain.
    #
    # @return [Buffer] The OpenAL buffer object.
    #
    ###########################################################################
    def self.create_buffer( waveform )
        buffer = Buffer.new
        alGenBuffers( 1, buffer.pointer )

        # Load data
        waveform_carray = FFI::MemoryPointer.new( :int16, waveform.length )
        waveform.map! do |sample|
            # Normalise data to 16bit integer
            sample = (sample * INT16Max).to_i
        end
        waveform_carray.write_array_of_int16( waveform )
        # Fourth parameter is the amount of data to write in bytes - at 16bits/samples
        # we are writing 2 bytes per sample.
        alBufferData( buffer.name, AL_FORMAT_MONO16, waveform_carray, waveform.length*2, SampleRate )

        return buffer
    end

    ###########################################################################
    #
    # @function release_buffer
    #
    # Mark a buffer as unused.
    #
    # @param [Buffer] buffer The buffer object
    #
    ###########################################################################
    def self.release_buffer( buffer )
        alDeleteBuffers( 1, buffer.pointer )
    end

    ###########################################################################
    #
    # @function create_source
    #
    # Allocate an OpenAL source object and assign it to both a position and
    # buffer object.
    #
    # @param [Buffer]  buffer An OpenAL buffer, returned by create_buffer
    # @param [Numeric] x      First positional coordinate
    # @param [Numeric] y      Second positional coordinate
    # @param [Numeric] z      Third positional coordinate
    #
    # @return [Source] The OpenAL source object
    #
    ###########################################################################
    def self.create_source( buffer, x,y,z )
        source = Source.new
        alGenSources( 1, source.pointer )
        # Set position
        alSource3f( source.name, AL_POSITION, x, y, z )
        # Set buffer
        alSourcei( source.name, AL_BUFFER, buffer.name )
        # Set attenuation constants
        alSourcef( source.name, AL_REFERENCE_DISTANCE, ReferenceDistance )

        return source
    end

    ###########################################################################
    #
    # @function release_source
    #
    # Marks the OpenAL source object as unused
    #
    # @param [Source] source The OpenAL source object, returned by create_source.
    #
    ###########################################################################
    def self.release_source( source )
        alDeleteSources( 1, source.pointer )
    end

    ###########################################################################
    #
    # @function play
    #
    # Begin synchronised playback on a number of sources and render the listener's
    # audio buffer to a ruby array of floating point samples.
    #
    # @param [Array<Source>] list_of_sources An array of OpenAL sources as
    #                                        returned by create_source
    # @param [Numeric]       duration        The length of the recording to render
    #                                        in units seconds
    #
    # @return [Array<Float>] The final rendered audio data corresponding to
    #                        the listener position.
    #
    ###########################################################################
    def self.play( list_of_sources, duration )
        # Start playback
        number = list_of_sources.length
        sources_carray = FFI::MemoryPointer.new( :int, number )
        sources_carray.write_array_of_int( list_of_sources.map { |a| a.name } )
        alSourcePlayv( number, sources_carray )
        # Render samples
        samples_to_render = (SampleRate * duration).ceil
        rendered_carray = FFI::MemoryPointer.new( :float, samples_to_render )
        alcRenderSamplesSOFT( device, rendered_carray, samples_to_render )
        rendered_samples = rendered_carray.read_array_of_float( samples_to_render )
        # Stop playback
        alSourceStopv( number, sources_carray )
        # Rewind
        alSourceRewindv( number, sources_carray )
        return rendered_samples
    end

    ###########################################################################
    #
    # @function listener=
    #
    # Sets the position of the listener within the current OpenAL context.
    #
    # @param [Array<Numeric>] position An array containing 3 spacial coordinates
    #
    ###########################################################################
    def self.listener=( position )
        alListener3f( AL_POSITION, position[0], position[1], position[2] )
    end

    private

    ###########################################################################
    #
    # @function device
    #
    # Returns the pointer to the loopback device associated with the currently
    # open OpenAL context.
    #
    # (no parameters)
    #
    # @return [FFI::Pointer] The OpenAL device pointer
    #
    ###########################################################################
    def self.device
        context = alcGetCurrentContext()
        device = alcGetContextsDevice( context )
        return device
    end

    ###########################################################################
    #
    # @function context_attribute_list
    #
    # Creates a native array containing the null-terminated sequence of key-value
    # integer tokens necessary to configure our context as a mono mix at our
    # global sample rate, using floating-point samples. Definitions of the magic
    # numbers can be found in OpenAL SOFT's include/AL/ALc.h header.
    #
    # (no parameters)
    #
    # @return [FFI::MemoryPointer] Pointer to a null-terminated native array of
    #                              integer key-value pairs.
    #
    ###########################################################################
    def self.context_attribute_list
        ruby_array = [
                       ALC_FREQUENCY, SampleRate,
                       ALC_FORMAT_CHANNELS_SOFT, ALC_MONO_SOFT,
                       ALC_FORMAT_TYPE_SOFT, ALC_FLOAT_SOFT,
                       0x0
                     ]
        carray = FFI::MemoryPointer.new( :int, ruby_array.length )
        carray.write_array_of_int( ruby_array )
        return carray
    end

    # C Functions
    attach_function :alcLoopbackOpenDeviceSOFT, [:pointer], :pointer
    attach_function :alcCreateContext, [:pointer, :pointer], :pointer
    attach_function :alcMakeContextCurrent, [:pointer], :bool
    attach_function :alcGetCurrentContext, [], :pointer
    attach_function :alcGetContextsDevice, [:pointer], :pointer
    attach_function :alcDestroyContext, [:pointer], :void
    attach_function :alcCloseDevice, [:pointer], :bool
    attach_function :alGenBuffers, [:int, :pointer], :void
    attach_function :alDeleteBuffers, [:int, :pointer], :void
    attach_function :alGenSources, [:int, :pointer], :void
    attach_function :alDeleteSources, [:int, :pointer], :void
    attach_function :alSource3f, [:int, :int, :float, :float, :float], :void
    attach_function :alSourcei, [:int, :int, :int], :void
    attach_function :alSourcef, [:int, :int, :float], :void
    attach_function :alBufferData, [:int, :int, :pointer, :int, :int], :void
    attach_function :alListener3f, [:int, :float, :float, :float], :void
    attach_function :alSourcePlayv, [:size_t, :pointer], :void
    attach_function :alSourceStopv, [:size_t, :pointer], :void
    attach_function :alcRenderSamplesSOFT, [:pointer, :pointer, :size_t], :void
    attach_function :alSourceRewindv, [:size_t, :pointer], :void

end

############################### END OF FILE ###################################