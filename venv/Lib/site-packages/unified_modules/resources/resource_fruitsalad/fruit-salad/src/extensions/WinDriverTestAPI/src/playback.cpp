/*******************************************************************************
 *
 * Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
 *
 * This software as well as any related documentation is furnished under 
 * license and may only be used or copied in accordance with the terms of the 
 * license. The information in this file is furnished for informational use 
 * only, is subject to change without notice, and should not be construed as 
 * a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
 * (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
 * that may appear in this document or any software that may be provided in
 * association with this document. 
 *
 * Except as permitted by such license, no part of this document may be 
 * reproduced, stored in a retrieval system, or transmitted in any form or by 
 * any means without the express written consent of Cirrus Logic International
 * (UK) Ltd or affiliated companies. 
 *
 * @file   playback.cpp
 * @brief  Windows playback from file using Windows Media Player.
 *
 * @version \$Id: playback.cpp 939 2015-03-12 12:59:17Z aangus $
 *
 * @warning
 *     This software is specifically written for Cirrus Logic devices.
 *     It may not be used with other devices.
 *
 ******************************************************************************/

//
// Includes
//
#include "stdafx.h"
#include <sstream>
#include <atlbase.h>
#include <shlobj.h>
#include <shobjidl.h>
#include <shellapi.h>
#include <tlhelp32.h>

///////////////////////////////////////////////////////////////////////////////
//
// Identifiers for each of the playback programs that can be invoked by this
// module.
//
///////////////////////////////////////////////////////////////////////////////
enum PlaybackProgram {
    WINDOWS_MEDIA_PLAYER,
    METRO
};

///////////////////////////////////////////////////////////////////////////////
///
/// Function: GetWMPIdentifier
///
/// @brief Obtain the identifier for the Windows Media Player playback method.
///
/// (no parameters)
///
/// @return The serialized identifier.
///
///////////////////////////////////////////////////////////////////////////////
DLL int GetWMPIdentifier()
{
    return WINDOWS_MEDIA_PLAYER;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: GetMetroIdentifier
///
/// @brief Obtain the identifier for the Metro Media Player playback method.
///
/// (no parameters)
///
/// @return The serialized identifier
///
///////////////////////////////////////////////////////////////////////////////
DLL int GetMetroIdentifier()
{
    return METRO;
}

// Constant, defines the expected location of wmplayer.exe on the target system.
static const wchar_t* PathToWMP = L"C:\\Program Files\\Windows Media Player\\wmplayer.exe";

// Constant, defines the app Id that identifies the Metro Player app.
static const wchar_t* metroMusicAppId = L"Microsoft.ZuneMusic_8wekyb3d8bbwe!Microsoft.ZuneMusic";

///////////////////////////////////////////////////////////////////////////////
///
/// Function: IsHResultFailed
///
/// @brief Check for a failed HRESULT and log an error message if so.
///
/// @param description Description of the operation being performed.
/// @param result      The result to check
///
/// @return True if the HRESULT indicated failure.
///
///////////////////////////////////////////////////////////////////////////////
static bool IsHResultFailed( std::string description, HRESULT result )
{
	bool ret_val = false;

	if( FAILED( result ) )
	{
		std::ostringstream msg; 
		msg << "ERROR: '" << description << "' (0x" << std::hex << result << ")" << std::endl; \
		std::cerr << msg.str(); 
		ret_val = true;
	}

	return ret_val;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: TerminateApp
///
/// @brief Terminate a process identifier by its process ID.
///
/// @param pid The process ID to terminate
///
/// @return True if the process is terminated successfully
///
///////////////////////////////////////////////////////////////////////////////
static bool TerminateApp( int pid )
{
    HANDLE app = OpenProcess( PROCESS_TERMINATE, FALSE, pid );
    if (!app)
    {
        goto failure;
    }

    if ( !TerminateProcess( app, 0 ) )
    {
        CloseHandle( app );
        goto failure;
    }
    WaitForSingleObject( app, INFINITE );
    CloseHandle( app );
    return true;
failure:
    PrintLastError( L"WinDriverTestAPI::TerminateApp" );
    return false;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: KillAllWMP
///
/// @brief Terminate all processes sharing the executable name 'wmplayer.exe'.
///
/// (no parameters)
///
/// @return True if all such processes were terminated successfully.
///
///////////////////////////////////////////////////////////////////////////////
static bool KillAllWMP()
{
    HRESULT success;
    PROCESSENTRY32 entry;
    HANDLE snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );
    entry.dwSize = sizeof( PROCESSENTRY32 );

    if ( INVALID_HANDLE_VALUE == snapshot )
    {
        goto failure;
    }
    
    for ( BOOL exists = Process32First( snapshot, &entry ); 
          exists;
          exists = Process32Next( snapshot, &entry )
        )
    {
        if ( !lstrcmpi( entry.szExeFile, TEXT( "wmplayer.exe" ) ) )
        {
            success = TerminateApp( entry.th32ProcessID );
            if ( FAILED( success ) )
            {
                goto failure;
            }
        }
    }
    CloseHandle( snapshot );
    return true;
failure:
    PrintLastError( L"WinDriverTestAPI::KillAllWMP" );
    return false;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: PlaybackUsingWMP
///
/// @brief Playback a named file using Windows Media Player.
///
/// @param fileName The media file to play
/// @param duration The file's expected duration in milliseconds
///
/// @return True if Windows Media Player is invoked and killed successfully
///
///////////////////////////////////////////////////////////////////////////////
static bool PlaybackUsingWMP( wstring fileName, int duration ) {
    // Convert to full path name.
    wchar_t *fullFilePath = _wfullpath( NULL, fileName.c_str(), fileName.size() );
    // Wrap quotation marks around it (in case the path has spaces)
    std::wstringstream withQuotes;
    withQuotes << L'"' << fullFilePath << L'"';

    int err = (int)ShellExecute( NULL, NULL, 
                                 PathToWMP, withQuotes.str().c_str(), 
                                 NULL, SW_SHOWNORMAL 
                               );
    if ( fullFilePath )
    {
        free( fullFilePath );
    }
    if ( err <= 32 )
    {
        std::cout << "ERROR: ShellExecute() returned 0x" << std::hex << (unsigned int) err << std::endl;
        return false;
    }

    Sleep( duration );
    return KillAllWMP();
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: KillAllMetro
///
/// @brief Terminate any/all instances of Metro Player.
///
/// (no parameters)
///
/// @return True if all such instances were terminated successfully.
///
///////////////////////////////////////////////////////////////////////////////
static bool KillAllMetro()
{
    HRESULT result;

    // Get the activation manager interface.
    CComPtr<IApplicationActivationManager> spActivationManager;
	result = spActivationManager.CoCreateInstance( CLSID_ApplicationActivationManager, nullptr, CLSCTX_LOCAL_SERVER );
	if ( IsHResultFailed( "WinDriverTestAPI::KillAllMetro ( IApplicationActivationManager )", result ) )
	{
		goto error;
	}

    // Re-activate the app so we can get the PID.
    DWORD pid;
	result = spActivationManager->ActivateApplication(metroMusicAppId, nullptr, AO_NONE, &pid );
	if ( IsHResultFailed( "WinDriverTestAPI::KillAllMetro ( Re-activate Application )", result ) )
	{
		goto error;
	}

    // Terminate the app.
	result = TerminateApp( pid );
	if ( IsHResultFailed( "WinDriverTestAPI::KillAllMetro ( TerminateApp )", result ) )
	{
		goto error;
	}

    return true;
error:
	return false;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: PlaybackUsingMetro
///
/// @brief Playback a named file using Metro Player.
///
/// @param fileName The media file to play
/// @param duration The file's expected duration in milliseconds
///
/// @return True if Metro Player is invoked and killed successfully
///
///////////////////////////////////////////////////////////////////////////////
static bool PlaybackUsingMetro( wstring fileName, int duration ) 
{	
    HRESULT result;
	CComPtr<IShellItemArray> fileShellItemArray;
	CComPtr<IApplicationActivationManager> spActivationManager;
    
    // Convert to full path name.
    wchar_t *fullFilePath = _wfullpath( NULL, fileName.c_str(), fileName.size() );
    if ( !fullFilePath )
    {
        goto error;
    }

    // Get the file as a IShellItemArray.
    LPITEMIDLIST fileIdList = ILCreateFromPath( fullFilePath );
    free( fullFilePath );
    if ( !fileIdList )
    {
        std::cout << "ERROR: File does not exist." << std::endl;
        goto error;
    };
   
	result = SHCreateShellItemArrayFromIDLists( 1, (LPCITEMIDLIST*)&fileIdList, &fileShellItemArray );
	if ( IsHResultFailed( "WinDriverTestAPI::PlaybackUsingMetro ( SHCreateShellItemArrayFromIDLists )", result ) )
	{
		goto error;
	}    
    ILFree( fileIdList );

	//
    // Get the activity manager interface and allow the app we are controlling 
    // to be set as foreground. Without being set as foreground, the music app 
    // will not start playing the file we pass it unless it was already running.
	//
    result = spActivationManager.CoCreateInstance( CLSID_ApplicationActivationManager, nullptr, CLSCTX_LOCAL_SERVER );
	if ( IsHResultFailed( "WinDriverTestAPI::PlaybackUsingMetro ( spActivationManager )", result ) )
	{
		goto error;
	}
    CoAllowSetForegroundWindow( spActivationManager, NULL );

    DWORD pid;
	result = spActivationManager->ActivateForFile( metroMusicAppId, fileShellItemArray, nullptr, &pid );
	if ( IsHResultFailed( "WinDriverTestAPI::PlaybackUsingMetro ( ActivateForFile )", result ) )
	{
		goto error;
	}
    
    Sleep( duration );
    return KillAllMetro();
error:
	return false;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: Playback
///
/// @brief Playback a named media file.
///
/// @param program  The identifier of the program to use i.e. Windows Media Player.
/// @param fileName The name of the media file to play.
/// @param duration The expected duration of the file in milliseconds.
///
/// @return bool    True if the playback program launches and closes successfully.
///
///////////////////////////////////////////////////////////////////////////////
DLL bool Playback( PlaybackProgram program, wstring fileName, int duration )
{
    switch ( program ) {
        case WINDOWS_MEDIA_PLAYER:
            return PlaybackUsingWMP( fileName, duration );
        case METRO:
            return PlaybackUsingMetro( fileName, duration );
        default:
            std::cout << "Playback Program not supported.\n";
            return false;
    }
}

//////////////////////////////// END OF FILE //////////////////////////////////