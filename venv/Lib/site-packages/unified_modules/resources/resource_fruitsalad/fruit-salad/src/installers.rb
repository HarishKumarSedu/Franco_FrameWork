# encoding: utf-8
################################################################################
###
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   installers.rb
### @brief  Creating and checking WISCE™ and Device pack installers.
###
### @note This file will contain Windows specific functionality as the
###       installers are built for Windows systems.
###
### @version \$Id: installers.rb 847 2015-02-06 15:55:37Z aangus $
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
###
#################################################################################

###############################################################################
# Includes
###############################################################################
require 'win32/registry'
require 'fileutils'
require 'configuration'

###############################################################################
#
# Module: FruitSalad
#
# Extends the FruitSalad module with classes for checking and performing operations
# with installers for WISCE™, Extensions SDK and device packs (Windows specific).
#
###############################################################################
module FruitSalad
    #######################################################################
    #
    # Class: InstallerRegInfo
    #
    # Collects together the relevant information returned from the registry for
    # an installed program.
    #
    #######################################################################
    class InstallerRegInfo
        attr_reader :version, :uninstall_str, :name, :guid

        #######################################################################
        #
        # Default Constructor.
        #
        #######################################################################
        def initialize( name, version, uninstall_str, guid )
           @name          = name
           @version       = version
           @guid          = guid
           @uninstall_str = uninstall_str
        end

        #######################################################################
        #
        # @function to_s
        #
        # Create a printable string from the object.
        #
        # (no parameters)
        #
        #######################################################################
        def to_s
            name = ''
            @name.each_byte do |byte|
                # Console doesn't support the TM character
                if 0x99 == byte
                    name << '(TM)'
                else
                    name << byte
                end
            end

            return "#{name} (#{@version}) - #{@guid}"
        end
    end

    #######################################################################
    #
    # Singleton Class.
    #
    # Provides methods for invoking installers and checking the registry for installed programs.
    #
    #######################################################################
    class Installer
        include Singleton

        # Registry path to Unistall Keys - local machine
        REG_PATH_TO_UNINSTALL_KEYS = 'Software\Microsoft\Windows\CurrentVersion\Uninstall'

        #
        # installware options (note the space before the /s)
        # REBOOTNOW set to false as we do not want the system restarting during testing.
        #
        INSTALL_AWARE_SILENT_INSTALL_OPTIONS   = ' /s REBOOTNOW=NO'
        INSTALL_AWARE_SILENT_UNINSTALL_OPTIONS = ' /s MODIFY=FALSE REMOVE=TRUE UNINSTALL=YES REBOOTNOW=NO'

        # GUID Constants
        GUID_WISCEExtensionsSDK = '{5EF7A023-A046-4A2D-992C-92F8C5A823E8}'
        GUID_WISCE              = '{B72FD72F-A9A1-4396-8E0A-80F547756469}'

        # Reg key constants
        Version_Reg_Key = 'DisplayVersion'

        @installer_dir_path = '.'

        # Device pack Creation - convert any windows paths (\ -> /)
        @device_pack_make_kit_path = Conf.property( :Device_Pack_Make_Kit_Path, '' ).gsub('\\', '/')
        @device_pack_temp_dir      = Conf.property( :Device_Pack_Temp_Dir, 'device_packs' ).gsub('\\', '/')
        @device_pack_device_store  = Conf.property( :Device_Pack_Device_Store, '' ).gsub('\\', '/')
        # archive of copied installers
        @installer_archive         = Conf.property( :Installer_Archive, '//filer/build/kits' ).gsub('\\', '/')

        #######################################################################
        #
        # @function installer_dir_path
        #
        # Set the directory path of the installer commands.
        #
        # @param [String] dir_path Directory path for the installer commands.
        #
        #######################################################################
        def self.installer_dir_path( dir_path )
            @installer_dir_path = dir_path
        end

        ###############################################################################
        #
        # @function clean_installers_dir
        #
        # Removes all executables from the installers directory.
        #
        #       Usage:
        #       Given clean installers directory
        #
        # (no parameters)
        #
        ###############################################################################
        def self.clean_installers_dir
            entries = Dir.entries( @installer_dir_path )
            entries.select!{|file_name| file_name.match( /[.\w]+.exe/ )}
            entries.each do |exe_file|
                FileUtils.rm( @installer_dir_path + '/' + exe_file )
            end
        end

        #######################################################################
        #
        # @function copy_installer
        #
        # Looks up and copies the requested installer and copies to the installer_dir_path location.
        #
        # Config options specify the searched locations (in order of search priority):
        #    :Installer_Archive - where to pull the latest kits from
        #    :Device_Pack_Temp_Dir - where to pull device kits from
        #
        # @param [String] installer_name Name of the installer to locate and copy.
        #
        # @raise If the requested installer cannot be found.
        #
        #######################################################################
        def self.copy_installer( installer_name )
            installer_archive = @installer_archive
            installer_path_name = installer_archive + '/' + installer_name

            device_pack_name = @device_pack_temp_dir + '/' + installer_name

            if File.exists?( installer_path_name )
                FileUtils.cp( installer_path_name,  @installer_dir_path )
            elsif File.exists?( device_pack_name )
                FileUtils.cp( device_pack_name,  @installer_dir_path )
            else
                raise "Available installers: Unable to find installer #{installer_name}"
            end

            unless File.exists?( @installer_dir_path + '/' + installer_name )
                raise "Available installers: Failed to copy #{installer_name} to install directory."
            end
        end

        #######################################################################
        #
        # @function run_installer_silently
        #
        # Run an installer sliently.
        #
        # @param [String] installer_name Name of the isntaller file to run.
        #
        # @raise If the execution of the installer fails to return successfully.
        #
        #######################################################################
        def self.run_installer_silently( installer_name )
            converted_dir_path = @installer_dir_path.gsub('\\', '/')

            if File.directory?( converted_dir_path )
                converted_dir_path += '/'
            end

            installer = converted_dir_path + installer_name
            if File.exists?( installer )
                install_silent_command = installer + INSTALL_AWARE_SILENT_INSTALL_OPTIONS
                system( install_silent_command )
            else
                raise "No such installer: #{installer}"
            end

            # check the exit status
            if $? != 0
                raise "Installer #{installer_name} execution failed."
            end
        end

        #######################################################################
        #
        # @function installer_filename
        #
        # Create the isntaller name from user friendly terms.
        #
        # @param [String] program_name       Program or device pack name.
        # @param [nil|String] version        Whether to look for a specific version (nil if any version).
        #
        # @return [String] Name of the executable to run.
        #
        #######################################################################
        def self.installer_filename( program_name, version )
            filename = ''
            # WISCE™ and the ExtensionsSDK have specific GUIDs
            case program_name
                when 'WISCEExtensionsSDK'
                    filename = program_name
                    unless version.nil?
                        filename += "_#{version}"
                    end
                when 'WISCE'
                    filename = "#{program_name}Setup"
                    unless version.nil?
                        filename += "_#{version}"
                    end
                else
                    version = version.gsub('.', '_')
                    filename = "#{program_name}Setup_Rev#{version}"
                end

            return filename + '.exe'
        end

        #######################################################################
        #
        # @function run_silent_uninstall
        #
        # Run the uninstaller for a given InstallerRegInfo silently.
        #
        # @param [InstallerRegInfo] reg_info_entry Installed program information returned
        #                                          from the registry.
        #
        #######################################################################
        def self.run_silent_uninstall( reg_info_entry )
            uninstall_silent_command = reg_info_entry.uninstall_str + INSTALL_AWARE_SILENT_UNINSTALL_OPTIONS
            system( uninstall_silent_command )
        end

        #######################################################################
        #
        # @function remove_installer
        #
        # Remove an installer from the current installer directory.
        #
        # @param [String] installer_name Name of the installer file to run.
        #
        #######################################################################
        def self.remove_installer( installer_name )
            path_installer_name = @installer_dir_path + '/' + installer_name

            if File.exists?( path_installer_name )
                FileUtils.rm( path_installer_name )
            end
        end

        #######################################################################
        #
        # @function check_program_is_installed
        #
        # Check whether the requested program is installed.
        #
        # @param [String] program_name       Program or device pack name.
        # @param [Boolean] is_install        Whether the program should be installed or uninstalled.
        #
        # @return [Array] Returns an array of InstallerRegInfo objects matching program_name.
        #
        #######################################################################
        def self.check_program_is_installed( program_name, is_install )
            register_info_array = []

            # WISCE™ and the ExtensionsSDK have specific GUIDs
            case program_name
                when 'WISCEExtensionsSDK'
                    register_info_array = lookup_installed_versions_by_GUID( GUID_WISCEExtensionsSDK )
                when 'WISCE'
                    register_info_array = lookup_installed_versions_by_GUID( GUID_WISCE )
                else
                    register_info_array = lookup_installed_versions_by_name( program_name )
            end

            return register_info_array
        end

        #######################################################################
        #
        # @function check_for_installed_version
        #
        # Check whether there is a program of version in the InstallerRegInfo array.
        #
        # @param [String]      program_name  Program or device pack name.
        # @param [nil|String]  version       Whether to look for a specific version (nil if any version).
        # @param [Boolean]     is_install    Whether the program should be installed or uninstalled.
        # @param [Boolean]     assert        Whether exceptions should be raised if the program was in the incorrect state.
        #
        # @return [Array] Returns an array of InstallerRegInfo objects matching program_name and version.
        #
        # @raise If the requested program is in the incorrect state and assert is true.
        #
        #######################################################################
        def self.check_for_installed_version( program_name, version, is_install, assert )
            was_installed = check_program_is_installed( program_name, is_install )
            display_str = "#{program_name}"
            unless version.nil?
                was_installed.select! { |program| program.version == version }
                display_str += " version (#{version})"
            end

            if assert && is_install && was_installed.empty?
                raise "#{display_str} was not installed."
            end

            if assert && !is_install && !was_installed.empty?
                raise "#{display_str} was installed."
            end

            return was_installed
        end

        ###############################################################################
        # @function lookup_installed_versions_by_GUID
        #
        # Lookup the uninstall keys in the registry for a given GUID.
        #
        # @param [String] guid GUID string (including braces) of the program to lookup.
        #
        # @return [Array] Array of InstallerRegInfo objects with matching uninstall GUID keys.
        #
        ###############################################################################
        def self.lookup_installed_versions_by_GUID( guid )
            matching_keys = []

            Win32::Registry::HKEY_LOCAL_MACHINE.open( REG_PATH_TO_UNINSTALL_KEYS ) do |reg|
                reg.keys.each do |key|
                    if guid == key
                        sub_key_name = REG_PATH_TO_UNINSTALL_KEYS + '\\' + key
                        Win32::Registry::HKEY_LOCAL_MACHINE.open( sub_key_name ) do |sub_key|
                            display_name  = sub_key['DisplayName']
                            uninstall_str = sub_key['UninstallString']
                            version       = sub_key['DisplayVersion']
                            reg_info = InstallerRegInfo.new( display_name, version, uninstall_str, guid )
                            matching_keys.push( reg_info )
                        end
                    end
                end
            end

            return matching_keys
        end

        ###############################################################################
        # @function lookup_installed_versions_by_name
        #
        # Lookup the uninstall keys in the registry for a given name.
        #
        # Used to locate device packs by name as the GUID is not fixed (depends on revision).
        #
        # Exact string being searched for is "<name> WISCE\x99 pack" (where \x99 is the ™ character).
        #
        # @param [String] name Name string of the program to lookup.
        #
        # @return [Array] Array of InstallerRegInfo objects matching the supplied name.
        #
        ###############################################################################
        def self.lookup_installed_versions_by_name( name )
            matching_keys = []
            display_name = "#{name} WISCE\x99 pack"

            Win32::Registry::HKEY_LOCAL_MACHINE.open( REG_PATH_TO_UNINSTALL_KEYS ) do |reg|
                reg.keys.each do |key|
                    # key should be a GUID, otherwise the accessed fields may not be available.
                    match_data = key.match(/{[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}}/)
                    unless match_data.nil?
                        sub_key_name = REG_PATH_TO_UNINSTALL_KEYS + '\\' + key
                        Win32::Registry::HKEY_LOCAL_MACHINE.open( sub_key_name ) do |sub_key|
                            sub_key.each_value do |v|
                                if 'DisplayName' == v
                                    if sub_key['DisplayName'] == display_name
                                        uninstall_str = sub_key['UninstallString']
                                        version       = sub_key['DisplayVersion']
                                        reg_info = InstallerRegInfo.new( display_name, version, uninstall_str, key )
                                        matching_keys.push( reg_info )
                                    end
                                end
                            end
                        end
                    end
                end
            end

            return matching_keys
        end

        ###############################################################################
        #
        # Device pack creation.
        #
        ###############################################################################

        ###############################################################################
        # @function clean_devices_dir
        #
        # Removes any existing files from the Device directory of the temp Device pack dir.
        #
        # Used as a staging area for the make_kit.bat script used to run InstallAware and
        # create the device packs.
        #
        # (no parameters)
        #
        # @raise if the temp device pack directory does not exist
        #
        ###############################################################################
        def self.clean_devices_dir
            device_dir_path = check_create_devices_dir

            contents = Dir.entries( device_dir_path )
            # do not delete the current and parent directory listings
            contents.reject! {|entry| entry.match(/^\.\.?$/) }
            contents.each do |entry|
                FileUtils.rm( device_dir_path + '/' + entry )
            end
        end

        ###############################################################################
        # @function check_create_devices_dir
        #
        # Check for the presence of the Devices dir in the temp device pack area, create if absent.
        #
        # (no parameters)
        #
        # @return [String] path to the Device sub-dir of the temp area.
        #
        # @raise if the temp device pack directory does not exist
        #
        ###############################################################################
        def self.check_create_devices_dir
            unless  File.directory?( @device_pack_temp_dir )
                raise 'invalid device pack temp directory \"#{@device_pack_temp_dir}\", please specify :Device_Pack_Temp_Dir in the config file'
            end

            device_dir = @device_pack_temp_dir + '/Devices'
            unless File.directory?( device_dir )
                FileUtils.mkdir( device_dir )
            end

            return device_dir
        end

        ###############################################################################
        # @function copy_device_to_pack_dir
        #
        # Copies the specified device from a source folder into the Devices directory.
        #
        # The Devices directory is packaged into the Device Pack by the make_kit.bat script.
        #
        # @param [String] device_filename Name of the device to be copied to the packaging area.
        # @param [String] device_rev      Revision of the device to be copied to the packaging area.
        #
        # @raise if the temp device pack directory does not exist
        # @raise device file does not exist
        #
        ###############################################################################
        def self.copy_device_to_pack_dir( device_filename, device_rev )
            device_dir_path = check_create_devices_dir
            device_filename = "#{device_filename}_RegMap_#{device_rev}.wxd"
            source_filename = @device_pack_device_store + '/' + device_filename
            unless File.exists?( source_filename )
                raise "Target device file #{source_filename} does not exist."
            end

            FileUtils.cp(source_filename, device_dir_path )
        end

        ###############################################################################
        # @function create_installer
        #
        # Run the make_kit script to produce the Device Pack installer.
        #
        # @param [String]     pack_name    Name of the installer to be created (Device pack if a valid device ID).
        # @param [String]     version      Version to be assigned to the created installer.
        # @param [nil|String] replace_name Optional device name to create a replacement installer, otherwise nil.
        #
        # @raise there is no valid path to the make_kit script
        #
        ###############################################################################
        def self.create_installer( pack_name, version, replace_name )
            base_name = "#{pack_name}Setup_Rev#{version.gsub( /\./, '_' )}"
            @installer_name = "#{base_name}.exe"

            unless File.exists?( @device_pack_make_kit_path )
                raise "Invalid path to Device Pack make_kit script: #{@device_pack_make_kit_path}"
            end

            windows_path_to_make_kit = @device_pack_make_kit_path.gsub( '/', '\\' )

            replace = ''
            unless replace_name.nil?
                replace = "REPLACE=#{replace_name}"
            end

            # Run the make_kit.bat script while working in the device pack directory
            working_directory = FileUtils.getwd
            FileUtils.chdir( @device_pack_temp_dir )
            # 2>&1 appended to capture stderr as well as stdout
            create_installer_command = "cmd /C #{windows_path_to_make_kit} #{pack_name} VERSION=#{version} #{replace} 2>&1"
            log_path = "#{base_name}.log"
            IO.popen( create_installer_command ) do |output_io|
                File.open( log_path, 'w') do |log_file|
                    output_io.readlines.each {|line| log_file << line}
                end
            end

            FileUtils.chdir( working_directory )
        end

        ###############################################################################
        # @function check_installer_created
        #
        # Check that the expected installer has been created.
        #
        # @param [nil|String] negate If nil check for existance, otherwise check for absence.
        #
        # @raise if the device pack installer does not exist when it should
        # @raise if the device pack installer exists when it should not
        #
        ###############################################################################
        def self.check_installer_created?( negate )
            installer_path = @device_pack_temp_dir + '/' + @installer_name

            exists = File.exists?( installer_path )

            if ( exists && !negate.nil? )
                raise "Device pack installer #{installer_path}.exe exists."
            end

            if ( !exists && negate.nil? )
                raise "Device pack installer #{installer_path}.exe does not exist."
            end
        end

    end # end of Installer class

end # end of FruitSalad module
###############################END OF FILE#############################################