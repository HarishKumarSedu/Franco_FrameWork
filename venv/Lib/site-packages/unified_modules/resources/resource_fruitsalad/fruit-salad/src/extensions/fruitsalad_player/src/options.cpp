///////////////////////////////////////////////////////////////////////////////
///
///Copyright (c) 2014 Wolfson Microelectronics plc.  All rights reserved.
///
/// This software as well as any related documentation is furnished under 
/// license and may only be used or copied in accordance with the terms of the 
/// license. The information in this file is furnished for informational use 
/// only, is subject to change without notice, and should not be construed as 
/// a commitment by Wolfson Microelectronics plc. Wolfson Microelectronics plc
/// assumes no responsibility or liability for any errors or inaccuracies that
/// may appear in this document or any software that may be provided in
/// association with this document. 
///
/// Except as permitted by such license, no part of this document may be 
/// reproduced, stored in a retrieval system, or transmitted in any form or by 
/// any means without the express written consent of Wolfson Microelectronics plc. 
///
/// @file   options.cpp
/// @brief  A command line option parser.
///
/// @version \$Id: options.cpp 518 2014-11-27 09:08:51Z piotrs $
///
/// Warning
///   This software is specifically written for Wolfson devices. It may not be
///   used with other devices.
///
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Includes
///////////////////////////////////////////////////////////////////////////////

#include <iostream>

#include "options.h"

///////////////////////////////////////////////////////////////////////////////
/// Function definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: Option
///
/// @brief Constructs an Option object.
///
///////////////////////////////////////////////////////////////////////////////
Option::Option()
{
    m_isSet = false;
    m_isSetDefault = false;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: IsSet
///
/// @brief Checks if the option is set.
///
/// @retval true  if the option is set
/// @retval false otherwise
///
///////////////////////////////////////////////////////////////////////////////
bool Option::IsSet()
{
    return m_isSet || m_isSetDefault;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: IsSetExplicitly
///
/// @brief Checks if the option was explicilty set by the user.
///
/// @retval true  if the option was set
/// @retval false otherwise
///
///////////////////////////////////////////////////////////////////////////////
bool Option::IsSetExplicitly()
{
    return m_isSet;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: SetDefault
///
/// @brief Flags the option as set to a default value.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void Option::SetDefault()
{
    m_isSetDefault = true;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: SetExplicitly
///
/// @brief Flags the option as set explicilty by the user.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void Option::SetExplicitly()
{
    m_isSet = true;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: Command
///
/// @brief Constructs a command object.
///
///////////////////////////////////////////////////////////////////////////////
Command::Command( const std::string &name )
{
    m_name = name;
    m_invoked = false;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: Get
///
/// @brief Gets the command as a string.
///
/// @return The command as a string.
///
///////////////////////////////////////////////////////////////////////////////
std::string Command::Get() const
{
    return m_name;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: IsInvoked
///
/// @brief Check if the command has been invoked.
///
/// @retval true  if the command has been invoked
/// @retval false otherwise
///
///////////////////////////////////////////////////////////////////////////////
bool Command::IsInvoked()
{
    return m_invoked;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: IsInvoked
///
/// @brief Check if the command has been invoked.
///
/// @param command A shared pointer to a Command object.
///
/// @retval true  if the command has been invoked
/// @retval false otherwise
///
///////////////////////////////////////////////////////////////////////////////
bool IsCommandInvoked( const std::shared_ptr<Command> &command )
{
    return command->IsInvoked();
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: SetInvoked
///
/// @brief Flags the command as invoked.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void Command::SetInvoked()
{
    m_invoked = true;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: AssociateOption
///
/// @brief Associates an option with the command.
///
/// @param option Shared pointer to an option.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void Command::AssociateOption( const std::shared_ptr<Option> &option )
{
    m_associatedOptions.push_back( option );
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ValidateOptions
///
/// @brief Checks if all options associated with the command were set.
///
/// @retval true  if all associated options are set
/// @retval false otherwise
///
///////////////////////////////////////////////////////////////////////////////
bool Command::ValidateOptions()
{
    bool valid = true;

    for( auto option : m_associatedOptions )
        valid = valid && option->IsSet();

    return valid;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: OptionDescriptor
///
/// @brief Constructs an option descriptor.
///
/// @param shortName    A short argument name.
/// @param longName     A long argument name.
/// @param description  A description of the option.
/// @param valueCount   Number of values the option can take
///                     (@see OptionValueCount).
/// @param valueType    Type of the option value (@see OptionValueType).
/// @param defaultValue A default value for the option.
/// @param option       A shared pointer to an Option instance.
///
///////////////////////////////////////////////////////////////////////////////
OptionDescriptor::OptionDescriptor( const std::string       &shorName,
                                    const std::string       &longName,
                                    const std::string       &description,
                                    OptionValueCount        valueCount,
                                    OptionValueType         valueType,
                                    const std::string       &defaultValue,
                                    std::shared_ptr<Option> option
                                  )
{
    m_shortName = shorName;
    m_longName = longName;
    m_description = description;
    m_valueCount = valueCount;
    m_valueType = valueType;
    m_defaultValue = defaultValue;
    m_option = option;

    if( "" != defaultValue )
    {
        if( INTEGER_OPTION == valueType )
            std::static_pointer_cast<ValuedOption<int>>( option )->SetValue( std::stoi( defaultValue ) );
        else if ( DOUBLE_OPTION == valueType )
            std::static_pointer_cast<ValuedOption<double>>( option )->SetValue( std::stoi( defaultValue ) );
        else if ( STRING_OPTION == valueType )
            std::static_pointer_cast<ValuedOption<std::string>>( option )->SetValue( defaultValue );
    }
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: GetValueCount
///
/// @brief Checks how many values can the option take.
///
/// @retval NO_VALUE     indicates the option can not take a value.
/// @retval SINGLE_VALUE indicates the option can take a single value.
///
///////////////////////////////////////////////////////////////////////////////
OptionValueCount OptionDescriptor::GetValueCount()
{
    return m_valueCount;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: GetValueType
///
/// @brief Checks what type of value can the option take.
///
/// @retval STRING_OPTION  indicates the option has a string value.
/// @retval INTEGER_OPTION indicates the option has an integer value.
/// @retval DOUBLE_OPTION  indicates the option has a double value.
///
///////////////////////////////////////////////////////////////////////////////
OptionValueType OptionDescriptor::GetValueType()
{
    return m_valueType;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: GetShortName
///
/// @brief Gets the short name of the option.
///
/// @return Short option name.
///
///////////////////////////////////////////////////////////////////////////////
std::string OptionDescriptor::GetShortName() const
{
    return m_shortName;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: GetLongName
///
/// @brief Gets the long name of the option.
///
/// @return Long option name.
///
///////////////////////////////////////////////////////////////////////////////
std::string OptionDescriptor::GetLongName() const
{
    return m_longName;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: GetDescription
///
/// @brief Gets the option's description.
///
/// @return Option description.
///
///////////////////////////////////////////////////////////////////////////////
std::string OptionDescriptor::GetDescription()
{
    return m_description;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: GetOption
///
/// @brief Gets the Option object associated with the descriptor.
///
/// @return Shared pointer to an Option object.
///
///////////////////////////////////////////////////////////////////////////////
std::shared_ptr<Option> OptionDescriptor::GetOption()
{
    return m_option;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: SetProgramName
///
/// @brief Sets parsed program name.
///
/// @param programName Program name to set.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void Options::SetProgramName( const std::string &programName )
{
    m_programName = programName;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: Parse
///
/// @brief Parses command line options.
///
/// @note It is assumed that argv and argc have not been processed in any way.
///
/// @param argc Argument count.
/// @param argv Argument values.
///
/// @retval PARSING_SUCCESS if the arguments were parsed successfuly,
/// @retval PARSING_ERROR   otherwise.
///
///////////////////////////////////////////////////////////////////////////////
ParserExitStatus Options::Parse( int argc, char **argv )
{
    ParserExitStatus exitStatus = PARSING_ERROR;
    std::queue<std::string> args;    

    SetProgramName( std::string( argv[0] ) );

    // remove program name from arguments
    argc -= (argc > 0);
    argv += (argc > 0);

    if ( argc > 0 )
    {
        for ( int i = 0; i < argc; ++i )
            args.push( argv[i] );

        if ( m_definedCommands.size() > 0 )
            exitStatus = ParseCommand( args );

        exitStatus = ParseOptions( args );

        if ( PARSING_SUCCESS == exitStatus )
            exitStatus = ValidateParse();
    }

    return exitStatus;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ParseCommand
///
/// @brief Parses the command.
///
/// @note It is assumed that args does not contain the program name and
///       command is the first argument or is not present.
///
/// @param args Arguments.
///
/// @retval PARSING_SUCCESS if the command was parsed successfuly,
/// @retval PARSING_ERROR   otherwise.
///
///////////////////////////////////////////////////////////////////////////////
ParserExitStatus Options::ParseCommand( std::queue<std::string> &args )
{
    ParserExitStatus exitStatus = PARSING_ERROR;
    std::string command = args.front();
    
    auto pos = std::find<commandContainer::iterator>( m_definedCommands.begin(),
                                                      m_definedCommands.end(),
                                                      command
                                                    );
    
    if ( m_definedCommands.end() != pos )
    {
        (*pos)->SetInvoked();
        exitStatus = PARSING_SUCCESS;
        args.pop();
    }

    return exitStatus;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ParseOptions
///
/// @brief Parses options.
///
/// @param opts A queue of options.
///
/// @retval PARSING_SUCCESS if the options were parsed successfuly,
/// @retval PARSING_ERROR   otherwise.
///
///////////////////////////////////////////////////////////////////////////////
ParserExitStatus Options::ParseOptions( std::queue<std::string> &opts )
{
    ParserExitStatus exitStatus = PARSING_SUCCESS;
    std::string option;

    while ( !opts.empty() && PARSING_SUCCESS == exitStatus )
    {
        exitStatus = ParseOption( opts );
    }

    return exitStatus;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ParseOption
///
/// @brief Parses a single option.
///
/// @param opts A queue of options.
///
/// @retval PARSING_SUCCESS if the option was parsed successfuly,
/// @retval PARSING_ERROR   otherwise.
///
///////////////////////////////////////////////////////////////////////////////
ParserExitStatus Options::ParseOption( std::queue<std::string> &opts )
{
    ParserExitStatus exitStatus = PARSING_ERROR;
    std::string option = opts.front(), value;
    ArgTokenType optionType = ParseOptionTypeAndRemovePrefix( option );
    
    if ( NOT_PREFIXED != optionType )
    {
        auto pos = std::find<optionDescriptorContainer::iterator>( m_definedOptions.begin(),
                                                                   m_definedOptions.end(),
                                                                   option
                                                                 );
        if ( m_definedOptions.end() != pos && !(*pos).GetOption()->IsSetExplicitly() )
        {
            opts.pop();
            switch ( (*pos).GetValueCount() )
            {
            case NO_VALUE:
                (*pos).GetOption()->SetExplicitly();
                exitStatus = PARSING_SUCCESS;
                break;
            case SINGLE_VALUE:
                if ( !opts.empty() )
                {
                    value = opts.front();
                    exitStatus = ParseAndSetValue( (*pos), value );
                    if ( PARSING_SUCCESS == exitStatus )
                        opts.pop();
                }
                break;
            }
        }
    }

    return exitStatus;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ParseTokenType
///
/// @brief Determines the type of a token.
///
/// @param token A token.
///
/// @retval NOT_PREFIXED         indicates the token is not an option.
/// @retval LONG_OPTION          indicates the token is a long option.
/// @retval SHORT_OPTION         indicates the token is a short option.
/// @retval WINDOWS_STYLE_OPTION indicates the token is a windows style option.
///
///////////////////////////////////////////////////////////////////////////////
ArgTokenType Options::ParseTokenType( const std::string &token )
{
    ArgTokenType optionType = NOT_PREFIXED;

    if ( 0 == token.compare( 0, 2, LONG_OPTION_PREFIX ) )
        optionType = LONG_OPTION;
    else if ( 0 == token.compare( 0, 1, SHORT_OPTION_PREFIX ) )
        optionType = SHORT_OPTION;
    else if ( 0 == token.compare( 0, 1, WINDOWS_STYLE_OPTION_PREFIX ) )
        optionType = WINDOWS_STYLE_OPTION;

    return optionType;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ParseOptionTypeAndRemovePrefix
///
/// @brief Determines the type of the supplied option.
///
/// @note If the supplied token is an option the prefix will be removed.
///
/// @param optionToken An option token.
///
/// @retval NOT_PREFIXED indicates the token is not an option.
/// @retval LONG_OPTION  indicates the token is a long option.
/// @retval SHORT_OPTION indicates the token is a short option.
///
///////////////////////////////////////////////////////////////////////////////
ArgTokenType Options::ParseOptionTypeAndRemovePrefix( std::string &optionToken )
{
    ArgTokenType optionType = ParseTokenType( optionToken );

    switch ( optionType )
    {
    case LONG_OPTION:
        optionToken.replace( 0, 2, "" );
        break;
    case SHORT_OPTION:
    case WINDOWS_STYLE_OPTION:
        optionToken.replace( 0, 1, "" );
        if( optionToken.size() > 1 )
            optionType = LONG_OPTION;
        else
            optionType = SHORT_OPTION;
        break;    
    }

    return optionType;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ParseAndSetValue
///
/// @brief Parses a value token.
///
/// @note If the supplied token is a valid value it will be set in the supplied
///       OptionDescriptor.
///
/// @param descriptor An option descriptor.
/// @param valueToken A value token.
///
/// @retval PARSING_SUCCESS if the value was parsed successfuly,
/// @retval PARSING_ERROR   otherwise.
///
///////////////////////////////////////////////////////////////////////////////
ParserExitStatus Options::ParseAndSetValue( OptionDescriptor &descriptor, std::string &valueToken )
{
    ParserExitStatus exitStatus = PARSING_ERROR;
    ArgTokenType tokenType = ParseTokenType( valueToken );

    if ( NOT_PREFIXED == tokenType )
    {
        try
        {
            switch ( descriptor.GetValueType() )
            {
            case INTEGER_OPTION:
                std::static_pointer_cast<ValuedOption<int>>( descriptor.GetOption() )->SetValue( std::stoi( valueToken ) );
                break;
            case DOUBLE_OPTION:
                std::static_pointer_cast<ValuedOption<double>>( descriptor.GetOption() )->SetValue( std::stod( valueToken ) );
                break;
            case STRING_OPTION:
                std::static_pointer_cast<ValuedOption<std::string>>( descriptor.GetOption() )->SetValue( valueToken );
                break;
            }
            exitStatus = PARSING_SUCCESS;
        }
        catch(std::exception e)
        {
            exitStatus = PARSING_ERROR;
        }
    }
    
    return exitStatus;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: ValidateParse
///
/// @brief Validates the parsed data.
///
/// @retval PARSING_SUCCESS if the parsed data is valid
/// @retval PARSING_ERROR   otherwise
///
///////////////////////////////////////////////////////////////////////////////
ParserExitStatus Options::ValidateParse()
{
    ParserExitStatus exitStatus = PARSING_ERROR;

    auto pos = std::find_if<commandContainer::iterator>( m_definedCommands.begin(),
                                                         m_definedCommands.end(),
                                                         IsCommandInvoked
                                                       );

    if ( m_definedCommands.end() != pos && (*pos)->ValidateOptions() )
        exitStatus = PARSING_SUCCESS;

    return exitStatus;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: AddCommand
///
/// @brief Adds a command to the parser.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
std::shared_ptr<Command> Options::AddCommand( const std::string &name )
{
    std::shared_ptr<Command> command( new Command( name ) );
    m_definedCommands.push_back( command );
    return command;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: PrintUsage
///
/// @brief Prints a command line help message.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void Options::PrintUsage()
{
    std::string usage =
        "fruitsalad_player {[--help] or <command> [<args>]}\n"
        "WHERE:\n"
        "  --help - Displays usage information.\n\n"
        "  <command> must be one of the following:\n"
        "    set_up - Configures the player.\n"
        "      requires the following <args>:\n"
        "        -p - a valid number of playback channels\n"
        "        -r - a valid number of recording channels\n"
        "        -s - a sample rate in Hz\n"
        "        -b - buffer size to be used for playback and\n"
        "                       recording\n\n"
        "    terminate - Terminates the player.\n\n"
        "    play - Starts playback.\n"
        "      requires the following <args>:\n"
        "        -f - name of file to play.\n\n"
        "    record - Starts recording.\n"
        "      requires the following <args>:\n"
        "        -f - name of file to record.\n\n"
        "    stop_playback - Stops playback.\n\n"
        "    stop_recording - Stops recording.\n";
    std::cout << usage;
}
/////////////////////////////END OF FILE///////////////////////////////////////