# encoding: utf-8
###############################################################################
###
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   fruitsalad_remote_base.rb
### @brief  Base for remote targets using SSH to connect to the remote device.
###
### @version \$Id: fruitsalad_remote_base.rb 972 2015-03-26 12:48:28Z aangus $
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

###############################################################################
# Includes
###############################################################################

require 'fruitsalad_base'
require 'wavefile_analyzer'
require 'tone_generator'
require 'fruitsalad_utils'
require 'device_factory'
require 'logfw'
require 'net/ssh'
require 'net/scp'

require 'io/console'
require 'result'

module FruitSaladRemoteBase
    include WavefileAnalyzer
    include ToneGenerator
    include FruitSaladDeviceFactory

    class RemoteDeviceInterface < FruitSaladBase::DeviceInterface
        # The sample rate to request for both playback and record.
        SampleRate = Conf.property( :SampleRate, nil )
        # The IP address or hostname of the target Android device.
        IPAddress = Conf.property( :Remote_Address, '127.0.0.1' )
        # The user to log into the target machine as.
        User = Conf.property( :Remote_User, nil )
        # The user's password.
        Password = Conf.property( :Remote_Password, nil )
        # The location of your RSA private key on your host machine.
        KeyFile = Conf.property( :Remote_KeyFile, nil )
        # The directory on the host machine where files are downloaded to
        FruitSaladTempDirectory = './tmp/'
        # Renaming file
        SCCEnrollmentName = Conf.property( :SCCEnrollmentName , 'moon-dsp6-ctrl.bin' )

        # Boolean indicates whether to return error code or not.
        ReturnErrorCodes = Conf.property( :ReturnErrorCodes, false )


        #######################################################################
        #
        # Connects to the remote device via ssh and stores the connection
        # in @session.
        #
        #######################################################################
        def connect()
            # A history of all files played back with this device.
            @playback_history = Array.new
            # The list of default use cases.
            @default_usecases = []

            if nil == Password and nil == KeyFile
                $LOG.info "Please type password (or leave blank for user's rsa key): "
                $LOG.info "... "
                @password = STDIN.noecho(&:gets).chomp
                $LOG.info "\n"
            else
                @password = Password
            end

            $LOG.debug "Connecting to #{IPAddress} as #{User}."
            unless nil == KeyFile
                @key = ""
                File.open( KeyFile ).each_line do |file|
                    @key << file
                end
            end

            begin
                @session = Net::SSH.start( IPAddress,
                                               User,
                                               :password => @password,
                                               :key_data => @key
                                             )
            rescue Exception => e
                if ReturnErrorCodes
                    if e.class.to_s == 'Errno::ECONNRESET'
                        return NetworkError.new(:HOST_CONNECTION_CLOSED,
                                                    e.message,
                                                    e.backtrace)
                    elsif e.class.to_s == 'Net::SSH::ConnectionTimeout'
                        return NetworkError.new(:SSH_TIME_OUT_ERROR,
                                                    e.message,
                                                    e.backtrace)
                    else
                        return NetworkError.new(:UNKWN_SSH_ERROR,
                                                   e.message,
                                                   e.backtrace)
                    end
                else
                    raise e
                end
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #######################################################################
        #
        # Cleans up the SSH connection.
        #
        #######################################################################
        def cleanup()
            @session.close
        end

        #######################################################################
        #
        # Unlike other targets, the Remote target involves a lot of downloads
        # and uploads. Bypass the normal timer behavior by using a custom timer
        # that only tracks time spent playing back.
        #
        #######################################################################
        def per_device_setup
            @timer = 0
            return
        end

        #######################################################################
        #
        # Get the time taken performing only Playback actions.
        #
        #######################################################################
        def time_taken
            return @timer
        end

        #######################################################################
        #
        # Begins recording and stores a filename as the instance
        # variable @output.
        #
        # @param [String] temp_dir  Remote temporary directory.
        # @param [Proc] record_proc A procedure responsible for invoking
        #                           recording on the remote device.
        # @param [String] filename  An optional parameter to record the data
        #                           with the given file name.
        #
        #######################################################################
        def setup_remote_record_output( temp_dir,
                                        record_proc,
                                        filename = 'FruitSaladOutputRecording.wav'
                                      )
            @remote_output = filename

            exec! "rm -f #{temp_dir}#{@remote_output}"

            $LOG.info "Capture ready."
            @defer_recording = Proc.new {
                $LOG.info "Beginning recording."
                record_proc.call( @remote_output )
            }
        end

        #######################################################################
        #
        # Plays a named file on the remote device.
        #
        # This script will SCP the named file onto the remote device,
        # and then play it.
        #
        # @param [String] file     is the path to the file to play.
        # @param [String] temp_dir Remote temporary directory.
        # @param [Proc] play_proc  A procedure responsible for invoking
        #                          playback on the remote device.
        # @param [Hash]   opts Optional upload argument. By default it is true
        #                 which means the file needs to be uploaded,if it is
        #                 false then uploading of file is not required.
        #
        #######################################################################
        def start_remote_playback( file, temp_dir, play_proc, opts = {})

            upload = opts.fetch(:upload, true)
            @playback_history << file
            if upload == true
                upload( file, temp_dir )
            end
            file = File.basename( file )
            unless nil == @defer_recording
                @defer_recording.call
            end

            @start_time = Time.new.to_f
            timed_cmd "Beginning playback." do
                ret_val = play_proc.call( file )
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
            end
            return
        end

        #######################################################################
        #
        # It gives the total playback time
        #
        # @return [Float] The total playback time
        #
        #######################################################################
        def playtime
            end_time = plaback_end_time
            end_time - @start_time
        end

        #######################################################################
        #
        # Ends any ongoing sound recording.
        #
        # Automatically downloads the captured recording onto the host
        # machine.
        #
        # @param [String] temp_dir       Remote temporary directory.
        # @param [Proc] end_capture_proc A procedure responsible for ending
        #                                recording on the remote device.
        #
        #######################################################################
        def end_remote_capture( temp_dir, end_capture_proc )
            unless nil == @remote_output
                end_capture_proc.call

                @output = download( @remote_output, temp_dir )
            end
        end

        #######################################################################
        #
        # init_saladmix Initializes saladmix binary with the given file.
        #
        # @param [String] local_file  Name of the file to upload.
        # @param [String] temp_dir    Remote temporary directory.
        #
        #######################################################################
        def init_saladmix( local_file, temp_dir )
            basename = File.basename( local_file )
            @saladmix_binary = "#{temp_dir}#{basename}"
        end

        #######################################################################
        #
        # Uploads a file to the remote target.
        #
        # @param [String] local_file  Name of the file to upload.
        # @param [String] temp_dir    Remote temporary directory.
        # @param [String] source_path Source location of the file to upload.
        # @param [Boolean] executable Flag to indicate whether the given file
        #                             is a executable one or not.
        # @param [Hash]   opts supports: [Boolean] is_enrollment - Whether
        #                              the given files are enrollment files
        #                              or not.
        #                              [String] destination_file -To change
        #                              the name of given file
        #
        # @raise [RuntimeError] An exception is raised read write permission
        #                       not given.
        # @raise [RuntimeError] An exception is raised renaming of the
        #                       enrollment failed
        #
        #######################################################################
        def upload( local_file, temp_dir, source_path = nil, executable = false, opts={} )
            is_enrollment = opts.fetch( :is_enrollment, false )
            destination_file = opts.fetch( :destination_file, nil )

            unless source_path.nil?
                local_file = "#{source_path}#{local_file}"
            end
            $LOG.debug "Uploading file #{local_file} to #{temp_dir}."
            $LOG.time ""
            unless File.exists?( local_file )
                $LOG.error "File not found : #{local_file}"
                raise "File not found"
            end
            Net::SCP.upload!(
                IPAddress, User, local_file , temp_dir,
                :ssh => { :password => @password, :key_data => @key }
            ) do |ch, name, sent, total|
                $LOG.print "."
            end
            if destination_file != nil
                basename = File.basename( local_file )
                exec! "mv -f #{temp_dir}#{basename} #{temp_dir}#{destination_file}"
                local_file = "#{source_path}#{destination_file}"
            end
            $LOG.print "\n"
            if executable == true
                basename = File.basename( local_file )
                executable_file = "#{temp_dir}#{basename}"
                ret_val = exec! "chmod +x #{executable_file}"
                exit_code = ret_val.data
                unless 0 == exit_code
                    raise 'RemoteSalad: Failed to make executable.'
                end
             elsif is_enrollment == true
                basename = File.basename( local_file )
                executable_file = "#{temp_dir}#{basename}"
                remove( SCCEnrollmentName, temp_dir )
                ret_val = exec! "mv -f #{executable_file} #{temp_dir}#{SCCEnrollmentName}"
                exit_code = ret_val.data
                status_permissions = exec! "chmod +x #{temp_dir}#{SCCEnrollmentName}"
                unless 0 == exit_code
                    raise 'RemoteSalad: Failed to rename and give permission' \
                          'to the given binary file .'
                end
            end
        end

        #######################################################################
        #
        # Downloads a file from the remote target.
        #
        # @param [String] remote_file Name of the file to download
        # @param [String] temp_dir    Remote temporary directory.
        #
        # @return [String] A path to the downloaded file.
        #
        #######################################################################
        def download( remote_file, temp_dir, download_path = nil )
            if download_path.nil?
                download_path = FruitSaladTempDirectory
            end
            if !File.directory? download_path
                Dir.mkdir download_path
            end
            $LOG.debug "Downloading file #{temp_dir}#{remote_file}."
            $LOG.time ""
            Net::SCP.download!(
                IPAddress, User,
                "#{temp_dir}#{remote_file}", download_path,
                :ssh => { :password => @password, :key_data => @key }
            ) do |ch, name, sent, total|
                $LOG.print "."
            end
            $LOG.print "\n"
            "#{download_path}#{remote_file}"
        end

        #######################################################################
        #
        # Removes a file from the remote target.
        #
        # @param [String] remote_file   Name of the remote file to remove
        # @param [String] remote_dir      Remote temporary directory.
        #
        #######################################################################
        def remove( remote_file, remote_dir )
            ret_val = exec! "rm -f #{remote_dir}#{remote_file}"
            exit_code = ret_val.data
            if exit_code == 0
                $LOG.debug "Removing a file #{remote_file} is successful"
            else
                $LOG.debug "Removing a file #{remote_file} is not successful"
            end
        end

        #######################################################################
        #
        # @function exec!
        #
        # Executes a command on the target and waits for it to finish.
        #
        # @param [String]  command A command to execute.
        # @param [Boolean] verbose A flag indicating whether debug output
        #                          should be printed to STDOUT.
        # @yield                   A code block can be supplied to this method
        #                          in order to do further data processing it
        #                          is parametrised with: exit code, data
        #                          collected from standard output and data
        #                          collected from standard error.
        #
        # @return [Int] Exit code of the executed command.
        #
        # @raise [RuntimeError] An exception is raised if the supplied command
        #                       fails to start executing.
        #
        #######################################################################
        def exec!( command, verbose = false )
            stdout = ''
            stderr = ''
            exit_status = nil

            if @session.nil?
                error_message = "@session: SSH object is not initialized"
                return InternalError.new(:OBJECT_NOT_INITIALIZED,
                                           error_message,
                                           Thread.current.backtrace)
            end

            channel = @session.open_channel do |ch|
                $LOG.debug "RemoteDeviceInterface: executing command - #{command}" if verbose
                ch.exec( command ) do |c, success|
                    raise "RemoteDeviceInterface: execution of command (#{command}) failed." unless success

                    c.on_data do |_, data|
                        stdout << data
                        $LOG.debug data if verbose
                    end

                    c.on_extended_data do |_, type, data|
                        if 1 == type
                            stderr << data
                            $LOG.debug data if verbose
                        end
                    end

                    c.on_request( 'exit-status' ) do |_, data|
                        exit_status = data.read_long
                    end
                end
            end

            begin
                channel.wait
            rescue Errno::ECONNRESET => e
                if ReturnErrorCodes
                    if e.class.to_s == 'Errno::ECONNRESET'
                        return NetworkError.new(:HOST_CONNECTION_CLOSED,
                                                   e.message,
                                                   e.backtrace)
                    else
                        return NetworkError.new(:UNKWN_SSH_ERROR, e.message, e.backtrace)
                    end
                else
                    raise e
                end
            end

            yield exit_status, stdout, stderr if block_given?

            if ReturnErrorCodes
                return ResultSuccess.new(exit_status)
            else
                return exit_status
            end
        end

    end
end
##############################END OF FILE######################################