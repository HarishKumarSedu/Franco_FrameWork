###############################################################################
###
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   KMeans.rb
### @brief  Implementation of K-Means classification algorithm as Ruby class
###
### @version \$Id: KMeans.rb 1067 2015-06-15 10:25:31Z aangus $
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

###############################################################################
#
# Implementation of K-Means classification algorithm. We can use this to verify
# our frequency-domain representation by using the expected values as an initial
# seed for the clusters. If the cluster centroids diverge from the initial values
# we know those clusters do not match the frequencies measured.
#
###############################################################################
class KMeans

    #
    # The cluster centroid positions.
    #
    attr_reader :centroids

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor. Initialises the values of @data_points and @centroids
    # to empty arrays.
    #
    # (no parameters)
    #
    ###########################################################################
    def initialize
        @data_points = []
        @centroids = []
        @dimensionality = nil
    end

    ###########################################################################
    #
    # @function add_data_points
    #
    # Adds a list of data points. These points will be classified using the seed
    # centroids and used to recalculate new centroids from the mean position of
    # all points in that set.
    #
    # @note The element arrays of data_points should have the same dimensionality
    # and have the same dimensionality as any centroids added to the model.
    #
    # @param [Array<Array<Numeric>>] data_points    The measured data
    #
    # @raise [RuntimeError] If the dimensionality of the datapoints is incorrect.
    #
    ###########################################################################
    def add_data_points( *data_points )
        if @dimensionality.nil?
            @dimensionality = data_points[0].length
        end
        data_points.each do |point|
            if point.length != @dimensionality
                raise "Data point dimensionality #{point} does not match dimensionality of #{@dimensionality}"
            end
            @data_points << point
        end
    end

    ###########################################################################
    #
    # @function add_centroid
    #
    # Add a seed centroid to the model.
    #
    # @note Each centroid should have the same dimensionality and have the same
    # dimensionality as any datapoints added to the model.
    #
    # @param [Array<Numeric>] coordinates   The coordinates of the new centroid
    #
    # @raise [RuntimeError] If the dimensionality of the centroid is incorrect.
    #
    ###########################################################################
    def add_centroid( *coordinates )
        if @dimensionality.nil?
            @dimensionality = coordinates.length
        end
        if coordinates.length != @dimensionality
            raise "Centroid dimensionality #{coordinates} does not match dimensionality of #{@dimensionality}"
        end
        @centroids << coordinates
    end

    ###########################################################################
    #
    # @function iterate
    #
    # Run the K-Means algorithm. This algorithm operated by classifying each
    # datapoint as belonging to the set of points closest to each centroid.
    # Then use each of those sets to calculate new positions for each centroid
    # from the mean position of that set.
    #
    # With each iteration the algorithm will converge on a local minima for the
    # optimal clustering of the provided data points with caveat that the number
    # of seed centroids must match the number of clusters within the source.
    #
    # For our purpose we are more interested in whether the algorithm diverges
    # from a proposed solution, making that caveat irrelevant and making it
    # unlikely that we will need more than a couple of iterations.
    #
    # @param [Fixnum] n     The number of iterations to carry out. Defaults to 1
    #
    ###########################################################################
    def iterate( n=1 )
        (1..n).each do |_|
            centroid_assignments = Hash.new { |hash,key| hash[key] = [] }
            @data_points.each do |point|
                closest_centroid_label = nil
                closest_centroid_distance = nil
                @centroids.each_with_index do |centroid, label|
                    delta = 0
                    centroid.each_index do |i|
                        delta += ( point[i] - centroid[i] )**2
                    end
                    if closest_centroid_distance.nil? or delta < closest_centroid_distance
                        closest_centroid_label = label
                        closest_centroid_distance = delta
                    end
                end
                centroid_assignments[closest_centroid_label] << point
            end

            @centroids = []
            centroid_assignments.values.each do |assignments|
                new_centroid = assignments.transpose.map do |a|
                    length = a.length
                    a.reduce(:+) / length
                end

                add_centroid( *new_centroid )
            end

        end
    end
end

################################# END OF FILE #################################