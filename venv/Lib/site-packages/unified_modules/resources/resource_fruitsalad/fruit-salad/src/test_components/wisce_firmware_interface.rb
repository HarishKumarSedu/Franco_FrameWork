# encoding: utf-8
################################################################################
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   wisce_firmware_interface
### @brief  Base class for specialisation by firmware test components used by WISCE.
###
### @version \$Id: wisce_firmware_interface.rb 1024 2015-05-05 16:10:29Z aangus $
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

require 'configuration'
require 'test_components/firmware_interface'
require 'logfw'

###############################################################################
#
# Encapsulates all of the high-level functionality expected from all firmware
# into a common interface.
#
###############################################################################
class WISCEFirmwareInterface < FirmwareInterface

    #
    # To specialise this class the following attributes must be defined in the
    # base class:
    # algorithm_name
    #
    attr_accessor :algorithm_name

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor. Assigns the owning DeviceInterface to the attribute
    # '@device'.
    #
    # @param [DeviceInterface] device The parent device object.
    #
    ###########################################################################
    def initialize( device )
        @device = device
    end

    ###########################################################################
    #
    # @function prerequisite_firmware
    #
    # Register a firmware file as being a prerequisite to the main module of this
    # code.
    #
    # @param [Fixnum] core         The DSP core this firmware should be loaded onto.
    # @param [String] name         The firmware name.
    # @param [String] file         The filename of the file containing this firmware or nil.
    # @param [String] version      The version of the file containing this firmware.
    #
    ###########################################################################
    def prerequisite_firmware( core, name, file, version )
        if @prerequisite_firmwares.nil?
            @prerequisite_firmwares = []
        end
        @prerequisite_firmwares << [ core, name, file, version ]
    end

    ###########################################################################
    #
    # @function load_prerequisite_firmwares
    #
    # Iterate through prerequisite firmware array and load each in turn.
    #
    # @param [String] revision         The firmware revision.
    #
    # (no parameters)
    #
    ###########################################################################
    def load_prerequisite_firmwares ( revision )
        @revision = revision
        if @prerequisite_firmwares.nil?
            @prerequisite_firmwares = []

            scan_for_prerequisite_firmwares
        end

        @component_firmwares = @prerequisite_firmwares.map do |core, name, file, version|
            firmware = WISCEFirmwareInterface.new( @device )
            firmware.algorithm_name = name
            firmware.load( core, firmware_file: file, firmware_revision: revision)

            firmware
        end
    end

    ###########################################################################
    #
    # @function scan_for_prerequisite_firmwares
    #
    # Read in the list of firmwares prerequisite to this one from a configuration
    # variable, :FirmwarePrerequisite
    #
    # (no parameters)
    #
    ###########################################################################
    def scan_for_prerequisite_firmwares
        prerequisites = firmware_data.fetch( "requires", [] )

        prerequisites.each do |row|
            core    = row['core'].to_i
            name    = row['name']
            file    = row.fetch('file',nil)
            version = row['version']

            prerequisite_firmware( core, name, file, version )
        end
    end

    ###########################################################################
    #
    # @function firmware_data
    #
    # Obtain the firmware data structure defined in the configuration file.
    #
    # (no parameters)
    #
    # @return [Hash] The firmware object for this firmware defined in the
    #                config file.
    #
    # @raise [RuntimeError] If the firmware is not defined.
    #
    ###########################################################################
    def firmware_data()
        device = FruitSalad::get_device()
        return Conf::get_firmware_data( device.device_id,
                                        device.hw_revision,
                                        algorithm_name,
                                        @revision
                                      )
    end

    ###########################################################################
    #
    # @function load
    #
    # Load the firmware onto the test target.
    #
    # @param [Fixnum] dsp_core_index  The index core to load the firmware onto.
    #                                 0-indexed.
    # @param [Hash]   options         The optional keyword arguments.
    #
    # @option options [Boolean] :autostart         If true, the firmware will be
    #                                              started immediately after loading,
    #                                              defaults to false.
    # @option options [String]  :firmware_file     Overrides the default mechanism
    #                                              for finding this firmware and
    #                                              loads a named file instead.
    # @option options [String]  :firmware_revision Requested firmware revision.
    #
    # @raise [RuntimeError] If FirmwareFiles config variable does not contain
    #                       a firmware for this algorithm/core combination or
    #                       is not defined.
    # @raise [RuntimeError] If the firmware fails to match the requested revision after loading,
    #                       or otherwise fails checks (wrong name, core etc.).
    #
    ###########################################################################
    def load( dsp_core_index, options={} )
        @core_index = dsp_core_index
        @revision = options.fetch( :firmware_revision, nil )

        # Check for deprecated form
        if options.is_a? TrueClass or options.is_a? FalseClass
            $LOG.info "WARNING: WISCEFirmwareInterface::load( Fixnum, Boolean ) is deprecated."
            $LOG.info "Use load( Fixnum, Hash ) instead."
            options = { :autostart => options }
        end

        # keyword arguments
        autostart = options.fetch( :autostart, false )
        firmware_file = options.fetch( :firmware_file, nil )
        if firmware_file.nil?
            firmware_file_list = firmware_data.fetch( "files", {} )

            firmware_file = firmware_file_list["DSP#{@core_index+1}"]
            if firmware_file.nil?
                $LOG.debug "firmware: #{firmware_data}"
                raise "Firmware data hash does not contain file for this core."
            end
        end

        # Currently, load_firmware does not work due to a known defect in WISCE.
        # Otherwise we'd use
        # @device.load_firmware
        # As an interim hack, we're using the following.
        firmware_id = firmware_data.fetch( 'id', nil )
        if ( 'FIRMWARE_FLORIDA_EZ2CONTROL' == firmware_id )
            @device.usecase( "dsp#{@core_index+1}_clocking" )
            @device.usecase( 'drc_settings' )
        elsif ( 'FIRMWARE_CLWR_EZ2CONTROL' == firmware_id ||
                'FIRMWARE_CLWR_EZ2CONTROL30' == firmware_id ||
                'FIRMWARE_CLEARWATER_MCDEBUG' == firmware_id
              )
            @device.usecase( 'clwr_clocking_setup' )
        elsif ( 'FIRMWARE_CLWR_VT_ENGINE' == firmware_id )
            @device.usecase( "dsp#{@core_index+1}_clwr_clocking" )
        elsif ( 'FIRMWARE_CLEARWATER_TDASR_ENGINE' == firmware_id )
            @device.usecase( "dsp#{@core_index+1}_clwr_clocking" )
        else
            raise 'Firmware id could not be recognized'
        end

        @firmware_version = nil
        firmware_revision = options.fetch( :firmware_revision, nil )
        if ( !firmware_revision.nil? )
           @firmware_version = firmware_data.fetch( 'version', nil )
            if ( @firmware_version.nil? )
                raise LoadingUnsuccessfulMessage
            end
        end

        @prerequisite_firmwares = nil
        load_prerequisite_firmwares( firmware_revision )
        @device.load_firmware_from_usecase( firmware_file, @core_index )
        opts = { 'revision' => @revision, 'version' => @firmware_version, 'dsp_core' => @core_index }
        # check firmware version - will be re-caught and thrown as Pending in the step_definitions layer
        unless @device.is_firmware_loaded?( algorithm_name, opts )
            # The call to is_firmware_loaded? will have already printed debug information on what was located on this core.
            raise LoadingUnsuccessfulMessage
        end

        if ( 'FIRMWARE_CLEARWATER_MCDEBUG' == firmware_id )
            @device.usecase( 'tracefw_clwr_settings' )
        end
        start if autostart
    end

    ###########################################################################
    #
    # @function start
    #
    # Begin running this firmware.
    #
    # @note The firmware should be loaded first.
    #
    ###########################################################################
    def start()
        @component_firmwares.each { |firmware| firmware.start }
        @device.start_firmware( algorithm_name, @revision, @firmware_version, @core_index )
    end

end

################################# END OF FILE #################################