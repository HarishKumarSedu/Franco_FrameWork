////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 Cirrus Logic International (UK) Ltd.  All rights reserved.
//
// This software as well as any related documentation is furnished under 
// license and may only be used or copied in accordance with the terms of the 
// license. The information in this file is furnished for informational use 
// only, is subject to change without notice, and should not be construed as 
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document. 
//
// Except as permitted by such license, no part of this document may be 
// reproduced, stored in a retrieval system, or transmitted in any form or by 
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies. 
//
/// @file   fruitsalad_player.cpp
/// @brief  Basic player/recorder facility for FruitSalad.
///
/// @version \$Id: fruitsalad_player.cpp 558 2014-12-03 16:55:34Z aangus $
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Includes
///////////////////////////////////////////////////////////////////////////////

#include <cstdio>
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <iostream>

#include <zmq.hpp>

#include "fruitsalad_player_interface.h"
#include "options.h"

///////////////////////////////////////////////////////////////////////////////
/// Namespace aliases
///////////////////////////////////////////////////////////////////////////////

namespace fpi = fruitsalad_player_interface;

///////////////////////////////////////////////////////////////////////////////
/// Enums
///////////////////////////////////////////////////////////////////////////////

// using positive error values as not all shells support negative return codes
enum ExitCode{ FP_SUCCESS = 0,
               FP_ARGUMENT_PARSE_ERROR,
               ZMQ_SEND_ERROR,
               ZMQ_RECEIVE_ERROR
             };

///////////////////////////////////////////////////////////////////////////////
/// Constants
///////////////////////////////////////////////////////////////////////////////
static const int g_DEFAULT_IO_THREAD_COUNT = 1;

///////////////////////////////////////////////////////////////////////////////
/// Function definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///
/// Function: SendCommand
///
/// @brief Sends a serialized command over a zmq socket.
///
/// @param socket A zmq socket to use while sending the message.
/// @param msg    A message to send.
///
/// @retval FP_SUCCESS     on success.
/// @retval ZMQ_SEND_ERROR if an error occurs while sending a message.
///
///////////////////////////////////////////////////////////////////////////////
ExitCode SendCommand( zmq::socket_t &socket, const std::string &msg )
{
    ExitCode exitCode = ZMQ_SEND_ERROR;

    zmq::message_t request( msg.size() );
    memcpy( request.data(), msg.data(), msg.size() );
    printf( "%s: %s\n", __FUNCTION__, "sending command" );
    bool sent = socket.send( request );
    printf( "%s: %s %d\n", __FUNCTION__, "send operation complete", sent );    

    if ( sent )
        exitCode = FP_SUCCESS;

    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: WaitForResult
///
/// @brief Performs a blocking receive on the supplied socket.
///
/// @param socket A zmq socket to listen on.
///
/// @retval FP_SUCCESS        on success.
/// @retval ZMQ_RECEIVE_ERROR if an error occurs while receiving the message.
///
///////////////////////////////////////////////////////////////////////////////
ExitCode WaitForResult( zmq::socket_t &socket )
{
    ExitCode exitCode = ZMQ_RECEIVE_ERROR;

    zmq::message_t reply;
    try
    {
        bool received = socket.recv( &reply );
    
        if ( received )
        {
            std::string resStr = std::string( static_cast<char*>(reply.data()),
                                              reply.size()
                                            );
            int resultCode = fpi::ParseResult( resStr );
            printf( "%s %s %d\n", __FUNCTION__, "received result", resultCode );
            exitCode = FP_SUCCESS;
        }
    }
    catch ( zmq::error_t e )
    {
        exitCode = ZMQ_RECEIVE_ERROR;
    } 
    
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: Handshake
///
/// @brief Sends a handshake message and waits for a response.
///
/// @param socket A zmq socket to use.
///
/// @retval FP_SUCCESS        on success.
/// @retval ZMQ_RECEIVE_ERROR if an error occurs while receiving the message.
///
///////////////////////////////////////////////////////////////////////////////
ExitCode Handshake( zmq::socket_t &socket )
{
    ExitCode exitCode = ZMQ_SEND_ERROR;

    exitCode = SendCommand( socket, fpi::CreateHandshakeMessage() );
    exitCode = WaitForResult( socket );

    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: main
///
/// @brief Program entry point.
///
/// @return FP_SUCCESS on success, error code defined on ExitCode otherwise.
///
///////////////////////////////////////////////////////////////////////////////
int main( int argc, char **argv )
{
    int exitCode = FP_ARGUMENT_PARSE_ERROR;
    Options options;

    std::shared_ptr<Command> setUp = options.AddCommand( "set_up" );
    std::shared_ptr<Command> play = options.AddCommand( "play" );
    std::shared_ptr<Command> record = options.AddCommand( "record" );
    std::shared_ptr<Command> stopPlayback = options.AddCommand( "stop_playback" );
    std::shared_ptr<Command> stopRecording = options.AddCommand( "stop_recording" );
    std::shared_ptr<Command> terminate = options.AddCommand( "terminate" );

	std::shared_ptr<Command> codec_state = options.AddCommand( "codec_state" );

    std::shared_ptr<ValuedOption<int>> playbackChannels =
        options.AddValuedOption<int>( "p",
                                      "playback_channels",
                                      "sets playback channel count",
                                      SINGLE_VALUE,
                                      INTEGER_OPTION,
                                      "1"
                                    );
    std::shared_ptr<ValuedOption<int>> recordingChannels =
        options.AddValuedOption<int>( "r",
                                      "recording_channels",
                                      "sets recording channel count",
                                      SINGLE_VALUE,
                                      INTEGER_OPTION,
                                      "1"
                                    );
    std::shared_ptr<ValuedOption<int>> sampleRate =
        options.AddValuedOption<int>( "s",
                                      "sample_rate",
                                      "sets sample rate",
                                      SINGLE_VALUE,
                                      INTEGER_OPTION,
                                      "44100"
                                    );
    std::shared_ptr<ValuedOption<int>> bufferSize =
        options.AddValuedOption<int>( "b",
                                      "buffer_size",
                                      "sets buffer size",
                                      SINGLE_VALUE,
                                      INTEGER_OPTION,
                                      "2048"
                                    );
    std::shared_ptr<ValuedOption<std::string>> fileName =
        options.AddValuedOption<std::string>( "f",
                                              "file_name",
                                              "sets file name",
                                              SINGLE_VALUE,
                                              STRING_OPTION,
                                              ""
                                            );
    
    setUp->AssociateOption( playbackChannels );
    setUp->AssociateOption( recordingChannels );
    setUp->AssociateOption( sampleRate );
    setUp->AssociateOption( bufferSize );
    
    play->AssociateOption( fileName );
    
    record->AssociateOption( fileName );

    ParserExitStatus parserExitStatus = options.Parse( argc, argv );
    
    if ( PARSING_SUCCESS == parserExitStatus )
    {
        zmq::context_t context( g_DEFAULT_IO_THREAD_COUNT );
        zmq::socket_t socket( context, ZMQ_REQ );

        //
        // note: in case of these options -1 means infinite, positive values
        //       indicate time in milliseconds (for more info see ZMQ docs)
        //
        int sendTimeout = 0, receiveTimeout =  -1, linger = 0;
        socket.setsockopt( ZMQ_SNDTIMEO, &sendTimeout, sizeof( sendTimeout ) );
        socket.setsockopt( ZMQ_RCVTIMEO, &receiveTimeout, sizeof( receiveTimeout ) );
        socket.setsockopt( ZMQ_LINGER, &linger, sizeof( linger ) );

        printf( "%s: %s\n", __FUNCTION__,"Connecting to player daemon ...");
        socket.connect( "tcp://localhost:5555" );
        printf( "%s: %s\n", __FUNCTION__,"Connected.");
        
        receiveTimeout =  100;
        socket.setsockopt( ZMQ_RCVTIMEO, &receiveTimeout, sizeof( receiveTimeout ) );
        exitCode = Handshake( socket );

        if ( FP_SUCCESS == exitCode )
        {
            receiveTimeout =  -1;
            socket.setsockopt( ZMQ_RCVTIMEO, &receiveTimeout, sizeof( receiveTimeout ) );

            if ( setUp->IsInvoked() )
            {
                exitCode = SendCommand( socket,
                                        fpi::CreateSetUpMessage( playbackChannels->GetValue(),
                                                                 recordingChannels->GetValue(),
                                                                 sampleRate->GetValue(),
                                                                 bufferSize->GetValue()
                                                               )
                                      );
            }
            else if( play->IsInvoked() )
            {
                exitCode = SendCommand( socket,
                                        fpi::CreatePlayFromFileMessage( fileName->GetValue() )
                                      );
            }
            else if( record->IsInvoked() )
            {
                exitCode = SendCommand( socket,
                                        fpi::CreateRecordToFileMessage( fileName->GetValue() )
                                      );
            }
            else if( stopPlayback->IsInvoked() )
            {
                exitCode = SendCommand( socket, fpi::CreateStopPlaybackMessage() );
            }
            else if( stopRecording->IsInvoked() )
            {
                exitCode = SendCommand( socket, fpi::CreateStopRecordingMessage() );
            }
            else if( terminate->IsInvoked() )
            {
                exitCode = SendCommand( socket, fpi::CreateTerminateMessage() );
            }
			else if( codec_state->IsInvoked() )
            {
                exitCode = SendCommand( socket, fpi::CreateCommandTypeMessage( fpi::CODEC_STATE) );
            }

            if ( FP_SUCCESS == exitCode )
                exitCode = WaitForResult( socket );
        }
        else
        {
            printf( "%s: %s\n", __FUNCTION__,"Daemon not working.");
        }

        socket.close();
    }
    else
    {
        options.PrintUsage();
    }

    return exitCode;
}
/////////////////////////////END OF FILE///////////////////////////////////////