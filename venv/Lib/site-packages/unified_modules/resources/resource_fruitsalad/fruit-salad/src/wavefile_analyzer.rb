###############################################################################
###
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.
###                         All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any errors
### or inaccuracies that may appear in this document or any software that may be
### provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   wavefile_analyzer.rb
### @brief  Performs analysis of .wav files to verify the behaviour of a device.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

require 'wavefile'
require 'waveinfo'
require 'configuration'
require 'fft'
require 'csv'
require 'audioinfo'
require 'KMeans'
require 'logfw'
include WaveFile

# Constant values for header processing.
DEF_WAVE_HDR_LEN = 44
DEF_FMT_DATA_LEN = 16
DEF_RIFF_LEN = DEF_FMT_DATA_LEN + 20
DEF_WAVE_FMT = 1
CHANNEL_STEREO = 2
#
# While writing sample into output file, we are writing them in a array of 2 or 3
# (if bit-depth is 16 writing array size will be 2. And if bit-depth is 24
# writing array size will be 3). So buffer size should be multiple of 2, 3 & 4.
#
BUFFER_SIZE = 1020

#################################################################################
#
# Analysis implementation to be used as a mix-in with platform-specific
# FruitSalad modules.
#
# This implementation deals with recordings stored as .wav files on a filesystem
# which should cover most if not all platforms except the null device.
#
#################################################################################
module WavefileAnalyzer

    #############################################################################
    #
    # The smallest maximum sample magnitude (as a float) needed for a recording
    # to be considered 'non-silent' in dBFS.
    #
    #############################################################################
    RecordingSilenceThreshold = Conf.property( :Analyzer_RecordingSilenceThreshold, -45 )

    # The cut-off for our simple similarity algorithm that determines whether
    # two audio signals are 'similar' enough.
    # Can be set with the Analyzer_SimpleSimilarityThreshold config key.
    SimpleSimilarityThreshold = Conf.property( :Analyzer_SimpleSimilarityThreshold, 0.95 )

    ###########################################################################
    #
    # The sample rate, to avoid artifacts from resampling.
    #
    ###########################################################################
    SampleRate = Conf.property( :SampleRate, nil )


    ###########################################################################
    #
    # Default impulse length used in frequency response measurements.
    #
    ###########################################################################
    DefaultImpulseLength = 8192

    #############################################################################
    #
    # @function is_silence?
    #
    # Determines whether a file is silence or not by finding the average
    # amplitude value within the file and comparing it against a value
    # specified by the constant RecordingSilenceThreshold.The length used to
    # calculate the average value is decided as per the length of FFT used
    # in our calculations.
    #
    # @param [String] file The name of the file to analyze
    #
    #############################################################################
    def is_silence?( file )
        supreavg = 0
        total_buffer = []
        average_value = 0

        # Flatten channels into single mono stream.
        format = WaveFile::Format.new( :mono, :float, SampleRate )
        reader = WaveFile::Reader.new( file, format ).each_buffer( SampleRate ) do | buffer |
            #The length to calculate the average value is decided based on FFT length used.
            NativeFFT::pad_length( buffer.samples )
            buffer.samples.each do | sample |
                average_value = average_value + sample.abs
            end
            average_value = average_value / buffer.samples.length
            supreavg = average_value.abs if supreavg < average_value.abs
        end
        supreavg = to_dbfs( supreavg ) # convert to dBFS
        $LOG.debug "Largest avg value is: #{supreavg} dBFS"
        $LOG.debug "Threshold is: #{RecordingSilenceThreshold}"
        return supreavg < RecordingSilenceThreshold
    end

  ############################################################################
    #
    # @function find_recording_supremum
    #
    # Find the maximum value in an given recorded audio stream.
    #
    # @param [String] file            The name of the file to analyse
    #
    # @return [Float] Maximum absolute value found in audio stream.
    #
    ############################################################################
    def find_recording_supremum( file )
        supremum = 0
        # Flatten channels into single mono stream.
        format = WaveFile::Format.new( :mono, :float, SampleRate )
        reader = WaveFile::Reader.new( file, format ).each_buffer( 1024 ) do |buffer|
            buffer.samples.each do |sample|
                if supremum < sample.abs
                    supremum = sample.abs
                end
            end
        end
        $LOG.debug "Audio File: #{file}"
        $LOG.debug "Largest sample raw value: #{supremum}"
        supremum = to_dbfs( supremum ) # convert to dBFS
        $LOG.debug "Largest sample was: #{supremum} dBFS"

        return supremum
    end

    ############################################################################
    #
    # @function is_similar_dB_volume?
    #
    # Determines whether two files have peak amplitudes within a set threshold
    # of each other.
    #
    # By finding the largest amplitude sample within the file and comparing it
    # against the largest amplitude sample within the other file and evaluating
    # whether this is within the specified 'max dB variance'.
    #
    # @param [String] file1            The name of the first file to analyse
    # @param [String] file2            The name of the second file to analyse
    # @param [String] dB_max_variance  Tolerable variance in the maximum (in dB)
    #
    ############################################################################
    def is_similar_dB_volume?( file1, file2, dB_max_variance )
        supremum1 = find_recording_supremum( file1 )
        supremum2 = find_recording_supremum( file2 )

        difference = supremum1 - supremum2
        $LOG.debug "Therefore dB difference = #{difference} dBFS"

        return difference.abs <= dB_max_variance
    end

    #############################################################################
    #
    # @function find_phase_diff?
    #
    # Determines the phase error between the two channels of the input file.
    #
    # @param [String] file The name of the file to analyze
    #
    # @raise [RunTimeError] If the input is not a two channel stream.
    # @raise [RunTimeError] If the length of inputfile is zero.
    # @raise [RunTimeError] If two channels contain different peak frequencies.
    #
    # @return [Float] Phase difference between 2 channels at peak frequencies
    #
    #############################################################################
    def find_phase_diff?( file )
        info = Reader.info( file )
        tx = nil
        channel1 = []
        channel2 = []
        @peak_phase = -1   # value will be updated on calculating the peak_frequency
        channel1_peak_freq = 0 # peak_frequency of channel 1
        channel2_peak_freq = 0 # peak_frequency of channel 2
        if( info.channels != 2 )
            raise'Input file should have 2 channles to find the phase difference'
        end
        format = Format.new( info.channels, info.bits_per_sample, info.sample_rate )
        reader = Reader.new( file, format ) do | file |
            tx = file.read( file.total_sample_frames ).samples
            if( 0 == tx.length )
                raise 'Input stream does not contain any data'
            end
        end
        ( 0...tx.length ).each do |i|
            channel1.push( tx[i][0] )
            channel2.push( tx[i][1] )
        end
        buffer = Buffer.new( channel1, Format.new( :mono, info.bits_per_sample, info.sample_rate ) )
        Writer.new( 'channel1.wav', Format.new( :mono, info.bits_per_sample, info.sample_rate ) ) do | writer |
           writer.write( buffer )
        end
        buffer = Buffer.new( channel2, Format.new( :mono, info.bits_per_sample, info.sample_rate ) )
        Writer.new( 'channel2.wav', Format.new( :mono, info.bits_per_sample, info.sample_rate ) ) do | writer |
           writer.write( buffer )
        end
        channel1_peak_freq = peak_frequency( 'channel1.wav' )
        channel1_peak_phase = @peak_phase
        channel2_peak_freq = peak_frequency( 'channel2.wav' )
        channel2_peak_phase = @peak_phase
        if( channel1_peak_freq != channel2_peak_freq )
            raise "#{file} have different channel1 and channel2 peak_frequencies"
        end
        #checking that the output does not contain silence
        if( 0 == channel1_peak_freq || 0 == channel2_peak_freq )
            raise "Check the input file data as channel1_peak_freq #{channel1_peak_freq} and channel2_peak_freq #{channel2_peak_freq}"
        end

        delta_phase = channel1_peak_phase - channel2_peak_phase
        return delta_phase.abs
    end

    ###########################################################################
    #
    # @function fft
    #
    # The default Fast Fourier Transform used by all analysis in this module.
    # This is a wrapper for NativeFFT::fft to explicitly include it in this
    # namespace.
    #
    # @param [Array] input Complex or Real valued samples of a time-domain
    #                      signal.
    # @param [Hash]  opts  Optional parameters passed as a hash.
    #
    # @option opts [Boolean] drop_mirrored  If true then drop the second, mirrored,
    #                                       copy of the DFT sequence. Defaults to false.
    # @option opts [Boolean] absolute       If true then convert the complex
    #                                       domain output to its absolute value.
    #                                       Defaults to false.
    #
    # @return [Array] Complex valued frequency bins for a frequency domain
    #                 representation of that signal.
    #
    ###########################################################################
    def fft( input, opts={} )
        drop_mirrored = opts.fetch( :drop_mirrored, false )
        absolute = opts.fetch( :absolute, false )

        output = NativeFFT::fft( input )

        if drop_mirrored
            output = output.take( output.length / 2 )
        end

        if absolute
            output.map! { |x| [x.abs,x.angle] }
        end

        return output
    end

    ###########################################################################
    #
    # @function ifft
    #
    # The default inverse Fast Fourier Transform used by all analysis in this
    # module. This is a wrapper for NativeFFT::ifft to explicitly include it in
    # this namespace.
    #
    # @param [Array] input Complex or Real valued numbers representing frequency
    #                      bins of a frequency-domain signal.
    #
    # @return [Array] Complex valued samples of a time-domain representation
    #                 of the same signal.
    #
    ###########################################################################
    def ifft( input )
        return NativeFFT::ifft( input )
    end

    ###########################################################################
    #
    # @function simple_similarity_measure
    #
    # Compares two files to determine similarity very crudely.
    #
    # @param [String] file1 The name of the first file.
    # @param [String] file2 The name of the second file.
    #
    # @return [Float] A number indicating how alike the two files are, with 1
    #                 being identical and 0 being not-at-all alike.
    #
    #############################################################################
    def simple_similarity_measure( file1, file2 )

        peak_frequency1 = peak_frequency( file1 )
        peak_frequency2 = peak_frequency( file2 )

        similarity = peak_frequency1 / peak_frequency2
        similarity = 1/similarity if similarity > 1

        $LOG.debug "Measured similarity: #{similarity}"

        return similarity
    end

    ###########################################################################
    #
    # @function files_similar?
    #
    # Determine whether two files are likely to be the same.
    #
    # @param [String] file1 The name of the first file.
    # @param [String] file2 The name of the file to compare it to.
    #
    # @return [Bool] True if the files are similar, else false.
    #
    ###########################################################################
    def files_similar?( file1, file2 )
        similarity = simple_similarity_measure( file1, file2 )
        return similarity >= SimpleSimilarityThreshold
    end

    ###########################################################################
    #
    # @function peak_frequency
    #
    # Estimate the frequency, of a wavefile, with peak power.
    #
    # @param [String] file The name of the file to analyze
    #
    # @return [Float] The peak frequency of the file in Hz.
    #
    ###########################################################################
    def peak_frequency( file )
        if File.exists?( file )
            info = Reader.info( file )
            sample_rate = info.sample_rate
        end

        frequencies = dominant_frequencies( file, sample_rate:sample_rate )
        return frequencies[0]
    end

    ###########################################################################
    #
    # @function frequency_bin_to_hz
    #
    # Convert a frequency bin to its associated frequency (in Hz) from its number
    # in the sequence.
    #
    # @param [Integer] bin_number       The number of the frequency bin to convert
    # @param [Fixnum]  sample_rate      The sample rate of the source sequence
    # @param [Fixnum]  sequence_length  The number of samples in the source sequence
    #
    # @return [Float] The corresponding frequency in Hz
    #
    ###########################################################################
    def frequency_bin_to_hz( bin_number, sample_rate, sequence_length )
        return bin_number.to_f * sample_rate.to_f / sequence_length.to_f
    end

    ###########################################################################
    #
    # @function arg_max
    #
    # Find the position of the largest value in a stream of numbers.
    #
    # @param [Array] array An Array of numbers.
    #
    # @return [Integer] The index of the peak.
    #
    ###########################################################################
    def arg_max( array )
        max = array[0]
        argument = 0
        length = array.length
        (1...length).each do |i|
            if array[i] > max
                max = array[i]
                argument = i
            end
        end
        return argument
    end

    ###########################################################################
    #
    # @function mode
    #
    # Find the modal value of an array.
    #
    # @note If the dataset is multimodal then only one mode will be returned.
    #
    # @param [Array] array The dataset.
    #
    # @return [Integer] The modal value.
    #
    ###########################################################################
    def mode( array )
        frequencies = []
        array.each do |value|
            frequency = array.count( value )
            frequencies << frequency
        end
        argument = arg_max( frequencies )
        return array[argument]
    end


    ###########################################################################
    #
    # @function find_frequencies
    #
    # Find the frequencies of an input WAV file.
    #
    # @param [String] wavfile       Name of the input file
    #
    # @return [Array] The frequency bins of input wave file
    #                 Updates the instance variable @peak_phase with the phase angle
    #                 at peak frequency.
    #
    ###########################################################################
    def find_frequencies( wavfile, sample_rate )
        input_signal = FruitSaladUtils::read_wavefile( wavfile, sample_rate )
        # Convert to mono signal
        input_signal = input_signal.map { |row| row.reduce(:+) }
        # Split into buffers each 1s long
        buffers = input_signal.each_slice( sample_rate ).to_a
        # Change to frequency-domain
        $LOG.info "Calculating FFTs"
        $LOG.time ""
        buffers.map! do |buffer|
            $LOG.print "."
            dft_sequence = fft( buffer, drop_mirrored:true, absolute:true )
            dft_sequence
        end
        $LOG.print "\n"
        fft_magnitude = 0
        fft_phase = 0
        fft_magnitude_phase = []
        frequency_domain_signal = []
        if buffers.length > 1
            buffers.reduce(&:zip).map( &:flatten ).map do |row|
                x=0
                while x <= row.length
                    if( !row[x].nil? && !row[x+1].nil? )
                        fft_magnitude = fft_magnitude + row[x]
                        fft_phase = fft_phase + row[x+1]
                    end
                x=x+2
                end

                fft_magnitude = fft_magnitude/row.length/2
                fft_phase = fft_phase/row.length/2
                fft_magnitude_phase.push( fft_magnitude )
                fft_magnitude_phase.push( fft_phase )
                fft_magnitude = 0
                fft_phase = 0
                if(!fft_magnitude_phase.nil?)
                    frequency_domain_signal.push( fft_magnitude_phase )
                end
                fft_magnitude_phase = []
            end
        else
            frequency_domain_signal = buffers[0]
        end
        # Sort (frequency,power) pairs by power
        signal_length = frequency_domain_signal.length*2
        frequency_by_power = ( 0...frequency_domain_signal.length ).zip frequency_domain_signal
        frequency_by_power.map! do |bin,power|
            [ frequency_bin_to_hz( bin, sample_rate, signal_length ), power ]
        end
        return frequency_by_power
    end

    ###########################################################################
    #
    # @function dominant_frequencies
    #
    # Find the dominant frequencies of an input WAV file.
    #
    # @param [String] wavfile       Name of the input file
    # @param [Hash]   options_hash  Hash of allowable FFT options.
    # @option options_hash [Number] :threshold threshold (noise floor) under which a tone will be discarded.
    #
    # @return [Array] The frequency bins that contribute the most to the signal,
    #                 sorted by power
    #
    # @raise [Errno::ENOENT] If wavfile does not exist
    #
    ###########################################################################
    def dominant_frequencies( wavfile, options_hash={} )
        # user configuration options and defaults
        # cutoff magnitude in dB was originally 1/4 (-12dB)
        fft_magnitude_cutoff = options_hash.fetch( :threshold, Conf.property( :FFT_magnitude_cutoff, -20 ) )
        tones_to_display     = Conf.property( :FFT_display_number, 5 )

        sample_rate = options_hash.fetch( :sample_rate, Conf.property( :SampleRate, 48000 ) )

        frequency_by_power = find_frequencies( wavfile, sample_rate )
        frequency_by_power.sort! { |a,b| b[1][0] <=> a[1][0] }
        # Filter out anything weaker than the cutoff relative to the most powerful frequency.
        peak = frequency_by_power[0][1][0]
        @peak_phase = frequency_by_power[0][1][1]
        $LOG.debug "peak_phase is #{@peak_phase}"
        attenuation = 10 ** ( fft_magnitude_cutoff.to_f / 20 )
        cutoff_power = peak * attenuation

        $LOG.debug "Peak tone found at #{frequency_by_power[0][0].round( 3 )}Hz, magnitude of #{peak.round( 3 )}(0dB) phase of #{@peak_phase.round(3)}"
        $LOG.debug "Cutoff magnitude of #{cutoff_power.round( 3 )} (#{fft_magnitude_cutoff}dB)"

        frequency_by_power = frequency_by_power.find_all do |frequency, power|
            power[0] >= cutoff_power
        end
        # Drop the power column
        frequency_by_power.map! { |frequency,_| frequency }

        ( 1..tones_to_display ).each do |i|
            if frequency_by_power.length >= i
                $LOG.debug "tone #{i}: #{frequency_by_power[i-1]} Hz"
            end
        end
        if frequency_by_power.length >= tones_to_display
            $LOG.debug "And #{frequency_by_power.length - tones_to_display} others."
        else
            $LOG.info 'And 0 others.'
        end

        return frequency_by_power
    end

    ###########################################################################
    #
    # @function saturation_check
    #
    # Find whether saturation occured in input WAV file.
    #
    # @param [String] wavfile             Name of the input file
    # @param [Array] expected_frequencies Array of expected frequencies.
    #                                     Only 2 frequencies are allowed.
    #
    # @return [Bool] True is returned if saturation occured in output file
    #                else false is returned
    #
    # @raise [Runtime Error] If expected frequency does not lie in input data
    #                        range
    #
    ###########################################################################
    def saturation_check( wavfile, expected_frequencies, sample_rate = nil )
        if sample_rate.nil?
            sample_rate = Conf.property( :SampleRate, 48000 )
        end

        if expected_frequencies.length > 1
            expected_frequencies.sort! { |a,b| a <=> b }
        end

        fundamental_frequency = expected_frequencies[0]
        wave_frequency = sample_rate / 2

        if fundamental_frequency > wave_frequency
            raise 'Your fundamental frequency does not lie in the wave frequency range'
        end

        frequency_by_power = find_frequencies( wavfile, sample_rate )

        # Calculating harmonic frequencies based on fundamental frequency
        harmonic_frequencies = []
        count = 0
        i = 2
        temp_frequency = ( fundamental_frequency * i )
        while temp_frequency < wave_frequency  do
            if expected_frequencies.length > 1
                ( 1...expected_frequencies.length ).each do |i|
                    if expected_frequencies [i] == temp_frequency
                        temp_frequency = 0
                        break
                    end
                end
            end
            if temp_frequency != 0
                harmonic_frequencies[count] = temp_frequency
                count +=1
            end
            i += 1
            temp_frequency = ( fundamental_frequency * i )
        end
        # Calculate harmonic frequencies sum
        harmonic_sum = 0
        ( 1...harmonic_frequencies.length ).each do |i|
            harmonic_frequency = harmonic_frequencies [i-1]
            ( 1...frequency_by_power.length ).each do |i|
                if frequency_by_power[i][0] == harmonic_frequency
                    value = frequency_by_power[i][1][0]
                    harmonic_sum = harmonic_sum + value
                    break
                end
            end
        end
        $LOG.debug "harmonic frequencies sum is #{harmonic_sum}"

        peak_value = 0;
        ( 1...frequency_by_power.length ).each do |i|
            if frequency_by_power[i][0].round == fundamental_frequency
                peak_value = frequency_by_power[i][1][0]
                $LOG.debug "Fundamental frequency value is #{peak_value}"
                break
            end
        end

        saturation_threshold = Conf.property( :Saturation_Threshold, 0.1 )
        saturation_cutoff = ( peak_value * saturation_threshold )

        return ( harmonic_sum > saturation_cutoff )
    end

    ###########################################################################
    #
    # @function verify_frequency_clusters
    #
    # Verify our expected frequency clusters appear in a list of dominant
    # frequencies as extracted by dominant_frequencies
    #
    # @param [Array<Numeric>] expected      The expected frequency cluster centroids
    # @param [Array<Numeric>] measured      The measured frequencies with power
    #                                       greater than the noise floor
    # @param [Numeric]        error         The tolerance within which the centroid
    #                                       is allowed to be
    #
    # @return [Array<Numeric>]  A list of expected frequency clusters not
    #                           satisfied by the measured dominant frequencies
    #
    ###########################################################################
    def verify_frequency_clusters( expected, measured, error )
        kmeans = KMeans.new
        measured.each do |frequency|
            kmeans.add_data_points( [frequency] )
        end

        expected.each do |frequency|
            kmeans.add_centroid( frequency )
        end

        kmeans.iterate

        #
        # Check resulting centroids against expected
        #
        # Spurious frequencies in the measured output will cause the centroids
        # to diverge from the seed values, dragging their means out of the
        # tolerance range specified by error.
        #
        missing_frequencies = []
        expected.each do |frequency|
            matches = kmeans.centroids.map do |centroid|
                centroid[0] >= frequency - error and centroid[0] <= frequency + error
            end
            unless matches.select { |a| true == a }.length > 0
                missing_frequencies << frequency
            end
        end
        $LOG.debug "KMeans Centroids: #{kmeans.centroids}"
        return missing_frequencies
    end

    ###########################################################################
    #
    # @function correlation
    #
    # Generate a correlation signal by sample-wise multiplication of two input
    # signals.
    #
    # @note The signals are assumed to be of the same SampleRate and
    #       approximately the same length. If one signal is longer than the other
    #       then the output signal will be the length of the shortest.
    #
    # @param [Array] a An array of numerical samples representing one input
    #                  signal
    # @param [Array] b An array of numerical samples representing one input
    #                  signal
    #
    # @return [Array] The output correlated signal.
    #
    ###########################################################################
    def correlation( a, b )
        length = [a.length, b.length].min
        output = Array.new( length )

        (0...length).each do |i|
            output[i] = a[i] * b[i]
        end

        return output
    end

    ###########################################################################
    #
    # @function hamming_window
    #
    # Generates the hamming coefficients for a window of specific length.
    #
    # @param [Integer] length The number of points in the hamming window.
    #
    # @return [Array] An array containing the Hamming coefficients.
    #
    ###########################################################################
    def hamming_window( length )
        output = []
        (0...length).each do |n|
            output << 0.5 * (1 - Math::cos( 2*Math::PI * n / (length-1) ) )
        end
        return output
    end

    ###########################################################################
    #
    # @function rms
    #
    # Calculates the RMS value of a signal.
    #
    # @param [Array] input An array of numerical samples over the frequency.
    #
    # @return [Float] The Root-Mean-Square value of the signal.
    #
    ###########################################################################
    def rms( input )
        squares = []
        input.each do |sample|
            squares << sample**2
        end

        mean = 0
        squares.each do |square|
            mean += square
        end
        mean /= squares.length.to_f

        root = sqrt( mean )

        return root
    end

    ###########################################################################
    #
    # @function frequency_response
    #
    # Measures the frequency response from a source signal, and a measured
    # output signal.
    #
    # @param [String] source_file   The source audio signal as a path to a .wav
    #                               file.
    # @param [String] recorded_file The recorded output of the system as a path
    #                               to .wav a file.
    #
    # @return [Array] The frequency response as an Array of hashmap objects.
    #                 Each hasmap contains the following symbols: :frequency,
    #                 :gain and :phase.
    #
    ###########################################################################
    def frequency_response( source_file, recorded_file )
        # Read in wave files.
        tx = rx = nil
        format = WaveFile::Format.new( :mono, :float, SampleRate )
        WaveFile::Reader.new( source_file, format ) do |file|
            tx = file.read( file.total_sample_frames ).samples
        end
        WaveFile::Reader.new( recorded_file, format ) do |file|
            rx = file.read( file.total_sample_frames ).samples
        end

        len_impulse = DefaultImpulseLength
        bucket_width = SampleRate.to_f/len_impulse.to_f

        rx = Array.new(tx.length,0.0)+rx

        # Find convolution (argument order matters)
        convolution = convolution_fft( rx, tx )

        # Locate the impulse response in the given correlation
        position = find_impulse_response_position( convolution,
                                                   tx.length,
                                                   tx.length )

        # Extract impulse response
        response = Array.new( len_impulse, 0.0 )
        j = 0
        ((position-len_impulse/2)...(position+len_impulse/2)).each do |i|
            response[j] =
                convolution[(i>=0 && i<(rx.length+tx.length)) ? i : 0]
            j += 1
        end

        # Hamming window
        hamming = hamming_window( response.length )
        (0...response.length).each do |i|
            response[i] = response[i] * hamming[i]
        end

        # Remove DC component and normalise
        response = process_impulse( fft( response ) )

        # Write a WISCE *.rsp file for verification purposes
        write_wisce_rsp_file( response, SampleRate )

        response = response[0...len_impulse/2]

        phase = response.map { |a| a.angle }
        response.map! { |a| a.abs }

        # Convert gain to dBFS units
        response.map! { |a| to_dbfs( a ) }

        # Dump the response for debug purposes
        file_name = "#{source_file}_response.csv"
        CSV.open( file_name, "wb" ) do |csv|
            csv << ["Frequency (Hz)", "Gain (dB)", "Phase Angle"]
            (1...response.length).each do |i|
                frequency = i.to_f * bucket_width
                db_gain = response[i]
                phase_angle = phase[i]
                csv << [frequency, db_gain, phase_angle]
            end
        end

        # Convert to hashmaps
        response = response.zip( (0...response.length), phase )
        response.map! { |a| {
            frequency: a[1]*bucket_width,
            gain: a[0],
            phase: a[2]
        } }

        return response
    end

    ###########################################################################
    #
    # @function response_acceptable?
    #
    # Is the measured response within the bounds defined by the expected
    # response?
    #
    # @param [Array] expected An Array of hash objects specifying the properties
    #                         or bounds that each datum of the measured response
    #                         is expected to fit.
    # @param [Array] measured An Array of hash objects specifying the actual
    #                         properties of each point of datum on the response
    #                         curve.
    # @param [Optional] low_freq_bound Lower bound of frequency band (in Hz)
    #                                  in which the filter response should be
    #                                  tested (default value is 0 Hz).
    # @param [Optional] hi_freq_bound Higher bound of frequency band (in Hz)
    #                                 in which the filter response should be
    #                                 tested (default value is 32000 Hz).
    #
    # @return [Bool] True if the measured response is inside the bounds defined
    #                by expected, else false.
    #
    # @raise []  An exception is raised if the the measured response does not
    #         match the expected response within bounds defined by the
    #         expected_response? method
    #
    ###########################################################################
    def response_acceptable?( expected, measured, low_freq_bound=0, hi_freq_bound=32000 )

        expected.each do |expected_datum|
            frequency = expected_datum[:frequency]
            if low_freq_bound<=frequency && frequency<=hi_freq_bound
                # Find the closest datum in the measured set
                distances = measured.map{ |a| (a[:frequency].to_f-frequency.to_f).abs }
                f_index = distances.index( distances.min )

                measured_datum = measured[f_index]

                unless measured_datum[:gain] >= expected_datum[:gain_min] and
                    measured_datum[:gain] <= expected_datum[:gain_max]
                    $LOG.info "Please see the csv file in tmp for detailed frequency analysis."
                    raise "Frequency response out of bounds at #{frequency}Hz. Measured #{measured_datum[:gain]}dB"
                end
            end
        end

        return true
    end

    ###########################################################################
    #
    # @function response_from_file
    #
    # Load a frequency response from a file. The format of the file has each
    # datum on a seperate line, with the frequency (in Hz) first, followed
    # by an '=' character and then the magnitude of the gain in dB. Whitespace is
    # ignored.
    #
    # @param [String] filename The name of the file to load.
    #
    # @return [Array] An array of Hash objects with :frequency and :gain attributes.
    #
    ###########################################################################
    def response_from_file( filename )
        file = File.new( filename, 'r' )
        response = []
        file.each_line do |line|
            datum = {}
            line = line.scan( /\-?\d+\.?\d*/ )
            raise "Error parsing #{filename}" unless line[0] != nil
            raise "Error parsing #{filename}" unless line[1] != nil
            datum[:frequency] = line[0].to_f
            datum[:gain] = line[1].to_f
            response << datum
        end
        file.close
        return response
    end

    ###########################################################################
    #
    # @function response_set_bounds
    #
    # Take a frequency response definition and a tolerance and add :gain_min and
    # :gain_max to each element's hash object.
    #
    # @param [Array] response  An array of hash objects each with :frequency and
    #                          :gain attributes which define the general shape of
    #                          the response curve
    # @param [Float] tolerance The amount that each data point is allowed to slide
    #                          up or down. :gain_min becomes the :gain - tolerance
    #                          and :gain_max becomes the :gain + tolerance.
    #
    # @return [Array] The response curve with :gain_min and :gain_max attributes
    #                 defined on each Hash element of the array.
    #
    ###########################################################################
    def response_set_bounds( response, tolerance )
        response.map do |element|
            element[:gain_min] = element[:gain] - tolerance
            element[:gain_max] = element[:gain] + tolerance
        end
        return response
    end

    ###########################################################################
    #
    # @function to_dbfs
    #
    # Convert sample value to full scale decibels (dBFS).
    #
    # @param level An amplitude value to convert.
    #
    # @return A dBFS amplitude.
    #
    ###########################################################################
    def to_dbfs( level )
        return 20*Math.log10( level )
    end

    ###########################################################################
    #
    # @function write_wisce_rsp_file
    #
    # Write out a given frequency response as a *.rsp file compatible with
    # WISCE™.
    #
    # @note This function is intended for debugging purposes.™
    #
    # @param [Array] response An array of complex values representing the full
    #                         frequency response (including negative
    #                         frequencies).
    # @param sample_rate Sample rate at which the frequency response was
    #                    obtained (or rather read in).
    #
    ###########################################################################
    def write_wisce_rsp_file( response, sample_rate )
        f = File.new( "response.rsp", "w" )
        t = Time.now
        f.write( "*\n*\n" )
        f.write( "* Wolfson audio response file\n" )
        f.write( "* Created at #{t.hour}:#{t.min}:#{t.sec} on "\
                 "#{t.year}-#{t.month}-#{t.day}\n" )
        f.write( "*\n*\n" )
        f.write( "SampleCount    #{response.length}\n" )
        f.write( "SampleRate     #{sample_rate}\n\n" )
        f.write( "Values:\n" )
        for a in response
            f.write( "#{a.real} #{a.imag}\n" )
        end
        f.close
    end

    ###########################################################################
    #
    # @function read_wisce_rsp_file
    #
    # Reads in a frequency response from a valid WISCE™ *.rsp file.
    #
    # @param filename Path to a valid WISCE™ *.rsp file.
    #
    # @return [Array] An array of Hash objects with :frequency and :gain
    #                 attributes.
    #
    ###########################################################################
    def read_wisce_rsp_file( filename )
        file = File.new( filename, 'r' )
        response = []
        sample_count = 0
        sample_rate = 0
        sample_counter = 0
        file.each_line do |line|
            unless line.start_with? "*"
                if line.start_with? "SampleCount"
                    line = line.scan(/\d+/)
                    raise "Error parsing #{filename}" unless line[0] != nil
                    sample_count = line[0].to_f
                elsif line.start_with? "SampleRate"
                    line = line.scan(/\d+/)
                    raise "Error parsing #{filename}" unless line[0] != nil
                    sample_rate = line[0].to_f
                elsif (not line.chomp.empty?) && (not line.start_with? "Values:")
                    datum = {}
                    line = line.scan( /\-?\d+\.?\d*/ )
                    raise "Error parsing #{filename}" unless line[0] != nil
                    raise "Error parsing #{filename}" unless line[1] != nil
                    datum[:frequency] = sample_rate*sample_counter.to_f/sample_count
                    datum[:gain] = to_dbfs( Complex(line[0],line[1]).abs )
                    sample_counter += 1
                    response << datum
                    if sample_counter >= sample_count/2.0
                        break
                    end
                end
            end
        end
        file.close
        return response
    end

    ###########################################################################
    #
    # @function process_impulse
    #
    # Removes DC component and normalises a given frequency response.
    #
    # @param [Array] response_fft An array of complex values representing the
    #                             full frequency response (including negative
    #                             frequencies).
    #
    # @return [Array] A normalised frequency response with DC component set to
    #                 0.
    #
    ###########################################################################
    def process_impulse( response_fft )
        # remove DC component
        response_fft[0] = Complex( 0, 0 )

        # power normalisation
        power_sum = 0.0
        (0...response_fft.length/2).each do |i|
            power_sum += response_fft[i].real.to_f**2.0 + response_fft[i].imag.to_f**2.0
        end
        power_sum = 1.0/Math.sqrt( power_sum/(response_fft.length.to_f/2.0) ).to_f

        (0...response_fft.length).each do |i|
            response_fft[i] = Complex( response_fft[i].real.to_f*power_sum,
                                       response_fft[i].imag.to_f*power_sum )
        end

        response_fft
    end

    ###########################################################################
    #
    # @function find_impulse_response_position
    #
    # Given convolution of generated MLS noise and corresponding measured
    # MLS noise locate the impulse response.
    #
    # @param [Array] rx An array representing the correlation of generated and
    #                   measured MLS noise.
    # @param mls_length The number of samples in the MLS pulse that was used
    #                   to generate the convolution output.
    # @param mls_separation The number of samples between the MLS pulses used
    #                       to generate the convolution output.
    #
    # @return Position of the impulse response in the supplied
    #         convolution.
    #
    ###########################################################################
    def find_impulse_response_position( rx, mls_length, mls_separation )
        max_value = 0.0
        max_value_position = 0

        # find maximal correlation peak
        rx.each_with_index do |value,i|
            if max_value<value.abs
                max_value = value.abs
                max_value_position = i
            end
        end

        # search on either side of best peak
        max_ratio = 0.0
        max_ratio_pos = 0
        (-1..1).each do |i|
            i_pos = max_value_position+i*mls_separation

            if i_pos>=mls_length && i_pos<=rx.length-mls_length/2
                # calculate peak amplitude
                peak_energy = rx[i_pos]**2.0

                # calculate energy in MLS pulse
                total_energy = 0.0
                (0...mls_length).each do |j|
                    total_energy += rx[i_pos+j-(mls_length-1)/2]**2.0
                end
                total_energy /= mls_length.to_f

                # calculate ratio of peak energy to total energy
                ratio = peak_energy.to_f/total_energy.to_f

                # record position of the highest ratio
                if max_ratio<ratio
                    max_ratio = ratio
                    max_ratio_pos = i_pos
                end
            end
        end

        max_ratio_pos
    end

    ###########################################################################
    #
    # @function convolution_fft
    #
    # Calculates the convolution of two signals.
    #
    # @param [Array] rx An array of floats representing an input signal.
    # @param [Array] tx An array of floats representing an input signal.
    #
    # @return [Array] An array of float values representing the convolution
    #                 of the given signals.
    #
    ###########################################################################
    def convolution_fft( rx, tx )
        txr = tx.reverse

        len_tx = nearest_power_of_two( tx.length )

        rx_len_padded = rx.length
        if 0!=(rx.length%len_tx)
            rx_len_padded = rx.length-(rx.length%len_tx)+len_tx
        end

        result = Array.new( rx.length+len_tx, 0.0 )

        txr = NativeFFT::fft_with_size(txr,len_tx*2)

        (0...rx_len_padded).step(len_tx) do |offset|
            rx_part = Array.new( 2*len_tx, 0.0 )
            (0...len_tx).each do |i|
                rx_part[i] = (i+offset)>=rx.length ? 0.0 : rx[i+offset]
            end

            rx_part = NativeFFT::fft_with_size(rx_part,len_tx*2)

            #convolve ffts of rx and tx
            (0...len_tx*2).each do |i|
                re = rx_part[i].real.to_f*txr[i].real.to_f - rx_part[i].imag*txr[i].imag.to_f
                im = rx_part[i].real.to_f*txr[i].imag.to_f + rx_part[i].imag*txr[i].real.to_f

                rx_part[i] = Complex( re, im )
            end

            rx_part = NativeFFT::ifft_with_size(rx_part,len_tx*2)

            #mix into result
            (0...len_tx*2).each do |i|
                if i+offset<rx.length+len_tx
                    result[i+offset] += rx_part[i].real.to_f
                end
            end
        end

        result
    end

    ###########################################################################
    #
    # @function nearest_power_of_two
    #
    # Finds a power of two nearest to the supplied value.
    #
    # @param n A numeric value.
    #
    # @return Power of two nearest to the given value.
    #
    ###########################################################################
    def nearest_power_of_two( n )
        2**(Math::log2(n).ceil)
    end

    ###########################################################################
    #
    # @function track_length_wav
    #
    # The length of a named track ending in extension '.wav'.
    #
    # @param [String] filename The name of the .wav file.
    #
    # @return [Float] The length of the .wav file in seconds.
    #
    ###########################################################################
    def track_length_wav( filename )
        duration = WaveFile::Reader.new( filename ).total_duration
        seconds = duration.hours * 60**2
        seconds += duration.minutes * 60
        seconds += duration.seconds
        seconds += duration.milliseconds / 1000.0
        return seconds
    end

    ###########################################################################
    #
    # @function track_length
    #
    # The length of a track of arbitrary type.
    #
    # Call through to specialist methods as necessary.
    #
    # @param [String] filename The name of the media file.
    #
    # @return [Float] The length of the media file in seconds.
    #
    # @raise [RunTimeError] If the file does not have appropriate metadata.
    #
    ###########################################################################
    def track_length( filename )
        extension = File::extname( filename ).downcase
        case extension
        when '.wav'
            return track_length_wav filename
        else
            AudioInfo.open( filename ) do |metadata|
                raise "Metadata is needed to find the length. Try a different file." if metadata.null?
                return metadata.length
            end
        end
    end
    ###########################################################################
    #
    # @function signal_addition
    #
    # Addition of two given wav files.
    #
    # @param [String] file1 The name of the first media file.
    # @param [String] file2 The name of the second media file.
    #
    # @return [String] out_filename The name of the added file.
    #
    ###########################################################################
    def signal_addition( file1, file2 )
        file1_info = WaveFile::Reader.info( file1 )
        file2_info = WaveFile::Reader.info( file2 )
        basename1 = File::basename( file1, '.wav' )
        basename2 = File::basename( file2, '.wav' )
        samples_per_buffer = 1024

        unless(
                file1_info.sample_rate == file2_info.sample_rate
                file1_info.bits_per_sample == file2_info.bits_per_sample
                file1_info.channels == file2_info.channels
               )
            raise "Signal addtion not supported for the given inptuts.
                   The inputs should be equal in bitdepth,
                   number of channels and sample rate"
        end

        if file1_info.channels > 2
            raise "Signal addition not supported for more than 2 channels"
        end

        sample_data1 = []
        sample_data2 = []
        sample_buffer = []
        out_filename = File.join( 'tmp', "added_#{basename1}_#{basename2}.wav" )

        format = WaveFile::Format.new( file1_info.channels,
                                       file1_info.bits_per_sample,
                                       file1_info.sample_rate
                                      )
        reader = WaveFile::Reader.new( file1, format ).each_buffer( samples_per_buffer ) do |buffer|
           sample_data1.concat buffer.samples
        end
        reader = WaveFile::Reader.new( file2, format ).each_buffer( samples_per_buffer ) do |buffer|
           sample_data2.concat buffer.samples
        end

        size1 = sample_data1.size
        size2 = sample_data2.size
        if size1 > size2
            size_big = size1
            size_small = size2
        else
            size_big = size2
            size_small = size1
        end

        for i in 0..( size_big - 1 )
            if i < size_small
                if file1_info.channels == 1
                    write_sample = ( sample_data1[i] / 2 ) + ( sample_data2[i] / 2 )
                else
                    write_sample = []
                    temp1 = ( sample_data1[i][0] / 2 ) + ( sample_data2[i][0] / 2 )
                    temp2 = ( sample_data1[i][1] / 2 ) + ( sample_data2[i][1] / 2 )
                    write_sample << [ temp1, temp2 ]
                end
            else
                if size1 > size2
                    if file1_info.channels == 1
                        write_sample = ( sample_data1[i] / 2 )
                    else
                        write_sample = []
                        temp1 = ( sample_data1[i][0] / 2 )
                        temp2 = ( sample_data1[i][1] / 2 )
                        write_sample << [ temp1, temp2 ]
                    end
                else
                    if file1_info.channels == 1
                        write_sample = ( sample_data2[i] / 2 )
                    else
                        write_sample = []
                        temp1 = ( sample_data2[i][0] / 2 )
                        temp2 = ( sample_data2[i][1] / 2 )
                        write_sample << [ temp1, temp2 ]
                    end
                end
            end
            sample_buffer << [write_sample]
        end

        write_buffer = WaveFile::Buffer.new( sample_buffer, format )
        WaveFile::Writer.new( "#{out_filename}", format ) do |writer|
            writer.write( write_buffer )
        end

        return out_filename
    end

    ###########################################################################
    #
    # @function gain_multiplication
    #
    # Multiplying given gain with given wav file.
    #
    # @param [String] file The name of the media file.
    # @param [Float] gain The gain value to be multiplied with wav.
    #
    # @return [String]  outfilename The file path of the gain multiplied
    #                               wav
    #
    # @raise [RunTimeError] Raises error if the gain not within the range of
    #                       0 to 1
    #
    ###########################################################################
    def gain_multiplication( file, gain )
        if 1 < gain || gain < 0.0
            raise 'Gain should be within the range of 0 to 1'
        end

        basename = File::basename( file, '.wav' )
        file_info = WaveFile::Reader.info( file )
        sample_data = []
        sample_buffer = []
        out_filename = File.join( 'tmp', "multiplied_gain_#{gain}_#{basename}.wav" )

        if file_info.channels > 2
            raise "Signal addition not supported for more than 2 channels"
        end

        format = WaveFile::Format.new( file_info.channels,
                                       file_info.bits_per_sample,
                                       file_info.sample_rate
                                      )
        reader = WaveFile::Reader.new( file, format ).each_buffer( 1024 ) do |buffer|
           sample_data.concat buffer.samples
        end

        size = sample_data.size
        for i in 0..( size - 1 )
            if 1 == file_info.channels
                write_sample = ( sample_data[i] * gain )
            else
                write_sample = []
                temp1 = ( sample_data[i][0] * gain )
                temp2 = ( sample_data[i][1] * gain )
                write_sample << [ temp1, temp2 ]
            end
            sample_buffer << write_sample
        end

        write_buffer = WaveFile::Buffer.new( sample_buffer, format )
        WaveFile::Writer.new( "#{out_filename}", format ) do |writer|
            writer.write( write_buffer )
        end

        return out_filename
    end

    ###########################################################################
    #
    # @function similarity
    #
    # Find the similarity between two given sign wav files.
    #
    # @param [String] file1 The name of the media file to compare.
    # @param [String] file2 The name of the another media file to compare.
    # @param [Float] error Threshold level.
    #
    # @raise [RunTimeError] When given files are not similar.
    #
    ###########################################################################
    def similarity( file1, file2, error )
    # Calculate measured frequencies
    measured_frequencies1 = FruitSalad::dominant_frequencies file1
    measured_frequencies2 = FruitSalad::dominant_frequencies file2

    missing = FruitSalad::verify_frequency_clusters(
                                                    measured_frequencies1,
                                                    measured_frequencies2,
                                                    error
                                                   )

        if missing.length > 0
            $LOG.debug "Missing frequencies: #{missing}"
            raise 'The given wav files are not similar.'
        end

    end

    ###########################################################################
    #
    # @function create_wav_copy
    #
    # Create the copy of wav file with the given data
    #
    # @param [String] in_file The name of the input file.
    # @param [String] out_file The name of the output file.
    #
    ###########################################################################
    def create_wav_copy( in_file, out_file)
        info = WaveFile::Reader.info( in_file )

        sample_data = []

        format = WaveFile::Format.new( info.channels,
                                       info.bits_per_sample,
                                       info.sample_rate
                                     )
        reader = WaveFile::Reader.new( in_file, format ).each_buffer( 1024 ) do |buffer|
           sample_data.concat buffer.samples
        end

        write_buffer = WaveFile::Buffer.new( sample_data, format )
        WaveFile::Writer.new( out_file, format ) do |writer|
            writer.write( write_buffer )
        end

    end

    ###########################################################################
    #
    # @function club_two_mono_to_stereo
    #
    # Convert the two given mono channel streams into one stereo stream.
    #
    # @param [String] in_file1 The name of the first input file.
    # @param [String] in_file2 The name of the second input file.
    # @param [String] out_file The name of the output file.
    #
    ###########################################################################
    def club_two_mono_to_stereo( in_file1, in_file2, out_file )

        # As we are converting mono into stereo channels are hard coded.
        channels = CHANNEL_STEREO

        info1 = WaveFile::Reader.info( in_file1 )
        info2 = WaveFile::Reader.info( in_file2 )

        if ( info1.sample_rate != info2.sample_rate or
             info1.bits_per_sample != info2.bits_per_sample or
             1 != info1.channels or
             1 != info2.channels
           )
            raise 'Given wave files should have same bit-depth, sample rate and mono channel files'
        end

        io_out = open( out_file, 'wb' )
        file1 = File.open( in_file1, 'rb' )
        file2 = File.open( in_file2, 'rb' )

        # Skip the Header of the wave file
        read_index = DEF_WAVE_HDR_LEN.to_i
        bytes_per_buffer = BUFFER_SIZE

        length1 = file1.size - read_index
        length2 = file2.size - read_index

        # Get the maximum length of given input files.
        max_length = length1
        max_length = length2 if length1 < length2

        # Calculate the number of bytes need to written per sample.
        bytes_per_sample = ( info1.bits_per_sample / 8 )

        # Calculate 'BUFFER_SIZE' data in the largest given input.
        loop_count = ( max_length / bytes_per_buffer )
        loop_count1 = ( length1 / bytes_per_buffer )
        loop_count2 = ( length2 / bytes_per_buffer )
        #
        # Calculates the data need to be written in the last loop.
        # As the last data of the input signal may not be the multiple of 1024.
        #
        modulus = ( max_length % bytes_per_buffer )
        modulus1 = ( length1 % bytes_per_buffer )
        modulus2 = ( length2 % bytes_per_buffer )

        loop_count += 1 if modulus != 0
        end_point = bytes_per_buffer
        end_point1 = bytes_per_buffer
        end_point2 = bytes_per_buffer

        count = 0
        loop_count.times do
            count += 1

            if loop_count == count and modulus != 0
                end_point = modulus
            end
            if loop_count1 == count and modulus1 != 0
                end_point1 = modulus1
            end
            if loop_count2 == count and modulus2 != 0
                end_point2 = modulus2
            end

            unless ( ( ( count - 1 ) * BUFFER_SIZE + end_point1) > length1 )
                io_in1 = IO.read( file1, end_point1, read_index )
            end
            unless ( ( ( count - 1 ) * BUFFER_SIZE + end_point2) > length2 )
                io_in2 = IO.read( file2, end_point2, read_index )
            end

            # Rotate each buffer with step of 'bytes_per_sample'
            # till BUFFER_SIZE for every buffer.
            0.step( ( end_point - 1 ), bytes_per_sample ) do |i|
                #
                # Writes each indidual byte into io_out file pointer.
                # The following loop writes data to first channel.
                #
                for j in 0..( bytes_per_sample - 1 )
                    if max_length > length1 and ( ( ( count - 1 ) * BUFFER_SIZE + end_point1) >= length1 )
                        #
                        # If file1 is smaller than file2 write 0 of file1
                        # after the file1 data processing completed.
                        #
                        io_out.write( '' )
                    else
                        io_out.write( io_in1[ i + j ] )
                    end
                end
                # The following loop writes data to second channel.
                for k in 0..( bytes_per_sample - 1 )
                    if max_length > length2 and ( ( ( count - 1 ) * BUFFER_SIZE + end_point2) >= length2 )
                        #
                        # If file2 is smaller than file1 write 0 of file12
                        # after the file1 data processing completed.
                        #
                        io_out.write( '' )
                    else
                        io_out.write( io_in2[ i + k ] )
                    end
                end
            end

            # Increament the read index by 'BUFFER_SIZE'.
            read_index += end_point
        end
        io_out.close
        file1.close
        file2.close
        #
        # As the we have written raw data in the out file add header to the
        # output file
        #
        add_wave_header_to_pcm_file( out_file,
                                     channels,
                                     info1.bits_per_sample,
                                     info1.sample_rate
                                   )
    end

    ###########################################################################
    #
    # @function add_wave_header_to_pcm_file
    #
    # Updates the wave header to the PCM file.
    #
    # @param [String] wav_file The name of the wave file
    # @param [Integer] channels No of channels for wave header.
    # @param [Integer] bits_per_sample Bit depth for the wave header.
    # @param [Integer] sample_rate Sample rate for the wave header.
    #
    ###########################################################################
    def add_wave_header_to_pcm_file( wav_file,
                                     channels,
                                     bits_per_sample,
                                     sample_rate
                                   )

        bit_depth = bits_per_sample / 8
        # Create a temporary file to store the pcm data.
        tmp_file = File.join( ENV['FRUITSALAD_HOME'],
                                    'tmp/tmp_file.wav'
                            )
        if  File.exists?( tmp_file )
            File.delete( tmp_file )
        end
        in_file = File.open( wav_file, 'rb' )
        out_file = File.open( tmp_file, 'wb' )
        wave_data = in_file.read
        out_file.write ( wave_data )
        out_file.close
        in_file.close

        # Add header to the temporarily created file and write  back to
        # original file name.
        file_ptr = File.open( tmp_file, 'rb' )
        file_ptr.seek( DEF_WAVE_HDR_LEN, IO::SEEK_SET )
        io_in = file_ptr.read

        if  File.exists?( wav_file )
            File.delete( wav_file )
        end
        io_out = open( wav_file, 'wb' )
        # Marks the file as a riff file. Characters are each 1 byte long.
        io_out.write( 'RIFF' )
        #
        # It is 36 only. In this section we will write 'Size of the overall file
        # - 8 bytes'. io_in.length gives us size of data section. And we are
        # adding 36(44-8) to it.
        #
        io_out.write( [io_in.length + DEF_RIFF_LEN].pack( 'i*' ) )
        # File Type Header. For our purposes, it always equals "WAVE".
        io_out.write( 'WAVE' )
        # Format chunk marker. Includes trailing null
        io_out.write( 'fmt ' )
        # Length of format data as listed above
        io_out.write( [DEF_FMT_DATA_LEN].pack( 'i*' ) )

        io_out.write( [DEF_WAVE_FMT].pack( 'v*' ) )
        # Number of Channels - 2 byte integer
        io_out.write( [channels].pack( 'v*' ) )
        # Sample Rate - 32 byte integer.
        io_out.write( [sample_rate].pack( 'i*' ) )
        # (Sample Rate * BitsPerSample * Channels) / 8.
        io_out.write( [( sample_rate * channels * bits_per_sample ) / 8].pack( 'i*' ) )

        io_out.write( [( channels * bits_per_sample ) / 8].pack( 'v*' ) )
        # Bits per sample
        io_out.write( [bits_per_sample].pack( 'v*' ) )
        # "data" chunk header. Marks the beginning of the data section.
        io_out.write( 'data' )
        # Size of the data section.
        io_out.write( [io_in.length].pack( 'i*' ) )
        # Write data in the wave file.
        io_out.write( io_in )
        io_out.close
        file_ptr.close
        if  File.exists?( tmp_file )
            File.delete( tmp_file )
        end
    end

    #############################################################################
    #
    # @function find_average_amplitude_value
    #
    # Determines the average amplitude value within the file.The average
    # amplitude value is calculated by adding amplitude value of every sample
    # and dividing the sum value with the total number of samples present in a
    # wave file.
    #
    # @param [String] file The name of the file to analyze
    #
    # @return [Array] returns array of average amplitude value per each channel
    #                 in a file.
    #
    #############################################################################
    def find_average_amplitude_value( file )

        # Reading file information
        info = Reader.info( file )
        channels = info.channels
        # Taking buffer size as 8000 by default
        buffer_size = Conf.property( :buffer_size, 8000 )
        bit_depth = info.bits_per_sample
        format = WaveFile::Format.new( channels, bit_depth, info.sample_rate )
        average = []
        for i in 0...channels
            count = 0
            average[i] = 0
            reader = WaveFile::Reader.new( file, format ).each_buffer( buffer_size ) do | buffer |
                sample_amplitude_value = 0
                buffer.samples.each do | sample |
                    if channels == 1
                        sample_amplitude_value = sample_amplitude_value + sample.abs
                    else
                        sample_amplitude_value = sample_amplitude_value + sample[i].abs
                    end
                end
                average_value = sample_amplitude_value.to_f / buffer.samples.length
                average[i] = average[i] + average_value
                count = count + 1
            end
            average[i] = average[i] / count
            # converting the PCM value to amplitude value
            average[i] = (average[i] / (2 ** (bit_depth - 1)))
            average[i] = to_dbfs( average[i] ) # convert to dBFS
            $LOG.debug "The average amplitude value of channel : #{i} is: #{average[i]} dBFS"
        end
        return average
    end

end
##################################### END OF FILE ###############################