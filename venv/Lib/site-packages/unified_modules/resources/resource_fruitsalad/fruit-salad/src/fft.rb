################################################################################
###
### Copyright (c) 2014 Wolfson Microelectronics plc.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Wolfson Microelectronics plc. Wolfson Microelectronics plc
### assumes no responsibility or liability for any errors or inaccuracies that
### may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Wolfson Microelectronics plc.
###
### @file   native_fft.rb
### @brief  Wrapper for native object-code implementation of Fast Fourier Transform.
###
### @version \$Id: fft.rb 367 2014-11-06 12:39:40Z aangus $
###
### Warning
###   This software is specifically written for Wolfson devices. It may not be
###   used with other devices.
###
#################################################################################

require "ffi"

###############################################################################
#
# Wrapper for shared library object code that calculates the complex frequency
# domain representation of a given signal.
#
# Higher-levle analysis should not be done here, only the actual fourier
# transform itself.
#
###############################################################################
module NativeFFT
    extend FFI::Library
    # Names of the shared library
    ffi_lib ["fft_x86", "libfft.arm.so", "libfft.x86.so"]

    # Position in the array returned by allocate_buffers that the Real Input
    # Buffer sits in.
    RealInput = 0
    # Position in the array returned by allocate_buffers that the Imag Input
    # Buffer sits in.
    ImagInput = 1
    # Position in the array returned by allocate_buffers that the Real Output
    # Buffer sits in.
    RealOutput = 2
    # Position in the array returned by allocate_buffers that the Imag Output
    # Buffer sits in.
    ImagOutput = 3

    ###########################################################################
    #
    # Pad an input signal by appending 0-values until its overall length is a
    # power of 2.
    #
    # @param [Array] input The input signal to pad.
    #
    # @return [Array] A copy of the original input with padding.
    #
    ###########################################################################
    def self.pad_length( input )
        while Math::log2( input.length ) % 1 != 0
            input << 0
        end
        return input
    end

    ###########################################################################
    #
    # Calculates the forward FFT for a given input signal. The returned signal
    # will contain as many samples (fS) as the input and the non-DC portion
    # will be mirrored about fS/2.
    #
    # @param [Array] input Is a Ruby Array of Complex or Real valued numbers
    #                      representing samples of the input time-domain signal.
    #
    # @return [Array] Returns a Ruby Array of Complex valued numbers representing
    #                 the input signal in the frequency domain.
    #
    ###########################################################################
    def self.fft( input )
        pad_length( input )
        return fft_with_size( input, input.length )
    end

    ###########################################################################
    #
    # Calculates the forward FFT for a given input signal. The returned signal
    # will contain as many samples (fS) as the input and the non-DC portion
    # will be mirrored about fS/2. Allows to control the FFT resolution by
    # setting buffer size (usually you will simply want to use fft).
    #
    # @param [Array] input Is a Ruby Array of Complex or Real valued numbers
    #                      representing samples of the input frequency-domain
    #                      signal.
    # @param size The size of FFT buffer to use.
    #
    # @return [Array] Returns a Ruby Array of Complex valued numbers representing
    #                 the input signal in the time domain.
    #
    ###########################################################################
    def self.fft_with_size( input, size )
        buffer_size = size
        pointers = allocate_buffers( buffer_size )
        copy_input( pointers, input )

        # Invoke native FFT
        CFFT( pointers[RealInput], pointers[ImagInput],
              pointers[RealOutput], pointers[ImagOutput],
              -1, buffer_size
            )

        output = copy_output( pointers, buffer_size )
        return output
    end

    ###########################################################################
    #
    # Calculates the inverse FFT from the frequency domain representation.
    #
    # @note Rounding errors mean that calling ifft on the forward fft of a
    #       signal may not result in exactly the same signal, only an
    #       approximation.
    #
    # @param [Array] input Is a Ruby Array of Complex or Real valued numbers
    #                      representing samples of the input frequency-domain
    #                      signal.
    #
    # @return [Array] Returns a Ruby Array of Complex valued numbers representing
    #                 the input signal in the time domain.
    #
    ###########################################################################
    def self.ifft( input )
        return ifft_with_size( input, input.length )
    end

    ###########################################################################
    #
    # Calculates the inverse FFT from the frequency domain representation.
    # Allows to control the FFT resolution by setting buffer size (usually you
    # will simply want to use ifft).
    #
    # @note Rounding errors mean that calling ifft on the forward fft of a
    #       signal may not result in exactly the same signal, only an
    #       approximation.
    #
    # @param [Array] input Is a Ruby Array of Complex or Real valued numbers
    #                      representing samples of the input frequency-domain
    #                      signal.
    # @param size The size of FFT buffer to use.
    #
    # @return [Array] Returns a Ruby Array of Complex valued numbers representing
    #                 the input signal in the time domain.
    #
    ###########################################################################
    def self.ifft_with_size( input, size )
        buffer_size = size
        pointers = allocate_buffers( buffer_size )
        copy_input( pointers, input )

        # Call native code
        CFFT( pointers[RealInput], pointers[ImagInput],
              pointers[RealOutput], pointers[ImagOutput],
              1, buffer_size
            )

        output = copy_output( pointers, buffer_size )
        return output
    end

    private

    ###########################################################################
    #
    # Helper function to allocate C-Array buffers on the heap for use with our
    # native FFT function.
    #
    # @param [Int] size The size of the buffers to allocate.
    #
    # @return [Array] a 4 element array of native memory locations in the order:
    #                 real input, imag input, real output, imag output.
    #
    ###########################################################################
    def self.allocate_buffers( size )
        pointers = Array.new( 4 ) { FFI::MemoryPointer.new( :float, size ) }
        return pointers
    end

    ###########################################################################
    #
    # Copy input samples from a Ruby representation to native memory.
    #
    # @param [Array] pointers A 4 element array of native memory locations as
    #                         created using allocate_buffers.
    # @param [Array] input    A Ruby Array of Complex or Real values to copy
    #                         into the first two floating point buffers of
    #                         pointers.
    #
    # @return [Nil]
    #
    ###########################################################################
    def self.copy_input( pointers, input )
        real_input = input.map { |c| c.to_c.real }
        imag_input = input.map { |c| c.to_c.imag }
        pointers[RealInput].write_array_of_float real_input
        pointers[ImagInput].write_array_of_float imag_input
        return nil
    end

    ###########################################################################
    #
    # Copy output back from native memory into a Ruby representation.
    #
    # @param [Array] pointers    A 4-element array of native memory locations as
    #                         created using allocate_buffers.
    # @param [Int]   buffer_size The number of elements in each C-array.
    #
    # @return [Array] A Ruby Array of Complex valued samples representing the
    #                 output of the transform.
    #
    ###########################################################################
    def self.copy_output( pointers, buffer_size )
        real_output = pointers[RealOutput].get_array_of_float( 0, buffer_size)
        imag_output = pointers[ImagOutput].get_array_of_float( 0, buffer_size)
        output = real_output.zip imag_output
        output.map! { |a| Complex( a[0], a[1] ) }
        return output
    end

    ###########################################################################
    #
    # Invokes the object code to perform a fast fourier transform on C-array
    # buffers representing the Complex input and output.
    #
    ###########################################################################
    attach_function :CFFT, [:pointer, :pointer, :pointer, :pointer, :float, :int], :void

end

######################### END OF FILE #########################################