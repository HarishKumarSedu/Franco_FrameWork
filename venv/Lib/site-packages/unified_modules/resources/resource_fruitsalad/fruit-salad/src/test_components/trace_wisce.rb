################################################################################
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   trace_wisce.rb
### @brief  Implementation of trace testing on the WISCE target.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

require 'configuration'
require 'test_components/wisce_firmware_interface'
require 'wisce_host_buffer_read'
include FruitSalad
require 'decompress'
require 'fruitsalad_base'

class TraceForWISCE < WISCEFirmwareInterface

    AlgorithmName = 'Trace'
    SampleRate = Conf.property( :SampleRate, nil )

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor. Sets the attributes needed by the interface.
    #
    # @param [DeviceInterface] device The parent device object.
    #
    ###########################################################################
    def initialize( device )
        @algorithm_name = AlgorithmName
        super
    end

    ###########################################################################
    #
    # @function trace_capture
    #
    # Plays a file and captures data.
    #
    # @param [String] input_file Name of a file to play.
    # @param [Hash]   options    Optional trace_capture arguments. This
    #                            supports: [String] data_file - File name which
    #                            is concatenated with input_file.
    #
    # @return [none] Returns none.
    #
    ###########################################################################
    def trace_capture( input_file, options = {} )

        data_file = options.fetch( :data_file, nil )

        # Get Firmware ID
        firmware_id = firmware_data.fetch( 'id', nil )

        # Calls WISCE host buffer read class initialize method
        @device.host_buffer_read.initialize_host_buffer_struct( firmware_id,
                                                                @core_index
                                                              )

        # Concatenates input file and data file, if data file is present.
        test_file = input_file
        unless data_file.nil?
            concatenated = 'tmp/concatenated_trace.wav'
            concat_data = FruitSaladUtils::concatenate_wavefiles( [input_file, data_file],
                                                                  SampleRate
                                                                )
            FruitSalad::write_waveform( concatenated, concat_data )
            test_file = concatenated
        end

        @device.playback( test_file, blocking: false )

        # wait for stream to start
        time_out = FruitSalad::track_length( test_file )
        wait_for_stream_start( time_out )

        if @device.output.nil?
            @device.output = 'trace_output.wav'
        end
        @device.trace_output = 'trace_output.wav'

        @device.host_buffer_read.read_host_buffer_data( firmware_id,
                                                        @device.trace_output
                                                      )

        @device.end_playback()
    end

    ###########################################################################
    #
    # @function wait_for_stream_start
    #
    # Checks if read index is greater than or equal to 0 for every 0.1 seconds
    # and waits in polling loop till read index is greater than or equal to 0
    # and exits if read index is not greater than 0 with in given time.
    #
    # @param [Float] time_out Maximum time out value to exit waiting for stream
    #                         to start buffer.
    #
    # @raise [RuntimeError] wait_for_stream_start will raise an exception if
    #                       stream buffering has not started with in time_out.
    #
    ###########################################################################
    def wait_for_stream_start( time_out )
        # Assigning poll time with 0.1 seconds
        poll_time = 0.1
        wait_time = 0

        while( wait_time <= time_out )
            # Finding if read index is greater than or equal to 0
            read_index = @device.host_buffer_read.get_read_index()
            if ( 0 <= read_index )
                break
            end
            sleep poll_time
            wait_time += poll_time
        end
        if ( 0 > read_index )
            raise 'Stream has not yet started'
        end
    end
end

############################### END OF FILE ###################################