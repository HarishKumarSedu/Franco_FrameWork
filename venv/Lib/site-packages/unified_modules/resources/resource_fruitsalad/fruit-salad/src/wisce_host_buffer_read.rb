################################################################################
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International(UK) Ltd assumes no responsibility or liability for any errors
### or inaccuracies that may appear in this document or any software that may
### be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   host_buffer_read_wisce.rb
### @brief  Implementation of Host Buffer Reading on the WISCE target.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

require 'configuration'
require 'test_components/wisce_firmware_interface'
require 'decompress'
require 'logfw'

include FruitSalad

###############################################################################
#
# Encapsulates all of the high-level functionality expected from Host Buffer
# read
#
###############################################################################
class HostBufferReadForWISCE

    # Map of core names to base addresses of firmware headers
    DSPDataMemoryBaseAddresses = Conf.property( :Firmware_DSPDataMemoryBaseAddresses, {} )

    # Recorded output file sample rate.
    SampleRate = Conf.property( :SampleRate, 16000 )

    # Bit-depth of the recorded output file.
    Bitdepth = Conf.property( :Bitdepth, 16 )


    # Number of channels of firmware recorded output file.
    Channels = Conf.property( :Firmware_Recording_Channels, {} )

    SUCCESS = 0
    DATA_READ_ERROR = -1
    BUFFER_STREAM_ERROR = -2
    # Constants for Max DSP buffer read size and register count per DSP field
    MAX_READ_SIZE = 1024
    MAX_24BIT_VALUE = 0xFFFFFF
    Is_24bit_signed = 0x800000
    BYTES_PER_WORD = 4
    BYTES_PER_ADSP_WORD = 3
    REGISTER_COUNT_PER_DSP_FIELD = 2

    # Host buffer structure offsets
    X_BUF_BASE_OFFSET_FROM_HOST_BUFFER = 0
    X_BUF_SIZE_OFFSET_FROM_HOST_BUFFER = 1
    X2_BUF_BASE_OFFSET_FROM_HOST_BUFFER = 2
    X_BUF_BRK_SIZE_OFFSET_FROM_HOST_BUFFER = 3
    Y_BUF_BASE_OFFSET_FROM_HOST_BUFFER = 4
    WRAP_OFFSET_FROM_HOST_BUFFER = 5
    HIGH_WATERMARK_OFFSET_FROM_HOST_BUFFER = 6
    IRQ_COUNT_OFFSET_FROM_HOST_BUFFER = 7
    IRQ_ACK_OFFSET_FROM_HOST_BUFFER = 8
    WRITE_INDEX_OFFSET_FROM_HOST_BUFFER = 9
    READ_INDEX_OFFSET_FROM_HOST_BUFFER = 10
    ERROR_OFFSET_FROM_HOST_BUFFER = 11

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor. Sets the attributes needed by the interface.
    #
    # @param [WISCESalad] device The parent device object.
    #
    ###########################################################################
    def initialize( device )
        @device = device
    end

    ###########################################################################
    #
    # @function get_memory_value
    #
    # Reads the memory value from the given offset of XM or YM base address and
    # converts the obtained byte array to word and returns it.
    #
    # @param [Integer] base_address Base address of DSP core either XM or YM.
    #
    # @param [Integer] dsp_offset Offset value to be added to the base address to get
    #                  the actual address of arbitrary memory
    #
    # @return [Integer] Returns obtained word after reading from the memory.
    #
    ###########################################################################
    def get_memory_value( base_address, dsp_offset )
        number_of_bytes = BYTES_PER_WORD
        read_from_device = true

        start_address = base_address + ( dsp_offset * REGISTER_COUNT_PER_DSP_FIELD )    # Adding readed offset to XM or YM base memory
        ret_bytes = @device.read_block_data( start_address,
                                             number_of_bytes,
                                             read_from_device
                                           )

        word = ret_bytes[0] << 24
        word |= ret_bytes[1] << 16
        word |= ret_bytes[2] << 8
        word |= ret_bytes[3]

        return word
    end

    ###########################################################################
    #
    # @function set_memory_value
    #
    # Writes given value in to the memory of XM or YM addresses.
    #
    # @param [Integer] write_address Address of the DSP core memory.
    #
    # @param [Integer] value Value that required to write in to memory.
    #
    # @return [none] Returns none
    #
    ###########################################################################
    def set_memory_value( write_address, value )
        # This is temporary solutions for writing values to memory.
        # Creating text file with the new value that need to write in to memory
        # with BLOCK WRITE commands.

        use_case_file = 'tmp_usecase'
        file_path = WISCESalad::UsecasePath

        new_file = File.join( file_path, use_case_file + ".txt" )

        File.open( new_file, 'w' ) do |file|
            file.puts "BLOCK_WRITE 0x#{write_address.to_s(16)} SMbus_32inx_16dat 0x34"
            file.printf( "%08x\n", value )
            file.puts "END"
        end

        # Using @system.LoadFile function writing updated read index to memory
        @device.usecase_from_file( use_case_file, silent: true )
    end

    ###########################################################################
    #
    # @function write_buffer_data
    #
    # Writes given buffer data to file.
    #
    # @param [Array] buffer A data array that needs to written to file.
    #
    # @param [String] file_name Name of the file to write the buffer data
    #                 to file.
    #
    # @return [none] Returns none.
    #
    ###########################################################################
    def write_buffer_data( buffer, file_name )
        File.open( file_name, 'wb' ) do | file |
            buffer.each do | ch |
                file.write( ch.chr )
            end
        end
    end

    ###########################################################################
    #
    # @function convert_to_24bit_signed
    #
    # Converts 24-bit value to signed representation.
    #
    # @param [Integer] word A 24-bit word integer.
    #
    # @return [Integer] Returns converted signed 24-bit word.
    #
    ###########################################################################
    def convert_to_24bit_signed( word )
        result = word & Is_24bit_signed    # Checks whether 24-bit word is signed?
        if( result != 0 )
            word -= MAX_24BIT_VALUE
            word -= 1                      # Represents word in negative.
        end
        return word
    end

    ###########################################################################
    #
    # @function get_host_buffer_ptr
    #
    # Reads DSP Host buffer register from the firmware register and returns DSP
    # host buffer pointer.
    #
    # @param [String] firmware_id Firmware ID that fetched from the firmware
    #                  data.
    #
    # @return [Integer] Returns DSP host buffer pointer.
    #
    # @raise [RunTimeError] If the firmware id could not be recognized or
    #                       firmware's attributes cannot be found in memory.
    #
    ###########################################################################
    def get_host_buffer_ptr( firmware_id )

        # Getting DSP Host buffer pointer from DSP data buffer struct

        if ( 'FIRMWARE_FLORIDA_EZ2CONTROL' == firmware_id ||
             'FIRMWARE_CLEARWATER_MCDEBUG' == firmware_id )
            dsp_host_ptr_name = "#{firmware_id}_DSP_HOST_BUFFER"
        elsif ( 'FIRMWARE_CLWR_EZ2CONTROL' == firmware_id )
            dsp_host_ptr_name = "#{firmware_id}_COMPRESSION_BUF_HDR_DSP_HOST_BUFFER"
        elsif ( 'FIRMWARE_CLWR_EZ2CONTROL30' == firmware_id )
            dsp_host_ptr_name = "#{firmware_id}_COMPRESSION_BUF_HDR_*HOST_BUF"
        else
            raise 'Firmware id could not be recognized'
        end

        dsp_host_ptr = @device.read_element_value( dsp_host_ptr_name )
        if dsp_host_ptr.nil?
            raise "#{dsp_host_ptr_name} not found."
        end

        return dsp_host_ptr.hex
    end

    ###########################################################################
    #
    # @function initialize_host_buffer_struct
    #
    # Initializes XM or YM memory addresses and reads dsp host buffer structure
    # elements.
    #
    # @param [String] firmware_id Firmware ID that fetched from the firmware
    #                  data.
    #
    # @param [Integer] dsp_core_index DSP core index value.
    #
    # @return [none] Returns none.
    #
    ###########################################################################
    def initialize_host_buffer_struct( firmware_id, dsp_core_index )

        # Initializing variables
        @xm_base = DSPDataMemoryBaseAddresses["DSP#{dsp_core_index + 1}_XM"]
        @ym_base = DSPDataMemoryBaseAddresses["DSP#{dsp_core_index + 1}_YM"]

        @dsp_host_buffer_offset = get_host_buffer_ptr( firmware_id )

        # Reading required fields from the dsp host buffer struct of XM memory

        # Getting first host buffer address X buf base from dsp host buffer struct, where data stores
        x_buf_base_offset = get_memory_value( @xm_base, @dsp_host_buffer_offset + X_BUF_BASE_OFFSET_FROM_HOST_BUFFER )
        @data_read_address = @xm_base + (x_buf_base_offset * REGISTER_COUNT_PER_DSP_FIELD)

        # Getting first host buffer size X buf size from dsp host buffer struct
        @x_buf_size = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + X_BUF_SIZE_OFFSET_FROM_HOST_BUFFER ) )

        # Getting second host buffer address X buf base 2 from dsp host buffer struct
        x_buf_base2_offset = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + X2_BUF_BASE_OFFSET_FROM_HOST_BUFFER ) )
        @data_read_address2 = @xm_base + (x_buf_base2_offset * REGISTER_COUNT_PER_DSP_FIELD)

        # Getting second host buffer size X buf brk from DSP host buffer struct (X + X2 buffer sizes)
        @x_buf_brk = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + X_BUF_BRK_SIZE_OFFSET_FROM_HOST_BUFFER ) )

        # Getting third buffer address Y buf base address from dsp host buffer struct
        y_buf_base_offset = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + Y_BUF_BASE_OFFSET_FROM_HOST_BUFFER ) )
        @data_read_address3 = @ym_base + (y_buf_base_offset * REGISTER_COUNT_PER_DSP_FIELD)

        # Getting third host buffer size wrap from dsp host buffer struct (X + X2 + Y buffer sizes)
        @wrap = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + WRAP_OFFSET_FROM_HOST_BUFFER ) )

        # Getting high_water_mark from dsp host buffer struct
        @high_water_mark = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + HIGH_WATERMARK_OFFSET_FROM_HOST_BUFFER ) )

        # Getting irq_count from dsp host buffer struct
        @irq_count = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + IRQ_COUNT_OFFSET_FROM_HOST_BUFFER ) )

        # Getting irq_ack from DSP host buffer struct
        @irq_ack = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + IRQ_ACK_OFFSET_FROM_HOST_BUFFER ) )

        @next_read_index_addr = @xm_base + ( ( @dsp_host_buffer_offset + READ_INDEX_OFFSET_FROM_HOST_BUFFER ) * REGISTER_COUNT_PER_DSP_FIELD )
    end

    ###########################################################################
    #
    # @function get_available_data
    #
    # Reads current read index and write index values from the DSP host buffer
    # struct, then calculates and returns available data in the dsp buffer or
    # any buffer stream error.
    #
    # @return [Integer] Returns DATA_READ_ERROR when data is not available to
    #                   read, BUFFER_STREAM_ERROR on buffer stream errors,
    #                   otherwise returns SUCCESS.
    #
    ###########################################################################
    def get_available_data

        return_value = SUCCESS   # Return value by default making it to SUCCESS
        if( @playback_status == false )
            # Getting Write Index from dsp host buffer struct
            current_write_index = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + WRITE_INDEX_OFFSET_FROM_HOST_BUFFER ) )
            @write_index = convert_to_24bit_signed( current_write_index )

            # Don't empty the buffer as it kills the firmware
            @write_index = @write_index - 1
        end
        @playback_status = @device.playback_completed?

        # Getting Read Index from dsp host buffer struct
        current_read_index = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + READ_INDEX_OFFSET_FROM_HOST_BUFFER ) )
        @read_index = convert_to_24bit_signed( current_read_index )

        # Getting Error from dsp host buffer struct
        @error = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + ERROR_OFFSET_FROM_HOST_BUFFER ) )
        if( ( @error > 0 ) && ( @buffer_overflow_flag == 0 ) )
            $LOG.info 'Buffer Overflow Occurred...'
            @buffer_overflow_flag = 1
        end

        if( @read_index < 0 )
            $LOG.info '[Buffer Test] Stream has not yet started...'
            return_value = BUFFER_STREAM_ERROR      # Stream has not yet started
        elsif( @read_index < @x_buf_size )
            num_words = @x_buf_size - @read_index
            @read_ptr = @data_read_address
            index = @read_index
        elsif( @read_index < @x_buf_brk )
            num_words = @x_buf_brk - @read_index
            @read_ptr = @data_read_address2
            index = @read_index - @x_buf_size
        elsif( @read_index < @wrap )
            num_words = @wrap - @read_index
            @read_ptr = @data_read_address3
            index = @read_index - @x_buf_brk
        else
            $LOG.info '[Buffer Test] Read Index is too high!'
            return_value = BUFFER_STREAM_ERROR
        end

        if( SUCCESS == return_value )
            # Update memory read pointer to the read index offset
            @read_ptr += ( index * REGISTER_COUNT_PER_DSP_FIELD )

            @data_available = @write_index - @read_index
            if( @data_available < 0 )
                @data_available = @data_available + @wrap
            end

            if( @data_available < num_words )
                num_words = @data_available
            end

            if( num_words >= MAX_READ_SIZE )
                num_words = MAX_READ_SIZE
            end

            @number_of_bytes = num_words * BYTES_PER_WORD
            if( @number_of_bytes == 0 )
                return_value = DATA_READ_ERROR
            end
        end

        return return_value
    end

    ###########################################################################
    #
    # @function update_read_index
    #
    # Calculates next read index from the current read index and number of bytes
    # read and writes next read index value to dsp host buffer struct address.
    #
    # @return [none] Returns none.
    #
    ###########################################################################
    def update_read_index
        # Updating read index to number of words read from memory
        next_read_index = @read_index + ( ( @number_of_bytes - ( @number_of_bytes % BYTES_PER_WORD ) ) / BYTES_PER_WORD )

        # If read index has reached the buffer end, again making read index to zero
        if( next_read_index == @wrap )
            next_read_index = 0
        end

        if( next_read_index > @wrap )
            next_read_index = 0 + ( next_read_index - @wrap )
        end
        set_memory_value( @next_read_index_addr, next_read_index )
        @read_index = next_read_index
    end

    ###########################################################################
    #
    # @function read_host_buffer_data
    #
    # Reads the host buffer data and outputs it into a file.
    #
    # @note Currently this method performs the host buffer read and reads the
    #       compressed DSP buffer data and decompresses the read compressed DSP
    #       buffer data and writes in to a 'decompressed.wav' file. It stops
    #       reading the host buffer data when playback is completed and
    #       terminates buffer streaming after reading available data in the
    #       output buffer.
    #
    # @param [String] firmware_id Firmware ID that fetched from the firmware
    #                             data.
    # @param [String] out_filename File name in to which decompressed data is
    #                              to be stored.
    #
    # @return [Integer] Returns read buffer status either success or failure.
    #
    # @return [Float] Returns time taken for the host to empty the active full
    #                 buffer.
    #
    # @raise [RunTimeError] If the firmware id could not be recognized or
    #                       firmware's attributes cannot be found in memory.
    #
    ###########################################################################
    def read_host_buffer_data( firmware_id, out_filename )

        $LOG.info '[Buffer Test] Buffer Streaming Started..'
        ########################### Buffer Reading ############################
        return_value = SUCCESS       # Return value by default making it to 0
        num_bytes = 0                # Used in writing a linear output buffer
        total_read = 0               # Total data read from the memory in words
        buffer = []                  # Linear output buffer
        @playback_status = false     # Assuming playback is happening
        @buffer_overflow_flag = 0    # Buffer overflow conditional flag
        time_taken = 0               # Time taken to read the full buffer
        start_time = Time.now        # Start time before the start of buffer read

        # Loop to rotate, until there is data available to read from the DSP
        # buffer and checks if there are any read errors
        begin
            # Gets available data to read from dsp buffer
            return_value = get_available_data()
            if( SUCCESS != return_value )
                break
            end

            read_from_device = true  # This makes read_block_data to read data
                                     # from the device and not from the cache.
            ret_bytes = @device.read_block_data( @read_ptr,
                                                 @number_of_bytes,
                                                 read_from_device
                                               )
            unless ret_bytes.size.nil?
                ret_size = ( ret_bytes.size / BYTES_PER_WORD )
            else
                return_value = DATA_READ_ERROR
                $LOG.info '[Buffer Test] Data read out error...'
                break
            end

            ret_size.times do | j |
                element = j * BYTES_PER_WORD
                buffer[num_bytes] = ret_bytes[element + 3]
                buffer[num_bytes + 1] = ret_bytes[element + 2]
                buffer[num_bytes + 2] = ret_bytes[element + 1]
                num_bytes += BYTES_PER_ADSP_WORD
            end

            #Updates read index value with the number of words read
            update_read_index()

            total_read += ret_size
        end while( return_value > DATA_READ_ERROR )

        end_time = Time.now
        time_taken_to_read = end_time - start_time

        # Actual data read from the memory is 3 bytes(24-bits) from the word.
        # And the total read bytes from the DSP buffer is multiplied by 3.
        $LOG.debug "[Buffer Test] Total Read in Bytes: #{total_read * BYTES_PER_ADSP_WORD}"

        if( return_value < DATA_READ_ERROR )
            return_value = DATA_READ_ERROR
        else
            return_value = SUCCESS
        end

        # Writes buffer data to file
        file_name = 'compressed.raw'
        write_buffer_data( buffer, file_name )

        # Decompresses the read compressed DSP buffer data file.
        # Getting DSP Host buffer pointer from DSP data buffer struct

        if ( ( 'FIRMWARE_FLORIDA_EZ2CONTROL' == firmware_id ) ||
             ( 'FIRMWARE_CLWR_EZ2CONTROL' == firmware_id )
           )
            channels = Channels['SCC25']
            if channels.nil?
                channels = 1
            end
        elsif ( 'FIRMWARE_CLWR_EZ2CONTROL30' == firmware_id )
            channels = Channels['SCC30']

            if channels.nil?
                channels = 2
            end
        elsif ( 'FIRMWARE_CLEARWATER_MCDEBUG' == firmware_id )
            channels = Channels['Trace']
            if channels.nil?
                channels = 2
            end
        else
            raise 'Firmware id could not be recognized'
        end

        NativeDecompress::do_decompress( file_name,
                                         out_filename,
                                         SampleRate,
                                         Bitdepth,
                                         channels
                                       )

        $LOG.debug '[Buffer Test] Buffer Streaming Completed..'  # End of Buffer Test
        return return_value, time_taken_to_read
    end

    ###########################################################################
    #
    # @function get_read_index
    #
    # Gets read index from dsp host buffer struct.
    #
    # @return [int] Returns read_index.
    #
    ###########################################################################
    def get_read_index
        # Getting Read Index from dsp host buffer struct
        current_read_index = get_memory_value( @xm_base, ( @dsp_host_buffer_offset + READ_INDEX_OFFSET_FROM_HOST_BUFFER ) )
        @read_index = convert_to_24bit_signed( current_read_index )
    end
end

################################# END OF FILE #################################