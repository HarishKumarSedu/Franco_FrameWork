###############################################################################
###
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   simulated_noise.rb
### @brief  Adds simulated noise to playback tracks.
###
### @version \$Id: simulated_noise.rb 1038 2015-05-12 10:04:28Z emmas $
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

#
# Requires
#
require 'configuration'
require 'tone_generator'
require 'wavefile_analyzer'
require 'wavefile'
require 'fruitsalad_utils'
require 'logfw'

###############################################################################
#
# Component transforms input audio tracks and adds simulated background noise
# once noise_db has been set to a non-nil value.
#
###############################################################################
class SimulatedNoiseModel

    # Buffer size to use for reading input file. Power of 2 chosen arbitrarily.
    BufferSize = 2**12
    MLSRegisters = 20

    private
    include ToneGenerator
    include WavefileAnalyzer
    public
    ###########################################################################
    #
    # Controls the amplitude of the simulated noise. Has units dB FS, with 0 as
    # the maximum. Above this level the noise will clip. Also switches the
    # component off if this and noise_snr are set to nil, which are the defaults
    # after instantiation. This attribute is over-ruled by noise_snr.
    #
    ###########################################################################
    attr_accessor :noise_db

    ###########################################################################
    #
    # Alternative way to control the simulated noise's amplitude by setting the
    # SNR relative to the signal track. Provided noise_db is non-nil it will
    # set the noise amplitude automatically. Switches this component off if both
    # this and noise_db are set to nil, which are the defaults after instantiation.
    #
    # Is specified in logarithmic units (dB).
    #
    ###########################################################################
    attr_accessor :noise_snr

    ###########################################################################
    #
    # If set, this file name will be used to provide the noise track. If nil,
    # then an MLS generator will be used instead.
    #
    ###########################################################################
    attr_accessor :noise_track

    ###########################################################################
    #
    # The name of the noise environment. If set, it will be used to build the
    # full path to any noise_track specified.
    #
    ###########################################################################
    attr_accessor :noise_environment

    ###########################################################################
    #
    # The path of the resources directory within which to search for noise
    # environments. Defaults to %FRUITSALAD_HOME%/resources but can be overridden
    # to use noise files from the current working directory or other location.
    #
    # Overwritten with the NoiseEnvironmentRoot config key.
    #
    ###########################################################################
    attr_accessor :noise_environment_root

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor
    #
    # (no parameters)
    #
    ###########################################################################
    def initialize
        @noise_db = nil # No noise, by default.
        @noise_snr = nil # Do not automatically set noise_db

        @noise_environment_root = Conf::property( # correct indentation crashes
            :NoiseEnvironmentRoot,                # my text editor.
            File.join(
                ENV['FRUITSALAD_HOME'].to_s,
                'resources'
            )
        )
    end

    ###########################################################################
    #
    # @function get_noise_path
    #
    # Using noise_track, it will search the current noise_environment
    # and return that track name from any channel.
    #
    # If noise_environment is not set then it is assumed that the noise_track is
    # itself a relative path already and no operation is performed.
    #
    # @param [Fixnum] noise_channel The noise channel to use. Defaults to 1.
    #
    # @return [String] The full, qualified path inside %FRUITSALAD_HOME% or the
    #                  identity mapping if noise_environment is not set.
    #
    ###########################################################################
    def get_noise_path( noise_channel=1 )
        full_path = @noise_track
        unless @noise_environment.nil?
            $LOG.debug "Using noise environment files #{@noise_environment}."
            channel_names = Dir::glob( File.join( @noise_environment_root, @noise_environment, '*' ) )
            channel_names = channel_names.find_all { |a| File::directory?( a ) }
            if channel_names.nil?
                $LOG.info "No channel found."
            else
                noise_channel = channel_names.to_a[noise_channel-1]
                full_path = File.join( noise_channel, full_path )
            end
        end

        $LOG.debug "Using noise track #{full_path}"

        return full_path
    end

    ###########################################################################
    #
    # @function attenuate_noise
    #
    # Attenuate the rms average amplitude amplitude of a noise track to some
    # required level and return the noise track as an array of samples.
    #
    # @param [Numeric]        desired_rms   The desired rms average amplitude.
    # @param [Array<Numeric>] noise_samples The source noise to attenuate.
    #
    # @return [Array<Numeric>] A time-domain sequence of samples.
    #
    # @raise [RunTimeError] If the RMS amplitude of noise_samples measures 0.
    #
    ###########################################################################
    def attenuate_noise( desired_rms, noise_samples )
        base_rms = rms( noise_samples )
        raise "Source noise amplitude measured 0 (divide by zero)." if 0 == base_rms
        gain = desired_rms / base_rms

        noise_samples.map! { |x| gain * x }

        return noise_samples
    end

    ###########################################################################
    #
    # @function generate_noise_track
    #
    # Generate the noise track based on the current settings. Used when mixing
    # in the noise track using an outside library like OpenAL.
    #
    # @param [Numeric]  duration    If realistic noise is not being used, what
    #                               duration should the pseudorandom noise track
    #                               have. Given in units seconds
    # @param [Numeric]  sample_rate At what sample_rate should the returned
    #                               noise track be sampled at, given in units Hz
    # @param [Hash]     options     Optional keyword arguments
    #
    # @option [options] :signal_rms     The root-mean-square amplitude of the
    #                                   signal track, used to calculate the
    #                                   noise track rms value when noise_snr is set.
    # @option [options] :noise_channel  The noise channel to retrieve when using
    #                                   realistic noise recordings
    # @option [options] :noise_db       Overrides the value of noise_db instead
    #                                   of using the instance variable to set
    #                                   the desired amplitude
    #
    # @return [Array<Numeric>]  An array containing a single channel of audio
    #                           samples represented as floats on [-1,1]
    #
    ###########################################################################
    def generate_noise_track( duration, sample_rate, options={} )
        # Optional arguments
        signal_rms = options.fetch( :signal_rms, 0 )
        noise_channel = options.fetch( :noise_channel, 1 )
        noise_db = options.fetch( :noise_db, @noise_db )

        if @noise_track.nil?
            # Generate noise track
            noise = mls( MLSRegisters ).take( duration*sample_rate )
        else
            # Read in noise track
            noise = get_noise_path( noise_channel )
            noise = FruitSaladUtils::read_wavefile( noise, sample_rate )
            noise.flatten!
        end

        # Set noise amplitude(rms)
        if @noise_snr.nil?
            noise_rms = FruitSaladUtils::dBFS_to_f( noise_db )
        else
            noise_rms = FruitSaladUtils::noise_amplitude_from_snr( @noise_snr, signal_rms )
        end
        noise = attenuate_noise( noise_rms, noise )
        return noise
    end

    #######################################################################
    #
    # @function mix_in_noise
    #
    # Create a new WAV file by taking input WAV files and adding an MLS
    # White Noise sequece to them, simulating background noise. The amplitude
    # of the MLS sequence is set by writable attribute simulated_background_noise
    #
    # @note Does nothing if noise_db is nil
    #
    # @param [String] in_track The filename of the source WAV file to modify
    # @param [Hash]   options  Optional arguments
    #
    # @option options [Fixnum] :noise_channel The noise channel to mix into this
    #                                         in_track when using realistic noise.
    #
    # @return [String] The filename of the WAV file with noise added
    #
    # @raise [RunTimeError] If the RMS of the noise source is too small.
    #
    #######################################################################
    def mix_in_noise( in_track, options={} )
        if noise_db.nil? && noise_snr.nil? # Skip if noise is not set.
            return in_track
        end

        # Optional arguments
        noise_channel = options.fetch( :noise_channel, 1 )

        out_track = "#{File::dirname(in_track)}/noisy#{noise_channel}_#{File::basename(in_track)}"

        info = WaveFile::Reader.info( in_track )
        format = WaveFile::Format.new( info.channels, :float, info.sample_rate )

        # Read in input signal
        in_signal = FruitSaladUtils::read_wavefile( in_track, info.sample_rate )

        in_track_length = info.sample_frame_count / info.sample_rate
        signal_rms = rms( in_signal.flatten )
        noise = generate_noise_track(
                                     in_track_length,
                                     info.sample_rate,
                                     signal_rms: signal_rms,
                                     noise_channel: noise_channel
                                    )

        # Mix
        out_signal = in_signal.zip noise
        if out_signal.find_all{ |_,noise_sample| noise_sample.nil? }.size > 0
            $LOG.info "Warning, noise track not long enough."
            $LOG.debug "Samples: signal #{in_signal.size}, noise #{noise.size}"
        end
        out_signal = out_signal.map do |channels, noise_sample|
            channels.map do |sample|
                sample + noise_sample.to_f # WaveFile is smart enough to clip for us.
            end
        end

        WaveFile::Writer.new( out_track, format ) do |writer|
            buffer = WaveFile::Buffer.new( out_signal, format )
            writer.write buffer
        end


        return out_track
    end

end

################################## END OF FILE ################################