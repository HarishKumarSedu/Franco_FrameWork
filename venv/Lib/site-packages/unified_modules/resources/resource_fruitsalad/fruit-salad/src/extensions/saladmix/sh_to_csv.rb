#!/usr/bin/ruby
# encoding: utf-8
###############################################################################
###
### Copyright (c) 2014 Wolfson Microelectronics plc.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Wolfson Microelectronics plc. Wolfson Microelectronics plc
### assumes no responsibility or liability for any errors or inaccuracies that
### may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Wolfson Microelectronics plc.
###
### @file   sh_to_csv.rb
### @brief  Converts old .sh usecase scripts to new CSV key-value dictionary.
###
### @version \$Id: sh_to_csv.rb 258 2014-10-17 10:04:04Z emmas $
###
### Warning
###   This software is specifically written for Wolfson devices. It may not be
###   used with other devices.
###
###############################################################################

require 'logfw'

###############################################################################
#
# Join sections of text encapsulated between '"' marks, so as to escape space
# characters in the sequence.
#
# @param [Array] tokens The list of space-seperated tokens comprising this line.
#
# @return [String] The joined sequence encapsulated between '"' characters.
#
###############################################################################
def join_string( tokens )
    field = ""
    (0..tokens.length-1).each do |i|
        if /.*\"$/ =~ tokens[i]
            field = tokens.slice!( 0, i+1 )
            field = field.join( " " )
            return field
        end
    end
    raise( "Mismatched quotes" )
end

###############################################################################
#
# Split a command into an array of tokens that can be written to the CSV file.
#
# @param [String] line The source line of the SH file.
#
# @return [Array] The corresponding CSV tokens.
#
###############################################################################
def tokenize( line )
    tokens = line.split
    row = []
    while tokens.length > 0
        field = tokens[0]
        if /^\".*/ =~ field
            field = join_string( tokens )
            row << field
        else
            row << tokens.delete_at( 0 )
        end
    end
    row
end

###############################################################################
#
# New line characters escaped with a '\' allow a SH command to extend across
# multiple lines for human-readability. Join lines ending with '\' to the next
# line recursively before proceeding.
#
# @param [String] line  The current line of text.
# @param [String] lines The remaining lines in the source SH file.
#
# @return [String] The final line with escaped new-line sequences removed.
#
###############################################################################
def escaped_lines( line, lines )
    if /\\$/ =~ line
        line = line.chomp( '\\' )
        line += lines.delete_at( 0 ).chomp
        line = escaped_lines( line, lines )
    end
    line
end

###############################################################################
#
# Parse a named SH usecase file and generate a corresponding saladmix CSV file.
#
# @param [String] in_filename The name of the source SH usecase file.
#
###############################################################################
def parse_file( in_filename )
    in_file = File.open( in_filename, 'r' )

    out_filename = in_filename.chomp( File.extname( in_filename ) )
    out_filename += ".csv"

    out_file = File.open( out_filename, 'w' )

    lines = in_file.readlines
    total_lines = lines.length
    while lines.length > 0 do
        line = lines.delete_at( 0 ).chomp
        line_number = total_lines - lines.length

        if /#!/ =~ line
            next
        end

        if "#" == line[0]
            out_file << line << "\n"
            next
        end

        unless /^\$CMD/ =~ line
            next
        end

        line = escaped_lines( line, lines )

        row = tokenize( line )
        row.delete_at( 0 )

        $LOG.debug "#{line_number}: #{row.join( "," )}"
        out_file << row.join( "," ) << "\n"

    end
end

###############################################################################
#
# Entry-point. Automatically parse every .sh file it can find below this
# directory level and generate a saladmix CSV file for it.
#
###############################################################################
if __FILE__ == $0
    files = Dir::glob( "./**/*.sh" )
    files.each do |file|
        $LOG.debug "Parsing file: #{file}"
        parse_file( file )
    end
end

#################################### END OF FILE ##############################