////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
//
// This software as well as any related documentation is furnished under 
// license and may only be used or copied in accordance with the terms of the 
// license. The information in this file is furnished for informational use 
// only, is subject to change without notice, and should not be construed as 
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document. 
//
// Except as permitted by such license, no part of this document may be 
// reproduced, stored in a retrieval system, or transmitted in any form or by 
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies. 
//
/// @file   saladmix.c
/// @brief  Bulk-writes libtinyalsa controls from a CSV file.
///
/// @version \$Id: saladmix.c 775 2015-01-27 14:29:59Z piotrs $
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//
#include "stdlib.h"
#include "stdio.h"
#include "string.h"

#include "saladmix.h"

#include "tinyalsa/asoundlib.h"

//
// Globals
//
char *binaryName = NULL;
struct mixer *pMixer = NULL;

//
// Function definitions
//

///////////////////////////////////////////////////////////////////////////////
///
// Function: RowDelete
///
/// @brief Free the memory associated with a Row object.
///
/// @param row The Row object to delete.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void RowDelete( struct Row *row )
{
    if ( row->key )
    {
        free( row->key );
    }
    if (row->values )
    {
        ValuesDelete( row->values );
    }
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: ValuesArray
///
/// @brief Convert our Values linked list into an array of integers or chars.
///
/// @param listhead Pointer to the first element of the values list.
/// @param elements The number of elements in the list: can be obtained using
///                 ValuesLength.
/// @param ctlType  Type of mixer control this array is to be written to.
///
/// @return An array allocated on the heap.
///
///////////////////////////////////////////////////////////////////////////////
void* ValuesArray( struct Values *listhead, unsigned int elements, int ctlType ) 
{
    void *array;
    if ( MIXER_CTL_TYPE_BYTE == ctlType )
        array = calloc( elements, sizeof( char ) );
    else
        array = calloc( elements, sizeof( long ) );

    struct Values *pointer = listhead;
    int position = 0;
    while ( pointer ) 
    {
        if ( !pointer->head ) 
        {
            pointer = pointer->next;
            continue;
        }
        long n = strtol ( pointer->head, NULL, 0 );

        if ( MIXER_CTL_TYPE_BYTE == ctlType )
            ((char*) array)[position] = n;
        else
            ((long*) array)[position] = n;

        pointer = pointer->next;
        ++position;
    }
    return array;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: ValuesAppend
///
/// @brief Append a given string to the first available slot in a Values linked 
///        list. 
///
/// @remark Implemented using recursion.
///
/// @param listhead Pointer to a Values node in the linked list.
/// @param string   The C-string to place in the linked list.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void ValuesAppend( struct Values *listhead, char *string ) 
{
    if ( !listhead->head ) 
    {
        // Copy string to the heap.
        char *copy = calloc( strlen( string ) + 1, sizeof( char ) );
        string = strcpy( copy, string );
        listhead->head = string;
    }
    else if ( listhead->next ) 
    {
        ValuesAppend( listhead->next, string );
    }
    else 
    {
        struct Values *node = calloc( 1, sizeof( struct Values ) );
        // Copy string to the heap.
        char *copy = calloc( strlen( string ) + 1, sizeof( char ) );
        string = strcpy( copy, string );
        node->head = string;
        listhead->next = node;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: CreateRow
///
/// @brief Parse a CSV row to the name of a tinyalsa control and its associated
///        Values.
///
/// @param csv    The row of CSV data as a single C-string.
///
/// @return A new Row struct containing the data from the CSV argument.
///
///////////////////////////////////////////////////////////////////////////////
struct Row *CreateRow( char *csv )
{
    char *token;
    struct Row *row = calloc( 1, sizeof( struct Row ) );
    row->values = calloc( 1, sizeof( struct Values ) );
    // Get key value.
    token = strtok( csv, "," );
    row->key = calloc( strlen( token ) + 1, sizeof( char ) );
    strcpy( row->key, token );

    // Get values.
    while ( ( token=strtok( NULL, "," ) ) != NULL ) 
    {
        ValuesAppend( row->values, token );
    }
    return row;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: ValuesDelete
///
/// @brief Deallocate a Values struct and all sub-nodes.
///
/// @param listhead Pointer to the first node in the linked list.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void ValuesDelete( struct Values *listhead ) 
{
    if ( listhead->next ) 
    {
        ValuesDelete( listhead->next );
    }
    if ( listhead->head ) 
    {
        free( listhead->head );
    }
    free( listhead );
    return;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: ValuesLength
///
/// @brief Calculate the length of a Values linked list using recursion.
///
/// @param listhead Pointer to the first node in the linked list.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
int ValuesLength( struct Values *listhead ) 
{
    if ( listhead->next ) 
    {
        return 1 + ValuesLength( listhead->next );
    }
    else 
    {
        return listhead->head ? 1: 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: ChopQuoteMarks
///
/// @brief Edits a string in place to remove '"' characters from the front and 
///        back of the string.
///
/// @param string The string to modify.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void ChopQuoteMarks( char *string ) 
{
    if ( '\"' == string[0] ) 
    {
        char *middle = strtok(string, "\"");
        strcpy( string, middle );
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: ValuesWrite
///
/// @brief Write a mixer control using its key and a list of values.
///
/// @param key     The string name of the control.
/// @param pValues The Values linked list containing the values to write.
///
///////////////////////////////////////////////////////////////////////////////
void ValuesWrite( char *key, struct Values *pValues ) 
{
    unsigned int elements = ValuesLength( pValues );

    // Chop off preceeding and trailing " marks from key.
    ChopQuoteMarks( key );

    struct mixer_ctl *ctl = mixer_get_ctl_by_name( pMixer, key );
    if ( ctl == NULL ) 
    {
        goto error;
    }
    enum mixer_ctl_type type = mixer_ctl_get_type( ctl );

    if ( type == MIXER_CTL_TYPE_ENUM && elements >= 1) 
    {
        ChopQuoteMarks( pValues->head );
        // Strip end of line characters.
        char *value = strtok( pValues->head, "\r\n" );
        if ( SUCCESS != mixer_ctl_set_enum_by_string( ctl, value ) )
            printf( "%s %s\n", "Error while writing control: ", key );
    }
    else if ( elements == 1 ) 
    {
        long value = strtol( pValues->head, NULL, 0 );
        int num_ctl_values = mixer_ctl_get_num_values(ctl);
        for ( int i = 0; i < num_ctl_values; ++i ) 
        {
            if ( SUCCESS != mixer_ctl_set_value( ctl, i, value ) )
                printf( "%s %s\n", "Error while writing control: ", key );
        }
    }
    else if ( elements > 1 ) 
    {
        long *array = ValuesArray( pValues, elements, type );
        if ( SUCCESS != mixer_ctl_set_array( ctl, array, elements ) )
            printf( "%s %s\n", "Error while writing control: ", key );
        free( array );
    }
    return;
error:
    printf( "Invalid control name: %s\n", key );
    exit( ERROR );
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: LoadUsecase
///
/// @brief Load a usecase from a CSV file.
///
/// @param cardIndex Index of the audio card to use.
/// @param filename  The path of the file to load from.
///
/// @return 0 on successful execution, or a non-zero integer if an error 
///         occured.
///
///////////////////////////////////////////////////////////////////////////////
int LoadUsecase( int cardIndex, char *filename ) 
{
    int error = SUCCESS;
    char row[MAX_LINE_LENGTH];
    char *key;
    struct Values *pValues;
    FILE *pFile = NULL;

    // Open mixer (once).
    pMixer = mixer_open( cardIndex ); 
    if ( !pMixer ) 
    {
        printf( "Could not open mixer\n" );
        error = ERROR;
        goto done;
    }

    pFile = fopen( filename, "r");
    if ( pFile == NULL ) 
    {
        printf( "Could not open %s.\n", filename);
        perror( NULL );
        error = ERROR;
        goto done;
    }

    // Process file by line.
    while ( !feof( pFile ) ) 
    {
        fgets( row, MAX_LINE_LENGTH, pFile );

        // Ignore lines beginning with '#'
        if ( '#' == row[0] ) 
        {
            continue;
        }
        struct Row *data = CreateRow( row );
        key = data->key;
        pValues = data->values;

        ValuesWrite( key, pValues );
        RowDelete( data );
    }
done:
    if ( pMixer ) 
    {
        mixer_close( pMixer );
    }
    if ( pFile ) 
    {
        fclose( pFile );
    }
    return error;

}

///////////////////////////////////////////////////////////////////////////////
///
// Function: PrintUsage
///
/// @brief Prints usage information to stdout.
///
/// (no parameters)
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void PrintUsage( void ) 
{
    printf( "Usage: %s [-D <card>] <CSV file>\n", binaryName );
}

#ifndef _TESTS
///////////////////////////////////////////////////////////////////////////////
/// 
// Function: main
///
/// @brief Entry-point into the saladmix program. Loads the usecase onto a
///        specified device.
///
/// @param argc The number of arguments passed to the program by the shell,
///             including the name of the binary itself.
/// @param argv An array of strings representing each argument passed by the
///             shell.
/// 
/// @return 0 on successful program execution, non-zero otherwise.
///
///////////////////////////////////////////////////////////////////////////////
int main( int argc, char **argv ) 
{
    int error_val = SUCCESS;
    int cardIndex = DEFAULT_CARD_INDEX;
    binaryName = argv[0];

    if ( argc < 2 ) 
    {
        PrintUsage();
        exit( ERROR );
    }
    if ( 0 == strcmp( "-h", argv[1] ) || 0 == strcmp( "--help", argv[1] ) ) 
    {
        PrintUsage();
        exit( ERROR );
    }
    if ( 0 == strcmp( "-D", argv[1] ) )
    {
        if ( 4 == argc )
        {
            cardIndex = atoi( argv[2] );
            argc -= 2;
            argv += 2;
        }
        else
        {
            PrintUsage();
            exit( ERROR );
        }
    }

    error_val = LoadUsecase( cardIndex, argv[1] );
    return error_val;
}
#endif
////////////////////////// END OF FILE ////////////////////////////////////////
