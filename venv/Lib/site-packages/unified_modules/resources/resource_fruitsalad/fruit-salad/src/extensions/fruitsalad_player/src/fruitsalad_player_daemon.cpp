////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 Cirrus Logic International (UK) Ltd.  All rights reserved.
//
// This software as well as any related documentation is furnished under 
// license and may only be used or copied in accordance with the terms of the 
// license. The information in this file is furnished for informational use 
// only, is subject to change without notice, and should not be construed as 
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document. 
//
// Except as permitted by such license, no part of this document may be 
// reproduced, stored in a retrieval system, or transmitted in any form or by 
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies. 
//
/// @file   fruitsalad_player_daemon.cpp
/// @brief  Basic player/recorder facility for FruitSalad.
///
/// @version \$Id: fruitsalad_player_daemon.cpp 558 2014-12-03 16:55:34Z aangus $
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Includes
///////////////////////////////////////////////////////////////////////////////

#include <cstdio>
#include <string>
#include <vector>
#include <zmq.hpp>

#include "fruitsalad_player_interface.h"
#include <portaudio_client_api.h>
#include <WinDriverTestAPI.h>

///////////////////////////////////////////////////////////////////////////////
/// Namespace aliases
///////////////////////////////////////////////////////////////////////////////

namespace fpi = fruitsalad_player_interface;

///////////////////////////////////////////////////////////////////////////////
/// Global variables
///////////////////////////////////////////////////////////////////////////////

HANDLE g_event = NULL;

///////////////////////////////////////////////////////////////////////////////
/// Function definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///
/// Function: ClientStateCallback
///
/// @brief Handles information about PortaudioClient state changes.
///
/// @param on          Indicates whether the state was "turned on" (true) or
///                    "turned off" (false).
/// @param clientState PortaudioClient state which has changed.
///
///////////////////////////////////////////////////////////////////////////////
void ClientStateCallback( bool on, PlayerState clientState )
{
    printf( "%s: %d %d\n", __FUNCTION__, on, clientState );
    if ( NULL != g_event && !on && PLAYBACK_READY == clientState )
    {
        SetEvent( g_event );
        CloseHandle( g_event );
    }
}

///////////////////////////////////////////////////////////////////////////////
///
/// Function: main
///
/// @brief Program entry point.
///
/// @return An error code or 0 on success.
///
///////////////////////////////////////////////////////////////////////////////
int main( int argc, const char **argv )
{
    (void) argc;
    (void) argv;

    bool running = TRUE;	
    int exitCode = 0;
	//
	// Flag setting whether the daemon should only send an exit code message 
	// or a more detailed request to the fruitsalad_player.
	//
	bool exitCodeOnlyMessage = true;

    // the 1 stands for the amount of threads zmq will use to handle IO
    zmq::context_t context( 1 );
    zmq::socket_t socket( context, ZMQ_REP );
    socket.bind( "tcp://*:5555" );

    // NOTE: this loop will run until a valid terminate message is received
    while( running )
    {
        zmq::message_t request;

        socket.recv( &request );
        std::string cmdStr = std::string( static_cast<char*>( request.data() ),
                                          request.size()
                                        );

        fpi::CommandType cmdType = fpi::ParseCommandType( cmdStr );

        printf( "%s: %s %d\n", __FUNCTION__, "received command: ", cmdType );

		std::string customMsg = "";

        fpi::SetUpArgs setUpArgs;
        fpi::FileArgs fileArgs;
		// majority of messages will only return an error code.
		exitCodeOnlyMessage = true;
        switch ( cmdType )
        {
            case fpi::HANDSHAKE:
                //
                // exit code does not matter in this case, as handshake is
                // meant only to determine if the daemon is running
                //
                exitCode = 0;
                break;
            case fpi::SET_UP:
                setUpArgs = fpi::ParseSetUpArguments( cmdStr );
                exitCode = SetUp( setUpArgs.playbackChannelCount,
                                  setUpArgs.recordingChannelCount,
                                  setUpArgs.sampleRate,
                                  setUpArgs.bufferSize,
                                  ClientStateCallback,
                                  NULL
                                );
                break;
            case fpi::TERMINATE:
                exitCode = Terminate();
                running = false;
                break;
            case fpi::PLAY:
                fileArgs = fpi::ParseFileArguments( cmdStr );
                exitCode = StartPlaybackFromFile( fileArgs.fileName.c_str() );
                
                if ( PA_CLIENT_SUCCESS == exitCode )
                {
                    g_event = CreateEvent( NULL, FALSE, FALSE, NULL );
                    WaitForSingleObject( g_event, INFINITE );
                }
                break;
            case fpi::RECORD:
                fileArgs = fpi::ParseFileArguments( cmdStr );
                exitCode = StartRecordingToFile( fileArgs.fileName.c_str() );
                break;
            case fpi::STOP_PLAYBACK:
                exitCode = StopPlayback();
                break;
            case fpi::STOP_RECORDING:
                exitCode = StopRecording();
                break;
			case fpi::CODEC_STATE:	
				// will need to send back a more complex message which
				// includes the codec state.
				exitCodeOnlyMessage = false;				
				// perform the operation
				PDEVICE_POWER_STATE aState = 0;				
				BOOL success = CodecDevicePowerState( aState );				
				customMsg = fpi::CreateCodecStateReturnMessage(success, (int) aState);								
                break;
        }

		if ( exitCodeOnlyMessage )
		{
	        std::string resMsg = fpi::CreateResultMessage( exitCode );			

			zmq::message_t reply( resMsg.size() );
			memcpy( (void*) reply.data(), resMsg.data(), resMsg.size() );
			socket.send( reply );
		}
		else
		{
			zmq::message_t reply( customMsg.size() );
			memcpy( (void*) reply.data(), customMsg.data(), customMsg.size() );
			socket.send( reply );
		}
    }

    g_event = NULL;

    return exitCode;
}
/////////////////////////////END OF FILE///////////////////////////////////////