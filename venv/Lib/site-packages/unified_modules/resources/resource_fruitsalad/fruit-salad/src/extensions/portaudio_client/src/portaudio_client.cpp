////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd. All rights reserved.
//
// This software as well as any related documentation is furnished under
// license and may only be used or copied in accordance with the terms of the
// license. The information in this file is furnished for informational use
// only, is subject to change without notice, and should not be construed as
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document.
//
// Except as permitted by such license, no part of this document may be
// reproduced, stored in a retrieval system, or transmitted in any form or by
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies.
//
/// @file   portaudio_client.cpp
/// @brief  Basic player/recorder facility for FruitSalad.
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
////////////////////////////////////////////////////////////////////////////////

//
// Defines
//

#ifndef _USE_MATH_DEFINES
#define _USE_MATH_DEFINES
#endif

//
// Include files
//

#include "portaudio_client.h"

#include <cmath>
#include <cstdlib>
#include <cstring>

//
// PortaudioClient method definitions
//

///////////////////////////////////////////////////////////////////////////////
///
//  Constructor: PortaudioClient
///
/// @brief constructor for class PortaudioClient.
///
/// Creates the mutexes for locking playback and record.
///
///////////////////////////////////////////////////////////////////////////////
PortaudioClient::PortaudioClient()
{
    // create two mutexes with default security, no owner, and unnamed.
    m_MutexRecordFile = CreateMutex( NULL, FALSE, NULL );
    m_MutexPlayBackFile = CreateMutex( NULL, FALSE, NULL );
}

///////////////////////////////////////////////////////////////////////////////
///
//  Destructor: PortaudioClient
///
/// @brief Destructor for class PortaudioClient.
///
/// Closes the mutex handles.
///
///////////////////////////////////////////////////////////////////////////////
PortaudioClient::~PortaudioClient()
{
    // Close the mutex handles.
    CloseHandle( m_MutexRecordFile );
    CloseHandle( m_MutexPlayBackFile );
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: GetClient
///
/// @brief Gets an instance of PortaudioClient.
///
/// (no parameters)
///
/// @remark If no instance of PortaudioClient exists yet - it gets created.
///
/// @return PortaudioClient instance.
///
///////////////////////////////////////////////////////////////////////////////
PortaudioClient& PortaudioClient::GetClient()
{
    static PortaudioClient client;
    return client;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: SetUp
///
/// @brief Initialize the PortaudioClient.
///
/// @note Initializes portaudio .
///
/// @param bufferSize                 The audio buffer size to be used for playback
///                                   and record (NOTE: setting a very small
///                                   buffer size will cause clicks, and setting
///                                   a very large buffer size will result in
///                                   latency).
/// @param stateTransitionCallback    Pointer to a function of stateCallbackType,
///                                   it is used to notify the outside world when
///                                   the clients internal state changes.
/// @param errorNotificationCallback  Pointer to a function of errorCallbackType,
///                                   it is used to notify the outside world of
///                                   errors.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::SetUp( int               bufferSize,
                                     stateCallbackType stateTransitionCallback,
                                     errorCallbackType errorNotificationCallback
                                   )
{
    PlayerStatus exitCode;
    int libExitCode;
    const PaHostApiInfo *defaultHostApiInfo;
    m_bufferSize = bufferSize;
    m_stateTransitionCallback = stateTransitionCallback;
    m_errorNotificationCallback = errorNotificationCallback;

    libExitCode = Pa_Initialize();
    PaHostApiIndex defaultHostApi = Pa_GetDefaultHostApi();
    defaultHostApiInfo = Pa_GetHostApiInfo( defaultHostApi );
    if ( paNoError != libExitCode )
    {
        NotifyError( PA_INITIALIZATION_ERROR, libExitCode );
        exitCode = PA_INITIALIZATION_ERROR;
    }
    else
    {
        if ( ( strcmp( "MME", defaultHostApiInfo->name ) ) &&
             ( strcmp( "Windows WASAPI" , defaultHostApiInfo->name ) ) )
        {
            exitCode = PA_INVALID_HOST_API_ERROR;
        }
        else
        {
            SetState( INITIALIZED );
            exitCode = PA_CLIENT_SUCCESS;
        }
    }
    return exitCode;
}

////////////////////////////////////////////////////////////////////////////////
///
//  Function: StartPlaybackFromFile
///
/// @brief opens the playback stream with the created instance.
///
/// @param playbackChannelCount  The number of channels to be used for playback.
/// @param samplingRate          The samplerate to be used for playback.
/// @param pPath                 A path to the file to be played back.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StartPlaybackFromFile( int        playbackChannelCount,
                                                     int        samplingRate,
                                                     const char *pPath
                                                   )
{
    PlayerStatus exitCode;

    m_playbackChannelCount = playbackChannelCount;
    m_sampleRatePlayback = samplingRate;
    exitCode = OpenPlaybackFile( pPath );
    if ( paNoError == exitCode )
    {
        exitCode = OpenStreamPlayback();
        if ( paNoError == exitCode )
        {
            exitCode = StartStreamPlayback();
            if ( paNoError == exitCode )
            {
                exitCode = PA_CLIENT_SUCCESS;
            }
            else
            {
                CloseStreamPlayback();
                ClosePlaybackFile();
                exitCode = PA_STREAM_START_ERROR;
            }
        }
        else
        {
            ClosePlaybackFile();
            exitCode = PA_STREAM_OPEN_ERROR;
        }
    }
    else
    {
        exitCode = PA_CLIENT_FILE_ERROR;
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: StartRecordingToFile
///
/// @brief Start recording to a file at a given location.
///
/// @param recordChannelCount    The number of channels to be used for recording.
/// @param samplingRate          The samplerate to be used for recording.
/// @param pPath                 A path where the recorded file is to be stored.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StartRecordingToFile( int        recordChannelCount,
                                                    int        samplingRate,
                                                    const char *pPath
                                                  )
{
    PlayerStatus exitCode;

    m_recordChannelCount = recordChannelCount;
    m_sampleRateRecord = samplingRate;
    exitCode = OpenRecordFile( pPath );
    if ( paNoError == exitCode )
    {
        exitCode = OpenStreamRecording();
        if ( paNoError == exitCode )
        {
            exitCode = StartStreamRecording();
            if ( paNoError == exitCode )
            {
                exitCode = PA_CLIENT_SUCCESS;
            }
            else
            {
                CloseStreamRecording();
                CloseRecordFile();
                exitCode = PA_STREAM_START_ERROR;
            }
        }
        else
        {
            CloseRecordFile();
            exitCode = PA_STREAM_OPEN_ERROR;
        }
    }
    else
    {
        exitCode = PA_CLIENT_FILE_ERROR;
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: Terminate
///
/// @brief Resets the internal state of PortaudioClient and terminates
///        portaudio.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::Terminate()
{
    PlayerStatus exitCode = PA_TERMINATION_ERROR;
    int libExitCode;
    m_playbackChannelCount = 0;
    m_recordChannelCount = 0;
    m_sampleRatePlayback = 0;
    m_sampleRateRecord = 0;
    m_bufferSize = 0;
    SetState( UNINITIALIZED );
    libExitCode = Pa_Terminate();
    if ( paNoError != libExitCode )
        NotifyError( PA_TERMINATION_ERROR, libExitCode );
    else
        exitCode = PA_CLIENT_SUCCESS;

    m_stateTransitionCallback = NULL;
    m_errorNotificationCallback = NULL;
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: GetPlaybackFile
///
/// @brief Gets a pointer to the current playback file.
///
/// (no parameters)
///
/// @return SNDFILE* Pointer to the current playback file or null.
///
///////////////////////////////////////////////////////////////////////////////
SNDFILE* PortaudioClient::GetPlaybackFile()
{
    return m_pPlaybackFile;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: GetRecodFile
///
/// @brief Gets a pointer to the current recording file.
///
/// (no parameters)
///
/// @return SNDFILE* Pointer to the current recording file or null.
///
///////////////////////////////////////////////////////////////////////////////
SNDFILE* PortaudioClient::GetRecordFile()
{
    return m_pRecordFile;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: GetPlaybackFileInfo
///
/// @brief Gets a reference to the current playback file info.
///
/// (no parameters)
///
/// @return SF_INFO Reference to the current playback file info.
///
///////////////////////////////////////////////////////////////////////////////
const SF_INFO & PortaudioClient::GetPlaybackFileInfo()
{
    return m_playbackFileInfo;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: GetRecordFileInfo
///
/// @brief Gets a reference to the current recording file info.
///
/// (no parameters)
///
/// @return SF_INFO Reference to the current recording file info.
///
///////////////////////////////////////////////////////////////////////////////
const SF_INFO& PortaudioClient::GetRecordFileInfo()
{
    return m_recordFileInfo;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: OpenPlaybackFile
///
/// @brief Opens a file to be played back.
///
/// @remark Sets client status to PLAYBACK_READY provided no file IO error
///         occurs.
///
/// @param pPath Path to a valid audio file.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::OpenPlaybackFile( const char *pPath )
{
    PlayerStatus exitCode = PA_CLIENT_FILE_ERROR;
    m_pPlaybackFile = sf_open( pPath, SFM_READ, &m_playbackFileInfo );
    if ( NULL != m_pPlaybackFile )
    {
        WaitForSingleObject( m_pPlaybackFile, INFINITE );
        SetState( PLAYBACK_READY );
        exitCode = PA_CLIENT_SUCCESS;
        ReleaseMutex( m_pPlaybackFile );
    }
    else
    {
        NotifyError( PA_CLIENT_FILE_ERROR, sf_error( m_pPlaybackFile ) );
    }

    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: OpenRecordFile
///
/// @brief Creates a file to be used when recording input.
///
/// @remark Sets client status to RECORD_READY provided no file IO error occurs.
///
/// @param pPath Path where the recorded file should be stored.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::OpenRecordFile( const char *pPath )
{
    PlayerStatus exitCode = PA_CLIENT_FILE_ERROR;
    m_recordFileInfo.format = SF_FORMAT_WAV | SF_FORMAT_PCM_16;
    m_recordFileInfo.channels = m_recordChannelCount;
    m_recordFileInfo.samplerate = m_sampleRateRecord;
    m_pRecordFile = sf_open( pPath, SFM_WRITE, &m_recordFileInfo );

    if ( NULL != m_pRecordFile )
    {
        WaitForSingleObject( m_MutexRecordFile, INFINITE );
        SetState( RECORD_READY );
        exitCode = PA_CLIENT_SUCCESS;
        ReleaseMutex( m_MutexRecordFile );
    }
    else
    {
        NotifyError( PA_CLIENT_FILE_ERROR, sf_error( m_pRecordFile ) );
    }

    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: ClosePlaybackFile
///
/// @brief Closes the playback file, and unsets PLAYBACK_READY status.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::ClosePlaybackFile()
{
    WaitForSingleObject( m_pPlaybackFile, INFINITE );
    PlayerStatus exitCode = PA_CLIENT_FILE_ERROR;
    int libExitCode;

    UnsetState( PLAYBACK_READY );
    libExitCode = sf_close( m_pPlaybackFile );
    if ( 0 == libExitCode )
        exitCode = PA_CLIENT_SUCCESS;
    m_pPlaybackFile = NULL;

    ReleaseMutex( m_pPlaybackFile );
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: CloseRecordFile
///
/// @brief Closes the recorded file, and unsets RECORD_READY status.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::CloseRecordFile()
{
    WaitForSingleObject( m_MutexRecordFile, INFINITE );
    PlayerStatus exitCode = PA_CLIENT_FILE_ERROR;
    int libExitCode;
    sf_write_sync( m_pRecordFile );
    libExitCode = sf_close( m_pRecordFile );
    if ( 0 == libExitCode )
        exitCode = PA_CLIENT_SUCCESS;
    UnsetState( RECORD_READY );
    m_pRecordFile = NULL;

    ReleaseMutex( m_MutexRecordFile );
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: OpenStreamPlayback
///
/// @brief Opens a portaudio stream to by used by the client for playback.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::OpenStreamPlayback()
{
    PlayerStatus exitCode;
    PaStreamParameters outputParameters;
    outputParameters.device = Pa_GetDefaultOutputDevice();
    if ( paNoDevice == outputParameters.device )
    {
        exitCode = PA_STREAM_OPEN_ERROR;
    }
    else
    {
        exitCode = OpenStreamSafePlayback( outputParameters );
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: OpenStreamRecording
///
/// @brief Opens a portaudio stream to by used by the client for recording.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::OpenStreamRecording()
{
    PlayerStatus exitCode;
    PaStreamParameters inputParameters;
    inputParameters.device = Pa_GetDefaultInputDevice();
    if ( paNoDevice == inputParameters.device )
    {
        exitCode = PA_STREAM_OPEN_ERROR;
    }
    else
    {
        exitCode = OpenStreamSafeRecording( inputParameters );
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: OpenStreamSafePlayback
///
/// @brief A helper method for OpenStream.
///
/// @note This method assumes that an output enabled audio device exists and that
///       a handle to it has been supplied in the structures passed in to the
///       method.
///
/// @param outputParameters A structure storing output stream parameters.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::OpenStreamSafePlayback( PaStreamParameters &outputParameters )
{
    PlayerStatus exitCode;
    int libExitCode;
    outputParameters.channelCount = m_playbackChannelCount;
    outputParameters.sampleFormat = paFloat32;
    outputParameters.suggestedLatency =
        Pa_GetDeviceInfo( outputParameters.device )->defaultLowOutputLatency;
    outputParameters.hostApiSpecificStreamInfo = NULL;

    exitCode = IsPlaybackSupported( outputParameters );

    if ( exitCode == PA_CLIENT_SUCCESS )
    {
        libExitCode = Pa_OpenStream( &m_pStreamPlayback,
                                     0,
                                     &outputParameters,
                                     m_sampleRatePlayback,
                                     m_bufferSize,
                                     paClipOff,
                                     ProcessPlayback,
                                     ( void* ) this
                                   );
        if ( paNoError != libExitCode )
        {
            exitCode = PA_STREAM_OPEN_ERROR;
            NotifyError( PA_STREAM_OPEN_ERROR, libExitCode );
        }
        else
        {
            exitCode = PA_CLIENT_SUCCESS;
        }

    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: OpenStreamSafeRecording
///
/// @brief A helper method for OpenStream.
///
/// @note This method assumes that an input enabled audio device exists and that
///       a handle to it has been supplied in the structures passed in to the
///       method.
///
/// @param inputParameters  A structure storing input stream parameters.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::OpenStreamSafeRecording( PaStreamParameters &inputParameters )
{
    PlayerStatus exitCode;
    int libExitCode;

    inputParameters.channelCount = m_recordChannelCount;
    inputParameters.sampleFormat = paFloat32;
    inputParameters.suggestedLatency =
        Pa_GetDeviceInfo( inputParameters.device )->defaultLowOutputLatency;
    inputParameters.hostApiSpecificStreamInfo = NULL;

    exitCode = IsRecordingSupported( inputParameters );
    if ( exitCode == PA_CLIENT_SUCCESS )
    {
        libExitCode = Pa_OpenStream( &m_pStreamRecording,
                                     &inputParameters,
                                     0,
                                     m_sampleRateRecord,
                                     m_bufferSize,
                                     paClipOff,
                                     ProcessRecording,
                                     (void*) this
                                   );
        if ( paNoError != libExitCode )
        {
            exitCode = PA_STREAM_OPEN_ERROR;
            NotifyError( PA_STREAM_OPEN_ERROR, libExitCode );
        }
        else
        {
            exitCode = PA_CLIENT_SUCCESS;
        }
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: CloseStreamPlayback
///
/// @brief Closes a portaudio stream used by the client.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::CloseStreamPlayback()
{
    PlayerStatus exitCode = PA_STREAM_CLOSE_ERROR;
    int libExitCode = Pa_CloseStream( m_pStreamPlayback );

    if ( paNoError != libExitCode )
        NotifyError( PA_STREAM_CLOSE_ERROR, libExitCode );
    else
        exitCode = PA_CLIENT_SUCCESS;
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: CloseStreamRecording
///
/// @brief Closes a portaudio stream used by the client.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::CloseStreamRecording()
{
    PlayerStatus exitCode = PA_STREAM_CLOSE_ERROR;
    int libExitCode = Pa_CloseStream( m_pStreamRecording );

    if ( paNoError != libExitCode )
        NotifyError( PA_STREAM_CLOSE_ERROR, libExitCode );
    else
        exitCode = PA_CLIENT_SUCCESS;
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: StartStreamPlayback
///
/// @brief Starts a portaudio stream used by the client for playback
///        and sets status to PLAYING.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StartStreamPlayback()
{
    PlayerStatus exitCode = PA_STREAM_START_ERROR;
    int libExitCode = Pa_StartStream( m_pStreamPlayback );

    if ( paNoError != libExitCode )
        NotifyError( PA_STREAM_START_ERROR, libExitCode );
    else
        SetState( PLAYING );
        exitCode = PA_CLIENT_SUCCESS;
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: StartStreamRecording
///
/// @brief Starts a portaudio stream used by the client used for recording
///        and sets the status to RECORDING.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StartStreamRecording()
{
    PlayerStatus exitCode = PA_STREAM_START_ERROR;
    int libExitCode = Pa_StartStream( m_pStreamRecording );

    if ( paNoError != libExitCode )
        NotifyError( PA_STREAM_START_ERROR, libExitCode );
    else
        SetState( RECORDING );
        exitCode = PA_CLIENT_SUCCESS;
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: StopStreamPlayback
///
/// @brief Stops a portaudio stream used by the client for playback 
///        and unset the PLAYING status.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StopStreamPlayback()
{
    PlayerStatus exitCode = PA_STREAM_STOP_ERROR;
    int libExitCode = Pa_StopStream( m_pStreamPlayback );

    if ( paNoError != libExitCode )
        NotifyError( PA_STREAM_STOP_ERROR, libExitCode );
    else
        if ( IsClientState( PLAYING ) )
            UnsetState( PLAYING );
        exitCode = PA_CLIENT_SUCCESS;
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: StopStreamRecording
///
/// @brief Stops a portaudio stream used by the client used for recording and
///        and unset the RECORDING status.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StopStreamRecording()
{
    PlayerStatus exitCode = PA_STREAM_STOP_ERROR;
    int libExitCode = Pa_StopStream( m_pStreamRecording );

    if ( paNoError != libExitCode )
        NotifyError( PA_STREAM_STOP_ERROR, libExitCode );
    else
        if ( IsClientState( RECORDING ) )
            UnsetState( RECORDING );
        exitCode = PA_CLIENT_SUCCESS;
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: StopPlayback
///
/// @brief Stops and closes the playback stream used by the client.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StopPlayback()
{
    PlayerStatus exitCode;
    exitCode = StopStreamPlayback();
    if ( paNoError == exitCode )
    {
        exitCode = CloseStreamPlayback();
        if ( paNoError == exitCode )
        {
            exitCode = ClosePlaybackFile();
            if ( paNoError == exitCode )
            {
                exitCode = PA_CLIENT_SUCCESS;
            }
            else
            {
                exitCode = PA_CLIENT_FILE_ERROR;
            }
        }
        else
        {
            exitCode = PA_STREAM_CLOSE_ERROR;
        }
    }
    else
    {
        exitCode = PA_STREAM_STOP_ERROR;
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: StopRecording
///
/// @brief Stops and closes the recording stream used by the client.
///
/// (no parameters)
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::StopRecording()
{
    PlayerStatus exitCode;
    exitCode = StopStreamRecording();
    if ( paNoError == exitCode )
    {
        exitCode = CloseStreamRecording();
        if ( paNoError == exitCode )
        {
            exitCode = CloseRecordFile();
            if ( paNoError == exitCode )
            {
                exitCode = PA_CLIENT_SUCCESS;
            }
            else
            {
                exitCode = PA_CLIENT_FILE_ERROR;
            }
        }
        else
        {
            exitCode = PA_STREAM_CLOSE_ERROR;
        }
    }
    else
    {
        exitCode = PA_STREAM_STOP_ERROR;
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: IsClientState
///
/// @brief Checks if the client is in a given state.
///
/// @param clientState A state value to check.
///
/// @return True if the client is in the given state, false otherwise.
///
///////////////////////////////////////////////////////////////////////////////
bool PortaudioClient::IsClientState( const PlayerState clientState )
{
    bool isClientState;
    if ( UNINITIALIZED == clientState )
        isClientState = clientState == m_clientState;
    else
        isClientState = clientState == ( clientState & m_clientState );
    return isClientState;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: SetState
///
/// @brief Sets a client state.
///
/// @note Note that the client may be in multiple states at a given time
///       (only the UNINITIALIZED state is exclusive).
///
/// @param clientState State to set.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void PortaudioClient::SetState( const PlayerState clientState )
{
    int prevClientState = m_clientState;
    if ( UNINITIALIZED == clientState )
        m_clientState = clientState;
    else
        m_clientState = m_clientState | clientState;

    if ( NULL!=m_stateTransitionCallback && prevClientState != m_clientState )
        m_stateTransitionCallback( true, clientState );
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: UnsetState
///
/// @brief Unsets a client state.
///
/// @note Note that the client may be in multiple states at a given time
///       (only the UNINITIALIZED state is exclusive).
///
/// @param clientState State to unset.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void PortaudioClient::UnsetState( const PlayerState clientState )
{
    int prevClientState = m_clientState;
    if ( INITIALIZED == clientState )
        m_clientState = UNINITIALIZED;
    else
        m_clientState = m_clientState & ( ~clientState );
    if ( NULL != m_stateTransitionCallback && prevClientState != m_clientState )
        m_stateTransitionCallback( false, clientState );
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: NotifyError
///
/// @brief Calls the errorNotificationCallback, provided it has been set.
///
/// @param errorCode    PortaudioClient error code.
/// @param libErrorCode Underlying library error code.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
void PortaudioClient::NotifyError( const PlayerStatus errorCode,
                                   const int          libErrorCode
                                 )
{

    if ( NULL != m_errorNotificationCallback )
    {
        if ( PA_CLIENT_FILE_ERROR == errorCode )
        {
            m_errorNotificationCallback( errorCode,
                                         libErrorCode,
                                         sf_error_number( libErrorCode )
                                       );
        }
        else
        {
            m_errorNotificationCallback( errorCode,
                                         libErrorCode,
                                         Pa_GetErrorText( libErrorCode )
                                       );
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: IsPlaybackSupported
///
/// @brief checks whether the provided sampling rate and channels are
///        supported by the selected playback device.
///
/// @param outputParameters  A structure storing output stream parameters.
///
/// @return The player's status
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::IsPlaybackSupported( PaStreamParameters &outputParameters )
{
    PlayerStatus exitCode;
    PaError samplingError;
    const PaDeviceInfo *deviceInfo;
    deviceInfo = Pa_GetDeviceInfo( outputParameters.device );
    samplingError = Pa_IsFormatSupported( NULL,
                                          &outputParameters,
                                          m_sampleRatePlayback );

    if ( paFormatIsSupported == samplingError )
    {
        if ( m_playbackChannelCount > deviceInfo->maxOutputChannels )
        {
            exitCode = PA_PLAYBACK_CHANNEL_COUNT_SUPPORT_ERROR;
            NotifyError( PA_PLAYBACK_CHANNEL_COUNT_SUPPORT_ERROR, samplingError );
        }
        else
        {
            exitCode = PA_CLIENT_SUCCESS;
        }
    }
    else
    {
         exitCode = PA_SAMPLINGRATE_SUPPORT_ERROR;
         NotifyError( PA_SAMPLINGRATE_SUPPORT_ERROR, samplingError );
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: IsRecordingSupported
///
/// @brief checks whether the provided sampling rate and channles are
///        supported by the selected recording device.
///
/// @param inputParameters  A structure storing input stream parameters.
///
/// @return The player's status.
///
///////////////////////////////////////////////////////////////////////////////
PlayerStatus PortaudioClient::IsRecordingSupported( PaStreamParameters &inputParameters )
{
    PlayerStatus exitCode;
    PaError samplingError;
    const PaDeviceInfo *deviceInfo;
    deviceInfo = Pa_GetDeviceInfo( inputParameters.device );
    samplingError = Pa_IsFormatSupported( &inputParameters,
                                          NULL,
                                          m_sampleRateRecord );

    if ( paFormatIsSupported == samplingError )
    {
        if ( m_recordChannelCount > deviceInfo->maxInputChannels )
        {
            exitCode = PA_RECORDING_CHANNEL_COUNT_SUPPORT_ERROR;
            NotifyError( PA_RECORDING_CHANNEL_COUNT_SUPPORT_ERROR, samplingError );
        }
        else
        {
            exitCode = PA_CLIENT_SUCCESS;
        }
    }
    else
    {
         exitCode = PA_SAMPLINGRATE_SUPPORT_ERROR;
         NotifyError( PA_SAMPLINGRATE_SUPPORT_ERROR, samplingError );
    }
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
/// Portaudio callback definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///
//  Function: ProcessPlayback.
///
/// @brief A portaudio callback.
///
/// @param pInput      Input buffer.
/// @param pOutput     Output buffer.
/// @param frameCount  Amount of frames in in buffers.
/// @param pTimeInfo   Timestamps indicating the ADC capture time of the first
///                    sample in the input buffer, the DAC output time of the
///                    first sample in the output buffer and the time the
///                    callback was invoked.
/// @param statusFlags Flags indicating whether input and/or output buffers have
///                    been inserted or will be dropped to overcome underflow or
///                    overflow conditions.
/// @param pUserData   Pointer to data supplied when opening the stream (in
///                    this case pointer to a PortaudioClient instance).
///
/// @retval paContinue - indicates the stream should continue to be active,
/// @retval paComplete - indicates the stream should finish once the output
///                      buffer is empty.
/// @retval paAbort    - indicates the stream should finish as soon as possible.
///
///////////////////////////////////////////////////////////////////////////////
extern int ProcessPlayback( const void                     *pInput,
                            void                           *pOutput,
                            unsigned long                  frameCount,
                            const PaStreamCallbackTimeInfo *pTimeInfo,
                            PaStreamCallbackFlags          statusFlags,
                            void                           *pUserData
                          )
{
    PortaudioClient *pClient = ( PortaudioClient* ) pUserData;
    float *pOut = ( float* )pOutput;
    sf_count_t read = 0;
    int exitCode = paContinue;
    memset( pOut, 0, frameCount * sizeof( float ) * pClient->m_playbackChannelCount );
    ( void ) pTimeInfo;
    ( void ) statusFlags;
    UNREFERENCED_PARAMETER( pInput );
    WaitForSingleObject( pClient->m_MutexPlayBackFile, INFINITE );
    if ( pClient->IsClientState( PLAYING ) )
    {
        read = sf_readf_float( pClient->GetPlaybackFile(), pOut, frameCount );
        if ( 0 == read )
            pClient->UnsetState( PLAYING );
    }
    ReleaseMutex( pClient->m_MutexPlayBackFile );
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: ProcessRecording
///
/// @brief A portaudio callback.
///
/// @param pInput      Input buffer.
/// @param pOutput     Output buffer.
/// @param frameCount  Amount of frames in in buffers.
/// @param pTimeInfo   Timestamps indicating the ADC capture time of the first
///                    sample in the input buffer, the DAC output time of the
///                    first sample in the output buffer and the time the
///                    callback was invoked.
/// @param statusFlags Flags indicating whether input and/or output buffers have
///                    been inserted or will be dropped to overcome underflow or
///                    overflow conditions.
/// @param pUserData   Pointer to data supplied when opening the stream (in
///                    this case pointer to a PortaudioClient instance).
///
/// @retval paContinue - indicates the stream should continue to be active,
/// @retval paComplete - indicates the stream should finish once the output
///                      buffer is empty.
/// @retval paAbort    - indicates the stream should finish as soon as possible.
///
///////////////////////////////////////////////////////////////////////////////
extern int ProcessRecording( const void                     *pInput,
                             void                           *pOutput,
                             unsigned long                  frameCount,
                             const PaStreamCallbackTimeInfo *pTimeInfo,
                             PaStreamCallbackFlags          statusFlags,
                             void                           *pUserData
                           )
{
    PortaudioClient *pClient = ( PortaudioClient* ) pUserData;
    float *pIn = ( float* )pInput;
    int exitCode = paContinue;
    ( void ) pTimeInfo;
    ( void ) statusFlags;
    UNREFERENCED_PARAMETER( pOutput );
    WaitForSingleObject( pClient->m_MutexRecordFile, INFINITE );
    if ( pClient->IsClientState( RECORDING ) )
    {
        sf_writef_float( pClient->GetRecordFile(), pIn, frameCount );
    }
    ReleaseMutex( pClient->m_MutexRecordFile );
    return exitCode;
}
/////////////////////////////END OF FILE///////////////////////////////////////