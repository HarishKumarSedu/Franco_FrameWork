###############################################################################
###
### Copyright (c) 2016 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file  analysis.rb
### @brief Encapsulates all the analysis kind of test method definitions
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################
require 'aqm_analyzer.rb'
require 'pops_detection.rb'
require 'logfw'

###############################################################################
#
# @function verify_output_for_silence
#
# Invokes silence find out utility to find the given file has data
#
# @param [String]  file      Name of the file.
# @param [Boolean] negotiate If it is true, the method searches for data in
#                            file not silent. If it is false, the method
#                            searches for silence and not for data.
#
# @raise [RuntimeError]      An error is raised if unexpected behavior observed
#
###############################################################################
def verify_output_for_silence( file, negotiate )
    device = FruitSalad.get_device()
    if negotiate
        raise 'Captured output was silent.' if FruitSalad::is_silence? file
    else
        raise('Captured output was silent.')\
            unless FruitSalad::is_silence? file
    end
end

################################################################################
##
## @function audio_comparison
##
## Verifies whether the output matches with the given input file.
##
## @param [String] file1    Name of the reference file
## @param [String] file2    Name of the output file
##
## @raise [RuntimeError]    An error is raised if unexpected behavior observed
##
## @return     0 or 1 If the given input files are same otherwise greter than 1
##
################################################################################
def audio_comparison( file1, file2 )
    $LOG.info "Audio comparison......"
    output = AQMTest::aqm_test( file1, file2 )
    $LOG.debug "output: #{output}"
    if output <= 1
        $LOG.info 'Given input files are same'
    else
        raise $LOG.error ('Files are not matched')
    end
    return output
end

################################################################################
##
## @function verify_output_has_frequency_peak
##
## Invokes peak frequency find out utility and raises exception if the output
## peak frequency does not match with the original peak frequency with in error.
##
## @param [String]  file      Name of the file.
## @param [Integer] frequency The expected frequency value or original.
##
## @raise [RuntimeError]      An error is raised if frequency not fall with in
##                            the expected frequency range.
##
################################################################################
def verify_output_has_frequency_peak( file, frequency, error )
    measured_frequency = FruitSalad.peak_frequency( file )
    $LOG.debug "Measured Frequency: #{measured_frequency}"
    unless measured_frequency <= frequency + error and measured_frequency >= frequency - error
        raise $LOG.error "Measured peak frequency was #{measured_frequency}, expected " \
              "#{frequency} +/- #{error}."
    end
end

################################################################################
##
## @function check_output_has_pops_and_clicks
##
## Invokes pops and clicks find out utility and raises exception if the output
## has pops and clicks in it.
##
## @param [String] file Name of the file.
##
## @raise [RuntimeError] An error is raised if the pops and clicks detected,
##        and raise_error_if_pops_detected value is set to be true.
##
## @return true if the pops and clicks detected and raise_error_if_pops_detected
##         value is set to be false.
##
################################################################################
def check_output_has_pops_and_clicks( file )
    $LOG.info "Checking for pops and clicks..."
    return_value = NativePopsDetection::pops_clicks_detection( file )
    raise_error_if_pops_detected = Conf::property( :Raise_Error_If_Pops_Detected, true )
    if( :POPS_DETECTED == return_value && true == raise_error_if_pops_detected)
        raise $LOG.error (' Pops Detected ')
    elsif( :POPS_DETECTED == return_value )
        $LOG.error "Pops Detected"
        return true
    end
end

#################################################################################
## @function is_output_saturated
##
## Check that output is not saturated when sinewave of given amplitude is played
##
## @param [String] file Name of the file
##
## @param [Integer] table It represents the expected frequencies of file
##
## @param [Integer] sample_rate The expected sample rate value of file
##
## @raise [RuntimeError] An error is raised if Saturation occured in output.
#################################################################################
def is_output_saturated( file, table , sample_rate )
    device = FruitSalad::get_device
    device.end_capture
    # Extract info from table
    expected_frequencies = table.map! do |row|
        FruitSaladUtils::string_to_frequency row
    end
    saturation_flag = FruitSalad::saturation_check file, expected_frequencies, sample_rate
    if ( saturation_flag == true )
        raise $LOG.error ('Saturation occured in output. Playback and Record volume is too high. Adjust it')
    end
end

#################################################################################
## @function check_output_has_dominant_frequency
##
## Check the output file has dominant frequency or not
##
## @param fft_options Optional string to be processed further for FFT options.
##
## @param table The table of frequencies to search for.
##
## @file_name [String] file Name of the file.
##
## @raise [RuntimeError] An error is raised if dominant frequencies are not found in output.
##
#################################################################################
def check_output_has_dominant_frequency( file_name, table, fft_options={} )
    options_hash =  fft_options
    error = options_hash[:error]
    # Extract info from table
    expected_frequencies = table.map! do |row|
        FruitSaladUtils::string_to_frequency row
    end
    # Calculate measured frequencies
    measured_frequencies = FruitSalad::dominant_frequencies file_name, options_hash
    # Find the expected frequencies
    missing = FruitSalad::verify_frequency_clusters(
                                                    expected_frequencies,
                                                    measured_frequencies,
                                                    error
                                                   )
    if missing.length > 0
        $LOG.debug "Missing frequencies: #{missing}"
        $LOG.info "One or more dominant frequencies are missed in the output"
    else
        $LOG.info "The output contains dominant frequencies"
    end
end

################################################################################
# @function is_output_contain_specific_tones
#
# Check the output file contains the dominant frequency within specific bands
#
# @param fft_options Optional string to be processed further for FFT options.
#
# @param table The table of frequency ranges to be exclude.
#              Should be labled as low and high.
#
# @file_name [String] file Name of the file.
#
# @raise [RuntimeError] An error is raised if Unacceptable tones found in output.
#
################################################################################
def is_output_contain_specific_tones( file_name, table, fft_options={} )
    options_hash = fft_options
    measured_frequencies = FruitSalad::dominant_frequencies file_name , options_hash
    failed = false
    table.each do |range|
        low = FruitSaladUtils::string_to_frequency range[:low]
        high = FruitSaladUtils::string_to_frequency range[:high]
        measured_frequencies.each do |measured|
            if low <= measured && measured <= high
                failed = true
                $LOG.info "Tone #{measured} Hz in range [#{low}, #{high}]"
            end
        end
    end
    raise $LOG.error 'Unacceptable tones found.' if failed
end

################################################################################
#
# @function check_average_amplitude_value_of_output
#
# Finding the average amplitude value within the file.
#
# @param [String] file            The name of the orginal file to analyse
#
# @return [Array] returns array of average Amplitude value per each channel in
#                 a file
#
################################################################################
def check_average_amplitude_value_of_output( file )
    value = FruitSalad::find_average_amplitude_value( file )
    return value
end

##################################### END OF FILE ##############################