################################################################################
###
### Copyright (c) 2014 Wolfson Microelectronics plc.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Wolfson Microelectronics plc. Wolfson Microelectronics plc
### assumes no responsibility or liability for any errors or inaccuracies that
### may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Wolfson Microelectronics plc.
###
### @file   wavefile_portaudio.rb
### @brief  Playback and recording of .wav files using portaudio API
###
### @version \$Id: wavefile_portaudio.rb 365 2014-11-05 15:03:24Z aangus $
###
### Warning
###   This software is specifically written for Wolfson devices. It may not be
###   used with other devices.
###
#################################################################################

#
# Includes
#

require "wavefile"
require "ffi-portaudio"
require "configuration"
require 'logfw'

#################################################################################
#
# Resource initialization
#
#################################################################################
FFI::PortAudio::API.Pa_Initialize
at_exit do
    FFI::PortAudio::API.Pa_Terminate
end

#################################################################################
#
# Wavefile playback and recording designed for running fruitsalad tests on a
# Windows target.
#
# @note For reasons that have not been determined functions only when
#           portaudio.dll is compiled with only DirectSound support otherwise
#           segfaults occur.
#
#################################################################################
module WavefilePortaudio

    #########################################################################
    #
    # Constants
    #
    #########################################################################

    #############################################################################
    #
    # The number of bytes that should be written, or read to/from an
    # in-memory buffer as part of bulk-reads and bulk-writes.
    #
    # Note: The methods used by Wavefile for low-level IO appear to be
    # themselves buffered, so this constant may have no effect at all.
    #############################################################################
    FileIOBlockSize = Conf.property( :FileIO_BlockSize, 2**12 )

    #############################################################################
    #
    # The number of audio channels to open for playback.
    #
    #############################################################################
    PlaybackChannels = Conf.property( :Playback_Channels, 2 )

    #############################################################################
    #
    # The number of audio channels to open for recording.
    #
    #############################################################################
    RecordingChannels = Conf.property( :Recording_Channels, 2 )

    #############################################################################
    #
    # Encapsulates a wavefile on the filesystem and allows for playback or
    # recording as methods. These will implicitly open the file as needed.
    #
    #############################################################################
    class File

        #########################################################################
        #
        # Public attributes
        #
        #########################################################################

        # The full or relative path to the file on disk.
        attr_accessor :path

        #########################################################################
        #
        # Constructor
        #
        # @param path [String] is the path to the file resource.
        #
        #########################################################################
        def initialize( path )
            @path = path
        end

        #########################################################################
        #
        # Opens the named file and begins playback. Playback will terminate
        # once the entire file has been read, but it will not automatically free
        # any portaudio resources.
        #
        # Playback is non-blocking.
        #
        # @note We only support the playback of a single file at a time. This
        #           will implicitly stop the playback of any active playback
        #           file.
        #
        #########################################################################
        def playback
            @info = WaveFile::Reader.info( @path )
            @format = WaveFile::Format.new( PlaybackChannels, :float, @info.sample_rate )
            @reader = WaveFile::Reader.new( @path, @format )

            @stream = Stream.get_stream
            $LOG.info "Starting playback."
            @stream.start_playback( @reader, @info )
        end

        #########################################################################
        #
        # Begins recording from the default capture device and writes the
        # samples to file.
        #
        # Recording is non-blocking.
        #
        # @note WaveFile will not flush the output buffer unless stop_recording
        #           is called.
        #
        # @note We only support recording to a single file at a time. Do not
        #           call this a second time without first calling stop_recording
        #           first to ensure write buffers are properly flushed.
        #
        # @param [int] sample_rate The number of samples per second of recording.
        #
        #########################################################################
        def record( sample_rate )
            @format = WaveFile::Format.new( RecordingChannels, :float, sample_rate )
            @writer = WaveFile::Writer.new( @path, @format )

            @stream = Stream.get_stream
            $LOG.info "Starting recording."
            @stream.start_recording( @writer, @format )
        end

        #########################################################################
        #
        # Stops any active playback.
        #
        # @note We only support playback of a single file at a time. This method
        #           will stop the currently active playback regardless of
        #           whether that particular file is the active playback.
        #
        #########################################################################
        def stop_playback
            $LOG.info "Stopping playback."
            @stream.stop_playback
        end

        #########################################################################
        #
        # Stops recording, closes the File and flushes any associated
        # write-buffer.
        #
        # @note The write buffer will not be flushed unless the file is closed
        #           using this method. Call this before attempting to analyze
        #           the file.
        #
        #########################################################################
        def stop_recording
            $LOG.info "Stopping recording."
            @stream.stop_recording
        end

        #########################################################################
        #
        # Returns true when the file's read pointer reaches the end of the file
        # i.e. the entire file has been read.
        #
        # This can be used to poll for the termination of playback as playback
        # is non-blocking.
        #
        #########################################################################
        def eof?
            @reader.current_sample_frame >= @reader.total_sample_frames
        end

    end

    private

    #########################################################################
    #
    # Workhorse for the ffi-portaudio methods and performs the actual
    # playback and recording. Specialises the FFI::PortAudio::Stream class
    # given by ffi-portaudio.
    #
    #########################################################################
    class Stream < FFI::PortAudio::Stream

        @@stream = nil

        #####################################################################
        #
        # PortAudio only allows for a single active stream. Ensure this by
        # using this factory.
        #
        # Initializes a Stream the first time it is called, and returns it.
        # On subsequent calls it returns the stream initialized in the first
        # call.
        #
        # @return [Stream]
        #
        #####################################################################
        def self.get_stream
            if nil == @@stream
                @@stream = Stream.new
            end
            @@stream
        end

        #####################################################################
        #
        # Default Constructor
        #
        #####################################################################
        def initialize
            @input = nil
            @output = nil
            @stream = nil
            @reader = nil
            @writer = nil
        end

        #####################################################################
        #
        # Begin playback from a wavefile.
        #
        # @param reader is an open WaveFile::Reader
        # @param info is the WaveFile::Info containing that file's header
        #   information e.g. sample rate.
        #
        #####################################################################
        def start_playback( reader, info )
            @reader = reader
            output = API::PaStreamParameters.new
            output[:device] = API.Pa_GetDefaultOutputDevice
            output[:channelCount] = PlaybackChannels
            output[:sampleFormat] = API::Float32

            stop_stream
            open( @input, output, info.sample_rate, FileIOBlockSize )
            start
        end

        ###################################################################
        #
        # Terminates any active playback and closes the file.
        #
        ###################################################################
        def stop_playback
            @reader.close
            @reader = nil

        end

        ###################################################################
        #
        # Begins recording to a file using this Stream.
        #
        # @param writer is an open WaveFile::Writer object.
        # @param format is the WaveFile::Format object used to create writer.
        #
        ###################################################################
        def start_recording( writer, format )
            @writer = writer
            @format = format
            input = API::PaStreamParameters.new
            input[:device] = API.Pa_GetDefaultInputDevice
            input[:channelCount] = RecordingChannels
            input[:sampleFormat] = API::Float32

            stop_stream
            open( input, @output, @format.sample_rate, FileIOBlockSize )
            start
        end

        ##################################################################
        #
        # Stops recording and closes the output file.
        #
        ##################################################################
        def stop_recording
            @writer.close
            @writer = nil
        end

        ##################################################################
        #
        # Halts the PaStream, allowing you to open a new PaStream with
        # different properties.
        #
        ##################################################################
        def stop_stream
            unless nil == @stream
                API::Pa_CloseStream( @stream.read_pointer )
                @stream = nil
            end
        end

        private
        ####################################################################
        #
        # Writes the PortAudio recording buffer to the open output file, if
        # there is one. Fills the PortAudio playback buffer from an open
        # source file, if there is one. Used as a callback by PortAudio.
        #
        # @note Call parameters are given by typedef for PaStreamCallback in
        #       portaudio.h
        #
        # @param input              is the recording buffer
        # @param output             is the playback buffer
        # @param frames_perBuffer   is the number of samples in the
        #                           recording/playback buffers
        # @param timeInfo           Is a struct describing ADC capture time,
        #                           of the first sample in the buffer, the DAC
        #                           output time of the first sample and the time
        #                           the callback was invoked.
        # @param statusFlags        indicates what behavior will occur in
        #                           overflow or underflow conditions.
        # @param userData           is a pointer to a user-supplied struct
        #                           which should not be used in Ruby (but
        #                           is necessary for signature matching)
        #
        ####################################################################
        def process( input, output, frames_perBuffer, timeInfo, statusFlags, userData )
            # Recording
            output.write_array_of_float( Array.new( FileIOBlockSize, 0 ) )
            rtn_value = :paComplete
            unless nil == @writer
                begin
                    samples = input.read_array_of_float( FileIOBlockSize )
                    samples = samples.each_slice( RecordingChannels ).to_a
                    samples = WaveFile::Buffer.new( samples, @format )
                    @writer.write( samples )
                    rtn_value = :paContinue
                rescue Exception => msg
                    $LOG.debug "Exception occured: #{msg}"
                    rtn_value = :paAbort
                end
            end
            unless nil == @reader or :paAbort == rtn_value
                rtn_value = :paContinue
                begin
                    out = @reader.read( FileIOBlockSize ).samples
                    output.write_array_of_float( out.flatten! )
                rescue Exception => msg
                    $LOG.debug "Exception occured: #{msg}"
                    rtn_value = :paAbort
                end
            end
            stop unless :paContinue == rtn_value
            rtn_value
        end

    end
end

################################## END OF FILE ##################################