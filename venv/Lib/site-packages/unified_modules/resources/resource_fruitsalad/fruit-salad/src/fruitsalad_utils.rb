################################################################################
###
### Copyright (c) 2014-2017 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   fruitsalad_utils.rb
### @brief  A collection of useful routines.
###
### @version \$Id: fruitsalad_utils.rb 981 2015-03-31 12:46:04Z aangus $
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
################################################################################

#
# Requires
#
require 'wavefile'
require 'benchmark'

module FruitSaladUtils
    attr_reader :time_stamp
    # Common Regular Expressions
    RegEx_Number = /-?\d+(?:\.\d+)?(?:e[\+-]?\d+)?/

    ############################################################################
    #
    # Set the file name to be loaded with a local context unless the file does
    # not exist, otherwise use the FRUITSALAD_HOME environment variable.
    #
    # @param fname A filename to look for.
    #
    # @return file name with local or FRUITSALAD_HOME path prepended.
    #
    ############################################################################
    def self.select_file_with_local_pref(fname)
        local_fname = File.join('.', fname)
        if File.exists?(local_fname)
            return local_fname
        else
            return File.join( ENV["FRUITSALAD_HOME"], fname)
        end
    end

    ############################################################################
    #
    # Converts a value in Hz to kHz.
    #
    # @param n A value in Hz to convert.
    #
    # @return The input value converted to kHz.
    #
    ############################################################################
    def self.convert_Hz_to_kHz( n )
        n.to_f/1000.0
    end

    ############################################################################
    #
    # Converts a value in kHz to Hz.
    #
    # @param n A value in kHz to convert.
    #
    # @return The input value converted to Hz.
    #
    ############################################################################
    def self.convert_kHz_to_Hz( n )
        n.to_f*1000.0
    end

    ############################################################################
    #
    # @function string_to_frequency
    #
    # Creates a floating point frequency in Hz from a string containing a number
    # and a unit (Hz or kHz)
    #
    # @param [String] string The frequency and its units in string form
    #
    # @return [Fixnum] The frequency in Hz
    #
    # @raise [RunTimeException] If the string fails to match the internal regex
    #                            or is nil
    #
    ############################################################################
    def self.string_to_frequency( string )
        frequency = /(\d+\.?\d*(?:e-?\d+)?) ?([k])?(?:Hz)?/i.match string
        raise "Could not match frequency as string with internal regexp" if frequency.nil?
        if frequency[2].nil?
            frequency = frequency[1].to_f
        else
            case frequency[2].downcase
            when 'k'
                frequency = frequency[1].to_f * 1000
            else
                raise "Units not understood #{frequency[0]}"
            end
        end
        return frequency
    end

    ############################################################################
    #
    # @function pad_with_lead_in_lead_out
    #
    # Creates a temporary copy of a given file with a specified amount
    # of (silent) lead in and lead out time.
    #
    # @param [String]   filename        The name of the input file to copy
    # @param [Numeric]  lead_in_time    The amount of lead-in time to prepend in seconds
    # @param [Numeric]  lead_out_time   The amount of lead-out time to append in seconds
    #
    # @return [String] The path to the modified copy
    #
    ############################################################################
    def self.pad_with_lead_in_lead_out( filename, lead_in_time, lead_out_time )
        basename = File::basename( filename, '.wav' )

        info = WaveFile::Reader.info( filename )
        sample_rate = info.sample_rate
        number_of_channels = info.channels

        samples = read_wavefile( filename, sample_rate )

        null_frame = [ Array.new( number_of_channels, 0 ) ]
        lead_in = null_frame * (lead_in_time*sample_rate).ceil
        lead_out = null_frame * (lead_out_time*sample_rate).ceil

        out_samples = lead_in + samples + lead_out

        unless Dir::exist? 'tmp'
            Dir::mkdir 'tmp'
        end

        out_filename = File.join( 'tmp', "lead_in#{lead_in_time}_out#{lead_out_time}_#{basename}.wav" )

        format = WaveFile::Format.new( number_of_channels, :float, sample_rate )
        buffer = WaveFile::Buffer.new( out_samples, format )
        WaveFile::Writer.new( out_filename, format ) do |writer|
            writer.write( buffer )
        end

        return out_filename

    end

    ############################################################################
    #
    # @function chop_at_random_location
    #
    # Creates a copy of a given file by choping given duration at some
    # random place.
    #
    # @param [String]   filename       The name of the input file to copy
    #
    # @option options [Float]   :out_duration   Seconds to chop from the given
    #                                           stream
    # @option options [Integer] :start_point      Sample at which track need to
    #                                           be reproduce
    #
    # @return [String] filename The path to the modified copy
    # @return [Integer] start_point Gives starting point of the chopped stream
    #
    # @raise [RuntimeError] An exception is raised if out_duration is greater
    #                       than input stream duration.
    #
    ############################################################################
    def self.chop_at_random_location( filename, options={} )
        out_duration = options.fetch( :out_duration, 2 )
        start_point = options.fetch( :start_point, nil )

        basename = File::basename( filename, '.wav' )

        info = WaveFile::Reader.info( filename )
        duration = info.sample_frame_count.to_f / info.sample_rate
        if duration <= out_duration
            raise 'Chop duration is larger than or equal to the given track duration'
        end

        out_samples = info.sample_rate * out_duration

        if start_point.nil?
            start_point = Random.rand( info.sample_frame_count - out_samples )
        else
            start_point = start_point
        end
        end_point = start_point + out_samples

        unless Dir::exist? 'tmp'
            Dir::mkdir 'tmp'
        end

        out_filename = File.join( 'tmp', "chopped_#{basename}.wav" )

        sample_index = 0
        out_buffer = 0
        samples_per_buffer = 1024
        sample_data = []
        start_point_modulo = start_point % samples_per_buffer
        end_point_modulo = end_point % samples_per_buffer

        format = WaveFile::Format.new( info.channels, info.bits_per_sample, info.sample_rate )
        reader = WaveFile::Reader.new( filename, format )
        reader.each_buffer( samples_per_buffer ) do |buffer|
            if (
                ( start_point < ( sample_index + samples_per_buffer ) ) &&
                ( end_point > sample_index )
               )
                # Copies the partial buffer start data to 'sample_data' array
                if ( start_point >= sample_index )
                    if out_samples < samples_per_buffer
                        sample_data.concat buffer.samples[
                         ( start_point_modulo )..( ( start_point_modulo ) + out_samples )
                         ]
                    else
                        sample_data.concat buffer.samples[
                         ( start_point_modulo )..samples_per_buffer
                         ]
                    end
                # Copies the partial buffer end data to 'sample_data' array
                elsif ( end_point < ( sample_index + samples_per_buffer ) )
                    sample_data.concat buffer.samples[0..( ( end_point_modulo ) - 1 )]
                # Copies the full buffer data to 'sample_data' array
                else
                    sample_data.concat buffer.samples
                end
            end

            sample_index += samples_per_buffer
            break if sample_index >= end_point
        end
        out_buffer = WaveFile::Buffer.new( sample_data, format )
        WaveFile::Writer.new( out_filename, format ) do |writer|
            writer.write( out_buffer )
        end
        return out_filename, start_point
    end

    ############################################################################
    #
    # @function dBFS_to_f
    #
    # Converts a value in dB FS to a float on the interval (0,1]
    #
    # @param [Fixnum] dBFS Value in decibels full scale
    #
    # @return [Fixnum] The corresponding fraction
    #
    ############################################################################
    def self.dBFS_to_f( dBFS )
        return 10**( dBFS.to_f / 20 )
    end

    ############################################################################
    #
    # @function noise_amplitude_from_snr
    #
    # Calculates the RMS amplitude of the noise needed to satisfy a given S/N
    # ratio with a given RMS signal amplitude.
    #
    # @param [Numeric] snr_db     The SNR expressed in units dB
    # @param [Numeric] signal_rms The RMS amplitude of the signal to match.
    #
    # @return [Numeric] The amplitude needed to satisfy the requested SNR.
    #
    ############################################################################
    def self.noise_amplitude_from_snr( snr_db, signal_rms )
        noise_rms = signal_rms / dBFS_to_f( snr_db )
        return noise_rms
    end

    ############################################################################
    #
    # @function read_wavefile
    #
    # Open a WAV file and return its sample data
    #
    # @param [String] filename    The name of the WAV file to open
    # @param [Fixnum] sample_rate The sample rate to convert the file to as it
    #                             is openned
    #
    # @return [Array<Array<Float>>] Sample data corresponding to that WAV file
    #
    ############################################################################
    def self.read_wavefile( filename, sample_rate )
        info = WaveFile::Reader.info( filename )
        format = WaveFile::Format.new( info.channels, :float, sample_rate )
        sample_data = []
        WaveFile::Reader.new( filename, format ) do |reader|
            buffer = reader.read( reader.total_sample_frames )
            sample_data.concat buffer.samples
        end
        # Ensure array-of-array structure
        if 1 == info.channels
            sample_data.map! { |x| [ x ] }
        end
        return sample_data
    end

    ############################################################################
    #
    # @function concatenate_wavefiles
    #
    # Reads the supplied wave files and combines them into one waveform and
    # returns it as an array of floats.
    #
    # @param [Array<String>] filenames   An array of strings representing
    #                                    filenames.
    # @param [Fixnum]        sample_rate The sample rate to convert the opened
    #                                    files to.
    #
    # @return [Array<Array<Float>>] The resulting waveform represented as
    #                               an array.
    #
    # @raise [RuntimeError] An exception is raised if sample_rate is not a
    #                       number.
    # @raise [RuntimeError] An exception is raised if filenames is nil or an
    #                       empty array.
    #
    ############################################################################
    def self.concatenate_wavefiles( filenames, sample_rate )
        raise 'Sample rate must be a number.' unless sample_rate.is_a? Numeric
        raise 'Can not concatenate nil.' if filenames.nil?
        raise 'Can not concatenate an empty list of files.' if filenames.empty?

        samples = []

        filenames.each do |filename|
            samples.concat read_wavefile( filename, sample_rate )
        end

        samples
    end

    ############################################################################
    # @function convert_fft_options
    #
    # Converts the FFT options from a capture group string into a Hash for further use.
    #
    # Supported options:
    #    :error     - number - tolerance needed to declare a frequency as found.
    #    :threshold - number - threshold (noise floor) under which a tone will be discarded.
    #
    # @param  [String] options_string capture group of the step definitions that contains a list of options.
    #
    # @return [Hash] A hash object of the FFT options.
    #
    # @raise If no recognised FFT options can be found.
    # @raise If the value given for error is negative.
    #
    ############################################################################
    def self.convert_fft_options( options_string )
        options_hash = {}
        #
        # can be a single regular expression for now, more complicated arguments (other than
        # key and number would require additional matching and processing.
        #
        fft_opt_reg_ex = /(?:(?:and|with) (error|threshold) (#{RegEx_Number}) (?:Hz|dB)?)/
        options_array = options_string.scan( fft_opt_reg_ex )

        # if no options are found for a non-whitespace options_string raise an error.
        if options_array.empty? and options_string.strip.length > 0
            raise "No recognised FFT options in string \"#{options_string}\" matching regex \"#{fft_opt_reg_ex.to_s}\""
        end

        # parse out the capture groups into key and value
        options_array.each do |opt|
            options_hash[opt[0].to_sym] = opt[1].to_f
        end

        # provide a default error level (tolerance) if one is not given.
        unless options_hash.has_key?( :error )
            options_hash[:error] = Conf.property("Analyzer_FrequencyTolerance", 0.5)
        else
            # check that the error is non-negative
            if options_hash[:error] < 0
                raise "Error value should be non-negative, found: \"#{options_hash[:error]}\""
            end
        end

        return options_hash
    end


    ############################################################################
    #
    # @function benchmark_reads
    #
    # Reads a block of data from the device a number of times.
    #
    # @param [Integer]    address       Address offset to read from
    # @param [Integer] number_of_bytes  number of bytes to read as a block
    # @param [Integer] repeats          Number of times to repeat the block read.
    #
    ############################################################################
    def self.benchmark_reads( address, number_of_bytes, repeats )
        @device = FruitSalad::get_device()
        read_from_device = true

        repeats.times do
            ret_bytes = @device.read_block_data( address,
                                               number_of_bytes,
                                               read_from_device
                                             )
        end
    end

    ############################################################################
    # @function logging_info
    #
    # It will logs the dsp firmware information,general log,
    # dsp register information,tinymix information,widget status,
    # into the logs with time stamp. Can store the logs for only
    # few last iterations by setting the configuration variable.
    #
    # @return status [Boolean] Returns the failure status logging method calls.
    #
    ############################################################################
    def self.logging_info()
        @device = FruitSalad::get_device()
        @device.initialize_logging()
        status = @device.dsp_firmware_info_log()
        status |= @device.dmesg_log()
        status |= @device.registerdump_16bit()
        status |= @device.registerdump_32bit()
        status |= @device.tinymix_log()
        status |= @device.widget_status_log()

        @LogDir = Conf::property(:LogDir, nil)
        tmp_path = File.join( ENV['FRUITSALAD_HOME'], 'tmp/' )

        if @LogDir
            log_path = File.join( ENV['FRUITSALAD_HOME'],
                                     "/../test/#{@LogDir}/logs/#{$script_log_file_name}_#{$time_stamp}/"
                                )
        else
            log_path = File.join( ENV['FRUITSALAD_HOME'],
                                   "/logs/#{$script_log_file_name}_#{$time_stamp}/"
                                )
        end

        if Dir::exist?( tmp_path )
            FileUtils.cp_r( tmp_path, log_path )
        end

        $log_count += 1
        $time_stamp_array[$log_count] = $time_stamp

        last_n_logs = Conf.property( :NumberOfLastLogs, nil )

        # Log only last logs as given from log count.
        if !( last_n_logs.nil? ) && ( $log_count > last_n_logs )
            if @LogDir
                del_path = File.join( ENV['FRUITSALAD_HOME'],
                                      "/../test/#{@LogDir}",
                                      'logs',
                                      "logs_#{$time_stamp_array[$log_count - last_n_logs]}/"
                                    )
            else
                del_path = File.join( ENV['FRUITSALAD_HOME'],
                                      'logs',
                                      "logs_#{$time_stamp_array[$log_count - last_n_logs]}/"
                                    )
            end

            if Dir::exist?( del_path )
                FileUtils.remove_dir( del_path )
            end
        end

        return status
    end

    ############################################################################
    # @function wisce_target_logging_info
    #
    # It stores the files in log folder created using timestamp for only
    # configured last iterations.
    #
    # @param [String] path Optional parameter to append to the file name
    #
    ############################################################################
    def self.wisce_target_logging_info( path = nil, test_case_type )
        time_stamp = Time.now.strftime( "%Y-%m-%d-%H-%M" )
        @device = FruitSalad::get_device()

        @file_path = $0.sub(/\.rb\Z/, '')
        path_elems = @file_path.split('/')
        @file_name = path_elems.pop
        unless path.nil?
            folder_name = path
        else
            folder_name = @file_name
        end

        @LogDir = Conf::property(:LogDir, nil )

        if @LogDir
            logging_path = File.join( ENV['FRUITSALAD_HOME'],
                                       "/../test/#{@LogDir}/logs/#{test_case_type}/#{folder_name}_#{time_stamp}"
            )
            logfile = File.join( ENV['FRUITSALAD_HOME'],
                                      "/../test/#{@LogDir}/logs/#{@file_name}.log"
                               )
        else
            logging_path = File.join( ENV['FRUITSALAD_HOME'],
                                       "/logs/#{test_case_type}/#{folder_name}_#{time_stamp}"
            )
            logfile = File.join( ENV['FRUITSALAD_HOME'],
                                 "/logs/#{@file_name}.log"
            )
        end

        unless Dir::exist?( logging_path )
            FileUtils.mkdir_p( logging_path )
        end

        tmp_path = File.join( ENV['FRUITSALAD_HOME'], 'tmp/' )

        if Dir::exist?( tmp_path )
            FileUtils.cp_r( "#{tmp_path}/.", logging_path )
        end

        #FileUtils.cp( logfile, logging_path )

        $log_count += 1
        $time_stamp_array[$log_count] = time_stamp

        last_n_logs = Conf.property( :NumberOfLastLogs, nil )

        # Log only last logs as given from log count.
        if !( last_n_logs.nil? ) && ( $log_count > last_n_logs )
            if @LogDir
                del_path = File.join( ENV['FRUITSALAD_HOME'],
                                      "/../test/#{@LogDir}",
                                      'logs',
                                      "#{folder_name}_#{$time_stamp_array[$log_count - last_n_logs]}/"
                                    )
            else
                del_path = File.join( ENV['FRUITSALAD_HOME'],
                                      'logs',
                                      "#{folder_name}_#{$time_stamp_array[$log_count - last_n_logs]}/"
                                    )
            end
            if Dir::exist?( del_path )
                FileUtils.remove_dir( del_path )
            end
        end
    end

    ############################################################################
    #
    # @function write_buffer_data
    #
    # writes the buffer data to a file
    #
    # @param [Array] buffer The starting address of buffer from which the
    #                data to read
    #
    # @param [String] file_name The file name into which buffer data to be written
    #
    # @return None.
    #
    ############################################################################
    def self.write_buffer_data( buffer, file_name )
        File.open( file_name, 'wb' ) do | file |
            buffer.each do | ch |
                file.write( ch.chr )
            end
        end
    end

    ############################################################################
    # @Function calculate_2_s_complement
    #
    #  Does 2's Complement on the given number.
    # @param number [Integer] Any Positive Integer number
    #
    # @return [hex] returns 2's Complement in hex.
    #
    #############################################################################
    def self.calculate_2_s_complement( number )
        n = number.to_s(16)
        hex_string = 'F' * n.length
        res = ( hex_string.to_i(16) - number ) + 1
        return res.to_s(16)
    end

    ############################################################################
    # @Function integer_array_to_byte_array
    #
    # Converts Integer Array to Byte Array.
    #
    # @param integer_array [Integer Array] Array of Integer Values.
    # @param register_length [Integer] Length of register in bits.
    #
    # @return [Byte Array] returns the converted Byte array.
    #
    #############################################################################
    def self.integer_array_to_byte_array( integer_array, register_length)
        byte_array = Array.new()
        integer_array.each do |val|
            if val < 0
                hex_string = calculate_2_s_complement(val.abs)
                hex_string = hex_string.rjust(register_length / 4,'f')
            else
                hex_string = val.to_s(16)
                hex_string = hex_string.rjust(register_length / 4,'0')
            end

            hex_string = hex_string.scan(/[a-f\d][a-f\d]/)
            hex_string.each do |v|
                byte_array << v.to_i(16)
            end
        end
        byte_array
    end

    ############################################################################
    # @Function byte_array_to_hex_array
    #
    # Converts Byte Array to Hex Array.
    #
    # @param byte_array [Byte Array] Array of Byte Values.
    # @param register_length [Integer] Length of register in bits.
    #
    # @return [Hex Array] returns the Hex array.
    #
    #############################################################################
    def self.byte_array_to_hex_array( byte_array, register_length)
        hex_array = Array.new()
        byte_array = byte_array.each_slice(register_length / 8).to_a
        byte_array.each do |value|
            hex_value = ""
            value.each do |single_byte|
                single_byte = single_byte.to_s(16).rjust(2,'0')
                hex_value+= single_byte
            end
            hex_array << hex_value
        end
        hex_array
    end

    ############################################################################
    # @Function clean_dir_contents
    #
    # Deletes all files and folders in specified directory.
    #
    # @param path_to_dir [Path] Directory/Folder to clean.
    #
    # @return [None] N/A.
    #
    #############################################################################

    def self.clean_dir_contents(path_to_dir)
        Dir.foreach(path_to_dir) do |folder_or_file|
            if ((folder_or_file.to_s != ".") and (folder_or_file.to_s != ".."))
                folder_or_file = File.join(path_to_dir, folder_or_file)
                if folder_or_file.to_s.include?(".")
                    File.delete(folder_or_file)
                else
                    FileUtils.rm_rf(folder_or_file)
                end
            end
        end
    end

    #########################################################################
    #
    # @function is_bit_perfect?
    #
    # Compare the output with input or reference for bit-perfect.
    # This comparison is done with excluding the ouput header.
    #
    # @param [String] input_file  The name of the input or reference file
    # @param [String] output_file  The name of the output file
    # @param [boolean] silence_remove true removes silence else doesn't.
    #
    # @return true if output is bit-perfect with input else false.
    #
    #########################################################################
    def self.is_bit_perfect?( input_file, output_file, silence_remove = true )
        bit_perfect_flag = false
        wav_header_length = 44
        if silence_remove
            self.remove_lead_trail_silence(output_file)
            ofh = File.open(@sox_tmp_path + '/out.wav', 'rb')
        else
            ofh = File.open(output_file, 'rb')
        end
        ofh.sysread(wav_header_length) # Moving file pointer to after the header
        op_data = ofh.read
        ofh.close

        ifh = File.open(input_file, 'rb')
        ip_data = ifh.read
        ifh.close

        if ip_data.include?(op_data)
          bit_perfect_flag = true
          $LOG.info("Output is bit-perfect with given reference")
        else
          $LOG.info("Output is NOT bit-perfect with given reference")
        end

        if silence_remove
            self.cleanup_sox_tmp()
        end

        return bit_perfect_flag
    end

    #########################################################################
    #
    # @function split_input_file_to_multiple_mono_files
    #
    # Generates multiple mono channel files using input file with multiple channels.
    #
    # @param [String] orginal_file_name  The name of the input multi-channel file
    #
    # @return [array] Return array of output file names
    #
    #########################################################################
    def self.split_input_file_to_multiple_mono_files( input_file_name )

        wave = WaveInfo.new( input_file_name )
        nu_of_channels = wave.channels# Checking number of channels
        input_file_path = File.dirname( input_file_name )
        input_file_name = File.basename(input_file_name)
        file_name = []
        file_path = "#{input_file_path}"

        $sox_path = Conf.property( :sox_path, "#{file_path}/sox_tmp" )
        unless Dir::exist? $sox_path
            Dir::mkdir $sox_path
        end
        if nu_of_channels >= 2
            for channel in 0...nu_of_channels
                system("sox #{input_file_path}/#{input_file_name} #{$sox_path}/out#{channel}_#{input_file_name} remix #{channel + 1}")
                file_name[channel] = "#{$sox_path}/out#{channel}_#{input_file_name}"
            end
        else
            raise $LOG.error "Input file has only one channel"
        end
        return file_name
    end
    #####################################################################
    #
    # @function remove_lead_trail_silence
    #
    # Removes leading and trailing silence from given wav file.
    # This generates an out.wav file in sox_tmp directory.
    # This requires sox installed.
    #
    # @param [String] wav_file  name of the file in which silence
    #                           has to be removed
    # @return nil
    #
    #####################################################################
    def self.remove_lead_trail_silence( wav_file )
        # The above-periods value is used to indicate if audio should be trimmed
        # at the beginning of the audio.
        # 0 - Doesn't remove the silence
        # 1 - Removes the silence
        above_period = 1
        # The above-periods value is used to indicate if audio should be trimmed
        # at the end of the audio.
        # 0 - Doesn't remove the silence
        # 1 - Removes the silence
        below_period = 1
        # Duration indications the amount of time that non-silence must be detected
        # before it stops trimming audio. By increasing the duration, burst of
        # noise can be treated as silence and trimmed off.
        duration = 0.1

        @silence_thrshold = Conf.property( :silence_thrshold, -100 )
        file_path = File.join( ENV['FRUITSALAD_HOME'],'tmp')
        @sox_tmp_path = Conf.property( :sox_tmp_path, "#{file_path}/sox_tmp" )

        unless Dir::exist? @sox_tmp_path
            Dir::mkdir @sox_tmp_path
        end

        # Remove leading and trailing silence from output file
        # For the below command to work you need to install sox
        system("sox #{wav_file} #{@sox_tmp_path}/out.wav silence #{above_period} \
                #{duration} #{@silence_thrshold}d reverse silence #{below_period} \
                #{duration} #{@silence_thrshold}d reverse" )
    end

    #####################################################################
    #
    # @function cleanup_sox_tmp
    #
    # Cleanup the sox_tmp folder.
    # @return nil
    #
    #####################################################################
    def self.cleanup_sox_tmp()
        @sox_tmp_cleanup = Conf.property( :sox_tmp_cleanup, false )
        # Cleanup
        if @sox_tmp_cleanup
          if Dir::exist?( @sox_tmp_path )
              FileUtils.remove_dir( @sox_tmp_path )
          end
        end
    end

end
##################################### END OF FILE ##############################