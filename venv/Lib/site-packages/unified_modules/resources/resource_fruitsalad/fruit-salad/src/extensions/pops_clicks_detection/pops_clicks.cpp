////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2016 Cirrus Logic International (UK) Ltd. All rights reserved.
//
// This software as well as any related documentation is furnished under
// license and may only be used or copied in accordance with the terms of the
// license. The information in this file is furnished for informational use
// only, is subject to change without notice, and should not be construed as
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document.
//
// Except as permitted by such license, no part of this document may be
// reproduced, stored in a retrieval system, or transmitted in any form or by
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies.
//
/// @file   pops_clicks.c
/// @brief  Detects pops and clicks in a file
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
////////////////////////////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "pops_clicks.h"
#include "fft.h"

//function prototypes
void BlackmanHarrisWindow( float *, int );

///////////////////////////////////////////////////////////////////////////////
///
// Function: PopsClicksDetection
///
/// @brief    Performs pops and clicks detection in a file.
///
/// @param *filename     Reference file path.
/// @param pop_time      Array which has times of detection of pops and clicks.
/// @param pop_time_size Size of array pop_time
/// @param pop_count     Count of pops and clicks detected.
///
/// @retval FILEOPEN_ERROR   Couldn't open file.
/// @retval NO_POPS          No pops in file.
/// @retval POPS_DETECTED    Pops detected in file.
/// @retval NO_MEMORY        Memory allocation error.
///
///////////////////////////////////////////////////////////////////////////////
PopRetCode PopsClicksDetection( char *filename, float *pop_time, int pop_time_size, int *pop_count )
{
    int i,j,k, xlen, transient_flag_sum = 0;
    int numofchan=0, Fs=0, bitddepth, length_out, nFrames=0, len, fcol = 0, count=0;
    size_t samples, total_samples = 0;
    char wave_header[WAVEHEADER_SIZE];
    float blackman_window[N]={0}, ref_fftreal[N], ref_fftimg[N], in[N]={0};
    float *stft_spectrum, ftemp_array[N], ref_complex[N], *f_transient_matrix;
    short temp_short[N2];
    float previous[N], current[N], next[N], T_minus_temp[N], T_plus_temp[N], tminus_val, tplus_val;
    float ftemp_val, Transient_threshold_sum, time, beta;
    PopRetCode exitCode;
    int transient_flag_threshold;
    float pImagInput[N2];
    FILE *fp;

    transient_flag_threshold = TRANSIENT_FLAG_THRESHOLD;
    beta = BETA;

    //Finding total number of bytes in the file
    fp = fopen( filename, "rb" );
    if( NULL == fp )
    {
        exitCode = FILEOPEN_ERROR;
        goto end;
    }
    exitCode = NO_POPS;

    fseek( fp, 0, SEEK_END );
    len = ftell( fp );
    fseek( fp, 0, SEEK_SET );

    //header reading
    fread( wave_header, 1, WAVEHEADER_SIZE, fp );

    //Number of Channels
    numofchan = wave_header[ 23 ]<<8;
    numofchan |= ( wave_header[ 22 ] & 0xff );

    //bit depth
    bitddepth = ( wave_header[ 35 ] & 0xff ) << 8;
    bitddepth |= ( wave_header[ 34 ] & 0xff );
    bitddepth = bitddepth >> 3;

    //samplerate reading
    Fs = wave_header[ 27 ] << 24;
    Fs |= ( wave_header[ 26 ] & 0xff ) << 16;
    Fs |= ( wave_header[ 25 ] & 0xff ) << 8;
    Fs |= ( wave_header[ 24 ] ) & 0xff;

    xlen = len - WAVEHEADER_SIZE;
    length_out = ( len - WAVEHEADER_SIZE ) / bitddepth;
    // calculate the total number of frames
    nFrames = 1 + ( ( length_out - WLEN ) / H );

    if( STEREO == numofchan )
    {
        nFrames = nFrames / 2;
    }
    // form the stft_spectrum matrix
    stft_spectrum = ( float * ) calloc( ROWN * nFrames, sizeof( float ) );
    if( NULL == stft_spectrum )
    {
        exitCode = NO_MEMORY;
        goto end;
    }
    // form the f_transient_matrix  matrix
    f_transient_matrix  = ( float * ) calloc( ROWN * nFrames, sizeof( float ) );
    if( NULL == f_transient_matrix )
    {
        exitCode = NO_MEMORY;
        goto free_stft_memory;
    }

    //Initializing buffers with zeros
    for( i = 0; i < N; i++ )
    {
        in[i] = 0;
    }
    //Calling blackman harris window function
    BlackmanHarrisWindow( blackman_window, N );

    //If stereo stream then converting to mono channel stream
    if( STEREO == numofchan )
    {
        samples = fread( &temp_short[ 0 ], 2, N2, fp );
        total_samples = total_samples + ( samples / 2 );
        for( i = 0; i < N; i++ )
        {
            temp_short[ i ] = ( temp_short[ 2 * i ] + temp_short[ ( 2 * i ) + 1 ] ) / 2;
        }
    }
    else
    {
        samples = fread( &temp_short[ 0 ], 2, LENGTH, fp );
        total_samples = total_samples + samples;
    }

    //converting pcm data to float
    for( j = 0; j < LENGTH; j++ )
    {
        in[ j ] = ( ( float )temp_short[ j ] / ( float )( POW15 ) ) ;
        pImagInput[ j ] = 0;
    }

    //code for finding transients in the frame
    for( i = 0; i < nFrames; i++ )
    {
        //Multiplying input samples with blackman window samples
        for( j = 0; j < N; j++ )
        {
            ref_complex[ j ] = ( float ) ( in[ j ] * blackman_window[ j ] );
        }
        //Performing FFT.
        CFFT( ref_complex, pImagInput, ref_fftreal, ref_fftimg, -1,
              FFT_LENGTH );
        for( j = 0; j < N; j++ ) //absolute
        {
            ref_fftreal[ j ] = ( float )( sqrt( ( ref_fftreal[ j ] * ref_fftreal[ j ] )
                                            + ( ref_fftimg[ j ] * ref_fftimg[ j ] ) ) );
        }
        //Storing fft output.
        for ( j = 0; j < N; j++ )
            *( stft_spectrum + i * N + j ) = ref_fftreal[ j ];

        if( i > 1 )
        {
            //Taking three frames data to perform T+ and T-
            for ( j = 0; j < N; j++ )
            {
                previous[ j ] = *( stft_spectrum + ( i - 2 ) * N + j );
                current[ j ] = *( stft_spectrum + ( i - 1 ) * N + j );
                next[ j ] = *( stft_spectrum + i * N + j );
            }
            //T- is current frame minus previous frame
            //T+ is current frame minus next frame
            for ( j = 0; j < N; j++ )
            {
                tminus_val = current[ j ] - previous[ j ];
                if( tminus_val >= 0 )
                    T_minus_temp[ j ] = tminus_val;
                else
                    T_minus_temp[ j ] = 0;

                tplus_val = current[ j ] - next[ j ];
                if( tplus_val >= 0 )
                    T_plus_temp[ j ] = tplus_val;
                else
                    T_plus_temp[ j ] = 0;
            }

            //Smoothing the function by using T- and T+ for transient detection
            for( j = 0; j < N - 6; j++ )
            {
                ftemp_val = T_minus_temp[ j ] + T_plus_temp[ j ];
                ftemp_val = ftemp_val + T_minus_temp[ j + 1 ] + T_plus_temp[ j + 1 ];
                ftemp_val = ftemp_val + T_minus_temp[ j + 2 ] + T_plus_temp[ j + 2 ];
                ftemp_val = ftemp_val + T_minus_temp[ j + 3 ] + T_plus_temp[ j + 3 ];
                ftemp_val = ftemp_val + T_minus_temp[ j + 4 ] + T_plus_temp[ j + 4 ];
                ftemp_val = ftemp_val + T_minus_temp[ j + 5 ] + T_plus_temp[ j + 5 ];
                ftemp_val = ftemp_val + T_minus_temp[ j + 6 ] + T_plus_temp[ j + 6 ];
                ftemp_array[ j ] = ftemp_val;
            }
            //Storing smoothed frame data
            for ( j = 0; j < N; j++ )
            {
                *( f_transient_matrix + fcol * N + j ) = ftemp_array[ j ];
            }
            fcol = fcol + 1;

            if( fcol > 5 )
            {
                /* Dynamic threshold calculation for each frequency bin requires past three frames
                and next threee frames data. */
                for ( j = 0; j < N-6; j++ )
                {
                    Transient_threshold_sum = *( f_transient_matrix + ( fcol - 6 ) * N + j )
                                                + *( f_transient_matrix + ( fcol - 5 ) * N + j )
                                                + *( f_transient_matrix + ( fcol - 4 ) * N + j )
                                                + *( f_transient_matrix + ( fcol - 3 ) * N + j )
                                                + *( f_transient_matrix + ( fcol - 2 ) * N + j )
                                                + *( f_transient_matrix + ( fcol - 1 ) * N + j )
                                                + *( f_transient_matrix + fcol * N + j );

                    Transient_threshold_sum = beta * ( Transient_threshold_sum / 7 );
                    //Comparing each frequency bin with dynamic threshold value
                    if( ( ( *( f_transient_matrix + ( fcol - 3 ) * N + j ) ) > Transient_threshold_sum )
                                && ( Transient_threshold_sum > 0.1 ) )
                    {
                        transient_flag_sum = transient_flag_sum + 1;
                    }
                }
                //If transient sum is greater than threshold then the frame is considered as transient frame.
                if( transient_flag_sum > transient_flag_threshold )
                {
                    time = ( float ) ( total_samples - N ) / Fs;
                    pop_time[ count ] = time;
                    count++;
                    if( count >= pop_time_size )
                    {
                        printf("More than %d pops and clicks found please allocate more memory for pop_time buffer",pop_time_size);
                        goto count_update;
                    }
                }
                transient_flag_sum = 0;
            }
        }
        //Moving last samples to buffer starting.
        for( j = 0; j < LENGTH - H; j++ )
        {
            in[ j ] = in[ j + H ] ;
        }
        //Reading samples for next frame
        if( STEREO == numofchan )//Converting stereo to mono if stereo stream
        {
            samples = fread( &temp_short[ 0 ], 2, H2, fp );
            total_samples = total_samples + ( samples / 2 );
            for( k = 0; k < H; k++ )
            {
                temp_short[ k ] = ( temp_short[ 2 * k ] + temp_short[ ( 2 * k ) + 1 ] ) / 2;
            }
        }
        else
        {
            samples = fread( &temp_short[ 0 ], 2, H, fp );
            total_samples = total_samples + samples;
        }
        //Converting to float
        for( j = 0; j < H; j++ )
        {
            in[ j + LAST_SAMPLES ] = ( ( float )temp_short[ j ] / ( float )( POW15 ) );
        }
    }
count_update:
    if( count > 0 )
    {
        ( *pop_count ) = count;
        exitCode = POPS_DETECTED;
    }
    printf( "Transient Detection Process Completed ...\n" );
    if( NULL != f_transient_matrix )
        free( f_transient_matrix );
free_stft_memory:
    if( NULL != stft_spectrum )
        free( stft_spectrum );
end:
    if( NULL != fp )
        fclose( fp );
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: BlackmanHarrisWindow
///
/// @brief    Calculated blackman harris window function samples.
///
/// @param *blackman_window    Pointer to array holding window samples.
/// @param N1                  Window length.
///
///////////////////////////////////////////////////////////////////////////////
void BlackmanHarrisWindow( float *blackman_window, int N1 )
{
    int i;
    float w;
    float scale = ( float )( 2 * M_PI ) / ( N1 - 1 );
    for( i = 0; i < N1; i++ )
    {
        w = A0 - ( A1 * cos( scale * i ) )
               + ( A2 * cos( scale * i * 2 ) )
               - ( A3 * cos( scale * i * 3 ) );

        blackman_window[ i ] = w;
    }
}
/////////////////////////////END OF FILE///////////////////////////////////////
