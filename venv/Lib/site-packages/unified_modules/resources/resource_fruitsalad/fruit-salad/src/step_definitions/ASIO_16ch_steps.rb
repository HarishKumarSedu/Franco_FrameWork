###############################################################################
###
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.
###                    All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any errors
### or inaccuracies that may appear in this document or any software that may be
### provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file ASIO_16ch_Steps.rb
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

require 'logfw'

###############################################################################
#
# @!method When_I_operate_channels
#
# Multi-track playback, with several mono WAV files being played on different
# channels. If a track should be mirrored across multiple channels each channel
# should have a separate entry.
#
# Multi-track record, with several mono WAV files being recorded on different
# channels.
#
#       Usage:
#       When I operate channels:
#           | Operation | Channel | File                     |
#           | Output    | 3       | resources/foo.wav        |
#           | Output    | 4       | resources/foo2.wav       |
#           | Record    | 1       | Recordings/input1.wav    |
#           | Record    | 2       | Recordings/input2.wav    |
#           ...
#
# Creates a Recordings directory, user can opt to use this for convenience
# This standardisation is required to use some step definitions
# Step definitions expect the following file-name format for recorded channels:
#     'Recordings/input[\d+].wav'
#
###############################################################################
When( /^I operate channels:$/ ) do |table|
    directory_name = 'Recordings'
    Dir.mkdir(directory_name) unless File.exists?( directory_name )

    # Create a Recordings directory, user can opt to use this for convenience
    # Standardisation required to use some step definitions
    # Step definitions will expect format 'Recordings/input1.wav'
    track_list = []

    output_channel = nil
    record_channel = nil

    table.map_headers!(
                        /Operation/i => :Operation,
                        /Channel/i => :Channel,
                        /File/i => :file
                      )
    table.hashes().each do |row|
        case row[:Operation].to_s
            when 'Output'
                output_channel = row[:Channel].to_i
                record_channel = nil
            when 'Record'
                record_channel = row[:Channel].to_i
                output_channel = nil
            end

        track_list << [ row[:file], output_channel, record_channel ]
    end

    FruitSalad::get_device.multitrack_playback( track_list )
end

################################################################################
#
# @!method Then_not_silence_in_ASIO_channels
#
# Determines whether the captured outputs represent silence.
#
# REQUIRES ASIO recorded input standardisation! Format Recordings/input1.wav
#
# Here silence is defined as an amplitude less than the dB value of the config
# variable Analyzer_RecordingSilenceThreshold.
#
#       Usage:
#       Then the following channels are not silent:
#        | 1 | 2 | 9 | 10 | 11 | 12 | 13 | 14 |
#
################################################################################
Then(/the following channels are not silent:$/) do |table|
    data = table.raw
    failed = []
    data.each do |rowdata|
        rowdata.each do |status|
            recording_filename = 'Recordings/input' + status.to_s + '.wav'
            if FruitSalad.is_silence?( recording_filename )
                failed.push( status )
            end
        end
    end
    unless failed.empty?
        message = 'The following channel(s) were silent:' + "\n"
        failed.each{|channel| message += "#{channel}\n" }
        raise( message )
    end
end

################################################################################
#
# @!method Then_the_channel_contains_tones
#
# Verify that the recorded output contains multiple expected frequencies.
#
# REQUIRES ASIO recorded input standardisation! Format Recordings/input1.wav
#
# Supported FFT options:
#    (with|and) error <Number> Hz
#    (with|and) threshold <Number> dB
# where:
#    error     - tolerance needed to declare a frequency as found.
#    threshold - threshold (noise floor) under which a tone will be discarded.
#
#       Usage:
#       Then the channel 2 contains tones<FFT options>*:
#           | frequency     |
#           | <frequency 1> |
#           | <frequency 2> |
#           ...
#           | <frequency N> |
#
# @example Then the channel 2 contains tones with error 5 Hz:
# @example | frequency |
# @example | 1000 Hz   |
# @example | 2000 Hz   |
# @example | 3 kHz     |

# @example Then the channel 2 contains tones with threshold -12 dB and error 5 Hz:
# @example | frequency |
# @example | 1000 Hz   |
# @example | 2000 Hz   |
#
# @param channel     Channel on which to verify recorded tones.
# @param fft_options Optional string to be processed further for FFT options.
# @param table       The table of frequencies to search for.
#
################################################################################
Then( /^the channel (#{Number}) contains tones(.*):$/ ) do |channel, fft_options, table|
    options_hash =  FruitSaladUtils::convert_fft_options( fft_options )
    error = options_hash[:error]

    # Extract info from table
    expected_frequencies = table.rows.map do |row|
        FruitSaladUtils::string_to_frequency row[0]
    end
    # Calculate measured frequencies
    measured_frequencies = FruitSalad::dominant_frequencies "Recordings/input#{channel}.wav", options_hash
    # Find the expected frequencies
    missing = FruitSalad::verify_frequency_clusters(
                                                    expected_frequencies,
                                                    measured_frequencies,
                                                    error
                                                   )
    if missing.length > 0
        $LOG.debug "Missing frequencies: #{missing}"
        raise 'Fourier transform does not match expected output.'
    end
end

###############################################################################
#
# @!method Then_the_channel_does_not_contain_tones
#
# REQUIRES ASIO recorded input standardisation! Format Recordings/input1.wav
#
# Assert that the dominant frequencies do not include any bins in one or more
# ranges.
#
# Supported FFT options:
#    (with|and) threshold <Number> dB
# where:
#    threshold - threshold (noise floor) under which a tone will be discarded.
#
#       Usage:
#       Then the channel 3 does not contain tones in bands<FFT options>*:
#           | low                   | high                  |
#           | <range 1 lower bound> | <range 1 upper bound> |
#           | <range 2 lower bound> | <range 2 upper bound> |
#           ...
#           | <range N lower bound> | <range N upper bound> |
#
# @example Then the channel 3 does not contain tones in bands:
# @example | low | high |
# @example | 0 Hz | 995 Hz |
# @example | 1.1 kHz | 4 kHz |

# @example Then the channel 3 does not contain tones in bands with threshold -24 dB:
# @example | low | high |
# @example | 0 Hz | 995 Hz |
# @example | 1.1 kHz | 4 kHz |
#
# @param channel     Channel on which to verify no recorded in-band tones.
# @param fft_options Optional string to be processed further for FFT options.
# @param table       The table of ranges to exclude. Should be labelled as low and high.
#
###############################################################################
Then( /^the channel (#{Number}) does not contain tones in bands (.*):$/ ) do |channel, fft_options, table|
    options_hash =  FruitSaladUtils::convert_fft_options( fft_options )

    table.map_headers!( /low/i => :low, /high/i => :high )
    recording_filename = 'Recordings/input' + channel.to_s + '.wav'
    measured_frequencies = FruitSalad::dominant_frequencies( recording_filename,
                                                             options_hash
                                                           )
    failed = false
    table.hashes.each do |range|
        low = FruitSaladUtils::string_to_frequency range[:low]
        high = FruitSaladUtils::string_to_frequency range[:high]
        measured_frequencies.each do |measured|
            if low <= measured && measured <= high
                failed = true
                $LOG.debug "Tone #{measured} Hz in range [#{low}, #{high}]"
            end
        end
    end
    raise 'Unacceptable tones found.' if failed
end

################################################################################
#
# @!method Then_the_following_files_are_similar
#
# Simple similarity measure of input and output.
#
# Checks amplitude of files are within a set dB of each other and performs a
# similarity measure of the peak tones.
#
#       Usage:
#       Then the following files are similar:
#           | file1                 | file2                 | max_dB_Variance |
#           | <file1 path>          | <file2 path>          | 2               |
#           | <next file1>          | <next file2>          | 1.35            |
#           ...
#
# @example     Then the following files are similar
# @example         | file1                 | file2                          | max_dB_Variance |
# @example         | Recordings/input2.wav | resources/Aud_1kHz_1s_-3dB.wav | 1.5                |
#
################################################################################
Then(/^the following files are similar$/) do |table|
    table.map_headers!(
                            /file1/i => :file1,
                            /file2/i => :file2,
                            /max_dB_Variance/i => :max_dB_Variance
                      )
    table.hashes().each do |row|
        logic1 = FruitSalad::simple_similarity_measure( row[:file1],
                                                        row[:file2]
                                                      )
        logic2 = FruitSalad::is_similar_dB_volume?( row[:file1],
                                                    row[:file2],
                                                    row[:max_dB_Variance].to_f
                                                  )

        unless ( logic1 and logic2 )
            raise 'Files are NOT suitably similar'
        else
            $LOG.info 'Files ARE suitably similar'
        end
    end
end

#################################### END OF FILE ###############################