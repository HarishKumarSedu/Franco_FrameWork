################################################################################
###
### Copyright (c) 2016 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file  playback_record.rb
### @brief Encapsulates all the playback and record based test method
###        definitions
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
################################################################################

require 'logfw'
require 'configuration'
require 'result'

# Boolean indicates whether to return error code or not.
ReturnErrorCodes = Conf.property( :ReturnErrorCodes, true )

################################################################################
#
# @function play_analog_data_from_host
#
# Invokes host specific method to play the analog data from the host PC.
#
# @param [String]  file_name        Name of the file to capture DSP output
# @param [Integer] background_play  By default it is false, when it is true
#                                   plays
#
################################################################################
def play_analog_data_from_host( file_name, background_play = false )

    device = FruitSalad.get_device()

    if background_play
        blocking = false
    else
        blocking = true
    end

    type = 'analog'
    device.playback_from_host( file_name,
                                  type: type,
                                  blocking: blocking)
end

################################################################################
#
# @function stop_playing_analog_data_from_host
#
# Invokes host specific method to stop playing the analog data from the host.
#
# (no parameters)
#
################################################################################
def stop_playing_analog_data_from_host()

    device = FruitSalad.get_device()
    type = 'analog'
    device.end_playback_at_host( type )
end

################################################################################
#
# @function play_digital_data_from_host
#
# Invokes host specific method for playing digital data from the host
#
# @param [String] file_name        Name of the file to play
# @param [Boolean] background_play By default it is false, if it is true
#                                  plays file in background
#
# @param [Integer] channels        if stereo playback channels is 2 or
#                                  if mono playback channels is 1
# @param [Array] channel_nums      Specify the channel numbers
#
################################################################################
def play_digital_data_from_host( file_name,
                                 channels,
                                 background_play = false,
                                 channel_nums = [1, 2, 3, 4]
                               )

    device = FruitSalad.get_device()
    blocking = background_play ? false : true
    if( !(file_name.is_a?(Array)) )
        if channels == 1
            track_list = [ [file_name, channel_nums[0], nil] ]
        elsif channels == 2
            track_list = [ [file_name, channel_nums[0], nil],
                           [file_name, channel_nums[1], nil]
                         ]
        else
            error_message = 'Current implementation do not support more than 2 channels'
            if ReturnErrorCodes
                return APIError.new(:UNSUPPORTED_DIGITAL_PLAYBACK,
                                       error_message,
                                       Thread.current.backtrace )
            else
                raise error_message + $LOG.error( error_message ).to_s
            end
        end
    else
        if channels == 1
            track_list = [ [file_name[0], channel_nums[0], nil] ]
        elsif channels == 2
            track_list = [ [file_name[0], channel_nums[0], nil],
                           [file_name[1], channel_nums[1], nil]
                         ]
        elsif channels == 3
            track_list = [ [file_name[0], channel_nums[0], nil],
                           [file_name[1], channel_nums[1], nil],
                           [file_name[2], channel_nums[2], nil]
                         ]
        elsif channels == 4
            track_list = [ [file_name[0], channel_nums[0], nil],
                           [file_name[1], channel_nums[1], nil],
                           [file_name[2], channel_nums[2], nil],
                           [file_name[3], channel_nums[3], nil]
                         ]
        elsif channels == 5
            track_list = [ [file_name[0], channel_nums[0], nil],
                           [file_name[1], channel_nums[1], nil],
                           [file_name[2], channel_nums[2], nil],
                           [file_name[3], channel_nums[3], nil],
                           [file_name[4], channel_nums[4], nil]
                         ]
        elsif channels == 6
            track_list = [ [file_name[0], channel_nums[0], nil],
                           [file_name[1], channel_nums[1], nil],
                           [file_name[2], channel_nums[2], nil],
                           [file_name[3], channel_nums[3], nil],
                           [file_name[4], channel_nums[4], nil],
                           [file_name[5], channel_nums[5], nil]
                         ]
        elsif channels == 7
            track_list = [ [file_name[0], channel_nums[0], nil],
                           [file_name[1], channel_nums[1], nil],
                           [file_name[2], channel_nums[2], nil],
                           [file_name[3], channel_nums[3], nil],
                           [file_name[4], channel_nums[4], nil],
                           [file_name[5], channel_nums[5], nil],
                           [file_name[6], channel_nums[6], nil]
                         ]
        elsif channels == 8
            track_list = [ [file_name[0], channel_nums[0], nil],
                           [file_name[1], channel_nums[1], nil],
                           [file_name[2], channel_nums[2], nil],
                           [file_name[3], channel_nums[3], nil],
                           [file_name[4], channel_nums[4], nil],
                           [file_name[5], channel_nums[5], nil],
                           [file_name[6], channel_nums[6], nil],
                           [file_name[7], channel_nums[7], nil]
                         ]
        else
            error_message = 'Current implementation do not support more than 8 channels'
            if ReturnErrorCodes
                return APIError.new(:UNSUPPORTED_DIGITAL_PLAYBACK,
                                      error_message,
                                      Thread.current.backtrace
                                      )
            else
                raise $LOG.error( error_message )
            end
        end
    end

    type = 'digital'
    if( !(file_name.is_a?(Array)) )
        ret_val = device.playback_from_host( file_name,
                                             track_list: track_list,
                                             blocking: blocking,
                                             type: type
                                           )
        if ReturnErrorCodes
            return ret_val
        end
    else
        device.playback_from_host( file_name[0],
                                   track_list: track_list,
                                   blocking: blocking,
                                   type: type
                                 )
        if ReturnErrorCodes
            return ret_val
        end
    end

end

################################################################################
#
# @function stop_playing_digital_data_from_host
#
# Invokes host specific method to stop playing the digital data from the host.
#
# (no parameters)
#
################################################################################
def stop_playing_digital_data_from_host()

    device = FruitSalad.get_device()
    type = 'digital'
    device.end_playback_at_host( type )
end

###############################################################################
#
# @function play_data_from_ap
#
# Invokes target specific method for playing data from application processor.
#
# @param [String]  file_name        Name of the file to play.
# @param [String]  file_path        Path of the playback file
# @param [Boolean] background_play  By default it is false, enables background
#                                   play when it is true.
# @param [Hash]   opts Optional upload argument. By default it is true which
#                 means the file needs to be uploaded,if it is false then
#                 uploading of file is not required.
#
################################################################################
def play_data_from_ap( file_name, file_path, background_play = false, opts = {} )

    upload = opts.fetch( :upload, true )
    device = FruitSalad.get_device()

    if background_play
        blocking = false
    else
        blocking = true
    end

    device.playback( file_name,
                     destination_path: file_path,
                     blocking: blocking,
                     upload: upload
                   )
end

################################################################################
#
# @function stop_playing_data_from_ap
#
# Stops playing data from application processor immediately or wait till it
# completes.
#
# @param [Boolean] wait_till_complete If the value is true, it will wait till
#                                     the playback completes, otherwise
#                                     immediately
#
################################################################################
def stop_playing_data_from_ap( wait_till_complete )

    device = FruitSalad.get_device()
    device.end_playback( wait_till_complete )
end

################################################################################
#
# @function start_recording_analog_data_at_host
#
# Invokes host specific method for recording analog data at the host PC.
#
# @param [String]   record_file_name Name of the file to record.
# @param [Integer]  sample_rate      Sampling rate while recording.
# @param [Integer]  channels         No of channels while recording
#
################################################################################
def start_recording_analog_data_at_host( record_file_name,
                                         sample_rate,
                                         channels
                                       )

    device = FruitSalad.get_device()
    type = 'analog'
    device.record_output_at_host( sample_rate,
                                  channels,
                                  type,
                                  record_file_name
                                )
end

################################################################################
#
# @function stop_recording_analog_data_at_host
#
# Invokes host specific method to stop recording of analog data at host PC.
#
# No arguments to parse.
#
################################################################################
def stop_recording_analog_data_at_host()
    device = FruitSalad.get_device()
    type = 'analog'
    device.end_capture_at_host( type )
end

################################################################################
#
# @function start_recording_digital_data_at_host
#
# Invokes host specific method for recording digital data at the host PC.
#
# @param [String]  record_file_name Name of the file to record.
# @param [Integer] sample_rate      Recording sampling rate.
# @param [Integer] channels         No of recording channels.
# @param [Integer] recording_time   The duration of time for which recording
#                                   should be done.
#
################################################################################
def start_recording_digital_data_at_host( record_file_name,
                                          sample_rate,
                                          channels,
                                          recording_time
                                        )

    device = FruitSalad.get_device()
    type = 'digital'

    # Second element is for playback channel and third element is for record
    # channel
    #track_list = [file name, channel, record].

    if 2 == channels
        track_list = [['temp_file1.wav', nil, 1], ['temp_file2.wav', nil, 2]]
    elsif 1 ==channels
        track_list = [[record_file_name, nil, 1]]
    else
        err_msg = 'Recording for more than 2 channels not supported'
        if ReturnErrorCodes
            return APIError.new(:UNSUPPORTED_DIGITAL_REC,
                                   err_msg,
                                   Thread.current.backtrace)
        else
            raise err_msg
        end
    end
    device.record_output_at_host( sample_rate,
                                  channels,
                                  type,
                                  record_file_name,
                                  recording_time,
                                  track_list
                                )
end

################################################################################
#
# @function stop_recording_digital_data_at_host
#
# Invokes host specific method to stop recording of digital data at host PC.
#
# @param [String]   record_file_name Name of the file to record.
# @param [Integer]  channels         No of channels while recording
#
################################################################################
def stop_recording_digital_data_at_host( record_file_name,
                                         channels
                                       )

    device = FruitSalad.get_device()
    type = 'digital'
    device.end_capture_at_host( type,
                                record_file_name: record_file_name,
                                channels: channels
                              )
end

################################################################################
#
# @function start_recording_dsp_output
#
# Invokes target specific method to start capturing the DSP output from AP.
#
# @param [String]  record_file_name Name of the file to capture DSP output
# @param [Integer] sample_rate      Recording sample rate
# @param [Integer] channels         Number of recording channels
# @param [String]  destination_path Path of the record file to store it
#
################################################################################
def start_recording_dsp_output( record_file_name,
                                sample_rate,
                                channels,
                                destination_path
                              )
    device = FruitSalad.get_device()
    device.record_from_compressed_stream( record_file_name,
                                          sample_rate,
                                          channels,
                                          destination_path
                                        )
end

################################################################################
#
# @function stop_recording_dsp_output
#
# Invokes target specific method to stop the compressed data from the output
# of DSP.
#
# @param [String] record_file_name Name of the file to capture the DSP output
#                                   in it
# @param [String] temporary_path   The path of the file to store temporarily.
# @param [String] destination_path location of the file to copy after record.
#
################################################################################
def stop_recording_dsp_output( record_file_name,
                               temporary_path,
                               destination_path
                             )
    device = FruitSalad.get_device()
    device.end_compressed_stream_capture( record_file_name,
                                          temporary_path,
                                          destination_path
                                        )
end

################################################################################
#
# @function get_playback_time()
#
# Get the time taken performing only Playback actions.
#
# (no parameters)
#
# @return [Float] Returns total playback time.
#
################################################################################
def get_playback_time()
    device = FruitSalad.get_device()
    time = device.playtime
end

################################################################################
#
# @function simultaneous_digital_play_and_capture
#
# Play and record multiple mono-channel WAV files to different playback device
# channels using the pa_multitrack utility. Channel should be given as a
# zero-indexed integer.
#
# @param [Array<Array>]  track_list  Array of track tuples to play/record:
#                                    of the form:
#                                    [ track_file, playback_number, record_number ]
# @param [Integer]       samples     Record for the given number of samples
# @param [Boolean]       background  Boolean variable to tell the function whether
#                                    play or record in background or not.
#
################################################################################
def simultaneous_digital_play_and_capture( track_list, samples = 480000, background = false, opt={} )
    device = FruitSalad.get_device()
    record = opt[:record] || false
    device.multitrack_playback( track_list, record, samples, background )
end

#######################################################################
# @function initialize_pa_multitrack
#
# Initializes Pa Multitrack.
#
#######################################################################
def initialize_pa_multitrack
    device = FruitSalad.get_device()
    device.initialize_pa_multitrack
end

#######################################################################
# @function analog_playback_completed?
#
# Checks if analog playback is completed.
#
# @return [Boolean]    true if analog playback is completed else false.
#
#######################################################################
def analog_playback_completed?
    device = FruitSalad.get_device()
    type = 'analog'
    return device.playback_completed?( type )
end

#######################################################################
# @function digital_playback_completed?
#
# Checks if digital playback is completed.
#
# @param [Boolean]    background    Either playback is in background or foreground.
#                                        Defaults to false(foreground)
#
# @return [Boolean]    true if digital playback is completed else false.
#######################################################################
def digital_playback_completed?( background = false )
    device = FruitSalad.get_device()
    type = 'digital'
    return device.playback_completed?( type, background )
end

#######################################################################
#
# @function start_recording_dsp_output_and_poll_compressed_node
#
# Starts recording from a compressed stream on the remote device and
#  poll for trigger.
#
# @param [String]  record_file_name Name of the file to capture DSP output
# @param [Integer] sample_rate      Recording sample rate
# @param [Integer] channels         Number of recording channels
# @param [String]  destination_path Path of the record file to store it
# @param [int]  length Number of seconds to record
# @return void
#
#######################################################################
def start_recording_dsp_output_and_poll_compressed_node( record_file_name,
                                                         sample_rate,
                                                         channels,
                                                         destination_path,
                                                         length
                                                       )
    device = FruitSalad.get_device()
    device.start_recording_and_poll_compressed_node( record_file_name,
                                                        sample_rate,
                                                        channels,
                                                        destination_path,
                                                        length
                                                     )
end

################################################################################
#
# @function stop_recording_dsp_output
#
# Invokes target specific method to stop the compressed data from the output
# of DSP.
#
# @param [String] record_file_name Name of the file to capture the DSP output
#                                   in it
# @param [String] temporary_path   The path of the file to store temporarily.
# @param [String] destination_path location of the file to copy after record.
#
################################################################################
def stop_recording_compressed_dsp_output( record_file_name,
                                          temporary_path,
                                          destination_path
                                        )
    device = FruitSalad.get_device()
    device.stop_recording_dsp_output( record_file_name,
                                      temporary_path,
                                      destination_path
                                    )
end
#########################################END#####################################