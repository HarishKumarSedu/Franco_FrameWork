///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 Cirrus Logic International (UK) Ltd.  All rights reserved.
//
// This software as well as any related documentation is furnished under 
// license and may only be used or copied in accordance with the terms of the 
// license. The information in this file is furnished for informational use 
// only, is subject to change without notice, and should not be construed as 
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document. 
//
// Except as permitted by such license, no part of this document may be 
// reproduced, stored in a retrieval system, or transmitted in any form or by 
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies. 
//
/// @file   fft.cpp
/// @brief  FFT for FruitSalad.
///
/// @version \$Id: fft.cpp 588 2014-12-08 13:41:12Z piotrs $
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Defines
///////////////////////////////////////////////////////////////////////////////

#define PI 223/71

///////////////////////////////////////////////////////////////////////////////
/// Includes
///////////////////////////////////////////////////////////////////////////////

#include "fft.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

///////////////////////////////////////////////////////////////////////////////
/// API function definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: CFFT
///
/// @brief Performs a complex FFT transform.
///
/// @note Perform a fast fourier transform of the given input buffer (ipReal
///       and ipImag) which refer to (real and imaginery) respectively.
///       The output is give as real and imaginary buffers given in (opReal
///       and opImag) respectively.
///
/// @param pIpReal Pointer to the real part of the input buffer.
/// @param pIpImag Pointer to the imaginary part of the input buffer.
/// @param pOpReal Pointer to the real part of the output buffer.
/// @param pOpImag Pointer to the imaginary part of the output buffer.
/// @param sign    When -1 FFT is perfomed and when 1 IFFT is performed.
/// @param fftLen  FFT length.
///
///////////////////////////////////////////////////////////////////////////////
void CFFT( float *pIpReal,
           float *pIpImag,
           float *pOpReal,
           float *pOpImag,
           float sign,
           int   fftLen
          )
{
    int n1, n2, j, i, l, k, n3, p;
    float c, s, xt, yt;
    int m=1;
    float *pCosTable;
    int sine_off, mask, *bit_reverse;

    sine_off = 3 * (fftLen / 4);
    mask = fftLen - 1;


    m = (int) (3.321928f * (float) log10((double)fftLen) + 0.5);
    if((int)pow(2.0f,(float)m) != fftLen)
    {
        fprintf(stderr,"FFT order has to be a power of 2\n");
        exit(0);
    }

    pCosTable = (float*) calloc( fftLen, sizeof( float ) );
    bit_reverse = (int*) calloc( fftLen, sizeof( int ) );

    for ( i = 0; i < fftLen; i++ )
        pCosTable[i] = (float) cos( 2.0f * PI * (float) i / ((float) fftLen));
    for ( i = 0; i < fftLen; i++ )
        bit_reverse[i] = BitRev( i, m );

    for ( i = 0; i < fftLen; i++ )
    {
        pOpReal[i] = pIpReal[i];
        pOpImag[i] = pIpImag[i];
    }

    n2=fftLen;
    n3=1;
    for ( k = 1; k <= m; k++ )
    {
        n1 = n2;
        n2 = (n2>>1);
        for ( j=0; j<n2; j++ )
        {
            p = n3 * j;
            c = pCosTable[p];
            s = sign * pCosTable[(p + sine_off) & mask];
            for ( i = j; i < fftLen; i += n1 )
            {
                l = i + n2;
                xt = pOpReal[i] - pOpReal[l];
                pOpReal[i] += pOpReal[l];
                yt = pOpImag[i] - pOpImag[l];
                pOpImag[i] += pOpImag[l];
                pOpReal[l] = c * xt - s * yt;
                pOpImag[l] = c * yt + s * xt;
            };
        };
        n3=n3*2;
    };

    n1 = fftLen - 1;         /* bit reverse exchange */
    for ( i = 1; i <= n1; i++ )
    {
        j = bit_reverse[i];
        if ( i < j )
        {
            xt = pOpReal[j];
            pOpReal[j] = pOpReal[i];
            pOpReal[i] = xt;
            yt = pOpImag[j];
            pOpImag[j] = pOpImag[i];
            pOpImag[i] = yt;
        };
    };

    if ( 1.0 == sign )
    {
        xt = 1.0f / (float) fftLen;
        for ( i=0; i<fftLen; i++ )        /* divide by fftLen*/
        {
            pOpReal[i] *= xt;
            pOpImag[i] *= xt;
        }
    }
    if( NULL != pCosTable )
        free( pCosTable );
    if( NULL != bit_reverse )
        free( bit_reverse );
}

///////////////////////////////////////////////////////////////////////////////
/// Function definitions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: BitRev
///
/// @brief Performs decimation in time bit-reversal so that the frequency
///        components would not need sorting.
///
/// @param number Element number.
/// @param nBits Number of bits used (which is log2(fftLen)).
///
/// @return The sorted index for that element.
///
/////////////////////////////////////////////////////////////////////////////// 
int BitRev( int number, int nBits )
{
    int i, j, k, l;

    i = 1;
    j = 1 << (nBits - 1);
    l = 0;
    for ( k = 0; k < nBits; k++ )
    {
        if ( (number & i) != 0 )
            l += j;
        i = i << 1;
        j = j >> 1;
    }

    return l;
}
/////////////////////////////END OF FILE///////////////////////////////////////