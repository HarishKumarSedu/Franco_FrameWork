###############################################################################
##
## Copyright (c) 2015-2017 Cirrus Logic International (UK) Ltd.  All rights reserved.
##
## This software as well as any related documentation is furnished under
## license and may only be used or copied in accordance with the terms of the
## license. The information in this file is furnished for informational use
## only, is subject to change without notice, and should not be construed as
## a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic
## International (UK) Ltd assumes no responsibility or liability for any errors
## or inaccuracies that may appear in this document or any software that may be
##  provided in association with this document.
##
## Except as permitted by such license, no part of this document may be
## reproduced, stored in a retrieval system, or transmitted in any form or by
## any means without the express written consent of Cirrus Logic International
## (UK) Ltd or affiliated companies.
##
## @file pa_multitrack.rb
## @brief Methods relating to the use of the pa_multitrack utility for getting
##        audio onto the Blue Box.
##
## @warning
##     This software is specifically written for Cirrus Logic devices.
##     It may not be used with other devices.
##
################################################################################

#
# Requires
#
require 'configuration'
require 'csv'
require 'logfw'

track_list_dir = Conf.property( 'TracklistFileDir', 'tmp' )
track_list_dir = File.join( ENV['FRUITSALAD_HOME'], track_list_dir )

# Constants for error file Paths
REC_ERROR_FILE = "#{track_list_dir}/record_error"
PLAY_ERROR_FILE = "#{track_list_dir}/play_error"

unless Dir::exist?( track_list_dir )
    Dir::mkdir( track_list_dir )
end

################################################################################
#
# PaMultitrack encapsulates the functionality of the pa_multitrack utility.
# Allowing multi-channel playback using ASIO and a TS2000 'blue box'.
#
################################################################################
class PaMultitrack

    attr_accessor :rec_thread
    attr_accessor :play_thread

    #
    # Boolean which indicates whether to retry or not if Buffer overrun occurs.
    #
    RETRY_IF_BUFFER_OVERRUN = Conf.property(:Retry_If_Buffer_OverRun, false)

    @@pa_mutlitrack_setup = false

    private

    ############################################################################
    #
    # @function set_up
    #
    # Set up the pa_multitrack utility for playback by performing the command:
    # pa_multitrack <HOST_API> "<DEVICE_NAME>" <SAMPLE_RATE> <BIT_DEPTH> <BUFFER_SIZE>.
    #
    # (no parameters)
    #
    ############################################################################
    def set_up
        @@pa_mutlitrack_setup = true
        # Configuration key Multitrack_Device, specifies the name of the device
        # as it appears in the pa_multitrack setup dialog.
        @device_string = Conf.property( :Multitrack_Device, 'USBStreamer ASIO Driver' )

        # The sample rate to use with pa_multitrack. Overwritten with configuration
        # key Multitrack_SampleRate
        @sample_rate = Conf.property( :Multitrack_SampleRate, 48000 )

        # The number of bits per sample. Overwritten with Multitrack_BitDepth
        # configuration key.
        @bit_depth = Conf.property( :Multitrack_BitDepth, 16 )

        # The number of samples to queue for playback per channel at a time.
        # Overwritten with the Multitrack_BufferSize configuration key.
        @buffer_size = Conf.property( :Multitrack_BufferSize, 512 )

        $LOG.debug `pa_multitrack ASIO "#{@device_string}" #{@sample_rate} #{@bit_depth} #{@buffer_size}`
    end

    ############################################################################
    #
    # @function create_csv
    #
    # Write our list of playback tracks to a CSV file to be used with pa_multitrack.
    # The CSV file will have rows of the form:
    #     '<track file>, <record_channel_num>, <play_channel_num>'
    #
    # Each track file should be a mono recording.
    #
    # @param [Array<Array>]  track_list  Array of track tuples to play/record:
    #                                    of the form:
    #                                    [ track_file, play_channel_num, record_channel_num ]
    # @param [Boolean]       record      Boolean variable to tell the function whether
    #                                    to record tracklist or playback tracklist.
    #
    # @return The relative path of the CSV file created.
    #
    ############################################################################
    def create_csv( track_list, record )
        track_list_dir = Conf.property( 'TracklistFileDir', 'tmp' )
        track_list_dir = File.join( ENV['FRUITSALAD_HOME'], track_list_dir )
        unless Dir::exist?( track_list_dir )
            Dir::mkdir( track_list_dir )
        end
        if record
            filename = File.join( "#{track_list_dir}/tracklist_record.csv" )
        else
            filename = File.join( "#{track_list_dir}/tracklist.csv" )
        end
       CSV.open( filename, 'w' ) do |csv|
           track_list.each do |track_name, play_channel_num , record_channel_num |
               csv << [ track_name, record_channel_num, play_channel_num ]
           end
       end
        return filename
    end

    public
    ############################################################################
    #
    # @function re_init_pa_multitrack
    #
    # Updates the pa_mutlitrack_setup so that set_up is triggered again with different pa_mutlitrack configuration.
    #
    ############################################################################
    def re_init_pa_multitrack
        @@pa_mutlitrack_setup = false
    end

    ############################################################################
    #
    # @function play_tracklist
    #
    # Write out our tracklist as CSV, then immediately play it using pa_multitrack.
    #
    # @param [Array<Array>]  track_list_play  Array of track tuples to play/record:
    #                                    of the form:
    #                                    [ track_file, playback_number, record_number ]
    # @param [Boolean]       record      Boolean variable to tell the function whether
    #                                    to record or not.
    # @param [Integer]       samples     Record for the given mumber of samples
    # @param [Boolean]       background  Boolean variable to tell the function whether
    #                                    play or record in background or not.
    #
    ############################################################################
    def play_tracklist( track_list_play, record = true, samples = 480000, background = false )
        txt_extension = ".txt"
        underscore = "_"
        csv_file = create_csv( track_list_play, record )
        unless @@pa_mutlitrack_setup
            set_up
        end
        if background
            if record
                @rec_thread = Thread.new{
                                rec_err_file = REC_ERROR_FILE + underscore + Time.now.to_i.to_s + txt_extension
                                command_line = "pa_multitrack \"#{csv_file}\" #{samples} 2>#{rec_err_file}"
                                system( command_line )
                                if RETRY_IF_BUFFER_OVERRUN
                                    re_run_multitrack_if_buffer_overrun(rec_err_file, command_line)
                                else
                                    log_the_error_message( rec_err_file )
                                end
                              }
            else
                @play_thread = Thread.new{
                                play_err_file = PLAY_ERROR_FILE + underscore +Time.now.to_i.to_s + txt_extension
                                command_line = "pa_multitrack \"#{csv_file}\" 2>#{play_err_file}"
                                system( command_line )
                                if RETRY_IF_BUFFER_OVERRUN
                                    re_run_multitrack_if_buffer_overrun(play_err_file, command_line)
                                else
                                    log_the_error_message( play_err_file )
                                end
                               }
            end
            # Initialize time for pa_multitrack to setup.
            sleep 1.5
        else
            if record
                rec_err_file = REC_ERROR_FILE + underscore + Time.now.to_i.to_s + txt_extension
                command_line = "pa_multitrack \"#{csv_file}\" #{samples} 2>#{rec_err_file}"
                value = system( command_line )
                if RETRY_IF_BUFFER_OVERRUN
                    re_run_multitrack_if_buffer_overrun(rec_err_file, command_line)
                else
                    log_the_error_message( rec_err_file )
                end
            else
                play_err_file = PLAY_ERROR_FILE + underscore + Time.now.to_i.to_s + txt_extension
                command_line = "pa_multitrack \"#{csv_file}\" 2>#{play_err_file}"
                value = system( command_line )
                if RETRY_IF_BUFFER_OVERRUN
                    re_run_multitrack_if_buffer_overrun(play_err_file, command_line)
                else
                    log_the_error_message( play_err_file )
                end
            end
        end
    end

    ############################################################################
    #
    # @function re_run_multitrack_if_buffer_overrun
    #
    # Checks for Buffer Over Run error,if found then retries for 3 times.
    #
    # @param [String]  error_file_name  Error file path.
    #
    # @param [String] command_line      System command line to retry
    #
    # @raise [RuntimeError]    Raises an error if Buffer overrun is observed after retrying it 3 times.
    #
    ############################################################################
    def re_run_multitrack_if_buffer_overrun( error_file_name, command_line )
        count = 0
        unless File.zero?( error_file_name )
            # Retrying 3 times.
            while true
                if count >= 3
                    raise( 'Buffer Overrun Issue occured more than 3 times.' +
                           $LOG.error('Buffer Overrun Issue occured more than 3 times.').to_s )
                end
                count += 1
                file_con = File.read( error_file_name )
                if file_con.include?( "System.Exception: Buffer overrun!" )
                   $LOG.info "Buffer Overrun Issue occured, Retrying - #{count}"
                   system( command_line )
                elsif !file_con.nil?
                    log_the_error_message( error_file_name )
                else
                   break
                end
            end
        end
        File.delete( error_file_name )
    end

    ############################################################################
    #
    # @function log_the_error_message
    #
    # Read and Log the PA Multitrack exception from file if exception exists
    #
    # @raise [RuntimeError]    Raises the PA Multitrack exception
    #
    # @param [String] error_file_name      Error file name
    #
    ############################################################################
    def log_the_error_message( error_file_name )
        unless File.zero?( error_file_name )
            error_message = File.read( error_file_name )
            raise(error_message + $LOG.error(error_message).to_s )
        end
        File.delete( error_file_name )
    end

end
################################# END OF FILE #################################