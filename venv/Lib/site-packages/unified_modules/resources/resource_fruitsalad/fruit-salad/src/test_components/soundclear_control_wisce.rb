################################################################################
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   soundclear_control_wisce.rb
### @brief  Implementation of SoundClear Control testing on the WISCE target.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

require 'configuration'
require 'test_components/wisce_firmware_interface'
require 'wisce_host_buffer_read'
require 'logfw'
include FruitSalad

###############################################################################
#
# Encapsulates all of the high-level functionality expected from SoundClear
# Control as a component of WISCESalad.
#
###############################################################################
class SoundClearControlForWISCE < WISCEFirmwareInterface

    # The name of the algorithm
    AlgorithmName = 'Ez2 Control'
    SampleRate = Conf.property( :SampleRate, 16000 )

    FloridaInterruptStatusRegName = 'Interrupt Status 2'
    FloridaInterruptMaskRegName = 'Interrupt Status 2 Mask'

    ClearwaterInterruptStatusRegName = 'IRQ1_Status_11'
    ClearwaterInterruptMaskRegName = 'IRQ1_Mask_11'

    DSP_IRQ1_EINT_BIT = 0x1
    DSP_IRQ1_EINT_UNMASK = 0xffe

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor. Sets the attributes needed by the interface.
    #
    # @param [DeviceInterface] device The parent device object.
    #
    ###########################################################################
    def initialize( device )
        @algorithm_name = AlgorithmName
        @time_taken_to_read = 0
        super
    end

    ###########################################################################
    #
    # @function triggered?
    #
    # Has SoundClear Control been triggered?
    #
    # @return [Bool] True if the firmware has been triggered at least once.
    #
    # @raise [RunTimeError] If the firmware's attributes cannot be found in memory.
    #
    ###########################################################################
    def triggered?
        sleep 2 # There needs to be a delay between the trigger phrase and
                # reading the register so the hardware can update.
        firmware_id = firmware_data.fetch( "id", nil )
        phrase_found_counter_name = "#{firmware_id}_TRIGGER_PHRASE_FOUND_COUNTER"
        phrase_found_counter = @device.read_element_value( phrase_found_counter_name )
        if phrase_found_counter.nil?
            raise "#{phrase_found_counter_name} not found."
        end
        return phrase_found_counter.to_i != 0
    end

    ###########################################################################
    #
    # @function interrupt_raised
    #
    # Reads interrupt status register bit
    #
    # @return [Integer] Returns interrupt status register bit.
    #
    # @raise [RunTimeError] If the firmware id could not be recognized.
    #
    ###########################################################################
    def interrupt_raised
        status = nil
        firmware_id = firmware_data.fetch( 'id', nil )
        if ( 'FIRMWARE_FLORIDA_EZ2CONTROL' == firmware_id )
            status = @device.read_element_value( FloridaInterruptStatusRegName )
        elsif ( 'FIRMWARE_CLWR_EZ2CONTROL' == firmware_id ||
                'FIRMWARE_CLWR_EZ2CONTROL30' == firmware_id )
            status = @device.read_element_value( ClearwaterInterruptStatusRegName )
        else
            raise 'Firmware id could not be recognized'
        end
        status = ( status.hex & DSP_IRQ1_EINT_BIT )
        return status
    end

    ###########################################################################
    #
    # @function time_taken
    #
    # Gets the time taken for the host to read and empty the active full buffer
    #
    # @return [Float] Returns measured time
    #
    ###########################################################################
    def time_taken
        return @time_taken_to_read.to_f
    end

    ###########################################################################
    #
    # @function clear_irq
    #
    # unmasks and clears the irq status bit.
    #
    # @return [none] Returns none.
    #
    # @raise [RunTimeError] If the firmware id could not be recognized.
    #
    ###########################################################################
    def clear_irq
        firmware_id = firmware_data.fetch( 'id', nil )
        if ( 'FIRMWARE_FLORIDA_EZ2CONTROL' == firmware_id )
            reg_value = @device.read_element_value( FloridaInterruptMaskRegName )
            reg_value = ( reg_value.hex & DSP_IRQ1_EINT_UNMASK )
            @device.write_element_value( FloridaInterruptMaskRegName, reg_value )
            reg_value = @device.read_element_value( FloridaInterruptStatusRegName )
            reg_value = ( reg_value.hex | DSP_IRQ1_EINT_BIT )
            @device.write_element_value( FloridaInterruptStatusRegName, reg_value )
        elsif ( 'FIRMWARE_CLWR_EZ2CONTROL' == firmware_id ||
                'FIRMWARE_CLWR_EZ2CONTROL30' == firmware_id  )
            reg_value = @device.read_element_value( ClearwaterInterruptMaskRegName )
            reg_value = ( reg_value.hex & DSP_IRQ1_EINT_UNMASK )
            @device.write_element_value( ClearwaterInterruptMaskRegName, reg_value )
            reg_value = @device.read_element_value( ClearwaterInterruptStatusRegName )
            reg_value = ( reg_value.hex | DSP_IRQ1_EINT_BIT )
            @device.write_element_value( ClearwaterInterruptStatusRegName, reg_value )
        else
            raise 'Firmware id could not be recognized'
        end
    end

    ###########################################################################
    #
    # @function read_svscore
    #
    # Reading svscore of SoundClear Control
    #
    # @return [Integer] score The matching score of the trigger
    #
    # @raise [RunTimeError] If the firmware's attributes cannot be found in memory.
    #
    ###########################################################################
    def read_svscore
        pid_svscore_name = 'SENSORY_ALGORITHM_SENSORY_PID_SVSCORE'
        pid_svscore = @device.read_element_value( pid_svscore_name )
        if pid_svscore.nil?
            raise "#{pid_svscore_name} not found."
        end
        return pid_svscore.hex
    end

    ###########################################################################
    #
    # @function wait_for_interrupt
    #
    # Checks interrupt has received to host or not for every 0.1 seconds and
    # waits in polling loop till host received an interrupt and exits if
    # interrupt has not raised with in given time.
    #
    # @param [Float] interrupt_time_out Maximum time out value to exit after it
    #                                   from the interrupt polling loop.
    #
    # @raise [RuntimeError] wait_for_interrupt will raise an exception if Sound
    #                       clear control has not raised any interrupt.
    #
    ###########################################################################
    def wait_for_interrupt( interrupt_time_out )

        # Assigning interrupt poll time with 0.1 seconds
        interrupt_poll_time = 0.1
        wait_time = 0

        while( wait_time <= interrupt_time_out )
            # Finding host has received any interrupt?
            status = interrupt_raised()
            if ( 0 != status )
                break
            end
            sleep interrupt_poll_time
            wait_time += interrupt_poll_time
        end
        if ( 0 == status )
            raise 'Host did not receive any interrupt'
        end
    end

    ###########################################################################
    #
    # @function buffer_test
    #
    # Concatenates the given trigger file and data file, plays the resultant
    # file and captures compressed stream.
    #
    # @note This also sets streaming timeout is set to infinite by writing 0 to
    #       the stream timeout field (see SC control release notes). This
    #       allows the buffer to stream the data. Writing 0 in to include
    #       trigger phrase field causing SC control host interrupt and trigger
    #       to fail and this is observed on SCC 3.0 not on SCC 2.5
    #
    # @param  [String]      trigger_file  Name of a trigger file to play.
    # @param  [String]      data_file     Name of a data file to play.
    # @param  [Hash]        opts          Options to play a file with.
    # @option opts [String] :type         Type of output format is either
    #                                     compressed or uncompressed. Defaults
    #                                     to compressed.
    # @option opts [String] :action       Action to either include or exclude
    #                                     trigger phrase.
    # @option opts [Float]  :stream_delay Amount of delay in seconds before
    #                                     recording.
    #
    # @return [Integer] Returns buffer test status either success or buffer
    #                   read errors.
    #
    # @raise [RuntimeError] buffer_test will raise an exception if firmware ID
    #                       can not be fetched or When invalid stream type
    #                       given or When invalid trigger phrase action given.
    #
    ###########################################################################
    def buffer_test( trigger_file, data_file, opts = {} )

        stream_delay = opts.fetch( :stream_delay, 1.0 )
        # Get Firmware ID
        firmware_id = firmware_data.fetch( 'id', nil )
        if firmware_id.nil?
            raise 'Firmware ID could not be fetched'
        end

        # Setting buffer streaming time out to zero means infinite
        streaming_name = "#{firmware_id}_STREAMING_TIMEOUT"
        @device.write_element_value( streaming_name, 0x0 )

        type = opts.fetch( :type, 'compressed' )
        if( 'uncompressed' == type )
            compression = "#{firmware_id}_APPLY_COMPRESSION"
            @device.write_element_value( compression, 0x0 )
            $LOG.info 'Processing uncompressed stream data...'
        elsif( 'compressed' == type )
            $LOG.info 'Processing compressed stream data...'
        else
            raise 'Invalid stream type given...'
        end

        action = opts.fetch( :action, 'include' )
        if( 'exclude' == action )
            trigger_phrase = 'SENSORY_ALGORITHM_INCLUDETRIGGERPHRASE'
            @device.write_element_value( trigger_phrase, 0x0 )
            $LOG.info 'Excluding Trigger Phrase...'
        elsif( 'include' == action )
            $LOG.info 'Including Trigger Phrase...'
        else
            raise 'Invalid trigger phrase action given...'
        end

        # Calls WISCE host buffer read class initialize method
        @device.host_buffer_read.initialize_host_buffer_struct( firmware_id,
                                                                @core_index
                                                              )

        trigger_length = FruitSalad::track_length( trigger_file )

        # Concatenates trigger file and data file, if data file is present.
        test_file = trigger_file
        unless data_file.nil?
            concatenated = 'tmp/concatenated.wav'
            concat_data = FruitSaladUtils::concatenate_wavefiles( [trigger_file, data_file],
                                                                  SampleRate
                                                                )
            FruitSalad::write_waveform( concatenated, concat_data )
            test_file = concatenated
        end

        @device.playback( test_file, blocking: false )
        # Assigning interrupt time out with twice the trigger length to check
        # interrupt got raised or not.
        interrupt_time_out = trigger_length * 2
        wait_for_interrupt( interrupt_time_out )

        # Output would be needed to set it here, so the other step definition
        # like peak tone verification will need it.
        @device.output = 'decompressed.wav'
        return_value, read_time = @device.host_buffer_read.read_host_buffer_data( firmware_id,
                                                                                  @device.output
                                                                                )
        @device.end_playback()
        return return_value
    end

    ###########################################################################
    #
    # @function measure_time
    #
    # measures time taken to empty the active full output buffer after IRQ has
    # raised
    #
    # @param [String]  trigger_file Name of a trigger file to play.
    #
    # @return [Integer] Returns buffer read status either success or buffer
    #                   read errors.
    #
    ###########################################################################
    def measure_time( trigger_file )

        # Get Firmware ID
        firmware_id = firmware_data.fetch( 'id', nil )

        # Setting buffer streaming time out to zero means infinite
        streaming_name = "#{firmware_id}_STREAMING_TIMEOUT"
        @device.write_element_value( streaming_name, 0x0 )

        # Calls WISCE host buffer read class initialize method
        @device.host_buffer_read.initialize_host_buffer_struct( firmware_id,
                                                                @core_index
                                                              )

        @device.playback( trigger_file, blocking: false )

        # Assigning interrupt time out with twice the trigger length to check
        # interrupt got raised or not.
        trigger_length = FruitSalad::track_length( trigger_file )
        interrupt_time_out = trigger_length * 2
        wait_for_interrupt( interrupt_time_out )

        # Output would be needed to set it here, so the other step definition
        # like peak tone verification will need it.
        @device.output = 'decompressed.wav'

        return_value, @time_taken_to_read = @device.host_buffer_read.read_host_buffer_data( firmware_id,
                                                                                            @device.output
                                                                                          )
        $LOG.debug "Time taken to empty the buffer is #{@time_taken_to_read}"

        @device.end_playback()
        return return_value
    end

end

################################# END OF FILE #################################