###############################################################################
###
### Copyright (c) 2016 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file  target_operations.rb
### @brief Encapsulates all the test methods which deals with the target.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

require 'logfw'
require 'test_method_definitions/miscellaneous_utils'

###############################################################################
#
# @function connect_to_target
#
# Connects to the target device and lists the connected devices.
#
# (no parameters)
#
###############################################################################
def connect_to_target( )
    device = FruitSalad.get_device()
    # Listing the connected devices with Communication protocol.
    if "#{device.class}".eql?("FruitSalad::WISCESalad")
        device.list_devices()
    end
    device.setup
end

###############################################################################
#
# @function set_device_as_nil
#
# Connects to the target device and set the device to nil.
#
# (no parameters)
#
###############################################################################
def set_device_as_nil()
    FruitSalad.set_device_nil()
end

###############################################################################
#
# @function copy_file
#
# Copies file to the destination path from the given source location and makes
# it as executable if it is marked as executable
#
# @param [String]  destination_path is the path to copy there.
# @param [String]  source_path      is the path to the copy from.
# @param [String]  routing_file     The name of the file to copy.
# @param [Boolean] is_executable    By default it is false, if it is true the
#                                   given file will be marked as executable.
# @param [Boolean] saladmix_binary  By default it is false, if it is true the
#                                   given file will be set as saladmix binary.
# @param [Hash]   opts              supports: [Boolean] is_enrollment - Whether
#                                   the given files are enrollment files
#                                   or not.
#                                   supports [String] destination_file -To change
#                                    the name of given file
#
###############################################################################
def copy_file( destination_path,
               source_path,
               routing_file,
               is_executable = false,
               saladmix_binary = false,
               opts={}
             )
    is_enrollment = opts.fetch( :is_enrollment , false )
    destination_file = opts.fetch( :destination_file , nil)

    device = FruitSalad.get_device()
    if is_enrollment == true
        device.upload( routing_file,
                       destination_path,
                       source_path,
                       is_executable,
                       is_enrollment:is_enrollment,
                       destination_file:destination_file
                     )
    else
        device.upload( routing_file,
                       destination_path,
                       source_path,
                       is_executable,
                       destination_file:destination_file
                     )
    end

    if saladmix_binary
        device.init_saladmix( routing_file, destination_path )
    end
end

###############################################################################
#
# @function remove_file
#
# Removes the file from the given file from given path
#
# @param [String]  remote_dir      is the path to the remove from in remote device.
# @param [String]  remote_file     The name of the file to remove.
#
###############################################################################
def remove_file( remote_file, remote_dir )
    device = FruitSalad.get_device()
    device.remove( remote_file, remote_dir )
end

###############################################################################
#
# @function load_routing_file
#
# Copies the routing file to the destination path from the given source location
# and executes it on the target platform.
#
# @param [String]  destination_path is the path to copy there.
# @param [String]  source_path      is the path to the copy from.
# @param [String]  routing_file     The name of the file to copy.
#
###############################################################################
def load_routing_file( destination_path, source_path, routing_file )
    device = FruitSalad.get_device()
    device.usecase_from_file( routing_file,
                              :source_path=> source_path,
                              :destination_path=>destination_path
                            )
end

###############################################################################
#
# @function load_bin_file
#
# Loads the bin file in WISCE from source path.
#
# @param [String]  destination_path is the path to copy there.
# @param [String]  source_path      is the path to take bin file from.
# @param [String]  bin_file         The name of the bin file to load.
#
###############################################################################
def load_bin_file( destination_path, source_path, bin_file )
    device = FruitSalad.get_device()
    device.usecase_from_file( bin_file,
                              :source_path=> source_path,
                              :destination_path=>destination_path,
                              :type=> ".bin"
                            )
end

################################################################################
# @function read_register_by_address
#
# Reads the value from the particular register address
#
# @param [String] Register address
#
# @param [Fixnum] bytes   Amount of bytes to read.
#
# @param [Fixnum] bits    Bit width of the register map
#
# @return It returns the value from the register address
#
################################################################################
def read_register_by_address( address, bytes, bits )
    device = FruitSalad::get_device
    if "#{device.class}".eql?("FruitSalad::RemoteSalad")
        device.read_memory_value( address.to_s(16), bytes, bits )
    elsif "#{device.class}".eql?("FruitSalad::WISCESalad")
        byte_array = device.read_block_data(address, bytes, true)
        convert_byte_array_to_hex_array(byte_array,bits)
    end
end

################################################################################
# @function write_register_by_address
#
# Writes a block of data to the arbitrary memory locations of the codec device
#
# @param [Hex/Integer] address  WISCE - (Hex)   Hex address  prefixed with 0x
#                                               in the codecs' memory( Ex : 0x012A ).
#                                    Remote - (Integer)  address in the codecs' memory.
#
# @param [Integer Array] value  Array of values to be written to memory locations.
#
# @param [Fixnum] bytes   Amount of bytes to write,by default its 2 bytes.
#
# @param [Fixnum] bits    Bit width of the register map,by default its 32 bits.
#
# @param [Boolean] read_from_device  True or False to write in to device
#                                     or in to cache.
#
################################################################################
def write_register_by_address( address, value, bytes = 2, bits = 32, read_from_device = true )
    device = FruitSalad::get_device
    if "#{device.class}".eql?("FruitSalad::WISCESalad")
        value = convert_integer_array_to_byte_array( value , bits )
        device.write_block_data( address, value, read_from_device )
    elsif "#{device.class}".eql?("FruitSalad::RemoteSalad")
        device.write_block_data( address.to_s(16), value, bytes, bits )
    end
end

##############################################################################
#
# @function read_register_by_name
#
# @param [String] register_name     Name of register to read
# @return returns value of the register
#
#############################################################################
def read_register_by_name( register_name )
    device = FruitSalad.get_device()
    reg_value = device.read_element_value( register_name )
    return reg_value
end

##############################################################################
#
# @function write_register_by_name
#
# @param [String]    register_name    Name of register to read
# @param [Integer]   value            value to be write in register
# @return [RuntimeError or nil]       If the given value is not a valid integer
#                                     or convertible string and return nil, if
#                                     given register name is invalid.
#
#############################################################################
def write_register_by_name( register_name, value )
    device = FruitSalad.get_device()
    device.write_element_value( register_name, value )
end

##############################################################################
#
# @function get_device_name
#
# @return returns name of the connected device
#
#############################################################################
def get_device_name()
    device = FruitSalad.get_device()
    device_name = device.get_current_device_name
    $LOG.info("Connected device is: #{device_name}")
    return device_name
end

###############################################################################
# @function connect_to_device
#
# Establish a connection to the given device on given system.
#
# @param [Hash]   opts     Key value pairs of system name, device name, device address
#                          and device file. we have to use arguments as
#                          :system_name - Name of the system to connect to (Ex: Aardvark)
#                          :device_name - Name of the device to connect to(Ex: WM8281)
#                          :device_address - The address of the device,Ex:0x80
#                          :device_file - Device file name,
#                           Ex: CS35L34_RegMap_RevA_0x80.xml
#
###############################################################################
def connect_to_device( opts = {} )
    device = FruitSalad.get_device()
    device.connect_target_device( opts )
end

############################################################################
# @Function reset_device
#       Resets the device.
# @param device_name that need to be reset
#
###########################################################################
def reset_device( device_name )
    device = FruitSalad.get_device()
    device.lochnagar_reset( device_name )
end

############################################################################
# @Function get_register_default_value
#
# Gets default value of a register
# @param register_name Name of register
#
# @return returns default value of the register
#
#############################################################################
def get_register_default_value( register_name )
    device = FruitSalad.get_device()
    device.get_default_element_value( register_name )
end

################################################################################
#
# @function read_mixer_property
#
# Retrieve the status of a TinyAlsa mixer control using tinymix on the target device.
#
# @param [String] key    The name of the mixer control.
#
# @param [Fixnum] offset Optional argument valid for byte controls.
#                        Indicates that the function should return
#                        only a value with a given offset (# bytes)
#                        into the control.
#
#@return [nil|String] The value of that control.
#
################################################################################
def read_mixer_property( key, offset = nil)
    device = FruitSalad.get_device()
    value = device.mixer_property( key, offset )
end

#######################################################################
#
# @function read_controls
#
# Reads all the ALSA controls in the target device and save to a file.
#
# @return [nil]
#
#######################################################################
def read_controls()
    device = FruitSalad.get_device()
    device.mixer_controls_dump()
end

#######################################################################
#
# @function load_modules
#
#Loads all modules that are given in the input.
#
# @Param [Array] modules Names of the modules to load.
#
#@param [Option] opts    enumerate - This option is used to check
#                        boot done fuctionality and system enumeration
#                        for VEGA.
#
# @return void
#
#######################################################################
def load_modules( modules, opts={} )
    enumerate = opts.fetch( :enumerate, false )
    device = FruitSalad.get_device()
    sleep_time = Conf.property( :sleep_time, nil )
    if enumerate == true
        device.load_all_modules( modules )
        # Time for setting modules
        sleep sleep_time
        enumerate()
    else
        device.load_all_modules( modules )
    end
end

#######################################################################
#
# @function enumerate
#
# check for boot done fuctionality and system enumeration for VEGA.
#
# @Param [nil]
#
# @return void
#
#######################################################################
def enumerate()
    device = FruitSalad.get_device()
    state = device.state()
    sleep_time = Conf.property( :sleep_time, nil )
    if state == 'INACTIVE'
        device.set_boot()
        # Time for setting boot and changing state
        sleep sleep_time
        state = device.state()
        if state == 'INACTIVE'
            $LOG.error "state is INACTIVE"
            raise "state is INACTIVE"
        else
            $LOG.info "state is Active"
        end
    else
        $LOG.info "state is Active"
    end
end

#######################################################################
#
# @function unload_modules
#
# Unloads all modules that are given in the input.
#
# @Param [Array] modules Names of the modules to unload.
# @param [Hash]   opts      Optional arguments.
#
# @option opts [String] :error_expected For any negative tests
#                                               if the error is expected or not
# @return void
#
#######################################################################
def unload_modules( modules, opts = {}  )
    expected_res = opts.fetch( :error_expected, nil )
    device = FruitSalad.get_device()
    device.unload_all_modules( modules, error_expected: expected_res )
end

#######################################################################
#
# @function check_for_aov_trigger
#
# Checks aov triggered or not
#
# @param [nil]
# @return [Int] Number bytes data transmitted
#
#######################################################################
def check_for_aov_trigger()
    device = FruitSalad.get_device()
    status = device.check_for_trigger()
    return status
end

#######################################################################
#
# @function set_mixer_control
#
# Sets a value to a TinyAlsa mixer control on the remote device.
#
# @note You can only set one value at an offset.
#
# @param [String] key     Name of the control to set.
# @param [String] value   Value(s) of to set to the control.
# @param [Integer] offset In case of multi-valued controls an offset can
#                         be provided to indicate which value should be
#                         set (instead of overwriting the entire
#                         control).
# @param [Option] opts    execution_time - This option is used for setting key
#                         value as integer bypassing the logic for parsing value
#                         for hex/number/switch. This option is used currently
#                         for tests measuring execution time taken for executing
#                         mixer controls.
#
# @return void
#
################################################################################
def set_mixer_control( key, value, offset=nil, opts={} )
    execution_time = opts.fetch( :execution_time, nil )

    device = FruitSalad.get_device()

    if execution_time.nil?
        device.set_mixer_property( key, value, offset )
    else
        device.set_mixer_property( key, value, offset, execution_time:true )
    end
end

#################################################################################
#
# @function set_nanomix_control
# sets a value to a nanomixer control on the remote device
#
# @param [String] key     Name of the control to set.
# @param [String] value   Value(s) of to set to the control.
#
# @return [true or false]
#################################################################################
def set_nanomix_control( key, value )
    device = FruitSalad.get_device()
    status = device.set_nanomix_property( key, value )
end

#################################################################################
#
# @function execute_the_command_on_remote_target
# Executes the given commmand on the remote device
#
# @param [command]   Command to execute on remote device.
#
# @return [nil]
#################################################################################
def execute_the_command_on_remote_target( command )
    device = FruitSalad.get_device()
    device.execute_the_command( command )
end
#################################################################################
#
# @function refresh_device
# Refreshes the device registers.
#
# (no paremeters)
#
# @return [nil]
#################################################################################
def refresh_device( )
    device = FruitSalad.get_device()
    device.device_refresh_all()
end
#########################################END#####################################
