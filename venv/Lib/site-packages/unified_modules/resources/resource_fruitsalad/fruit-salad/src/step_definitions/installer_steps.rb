###############################################################################
##
## Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
##
## This software as well as any related documentation is furnished under
## license and may only be used or copied in accordance with the terms of the
## license. The information in this file is furnished for informational use
## only, is subject to change without notice, and should not be construed as
## a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
## (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
## that may appear in this document or any software that may be provided in
## association with this document.
##
## Except as permitted by such license, no part of this document may be
## reproduced, stored in a retrieval system, or transmitted in any form or by
## any means without the express written consent of Cirrus Logic International
## (UK) Ltd or affiliated companies.
##
## @file  installer_steps.rb
## @brief Step-definitions for device pack and WISCE installers.
##
## @version \$Id: installer_steps.rb 847 2015-02-06 15:55:37Z aangus $
##
## @warning
##     This software is specifically written for Cirrus Logic devices.
##     It may not be used with other devices.
##
###############################################################################

require 'logfw'

###############################################################################
#
# @!method Given_I_am_running_installers_from
#
# Specify the location from which installers are to be run from.
#
#       Usage:
#       Given I am running installers from the current directory
#       Given I am running installers from "C:\local\path"
#       Given I am running installers from "\\filer\systems\path\to\location"
#
# @param install_dir Name of the directory in which to launch the installers from.
#
# @example Given I am running installers from the current directory
# @example Given I am running installers from "C:\WISCEArchive\WISCEInstaller"
#
# @raise [RunTimeError] If the specified directory does not exist.
#
###############################################################################
Given( /^I am running installers from (the current directory|".+")$/ ) do |install_dir|

    if 'the current directory' == install_dir
        FruitSalad::Installer.installer_dir_path( '' )
    else
        dir_name_without_quotes = install_dir[1..-2]
        unless File.directory?( dir_name_without_quotes )
            raise "Requested installer directory #{install_dir} does not exist."
        end

        FruitSalad::Installer.installer_dir_path( dir_name_without_quotes )
    end
end

###############################################################################
#
# @!method Given_the_installers_directory_is_clean
#
# Removes all executables from the installers directory.
#
#       Usage:
#       Given the installers directory is clean
#
# (no parameters)
#
###############################################################################
Given(/^the installers directory is clean$/) do
    FruitSalad::Installer.clean_installers_dir
end

###############################################################################
#
# @!method When_I_run_installer
#
# Run the requested installer silently.
#
#       Usage:
#       When I run the <installer_name>
#
# @param installer_name Name of installer to execute silently.
#
# @example Given I am running installers from the current directory
# @example Given I am running installers from "C:\WISCEArchive\WISCEInstaller"
#
# @raise [RunTimeError] If the specified directory does not exist.
#
###############################################################################
When( /^I run the ([\w.]+) installer$/ ) do |installer_name|
    FruitSalad::Installer.run_installer_silently( installer_name )
end

###############################################################################
#
# @!method Given_available_installer
#
# Copies the specified installer to the install directory.
#
# Will lookup the following config keys to try and find files:
#    :Installer_Archive    - where to pull the latest kits from
#    :Device_Pack_Temp_Dir - where to pull device kits from
#
#       Usage:
#       Given available installer <installer_name>
#       Given available installer <installer_name> version <version>
#
# @param installer_name Name of installer to copy into the installer directory.
# @param exe            The .exe extension.
# @param version        Optional string defining the pack version that should be available (e.g. 2.1).
#
# @example Given available installer WISCESetup_3.2.3.3.16960.exe
# @example Given available installer CS4785Setup_Rev2_0.exe
# @example Given available installer CS4785 version 2.0
#
# @raise [RunTimeError] If the specified isntaller cannot be located.
#
###############################################################################
Given( /^available installer (\w+#{REVISION_STR}?(\.exe)?)(?: version (#{REVISION_STR}))?$/ ) do |installer_name, exe, version|
    unless exe.nil?
        installer_name + exe
    end

    unless version.nil?
        installer_name = "#{installer_name}Setup_Rev#{version.gsub('.', '_')}.exe"
    end

    FruitSalad::Installer.copy_installer( installer_name )
end

###############################################################################
#
# @!method Given_Program_is_installed
#
# Check that a given program is installed, if not (un-)install and check again.
#
# This step is intended to place the system into a known state by installing or uninstalling programs
# as required by future steps. An initial check is performed, if this fails FruitSalad attempts to
# put the program into the requested program state. The check is then performed again raising an assertion if not met.
# Will also print version and GUID information on installations of the requested program to the console.
#
#       Usage:
#       Given <program_name> (version <version>)? is (installed|uninstalled)
#       Given the device pack <program_name> (version <version>)? is (installed|uninstalled)
#
# @param program_name Name of the program to check for (un-)installation
# @param version      Optional string defining the pack version that should be installed (e.g. 2.1).
# @param install      Whether we are installing or unistalling the program.
#
# @example Given WISCE is installed
# @example Given WISCEExtensionsSDK is uninstalled
# @example Given the device pack CS9999 is installed
# @example Given the device pack CS9999 version 9.9 is uninstalled
#
# @raise [RunTimeError] If performing the (un-)install operation fails.
# @raise [RunTimeError] If the requested program is in the incorrect state (installed/uninstalled).
#
###############################################################################
Given( /^(?:the device pack )?(\w+)(?: version (#{REVISION_STR}))? is (installed|uninstalled)$/ ) do |program_name, version, install|
    is_install = 'installed' == install

    # do not assert, if it is not installed we will run the relevant installer and check again.
    was_installed = FruitSalad::Installer.check_for_installed_version( program_name, version, is_install, false )

    if !was_installed.empty? && !is_install
        was_installed.each do |program|
            FruitSalad::Installer.run_silent_uninstall( program )
        end
    end

    if was_installed.empty? && is_install
        installer_filename = FruitSalad::Installer.installer_filename( program_name, version )
        FruitSalad::Installer.run_installer_silently( installer_filename )
    end

    # this time assert so that step will fail if given setup is not true.
    was_installed = FruitSalad::Installer.check_for_installed_version( program_name, version, is_install, true )

    unless was_installed.empty?
        $LOG.debug was_installed
    end
end

###############################################################################
#
# @!method Then_Program_has_been_installed
#
# Check a given program has been installed.
#
# Looks up the uninstall keys held in the systems registry as to whether the requested
# program is present on the system. Will also print version and GUID information on
# installations of the requested program to the console.
#
#       Usage:
#       Then <program_name> (version <version>)? has been (installed|uninstalled)
#       Then <program_name> (version <version>)? has not been (installed|uninstalled)
#       Then the device pack <program_name> (version <version>)? has been (installed|uninstalled)
#       Then the device pack <program_name> (version <version>)? has not been (installed|uninstalled)
#
# @param program_name Name of the program to check for (un-)installation
# @param version      Optional string defining the pack version that should be installed (e.g. 2.1).
# @param negate       Optional parameter whether to negate the install parameter (e.g. install becomes uninstall)
# @param install      Whether we are installing or unistalling the program.
#
# @example Then WISCE has been installed
# @example Then WISCEExtensionsSDK has not been installed
# @example Then the device pack CS9999 has been installed
# @example Then the device pack CS9999 version 9.9 has been uninstalled
#
# @raise [RunTimeError] If the requested program is in the incorrect state (installed/uninstalled).
#
###############################################################################
Then( /^(?:the device pack )?(\w+)(?: version (#{REVISION_STR}))? has( not)? been (installed|uninstalled)$/ ) do |program_name, version, negate, install|
    is_install = ('installed' == install) && negate.nil?
    was_installed = FruitSalad::Installer.check_for_installed_version( program_name, version, is_install, true )

    was_installed.each do |program|
        $LOG.debug program
    end
end

###############################################################################
#
# Device Pack Installer Creation
#
###############################################################################

###############################################################################
#
# @!method Given_the_pack_devices_directory_is_empty
#
# Cleans out the Device Pack "Devices" directory.
#
# Expects the following keys to be set in the configuration file:
#    :Device_Pack_Make_Kit_Path - path where to find the make_kit.bat script
#    :Device_Pack_Temp_Dir      - temporary directory from which to create packs
#                                 (contains the pack directory structure).
#    :Device_Pack_Device_Store  - Location from which to pick up devices.
#
#       Usage:
#       Given the pack Devices directory is clean
#
# (no parameters)
#
###############################################################################
Given(/^the pack Devices directory is clean$/) do
    FruitSalad::Installer.clean_devices_dir
end

###############################################################################
#
# @!method Given_device_available_for_packaging
#
# Copies the specified device from a source folder into the Devices directory.
#
# Expects the following keys to be set in the configuration file:
#    :Device_Pack_Make_Kit_Path - path where to find the make_kit.bat script
#    :Device_Pack_Temp_Dir      - temporary directory from which to create packs
#                                 (contains the pack directory structure).
#    :Device_Pack_Device_Store  - Location from which to pick up devices.
#
#       Usage:
#       Given Device <device_name> <RevLetter> is available for packaging
#
# @param device_name Name of the device to be packaged
# @param device_rev  Revision letter (preceeded by Rev) to be packaged.
#
# @example Device CS47L85 RevB is available for packaging
# @example Device WM1111 RevB is available for packaging
#
###############################################################################
Given( /^Device (\w+) (Rev\w+) is available for packaging$/ ) do |device_name, device_rev|
    FruitSalad::Installer.copy_device_to_pack_dir( device_name, device_rev )
end

###############################################################################
#
# @!method When_I_create_device_pack
#
# Runs the make_kit script to generate the Device pack using InstallAware.
#
#       Usage:
#       When I create the device pack <pack_name> version <version>
#       When I create the device pack <pack_name> version <version> replacing <replace_name>
#
# @param [String] pack_name    Name of the pack to be created (a device name for device packs)
# @param [String] version      Version number to be assigned to the pack.
# @param [String] replace_name Device name of the device to be replaced by this device pack.
#
# @example When I create the device pack WM1111 version 2.1
# @example When I create the device pack CS1111 version 2.2 replacing WM1111
#
###############################################################################
When( /^I create the device pack (\w+) version (#{REVISION_STR})(?: replacing (\w+))?$/ ) do |pack_name, version, replace_name|
    FruitSalad::Installer.create_installer( pack_name, version, replace_name )
end

###############################################################################
#
# @!method Then_a_device_pack_installer_created
#
# Check whether isntallaware successfully created an installer (or not).
#
#       Usage:
#       Then a device pack installer has been created
#       Then a device pack installer has not been created
#
# @param [nil|string] negate Whether to negate the check for a device pack installer.
#
# @raise if the device pack installer does not exist when it should
# @raise if the device pack installer exists when it should not
#
###############################################################################
Then( /^a device pack installer has (not )?been created$/ ) do |negate|
    FruitSalad::Installer.check_installer_created?( negate )
end

################################## END OF FILE ##################################