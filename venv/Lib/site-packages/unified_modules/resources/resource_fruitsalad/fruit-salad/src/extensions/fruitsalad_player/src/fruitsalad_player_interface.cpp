////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 Cirrus Logic International (UK) Ltd.  All rights reserved.
//
// This software as well as any related documentation is furnished under 
// license and may only be used or copied in accordance with the terms of the 
// license. The information in this file is furnished for informational use 
// only, is subject to change without notice, and should not be construed as 
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document. 
//
// Except as permitted by such license, no part of this document may be 
// reproduced, stored in a retrieval system, or transmitted in any form or by 
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies. 
//
/// @file   fruitsalad_player_interface.cpp
/// @brief  Convenience functions wrapping message creation.
///
/// @version \$Id: fruitsalad_player_interface.cpp 565 2014-12-04 11:48:43Z aangus $
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Includes
///////////////////////////////////////////////////////////////////////////////

#include <cstdlib>
#include <sstream>
#include <algorithm>
#include <iterator>
#include <iostream>
#include <vector>

#include "fruitsalad_player_interface.h"

///////////////////////////////////////////////////////////////////////////////
/// Function definitions
///////////////////////////////////////////////////////////////////////////////

namespace fruitsalad_player_interface
{
///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreateHandshakeMessage
///
/// @brief Creates a handshake it as a string.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreateHandshakeMessage()
    {
        std::stringstream msg;

        msg << HANDSHAKE;

        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreateSetUpMessage
///
/// @brief Creates a set up message and serializes it as a string.
///
/// @param playbackChannelCount  Number of playback channels.
/// @param recordingChannelCount Number of recording channels.
/// @param sampleRate            Sample rate in Hz.
/// @param bufferSize            Audio buffer size to use while playback and
///                              recording.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreateSetUpMessage( const int &playbackChannelCount,
                                    const int &recordingChannelCount,
                                    const int &sampleRate,
                                    const int &bufferSize
                                  )
    {
        std::stringstream msg;
        
        msg << SET_UP << " ";
        msg << playbackChannelCount << " " << recordingChannelCount << " ";
        msg << sampleRate << " " << bufferSize;

        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreateTerminateMessage
///
/// @brief Creates a terminate message and serializes it as a string.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreateTerminateMessage()
    {
        std::stringstream msg;

        msg << TERMINATE;

        return msg.str();
    }

	///////////////////////////////////////////////////////////////////////////////
	///
	/// Function: CreateCommandTypeMessage
	///
	/// @brief Creates string message using the CommandType
	///        and serializes it as a string.
	///
	/// @param CommandType Command message to be issued.
	///
	/// @return A message serialized as string.
	///
	///////////////////////////////////////////////////////////////////////////////
    std::string CreateCommandTypeMessage(CommandType command)
    {
        std::stringstream msg;
        msg << command;
        return msg.str();
    }

	///////////////////////////////////////////////////////////////////////////////
	///
	/// Function: CreateCodecStateReturnMessage
	///
	/// @brief Creates a space separated string message returning the success code
	///        and the state of the codec.
	///
	///        Example output: success 0 CODEC_STATE 0
	///
	/// @param success whether the command was successful: 0 false, 1 true.
	/// @param aState  The codec power state.
	///
	/// @return A return message serialized as string.
	///
	///////////////////////////////////////////////////////////////////////////////
    std::string CreateCodecStateReturnMessage(int success, int aState)
    {
        std::stringstream msg;
        msg << "success " << success << " CODEC_STATE " << aState;
        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreatePlayFromFileMessage
///
/// @brief Creates a play from file message and serializes it as a string.
///
/// @param fileName Name of a file to play.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreatePlayFromFileMessage( const std::string &fileName )
    {
        std::stringstream msg;
        
        msg << PLAY << " " << fileName;

        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreateRecordToFileMessage
///
/// @brief Creates a record to file message and serializes it as a string.
///
/// @param fileName Name of a file to record.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreateRecordToFileMessage( const std::string &fileName )
    {
        std::stringstream msg;

        msg << RECORD << " " << fileName;

        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreateStopPlaybackMessage
///
/// @brief Creates a stop playback message and serializes it as a string.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreateStopPlaybackMessage()
    {
        std::stringstream msg;
        
        msg << STOP_PLAYBACK;

        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreateStopRecordingMessage
///
/// @brief Creates a stop recording message and serializes it as a string.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreateStopRecordingMessage()
    {
        std::stringstream msg;
        
        msg << STOP_RECORDING;

        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: CreateResultMessage
///
/// @brief Creates a result message and serializes it as a string.
///
/// @return A message serialized as string.
///
///////////////////////////////////////////////////////////////////////////////
    std::string CreateResultMessage( const int &result )
    {
        std::stringstream msg;
        
        msg << result;

        return msg.str();
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: ParseCommandType
///
/// @brief Parses the command type of a given message.
///
/// @param msg A message to parse.
///
/// @return CommandType of the given message.
///
///////////////////////////////////////////////////////////////////////////////
    CommandType ParseCommandType( const std::string &msg )
    {
        CommandType commandType;

        std::istringstream iss( msg );
        std::vector<std::string> tokens;
        
        copy( std::istream_iterator<std::string>(iss),
              std::istream_iterator<std::string>(),
              back_inserter( tokens ) 
			);

        if ( tokens.size() > 0 )
        {
            commandType = IntToCommandType( atoi( tokens[0].c_str() ) );
            
            if ( ( SET_UP == commandType && tokens.size() != 5 ) ||
                 ( ( PLAY == commandType || RECORD ==commandType ) &&
                   tokens.size() != 2
                 )
               )
            {
                commandType = INVALID_COMMAND;
            }
        }
        else
        {
            commandType = INVALID_COMMAND;
        }

        return commandType;
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: IntToCommandType
///
/// @brief Safely converts int to command type.
///
/// @param type An integer representing command type.
///
/// @return CommandType of the given message.
///
///////////////////////////////////////////////////////////////////////////////
    CommandType IntToCommandType( const int &type )
    {
        CommandType commandType;

        switch ( type )
        {
        case SET_UP:
        case TERMINATE:
        case PLAY:
        case RECORD:
        case STOP_PLAYBACK:
        case STOP_RECORDING:
		case CODEC_STATE:
            commandType = static_cast<CommandType>( type );
            break;
        default:
            commandType = INVALID_COMMAND;
        }

        return commandType;
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: ParseSetUpArguments
///
/// @brief Parses arguments from a set up message.
///
/// @param msg A valid set up message.
///
/// @return A struct holding set up arguments.
///
///////////////////////////////////////////////////////////////////////////////
    SetUpArgs ParseSetUpArguments( const std::string &msg )
    {
        SetUpArgs args;
        
        std::istringstream iss( msg );
        std::vector<std::string> tokens;
        
        copy( std::istream_iterator<std::string>(iss),
              std::istream_iterator<std::string>(),
              back_inserter( tokens ) 
			);

        args.playbackChannelCount = atoi( tokens[1].c_str() );
        args.recordingChannelCount = atoi( tokens[2].c_str() );
        args.sampleRate = atoi( tokens[3].c_str() );
        args.bufferSize = atoi( tokens[4].c_str() );

        return args;
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: ParseFileArguments
///
/// @brief Parses arguments from a play or record message.
///
/// @param msg A valid play or record message.
///
/// @return A struct holding file arguments.
///
///////////////////////////////////////////////////////////////////////////////
    FileArgs ParseFileArguments( const std::string &msg )
    {
        FileArgs args;
        
		// TODO: this code is very replicated, refactor
        std::istringstream iss( msg );
        std::vector<std::string> tokens;
        
        copy( std::istream_iterator<std::string>(iss),
              std::istream_iterator<std::string>(),
              back_inserter( tokens ) 
			);

        args.fileName = tokens[1];

        return args;
    }

///////////////////////////////////////////////////////////////////////////////
///
/// Function: ParseResult
///
/// @brief Parses a result message.
///
/// Where other data is to be returned to the caller, output formatted
/// messages to the standard output in the form [<variable>]: <data>.
///
/// @param msg A valid result message.
///
/// @return A result code.
///
///////////////////////////////////////////////////////////////////////////////
    int ParseResult( const std::string &msg )
    {
		// tokenise the string on white-space
		std::istringstream iss( msg );
        std::vector<std::string> tokens;
        copy( std::istream_iterator<std::string>(iss),
              std::istream_iterator<std::string>(),
              back_inserter( tokens ) 
			);

		// for backwards compatibility unless there are 4 tokens there
		// will be only a single token which is the errorCode
		std::string retStr = tokens[0];

		// Where 4 tokens have been returned there is additional data to output
		// to stdout for the user to read/parse.
		if ( 4 == tokens.size() )
		{	
			// first output the errorCode
			printf( "[%s]: %s\n", tokens[0].c_str(), tokens[1].c_str() );
			// then the integer result (still as string data)
			printf( "[%s]: %s\n", tokens[2].c_str(), tokens[3].c_str() );
			retStr =  tokens[1];
		}

        return atoi( retStr.c_str() );
    }
}
/////////////////////////////END OF FILE///////////////////////////////////////