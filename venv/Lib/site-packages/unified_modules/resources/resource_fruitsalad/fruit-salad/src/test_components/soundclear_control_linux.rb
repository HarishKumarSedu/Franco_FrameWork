# encoding: utf-8
################################################################################
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   soundclear_control_linux.rb
### @brief  Implementation of SoundClear Control testing on Linux-derived targets.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

require 'test_components/firmware_interface'

###############################################################################
#
# Encapsulates all of the high-level functionality expected from SoundClear
# Control as a component of PiSalad and RemoteSalad.
#
###############################################################################
class SoundClearControlForLinux < FirmwareInterface

    # The name of the algorithm in our configuration map.
    AlgorithmName = 'Ez2 Control'

    #
    # Card name (can be found in the machine driver) required to locate
    # debugfs entries
    #
    CardName = Conf.property( :Linux_ASoCCardName, nil )
    # Directory containing ASoC debugfs nodes
    ASoCDebugfsRoot = '/sys/kernel/debug/asoc'
    SampleRate = Conf.property( :SampleRate, nil )

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor. Assigns the owning DeviceInterface to the attribute
    # 'device'.
    #
    # @param [DeviceInterface] device The parent device object.
    #
    ###########################################################################
    def initialize( device )
        @device = device
        begin
            @firmware_id = Conf.hash_lookup_value( :Firmware_ids,
                                                   AlgorithmName
                                                 )
            params = Conf.hash_lookup_value( :Firmware_parameters,
                                             AlgorithmName
                                           )
            @parameters = NestedProperty.new( AlgorithmName, params )
            dsp_base_addr = Conf.property( :Firmware_DSPMemoryBaseAddresses,
                                           {}
                                         )
            @dsp_base_addresses = NestedProperty.new(
                                             'Firmware_DSPMemoryBaseAddresses',
                                             dsp_base_addr
                                                    )
        rescue RuntimeError
            @firmware_id = nil
        end
    end

    ###########################################################################
    #
    # @function load
    #
    # Load SoundClear Control onto the test target.
    #
    # @param  [Fixnum] dsp_core_index The index core to load the firmware onto.
    #                                 0-indexed.
    # @option [Bool]   :autostart     Automatically start the core running if
    #                                 true. Defaults to false.
    #
    # @raise [RuntimeError] An exception is raised if the firmware fails to
    #                       load.
    #
    ###########################################################################
    def load( dsp_core_index, options = {} )
        autostart = options.fetch( :autostart, false )
        @core_index = dsp_core_index
        clocking_usecase = "dsp#{@core_index + 1}_soundclear_control_clocking"
        boot_usecase = "dsp#{@core_index + 1}_soundclear_control_wake_up_core"

        @device.usecase( clocking_usecase )
        @device.load_firmware( AlgorithmName, @core_index )
        @device.usecase( boot_usecase )
        opts = { 'version' => nil, 'dsp_core' => @core_index }
        loaded, dsp_core_id = @device.is_firmware_loaded?( AlgorithmName, opts )
        if !loaded
            raise LoadingUnsuccessfulMessage
        end

        start if autostart
    end

    ###########################################################################
    #
    # @function start
    #
    # Begin running SoundClear control.
    #
    ###########################################################################
    def start()
        @device.start_firmware( AlgorithmName, nil, @core_index )
    end


    ###########################################################################
    #
    # @function triggered?
    #
    # Has SoundClear Control been triggered?
    #
    # @return [Bool] True if the firmware has been triggered at least once.
    #
    ###########################################################################
    def triggered?
        data_memory_base = @dsp_base_addresses.send("DSP#{@core_index + 1}").XM
        trigger_counter_offset = @parameters.Trigger_Phrase_Found_Counter.memory_offset
        trigger_counter_address = data_memory_base.to_s.hex +
                                  trigger_counter_offset.to_s.hex

        # make sure trigger counter had the chance to update
        sleep 1

        trigger_counter = @device.read_memory_value(
                                            trigger_counter_address.to_s( 16 ),
                                            4
                                                   )

        return 0 != trigger_counter.to_i
    end

    ###########################################################################
    #
    # @function buffer_test
    #
    # Concatenates the given trigger file and data file, plays the resultant
    # file and records output from a compressed stream while the playback is
    # ongoing. If the given stream delay value is nil or <0 the compressed
    # stream will be opened before beginning playback, if the value >=0 the
    # compressed stream will be opened with the given delay relative to the
    # end of the trigger file.
    #
    # @note The supplied trigger file should not be padded with spurious data
    #       at the end, as otherwise the compresses stream will be opened with
    #       a delay greater than the supplied value.
    #
    # @param  [String]      trigger_file  Name of a trigger file to play.
    # @param  [String]      data_file     Name of a data file to play.
    # @param  [Hash]        opts          Options to play a file with.
    # @option opts [String] :type         Type of output format is either
    #                                     compressed or uncompressed. Defaults
    #                                     to compressed.
    # @option opts [String] :action       Action to either include or exclude
    #                                     trigger phrase.
    # @option opts [Float]  :stream_delay Duration, in seconds, by which
    #                                     opening the compressed stream should
    #                                     be delayed.
    #
    # @return void
    #
    ###########################################################################
    def buffer_test( trigger_file, data_file, opts = {} )
        type = opts.fetch( :type, 'compressed' )
        action = opts.fetch( :action, 'include' )
        stream_delay = opts.fetch( :stream_delay, 1.0 )

        disable_sad

        trigger_length = FruitSalad::track_length( trigger_file )
        concatenated = 'tmp/concatenated.wav'
        FruitSalad::write_waveform( concatenated,
                                    FruitSaladUtils::concatenate_wavefiles(
                                                     [trigger_file, data_file],
                                                     SampleRate
                                                                         )
                                  )

        if stream_delay.nil? || stream_delay < 0
            @device.record_from_compressed_stream()
        end

        @device.playback( concatenated, blocking: false )

        if stream_delay >= 0
            sleep( stream_delay + trigger_length )
            @device.record_from_compressed_stream()
        end

        @device.end_playback( true )
        @device.end_compressed_stream_capture()
    end

    ###########################################################################
    #
    # @function disable_sad
    #
    # Disables SAD by writing to a TinyALSA control.
    #
    # @note SAD is disabled by setting 0 to the 135'th (see Ez2Control data
    #       sheet) byte of control named 'DSP<n> XM <firmware id>:0'.
    #
    # (no parameters)
    #
    # @return void
    #
    ###########################################################################
    def disable_sad
        key = "DSP#{@core_index + 1} XM #{@firmware_id}:0"
        use_sad_offset = @parameters.UseSADTrigger.memory_offset
        @device.set_mixer_property( key, '0x00', use_sad_offset )
    end

    #######################################################################
    #
    # @function read_voice_counter
    #
    # Reads voice trigger counter node and returns the node value.
    #
    # @return [Integer] Value Returns the voice trigger counter node value.
    #
    #######################################################################
    def read_voice_trigger_counter()
        value = nil
        @device.exec! "cat #{ASoCDebugfsRoot}/#{CardName}/test-automation/voice_trigger_count" do |_, stdout, _|
            value = stdout
        end
        if !value.nil? and !value.empty?
            value = value.gsub("\n",'')
        end
        return value
    end
end
################################# END OF FILE #################################