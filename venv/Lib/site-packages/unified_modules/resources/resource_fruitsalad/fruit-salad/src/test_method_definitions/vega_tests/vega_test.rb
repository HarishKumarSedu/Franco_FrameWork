################################################################################
###
### Copyright (c) 2016-2017 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file  vega_test.rb
### @brief Encapsulates all the test methods which deals with message
###        communicationof VEGA.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################
require 'configuration'
require 'csv'
require '../../fruit-salad/src/fruitsalad_utils.rb'

# Constants used in message communication.
RESPONSE_CRAN    = "01"
BULK_BIT_NOT_SET = "0"
PANIC_MESSAGE     = 5
DMA_MESSAGE       = 3
SUCCESS_CODE      = 0
RESPONSE_NOTIFY   = "11"
BULK_BIT_SET      = "1"
MESSAGE_SIZE      = 12
PAYLOAD_LENGTH    = 20
NO_INTERRUPT_AVAILABLE = 0
FAIL              = 1
RX_DMA_MESSAGE    = "Notif_System_RxDmaSetupstatus"
RX_DMA_MESSAGE_ID = 3
RX_DMA_NOTIFY     = "11"
RX_DMA_SERVICE_INSTANCE = "00000"
ZERO = 0
BULK_DATA_SIZE = 4096
BYTES_PER_DWORD = 4
ACK_CRAN = "10"
VOICEID_DATA = 0
ASR_DATA = 1
RAW_DATA = 2
COMPLETION_EVENT = 3

ARM_COMMS_FIFO_DEPTH = 4
ARM_COMMS_MSG_SIZE_MAX = 20
MAILBOX_RD_IDX_OFFSET = 0
MAILBOX_WR_IDX_OFFSET = 1
MAILBOX_MESSAGE_OFFSET = 2

MAILBOX_EMPTY = -1
MAILBOX_FULL = 0
MAILBOX_HAS_MSGS = 1

HALO_ARM_RESPONSE_TIME_MAX = 20 #(in milli seconds)
DSP_WAIT_TIME = HALO_ARM_RESPONSE_TIME_MAX * 2
MSG_PAYLOAD_OFFSET = 2

#WR and RD idx + MSG
MSG_SIZE_IN_BYTES =  (ARM_COMMS_MSG_SIZE_MAX * 4) + 4 + 4

GET_MSG_TYPE   = 1
GET_MSG_LEN    = 2
GET_HALO_STATE = 3
GET_ERR_CODE   = 4
GET_STRM_TYPE  = 5
BARGE_IN_STATE = 6
MIC_OWNER_SHIP = 7
TALK_MODE = 8
ENROLMENT_MODE = 9
EVENT_TYPE = 10
DEBUGINFO_TYPE = 11
CASTILLO_RAS_SRV_ID = 10

CORE_START = 1
CORE_RUN = 2

class Vega

    # attribute accessors
    attr_accessor :purge_notify

include FruitSaladUtils

    @@SCP_FLAT_FIFO1_BASE_ADDR = 0x00000000
    @@SCP_FLAT_RX_DAT_OFFSET   = 0x208000
    @@SCP_FLAT_TX_DAT_OFFSET   = 0x218000
    @@SCP_FLAT_EXT_STS_GPR     = 0x200404

    @@default_services = [ "0x5953", "0x9669", "0x4244", "0x4152", "0x2323" ]

    @@MsgType = {
                 "NO_MSG" => 0,
                 "SET_STATE" => 1,
                 "SET_STATE_RSP" => 2,
                 "GET_STATE" => 3,
                 "GET_STATE_RSP" => 4,
                 "SET_BRGIN_STATE" => 5,
                 "SET_BRGIN_STATE_RSP" => 6,
                 "SET_MIC_OWNRSHP" => 7,
                 "SET_MIC_OWNRSHP_RSP" => 8,
                 "READ_STRM" => 9,
                 "READ_STRM_RSP" => 10,
                 "CANCEL_RD_STRM" => 11,
                 "CANCEL_RD_STRM_RSP" => 12,
                 "GET_CURRENT_FRME" => 13,
                 "GET_CURRENT_FRME_RSP" => 14,
                 "SET_STRM_MRKR" => 15,
                 "SET_STRM_MRKR_RSP" => 16,
                 "GET_STRM_MRKR" => 17,
                 "GET_STRM_MRKR_RSP" => 18,
                 "GET_DBG_INFO" => 19,
                 "GET_DBG_INFO_RSP" => 20,
                 "DSP_SS_EVNT" => 21,
                 "DSP_SS_AWAKE" => 22,
                 "GET_TALK_MODE" => 23,
                 "GET_TALK_MODE_RSP" => 24,
                 "SET_ENROLMENT_MODE" => 25,
                 "SET_ENROLMENT_MODE_RSP" => 26,
                 "PROCESS_BUFFER" => 27,
                 "PROCESS_BUFFER_RSP" => 28,
                 "SET_EXT_TRGR_DET" => 29,
                 "SET_EXT_TRGR_DET_RSP" => 30
                }

    @@MsgLength = {
                   "BLANK_MSG_LEN" => 0,
                   "MSG_LEN_1" => 1,
                   "NO_MSG_LEN" => 2,
                   "SET_STATE_LEN" => 3,
                   "SET_STATE_RSP_LEN" => 4,
                   "GET_STATE_LEN" => 2,
                   "GET_STATE_RSP_LEN" => 5,
                   "SET_BRGIN_STATE_LEN" => 3,
                   "SET_BRGIN_STATE_RSP_LEN" => 4,
                   "SET_MIC_OWNRSHP_LEN" => 3,
                   "SET_MIC_OWNRSHP_RSP_LEN" => 4,
                   "READ_STRM_LEN" => 7,
                   "READ_STRM_RSP_LEN" => 4,
                   "CANCEL_RD_STRM_LEN" => 3,
                   "CANCEL_RD_STRM_RSP_LEN" => 3,
                   "GET_CURRENT_FRME_LEN" => 2,
                   "GET_CURRENT_FRME_RSP_LEN" => 4,
                   "SET_STRM_MRKR_LEN" => 3,
                   "SET_STRM_MRKR_RSP_LEN" => 5,
                   "GET_STRM_MRKR_LEN" => 3,
                   "GET_STRM_MRKR_RSP_LEN" => 5,
                   "GET_DBG_INFO_LEN" => 3,
                   "GET_DBG_INFO_RSP_LEN" => 18,
                   "DSP_SS_EVNT_TRIG_DETECT_LEN" => 7,
                   "DSP_SS_EVNT_FATAL_ERR_LEN" => 19,
                   "DSP_SS_EVNT_STREAM_COMPLET_LEN" => 6,
                   "DSP_SS_AWAKE_LEN" => 5,
                   "Less_Message_Length" => 2,
                   "More_Message_Length" => 4,
                   "Read_Stream_More_Message_Length" => 9,
                   "GET_TALK_MODE_LEN" => 2,
                   "GET_TALK_MODE_RSP_LEN" => 4,
                   "SET_ENROLMENT_MODE_LEN" => 3,
                   "SET_ENROLMENT_MODE_RSP_LEN" => 4,
                   "PROCESS_BUFFER" => 4,
                   "PROCESS_BUFFER_RSP" => 3,
                   "SET_EXT_TRGR_DET_LEN" => 4,
                   "SET_EXT_TRGR_DET_RSP_LEN" => 3,
                   "DSP_SS_EVNT_AUDIO_AVAILABLE_LEN" => 6,
                   "SET_STATE_More_Message_Length" => 5
                  }

    @@TState = {
                "EIdle" => 0,
                "EListenDetectOnHalo" => 1,
                "EListenDetectOnAp" => 2,
                "EStream" => 3,
                "EFatalError" => 4
               }

    @@ErrorCode = {
                   "ERR_NO_ERR" => 0,
                   "ERR_INVAL" => 1,
                   "ERR_OVERFLOW"  => 2
                  }

    @@TStream = {
                 "EStreamInvalid" => -1,
                 "EBiometric" => 0,
                 "EAsr" => 1,
                 "ERaw" => 2
                }

    @@TType = {
               "EKeyphraseDetect" => 1,
               "EFatalError" => 2,
               "EStreamXferCmplt" => 3,
               "EAudioAvailable" => 4
              }

    @@BargeInState = {
                      "Enabled" => 1,
                      "Disabled" => 0
                     }

    @@MicOwnerShip = {
                      "Enabled" => 1,
                      "Disabled" => 0
                     }

    @@MarkerValue = {
                     "MRKR_0" => 0, #//!< frame marker 0
                     "MRKR_1" => 1, #//!< frame marker 1
                     "MRKR_2" => 2, #//!< frame marker 2
                     "MRKR_3" => 3 #//!< frame marker 3
                    }

    @@DebugInfoType = {
                       "ESystemDbg" => 0,
                       "EControllerDbg" => 1,
                       "EPackerDbg" => 2,
                       "EBargeInDbg" => 3,
                       "EHNDDbg" => 4,
                       "EABMDbg" => 5,
                       "EM2MDbg" => 6,
                       "EProfDbg" => 7,
                       "EVte1Dbg" => 8,
                       "EVte2Dbg" => 9,
                       "ESsfDbg" => 10
                      }

    @@TalkMode = {
                  "ENearTalk" => 0,
                  "ECloseTalk" => 1,
                  "EUnknownTalk" => 2,
                 }

    @@EnrolmentStatus = {
                         "EnrolModeOk" => 0,
                         "EnrolModeBlkMic" => 1
                        }

    ############################################################################
    #
    # @@message_header_hash is a dictionary that consists binary value of the
    # message with out the message data. Binary value is equal to 16 bits data
    # [5-bits for service_instance + 1-bit for bulk bit + 2-bits for CRAN + 8-bits
    # for Message-id ]
    #
    # Below hash is not finalised and it will grow up once the list of messages
    # are fixed
    #
    # Note:
    # The entries in the hash should follow below syntax,Shown for a example command
    #       1.Command       = Cmd_getsysteminfo
    #       2.Response      = Rsp_getsysteminfo
    #       3.Nofification  = Notif_Invalid
    #      If the command will contain only Response then there will be only 2
    #      elements i.e Command and Response
    #
    ############################################################################
    @@message_header_hash = {"Cmd_GetSystemInfo" => "0000000000000000",
                             "Rsp_GetSystemInfo" => "0000000100000000",
                             "Cmd_GetServiceInfo" => "0000000000000001",
                             "Rsp_GetServiceInfo" => "0000000100000001",
                             "Cmd_ArmShutDown"  => "0000000000000010",
                             "Rsp_ArmShutDown" => "0000000100000010",
                             "Notif_System_RxDmaSetupstatus" => "0000001100000011",
                             "Notif_System_InvalidCommand" => "0000001100000100",
                             "Notif_System_VegaPanic" => "0000011100000101",
                             "Cmd_ReadRegister"   => "0001100000000001",
                             "Rsp_ReadRegister" => "0001100100000001",
                             "Cmd_WriteRegister" => "0001100000000010",
                             "Rsp_WriteRegister" => "0001100100000010",
                             "Cmd_InvalidCommand" => "0000000000000100",
                             "Cmd_InvalidCran" => "0000001100000000",
                             "Cmd_InvalidSI" => "1101100000000000",
                             "Cmd_InvalidBulkbit" => "0000010000000000",
                             "Cmd_GetMode" => "0000100000000001",
                             "Rsp_GetMode" => "0000100100000001",
                             "Cmd_SetMode" => "0000100000000000",
                             "Rsp_SetMode" => "0000100100000000",
                             "Cmd_LoudSpeakersEnabled" => "0000100000000010",
                             "Rsp_LoudSpeakersEnabled" => "0000100100000010",
                             "Cmd_LoudSpeakersDisabled" => "0000100000000011",
                             "Rsp_LoudSpeakersDisabled" => "0000100100000011",
                             "Cmd_SetEnrollConfig" => "0000100000000110",
                             "Rsp_EnrollConfig" => "0000100100000110",
                             "Cmd_IsPhraseInstalled" => "0000100000010100",
                             "Rsp_IsPhraseInstalled" => "0000100100010100",
                             "Cmd_InstallPhrase" => "0000110000010110",
                             "Rsp_InstallPhrase" => "0000100100010110",
                             "Cmd_RepStart" => "0000100000000111",
                             "Rsp_RepStart" => "0000100100000111",
                             "Cmd_CommitBvp" => "0000100000001001",
                             "Rsp_CommitBvp" => "0000100100001001",
                             "Cmd_GenerateTrigger" => "0000100001100101",
                             "Rsp_GenerateTrigger" => "0000100101100101",
                             "Notif_RepStatus" => "0000101100001000",
                             "Cmd_IsuserInstalled" => "0000100000010111",
                             "Rsp_IsuserInstalled" => "0000100100010111",
                             "Cmd_AuthStart" => "0000100000001010",
                             "Rsp_AuthStart" => "0000100100001010",
                             "Cmd_StartListen" => "0000100000001100",
                             "Rsp_StartListen" => "0000100100001100",
                             "Notif_ListeningModeHaloFwError" => "0000101100001101",
                             "Notif_EnteredStreamingMode" => "0000101100001110",
                             "Cmd_MoveForwardInTime" => "0000100001100100",
                             "Rsp_MoveForwardInTime" => "0000101001100100",
                             "Cmd_GetAsrBlock" => "0000100000010010",
                             "Rsp_GetAsrBlock" => "0000100100010010",
                             "Cmd_VoiceIdChallenge" => "0000110000000101",
                             "Rsp_VoiceIdChallenge" => "0000100100000101",
                             "Cmd_RemovePhrase" => "0000100000010101",
                             "Rsp_RemovePhrase" => "0000100100010101",
                             "Cmd_AreBiometricAssetsValid" => "0000100000000100",
                             "Rsp_AreBiometricAssetsValid" => "0000100100000100",
                             "Cmd_RemoveUser" => "0000100000011000",
                             "Rsp_RemoveUser" => "0000100100011000",
                             "Cmd_SetTriggerDetect" => "0000100000001111",
                             "Rsp_SetTriggerDetect" => "0000100100001111",
                             "Bulk_RspAsr" => "0000110100010010",
                             "Bulk_RspVoiceIdChallenge" => "0000110100000101",
                             "Cmd_SetFWUS2" => "1111110000100001",
                             "Cmd_SetCustPubKey" => "1111110000100010",
                             "Cmd_SetMAB" => "1111110000100011",
                             "Resp_SetFWUS2" => "1111100101100001",
                             "Resp_SetCustPubKey" => "1111100101100010",
                             "Resp_SetMAB" => "1111100101100011",
                             "Notif_RequestFWUS2" => "1111101101000001",
                             "Notif_RequestCustPubKey" => "1111101101000010",
                             "Notif_RequestMAB" => "1111101101000011",
                             "Notif_NoBootableComponents" => "1111101101000101",
                             "Notif_FailedFlashAuthentication" => "1111101101000110",
                             "Notif_FlashCorrupted" => "1111101101000111",
                             "Cmd_GetTriggerInfo"   => "0000100000010000",
                             "Rsp_GetTriggerInfo"   => "0000100100010000",
                             "Cmd_GetBioResultAuthPubKey" => "0000100000011001",
                             "Rsp_GetBioResultAuthPubKey" => "0000100100011001",
                             "Bulk_Rsp_GetBioResultAuthPubKey" => "0000110100011001",
                             "Cmd_GetAvailableAsrData" => "0000100000010001",
                             "Rsp_GetAvailableAsrData" => "0000100100010001",
                             "Cmd_GetDebugInfoRAS" =>  "0001100000000011",
                             "Rsp_GetDebugInfoRAS" =>  "0001110100000011",
                             "Cmd_GetDebugInfoSS" =>  "0000000000000111",
                             "Rsp_GetDebugInfoSS" =>  "0000010100000111",
                             "Cmd_GetDebugInfoVOX" => "0000100000011010",
                             "Rsp_GetDebugInfoVOX" => "0000110100011010",
                             "Cmd_InvokePanic" => "0001000000000000",
                             "Rsp_InvokePanic" => "0001000100000000",
                             "Notif_new_auth_result" => "0000101100011011",
                             "Cmd_SetTraceFilter" => "0000000000000110",
                             "Rsp_SetTraceFilter" => "0000000100000110",
                             "Cmd_ChangedRASSIForDebugInfo" => "0001000000000011",
                             "Cmd_SetRegisters"   => "0001110000000101",
                             "Rsp_SetRegisters"   => "0001100100000101",
                             "Cmd_GetRegisters"   => "0001100000000100",
                             "Rsp_GetRegisters"   => "0001110100000100",
                             "Cmd_FixedInstall_bin" => "0000100000011110",
                             "Cmd_Install_bin" => "0000110000011110",
                             "Rsp_Install_bin" => "0000100100011110",
                             "Cmd_Remove_bin" => "0000100000011111",
                             "Rsp_Remove_bin" => "0000100100011111",
                             "Cmd_is_bin_installed" => "0000100000100000",
                             "Rsp_is_bin_installed" => "0000100100100000",
                             "Cmd_install_BIOVTE_map" => "0000110000100001",
                             "Cmd_FixedinstallBiovte" => "0000100000100001",
                             "Rsp_install_BIOVTE_map" => "0000100100100001",
                             "Cmd_Remove_BIOVTE_map" => "0000100000100010",
                             "Rsp_Remove_BIOVTE_map" => "0000100100100010",
                             "Cmd_Is_BIOVTE_installed" => "0000100000100011",
                             "Rsp_Is_BIOVTE_installed" => "0000100100100011",
                             "Cmd_GetRASDebugInfoCatCount" => "0001100000001000",
                             "Rsp_GetRASDebugInfoCatCount" => "0001100100001000",
                             "Cmd_GetRASDebugInfoPageCount" => "0001100000001001",
                             "Rsp_GetRASDebugInfoPageCount" => "0001100100001001",
                             "Cmd_GetSSDebugInfoCatCount" => "0000000000001001",
                             "Rsp_GetSSDebugInfoCatCount" => "0000000100001001",
                             "Cmd_GetSSDebugInfoPageCount" => "0000000000001010",
                             "Rsp_GetSSDebugInfoPageCount" => "0000000100001010",
                             "Cmd_GetVOXDebugInfoCatCount" => "0000100000011100",
                             "Rsp_GetVOXDebugInfoCatCount" => "0000100100011100",
                             "Cmd_GetVOXDebugInfoPageCount" => "0000100000011101",
                             "Rsp_GetVOXDebugInfoPageCount" => "0000100100011101",
                             "Cmd_ChangedSIReadRegister" => "0001000000000001",
                             "Rsp_ChangedSIReadRegister" => "0001000100000001",
                             "Cmd_ChangedSIWriteRegister" => "0001000000000010",
                             "Rsp_ChangedSIWriteRegister" => "0001000100000010",
                             "Cmd_ChangedSIInvokePanic" => "0000100000000000",
                             "Rsp_ChangedSIInvokePanic" => "0000100100000000",
                             "Cmd_SetIRQNotifyMode" => "0001100000000110",
                             "Rsp_SetIRQNotifyMode" => "0001100100000110",
                             "Cmd_CastilloReadRegister"   => "0101000000000001",
                             "Rsp_CastilloReadRegister" => "0101000100000001",
                             "Cmd_CastilloWriteRegister" => "0101000000000010",
                             "Rsp_CastilloWriteRegister" => "0101000100000010",
                             "Cmd_CastilloSetRegisters"   => "0101010000000101",
                             "Rsp_CastilloSetRegisters"   => "0101000100000101",
                             "Cmd_CastilloGetRegisters"   => "0101000000000100",
                             "Rsp_CastilloGetRegisters"   => "0101010100000100",
                             "Cmd_CastilloGetDebugInfoRAS" =>  "0101000000000011",
                             "Rsp_CastilloGetDebugInfoRAS" =>  "0101010100000011",
                             "Cmd_CastilloRASDebugInfoCatCount" => "0101000000001000",
                             "Rsp_CastilloRASDebugInfoCatCount" => "0101000100001000",
                             "Cmd_CastilloRASDebugInfoPageCount" => "0101000000001001",
                             "Rsp_CastilloRASDebugInfoPageCount" => "0101000100001001",
                             "Cmd_GetRASCapability" => "0001100000001010",
                             "Rsp_GetRASCapability" => "0001100100001010"
                            }

    ############################################################################
    # @@failure_Code
    #
    # This Hash Contains some of the Error Codes that are used in the message
    # Communication.
    #
    ############################################################################
    @@failure_code =   {
                        "success" => 0,
                        "invalid_service_instance" => 2,
                        "invalid_bulk" => 3,
                        "invalid_cran" => 4,
                        "invalid_msg_id" => 5,
                        "cmd_not_allowed_in_this_mode" => 16,
                        "invalid_user_idx" => 17,
                        "invalid_phrase_idx"  => 18,
                        "user_already_reg_for_biometrics" => 23,
                        "phrase_not_installed" => 24,
                        "voiceid_lib_error" => 25,
                        "enroll_config_already_set" => 33,
                        "invalid_num_of_rep" => 34,
                        "invalid_mode_transition" => 15,
                        "invalid_mode" => 14,
                        "bio_assets_invalid" => 20,
                        "enroll_config_not_set" =>  32,
                        "all_rep_done_must_commit_bvp" => 36,
                        "halo_fw_error" => 26,
                        "rep_going_on" => 35,
                        "not_started_bcos_spk_enabled" => 29,
                        "not_enough_valid_rep" => 44,
                        "flash_error" => 11,
                        "user_not_reg_for_biometrics" => 21,
                        "security_lvl_invalid" => 30,
                        "auth_going_on" => 45,
                        "rep_trigg_timeout" => 37,
                        "rep_unexpected_trigg"=> 38,
                        "security_failure" => 27,
                        "aborted_bcos_spk_enabled" => 28,
                        "rep_noisy" => 39,
                        "rep_not_enough_speech" => 40,
                        "rep_no_speech" => 41,
                        "rep_sat_too_high" => 42,
                        "rep_feature_buf_overflow" => 43,
                        "no_user_identified" => 31
                       }

    ############################################################################
    #
    # @function update message header hash
    #
    # This Api is used to update the message header hash based on no of available
    # services
    # @ param [array] services_list   list of available services
    # @return    none
    #
    ############################################################################
    def update_message_header_hash( services_list )
        missing_services = @@default_services - services_list
        for i in (0...missing_services.length)
            missing_index = @@default_services.index(missing_services[i])
            @@message_header_hash.each do |key, value|
                if missing_index == value[0...5].to_i(2)
                    @@message_header_hash.delete(key)
                end
            end
        end

        # This will remove the duplicate service instance
        # currently this will only handle RAS
        # need to expand this based on the requirement
        dup_services = services_list.select{|item| services_list.count(item) > 1}.uniq
        dup_index = []
        for j in (0 ... dup_services.length)
            dup_index = services_list.each_index.select { |i| services_list[i]== dup_services[j] }
        end
        if( dup_index.length > 1 )
            update_hash_value( CASTILLO_RAS_SRV_ID, dup_index[dup_index.length-1])
            #services_list[dup_index[dup_index.length-1]] = "changed_ras"
        end

        for i in (0...@@default_services.length)
            for j in (0...services_list.length)
                if(services_list[j] == @@default_services[i] )
                     if( i != j)
                          update_hash_value( i, j )
                     end
                end
            end
        end
    end

    ############################################################################
    #
    # @function update_hash_value
    #
    # This Api is used to update the hash  value from old_value to new_value
    #
    # @param [ Integer ] old_value - It represents the SI values of old services.
    # @param [ Integer ] new_value - It represents the SI values of modified Services
    # @param [ :opt ]    :delete   - If this is '1' delete the keys.
    # @return none
    #
    ############################################################################
    def update_hash_value( old_value, new_value, opts = {} )
        detele_value  = opts[ :delete ]
        @@message_header_hash.each do |key, value|
            if(value[0...5].to_i(2) == old_value)
                updated_value = new_value.to_s(2).rjust(5,'0') + value[5...16]
                if(detele_value == 1)
                    @@message_header_hash.delete(key)
                else
                    @@message_header_hash[key] = updated_value
                end
            end
        end
    end

    ############################################################################
    #
    # @function initialize
    # default Constructor
    #
    ############################################################################
    def initialize
        @@device = FruitSalad.get_device()
        # Name of the Control Interface Type to set up the device.
        @firware_version = Conf.property( :Firmware_Version, nil )
        @arm_comms_incoming_mailbox_base = Conf.property( :ARM_COMMS_INCOMING_MAILBOX_BASE, nil )
        @arm_comms_outgoing_mailbox_base = Conf.property( :ARM_COMMS_OUTGOING_MAILBOX_BASE, nil )
        @halo_response_time = Conf.property( :Halo_Response_Time, 8 )
        @time_to_read_1sec_voiceid_data = Conf.property( :Time_To_Read_1sec_VoiceId_Data, 14 )
        @time_to_read_1sec_2ch_asr_data = Conf.property( :Time_To_Read_1sec_2ch_ASR_Data, 20 )
        @time_to_read_1sec_2ch_raw_data = Conf.property( :Time_To_Read_1sec_2ch_RAW_Data, 20 )
        @time_to_wait_for_completion_event = Conf.property( :Time_To_Wait_For_Completion_Event, 1000 )
        @halo_core_max_wait_time = Conf.property( :Halo_Core_Max_Wait_Time, 10000 )
        @keyphrase_detector_id = Conf.property( :Keyphrase_Detector_Id, 12 )
        @keyphrase_id = Conf.property( :Keyphrase_Id, 1 )
        @check_ssf_debug_msg = Conf.property( :Check_SSF_Debug_Msg, true )
        @check_vte1_ssf_debug_msg = Conf.property( :Check_Vte1_SSF_Debug_Msg, false )
        @vte2_keyphrase_detector_id = Conf.property( :VTE2_Keyphrase_Detector_Id, 180 )
        @vte2_keyphrase_id = Conf.property( :VTE2_Keyphrase_Id, 23 )
        @channel_count = Conf.property( :Channel_Count, 2 )
        @purge_notify = @@message_header_hash["Notif_new_auth_result"]
        @halo_state_register_name = Conf.property( :Halo_State_Register_Name, 'FIRMWARE_VEGA_BIOMETRIC_HALOSTATE' )
        @halo_default_state = Conf.property( :Halo_Default_State, 'EIdle' )
        @halo_mailbox_interrupt_register_name = Conf.property( :Halo_Mailbox_Interrupt_Register_Name, 'GPIO_STATUS1' )
        @halo_mailbox_interrupt_control_register_name = Conf.property( :Halo_Mailbox_Interrupt_Control_Register_Name, 'GPIO1_CTRL1' )
        @halo_mailbox_interrupt_control_register_address = Conf.property( :Halo_Mailbox_Interrupt_Control_Register_Address, 0xC08 )
        @check_messages_using_mailbox = Conf.property( :Check_Messages_Using_Mailbox, true )
        @value_used_to_set_gpio_low = Conf.property( :Value_Used_To_Set_Gpio_Low, 0xFFFF2FFF )
        @if_device_is_castillo = Conf.property( :If_Device_Is_Castillo, nil )
        @if_device_is_vega_halo = Conf.property( :If_Device_Is_Vega_Halo, nil )
        @set_state_response_time = Conf.property( :Set_State_Response_Time, 8 )
        @read_eaudio_available_events = Conf.property( :Read_Eaudio_Available_Events, nil )
        @set_state_length = Conf.property( :Set_State_Length, 3 )
        @@MsgLength ["SET_STATE_LEN"] = @set_state_length
    end

    ############################################################################
    #
    # @function send_command_wait_for_response
    #
    # This is a API used to send a command to the VEGA and return with response
    #  if the optional argument is present then it sends only command Else
    #  it will send the command and Read the Response back.
    #
    # @param  message_name   command name that has to tested.
    # @param [string]        10 byte hex characters
    # @param [opts]          optional parameter which Specifies either to send
    #                        command or to send command and read response.
    #
    # @return[IntegerArray]  payload  on sucess Integer array(10 bytes)
    #                        on failure return 1 with message reason for failure.
    #
    ############################################################################
    def send_command_wait_for_response( message_name, payload, opts = {} )
        if PAYLOAD_LENGTH == payload.length
            only_command  = opts[ :only_command ]
            message = construct_message( message_name, payload )
            write_data_with_padding( message )

            unless only_command
                message_status = check_for_interrupt
                if message_status
                    read_available_data( MESSAGE_SIZE )
                    return compare_message_header( message,
                                                   RESPONSE_CRAN,
                                                   BULK_BIT_NOT_SET
                                                  )
                else
                    $LOG.error "\nUnable to Receive the interrupt\n"
                end
            end
        else
            $LOG.error "Invalid input payload size #{payload.length} should be 20"
        end
        return FAIL
    end

    ############################################################################
    #
    # @function wait_for_response
    #
    #  The API is used to get the response for the commands that are already
    #  submitted to VEGA.
    #
    # @param                 message_name
    # @option [ opts ] Integer :bulk_response If it is specified will read bulk
    #                                        response from Vega.
    #
    # @return [IntegerArray] If message status is true returns message
    #                        payload else returns FAIL value
    #
    ############################################################################
    def wait_for_response( message_name , opts = {} )
        bulk_response = opts[:bulk_response]
        payload = ""
        message = construct_message( message_name , payload )
        if bulk_response
            return read_bulk_vega( message_name )
        else
            return check_for_interrupt_and_read_message( message, RESPONSE_CRAN, BULK_BIT_NOT_SET )
        end
    end

    ############################################################################
    #
    # @function read_notification
    #
    # This API is used to read the notification from the VEGA.
    # If there are any notifications from VEGA host should be able to address
    # these nofifications accordingly
    #
    # @param  [string] message_name - It represents the name of the message.
    # @param  [ :bulk_notify ] opt  - It is used when user receives a bulk
    #                                 from VEGA.
    # @return [IntegerArray]        - If message status is true returns message
    #                                 payload else returns FAIL value
    #
    ############################################################################
    def read_notification( message_name, opt = {} )
        bulk_notify = opt[ :bulk_notify ]
        @expected_userid = opt[:userid]
        @@purge_notify_error =opt[:purge_notify]
        payload = ""
        message = construct_message( message_name , payload )
        message_status = check_for_interrupt
        @purge_notify_start_time = DateTime.now.strftime( '%Q' ).to_i
        if message_status
            read_available_data( MESSAGE_SIZE )
            if bulk_notify
                payload = compare_message_header( message,
                                                  RESPONSE_NOTIFY,
                                                  BULK_BIT_SET
                                                )
                if payload.class == Array
                    bulk_size = extract_bulk_size()
                    read_available_data( bulk_size )
                    return @available_message, payload
                end
            else
                payload = compare_message_header( message,
                                                  RESPONSE_NOTIFY,
                                                  BULK_BIT_NOT_SET
                                                )
            end
            if payload.class == Array
                $LOG.info " Received Notification as #{message_name}"
            end
            return @available_message
        else
            $LOG.error "\nUnable to receive the Interrupt\n"
            return FAIL
        end
    end

    ############################################################################
    #
    # @function write_bulk_vega
    #
    # The API is used to write bulk data in to VEGA.
    #  Generally this API used to send bulk of challange bits and other data to
    #   VEGA
    #
    # @param [string]        message_name  name of the command
    # @param [string]        payload   string of hex values
    # @param [string]        bulk_data string of hex values
    # @param [optional]      :time_delay - It represent waiting time in seconds.
    #
    # @return [IntegerArray] If message status is true returns message
    #                        payload else returns FAIL value
    #
    ############################################################################
    def write_bulk_vega( message_name, payload, bulk_data, opts={} )
        time_delay = opts[:time]
        if PAYLOAD_LENGTH == payload.length
            str_size = bulk_data.size.to_s(16).rjust(8,'0')
            size = str_size.scan(/../).reverse.join
            if size.casecmp( payload[0...8] )
                message = construct_message(
                                            message_name,
                                            payload
                                            )
                @bulk_data = bulk_data
                write_data_with_padding( message )
                message_status = check_for_interrupt

                unless time_delay == nil
                    $LOG.info "Time delay after sending voiceid command : #{time_delay}"
                    sleep( time_delay )
                end
                if message_status
                    read_available_data( MESSAGE_SIZE )
                    service_instance = message[0].to_s(2).rjust(8,'0')
                    payload = ""
                    message = construct_message( RX_DMA_MESSAGE , payload )
                    payload = compare_message_header( message,
                                                      RESPONSE_NOTIFY,
                                                      BULK_BIT_NOT_SET
                                                    )

                    if payload.class == Array
                        success_code = @available_message[2]
                        if SUCCESS_CODE == success_code
                            rx_dma_payload = rx_dma_status_functionality( message_name )
                            result = ( rx_dma_payload.class == String || rx_dma_payload.class == Array )
                            if ( result )
                                return @available_message
                            elsif ( NO_INTERRUPT_AVAILABLE == rx_dma_payload )
                                $LOG.error "No interrupt after writing the Data"
                                return FAIL
                            end
                         else
                            $LOG.error "NO Memory Error"
                            return FAIL
                        end
                    else
                        $LOG.error "Invalid response from Vega : #{@available_message}"
                        return FAIL
                    end
                else
                    $LOG.error "Unable to receive interrupt"
                    return FAIL
                end
            else
                $LOG.error "input size and data size not equal"
                return FAIL
            end
        else
            $LOG.error "Invalid input payload size #{payload.length} should be 20"
            return FAIL
        end
    end

    ############################################################################
    #
    # @function read_bulk_vega
    # The API is used to read the bulk data from VEGA
    # The API generally used to read data like signed challanged bits and ASR
    # data
    #
    # @param  message_name  name of the command.
    # @return[IntegerArray] on success available_message Array
    #                       on failure return 1
    #
    ############################################################################
    def read_bulk_vega( message_name )
        payload = ""
        message = construct_message( message_name , payload )
        message_status = check_for_interrupt
        if message_status
            read_available_data( MESSAGE_SIZE )
            payload = compare_message_header( message, RESPONSE_CRAN, BULK_BIT_SET )
            if payload.class == Array
                size = extract_bulk_size()
                read_available_data( size )
                return @available_message, payload
            end
            return payload
        else
            $LOG.error "Unable to receive the interrupt"
            return FAIL
        end
    end

    ###########################################################################
    #
    # @function construct_message
    #
    # This method is used to construct message with the message_name and payload
    #
    # @param  [string] message_name name of the command
    # @param [string]  payload string of hex values
    # @return[Integer] Array of elements in  integer format.
    #
    ############################################################################
    def construct_message( message_name, payload )
        message_header = @@message_header_hash[ message_name ]
        message_payload = payload.hex.to_s(2).rjust( payload.size*4, '0' )
        integer_array = Array.new
        message = message_header +  message_payload
        message.scan /\S{8}/ do |i|
                int = i.to_i(2)
                integer_array << int
            end
        $LOG.debug "Construct message is #{integer_array}"
        return integer_array
    end

    ############################################################################
    #
    # @function is_message_available
    #
    # This method will parse the interrupt status register value.
    # This method is checking the availability of TX_FIFO Not Empty Register
    #
    # @param  [Integer Array] interrupt value register value that was read from the vega.
    # @return [boolean]       on sucess true else false
    #
    ############################################################################
    def is_message_available( interrupt_value )
        if( interrupt_value[0] == 0 && interrupt_value[1] == 0 && interrupt_value[2] == 0 && interrupt_value[3] == 32 )
            return true
        else
            return false
        end
    end

    ############################################################################
    #
    # @function  parse_for_message_header
    #  This method extracts si and bulk_bit and cran field and message id Field
    #
    # @param none
    # @return[string]   si
    #         [string]  bulk_bit  value
    #         [string]  cran
    #         [Integer] msg_id
    #
    ############################################################################
    def parse_for_message_header
        type_size_si = @available_message[0].to_s(2).rjust( 8, '0' )
        si = type_size_si[0..4]
        bulk_bit = type_size_si[5]
        cran = type_size_si[6] + type_size_si[7]
        msg_id = @available_message[1]
        return si, bulk_bit, cran, msg_id
    end

    ############################################################################
    #
    # @function extract_bulk_size
    #
    # This method extracts the size of the buffer that to be read from the Vega
    #  The size is used to extract the buffer data from the txfifo
    #
    # @param           none
    # @return[Integer] buffer_size
    #
    ############################################################################
    def extract_bulk_size
        buf_size = @available_message[2..5].reverse
        payload_size = ""
        for i in 0...buf_size.length
            binary_array = buf_size[i].to_s(2).rjust( 8, '0' )
            payload_size = payload_size + binary_array
        end
        return payload_size.to_i(2)
    end

    ############################################################################
    #
    # @function parse_for_slices
    #
    # This method Extract  the slice_Size(6..9)bytes  and slice_num(5th byte)
    #
    # @param none
    # @return [Integer]  slice_size
    # @return [Integer]  slice_num
    #
    ############################################################################
    def parse_for_slices
        slice_size = ""
        slice = @available_message[6..9]
        for i in 0..3
            binary = slice[i].to_s(2).rjust(8,'0')
            slice_size = binary + slice_size
        end
        slice_size = slice_size.to_i(2)
        slice_num = @available_message[5]
        return slice_size, slice_num
    end

    ############################################################################
    #
    # @function slice_bulk_data
    #
    # This method makes the bulk_data into slices as per the slice size that was
    #  given as input
    #
    # @param [integer]    slice_size  which determines the size to split
    # @return Slice_data  Integer format
    # @raise Execption raises if invalid slice size return from vega
    #
    ############################################################################
    def slice_bulk_data( slice_size )
        if @bulk_data.size >= slice_size
            slice_data = @bulk_data.slice! 0...slice_size
            buffer_values = []
            buffer_values = slice_data.unpack('C*')
            write_data_with_padding( buffer_values )
        else
            raise 'Invalid slice size return from vega'
        end
    end

    ############################################################################
    #
    # @function parse_for_payload_notify
    #
    #  This function Returns the Error Result.
    #
    # @param  none
    # @return [String] Failure Key read from the Hash
    #
    ############################################################################
    def parse_for_payload_notify()
        return verify_the_result( @available_message[2] )
    end

    ############################################################################
    #
    # @function read_available_data
    #
    # To read required amount of bytes from the Vega
    #
    # @param [Integer]  size bytes that need to be Extracted from the Vega
    # @return no return
    #
    ############################################################################
    def read_available_data( byte_size )
        padded_available_message = []
        @available_message = []
        read_from_device = true

        rem = byte_size % BYTES_PER_DWORD
        if rem != ZERO
            byte_size = byte_size + ( BYTES_PER_DWORD - rem )
        end

        while byte_size > ZERO
            if byte_size <= BULK_DATA_SIZE
                padded_available_message = @@device.read_block_data(
                                                                     @@SCP_FLAT_FIFO1_BASE_ADDR +
                                                                     @@SCP_FLAT_TX_DAT_OFFSET,
                                                                     byte_size,
                                                                     read_from_device
                                                                   )
                byte_size = 0
            else
                padded_available_message = @@device.read_block_data(
                                                                     @@SCP_FLAT_FIFO1_BASE_ADDR +
                                                                     @@SCP_FLAT_TX_DAT_OFFSET,
                                                                     BULK_DATA_SIZE,
                                                                     read_from_device
                                                                   )
                byte_size = byte_size - BULK_DATA_SIZE
           end
            @available_message += padded_available_message
        end

        $LOG.debug "available_message is #{@available_message}"
        return @available_message
    end

    ############################################################################
    #
    # @function write_data_with_padding
    #
    # This method writes the data into the vega 4 bytes at a time
    # until all the Bytes of the input has written to the Vega
    #
    # @Param[Integer_array] message  Intger Values that has to be Written.
    # @return none
    #
    ############################################################################
    def write_data_with_padding( message )
        i =0
        while i < message.size
            if BULK_DATA_SIZE <= message.size
                @@device.write_block_data( @@SCP_FLAT_FIFO1_BASE_ADDR +
                                           @@SCP_FLAT_RX_DAT_OFFSET,
                                           message[i...i+BULK_DATA_SIZE],
                                           true
                                         )
                message.shift( BULK_DATA_SIZE )
            else
               @@device.write_block_data( @@SCP_FLAT_FIFO1_BASE_ADDR +
                                          @@SCP_FLAT_RX_DAT_OFFSET,
                                          message,
                                          true
                                        )
                break
            end
        end
    end

    ############################################################################
    #
    # @function rx_dma_status_functionality
    #
    # This Function is for parsing the data to slices and sending the
    # sliced data to the  vega and read the Response back from the Vega
    #
    # @param [ String ] message_name - It refers to the command name.
    # @return [integerArray] if the bulk_bit is 1 read the Bulk_response and Return
    #                        to Ap. If Bulk_bit is 0 read the 12 byte response And Return.
    #
    ############################################################################
    def rx_dma_status_functionality( message_name )
        bulk_input_data = @bulk_data
        total_slice_size = 0
        while 1
            slice_size, slice_num = parse_for_slices()
            $LOG.debug "Slice Size : #{slice_size}, Slice_number : #{slice_num}"
            total_slice_size = slice_size + total_slice_size
            slice_bulk_data( slice_size )

            if ZERO != @bulk_data.length
                message_status = check_for_interrupt
                if message_status
                    read_available_data( MESSAGE_SIZE )
                    payload = ""
                    message = construct_message( RX_DMA_MESSAGE , payload )
                    payload = compare_message_header( message, RESPONSE_NOTIFY, BULK_BIT_NOT_SET )
                    if payload.class == Array
                        next
                    else
                        if ( bulk_input_data.length == total_slice_size && BULK_BIT_NOT_SET == bulk_bit )
                            $LOG.info "Completed writting complete data into vega"
                            if @available_message[2] == SUCCESS
                                $LOG.debug "Now the Response For the BULk_method is #{@available_message}"
                                return @available_message
                            else
                                result = verify_the_result( @available_message[2] )
                                $LOG.error "Failed Getting the Response due to #{result}"
                                return result
                            end
                        else
                            $LOG.error "Received Invalid response from Vega"
                            return @available_message
                        end
                        $LOG.info "Rx DMA status checking completed 1"
                    end
                else
                    $LOG.error "Unable to receive Interrupt from Vega"
                    return NO_INTERRUPT_AVAILABLE
                end
            else
                message = construct_message( message_name, payload = "" )
                message_status = check_for_interrupt
                if message_status
                    read_available_data( MESSAGE_SIZE )

                    payload = compare_message_header( message, RESPONSE_CRAN, BULK_BIT_SET )
                    service_instance, bulk_bit, cran,message_id = parse_for_message_header
                    if BULK_BIT_SET == bulk_bit && payload.class == Array
                        payload_size = extract_bulk_size()
                        read_available_data( payload_size )
                        return @available_message
                    else
                        return compare_message_header( message, RESPONSE_CRAN, BULK_BIT_NOT_SET )
                    end
                else
                    $LOG.error "Unable to receive Interrupt from Vega"
                    return NO_INTERRUPT_AVAILABLE
                end
            end
        end
    end

    ############################################################################
    #
    # @function compare_messageid
    #
    # This function is to Compare the Messageid and Return the result based on
    # the Message id
    #
    # @param [Integer]         actual_id messageid from the Construct message
    # @param [Integer]         resp_id messageid from the returned message
    # @return[integerArray]    if messageid are equal
    #                            else return 1
    #
    ############################################################################
    def compare_messageid( actual_id, resp_id )
        if ( actual_id == resp_id )
            payload = @available_message[ 2..@available_message.length-1 ]
            return payload
        else
            header = @available_message[0].to_s(2).rjust( 8, '0')
            resp_message_id_no =  header + resp_id.to_s(2).rjust(8,'0')
            command_name  = @@message_header_hash.key( resp_message_id_no )
            actual_id_no = header + actual_id.to_s(2).rjust(8,'0')
            message_name = @@message_header_hash.key( actual_id_no )
            $LOG.debug "\nReceived Response #{command_name} instead of response for #{message_name}"
            return 1
        end
    end

    ############################################################################
    #
    # @function invalid_cran_notification
    #
    # This method is to Display the Notification message in case of failure.
    #
    # @param [integer] resp_message_id_no messageid recieved
    # @return 1
    #
    ############################################################################
    def invalid_cran_notification( resp_message_id_no )
        command = @available_message[0].to_s(2).rjust( 8, '0') +
                        resp_message_id_no.to_s(2).rjust( 8, '0' )
        command_name = @@message_header_hash.key( command )
        result = parse_for_payload_notify()
        $LOG.debug "\nReceived Notification as #{command_name} as because #{result}"
        return 1
    end

    ############################################################################
    #
    # @function verify_the_result
    #
    # This function is used to extract result that return from the Vega
    #
    # @param [integer] reponse byte value return from the Vega.
    # @return [String] Key value that is Fetched from the Hash.
    #
    ############################################################################
    def verify_the_result( response )
        response_code = @@failure_code.key( response )
        $LOG.debug "Response from the Vega is #{response_code}"
        return response_code
    end

    ############################################################################
    #
    # @function check_for_interrupt
    #
    # This function Checks for availablity of interrupt within 100000 ms
    #
    # @param none
    # @return [bool] if interrupt is available then  return true
    #                       else return false
    #
    ############################################################################
    def check_for_interrupt
        start_time = DateTime.now.strftime( '%Q' )
        while ( DateTime.now.strftime( '%Q' ).to_i - start_time.to_i < 100000 )

            interrupt_value = @@device.read_block_data( @@SCP_FLAT_FIFO1_BASE_ADDR +
                                                        @@SCP_FLAT_EXT_STS_GPR,
                                                        4,
                                                        true
                                                       )
            message_status = is_message_available( interrupt_value )
            if message_status
                interrupt_time = DateTime.now.strftime( '%Q' ).to_i - start_time.to_i
                $LOG.debug "Interrupt occured in #{interrupt_time} milli seconds"
                return true
            end
        end
        interrupt_time = DateTime.now.strftime( '%Q' ).to_i - start_time.to_i
        $LOG.error "Unable to raise interrupt in #{interrupt_time} milli seconds"
        return false
    end

    ############################################################################
    #
    # @function compare_message_header
    #
    # Compares message header and Return result if they are equal
    #
    # @param [IntegerArray] message                 Header
    # @param [String]       cran                    Required Response Cran
    # @param [String]       bulk                    Required Response Bulk_bit
    # @option[:String]      :ignore_notification    Notification that to be ignored
    # @return [IntegerArray]                        on success integer Array
    #                                               else return 1
    #
    ############################################################################
    def compare_message_header( message, cran, bulk, opts = {} )
        if check_for_panic_notification( message )
            $LOG.error "unable to get the expected response"
            return 1
        end
        ignore_notify = opts.fetch( :ignore_notification, "Notif_new_auth_result" )
        header = message[0].to_s(2).rjust( 8, '0' )
        actual_service_instance = header[0...5]
        message_id = message[1]
        rsp_service_instance, rsp_bulk, rsp_cran, rsp_msgid = parse_for_message_header
        if actual_service_instance == rsp_service_instance && cran == rsp_cran && bulk == rsp_bulk
            return compare_messageid( message_id, rsp_msgid )
        elsif purge_notification( ignore_notify )
            return check_for_interrupt_and_read_message( message, cran, bulk )
        elsif ( rsp_cran.eql? ACK_CRAN ) && ( rsp_bulk.eql? BULK_BIT_NOT_SET )
            return check_for_interrupt_and_read_message( message, cran, bulk )
        else
            return invalid_cran_notification( rsp_msgid )
        end
    end

    ############################################################################
    #
    # @function construct_halo_message
    #
    # This function is used to construct the message, write the constructed message
    # in to mailbox.
    #
    # @param message_type    The message type to write in to mailbox
    #        message_length  The message length to write in to mailbox
    #        message_payload The message payload to write in to mailbox
    #
    # @return None.
    #
    ############################################################################
    def construct_halo_message( message_type, message_length, message_payload )

        message = Struct.new( :message_type, :message_length, :message_payload )
        set_state_message = message.new( message_type, message_length, message_payload)

        $LOG.info "construct_halo_message message_type is #{ message_type }"
        $LOG.info "construct_halo_message message_length is #{ message_length }"
        $LOG.info "construct_halo_message message_payload is #{ message_payload }"

        if( "SET_STATE" == message_type )
            @state = message_payload[ 0 ]
            @set_state_scenario = 1
            $LOG.info "#### @state is #{@state}"
        end

        if( "SET_STATE" == message_type && "SET_STATE_LEN" != message_length )
            @state_neg_case = 1
        end

        if( "SET_BRGIN_STATE" == message_type )
            @enabled = message_payload[ 0 ]
            $LOG.info "#### @enabled is #{@enabled}"
        end

        if( "SET_MIC_OWNRSHP" == message_type )
            @hip_owns_mics = message_payload[ 0 ]
            $LOG.info "#### @hip_owns_mics is #{@hip_owns_mics}"
        end

        if( "READ_STRM" == message_type )
            if( @state == 0 )
                @rd_strm_idle_state = 1
                $LOG.info "@rd_strm_idle_state is #{@rd_strm_idle_state}"
            end
            @read_strm_type = message_payload[ 0 ]
        end

        if( "CANCEL_RD_STRM" == message_type )
            @cancel_rd_strm = message_payload[ 0 ]
            $LOG.info "#### @cancel_rd_strm is #{@cancel_rd_strm}"
        end

        if( "SET_STRM_MRKR" == message_type )
            @set_strm_marker = message_payload[ 0 ]
            $LOG.info "#### @set_strm_marker is #{@set_strm_marker}"
        end

        if( "GET_STRM_MRKR" == message_type )
            @get_strm_marker = message_payload[ 0 ]
            $LOG.info "#### @get_strm_marker is #{@get_strm_marker}"
        end

        if( "GET_DBG_INFO" == message_type )
            @debug_msg_type = message_payload[ 0 ]
            $LOG.info "#### @debug_msg_type is #{@debug_msg_type}"
        end

        if( "SET_ENROLMENT_MODE" == message_type )
            if ZERO != message_payload[ 0 ]
                @enrollment_mode = 1
            else
                @enrollment_mode = 0
            end
            $LOG.info "#### @enrollment_mode is #{@enrollment_mode}"
        end

        write_message_to_halo( set_state_message )
    end

    ############################################################################
    #
    # @function write_message_to_halo
    #
    # Writes the message in to mailbox and updates write index.
    #
    # @param message(structure) The message to write in to mailbox
    #
    # @return None.
    #
    ############################################################################
    def write_message_to_halo(message)
        msg_type = @@MsgType[message["message_type"]]
        msg_length = @@MsgLength[message["message_length"]]
        msg_payload = message["message_payload"]

        array1 = []
        convert_word_to_byte( array1, 0, msg_type )
        convert_word_to_byte( array1, 4, msg_length )

        payload_index = MSG_PAYLOAD_OFFSET * 4
        payload_length = msg_length - 2

        if( nil != msg_payload )
            message_payload_count = msg_payload.count
        else
            message_payload_count = 0
        end
        if( 0 != payload_length )
            if( payload_length <= message_payload_count )
                select = payload_length
            else
                select = message_payload_count
            end
            i = 0
            select.times do
                message_data = msg_payload[ i ]
                convert_word_to_byte( array1, payload_index, message_data )
                payload_index = payload_index + 4
                i = i + 1
            end
        end

        msg_address = @arm_comms_incoming_mailbox_base + ( MAILBOX_MESSAGE_OFFSET << 2 )
        wr_idx_value = get_idx_value( @arm_comms_incoming_mailbox_base, MAILBOX_WR_IDX_OFFSET )

        wr_msg_address = msg_address + ( wr_idx_value )* ( ARM_COMMS_MSG_SIZE_MAX << 2 )
        $LOG.info "writing into mail box array is #{array1}"
        @@device.write_block_data( wr_msg_address, array1, true )
        update_idx( @arm_comms_incoming_mailbox_base, MAILBOX_WR_IDX_OFFSET )

        if true == @if_device_is_vega_halo
            write_register_by_name( 'DSP1_INTP_CTL_IRQ_GEN', 2 )
        end

    end

    ############################################################################
    #
    # @function read_message_from_halo
    #
    # Reads the message from mailbox by checking mailbox status.
    #
    # @param optional The optional :negative parameter
    #
    # @return [boolean] True or false based on the result.
    #
    ############################################################################
    def read_message_from_halo( options = {})
        @test_type = options.fetch( :negative, nil )
        @response_time = options.fetch( :completion_event_wait_time, nil )
        if( VOICEID_DATA == @response_time )
            halo_response_time = @time_to_read_1sec_voiceid_data
        elsif( ASR_DATA == @response_time )
            halo_response_time = @time_to_read_1sec_2ch_asr_data
        elsif( RAW_DATA == @response_time )
            halo_response_time = @time_to_read_1sec_2ch_raw_data
        elsif( COMPLETION_EVENT == @response_time )
            halo_response_time = @time_to_wait_for_completion_event
        elsif 1 == @set_state_scenario
            halo_response_time = @set_state_response_time
            @set_state_scenario = 0
        else
            halo_response_time = @halo_response_time
        end
        $LOG.info "halo maximum response time is #{halo_response_time} msec"

        if true == @check_messages_using_mailbox
            start_time = DateTime.now.strftime( '%Q' )
            while( ( DateTime.now.strftime( '%Q' ).to_i - start_time.to_i ) <= halo_response_time )
                mailbox_status = get_mailbox_status( @arm_comms_outgoing_mailbox_base )
                if( mailbox_status == MAILBOX_FULL || mailbox_status == MAILBOX_HAS_MSGS )
                    $LOG.debug "start time is #{start_time.to_i}"
                    $LOG.debug "message recevied time is #{DateTime.now.strftime( '%Q' ).to_i}"
                    $LOG.debug "message received in #{DateTime.now.strftime( '%Q' ).to_i - start_time.to_i} msec"
                    break
                end
            end
        else
            start_time = DateTime.now.strftime( '%Q' )
            while( ( DateTime.now.strftime( '%Q' ).to_i - start_time.to_i ) <= halo_response_time )
                gpio_status = get_mailbox_interrupt_status
                $LOG.debug "gpio_status is #{gpio_status}"
                if MAILBOX_HAS_MSGS == gpio_status.to_i
                    $LOG.debug "start time is #{start_time.to_i}"
                    $LOG.debug "message recevied time is #{DateTime.now.strftime( '%Q' ).to_i}"
                    $LOG.debug "message received in #{DateTime.now.strftime( '%Q' ).to_i - start_time.to_i} msec"
                    #get_gpio_level = @@device.read_block_data( @halo_mailbox_interrupt_control_register_address , 4, true )
                    #$LOG.debug " mailbox interrupt control register data is : #{get_gpio_level}"
                    break
                end
            end
            mailbox_status = get_mailbox_status( @arm_comms_outgoing_mailbox_base )
        end

        if( MAILBOX_EMPTY == mailbox_status )
            mailbox_status = get_mailbox_status( @arm_comms_outgoing_mailbox_base )
            $LOG.info "mail box is empty" if ZERO == @message_count
        end
        msg_address = @arm_comms_outgoing_mailbox_base + ( MAILBOX_MESSAGE_OFFSET << 2 )
        result = nil

        if( @message_count > 0 )
            rd_idx_value = get_idx_value( @arm_comms_outgoing_mailbox_base, MAILBOX_RD_IDX_OFFSET )
            rd_msg_address = msg_address + ( rd_idx_value ) * ( ARM_COMMS_MSG_SIZE_MAX << 2 )
            #update read_index
            update_idx( @arm_comms_outgoing_mailbox_base, MAILBOX_RD_IDX_OFFSET )
            read_data = @@device.read_block_data( rd_msg_address, MSG_SIZE_IN_BYTES, true )

            result_data = parse_message( read_data )
            if( 1 == @test_type )
                result = result_data
            else
                if( 1 == result_data )
                    result = true
                else
                    result = false
                end
            end
        end

        if true != @check_messages_using_mailbox && 1 == @message_count
            get_gpio_level = @@device.read_block_data( @halo_mailbox_interrupt_control_register_address , 4, true )
            gpio_value = convert_byte_to_word( get_gpio_level, 0 )
            $LOG.debug "gpio_value is #{gpio_value}"
            set_gpio_value = gpio_value & @value_used_to_set_gpio_low
            gpio_array = []
            convert_word_to_byte( gpio_array, 0, set_gpio_value )
            @@device.write_block_data( @halo_mailbox_interrupt_control_register_address, gpio_array, true )
            get_mailbox_interrupt_status
        end
        return result
    end

    ############################################################################
    #
    # @function HALO_read_address
    #
    # read the data from the address provided in bytes of size
    #
    # @param [Integer] address The Starting address of buffer from which the
    #                  data to read
    #
    # @param [Integer] bytes The size mentioned in bytes how much data to be read
    #
    # @return read data as array
    #
    ############################################################################
    def HALO_read_address( address, bytes )
        return @@device.read_block_data( address, bytes, true )
    end

    ############################################################################
    #
    # @function write_buffer_data
    #
    # writes the butter data to a file
    #
    # @param [Integer] buffer The Starting address of buffer from which the
    #                  data to read
    #
    # @param [String] file_name The file name into which buffer data to be written
    #
    # @return None.
    #
    ############################################################################
    def write_buffer_data( buffer, file_name )
        FruitSaladUtils::write_buffer_data( buffer, file_name )
    end

    ############################################################################
    #
    # @function update_idx
    #
    # Updates the read/write index in the mailbox when some message is read/written
    #
    # @param mailbox_address The mailbox base address
    #        offset          The Read/Write offset in mailbox
    #
    # @return None.
    #
    ############################################################################
    def update_idx( mailbox_address, offset )
        read_value = get_idx_value( mailbox_address, offset )
        idx_value_increment = read_value + 1

        #Wrap the index to base if the index reached fifo full
        if( 3 == read_value )
            idx_value_increment = 0
        end

        array1 = []
        convert_word_to_byte( array1, 0, idx_value_increment )

        mailbox_idx_address = mailbox_address + ( offset << 2 )
        @@device.write_block_data( mailbox_idx_address, array1, true )
    end

    ############################################################################
    #
    # @function get_idx_value
    #
    # Reads the read/write index value from mailbox.
    #
    # @param mailbox_address The mailbox base address
    #        offset          The Read/Write offset in mailbox
    #
    # @return read_value Returns the read/write index value in mailbox.
    #
    ############################################################################
    def get_idx_value( mailbox_address, offset )
        mailbox_idx_address = mailbox_address + ( offset << 2 )
        idx_value = @@device.read_block_data( mailbox_idx_address, 4, true )
        read_value = convert_byte_to_word( idx_value, 0 )
        return read_value
    end

    ############################################################################
    #
    # @function get_mailbox_interrupt_status
    #
    # Reads the status of gpio register.
    #
    # @param mailbox_address The mailbox base address
    #
    # @return gpio_status Returns the status of gpio register
    #
    ############################################################################
    def get_mailbox_interrupt_status
        gpio_status = read_register_by_name( @halo_mailbox_interrupt_register_name )
        $LOG.info "GPIO_STATUS is #{gpio_status.to_i}"
        gpio_ctrl1 = read_register_by_name( @halo_mailbox_interrupt_control_register_name )
        $LOG.debug "gpio_ctrl1 is #{gpio_ctrl1}"
        return gpio_status
    end

    ############################################################################
    #
    # @function get_mailbox_status
    #
    # Reads the status of mailbox.
    #
    # @param mailbox_address The mailbox base address
    #
    # @return return_value Returns the status of mailbox
    #         MAILBOX_EMPTY     Returns if mailbox is empty
    #         MAILBOX_FULL      Returns if mailbox is full
    #         MAILBOX_HAS_MSGS  Returns if mailbox has messages
    #
    ############################################################################
    def get_mailbox_status( mailbox_address )
        rd_idx_value = get_idx_value( mailbox_address, MAILBOX_RD_IDX_OFFSET )
        wr_idx_value = get_idx_value( mailbox_address, MAILBOX_WR_IDX_OFFSET )
        if( rd_idx_value == wr_idx_value )
            return_value = MAILBOX_EMPTY
            @message_count = 0
        else
            number_of_messages = ( wr_idx_value - rd_idx_value ) % ARM_COMMS_FIFO_DEPTH
            $LOG.info "number of messages is #{number_of_messages}"
            if( number_of_messages > 0 )
                @message_count = number_of_messages
                if( number_of_messages == ( ARM_COMMS_FIFO_DEPTH - 1 ) )
                    return_value = MAILBOX_FULL
                else
                    return_value = MAILBOX_HAS_MSGS
                end
            end
        end
        return return_value
    end

    ############################################################################
    #
    # @function check_for_msg
    #
    # checks the message box has any messages for time specified and method will
    # break once the message box has message or specified time is completed
    #
    # @param halo_response_time Time mailbox base address
    #
    # @return [boolean] True or false based on the mailbox_status.
    #
    ############################################################################
    def check_for_msg( check_time )
        start_time = DateTime.now.strftime( '%Q' )
        while( DateTime.now.strftime( '%Q' ).to_i - start_time.to_i <= check_time )
            mailbox_status = get_mailbox_status( @arm_comms_outgoing_mailbox_base )
            if( mailbox_status == MAILBOX_FULL || mailbox_status == MAILBOX_HAS_MSGS )
                $LOG.debug "check_for_msg start time is #{start_time.to_i}"
                $LOG.debug "check_for_msg recevied time is #{DateTime.now.strftime( '%Q' ).to_i}"
                $LOG.debug "check_for_msg received in #{DateTime.now.strftime( '%Q' ).to_i - start_time.to_i} msec"
                break
            end
        end
        if ( mailbox_status == MAILBOX_FULL || mailbox_status == MAILBOX_HAS_MSGS )
            return true
        else
            return false
        end
    end

    ############################################################################
    #
    # @function get_message_count
    #
    # Reads the Number of messages in mailbox.
    #
    # @param mailbox_address The mailbox base address
    #
    # @return Returns the Number of messages in mailbox.
    #
    ############################################################################
    def get_message_count( mailbox_address )
        rd_idx_value = get_idx_value( mailbox_address, MAILBOX_RD_IDX_OFFSET )
        wr_idx_value = get_idx_value( mailbox_address, MAILBOX_WR_IDX_OFFSET )
        number_of_messages = ( wr_idx_value - rd_idx_value ) % ARM_COMMS_FIFO_DEPTH
        return number_of_messages
    end

    ############################################################################
    #
    # @function get_ssf_status
    #
    # tells whether ssf got fired or not.
    #
    # @return true if ssf is fired.
    #         false if ssf is not fired / failed.
    #
    ############################################################################
    def get_ssf_status()
        result = true
        msg_paylod_ofset = 2
        construct_halo_message( "GET_DBG_INFO", "GET_DBG_INFO_LEN", [ 10 ] )
        debug_event_rsp = read_message_from_halo( negative: 1 )
        if ( 1 == debug_event_rsp[ msg_paylod_ofset + 3 ] )
            if ( debug_event_rsp[ msg_paylod_ofset + 5 ] == debug_event_rsp[ msg_paylod_ofset + 4 ] )
                $LOG.error "SSF start and stop values are equal to #{ debug_event_rsp[ msg_paylod_ofset + 4 ] }"
                $LOG.error "SSF start/stop identification is not done correctly"
                result = false
            end
        else
            $LOG.error "Trigger is detected but SSF not fired"
            result = false
        end
        return result
    end

    ############################################################################
    #
    # @function parse_message
    #
    # Parses the message read from the halo outbox.
    #
    # @param read_data The data read from the halo outbox.
    #
    # @return 1 or 0 for positive testcase.
    #         The parsed data for negative testcase.
    #
    ############################################################################
    def parse_message( read_data )
        read_value = convert_byte_to_word( read_data, 0 )
        message_type_rsp = read_value
        $LOG.info "message_type_rsp is #{message_type_rsp}"

        read_value = convert_byte_to_word( read_data, 4 )
        message_len_rsp = read_value
        $LOG.info "message_len_rsp is #{message_len_rsp}"

        message_rsp_array = []
        message_rsp_array[ 0 ] = message_type_rsp
        message_rsp_array[ 1 ] = message_len_rsp
        payload_index = MSG_PAYLOAD_OFFSET * 4
        i = 2
        payload_length_rsp = message_len_rsp - 2

        payload_length_rsp.times do
            read_value = convert_byte_to_word( read_data, payload_index )
            message_rsp_array[ i ] = read_value
            $LOG.info "message_rsp_array is #{message_rsp_array[i]}"
            payload_index = payload_index + 4
            i = i + 1
        end

        if( 1 == @test_type )
            if 21 == message_rsp_array[ 0 ] && 1 == message_rsp_array[ 2 ]
                @state = 3
                if true == @check_ssf_debug_msg
                    trigger_event_rsp = message_rsp_array
                    msg_paylod_ofset = 2
                    if( @vte2_keyphrase_detector_id == message_rsp_array[ msg_paylod_ofset + 3 ] &&
                        @vte2_keyphrase_id == message_rsp_array[ msg_paylod_ofset + 4 ]
                      )
                        ssf_status = get_ssf_status
                        $LOG.debug "ssf_status value is #{ssf_status}"
                        if true == ssf_status
                            return trigger_event_rsp
                        else
                            return trigger_event_rsp[ 0..3 ]
                        end
                    elsif true == @check_vte1_ssf_debug_msg
                        ssf_status = get_ssf_status
                        $LOG.debug "ssf_status value is #{ssf_status}"
                        if true == ssf_status
                            return trigger_event_rsp
                        else
                            return trigger_event_rsp[ 0..3 ]
                        end
                    else
                        return trigger_event_rsp
                    end
                else
                    return message_rsp_array
                end
            elsif true == @read_eaudio_available_events
                if 21 == message_rsp_array[ 0 ] && 4 == message_rsp_array[ 2 ]
                    read_message_from_halo( negative: 1 )
                else
                    return message_rsp_array
                end
            else
                return message_rsp_array
            end
        end

        msg_paylod_ofset = 2
        result = 1
        case message_type_rsp
        when @@MsgType["SET_STATE_RSP"]
            $LOG.info "message type is SET_STATE_RSP while parsing"

            if( 1 == @state_neg_case &&
                ( @@ErrorCode["ERR_NO_ERR"] == message_rsp_array[ msg_paylod_ofset + 1 ] )
              )
                $LOG.error "No error thrown for invalid length"
                result = 0
            end
            if( @@MsgLength["SET_STATE_RSP_LEN"] != message_len_rsp )
                $LOG.error "SET_STATE_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @state )
                $LOG.error "SET_STATE_RSP state is not matched"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "SET_STATE_RSP error type not matched"
                result = 0
            end
        when @@MsgType["GET_STATE_RSP"]
            $LOG.info "message type is GET_STATE_RSP while parsing"
            if( @@MsgLength["GET_STATE_RSP_LEN"] != message_len_rsp )
                $LOG.error "GET_STATE_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @state )
                $LOG.error "GET_STATE_RSP state is not matched"
                result = 0
            end
            if( @channel_count != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "GET_STATE_RSP channel count not matched"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 2 ] )
                $LOG.error "GET_STATE_RSP error type not matched"
                result = 0
            end
        when @@MsgType["SET_BRGIN_STATE_RSP"]
            $LOG.info "message type SET_BRGIN_STATE_RSP while parsing"
            if( @@MsgLength["SET_BRGIN_STATE_RSP_LEN"] != message_len_rsp )
                $LOG.error "SET_BRGIN_STATE_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @enabled )
                $LOG.error "SET_BRGIN_STATE_RSP enable/disable not matched"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "SET_BRGIN_STATE_RSP error type not matched"
                result = 0
            end
        when @@MsgType["SET_MIC_OWNRSHP_RSP"]
            $LOG.info "message type is SET_MIC_OWNRSHP_RSP while parsing"
            if( @@MsgLength["SET_MIC_OWNRSHP_RSP_LEN"] != message_len_rsp )
                $LOG.error "SET_MIC_OWNRSHP_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @hip_owns_mics )
                $LOG.error "SET_MIC_OWNRSHP_RSP hip_owns_mics not matched"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "SET_MIC_OWNRSHP_RSP error type not matched"
                result = 0
            end
        when @@MsgType["READ_STRM_RSP"]
            $LOG.info "message type is READ_STRM_RSP while parsing"
            $LOG.info "@rd_strm_idle_state is #{@rd_strm_idle_state}"
            $LOG.info "message_rsp_array[msg_paylod_ofset+1] is #{message_rsp_array[ msg_paylod_ofset + 1 ]}"

            if( @rd_strm_idle_state == 1 &&
                ( @@ErrorCode["ERR_INVAL"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
              )
                $LOG.error "READ_STRM_RSP is not throwing error in Idle state"
                @rd_strm_idle_state = 0
                result = 0
            end
            if( @@MsgLength["READ_STRM_RSP_LEN"] != message_len_rsp )
                $LOG.error "READ_STRM_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @read_strm_type )
                $LOG.error "READ_STRM_RSP stream type not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] == @read_strm_type )
                range = ( 0..2 )
                unless range.include?(message_rsp_array[msg_paylod_ofset])
                    $LOG.error "READ_STRM_RSP is not with in the range"
                    result = 0
                end
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "READ_STRM_RSP error type not matched"
                if( @@ErrorCode["ERR_INVAL"] == message_rsp_array[ msg_paylod_ofset + 1 ] )
                    $LOG.error "READ_STRM_RSP given error type ERR_INVAL"
                elsif( @@ErrorCode["ERR_OVERFLOW"] == message_rsp_array[ msg_paylod_ofset + 1 ] )
                    $LOG.error "READ_STRM_RSP given error type ERR_OVERFLOW"
                end
                result = 0
            end
        when @@MsgType["CANCEL_RD_STRM_RSP"]
            $LOG.info "message type is CANCEL_RD_STRM_RSP while parsing"
            if( @@MsgLength["CANCEL_RD_STRM_RSP_LEN"] != message_len_rsp )
                $LOG.error "CANCEL_RD_STRM_RSP length not matched"
                result = 0
            end
            if( ( message_rsp_array[ msg_paylod_ofset ] != @cancel_rd_strm ) ||
                ( @@TStream["EStreamInvalid"]  == message_rsp_array[ msg_paylod_ofset ] ) )
                $LOG.error "CANCEL_RD_STRM_RSP stream type not matched or invalid stream type is requested"
                result = 0
            end
        when @@MsgType["GET_CURRENT_FRME_RSP"]
            $LOG.info "message type is GET_CURRENT_FRME_RSP while parsing"
            if( @@MsgLength["GET_CURRENT_FRME_RSP_LEN"] != message_len_rsp )
                $LOG.error "GET_CURRENT_FRME_RSP length not matched"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "GET_CURRENT_FRME_RSP error type not matched"
                result = 0
            end
        when @@MsgType["SET_STRM_MRKR_RSP"]
            $LOG.info "message type is SET_STRM_MRKR_RSP while parsing"
            if( @@MsgLength["SET_STRM_MRKR_RSP_LEN"] != message_len_rsp )
                $LOG.error "SET_STRM_MRKR_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @set_strm_marker )
                $LOG.error "SET_STRM_MRKR_RSP marker is not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] == @set_strm_marker )
                range = ( 0..3 )
                unless range.include?message_rsp_array[msg_paylod_ofset]
                    $LOG.error "SET_STRM_MRKR_RSP marker is not with in the range"
                    result = 0
                end
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 2 ] )
                $LOG.error "SET_STRM_MRKR_RSP error type not matched"
                result = 0
            end
        when @@MsgType["GET_STRM_MRKR_RSP"]
            $LOG.info "message type is GET_STRM_MRKR_RSP while parsing"
            if( @@MsgLength["GET_STRM_MRKR_RSP_LEN"] != message_len_rsp )
                $LOG.error "GET_STRM_MRKR_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @get_strm_marker )
                $LOG.error "GET_STRM_MRKR_RSP marker is not matched"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 2 ] )
                $LOG.error "GET_STRM_MRKR_RSP error type not matched"
                result = 0
            end
        when @@MsgType["GET_DBG_INFO_RSP"]
            $LOG.info "message type is GET_DBG_INFO_RSP while parsing"
            if( @@MsgLength["GET_DBG_INFO_RSP_LEN"] != message_len_rsp )
                $LOG.error "GET_DBG_INFO_RSP length not matched"
                result = 0
            end
            if( message_rsp_array[ msg_paylod_ofset ] != @debug_msg_type )
                $LOG.error "GET_DBG_INFO_RSP debug msg type not matched"
                result = 0
            end
            debugtype = message_rsp_array[ msg_paylod_ofset ]
            case debugtype
            when @@DebugInfoType["ESsfDbg"]
                if ( 1 == message_rsp_array[ msg_paylod_ofset + 3 ] )
                    if ( message_rsp_array[ msg_paylod_ofset + 5 ] == message_rsp_array[ msg_paylod_ofset + 4 ] )
                        $LOG.error "SSF start and stop values are equal to #{ message_rsp_array[ msg_paylod_ofset + 4 ] }"
                        $LOG.error "SSF is not fired correctly"
                        result = 0
                    end
                else
                    $LOG.error "SSF is not fired"
                    result = 0
                end
            end
        when @@MsgType["DSP_SS_EVNT"]
            $LOG.info "message type is DSP_SS_EVNT while parsing"
            event = message_rsp_array[ msg_paylod_ofset ]
            case event
            when @@TType["EKeyphraseDetect"]
                #whenever trigger detects puts state to Estream so that get state should return estream
                @state = 3
                if( @@MsgLength["DSP_SS_EVNT_TRIG_DETECT_LEN"] != message_len_rsp )
                    $LOG.error "DSP_SS_EVNT_TRIG_DETECT_LEN length not matched"
                    result = 0
                end
                if( @keyphrase_detector_id != message_rsp_array[ msg_paylod_ofset + 3 ] )
                    if ( @vte2_keyphrase_detector_id != message_rsp_array[ msg_paylod_ofset + 3 ] )
                        $LOG.error "EKeyphrase Detector ID not matched"
                        result = 0
                    end
                end
                if( @keyphrase_id != message_rsp_array[ msg_paylod_ofset + 4 ] )
                    if( @vte2_keyphrase_id != message_rsp_array[ msg_paylod_ofset + 4 ] )
                        $LOG.error "EKeyphrase ID not matched"
                        result = 0
                    end
                end
            when @@TType["EFatalError"]
                if( @@MsgLength["DSP_SS_EVNT_FATAL_ERR_LEN"] != message_len_rsp )
                    $LOG.error "DSP_SS_EVNT_FATAL_ERR_LEN length not matched"
                    result = 0
                end
                raise( 'EFatal Error' + $LOG.error('EFatal Error').to_s )
            when @@TType["EStreamXferCmplt"]
                if( @@MsgLength["DSP_SS_EVNT_STREAM_COMPLET_LEN"] != message_len_rsp )
                    $LOG.error "DSP_SS_EVNT_STREAM_COMPLET_LEN length not matched"
                    result = 0
                end
            when @@TType["EAudioAvailable"]
                if( @@MsgLength["DSP_SS_EVNT_AUDIO_AVAILABLE_LEN"] != message_len_rsp )
                    $LOG.error "DSP_SS_EVNT_AUDIO_AVAILABLE_LEN length not matched"
                    result = 0
                end
                if true == @read_eaudio_available_events
                    read_message_from_halo() if 0 != result
                end
            else
                $LOG.error "Unexpectd DSP_SS_EVNT type received"
                result = 0
            end
        when @@MsgType["DSP_SS_AWAKE"]
            $LOG.info "message type is DSP_SS_AWAKE while parsing"
            if( @@MsgLength["DSP_SS_AWAKE_LEN"] != message_len_rsp )
                $LOG.error "DSP_SS_AWAKE_LEN length not matched"
                result = 0
            end
            $LOG.info "FIRMWARE_VERSION is #{@firware_version}"
            $LOG.debug "message_rsp_array[msg_paylod_ofset] is #{message_rsp_array[msg_paylod_ofset]}"
            if( @firware_version != message_rsp_array[msg_paylod_ofset] )
                $LOG.error "DSP_SS_AWAKE Version not matched"
                result = 0;
            end
            if( @@TState[@halo_default_state] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "DSP_SS_AWAKE state not matched"
                result = 0;
            end
            if( @channel_count != message_rsp_array[ msg_paylod_ofset + 2 ] )
                $LOG.error "DSP_SS_AWAKE channel count not matched"
                result = 0;
            end
            @state = message_rsp_array[ msg_paylod_ofset + 1 ] if( 1 == result )
        when @@MsgType["SET_ENROLMENT_MODE_RSP"]
            $LOG.info "message type is SET_ENROLMENT_MODE_RSP while parsing"
            if( @@MsgLength["SET_ENROLMENT_MODE_RSP_LEN"] != message_len_rsp )
                $LOG.error "SET_ENROLMENT_MODE_RSP length not matched"
                result = 0
            end
            enrol_mode = message_rsp_array[ msg_paylod_ofset ]
            case enrol_mode
            when @@EnrolmentStatus["EnrolModeOk"]
                $LOG.info "Enrol Mode is Ok"
            when @@EnrolmentStatus["EnrolModeBlkMic"]
                $LOG.info "Enrol Mode Mics became blocked"
            else
                $LOG.error "Unexpectd Enrol Mode received"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "SET_ENROLMENT_MODE_RSP error type not matched"
                result = 0
            end
        when @@MsgType["GET_TALK_MODE_RSP"]
            $LOG.info "message type is GET_TALK_MODE_RSP while parsing"
            if( @@MsgLength["GET_TALK_MODE_RSP_LEN"] != message_len_rsp )
                $LOG.error "GET_TALK_MODE_RSP length not matched"
                result = 0
            end
            mode = message_rsp_array[ msg_paylod_ofset ]
            case mode
            when @@TalkMode["ENearTalk"]
                $LOG.info "ENearTalk mode is Detected"
            when @@TalkMode["ECloseTalk"]
                $LOG.info "ECloseTalk mode is Detected"
            when @@TalkMode["EUnknownTalk"]
                $LOG.info "EUnknownTalk mode is Detected"
            else
                $LOG.error "Unexpected TalkMode received"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                $LOG.error "GET_TALK_MODE_RSP error type not matched"
                result = 0
            end
        when @@MsgType["SET_EXT_TRGR_DET_RSP"]
            $LOG.info "message type is SET_EXT_TRGR_DET_RSP while parsing"
            if( @@MsgLength["SET_EXT_TRGR_DET_RSP_LEN"] != message_len_rsp )
                $LOG.error "SET_EXT_TRGR_DET_RSP length not matched"
                result = 0
            end
            if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset ] )
                $LOG.error "SET_EXT_TRGR_DET_RSP error type not matched"
                result = 0
            end
        else
            result = 0;
            $LOG.error "Unexpectd message response received"
        end # switch case end
        $LOG.info "************************************************************"
        return result
    end # parse_message method end

    ############################################################################
    #
    # @function get_data
    #
    # Gets the type of data required.
    #
    # @param type Type of data required
    #        key  The key value required.
    #
    # @return value Value of type and key
    #
    ############################################################################
    def get_data( type, key )
        case type
        when GET_MSG_TYPE
            value = @@MsgType[ key ]
        when GET_MSG_LEN
            value = @@MsgLength[ key ]
        when GET_HALO_STATE
            value = @@TState[ key ]
        when GET_ERR_CODE
            value = @@ErrorCode[ key ]
        when GET_STRM_TYPE
            value = @@TStream[ key ]
        when BARGE_IN_STATE
            value = @@BargeInState[ key ]
        when MIC_OWNER_SHIP
            value = @@MicOwnerShip[ key ]
        when TALK_MODE
            value = @@TalkMode[ key ]
        when ENROLMENT_MODE
            value = @@EnrolmentStatus[ key ]
        when EVENT_TYPE
            value = @@TType[ key ]
        when DEBUGINFO_TYPE
            value = @@DebugInfoType[ key ]
        else
            $LOG.info "Please give proper type"
        end
        return value
    end

    ############################################################################
    #
    # @function convert_word_to_byte
    #
    # Returns word in bytewise.
    #
    # @param array array to put the converted bytes
    #        index The index at which to store bytes.
    #        word  The word to covert to byte
    #
    # @return None.
    #
    ############################################################################
    def convert_word_to_byte( array, index, word )
        array[  index ] = ( ( word >> 24 ) & 0xFF )
        array[  index + 1 ] = ( ( word >> 16 ) & 0xFF )
        array[  index + 2 ] = ( ( word >> 8 ) & 0xFF )
        array[  index + 3 ] = ( ( word >> 0 ) & 0xFF )
    end

    ############################################################################
    #
    # @function convert_byte_to_word
    #
    # Returns constructed word out of the given bytes
    #
    # @param array        array of bytes
    #        index        The index at which to take bytes.
    #
    # @return return_word Return the converted word
    #
    ############################################################################
    def convert_byte_to_word( byte_array, index )
        return_word = byte_array[ index + 3 ]
        return_word = return_word + ( byte_array[ index + 2 ] << 8 )
        return_word = return_word + ( byte_array[ index + 1 ] << 16 )
        return_word = return_word + ( byte_array[ index + 0 ] << 24 )
        return return_word
    end

    ############################################################################
    #
    # @function halo_core_start_wait_time
    #
    # Wait until halo core enters into start state or into run state
    #
    # @return None
    #
    ############################################################################
    def halo_core_start_wait_time
        start_time = DateTime.now.strftime( '%Q' )
        while( DateTime.now.strftime( '%Q' ).to_i - start_time.to_i <= @halo_core_max_wait_time )
            halo_status = read_register_by_name( @halo_state_register_name )
            if( CORE_RUN == halo_status.to_i )
                break
            end
        end
    end

    ############################################################################
    #
    # @function purge_notification
    #        Checks whether the returned message from Vega contains the notification
    # which is to be ignored
    #
    # @param  [String] purge_notify  Notification message that to be ignored
    # @return [boolean]              if it receives the expected notification then returns true
    #                                else returns false
    #
    ############################################################################
    def purge_notification( purge_notify )

        # Variable
        no_user_identified = 255
        frame_payload_size = 4
        max_audio_processed = 73  # Status code
        data = []

        auth_result = @available_message[0].to_s(2).rjust(8,'0') + @available_message[1].to_s(2).rjust(8,'0')
        if @@message_header_hash[purge_notify].eql? auth_result
            purge_notify_end_time = DateTime.now.strftime( '%Q' ).to_i
            total_duration = purge_notify_end_time - @purge_notify_start_time
            $LOG.debug "Received the notification as #{purge_notify}"

            # Calculating total frames processed
            for i in 0...frame_payload_size
                data[i] = @available_message[2 + i].to_s(16).rjust(2, '0')
            end
            frame_data = data.reverse.join.to_i(16)
            $LOG.info "Strt_time : #{@purge_notify_start_time},\
                       End_time : #{purge_notify_end_time},\
                       duration : #{total_duration},\
                       Frames processed : #{frame_data},\
                       Users identified : #{@available_message[6..8]}".squeeze(" ")
            for rsp_user in @available_message[6..8]
                if @available_message[ 9 ] == @@failure_code["success"]
                    if (@expected_userid != rsp_user ) && ( @expected_userid != nil )
                        if ( rsp_user != no_user_identified )
                            raise "Invalid user identified Expected_user : #{@expected_userid}, Rsp_user:#{rsp_user} "
                        end
                    end
                else
                    if ( rsp_user == no_user_identified )
                        if( @available_message[ 9 ] == @@purge_notify_error)
                            return true
                        end
                        unless ( @available_message[ 9 ] == max_audio_processed )
                            raise "Auth notification result failed with and error code : #{@available_message[ 9 ]}"
                        end
                    else
                        raise "Received Invalid userid : #{rsp_user}"
                    end
                end
            end
            return true
        else
            return false
        end
    end

    ########################################################################
    #
    # @function check_for_interrupt_and_read_message
    #       This method check for the existance of the interrupt, if interrupt exist
    #  then read the 12 bytes of payload from the RXFIFO
    #
    # @param  [IntegerArray] message  2 bytes of header info [SI,Bulk,CRAN, Msgid ]
    # @param  [String]       cran     2 bits of cran field
    # @param  [String]       bulk     1 bit of bulk bit
    # @return [IntegerArray]          if the available message matches the header will
    #                                 return payload else FAIL (1)
    #
    ############################################################################
    def check_for_interrupt_and_read_message( message, cran, bulk )
        message_status = check_for_interrupt()
        if message_status
            read_available_data( MESSAGE_SIZE )
            service_instance, bulk_bit, rsp_cran ,message_id = parse_for_message_header
            return compare_message_header( message, cran, bulk )
        else
            $LOG.error "Unable to Receive Interrupt"
            return FAIL
        end
    end

    ############################################################################
    #
    # @function send_command_wait_for_ack
    #   API is used to send the command and wait for acknowledgement to receive
    # from the Vega.
    #
    # @param [String]      message_name command name for which the acknowledgement should be
    #                                   read
    # @param [String]      payload      payload for the command
    # @return[IntegerArray]             on sucess Integer array(10 bytes)
    #                                   on failure return 1 with message reason for failure.
    #
    #############################################################################
    def send_command_wait_for_ack( message_name, payload )
        message = construct_message( message_name, payload )
        write_data_with_padding( message )
        $LOG.info "waiting for  the Acknowledgement for the #{message_name}"
        return check_for_interrupt_and_read_message( message, ACK_CRAN, BULK_BIT_NOT_SET )
    end

    ############################################################################
    #
    # @function check_for_panic_notification
    #
    # This method is used capture the panic dump into file if vega responded with
    # Panic notification.
    #
    # @param [ String ] message - It refers to the message name in binary format.
    # @return - It returns boolean value [ True or false ].
    #
    ############################################################################
    def check_for_panic_notification( message )
        panic = message[0].to_s(2).rjust(8,'0') + message[1].to_s(2).rjust(8,'0')
        if @@message_header_hash["Notif_System_VegaPanic"].eql? panic
            return false
        else
            panic_notify = @available_message[0].to_s(2).rjust(8,'0') + @available_message[1].to_s(2).rjust(8,'0')
            if @@message_header_hash[ "Notif_System_VegaPanic" ].eql? panic_notify
                $LOG.info "Received the notification as #{ @@message_header_hash.key( panic_notify ) }"
                size = extract_bulk_size()
                read_available_data( size )
                current_time = DateTime.now.strftime "%d_%m_%Y_%H_%M"
                IO.write( "#{ ENV['FRUITSALAD_HOME'] }/tmp/panic#{current_time}.txt", @available_message )
                return true
            else
                return false
            end
        end
    end

end # class end
################################################################################