###############################################################################
##
## Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
##
## This software as well as any related documentation is furnished under
## license and may only be used or copied in accordance with the terms of the
## license. The information in this file is furnished for informational use
## only, is subject to change without notice, and should not be construed as
## a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
## (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
## that may appear in this document or any software that may be provided in
## association with this document.
##
## Except as permitted by such license, no part of this document may be
## reproduced, stored in a retrieval system, or transmitted in any form or by
## any means without the express written consent of Cirrus Logic International
## (UK) Ltd or affiliated companies.
##
### @file spi_protocol_steps.rb
### @brief cucumber step definition for spi protocol related test cases.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

include Defaults
#################################################################################
#
# @!method Then_SPI_is_enabled
#
# Connect to the FPGA board and check for the SPI and I2C control registers.
#
#       Usage:
#       Then SPI is enabled
#
# @raise [RunTimeError] Raise exception if SPI is not enabled.
#
#################################################################################
Then( /^SPI is enabled$/ ) do
    device = FruitSalad::get_device

    SystemName = Conf.property( :WISCE_SystemName, 'Aardvark' )
    DeviceNameLochnagar = Conf.property( :WISCE_DeviceNameLochnagar, 'WM0050' )

    device.connect( SystemName, DeviceNameLochnagar )
    spi_ctrl = device.read_element_value( 'SPI_CTRL' )
    i2c_ctrl = device.read_element_value( 'I2C_CTRL' )

    if '81' != spi_ctrl and '01' != i2c_ctrl
        raise 'SPI is not enabled.'
    end
end

#################################################################################
#
# @!method Then_the_speed_of_I2C_SPI_reliable
#
# Calculates the speed of I2C/SPI link.
#
# @example Then the speed of I2C/SPI is reliable
#
# @ param  Specifies the link I2C/SPI
#################################################################################
Then( /^the speed of "(.*)" is reliable$/ ) do | string |
    # Number of repeats - 1000 gives a real time equivalent average for a block read
    NUM_REPEATS = 1000
    # Clearwater Memory Constants
    DSP6_XM_CLWR = 0x320000
    # Florida Memory Constants
    DSP3_XM_FLORIDA = 0x1A0000

    # Minimum speed of the link in Kbps
    MIN_SPEED = 256

    # Array of block sizes to use for reads
    sizes = [1024]

    device = FruitSalad.get_device()
    system_name = Conf.property( :WISCE_SystemName, 'Aardvark' )
    device_name = Conf.property( :WISCE_DeviceName, 'WM1840' )
    device.connect( system_name, device_name )

    deviceID = device.device_id
    if( DEVICE_ID_CLEARWATER == deviceID )
         address = DSP6_XM_CLWR
    elsif( DEVICE_ID_FLORIDA == deviceID )
         address = DSP3_XM_FLORIDA
    else
        raise 'Unknown Codec'
    end
    sizes.each do |size|
        tms = Benchmark.measure { FruitSaladUtils::benchmark_reads( address, size, NUM_REPEATS ) }
        average = tms.real / NUM_REPEATS
        per_byte = average / size
        kbps = ( size * 8 ) / ( average * 1000 )
        printf( "real: %f avg: %f per_byte: %f kbps: %f\n", tms.real, average, per_byte, kbps )
        if kbps < MIN_SPEED
            raise 'Failed. The speed is not good enough'
        end
    end

end

#################################### END OF FILE  ################################