///////////////////////////////////////////////////////////////////////////////
///
///Copyright (c) 2014 Wolfson Microelectronics plc.  All rights reserved.
///
/// This software as well as any related documentation is furnished under 
/// license and may only be used or copied in accordance with the terms of the 
/// license. The information in this file is furnished for informational use 
/// only, is subject to change without notice, and should not be construed as 
/// a commitment by Wolfson Microelectronics plc. Wolfson Microelectronics plc
/// assumes no responsibility or liability for any errors or inaccuracies that
/// may appear in this document or any software that may be provided in
/// association with this document. 
///
/// Except as permitted by such license, no part of this document may be 
/// reproduced, stored in a retrieval system, or transmitted in any form or by 
/// any means without the express written consent of Wolfson Microelectronics plc. 
///
/// @file   options.h
/// @brief  A command line option parser.
///
/// @version \$Id: options.h 519 2014-11-27 09:11:11Z piotrs $
///
/// Warning
///   This software is specifically written for Wolfson devices. It may not be
///   used with other devices.
///
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Includes
///////////////////////////////////////////////////////////////////////////////

#include <string>
#include <vector>
#include <queue>
#include <map>
#include <memory>
#include <exception>
#include <iostream>
#include <algorithm>

///////////////////////////////////////////////////////////////////////////////
/// Enums
///////////////////////////////////////////////////////////////////////////////

enum ParserExitStatus { PARSING_SUCCESS = 0,
                        PARSING_ERROR = -1
                      };

enum ArgTokenType { NOT_PREFIXED,
                    LONG_OPTION,
                    SHORT_OPTION,
                    WINDOWS_STYLE_OPTION
                  };

enum OptionValueCount { NO_VALUE, SINGLE_VALUE };
enum OptionValueType { STRING_OPTION, INTEGER_OPTION, DOUBLE_OPTION };

///////////////////////////////////////////////////////////////////////////////
/// Constants
///////////////////////////////////////////////////////////////////////////////

static const std::string LONG_OPTION_PREFIX = "--";
static const std::string SHORT_OPTION_PREFIX = "-";
static const std::string WINDOWS_STYLE_OPTION_PREFIX = "/";

///////////////////////////////////////////////////////////////////////////////
/// Class declarations
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///
/// Class: Option
///
/// @brief Class defining an instance of a command line option.
///
/// @note This class may be used as a simple on/off option, but more importantly
///       is a base for any other kind of option which may be defined (for
///       instance @see ValuedOption<T>).
///
///////////////////////////////////////////////////////////////////////////////
class Option
{
public:
    Option();
    bool IsSet();
    bool IsSetExplicitly();
    void SetDefault();
    void SetExplicitly();

private:
    bool m_isSet, m_isSetDefault;
};

///////////////////////////////////////////////////////////////////////////////
///
/// Class: Command
///
/// @brief Class defining an instance of a command.
///
/// @note Commands are different from options in two respects. Firstly, if
///       a command is invoked it must be the first argument on the command
///       line. Secondly, a command may have specific options associated with
///       it.
///
///////////////////////////////////////////////////////////////////////////////
class Command
{
public:
    Command( const std::string &name );
    std::string Get() const;
    bool IsInvoked();
    void SetInvoked();
    void AssociateOption( const std::shared_ptr<Option> &option );
    bool ValidateOptions();

private:
    bool m_invoked;
    std::string m_name;
    std::vector<std::shared_ptr<Option>> m_associatedOptions;
};

bool IsCommandInvoked( const std::shared_ptr<Command> &command );

///////////////////////////////////////////////////////////////////////////////
///
/// Class: ValuedOption
///
/// @brief Class defining an instance of a command line option, which can hold
///        a value.
///
/// @note Currently the only supported types are the ones defined in
///       @see OptionValueType.
///
///////////////////////////////////////////////////////////////////////////////
template<typename T>
class ValuedOption : public Option
{
public:
    T GetValue();
    void SetValue( const T &value );

private:
    T m_value;
};

///////////////////////////////////////////////////////////////////////////////
///
/// Class: OptionDescriptor
///
/// @brief Class defining the description of a commandline option.
///
///////////////////////////////////////////////////////////////////////////////
class OptionDescriptor
{
public:
    OptionDescriptor( const std::string       &shortName,
                      const std::string       &longName,
                      const std::string       &description,
                      OptionValueCount        valueCount,
                      OptionValueType         valueType,
                      const std::string       &defaultValue,
                      std::shared_ptr<Option> option
                    );
    OptionValueCount GetValueCount();
    OptionValueType GetValueType();
    std::string GetShortName() const;
    std::string GetLongName() const;
    std::string GetDescription();
    std::shared_ptr<Option> GetOption();

private:
    OptionValueCount m_valueCount;
    OptionValueType m_valueType;
    std::string m_shortName;
    std::string m_longName;
    std::string m_description;
    std::string m_defaultValue;
    std::shared_ptr<Option> m_option;
};

///////////////////////////////////////////////////////////////////////////////
///
/// Class: Options
///
/// @brief Class defining an option parser.
///
/// @note The parser must be set up using Add* methods before invoking Parse.
///
///////////////////////////////////////////////////////////////////////////////
class Options
{
    typedef std::vector<std::shared_ptr<Command>> commandContainer;
    typedef std::vector<OptionDescriptor> optionDescriptorContainer;
public:
    ParserExitStatus Parse( int argc, char** argv );
    std::shared_ptr<Command> AddCommand( const std::string& name );
    template<typename T>
    std::shared_ptr<ValuedOption<T>> AddValuedOption( const std::string &shortName,
                                                      const std::string &longName,
                                                      const std::string &description,
                                                      OptionValueCount  valueCount,
                                                      OptionValueType   valueType,
                                                      const std::string &defaultValue
                                                    );
    void PrintUsage();

private:
    void SetProgramName( const std::string &programName );
    void SetCommand( const std::string &command);
    ParserExitStatus ParseCommand( std::queue<std::string> &args );
    ParserExitStatus ParseOptions( std::queue<std::string> &opts );
    ParserExitStatus ParseOption( std::queue<std::string> &opts );
    ArgTokenType ParseTokenType( const std::string &token );
    ArgTokenType ParseOptionTypeAndRemovePrefix( std::string &optionToken );
    ParserExitStatus ParseAndSetValue( OptionDescriptor &descriptor, std::string &valueToken );
    ParserExitStatus ValidateParse();

    commandContainer m_definedCommands;
    optionDescriptorContainer m_definedOptions;

    std::string m_programName;
    std::vector<std::string> m_options;
};

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: GetValue
///
/// @brief Gets an option value.
///
/// @return An option value.
///
///////////////////////////////////////////////////////////////////////////////
template<typename T>
T ValuedOption<T>::GetValue()
{
    return m_value;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: SetValue
///
/// @brief Sets an option value.
///
/// @param value A value to be set.
///
/// @return void
///
///////////////////////////////////////////////////////////////////////////////
template<typename T>
void ValuedOption<T>::SetValue( const T &value )
{
    SetDefault();
    m_value = value;
}

///////////////////////////////////////////////////////////////////////////////
/// 
/// Function: AddValuedOption
///
/// @brief Adds a valued option to the parser.
///
/// @param shortName    A short argument name.
/// @param longName     A long argument name.
/// @param description  A description of the option.
/// @param valueCount   Number of values the option can take
///                     (@see OptionValueCount).
/// @param valueType    Type of the option value (@see OptionValueType).
/// @param defaultValue Optional. A default value for the option.
///
/// @return A shared pointer to the added option.
///
///////////////////////////////////////////////////////////////////////////////
template<typename T>
std::shared_ptr<ValuedOption<T>> Options::AddValuedOption( const std::string &shortName,
                                                           const std::string &longName,
                                                           const std::string &description,
                                                           OptionValueCount   valueCount,
                                                           OptionValueType    valueType,
                                                           const std::string &defaultValue = ""
                                                         )
{
    std::shared_ptr<ValuedOption<T>> option( new ValuedOption<T> );
    m_definedOptions.push_back( OptionDescriptor( shortName,
                                                  longName,
                                                  description,
                                                  valueCount,
                                                  valueType,
                                                  defaultValue,
                                                  option
                                                )
                              );
    
    return option;
}

///////////////////////////////////////////////////////////////////////////////
/// Operators
///////////////////////////////////////////////////////////////////////////////

inline bool operator==( const std::shared_ptr<Command> &lhs, const std::string &rhs )
{
    return lhs->Get() == rhs;
}

inline bool operator==( const std::string &lhs, const std::shared_ptr<Command> &rhs )
{
    return lhs == rhs->Get();
}

inline bool operator!=( const std::shared_ptr<Command> &lhs, const std::string &rhs )
{
    return !( lhs == rhs );
}

inline bool operator!=( const std::string &lhs, const std::shared_ptr<Command> &rhs )
{
    return !( lhs == rhs );
}

inline bool operator==( const OptionDescriptor &lhs, const std::string &rhs )
{
    return lhs.GetShortName() == rhs || lhs.GetLongName() == rhs;
}

inline bool operator==( const std::string &lhs, const OptionDescriptor &rhs )
{
    return rhs.GetShortName() == lhs || rhs.GetLongName() == lhs;
}

inline bool operator!=( const OptionDescriptor &lhs, const std::string &rhs )
{
    return !( lhs == rhs );
}

inline bool operator!=( const std::string &lhs, const OptionDescriptor &rhs )
{
    return !( lhs == rhs );
}
/////////////////////////////END OF FILE///////////////////////////////////////