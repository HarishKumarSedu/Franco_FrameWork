################################################################################
###
### Copyright (c) 2017-2018 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file  wright_test.rb
### @brief Encapsulates all the test methods which deals with message
###        communicationof WRIGHT.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################
require 'configuration'
require 'csv'
require '../../fruit-salad/src/fruitsalad_utils.rb'
require_relative '../vega_tests/vega_test'

class Wright < Vega

    include FruitSaladUtils

    @@default_services = [ "0x5953", "0x4244", "0x4c41", "0x4152", "0x2323" ]

    @@MsgType1 = {
                  "WRITE_STRM" => 23,
                  "WRITE_STRM_RSP" => 24,
                  "SYNC_DSP_SS" => 25,
                  "SYNC_DSP_SS_RSP" => 26,
                  "CANCEL_WR_STRM" => 27,
                  "CANCEL_WR_STRM_RSP" => 28,
                  "READ_STRM_HDR" => 29,
                  "READ_STRM_HDR_RSP" => 30,
                  "WRITE_STRM_HDR" => 31,
                  "WRITE_STRM_HDR_RSP" =>32
                 }
    @@MsgType = @@MsgType.merge( @@MsgType1 )

    @@MsgLength1 = {
                    "WRITE_STRM_LEN" => 6,
                    "WRITE_STRM_HDR_LEN" => 7,
                    "WRITE_STRM_RSP_LEN" => 4,
                    "READ_STRM_HDR_LEN" => 8,
                    "READ_STRM_HDR_RSP_LEN" => 4,
                    "SYNC_DSP_SS_LEN" => 2,
                    "SYNC_DSP_SS_RSP_LEN" => 3,
                    "CANCEL_WR_STRM_LEN" => 3,
                    "CANCEL_WR_STRM_RSP_LEN" => 3,
                    "WRITE_STRM_HDR_RSP_LEN" => 4,
                    "Write_Stream_More_Message_Length" => 9
                   }
    @@MsgLength = @@MsgLength.merge( @@MsgLength1 )

    @@TStream1 = {
                  "ESCFFDataIn" => 2,
                  "ESCFFDataOut" => 3
                 }
    @@TStream = @@TStream.merge( @@TStream1 )

    @@TType1 = {
                "EStreamUnderFlow" => 4
               }
    @@TType = @@TType.merge( @@TType1 )

    ############################################################################
    #
    # @@message_header_hash is a dictionary that consists binary value of the
    # message with out the message data. Binary value is equal to 16 bits data
    # [5-bits for service_instance + 1-bit for bulk bit + 2-bits for CRAN + 8-bits
    # for Message-id ]
    #
    # Below hash is not finalised and it will grow up once the list of messages
    # are fixed
    #
    # Note:
    # The entries in the hash should follow below syntax,Shown for a example command
    #       1.Command       = Cmd_getsysteminfo
    #       2.Response      = Rsp_getsysteminfo
    #       3.Nofification  = Notif_Invalid
    #      If the command will contain only Response then there will be only 2
    #      elements i.e Command and Response
    #
    ############################################################################
    @@message_header_hash1 = {"Cmd_AlgoReadRegister" => "0001000000000001",
                              "Rsp_AlgoReadRegister" => "0001000100000001",
                              "Cmd_AlgoWriteRegister" => "0001000000000010",
                              "Rsp_AlgoWriteRegister" => "0001000100000010",
                              "Cmd_AlgoSetRegisters"   => "0001010000000101",
                              "Rsp_AlgoSetRegisters"   => "0001000100000101",
                              "Cmd_AlgoGetRegisters"   => "0001000000000100",
                              "Rsp_AlgoGetRegisters"   => "0001010100000100",
                              "Cmd_GetDebugInfoALGO" =>  "0001000011111111",
                              "Rsp_GetDebugInfoALGO" =>  "0001010111111111",
                              "Cmd_GetDebugInfoSS" =>  "0001000011111111",
                              "Rsp_GetDebugInfoSS" =>  "0001010111111111",
                              "Cmd_GetDebugInfoRAS" =>  "0001000011111111",
                              "Rsp_GetDebugInfoRAS" =>  "0001010111111111",
                              "Cmd_SetNotifyMode"    => "0001000000000110",
                              "Rsp_SetNotifyMode"   =>  "0001000100000110",
                              "Notif_ControlChange" => "0001001100000111",
                              "Cmd_Invoke_Panic" => "0000100000000000",
                              "Rsp_Invoke_Panic" => "0000100100000000",
                              "Cmd_GetAlgoDebugInfoCatCount" => "0001000011111101",
                              "Rsp_GetAlgoDebugInfoCatCount" => "0001000111111101",
                              "Cmd_GetAlgoDebugInfoPageCount" => "0001000011111110",
                              "Rsp_GetAlgoDebugInfoPageCount" => "0001000111111110",
                              "Cmd_GetSSDebugInfoCatCount" => "0000000011111101",
                              "Rsp_GetSSDebugInfoCatCount" => "0000000111111101",
                              "Cmd_GetSSDebugInfoPageCount" => "0000000011111110",
                              "Rsp_GetSSDebugInfoPageCount" => "0000000111111110",
                              "Cmd_GetRASDebugInfoCatCount" => "0001100011111101",
                              "Rsp_GetRASDebugInfoCatCount" => "0001100111111101",
                              "Cmd_GetRASDebugInfoPageCount" => "0001100011111110",
                              "Rsp_GetRASDebugInfoPageCount" => "0001100111111110"
                              }

    @@message_header_hash = @@message_header_hash.merge( @@message_header_hash1 )

    ############################################################################
    #
    # @function initialize
    #
    # default Constructor
    #
    ############################################################################
    def initialize
        super
        @halo_1_incoming_mailbox_base = Conf.property( :HALO_1_INCOMING_MAILBOX_BASE, nil )
        @halo_1_outgoing_mailbox_base = Conf.property( :HALO_1_OUTGOING_MAILBOX_BASE, nil )
        @halo_2_incoming_mailbox_base = Conf.property( :HALO_2_INCOMING_MAILBOX_BASE, nil )
        @halo_2_outgoing_mailbox_base = Conf.property( :HALO_2_OUTGOING_MAILBOX_BASE, nil )
    end

    ############################################################################
    #
    # @function construct_halo_message
    #
    # This function is used to construct the message, write the constructed message
    # in to mailbox.
    #
    # @param message_type    The message type to write in to mailbox
    #        message_length  The message length to write in to mailbox
    #        message_payload The message payload to write in to mailbox
    #
    # @return None.
    #
    ############################################################################
    def construct_halo_message( message_type, message_length, message_payload, options = {} )
        @wright_specific = options.fetch( :wright_specific, false )
        halo2 = options.fetch( :halo2, false )
        if halo2
            @arm_comms_incoming_mailbox_base = @halo_2_incoming_mailbox_base
            @arm_comms_outgoing_mailbox_base = @halo_2_outgoing_mailbox_base
        else
            @arm_comms_incoming_mailbox_base = @halo_1_incoming_mailbox_base
            @arm_comms_outgoing_mailbox_base = @halo_1_outgoing_mailbox_base
        end
        if @wright_specific
            construct_wright_halo_message( message_type, message_length, message_payload )
        else
            super( message_type, message_length, message_payload )
        end
    end

    ############################################################################
    #
    # @function construct_wright_halo_message
    #
    # This function is used to construct the message, write the constructed message
    # in to mailbox.
    #
    # @param message_type    The message type to write in to mailbox
    #        message_length  The message length to write in to mailbox
    #        message_payload The message payload to write in to mailbox
    #
    # @return None.
    #
    ############################################################################
    def construct_wright_halo_message( message_type, message_length, message_payload )
        message = Struct.new( :message_type, :message_length, :message_payload )
        set_state_message = message.new( message_type, message_length, message_payload )

        $LOG.info "construct_halo_message message_type is #{ message_type }"
        $LOG.info "construct_halo_message message_length is #{ message_length }"
        $LOG.info "construct_halo_message message_payload is #{ message_payload }"

        if( "WRITE_STRM" == message_type )
            if( @state == 0 )
                @wr_strm_idle_state = 1
                $LOG.info "@wr_strm_idle_state is #{@wr_strm_idle_state}"
            end
            @write_strm_type = message_payload[ 0 ]
        end
        if( "WRITE_STRM_HDR" == message_type )
            if( @state == 0 )
                @wr_strm_idle_state = 1
                $LOG.info "@wr_strm_idle_state is #{@wr_strm_idle_state}"
            end
            @write_strm_hdr_type = message_payload[ 0 ]
        end
        if( "READ_STRM_HDR" == message_type )
            if( @state == 0 )
                @rd_strm_idle_state = 1
                $LOG.info "@rd_strm_idle_state is #{@rd_strm_idle_state}"
            end
            @read_strm_hdr_type = message_payload[ 0 ]
        end

        if( "CANCEL_WR_STRM" == message_type )
            @cancel_wr_strm = message_payload[ 0 ]
            $LOG.info "#### @cancel_wr_strm is #{@cancel_wr_strm}"
        end
        write_message_to_halo( set_state_message )
    end

    ############################################################################
    #
    # @function read_message_from_halo
    #
    # Reads the message from mailbox by checking mailbox status.
    #
    # @param optional The optional :negative parameter
    # @param optional The optional :wright_specific parameter
    #
    # @return [boolean] True or false based on the result.
    #
    ############################################################################
    def read_message_from_halo( options = {})
        @test_type = options.fetch( :negative, nil )
        fun_type = options.fetch( :wright_specific, false )
        halo2 = options.fetch( :halo2, false )
        if halo2
            @arm_comms_incoming_mailbox_base = @halo_2_incoming_mailbox_base
            @arm_comms_outgoing_mailbox_base = @halo_2_outgoing_mailbox_base
        else
            @arm_comms_incoming_mailbox_base = @halo_1_incoming_mailbox_base
            @arm_comms_outgoing_mailbox_base = @halo_1_outgoing_mailbox_base
        end
        start_time = DateTime.now.strftime( '%Q' )
        halo_response_time = @halo_response_time

        $LOG.info "halo maximum response time is #{halo_response_time} msec"

        start_time = DateTime.now.strftime( '%Q' )
        while( ( DateTime.now.strftime( '%Q' ).to_i - start_time.to_i ) <= halo_response_time )
            mailbox_status = get_mailbox_status( @arm_comms_outgoing_mailbox_base )
            if( mailbox_status == MAILBOX_FULL || mailbox_status == MAILBOX_HAS_MSGS )
                $LOG.debug "start time is #{start_time.to_i}"
                $LOG.debug "message recevied time is #{DateTime.now.strftime( '%Q' ).to_i}"
                $LOG.debug "message received in #{DateTime.now.strftime( '%Q' ).to_i - start_time.to_i} msec"
                break
            end
        end

        if( MAILBOX_EMPTY == mailbox_status )
            $LOG.info "mail box empty"
            mailbox_status = get_mailbox_status( @arm_comms_outgoing_mailbox_base )
        end
        msg_address = @arm_comms_outgoing_mailbox_base + ( MAILBOX_MESSAGE_OFFSET << 2 )
        result = nil

        if( @message_count > 0 )
            rd_idx_value = get_idx_value( @arm_comms_outgoing_mailbox_base, MAILBOX_RD_IDX_OFFSET )
            rd_msg_address = msg_address + ( rd_idx_value ) * ( ARM_COMMS_MSG_SIZE_MAX << 2 )
            #update read_index
            update_idx( @arm_comms_outgoing_mailbox_base, MAILBOX_RD_IDX_OFFSET )
            read_data = @@device.read_block_data( rd_msg_address, MSG_SIZE_IN_BYTES, true )

            result_data = parse_message( read_data ,fun_type)
            if( 1 == @test_type )
                result = result_data
            else
                if( 1 == result_data )
                    result = true
                else
                    result = false
                end
            end
        end
        return result
    end

    ############################################################################
    #
    # @function parse_message
    #
    # Parses the message read from the halo outbox.
    #
    # @param read_data The data read from the halo outbox.
    # @param fun_type  The wright_specific parameter
    #
    # @return 1 or 0 for positive testcase.
    #         The parsed data for negative testcase.
    #
    ############################################################################
    def parse_message( read_data, fun_type)
        if fun_type
            parse_wright_message( read_data )
        else
            super( read_data )
        end
    end

    ############################################################################
    #
    # @function parse_wright_message
    #
    # Parses the message read from the halo outbox.
    #
    # @param read_data The data read from the halo outbox.
    #
    # @return 1 or 0 for positive testcase.
    #         The parsed data for negative testcase.
    #
    ############################################################################
    def parse_wright_message( read_data )
        read_value = convert_byte_to_word( read_data, 0 )
        message_type_rsp = read_value
        $LOG.info "message_type_rsp is #{message_type_rsp}"
        read_value = convert_byte_to_word( read_data, 4 )
        message_len_rsp = read_value
        $LOG.info "message_len_rsp is #{message_len_rsp}"

        message_rsp_array = []
        message_rsp_array[ 0 ] = message_type_rsp
        message_rsp_array[ 1 ] = message_len_rsp
        payload_index = MSG_PAYLOAD_OFFSET * 4
        i = 2
        payload_length_rsp = message_len_rsp - 2

        payload_length_rsp.times do
            read_value = convert_byte_to_word( read_data, payload_index )
            message_rsp_array[ i ] = read_value
            $LOG.info "message_rsp_array is #{message_rsp_array[i]}"
            payload_index = payload_index + 4
            i = i + 1
        end

        if( 1 == @test_type )
            return message_rsp_array
        end

        msg_paylod_ofset = 2
        result = 1
        case message_type_rsp
            when @@MsgType["WRITE_STRM_RSP"]
                $LOG.info "message type is WRITE_STRM_RSP while parsing"
                $LOG.info "@wr_strm_idle_state is #{@wr_strm_idle_state}"
                $LOG.info "message_rsp_array[msg_paylod_ofset+1] is #{message_rsp_array[ msg_paylod_ofset + 1 ]}"

                if( @wr_strm_idle_state == 1 &&
                    ( @@ErrorCode["ERR_INVAL"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                  )
                    $LOG.error "WRITE_STRM_RSP is not throwing error in Idle state"
                    @rd_strm_idle_state = 0
                    result = 0
                end
                if( @@MsgLength["WRITE_STRM_RSP_LEN"] != message_len_rsp )
                    $LOG.error "WRITE_STRM_RSP length not matched"
                    result = 0
                end
                if( message_rsp_array[ msg_paylod_ofset ] != @write_strm_type )
                    $LOG.error "WRITE_STRM_RSP stream type not matched"
                    result = 0
                end
                if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                    $LOG.error "WRITE_STRM_RSP error type not matched"
                    result = 0
                end
                if( message_rsp_array[ msg_paylod_ofset ] == @write_strm_type )
                    range = ( 0..3 )
                    unless range.include?(message_rsp_array[msg_paylod_ofset])
                        $LOG.error "WRITE_STRM_RSP is not with in the range"
                        result = 0
                    end
                end
            when @@MsgType["READ_STRM_HDR_RSP"]
                $LOG.info "message type is READ_STRM_HDR_RSP while parsing"
                $LOG.info "@rd_strm_idle_state is #{@rd_strm_idle_state}"
                $LOG.info "message_rsp_array[msg_paylod_ofset+1] is #{message_rsp_array[ msg_paylod_ofset + 1 ]}"

                if( @rd_strm_idle_state == 1 &&
                    ( @@ErrorCode["ERR_INVAL"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                  )
                    $LOG.error "READ_STRM_HDR_RSP is not throwing error in Idle state"
                    @rd_strm_idle_state = 0
                    result = 0
                end
                if( @@MsgLength["READ_STRM_HDR_RSP_LEN"] != message_len_rsp )
                    $LOG.error "READ_STRM_HDR_RSP length not matched"
                    result = 0
                end
                if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                    $LOG.error "READ_STRM_HDR_RSP error type not matched"
                    result = 0
                end
                if( message_rsp_array[ msg_paylod_ofset ] == @read_strm_hdr_type )
                    range = ( 0..3 )
                    unless range.include?(message_rsp_array[msg_paylod_ofset])
                        $LOG.error "READ_STRM_HDR_RSP is not with in the range"
                        result = 0
                    end
                end
            when @@MsgType["WRITE_STRM_HDR_RSP"]
                $LOG.info "message type is WRITE_STRM_HDR_RSP while parsing"
                $LOG.info "@wr_strm_idle_state is #{@wr_strm_idle_state}"
                $LOG.info "message_rsp_array[msg_paylod_ofset+1] is #{message_rsp_array[ msg_paylod_ofset + 1 ]}"

                if( @wr_strm_idle_state == 1 &&
                    ( @@ErrorCode["ERR_INVAL"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                  )
                    $LOG.error "WRITE_STRM_HDR_RSP is not throwing error in Idle state"
                    @rd_strm_idle_state = 0
                    result = 0
                end
                if( @@MsgLength["WRITE_STRM_HDR_RSP_LEN"] != message_len_rsp )
                    $LOG.error "WRITE_STRM_HDR_RSP length not matched"
                    result = 0
                end
                if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset + 1 ] )
                    $LOG.error "WRITE_STRM_HDR_RSP error type not matched"
                    result = 0
                end
                if( message_rsp_array[ msg_paylod_ofset ] == @write_strm_hdr_type )
                    range = ( 0..3 )
                    unless range.include?(message_rsp_array[msg_paylod_ofset])
                        $LOG.error "WRITE_STRM_HDR_RSP is not with in the range"
                        result = 0
                    end
                end
            when @@MsgType["SYNC_DSP_SS_RSP"]
                $LOG.info "message type is SYNC_DSP_SS_RSP while parsing"
                if( @@MsgLength["SYNC_DSP_SS_RSP_LEN"] != message_len_rsp )
                    $LOG.error "SYNC_DSP_SS_RSP length not matched"
                    result = 0
                end
                if( @@ErrorCode["ERR_NO_ERR"] != message_rsp_array[ msg_paylod_ofset ] )
                    $LOG.error "SYNC_DSP_SS_RSP error type not matched"
                    result = 0
                end

            when @@MsgType["CANCEL_WR_STRM_RSP"]
                $LOG.info "message type is CANCEL_WR_STRM_RSP while parsing"
                if( @@MsgLength["CANCEL_WR_STRM_RSP_LEN"] != message_len_rsp )
                    $LOG.error "CANCEL_WR_STRM_RSP length not matched"
                    result = 0
                end
                if( ( message_rsp_array[ msg_paylod_ofset ] != @cancel_wr_strm ) ||
                    ( @@TStream["EStreamInvalid"]  == message_rsp_array[ msg_paylod_ofset ] ) )
                    $LOG.error "CANCEL_WR_STRM_RSP stream type not matched or invalid stream type is requested"
                    result = 0
                end
            when @@MsgType["DSP_SS_EVNT"]
                $LOG.info "message type is DSP_SS_EVNT while parsing"
                event = message_rsp_array[ msg_paylod_ofset ]
                case event
                    when @@TType["EKeyphraseDetect"]
                        #whenever trigger detects puts state to Estream so that get state should return estream
                        @state = 3
                        if( @@MsgLength["DSP_SS_EVNT_TRIG_DETECT_LEN"] != message_len_rsp )
                            $LOG.error "DSP_SS_EVNT_TRIG_DETECT_LEN length not matched"
                            result = 0
                        end
                        if( @keyphrase_detector_id != message_rsp_array[ msg_paylod_ofset + 3 ] )
                            $LOG.error "EKeyphrase Detector ID not matched"
                            result = 0
                        end
                        if( @keyphrase_id != message_rsp_array[ msg_paylod_ofset + 4 ] )
                            $LOG.error "EKeyphrase ID not matched"
                            result = 0
                        end
                    when @@TType["EFatalError"]
                        if( @@MsgLength["DSP_SS_EVNT_FATAL_ERR_LEN"] != message_len_rsp )
                            $LOG.error "DSP_SS_EVNT_FATAL_ERR_LEN length not matched"
                            result = 0
                        end
                        raise( 'EFatal Error' + $LOG.error('EFatal Error').to_s )
                    when @@TType["EStreamUnderFlow"]
                        $LOG.error "DSP_SS_EVNT_EStreamUnderFlow is occured"
                        result = 0
                    when @@TType["EStreamXferCmplt"]
                        if( @@MsgLength["DSP_SS_EVNT_STREAM_COMPLET_LEN"] != message_len_rsp )
                            $LOG.error "DSP_SS_EVNT_STREAM_COMPLET_LEN length not matched"
                            result = 0
                        end
                    else
                        $LOG.error "Unexpectd DSP_SS_EVNT type received"
                        result = 0
                end
            else
                result = 0;
                $LOG.error "Unexpectd message response received"
        end # switch case end
        $LOG.info "************************************************************"
        return result
    end # parse_message method end

    ############################################################################
    #
    # @function write_bulk_wright
    #
    # The API is used to write bulk data in to Wright.
    #  Generally this API used to send bulk of challange bits and other data to
    #   Wright
    #
    # @param [string]        message_name  name of the command
    # @param [string]        payload   string of hex values
    # @param [string]        bulk_data string of hex values
    # @param [optional]      :time_delay - It represent waiting time in seconds.
    #
    # @return [IntegerArray] If message status is true returns message
    #                        payload else returns FAIL value
    #
    ############################################################################
    def write_bulk_wright( message_name, payload, bulk_data, opts={} )
        time_delay = opts[:time]
        no_memory = opts[:no_memory]
        if PAYLOAD_LENGTH == payload.length
            str_size = bulk_data.size.to_s(16).rjust(8,'0')
            size = str_size.scan(/../).reverse.join
            if size.casecmp( payload[0...8] )
                message = construct_message( message_name,
                                             payload
                                           )
                @bulk_data = bulk_data
                write_data_with_padding( message )
                message_status = check_for_interrupt

                unless time_delay == nil
                    $LOG.info "Time delay after sending voiceid command : #{time_delay}"
                    sleep( time_delay )
                end
                if message_status
                    read_available_data( MESSAGE_SIZE )
                    service_instance = message[0].to_s(2).rjust(8,'0')
                    payload = ""
                    message = construct_message( RX_DMA_MESSAGE , payload )
                    payload = compare_message_header( message,
                                                      RESPONSE_NOTIFY,
                                                      BULK_BIT_NOT_SET
                                                    )

                    if payload.class == Array
                        success_code = @available_message[2]
                        if SUCCESS_CODE == success_code
                            rx_dma_payload = rx_dma_status_functionality( message_name )
                            result = ( rx_dma_payload.class == String || rx_dma_payload.class == Array )
                            if ( result )
                                return @available_message
                            elsif ( NO_INTERRUPT_AVAILABLE == rx_dma_payload )
                                $LOG.error "No interrupt after writing the Data"
                                return FAIL
                            end
                        else
                            if no_memory
                                return @available_message
                            else
                                $LOG.error "NO Memory Error"
                                return FAIL
                            end
                        end
                    else
                        $LOG.error "Invalid response from Wright : #{@available_message}"
                        return FAIL
                    end
                else
                    $LOG.error "Unable to receive interrupt"
                    return FAIL
                end
            else
                $LOG.error "input size and data size not equal"
                return FAIL
            end
        else
            $LOG.error "Invalid input payload size #{payload.length} should be 20"
            return FAIL
        end
    end

end # class end
################################################################################