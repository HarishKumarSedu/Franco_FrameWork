# encoding: utf-8
###############################################################################
###
### Copyright (c) 2014-2017 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   RemoteSalad.rb
### @brief  FruitSalad device specialisation for *nix devices controlled via
###         ssh (e.g. Arndale, Raspberry Pi).
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

#
# Includes
#
require 'fruitsalad_remote_base'
require 'generate_script'
require 'saladmix_invoke'
require 'tinyalsa_inspect'
require 'fruitsalad_utils'
require 'linux_firmware'
require 'wisce_bridge_client'
require 'linux_jack_detection'
require 'fileutils'
require 'logfw'
# Firmware test components
require 'test_components/soundclear_control_linux'
require 'test_components/pass_through_linux'
require 'portaudio_client'
require 'pa_multitrack'
require 'result'

###############################################################################
#
# Implementation of Fruit Salad for SSH connected android devices.
#
###############################################################################
module FruitSalad
    extend FruitSaladRemoteBase
    extend TinyAlsaInspect
    extend WISCEBridgeClient

    ###########################################################################
    #
    # Device Specialisation
    #
    ###########################################################################
    class RemoteSalad < FruitSaladRemoteBase::RemoteDeviceInterface
        # Import config variables for saladmix.
        include SaladMixInvoker
        include LinuxFirmware
        include LinuxJackDetection

        #
        # Controls what mechanism should be used to access information stored
        # in chip registers
        #
        ChipInfoAccess = Conf.property( :Linux_ChipInfoAccess, 'native' ).to_sym
        # The folder where usecase scripts can be found.
        UsecasePath = Conf.property( :UsecasePath, 'remote_usecases' )
        # The sample rate to request for both playback and record.
        SampleRate = Conf.property( :SampleRate, nil )
        #
        # A directory on the target machine which we can safely clobber with
        # our files. Should end in a trailing directory seperator.
        #
        TempDir = Conf.property( :Remote_TempDir, '/tmp/fruitsalad/' )
        # A list of usecase scripts to invoke when usecase :default is called.
        # Can be overwritten with the config variable DefaultUsecases
        DefaultUsecases = Conf.property( :DefaultUsecases, [
                                                         'Playback_to_Headset',
                                                         'Record_from_Headset'
                                                           ]
                                       )
        #
        # Index of the audio card to test (supplied to tinyalsa tools with:
        # -D <card>)
        #
        AudioCardIndex = Conf.property( :Linux_AudioCardIndex, 0 )
        #
        # Index of the audio device to test (supplied to crec tools with:
        # -d<DeviceNode>)
        #
        DeviceNode = Conf.property( :Linux_DeviceNode, 1 )
        # Directory pointing to regmap
        RegmapDebugfsRoot = '/sys/kernel/debug/regmap'
        # 16 bit regmap name
        Regmap16bit = Conf.property( :Linux_Regmap16bit, 'spi1.0-moon_16bit' )
        # 32 bit regmap name
        Regmap32bit = Conf.property( :Linux_Regmap32bit, 'spi1.0-moon_32bit' )
        # Directory containing ASoC debugfs nodes
        ASoCDebugfsRoot = '/sys/kernel/debug/asoc'
        #
        # Card name (can be found in the machine driver) required to locate
        # debugfs entries
        #
        CardName = Conf.property( :Linux_ASoCCardName, nil )
        #
        # Codec name (can be found in the codec driver) required to locate
        # debugfs entries
        #
        CodecName = Conf.property( :Linux_ASoCCodecName, nil )
        AudioDevice = Conf.property( :CodecName, 'moon' )
        # BitDepth supported
        Bitdepth = Conf.property( :Bitdepth, 16 )

        # Autrace_decode_error
        INVALID_INPUT_FILE = 234

        # Boolean indicates whether to return error code or not.
        ReturnErrorCodes = Conf.property( :ReturnErrorCodes, true )

        UnrecoginsedChipInfoAccessMsg = 'Unrecognised register and firmware ' \
                                        'information access method. (hint: '  \
                                        'valid methods are - %{valid_methods})'
        NumberOfDSPCores = Conf.property( :NumberOfDSPCores, nil )
        DEVICE_ID_REG_ADDR = 0
        HW_REV_REG_ADDR = 1
        HW_REVISION_WIDTH = 0xFF
        RUNNING = 'Y'

        attr_reader :playback_active
        attr_reader :recording_active
        attr_reader :analog_playback_active
        attr_reader :analog_recording_active
        attr_reader :digital_playback_active
        attr_reader :digital_recording_active

        attr_reader :compressed_recording_active
        attr_reader :time_stamp

        #######################################################################
        #
        # @function initialize
        #
        # Default constructor
        #
        # Resets our card.
        #
        # @raise [RuntimeError] An exception is raised if creation of a remote
        #                       temporary directory fails.
        # @raise [RuntimeError] An exception is raised if saladmix can not be
        #                       made executable.
        #
        #######################################################################
        def initialize

            # Final errors logged related arguments.
            $log_count = 0
            $time_stamp_array = []

            initialize_firmware_components()

            ret_val = connect
            if ret_val.status_code != 0 && ReturnErrorCodes
                raise ret_val.error_info + $LOG.error(ret_val.error_info).to_s
            end
            @default_usecases = DefaultUsecases

            ret_val = exec! "mkdir -p #{TempDir}"
            exit_code = ret_val.data
            unless 0 == exit_code
                raise 'RemoteSalad: Failed to create remote temporary '       \
                      'directory.'
            end

            ret_val = exec! "rm -f #{TempDir}*"
            exit_code = ret_val.data
            unless 0 == exit_code
                raise 'RemoteSalad: Failed to delete remote '       \
                      'directory contents.'
            end
            if true == SaladMixUpload and nil != SaladMixLocation
                upload( SaladMixLocation, TempDir )
                basename = File.basename( SaladMixLocation )
                @saladmix_binary = "#{TempDir}#{basename}"
                ret_val = exec! "chmod +x #{@saladmix_binary}"
                exit_code = ret_val.data
                unless 0 == exit_code
                    raise 'RemoteSalad: Failed to make saladmix executable.'
                end
            end
            if false == SaladMixUpload and nil != SaladMixLocation
                @saladmix_binary = SaladMixLocation
            end

            exec! 'killall wbridge'

            @wiscebridge_started = false

            @playback_active = false
            @recording_active = false
            @analog_playback_active = false
            @analog_recording_active = false
            @digital_playback_active = false
            @digital_recording_active = false
            @compressed_recording_active = false

            at_exit do
                exec! 'killall tinycap'
                exec! 'killall wbridge'
                exec! 'killall crec'

                cleanup
            end

            @jack_detection_invoker = JDInvoker.new( @session )
        end

        #######################################################################
        #
        # @function initialize_firmware_components
        #
        # Loads the testing components for our firmware algorithms.
        #
        #######################################################################
        def initialize_firmware_components
            @soundclear_control = SoundClearControlForLinux.new( self )
            @pass_through = PassThroughFirmwareForLinux.new( self )
        end

        #######################################################################
        #
        # @function initialize_wiscebridge
        #
        # Starts WISCEBridge on the remote system, provided it is not already
        # running.
        #
        # @note This function is meant to be invoked at the beginning of any
        #       methods using WISCEBridge™, rather than in the initialize
        #       routine. Thanks to this tests which do not require the usage of
        #       WISCEBridge™ will run smoothly without it on the remote system.
        #
        # @param timeout  Amount of time in seconds to wait for WISCEBridge
        #                 before throwing an exception.
        #
        # @return void
        #
        # @raise [RuntimeError] An exception is thrown if WISCEBridge was not
        #                       found on the remote system or if it did not
        #                       start successfully.
        # @raise [RuntimeError] An exception is thrown if a pseudo-tty can not
        #                       be obtained.
        # @raise [RuntimeError] An exception is thrown if WISCEBridge does not
        #                       start before the supplied timeout.
        #
        #######################################################################
        def initialize_wiscebridge( timeout = 10 )
            if !@wiscebridge_started
                ret_val = exec! 'type wbridge'
                exists = ret_val.data
                unless 0 == exists
                    raise 'RemoteSalad: WISCEBridge is not installed on the ' \
                          'remote system (information on installing '         \
                          'WISCEBridge can be found in FruitSalad docs).'
                end

                @session.open_channel do |ch|
                    ch.request_pty do |chl, success|
                        unless success
                            raise 'RemoteSalad: Could not obtain pseudo-tty.'
                        end
                    end

                    ch.exec 'echo 1 | wbridge' do |chl, success|
                        unless success
                            raise 'RemoteSalad: Could not execute WISCEBridge.'
                        end

                        ch.on_data do |c,data|
                            if !data.index( /Waiting for connection on port \d+\./ ).nil?
                                @wiscebridge_started = true
                            end
                        end

                        ch.on_close do
                            @wiscebridge_started = false
                            $LOG.info 'RemoteSalad: WISCEBridge successfully '     \
                                 'terminated.'
                        end
                    end
                end

                start_time = Time.now
                @session.loop(1) do
                    end_time = Time.now
                    if end_time - start_time > timeout
                        raise 'RemoteSalad: WISCEBridge is taking too long to'\
                              ' start.'
                    end
                    !@wiscebridge_started
                end
            end
            return
        end

        #######################################################################
        #
        # Device specific implimentation that specifies how to load a usecase
        # script with the given name.
        #
        # @param [String] file_prefix      The name of the usecase script
        #                                  excluding file extension (i.e. csv)
        #
        # @param [Hash]   opts  Optional usecase_from_file arguments. This
        #                       supports: [String] source_path - location of
        #                       file to load (default value is nil).
        #                       [String] destination_path - location of file
        #                       to load (default value is nil)
        #
        # @raise [RuntimeError] An exception is raised if a usecase script can
        #                       not be made executable.
        # @raise [RuntimeError] An exception is raised if a usecase script is
        #                       not executed successfully.
        # @raise [RuntimeError] An exception is raised if saladmix execution
        #                       fails.
        #
        #######################################################################
        def usecase_from_file( file_prefix, opts = {} )
            supported_opts = [ :source_path, :destination_path]
            validate_options( opts.keys, supported_opts, 'RemoteSalad: (usecase_from_file)' )

            usecase_path = opts.fetch( :source_path, nil )
            destination_path = opts.fetch( :destination_path, nil )

            if usecase_path.nil?
                usecase_path = UsecasePath
            end
            if destination_path.nil?
                destination_path = TempDir
            end
            local_file = File.join( usecase_path, file_prefix + ".csv" )
            if nil == @saladmix_binary # Fall back on shell script
                $LOG.info "Generating bash script."
                script = GenerateScript::Script.new( local_file )
                local_file = script.script_name
                upload( local_file, TempDir )

                ret_val = exec! "chmod +x #{destination_path}#{local_file}"
                exit_code = ret_val.data
                unless 0 == exit_code
                    raise "RemoteSalad: Failed to make "                      \
                          "#{TempDir}#{local_file} executable."
                end

                timed_cmd "Executing usecase script: #{local_file}." do
                    ret_val = exec! "sh #{destination_path}#{local_file} > /dev/null"
                    exit_code = ret_val.data
                    unless 0 == exit_code
                        raise "RemoteSalad: Execution of "                    \
                              "#{destination_path}#{local_file} failed."
                    end
                end
            else # Use saladmix
                upload( local_file, destination_path )
                local_file = File.basename( local_file )
                timed_cmd "Loading usecase CSV: #{local_file}." do
                    ret_val = exec! "#{@saladmix_binary} "                  \
                                      "-D #{AudioCardIndex} "                 \
                                      "#{destination_path}#{local_file}"
                    exit_code = ret_val.data
                    unless 0 == exit_code
                        raise 'RemoteSalad: Saladmix execution failed. Ensure'\
                              ' your configuration contains appropriate '     \
                              'settings and the usecase you are using is '    \
                              'correct.'
                    end
                end
            end
        end

        #######################################################################
        #
        # @function initialize_logging
        #
        # Initializes logging constructors for logging module.
        #
        #######################################################################
        def initialize_logging()
            $time_stamp = Time.now.strftime( "%Y-%m-%d-%H-%M-%S-%L" )
            @LogDir = Conf::property(:LogDir, nil )

            if @LogDir
                @logging_path = File.join( ENV['FRUITSALAD_HOME'],
                                            "/../test/#{@LogDir}/logs"
                                         )
            else
                @logging_path = File.join( ENV['FRUITSALAD_HOME'],
                                            "/logs"
                                         )
            end

            unless Dir::exist?( @logging_path )
                Dir::mkdir( @logging_path )
            end

            if @LogDir
                @logging_path = File.join( ENV['FRUITSALAD_HOME'],
                                         "/../test/#{@LogDir}/logs/#{$script_log_file_name}_#{$time_stamp}"
                                         )
            else
                @logging_path = File.join( ENV['FRUITSALAD_HOME'],
                                       "/logs/#{$script_log_file_name}_#{$time_stamp}"
                                     )
            end

            unless Dir::exist?( @logging_path )
                Dir::mkdir( @logging_path )
            end
        end

        ########################################################################
        #
        # @function dsp_firmware_info_log
        #
        # It redirects  the dsp information into  a log with current time stamp
        # and downloads the log into the fruitsalad logs directory.
        #
        # @return status [Boolean] Returns the failure status of the all the remote calls.
        #
        ########################################################################
        def dsp_firmware_info_log()
            debugfs_path = "#{ASoCDebugfsRoot}/#{CardName}/#{CodecName}"
            status = 0
            exec! "echo DSP_Firmware_Info:: > #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
            1.upto( NumberOfDSPCores ) do |number|
                exec! "echo DSP number::#{number} >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                exec! "echo wmfw file name:: >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                ret_val = exec! "cat #{debugfs_path}/dsp#{number}/wmfw_file_name >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                status |= ret_val.data
                exec! "echo binfile name:: >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                ret_val = exec! "cat #{debugfs_path}/dsp#{number}/bin_file_name >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                status |= ret_val.data
                exec! "echo  fw_id :: >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                ret_val = exec! "cat #{debugfs_path}/dsp#{number}/fw_id >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                status |= ret_val.data
                exec! "echo  fw_version :: >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                ret_val = exec! "cat #{debugfs_path}/dsp#{number}/fw_version >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log "
                status |= ret_val.data
                exec! "echo running:: >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                ret_val = exec! "cat #{debugfs_path}/dsp#{number}/running >> #{TempDir}dsp_firmware_info_#{$time_stamp}.log"
                status |= ret_val.data
            end
            unless 0 == status
                 $LOG.info 'RemoteSalad: Failed to log firmware informations. '
            end
            download( "dsp_firmware_info_#{$time_stamp}.log", TempDir, @logging_path )
            exec! "rm -f #{TempDir}dsp_firmware_info_#{$time_stamp}.log "
            return status
        end

        ########################################################################
        #
        # @function dmesg_log
        #
        # It gives the dmesg log and downloads the respective log with current
        # time stamp into the fruitsalad temp directory.
        #
        # @return status [Boolean] Returns the failure status of the remote call.
        #
        #######################################################################
        def dmesg_log()
            ret_val = exec! "dmesg > #{TempDir}dmesg_#{$time_stamp}.log "
            status = ret_val.data
            unless 0 == status
                $LOG.info 'RemoteSalad: Failed to log dmesg logs. '
            end
            download( "dmesg_#{$time_stamp}.log", TempDir, @logging_path )
            exec! "rm -f #{TempDir}dmesg_#{$time_stamp}.log "
            clear_dmesg_log()
            return status
        end

        #######################################################################
        #
        # @function registerdump_16bit
        #
        # It redirects the respective 16 bit register information into  log
        # with the current time stamp and downloads the log into the fruit
        # salad temp directory.
        #
        # @return status [Boolean] Returns the failure status of the remote call.
        #
        #######################################################################
        def registerdump_16bit()
            ret_val = exec! "cat /sys/kernel/debug/regmap/#{Regmap16bit}/registers > #{TempDir}registerdump_16bit_#{$time_stamp}.log"
            status = ret_val.data
            unless 0 == status
                 $LOG.info 'RemoteSalad: Failed to log 16bit register. '
             end
            download( "registerdump_16bit_#{$time_stamp}.log", TempDir, @logging_path )
            exec! "rm -f #{TempDir}registerdump_16bit_#{$time_stamp}.log "
            return status
        end

        #######################################################################
        #
        # @function registerdump_32bit
        #
        # It redirects the respective dsp 32 bit register information into  log
        # with the current time stamp and downloads the log into the fruitsalad
        # temp directory.
        #
        # @return status [Boolean] Returns the failure status of the remote call.
        #
        #######################################################################
        def registerdump_32bit()
            ret_val = exec! "cat  /sys/kernel/debug/regmap/#{Regmap32bit}/registers > #{TempDir}registerdump_32bit_#{$time_stamp}.log"
            status = ret_val.data
            unless 0 == status
                 $LOG.info 'RemoteSalad: Failed to log 32bit register. '
             end
            download( "registerdump_32bit_#{$time_stamp}.log", TempDir, @logging_path )
            exec! "rm -f #{TempDir}registerdump_32bit_#{$time_stamp}.log "
            return status
        end

        #######################################################################
        #
        # @function tinymix_log
        #
        # It gives the tinymix log with the current time stamp and downloads
        # the log into the fruitsalad logs directory.
        #
        # @return status [Boolean] Returns the failure status of the remote call.
        #
        #######################################################################
        def tinymix_log()
            ret_val = exec! "tinymix > #{TempDir}tinymix_log_#{$time_stamp}.log"
            status = ret_val.data
            unless 0 != status
                 $LOG.info 'RemoteSalad: Failed to log tinymix logs. '
             end
            download( "tinymix_log_#{$time_stamp}.log", TempDir, @logging_path )
            exec! "rm -f #{TempDir}tinymix_log_#{$time_stamp}.log "
            return status
        end

        #######################################################################
        #
        # @function clear_dmesg_log
        #
        # It clears the dmesg log information
        #
        # @return status [Boolean] Returns the failure status of the remote call.
        #
        ########################################################################
        def clear_dmesg_log()
            exec! "dmesg -c"
        end

        #################################################################################
        #
        # @function execute_the_command
        # Executes the given commmand on the remote device
        #
        # @param [cmd]     Command to execute on remote device.
        #
        # @return [nil]
        #################################################################################
        def execute_the_command( cmd )
            exec! "#{cmd}" do |_, stdout, stderr|
                value = stdout
                check_for_tinymix_errors stderr
            end
        end
        ########################################################################
        #
        # @function widget_status_log
        #
        # It reads the widget status and downloads the log into the fruitsalad
        # logs directory.
        #
        # @return status [Boolean] Returns the failure status of the remote call.
        #
        ########################################################################
        def widget_status_log()
            dapm_array = Conf.property( :DAPMArray, ['dapm'] )
            status = 0
            dapm_array.each do |dapm|
                exec! "ls #{ASoCDebugfsRoot}/#{CardName}/#{dapm}/ > #{TempDir}widgets.txt"
                download( "widgets.txt", TempDir, @logging_path )
                @widget_file = File.join( "#{@logging_path}",
                                         'widgets.txt'
                                       )
                exec! "echo Widget_Status of #{dapm} :: >> #{TempDir}widget_status_#{$time_stamp}.log"
                File.open(@widget_file).each do |line|
                    #
                    # Adding backslash to the file name if there is any space in
                    # the file name. And remove newline character( if any ) in the
                    # filename.
                    #
                    line = line.gsub(/ /, '\ ')
                    line = line.gsub("\n",'')
                    exec! "echo #{line} >> #{TempDir}widget_status_#{$time_stamp}.log"
                    ret_val = exec! "cat #{ASoCDebugfsRoot}/#{CardName}/#{dapm}/#{line} >> #{TempDir}widget_status_#{$time_stamp}.log"
                    status |= ret_val.data
                end
            end
            download( "widget_status_#{$time_stamp}.log", TempDir, @logging_path )
            exec! "rm -f #{TempDir}widget_status_#{$time_stamp}.log "
            return status
        end

        #######################################################################
        #
        # @function record_output
        #
        # Begins recording and stores a filename as the instance
        # variable @output.
        #
        # @param [String] filename Name of the recording file and defaults to
        #                          'FruitSaladOutputRecording.wav' if nothing
        #                          specified.
        #
        #######################################################################
        def record_output( filename = 'FruitSaladOutputRecording.wav' )
            record = Proc.new do |proc_file|
                starting = true
                @session.open_channel do |channel|
                    channel.exec "tinycap #{TempDir}#{proc_file} -D "         \
                                 "#{AudioCardIndex} -r #{SampleRate} "        \
                                 "-b #{Bitdepth}" do |ch, success|
                        if success
                            @recording_active = true
                            $LOG.info 'RemoteSalad: Beginning recording.'
                            starting = false
                        else
                            raise 'RemoteSalad: Failed to start recording.'
                        end

                        ch.on_request( 'exit-status' ) do |c, data|
                            $LOG.debug "RemoteSalad: Recording exit status "        \
                                 "#{data.read_long}."
                        end

                        ch.on_close do
                            @recording_active = false
                            $LOG.info 'RemoteSalad: Recording finished.'
                        end
                    end
                end

                begin
                    @session.loop do
                        starting
                    end
                rescue Errno::ECONNRESET => e
                    if ReturnErrorCodes
                        return NetworkError.new(:HOST_CONNECTION_CLOSED,
                                                   e.message,
                                                   e.backtrace)
                    else
                        raise e
                    end
                end
            end

            setup_remote_record_output( TempDir, record, filename )
        end

        #########################################################################
        #
        # @function record_output_at_host
        #
        # Capture output through line-in.
        #
        # The file-name used to save the captured output is stored in the
        # attribute @output.
        #
        # @param [Integer] sample_rate     Recording sample rate
        #
        # @param [Integer] channels        Number of recording channels
        #
        # @param [String]  type            Type of recording either analog or
        #                                  digital.
        #
        # @param [String] record_file_name The name of the recording file and
        #                                  by default set to
        #                                  'tmpfile_analogRecording.wav'
        #
        # @param [Integer] record_time     Optional parameter to specify record
        #                                  time.
        #
        # @param [Array] track_list        Optional parameter to give track list
        #                                  for recording of digital data.
        #
        #########################################################################
        def record_output_at_host( sample_rate,
                                   channels,
                                   type,
                                   record_file_name = 'tmpfile_analogRecording.wav',
                                   record_time = nil,
                                   track_list = nil
                                 )

            if( type == 'analog' )
                @output = record_file_name
                ret_val = PortaudioClient::start()
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
                ret_val = PortaudioClient::start_recording( channels,
                                                            sample_rate,
                                                            @output
                                                          )
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
                @analog_recording_active = true
            elsif( type == 'digital' )

                # Clone the track_list
                track_list = Marshal.load( Marshal.dump( track_list ) )
                track_list.map! do |track, channel, record|
                    @digital_output = track
                    @digital_recording_active = true
                    [track, channel, record]
                end

                background = true
                record = true
                samples = sample_rate * record_time
                PaMultitrack.new().play_tracklist( track_list, record, samples, background )
            else
                raise 'Specified recording type is not supported'
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #######################################################################
        #
        # @function playback_from_host
        #
        # Plays a named file on the Host device.
        #
        # This script will SCP the named file onto the Android device,
        # and then play it.
        #
        # @param [String] file is the path to the file to play.
        # @param [Hash]   opts Optional playback arguments. This platform
        #                      supports: [Boolean] blocking - indicates whether
        #                      playback should block until completion or exit
        #                      immediately (defaults to true).
        #
        # @raise [RuntimeError] An error is raised if unexpected keyword
        #                       arguments are provided.
        #
        #######################################################################
        def playback_from_host( file, opts = {} )

            supported_opts = [:blocking, :type, :track_list]
            validate_options( opts.keys, supported_opts, 'RemoteSalad: (playback)' )

            blocking = opts.fetch( :blocking, true )
            type = opts.fetch( :type, 'analog' )
            track_list = opts.fetch( :track_list, nil )

            if File.exists?( file )
                info = Reader.info( file )
                sample_rate = info.sample_rate
                channels = info.channels
                file = simulated_noise_model.mix_in_noise( file )
            else
                if ReturnErrorCodes
                    error_message = "The specified file: #{file} not found.."
                    return FileSystemError.new(:FILE_NOT_FOUND,
                                                  error_message,
                                                  Thread.current.backtrace)
                else
                    raise "The specified file: #{file} not found.."
                end
            end

            if( type == 'analog' )
                PortaudioClient::start()
                start_time = Time.new.to_f
                ret_val = PortaudioClient::start_playback( channels,
                                                  sample_rate,
                                                  file
                                                )
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
                @analog_playback_active = true
                if( true == blocking )
                    PortaudioClient::wait_for_notification()
                    ret_value = end_playback_at_host( type )
                    if ReturnErrorCodes
                        if ret_value.status_code != 0 && ReturnErrorCodes
                            return ret_value
                        end
                    end
                    end_time   = Time.new.to_f
                    @playtime  = end_time - start_time
                end
            elsif( type == 'digital' )
                # Clone the track_list
                track_list_play = Marshal.load( Marshal.dump( track_list ) )
                track_list_play.map! do |track, channel|
                    @digital_input = track
                    [track, channel]
                end

                @digital_playback_active = true
                record = false
                PaMultitrack.new().play_tracklist( track_list_play, record )
            else
                if ReturnErrorCodes
                    error_message = "Specified end playback type - #{type} is not supported"
                    return InternalError.new(:UNSUPPORTED_ARGUMENTS,
                                               error_message,
                                               Thread.current.backtrace)
                else
                    raise error_message
                end
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #######################################################################
        #
        # @function playback
        #
        # Plays a named file on the Android device.
        #
        # This script will SCP the named file onto the Android device,
        # and then play it.
        #
        # @param [String] file is the path to the file to play.
        # @param [Hash]   opts Optional playback arguments. This platform
        #                      supports: [Boolean] blocking - indicates whether
        #                      playback should block until completion or exit
        #                      immediately (defaults to true).
        #                      [Boolean] upload - indicates whether
        #                      file needs to be uploaded or not.
        #
        # @raise [RuntimeError] An error is raised if unexpected keyword
        #                       arguments are provided.
        #
        #######################################################################
        def playback( file, opts = {} )

            supported_opts = [:blocking, :destination_path, :upload ]
            validate_options( opts.keys,
                              supported_opts,
                              'RemoteSalad: (playback)'
                            )

            blocking = opts.fetch( :blocking, true )
            destination_path = opts.fetch( :destination_path, TempDir )
            upload = opts.fetch( :upload, true )

            if File.exists?( file )
                info = Reader.info( file )
                sample_rate = info.sample_rate
                channels = info.channels
                @playback_history << file
                file = simulated_noise_model.mix_in_noise( file )
            else
                error_message = "The specified file: #{file} not found.."
                if ReturnErrorCodes
                    return FileSystemError.new(:FILE_NOT_FOUND,
                                                  error_message,
                                                  Thread.current.backtrace)
                else
                    raise error_message
                end
            end

            # Load our default usecases if no usecases have been loaded.
            usecase( :default ) if false == @usecase_loaded

            play = Proc.new do |proc_file|
                ret_val = play( proc_file, destination_path )
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
                ret_val = end_playback( true ) if blocking
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
                return ResultSuccess.new() if ReturnErrorCodes
            end

            start_remote_playback( file,
                                   destination_path,
                                   play,
                                   :upload => upload
                                 )
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #######################################################################
        #
        # @function end_capture
        #
        # Ends any ongoing sound recording.
        #
        # Automatically downloads the captured recording onto the host
        # machine.
        #
        # @note Accomplishes this by killing /all/ tinycap processes, may
        #       be dangerous depending on set-up.
        #
        # (no parameters)
        #
        # @raise [RuntimeError] An exception is raised if killall tinycap
        #                       fails.
        #
        #######################################################################
        def end_capture()
            if @recording_active
                end_cap = Proc.new do
                    ret_val = exec! 'killall -2 tinycap'
                    if ret_val.status_code != 0 && ReturnErrorCodes
                        return ret_val
                    else
                        unless 0 == ret_val.data
                            raise 'RemoteSalad: Failed to terminate audio capture.'
                        end
                    end
                    @session.loop do
                        @recording_active
                    end
                end

                end_remote_capture( TempDir, end_cap )
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #########################################################################
        #
        # @function end_capture_at_host
        #
        # Terminates any active recording.
        #
        # @param [String] type Type of the recording whether it is digital or
        #                 analog. Default is analog.
        # @param [String] opts Optional playback arguments. This platform
        #                      supports:
        #                      [String] record_file_name The recorded file name.
        #                      [Integer] channels No of channels of the recording.
        #
        # @raise [Runtime error] At present recording can be done for only
        #                        maximum of 2 channels. More than 2 channels will raise
        #                        a run time exception.
        #
        #########################################################################
        def end_capture_at_host( type, opts={} )

            supported_opts = [:record_file_name, :channels]
            validate_options( opts.keys, supported_opts, 'RemoteSalad: (playback)' )
            if( type == 'analog' )
                if @analog_recording_active
                    PortaudioClient::StopRecording()
                    PortaudioClient::terminate()
                    @analog_recording_active = false
                end
            elsif( type == 'digital' )
                record_file_name = opts.fetch( :record_file_name, nil )
                channels = opts.fetch( :channels, nil )

                temp_file1 = File.join( ENV['FRUITSALAD_HOME'],
                                        'tmp/temp_file1.wav'
                                      )
                temp_file2 = File.join( ENV['FRUITSALAD_HOME'],
                                        'tmp/temp_file2.wav'
                                      )
                if @digital_recording_active
                    task_list_exit_code = system( "tasklist /FI \"IMAGENAME eq pa_multitrack.exe\" | find /I \"pa_multitrack.exe\" > nul" )
                    if( task_list_exit_code == true )
                        task_kill_exit_code = system( "taskkill /F /IM pa_multitrack.exe > nul 2>&1" )
                    end
                    if 2 == channels
                        FruitSalad::club_two_mono_to_stereo( temp_file1,
                                                             temp_file2,
                                                             record_file_name
                                                           )
                    elsif 1 == channels
                        if( task_kill_exit_code == true )
                            info = WaveFile::Reader.info( record_file_name )
                            FruitSalad::add_wave_header_to_pcm_file(
                                                 record_file_name,
                                                 info.channels,
                                                 info.bits_per_sample,
                                                 info.sample_rate
                                                                   )
                        end
                    else
                        error_message = 'Recording for more than 2 channels not supported'
                        if ReturnErrorCodes
                            return APIError.new( :UNSUPPORTED_DIGITAL_RECORD,
                                                   error_message,
                                                   Thread.current.backtrace)
                        else
                            raise error_message
                        end
                    end
                    @digital_recording_active = false
                end
            else
                error_message = 'Specified end recording type is not supported'
                if ReturnErrorCodes
                    return APIError.new( :UNSUPPORTED_RECORDING_TYPE,
                                           error_message,
                                           Thread.current.backtrace)
                else
                    raise error_message
                end
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #######################################################################
        #
        # @function play
        #
        # This function provides a bare minimum implementation of playback
        # functionality, it assumes the provided file is already present
        # on the device and that the device has been properly set up.
        #
        # @note Consider using playback or non_blocking_playback instead of
        #       this method.
        #
        # @param [String] file Name of the file to play.
        #
        # @return void
        #
        #######################################################################
        def play( file, destination_path )
            starting = true
            @session.open_channel do |channel|
                channel.exec "tinyplay #{destination_path}#{file} -D #{AudioCardIndex}"\
                        do |ch, success|
                    if success
                        @playback_active = true
                        $LOG.info 'RemoteSalad: Beginning playback.'
                        starting = false
                    else
                        raise 'RemoteSalad: Failed to start playback.'
                    end

                    ch.on_request( 'exit-status' ) do |c, data|
                        $LOG.debug "RemoteSalad: Playback exit status "             \
                             "#{data.read_long}."
                    end

                    ch.on_close do
                        @playback_active = false
                        $LOG.info 'RemoteSalad: Playback finished.'
                    end
                end
            end

            begin
                @session.loop do
                    starting
                    #raise Exception('Hello')
                end
            rescue Errno::ECONNRESET => e
            # rescue Exception => e
                error_message = 'An existing connection was forcibly closed by the remote host'
                if ReturnErrorCodes
                    return NetworkError.new(:HOST_CONNECTION_CLOSED,
                                               error_message,
                                               e.backtrace)
                else
                    raise error_message
                end
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #######################################################################
        #
        # @function end_playback
        #
        # Ends playback immediately or waits until it finishes
        # successfully.
        #
        # @param [Boolean] wait Flag indicating whether the playback should
        #                       be ended immediately, or if execution
        #                       should be blocked until the started
        #                       playback finishes successfully.
        #
        # @return void
        #
        #######################################################################
        def end_playback( wait = false )
            if @playback_active
                if wait
                    $LOG.info 'RemoteSalad: Waiting for playback to finish.'
                else
                    ret_val = exec! 'killall -2 tinyplay'
                    if ret_val.status_code != 0 && ReturnErrorCodes
                        return ret_val
                    end
                end

                begin
                    @session.loop do
                        @playback_active
                    end
                rescue Errno::ECONNRESET => e
                    error_message = 'An existing connection was forcibly closed by the remote host'
                    if ReturnErrorCodes
                        return NetworkError.new(:HOST_CONNECTION_CLOSED,
                                                   error_message,
                                                   e.backtrace)
                    else
                        raise error_message
                    end
                end
            end
            @end_time = Time.new.to_f
            if ReturnErrorCodes
                return ResultSuccess.new(@end_time)
            else
                return @end_time
            end
        end

        #########################################################################
        #
        # @function end_playback_at_host
        #
        # Ends playback if playback is inactive, otherwise not.
        #
        # @param [String] type Terminates given type of playback.
        #
        #########################################################################
        def end_playback_at_host( type = 'analog' )
            if( type == 'analog' )
                if @analog_playback_active
                    PortaudioClient::StopPlayback()
                    @analog_playback_active = false
                end
            elsif( type == 'digital' )
                if @digital_playback_active
                    @digital_playback_active = false
                    exit_code = system( "tasklist /FI \"IMAGENAME eq pa_multitrack.exe\" | find /I \"pa_multitrack.exe\" > nul" )
                    if( exit_code == true )
                        exit_code = system( "taskkill /F /IM pa_multitrack.exe > nul 2>&1" )
                    end
                end
            else
                if ReturnErrorCodes
                    error_message = "Specified end playback type - #{type} is not supported"
                    return APIError.new(:UNSUPPORTED_PLAYBACK_TYPE,
                                           error_message,
                                           Thread.current.backtrace)
                else
                    raise error_message
                end
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end

        #######################################################################
        #
        # @function playback_completed?
        #
        # Gives current status of playback whether it is completed or not.
        #
        # @return [Boolean] True if playback has completed.
        #
        #######################################################################
        def playback_completed?
            return PortaudioClient::playback_completed?
        end

        #######################################################################
        #
        # @function record_from_compressed_stream
        #
        # Starts recording from a compressed stream on the remote device.
        #
        # (no parameters)
        #
        # @return void
        #
        #######################################################################
        def record_from_compressed_stream( filename,
                                           sample_rate,
                                           channels,
                                           destination_path = nil
                                        )
            if destination_path.nil?
                destination_path = TempDir
            end
            @remote_output_raw = "#{destination_path}#{filename}"
            ret_val = exec! "rm -f #{@remote_output_raw}"
            if ret_val.status_code != 0 && ReturnErrorCodes
                return ret_val
            end
            starting = true

            @session.open_channel do |channel|
                channel.exec "crec -v -c#{AudioCardIndex} -d#{DeviceNode} "               \
                             "-R#{sample_rate} -C#{channels} "           \
                             "#{@remote_output_raw}" do |ch, success|
                    if success
                        @compressed_recording_active = true
                        starting = false
                    else
                        raise 'RemoteSalad: Failed to start compressed record.'
                    end

                    ch.on_request( 'exit-status' ) do |c, data|
                        $LOG.debug "RemoteSalad: Compressed recording exit status " \
                             "#{data.read_long}."
                    end

                    ch.on_close do
                        @compressed_recording_active = false
                        $LOG.info 'RemoteSalad: Compressed recording finished.'
                    end
                end
            end

            begin
                @session.loop do
                    starting
                end
            rescue Errno::ECONNRESET => e
                error_message = 'An existing connection was forcibly closed by the remote host'
                if ReturnErrorCodes
                    return NetworkError.new(:HOST_CONNECTION_CLOSED,
                                                error_message,
                                                e.backtrace)
                else
                    raise error_message
                end
            end
            return ResultSuccess.new()
        end

        #######################################################################
        #
        # @function start_recording_and_poll_compressed_node
        #
        # Starts recording from a compressed stream on the remote device and
        #  poll for trigger.
        #
        # @param [String]  record_file_name Name of the file to capture DSP output
        # @param [Integer] sample_rate      Recording sample rate
        # @param [Integer] channels         Number of recording channels
        # @param [String]  destination_path Path of the record file to store it
        # @param [int]  length Number of seconds to record
        # @return void
        #
        #######################################################################
        def start_recording_and_poll_compressed_node( record_file_name,
                                                      sample_rate,
                                                      channels,
                                                      destination_path,
                                                      length
                                                    )
            @remote_output_raw = "#{destination_path}#{record_file_name}"
            buffer_size = Conf.property( :AoV_Buffer_size, 49152 )
            frame = Conf.property( :AoV_Frame, 64 )
            format = Conf.property( :AoV_Format, 'S16_LE' )
            @logfile = Conf.property( :Logfile, "log.txt" )
            logfile = "#{destination_path}#{@logfile}"
            ret_val = exec! "rm -f #{@remote_output_raw}"
            if ret_val.status_code != 0 && ReturnErrorCodes
                return ret_val
            end
            if File.exists?( logfile )
                File.delete( logfile )
            end
            starting = true
            @session.open_channel do |channel|
                if length == nil
                    channel.exec "crec -v -c#{AudioCardIndex} -d#{DeviceNode} -R#{sample_rate} -b #{buffer_size} -f #{frame} -C #{channels} " \
                        "-F #{format} #{@remote_output_raw} | pv -b -f 2>#{logfile}" do |ch, success|
                        if success
                            @compressed_recording_active = true
                            starting = false
                        else
                            raise 'RemoteSalad: Failed to start compressed record.'
                        end

                        ch.on_request( 'exit-status' ) do |c, data|
                            $LOG.debug "RemoteSalad: Compressed recording exit status " \
                                "#{data.read_long}."
                        end

                        ch.on_close do
                            @compressed_recording_active = false
                            $LOG.info 'RemoteSalad: Compressed recording finished.'
                        end
                    end
                else
                    channel.exec "crec -v -c#{AudioCardIndex} -d#{DeviceNode} " \
                        "-R#{sample_rate} -l#{length} -b #{buffer_size} -f #{frame} -C #{channels} " \
                        "-F #{format} #{@remote_output_raw} | pv -b -f 2>#{logfile}" do |ch, success|
                        if success
                            @compressed_recording_active = true
                            starting = false
                        else
                            raise 'RemoteSalad: Failed to start compressed record.'
                        end

                        ch.on_request( 'exit-status' ) do |c, data|
                            $LOG.debug "RemoteSalad: Compressed recording exit status " \
                                "#{data.read_long}."
                        end

                        ch.on_close do
                            @compressed_recording_active = false
                            $LOG.info 'RemoteSalad: Compressed recording finished.'
                        end
                    end
                end
            end

            begin
                @session.loop do
                    starting
                end
            rescue Errno::ECONNRESET => e
                error_message = 'An existing connection was forcibly closed by the remote host'
                if ReturnErrorCodes
                    return NetworkError.new(:HOST_CONNECTION_CLOSED,
                                            error_message,
                                            e.backtrace
                                            )
                else
                    raise error_message
                end
            end
            return ResultSuccess.new()
        end

        #######################################################################
        #
        # @function stop_recording_dsp_output
        #
        # Ends an ongoing compressed capture on the remote device, decodes
        # the output and downloads the resulting recording.
        #
        # (no parameters)
        #
        # @return void
        #
        # @raise [RuntimeError] An exception is raised if decoding the
        #                       recording fails.
        #
        #######################################################################
        def stop_recording_dsp_output( record_file_name, destination_path = nil, download_path = nil )
            if @compressed_recording_active
                ret_val = exec! 'killall -2 crec'
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
                @session.loop do
                    @compressed_recording_active
                end
            end

            @remote_output_wav = record_file_name
            ret_val = exec! "rm -f #{destination_path}#{@remote_output_wav}"
            if ret_val.status_code != 0 && ReturnErrorCodes
                return ret_val
            end
            $LOG.info 'RemoteSalad: Decoding recording from compressed '
            ret_val = exec! "autrace_decode #{@remote_output_raw} #{destination_path}#{@remote_output_wav} 2>#{destination_path}autrace_decode_error.txt"

            if ret_val.status_code != 0 && ReturnErrorCodes
                return ret_val
            else
                unless 0 == ret_val.data || INVALID_INPUT_FILE == ret_val.data # Work arround for autrace_decode error
                                                                               # which returns invalid input file
                                                                               # even though the input file is valid
                                                                               # and it is able to decode.
                    raise 'RemoteSalad: Failed to decode compressed recording.'
                end
            end

            @output = download( @remote_output_wav, destination_path, download_path )
            if @output
                return ResultSuccess.new()
            end
        end

        #######################################################################
        #
        # @function check_for_trigger
        #
        # Check aov trigerred or not by reading the data contains in a file
        #
        # @param [nil]
        # @return [Int] Number bytes data transmited
        #
        #######################################################################
        def check_for_trigger()

            # Time to complete recording
            time = Conf.property( :Time_To_Sleep, 5 )
            sleep time
            data = []
            @logging_path = File.join( ENV['FRUITSALAD_HOME'], '/tmp' )
            if File.exists?( "#{@logging_path}/#{@logfile}" )
                File.delete( "#{@logging_path}/#{@logfile}" )
            end
            download( @logfile, TempDir, @logging_path )
            file_name = File.join( ENV['FRUITSALAD_HOME'], '/tmp/log.txt' )
            f = open( file_name, 'r').each do |line|
                data.push(line)
            end
            crec_data = data[-1]
            crec_data = crec_data.scan( /\d/ )
            crec_data = crec_data[-1]
            # Closing file and deleting
            f.close()
            if File.exists?( "#{@logging_path}/#{@logfile}" )
                File.delete( "#{@logging_path}/#{@logfile}" )
            end
            return crec_data.to_i
        end

        #######################################################################
        #
        # @function end_compressed_stream_capture
        #
        # Ends an ongoing compressed capture on the remote device, decodes
        # the output and downloads the resulting recording.
        #
        # (no parameters)
        #
        # @return void
        #
        # @raise [RuntimeError] An exception is raised if decoding the
        #                       recording fails.
        #
        #######################################################################
        def end_compressed_stream_capture( record_file_name, destination_path = nil, download_path = nil )
            if @compressed_recording_active
                ret_val = exec! 'killall -2 crec'
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end
                @session.loop do
                    @compressed_recording_active
                end
                @remote_output = record_file_name
                ret_val = exec! "rm -f #{destination_path}#{@remote_output}"
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                end

                $LOG.info 'RemoteSalad: Decoding recording from compressed stream.'
                ret_val = exec! "autrace_decode "                           \
                                  "#{@remote_output_raw} " \
                                  "#{destination_path}#{@remote_output}"
                if ret_val.status_code != 0 && ReturnErrorCodes
                    return ret_val
                else
                    unless 0 == ret_val.data
                        raise 'RemoteSalad: Failed to decode compressed recording.'
                    end
                end
                @output = download( @remote_output, destination_path, download_path )
                if @output
                    return ResultSuccess.new()
                end
            end
        end

        #######################################################################
        #
        # @function mixer_property
        #
        # Retrieve the status of a TinyAlsa mixer control using tinymix on the
        # target device.
        #
        # @param [String] key    The name of the mixer control.
        # @param [Fixnum] offset Optional argument valid for byte controls.
        #                        Indicates that the function should return
        #                        only a value with a given offset (# bytes)
        #                        into the control.
        #
        # @return [nil|String] The value of that control.
        #
        #######################################################################
        def mixer_property( key, offset = nil )
            value = ''
            exec! "tinymix -D #{AudioCardIndex} \"#{key}\""                   \
                    do |_, stdout, stderr|
                value = stdout
                check_for_tinymix_errors stderr
            end
            value = TinyAlsaInspect::parse_property( value )

            if !offset.nil?
                value.gsub! "#{key}:", ''
                value.strip!
                values = value.scan( /[\da-fA-F]{8}/ )
                value = values[offset % 4]
            end

            if ( value.match(/(\w+:)\d+/) )
                temp = $1
                value.scan(/\d\d/) do |tmp|
                    temp = temp + "0x" + tmp + " "
                end
                value = temp.strip!()
            end
            return value
        end

        #######################################################################
        #
        # @function set_mixer_property
        #
        # Sets a value to a TinyAlsa mixer control on the remote device.
        #
        # @note You can only set one value at an offset.
        #
        # @param [String] key     Name of the control to set.
        # @param [String] value   Value(s) of to set to the control.
        # @param [Integer] offset In case of multi-valued controls an offset can
        #                         be provided to indicate which value should be
        #                         set (instead of overwriting the entire
        #                         control).
        # @param [Option] opts    execution_time - This option is used for setting key
        #                         value as integer bypassing the logic for parsing value
        #                         for hex/number/switch. This option is used currently
        #                         for tests measuring execution time taken for executing
        #                         mixer controls.
        #
        # @return void
        #
        # @raise [RuntimeError] An exception is raised if value is an empty
        #                       string.
        # @raise [RuntimeError] An exception is raise if offset is set and
        #                       multiple values are provided.
        #
        #######################################################################
        def set_mixer_property( key, value, offset=nil, opts={} )

            command = "tinymix -D #{AudioCardIndex} \"#{key}\""

            execution_time = opts.fetch( :execution_time, nil )

            if execution_time.nil?
                error_message = 'RemoteSalad: You need to provide a value to set'
                if value == nil
                    raise $LOG.error "#{error_message} for control \"#{key}\""
                end

                hex = /0x[\dABCDEFabcdef]{2}/
                number = /\d+/
                switch = /[Oo]n|[Oo]ff/

                values = value.split( ' ' )

                if 1 < values.length && !offset.nil?
                    error_message = 'RemoteSalad: Only a single value can be set ' \
                                      'with an offset'
                    raise $LOG.error "#{error_message} for control \"#{key}\""
                end

                if value.scan( hex ).length == values.length
                    values.map! { |v| v.hex }
                    value = values.join( ' ' )
                elsif value.scan( number ).length == values.length
                    value = values.join( ' ' )
                elsif value.scan( switch ).length == values.length
                    values.map! do |v|
                        if 0 == v.casecmp( 'on' )
                            v = 1
                        else
                            v = 0
                        end
                        v
                    end
                    value = values.join( ' ' )
                else
                    value = "\"#{values.join( ' ' )}\""
                end

                if !offset.nil?
                    current_value = ''
                    exec! command do |_, stdout, stderr|
                        current_value = stdout
                        check_for_tinymix_errors stderr
                    end
                    current_value = /#{key}:(.*)/.match( current_value )
                    current_value = current_value[1]
                    temp = ""
                    current_value.scan(/\d\d/) do |tmp|
                        temp = temp + "0x" + tmp + " "
                    end
                    current_value = temp.strip!()
                    current_value = current_value.gsub( /\(.*\)/, '' ).strip
                    current_value = current_value.split(' ')
                    current_value[ offset ] = value
                    value = ''
                    current_value.each do |v|
                        if !(v =~ hex).nil?
                            v = v.hex
                        elsif 0 == v.casecmp( 'on' )
                            v = 1
                        elsif 0 == v.casecmp( 'off' )
                            v = 0
                        end
                        value += "#{v} "
                    end
                    value.strip!
                end

                exec! "#{command} #{value}" do |_, _, stderr|
                    check_for_tinymix_errors stderr
                end
            else
                exec! "#{command} #{value}" do |_, _, stderr|
                    check_for_tinymix_errors stderr
                end
            end

        end

        #######################################################################
        #
        # @function set_nanomix_property
        # sets a value to a nanomixer control on the remote device
        #
        # @param [String] key     Name of the control to set.
        # @param [String] value   Value(s) of to set to the control.
        #
        # @return [true or false]
        #######################################################################
        def set_nanomix_property( key, value )
            command = "nanomix \"#{key}\""
            exec! "#{command} #{value}" do |_, _, stderr|
                check_for_tinymix_errors stderr
            end
        end

        #######################################################################
        #
        # @function mixer_controls_dump
        #
        # Reads all the ALSA controls in the target device and save to a file.
        #
        # @return [nil]
        #
        #######################################################################
        def mixer_controls_dump()
            value = ''
            exec! "alsa-ctl-dump -e" do |_, stdout, stderr|
                value = stdout
                check_for_tinymix_errors stderr
            end
            file_name = File.join( ENV['FRUITSALAD_HOME'],'tmp/alsa_controls.txt')
            open( file_name, 'w') { |f|
                f.puts value
            }
        end

        #######################################################################
        #
        # @function load_all_modules
        #
        # Loads all modules that are given in the input.
        #
        # @Param [Array]      Names of the modules to load.
        #
        # @return void
        #
        #######################################################################
        def load_all_modules( modules )
            module_name = ''
            modules.each do|module_name|
                $LOG.info "Loading module name == #{module_name}"
                exec! "modprobe -v #{module_name}" \
                    do |_, stdout, stderr|
                    check_for_tinymix_errors stderr
                end
            end
        end

        #######################################################################
        #
        # @function state
        #
        # Reads the state of VEGA.
        #
        # @return [String] Reads the STATE which is ACTIVE or INACTIVE.
        #
        #######################################################################
        def state()
            debugfs_path = Conf.property( :debugfs_path, nil )
            state = ''
            exec! "cat #{debugfs_path}/state" \
                do |_, stdout, stderr|
                state =  stdout
                check_for_tinymix_errors stderr
            end
            return state
        end

        #######################################################################
        #
        # @function set_boot
        #
        # Sets the bootdone to 1 to trigger bootdone functionality of VEGA.
        #
        # @return [nil]
        #
        #######################################################################
        def set_boot()
            debugfs_path = Conf.property( :debugfs_path, nil )
            exec! "echo 1 > /#{debugfs_path}/bootdone" \
                do |_, stdout, stderr|
                check_for_tinymix_errors stderr
            end
        end

        #######################################################################
        #
        # @function unload_all_modules
        #
        # Unloads all modules that are given in the input.
        #
        # @Param [Array]      Names of the modules to unload.
        # @param [Hash]   opts      Optional arguments.
        #
        # @option opts [String] :error_expected For any negative tests
        #                                               if the error is expected or not
        # @return nil
        #
        #######################################################################
        def unload_all_modules( modules, opts={} )
            expected_res = opts.fetch( :error_expected, nil )
            modules.each do|module_name|
                $LOG.info "Unloading module name == #{module_name}"
                exec! "modprobe -v -r #{module_name}" \
                    do |_, stdout, stderr|
                    check_for_tinymix_errors( stderr, error_expected: expected_res )
                end
            end
        end

        #######################################################################
        #
        # @function is_firmware_loaded?
        #
        # Check whether the specified firmware is present on the target device.
        #
        # @param [String]             algo_name The name of the algorithm
        #                                       to check for.
        # @param [Hash]                      opts      Firmware Information hash.
        # @option opts [nil|String]         :version  Version string of the firmware
        #                                             that should be present.
        # @option opts [nil|String|Integer] :dsp_core The name of the DSP that the
        #                                             firmware should be installed
        #                                             on (e.g. DSP2).
        # @option opts [Integer] :expected_firmware_id ID of that particular firmware
        #
        # @return [Boolean] true if the specified firmware was present,
        #                   otherwise returns false
        #
        # @raise [RuntimeError] An exception is raised if the usecase required
        #                       to wake up the codec can not be found.
        # @raise [RuntimeError] An exception is raised if dsp debugfs nodes
        #                       can not be read.
        # @raise [RuntimeError] An exception id raised if the RemoteSalad is
        #                       configured to use an unknown firmware info
        #                       and register value access method.
        #
        #######################################################################
        def is_firmware_loaded?( algo_name, opts )
            supported_opts = ['version', 'dsp_core','expected_fw_id']
            validate_options( opts.keys ,supported_opts, 'RemoteSalad: (is_firmware_loaded?)')
            version = opts.fetch( 'version', nil )
            dsp_core = opts.fetch( 'dsp_core', nil )
            expected_firmware_id = opts.fetch( 'expected_fw_id', nil )
            if expected_firmware_id == nil
                expected_firmware_id = Conf::hash_lookup_value( :Firmware_ids,
                                                                algo_name
                                                              )
            end
            loaded = false
            dsp_core_id = extract_dsp_index( dsp_core )
            firmware_id = ''
            firmware_rev = ''

            case ChipInfoAccess
            when :native
                debugfs_path = "#{ASoCDebugfsRoot}/#{CardName}/#{CodecName}"
                dsp_name = nil

                if nil != dsp_core_id
                    dsp_name = "dsp#{dsp_core_id + 1}"
                    exec! "cat #{debugfs_path}/#{dsp_name}/fw_id"             \
                            do |exit_code, stdout, _|
                        if 0 != exit_code
                            raise "Failed to read debugfs!"
                        end
                        firmware_id = stdout
                    end
                    if !firmware_id.empty?
                        loaded = firmware_id.hex == expected_firmware_id.hex
                    end
                else
                    dsps = []
                    exec! "ls #{debugfs_path}" do |_, stdout, _|
                        dsps = stdout.scan( /^dsp\d+$/ )
                    end

                    for dsp in dsps
                        dsp_core_id = extract_dsp_index( dsp )
                        exec! "cat #{debugfs_path}/#{dsp}/fw_id"              \
                                do |exit_code, stdout, _|
                            if 0 != exit_code
                                raise 'Failed to read debugfs!'
                            end
                            firmware_id = stdout
                        end
                        if !firmware_id.empty?
                            loaded = firmware_id.hex == expected_firmware_id.hex
                            if loaded
                                dsp_name = dsp
                                break
                            end
                        end
                    end
                end

                if !version.nil? && loaded
                    exec! "cat #{debugfs_path}/#{dsp_name}/fw_version"        \
                            do |exit_code, stdout, _|
                        if 0 != exit_code
                            raise "Failed to read debugfs!"
                        end
                        firmware_rev = stdout
                    end
                    if !firmware_rev.empty?
                        firmware_rev.gsub '0x', ''
                        major = firmware_rev[0..1].hex
                        minor = firmware_rev[2..3].hex
                        patch = firmware_rev[4..5].hex
                        firmware_rev = "#{major}.#{minor}.#{patch}"
                        loaded = firmware_rev == version
                    end
                end
            when :WISCEBridge
                initialize_wiscebridge

                # ensure codec is awake before proceeding (needed by
                # WISCEBridge to read values from the codec)
                unless File.file? "#{UsecasePath}/wake_up_codec.csv"
                    raise 'RemoteSalad: is_firmware_loaded? requires a '      \
                          ' usecase "wake_up_codec.csv" to ensure the codec'  \
                          ' is not in low power mode before attempting to use'\
                          ' WISCEBridge to read any data from the codec.'
                end
                usecase 'wake_up_codec'

                begin
                    WISCEBridgeClient::connect( IPAddress )
                    WISCEBridgeClient::select_device

                    if nil != dsp_core_id
                        firmware_id = WISCEBridgeClient::get_firmware_id( dsp_core_id )
                        loaded = firmware_id.hex == expected_firmware_id.hex
                    else
                        dsp_core_id = 0
                        loop do
                            begin
                                firmware_id = WISCEBridgeClient::get_firmware_id( dsp_core_id )
                                loaded = firmware_id.hex == expected_firmware_id.hex
                                break if loaded
                                dsp_core_id += 1
                            rescue
                                break
                            end
                        end
                    end

                    if nil != version && loaded
                        firmware_rev = WISCEBridgeClient::get_firmware_revision( dsp_core_id )
                        loaded = firmware_rev == version
                    end
                ensure
                    WISCEBridgeClient::disconnect
                end
            else
                raise UnrecoginsedChipInfoAccessMsg % {valid_methods:
                                                        [:native, :WISCEBridge]
                                                      }
            end

            return loaded, dsp_core_id
        end

        #######################################################################
        #
        # @function is_firmware_running?
        #
        # Check whether the specified firmware is running on the target device.
        #
        # @param [String]             algo_name The name of the algorithm
        #                                       to check for.
        # @param [Hash]               opts      Firmware Information hash.
        # @option opts [nil|String]         :version  Version string of the firmware
        #                                             that should be present.
        # @option opts [nil|String|Integer] :dsp_core The name of the DSP that the
        #                                             firmware should be installed
        #                                             on (e.g. DSP2).
        # @option opts [Integer] :expected_firmware_id ID of that particular firmware
        #
        # @return [Boolean] true if the specified firmware was running,
        #                   otherwise returns false
        # @raise [RuntimeError] An exception is raised if the requested firmware
        #                       failed to load in the specified DSP core.
        # @raise [RuntimeError] An exception is raised if dsp debugfs nodes
        #                       can not be read.
        #
        #######################################################################
        def is_firmware_running?( algo_name, opts )
            supported_opts = ['version', 'dsp_core','expected_fw_id']
            validate_options( opts.keys ,supported_opts, 'RemoteSalad: (is_firmware_running?)')
            expected_firmware_id = opts.fetch( 'expected_fw_id', nil )
            dsp_core = opts.fetch( 'dsp_core', nil )
            version = opts.fetch( 'version', nil )
            if expected_firmware_id == nil
                expected_firmware_id = Conf::hash_lookup_value( :Firmware_ids,
                                                                algo_name
                                                              )
            end
            loaded = false
            flag = false
            running = ''


            loaded, dsp_core_id = is_firmware_loaded?( algo_name, opts )
            if( loaded == false )
                $LOG.info 'Firmware failed to load in the given DSP core'
                return flag
            end

            case ChipInfoAccess
            when :native
                debugfs_path = "#{ASoCDebugfsRoot}/#{CardName}/#{CodecName}"
                dsp_name = nil

                if nil != dsp_core_id
                    dsp_name = "dsp#{dsp_core_id + 1}"
                    exec! "cat #{debugfs_path}/#{dsp_name}/running"            \
                            do |exit_code, stdout, _|
                        if 0 != exit_code
                            raise "Failed to read debugfs!"
                        end
                        running = stdout
                    end
                    if !running.empty?
                        flag = running.chomp == RUNNING
                    end
                end
            else
                raise UnrecoginsedChipInfoAccessMsg % {valid_methods:
                                                        [:native]
                                                      }
            end
            return flag
        end

        #######################################################################
        #
        # @function load_firmware
        #
        # Loads firmware onto the selected device.
        #
        # @param [String] algo_name The filename of the firmware to load on
        #                           the target
        # @param [String] dsp_core  The name of the DSP that the firmware should
        #                           be loaded on (e.g. DSP2).
        # @param [Hash]   opts      Optional arguments.
        #
        # @option opts [String] :faux_firmware_name A "false identity" for the
        #                                           firmware. This is used when
        #                                           trying to load a firmware
        #                                           not available on the
        #                                           drivers' hardcoded list
        #                                           of firmwares.
        #
        # @return void
        #
        #######################################################################
        def load_firmware( algo_name, dsp_core, opts = {} )
            tinymix_name = Conf::hash_lookup_value( :Firmware_tinymixNames,
                                                    algo_name
                                                  )
            dsp_core_id = extract_dsp_index( dsp_core )
            faux_name = opts.fetch( :faux_firmware_name, nil )

            # copy firmware to the remote device
            deploy_firmware( algo_name,
                             dsp_index: dsp_core_id,
                             faux_firmware_name: faux_name
                           )

            set_mixer_property "DSP#{dsp_core_id + 1} Firmware",
                               "#{tinymix_name}"

            return
        end

        #######################################################################
        #
        # @function start_firmware
        #
        # Locate and start the core with the requested firmware.
        #
        # @note This implementation only checks whether the core has been
        #       started as the linux driver should autostart executing the
        #       firmware once it's loaded.
        #
        # @param [String]             algo_name The name of the algorithm to
        #                                       deploy.
        # @param [nil|String]         revision  Version string of the firmware
        #                                       that should be present.
        # @param [nil|String|Integer] dsp_core  The name of the DSP that the
        #                                       firmware should be installed
        #                                       on (e.g. DSP2).
        #
        # @return [Boolean] true if the firmware started, false otherwise.
        #
        # @raise [RuntimeError] An exception is raised if the debugfs node
        #                       corresponding to the given dsp core can not be
        #                       read.
        # @raise [RuntimeError] An exception id raised if the RemoteSalad is
        #                       configured to use an unknown firmware info
        #                       and register value access method.
        #
        #######################################################################
        def start_firmware( algo_name, revision, dsp_core )
            opts['version'] = revision
            opts['dsp_core'] = dsp_core
            started, dsp_core_id = is_firmware_loaded?( algo_name, opts )
            dsp_core_id = extract_dsp_index( dsp_core )

            case ChipInfoAccess
            when :native
                debugfs_path = "#{ASoCDebugfsRoot}/#{CardName}/#{CodecName}"
                dsp_core_id = extract_dsp_index( dsp_core )
                dsp_name = "dsp#{dsp_core_id + 1}"
                core_running = ''
                exec! "cat #{debugfs_path}/#{dsp_name}/running"              \
                        do |exit_code, stdout, _|
                    if 0 != exit_code
                        raise 'Failed to read debugfs!'
                    end
                    core_running = stdout
                end
                if !core_running.empty?
                    started = 'Y' == core_running
                end
            when :WISCEBridge
                begin
                    WISCEBridgeClient::connect( IPAddress )
                    WISCEBridgeClient::select_device

                    started = WISCEBridgeClient::is_core_started?( dsp_core_id )
                ensure
                    WISCEBridgeClient::disconnect
                end
            else
                raise UnrecoginsedChipInfoAccessMsg % {valid_methods:
                                                        [:native, :WISCEBridge]
                                                      }
            end if started

            started
        end

        #######################################################################
        #
        # @function read_memory_value
        #
        # Reads a value from the codecs' memory.
        #
        # @param [String] address An address in the codecs' memory.
        # @param [Fixnum] bytes   Amount of bytes to read.
        # @param [Fixnum] bits    Bit width of the register map (defaults to
        #                         32).
        #
        # @return [nil|String] String representing a memory value (in hex) or
        #                      nil if WISCEBridge™ connection fails.
        #
        # @raise [RuntimeError] An exception is raised if an unrecognised bit
        #                       width is used.
        # @raise [RuntimeError] An exception is raised if the RemoteSalad is
        #                       configured to use an unknown firmware info
        #                       and register value access method.
        #
        #######################################################################
        def read_memory_value( address, bytes = 2, bits = 32 )
            value = nil

            case ChipInfoAccess
            when :native
                upload( File.join( ENV['FRUITSALAD_HOME'],
                                  'miscutil',
                                  'read_register.sh'
                                 ),
                        TempDir
                      )
                case bits
                when 16
                    regmap = Regmap16bit
                    grep_address = address.rjust(4, '0')
                when 32
                    regmap = Regmap32bit
                    grep_address = address.rjust(6, '0')
                else
                    raise "Unrecognised register map bit width - #{bits}."
                end
                if ( /0x[\da-fA-F]+/ =~ address ).nil?
                    address = "0x#{address}"
                end
                # Currently we have the bug with read_register.sh, as a work
                # around we are currently reading it through cat command. We
                # need to handle this in a separate task to handle this bug.
                if bytes > 4
                    exec! "bash #{TempDir}read_register.sh #{address} #{bits} "   \
                          "#{RegmapDebugfsRoot}/#{regmap}/range "                 \
                          "#{RegmapDebugfsRoot}/#{regmap}/registers"              \
                          do |_, stdout, _|
                    end
                else
                    exec! "cat #{RegmapDebugfsRoot}/#{regmap}/registers | grep #{grep_address}:" do |_, stdout, _|
                        value = stdout
                    end
                end
                if !value.nil? and !value.empty?
                    value.gsub!( /[\da-fA-F]+:/, '' ).strip!
                end
            when :WISCEBridge

                initialize_wiscebridge

                begin
                    WISCEBridgeClient::connect( IPAddress )
                    WISCEBridgeClient::select_device

                    value = WISCEBridgeClient::read_memory_value( address,
                                                                  bytes
                                                                )
                ensure
                    WISCEBridgeClient::disconnect
                end
            else
                raise UnrecoginsedChipInfoAccessMsg % {valid_methods:
                                                        [:native, :WISCEBridge]
                                                      }
            end
            value
        end

        #########################################################################
        #
        # @function write_block_data
        #
        # Writes a block of data to the arbitrary memory locations of the codec device.
        #
        # @param[String] address An address in the codec's memory.
        #
        # @param[Integer] value It is a value written into the particular address.
        #
        # @param [Fixnum] bytes   Amount of bytes to write(defaults to 2).
        #
        # @param [Fixnum] bits  Bit width of the register map (defaults to
        #                           32).
        #
        #########################################################################
        def write_block_data( address , value, bytes = 2, bits = 32 )
            case ChipInfoAccess
            when :native
                case bits
                when 16
                    regmap = Regmap16bit
                    increment = 1
                    num = bytes/2
                when 32
                    regmap = Regmap32bit
                    increment = 2
                    num = bytes/4
                end
                address = address.to_i
                for i in 0..(num-1)
                    ret_val = exec! "echo #{address} #{value[i]} > #{RegmapDebugfsRoot}/#{regmap}/registers "
                    ret = ret_val.data
                    if ret != 0
                        raise $LOG.error ('Writing into the register is fail and check once write permissions')
                    end
                    address += increment
                end
            else
                raise $LOG.error ('unsupported error')
            end
        end

        #########################################################################
        #
        # @function device_id
        #
        # Returns the Hardware Device ID read from register 0h
        #
        # (no parameters)
        #
        # @return [Integer|nil] Returns the Hardware Device ID
        #
        #########################################################################
        def device_id
           sw_rst_dev_id = read_memory_value( DEVICE_ID_REG_ADDR.to_s(16), 2 )
           return sw_rst_dev_id.hex
        end

        #########################################################################
        #
        # @function hw_revision
        #
        # Returns the Hardware Revision read from register 1h
        #
        # (no parameters)
        #
        # @return [Integer|nil] Returns the Hardware Revision
        #
        #########################################################################
        def hw_revision
           hw_rev = read_memory_value( HW_REV_REG_ADDR.to_s(16), 2 )
           return hw_rev.hex & HW_REVISION_WIDTH
        end

        #######################################################################
        #
        # @function plaback_end_time
        #
        # Get the end time of the playback.
        #
        # (no parameters)
        #
        # @return [Float] Returns end time of playback.
        #
        #######################################################################
        def plaback_end_time
            @end_time
        end

        private
        #######################################################################
        #
        # @function check_for_tinymix_errors
        #
        # Determines if tinymix printed any errors to stderr.
        #
        # @note This method is meant as a workaround to tinymix not returning
        #       error codes upon failure.
        #
        # @param [String] stderr The contents of stderr collected as a result
        #                        of a tinymix invocation.
        #
        # @raise [RuntimeError] An exception is risen if stderr contains
        #                       tinymix errors.
        # @param [Hash]   opts      Optional arguments.
        #
        # @option opts [String] :error_expected For any negative tests
        #                                               if the error is expected or not
        #
        #######################################################################
        def check_for_tinymix_errors( stderr, opts = {} )
            expected = opts.fetch( :error_expected, nil )
            unless stderr.empty?
                error_message = ''
                #
                # Android prints an error on each ssh command invocation, so
                # parse it out, disregard it and assume the rest of stderr
                # pertains to tinymix
                #
                error = /void endpwent\(\)\(\d+\) is not implemented on Android[\n\r]*((?:.*[\n\r]*)*)/.match( stderr )
                if error.nil?
                    #
                    # in case of a non Android system assume any output on
                    # stderr is printed by tinymix
                    #
                    error_message = stderr
                elsif !error[1].empty?
                    error_message = error[1]
                end
                if expected != nil
                    raise 'RemoteSalad: tinymix returned the following error' +
                          " - #{error_message}"  unless ( error_message =~ /#{expected}(.*)/)
                else
                    unless error_message.empty?
                        raise 'RemoteSalad: tinymix returned the following error' +
                               " - #{error_message}"
                    end
                end
            end
        end
    end
end

# Configure the Device Factory to use our specialised device.
FruitSalad.type = FruitSalad::RemoteSalad

#################################### END OF FILE ##############################