////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Cirrus Logic International (UK) Ltd. All rights reserved.
//
// This software as well as any related documentation is furnished under
// license and may only be used or copied in accordance with the terms of the
// license. The information in this file is furnished for informational use
// only, is subject to change without notice, and should not be construed as
// a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document.
//
// Except as permitted by such license, no part of this document may be
// reproduced, stored in a retrieval system, or transmitted in any form or by
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies.
//
/// @file   discontinuity.cpp
/// @brief  provides discontinuity checking wrapper functionality for FruitSalad.
///
/// @warning
///   This software is specifically written for Cirrus Logic devices.
///   It may not be used with other devices.
///
////////////////////////////////////////////////////////////////////////////////

//
// Include files
//
#include <stdio.h>
#include <math.h>
#include "discontinuity.h"
#include "fft.h"

///////////////////////////////////////////////////////////////////////////////
///
// Function: DiscontinuityDetection
///
/// @brief    Performs discontinuity checking in output file with respect to
///           reference file and returns at what time there is discontinuity
///           if there is any discontinuity in output file.
///
/// @param *pReferenceFile     Reference file path.
/// @param *pOutputFile        Output file path.
/// @param *pDiscontinuityTime Pointer to hold time at which discontinuity
///                            occured in output file.
///
/// @retval FILEOPEN_ERROR   Couldn't open files.
/// @retval DISC_DETECTED    Discontinuity detected in output file.
/// @retval NO_DISCONTINUITY No discontinuity in output file.
///
///////////////////////////////////////////////////////////////////////////////
DISC_API DiscontinuityRetCode DiscontinuityDetection( char  *pReferenceFile,
                                                      char  *pOutputFile,
                                                      float *pDiscontinuityTime
                                                    )
{

    int i, j, numSamples, totalSamples;
    int discontinuityFlag, byteDepth, silenceSampleCount;
    int indicesMax, nFrames, lastSamples, sampleRate;

    float normValue, hanningSum, sec;
    double *pXcfRef, *pXcfOut, *pXcf;
    float *pRefReal, *pOutReal, *pRefComplex, *pOutComplex;
    float *pRefFFTReal, *pRefFFTImg, *pOutFFTReal, *pOutFFTImg;
    float *pRefMagnitudeRatio, *pOutMagnitudeRatio, *pImagInput;
    double *pHannWindow;
    DiscontinuityRetCode exitCode;
    discDetect stDiscDetect;
    SF_INFO sfRefInfo, sfOutInfo;
    SNDFILE *sndRefFile, *sndOutFile;
    sf_count_t lengthRef, lengthOut, readSamples;

    pXcfRef = stDiscDetect.xcfRef;
    pXcfOut = stDiscDetect.xcfOut;
    pXcf = stDiscDetect.xcFunction;
    pRefReal = stDiscDetect.refReal;
    pOutReal = stDiscDetect.outReal;
    pRefComplex = stDiscDetect.refComplex;
    pOutComplex = stDiscDetect.outComplex;
    pRefFFTReal = stDiscDetect.refFFTReal;
    pRefFFTImg = stDiscDetect.refFFTImg;
    pOutFFTReal = stDiscDetect.outFFTReal;
    pOutFFTImg = stDiscDetect.outFFTImg;
    pRefMagnitudeRatio = stDiscDetect.refMagnitudeRatio;
    pOutMagnitudeRatio = stDiscDetect.outMagnitudeRatio;
    pHannWindow = stDiscDetect.hannWindow;
    pImagInput = stDiscDetect.imagInput;

    discontinuityFlag = 0;

    //Initializing buffers with zeros.
    InitBuffers( &stDiscDetect );

    //Opening files.
    sfRefInfo.format = 0;
    sfOutInfo.format = 0;

    sndRefFile = sf_open( pReferenceFile, SFM_READ, &sfRefInfo );
    if( NULL == sndRefFile )
    {
        exitCode = FILEOPEN_ERROR;
        goto end;
    }

    sndOutFile = sf_open( pOutputFile, SFM_READ, &sfOutInfo );
    if( NULL == sndOutFile )
    {
        exitCode = FILEOPEN_ERROR;
        goto close_inputfile;
    }

    sf_command( sndRefFile, SFC_SET_NORM_DOUBLE, NULL, SF_TRUE );
    sf_command( sndOutFile, SFC_SET_NORM_DOUBLE, NULL, SF_TRUE );

    sf_command( sndRefFile, SFC_SET_NORM_FLOAT, NULL, SF_TRUE );
    sf_command( sndOutFile, SFC_SET_NORM_FLOAT, NULL, SF_TRUE );

    //samplerate reading
    sampleRate = sfRefInfo.samplerate;
    //bytedepth reading
    byteDepth = ( sfRefInfo.format & SF_TYPE_MASK );

    //Finding length of files samples wise.
    lengthRef = sfRefInfo.frames;
    lengthOut = sfOutInfo.frames;

    silenceSampleCount = SilenceDetection( sndRefFile );

    sf_seek( sndRefFile, ( silenceSampleCount ), SEEK_SET );
    lengthRef = lengthRef - silenceSampleCount;

    //Reading samples from reference file.
    numSamples = XCOR_LENGTH;
    sf_read_double( sndRefFile, pXcfRef, numSamples );

    //Reading samples from output file.
    numSamples = XCF_LENGTH;
    sf_read_double( sndOutFile, &pXcfOut[XCOR_LENGTH], numSamples );

    //Computing normalized cross correlation between reference, output files.
    indicesMax = NormCrossCorrelation( pXcfOut, pXcfRef, pXcf );

    indicesMax = ( indicesMax - XCOR_LENGTH );

    if( indicesMax < 0 )
    {
        indicesMax = abs( indicesMax );
        //Seeking to the index in reference file where correlation was maximum.
        sf_seek( sndRefFile, ( indicesMax + silenceSampleCount ), SEEK_SET );
        //Seeking to the point after wave header in output file.
        sf_seek( sndOutFile, 0, SEEK_SET );

        //Substracting correlation index size from reference file length.
        lengthRef = lengthRef - indicesMax;
    }
    else
    {
        //Seeking to the index in output file where correlation was maximum.
        sf_seek( sndOutFile, indicesMax, SEEK_SET );
        //Seeking to the point after wave header in reference file.
        sf_seek( sndRefFile, ( silenceSampleCount ), SEEK_SET );

        //Substracting correlation index size from output file length.
        lengthOut = lengthOut - indicesMax;
    }
    //Taking minimum length from reference and output files.
    if( lengthOut > lengthRef )
        lengthOut = lengthRef;

    //Number of frames
    nFrames = ( int )( lengthOut / DISC_FRAME_LENGTH );
    //Left over samples
    lastSamples = lengthOut % DISC_FRAME_LENGTH;

    CalcHannWindow( pHannWindow, HANN_WINDOW_LENGTH );

    hanningSum = 0;
    for( i = 0; i < HANN_WINDOW_LENGTH; i++ )
    {
        hanningSum = ( float )( hanningSum + pHannWindow[i] );
    }
    normValue = ( 1 / hanningSum );

    totalSamples = 0;

    //Reading samples from reference and output file.
    numSamples = DISC_FFT_LENGTH;
    readSamples = sf_read_float( sndRefFile, pRefReal, numSamples );
    readSamples = sf_read_float( sndOutFile, pOutReal, numSamples );

    totalSamples = totalSamples + DISC_FRAME_LENGTH;
    //Iterating through number of frames till discontinuity is detected.
    for( i = 0; i < nFrames; i++ )
    {
        //Multiplying reference and input samples with hanning window.
        for( j = 0; j < DISC_FFT_LENGTH; j++)
        {
            pRefComplex[j] = ( float )( pRefReal[j] * pHannWindow[j] );
            pOutComplex[j] = ( float )( pOutReal[j] * pHannWindow[j] );
        }

        CFFT( pRefComplex, pImagInput, pRefFFTReal, pRefFFTImg, -1,
              DISC_FFT_LENGTH);
        CFFT( pOutComplex, pImagInput, pOutFFTReal, pOutFFTImg, -1,
              DISC_FFT_LENGTH);

        //Computing magnitude ratios for reference and output files.
        ComputeMagnitudeRatio( pRefFFTReal, pRefFFTImg, pOutFFTReal, pOutFFTImg,
                               pRefMagnitudeRatio, pOutMagnitudeRatio, normValue );

        sec = ( ( float )totalSamples / sampleRate );
        //discontinuity detection
        discontinuityFlag = DetectDiscontinuity( pRefMagnitudeRatio,
                                                 pOutMagnitudeRatio, pRefFFTReal );

        if( discontinuityFlag == 1 )
        {
            ( *pDiscontinuityTime ) = sec;
            exitCode = DISC_DETECTED;
            goto close_inoutfiles;
        }

        //Break if we have reached the last frame.
        if( i == ( nFrames-1 ) )
            break;
        //Update samples for next frame. Since FFT needs past samples we are
        //copying last 4096 samples to buffer start.
        for( j = 0; j < DISC_FRAME_LENGTH; j++ )
        {
            pRefReal[j] = pRefReal[j + DISC_FRAME_LENGTH];
            pOutReal[j] = pOutReal[j + DISC_FRAME_LENGTH];
        }
        //Reading next 4096 samples from files
        if( i < ( nFrames - 2 ) )
        {
            numSamples = DISC_FRAME_LENGTH;
            readSamples = sf_read_float( sndRefFile,
                                         &pRefReal[DISC_FRAME_LENGTH], numSamples );
            readSamples = sf_read_float( sndOutFile,
                                         &pOutReal[DISC_FRAME_LENGTH], numSamples );
        }
        else
        {
            //In some cases last frame may not consist full 4096 samples
            //so appending with zeros.
            numSamples = lastSamples;
            readSamples = sf_read_float( sndRefFile,
                                         &pRefReal[DISC_FRAME_LENGTH], numSamples );
            readSamples = sf_read_float( sndOutFile,
                                         &pOutReal[DISC_FRAME_LENGTH], numSamples );
            for( j = lastSamples; j < DISC_FRAME_LENGTH; j++ )
            {
                pRefReal[j + DISC_FRAME_LENGTH] = 0;
                pOutReal[j + DISC_FRAME_LENGTH] = 0;
            }
        }
        totalSamples = totalSamples + DISC_FRAME_LENGTH;
    }
    exitCode = NO_DISCONTINUITY;

close_inoutfiles:
    sf_close( sndOutFile );
close_inputfile:
    sf_close( sndRefFile );
end:
    return exitCode;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: NormCrossCorrelation
///
/// @brief    Computing normalized correlation of output signal with reference
///           signal.
///
/// @param *pXcfRef  Pointer to the buffer to hold reference file samples.
/// @param *pXcfOut  Pointer to the buffer to hold ouput file samples.
/// @param *pCorrOut Pointer to the buffer to hold cross correlation output.
///
/// @return   Returns cross correlation index.
///
///////////////////////////////////////////////////////////////////////////////
int NormCrossCorrelation( double *pXcfOut,
                          double *pXcfRef,
                          double *pCorrOut
                        )
{
    double max, refSum, refMean, outSum, outMean, squareOut;
    double refVal, outVal, refSquare, outSquare, xcorVal;
    int indicesMax, i, j, k;

    //variable to hold minimum correlation value
    max = -1024;
    //variable to hold index in reference data with maximum correlation
    indicesMax = 0;
    refSum = 0;
    for( i = 0; i < XCOR_LENGTH; i++ )
    {
        refSum = refSum + pXcfRef[i];
    }
    refMean = refSum / XCOR_LENGTH;

    //cross correlation computation
    for( i = 0; i < XCF_LENGTH; i++ )
    {
        outSum = 0;
        for( k = i; ( k < ( XCOR_LENGTH + i ) ); k++ )
        {
            outSum = outSum + pXcfOut[k];
        }
        outMean = outSum / XCOR_LENGTH;

        k = i;
        xcorVal = 0;
        refSquare = 0;
        outSquare = 0;
        for( j = 0; j < XCOR_LENGTH; j++ )
        {
            outVal = ( pXcfOut[k] - outMean );
            refVal = ( pXcfRef[j] - refMean );

            xcorVal = xcorVal + ( refVal * outVal );
            refSquare = refSquare + ( refVal * refVal );
            outSquare = outSquare + ( outVal * outVal );
            k++;
        }
        squareOut = sqrt( refSquare * outSquare );
        pCorrOut[i] = ( xcorVal / squareOut );
        // computing maximum correlation index
        if( pCorrOut[i] > max )
        {
            max = pCorrOut[i];
            indicesMax = i;
        }
    }
    return indicesMax;
}
///////////////////////////////////////////////////////////////////////////////
///
// Function: DetectDiscontinuity
///
/// @brief    Comparing magnitude ratios of reference and output signals.If the
///           signal level is strong and if the difference between magnitude
///           ratios is greater than 0.1dB, then there is discontinuty in the
///           output.
///
/// @param *pRefMagnitudeRatio  Pointer to the buffer to hold reference signal
///                             magnitude ratios.
/// @param *pOutMagnitudeRatio  Pointer to the buffer to hold output signal
///                             magnitude ratios.
/// @param *pRefFFTReal         Pointer to the buffer to hold reference FFT
///                             output.
///
/// @return   Returns 1 if discontinuity is detected otherwise 0 is returned.
///
///////////////////////////////////////////////////////////////////////////////
int DetectDiscontinuity( float *pRefMagnitudeRatio,
                         float *pOutMagnitudeRatio,
                         float *pRefFFTReal
                       )
{
    int j, discontinuityFlag = 0;
    for( j = 0; j < MAGNITUDE_RATIOS_COUNT; j++ )
    {
        if( ( fabs( pRefMagnitudeRatio[j] - pOutMagnitudeRatio[j] ) > MAGNITUDE_RATIO_THRESHOLD )&&
            ( ( 20 * log10( pRefFFTReal[j+1] ) ) > NOISE_THRESHOLD_DB )&&
            ( ( 20 * log10( pRefFFTReal[j] ) ) > NOISE_THRESHOLD_DB ) )
        {
            discontinuityFlag = 1;
            break;
        }
    }
    return discontinuityFlag;
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: ComputeMagnitudeRatio
///
/// @brief    Calculates magnitude ratios(b/a) for reference and output files.
///
/// @param *pRefFFTReal        Pointer to the buffer to hold reference real part.
/// @param *pRefFFTImg         Pointer to the buffer to hold reference imaginary part.
/// @param *pOutFFTReal        Pointer to the buffer to hold output real part.
/// @param *pOutFFTImg         Pointer to the buffer to hold output imaginary part.
/// @param *pRefMagnitudeRatio Pointer to the buffer to hold reference magniutde ratios.
/// @param *pOutMagnitudeRatio Pointer to the buffer to hold output magnitude ratios.
/// @param normValue           Value used for normalizing.
///
///////////////////////////////////////////////////////////////////////////////
void ComputeMagnitudeRatio( float *pRefFFTReal,
                            float *pRefFFTImg,
                            float *pOutFFTReal,
                            float *pOutFFTImg,
                            float *pRefMagnitudeRatio,
                            float *pOutMagnitudeRatio,
                            float normValue
                          )
{
    int j;
    //absolute of samples is calculated i.e sqrt(real^2 + imag^2)
    for( j = 0; j < DISC_NUM_BINS; j++ )
    {
        pRefFFTReal[j] = ( float )( sqrt( ( pRefFFTReal[j] * pRefFFTReal[j] ) +
                                          ( pRefFFTImg[j] * pRefFFTImg[j] ) ) );
        pOutFFTReal[j] = ( float )( sqrt( ( pOutFFTReal[j] * pOutFFTReal[j] ) +
                                          ( pOutFFTImg[j] * pOutFFTImg[j] ) ) );
        //normalizing
        pRefFFTReal[j] = pRefFFTReal[j] * normValue;
        pOutFFTReal[j] = pOutFFTReal[j] * normValue;

    }

    //Magnitude ratio computation i.e (b/a) is calculated.
    for( j = 0; j < MAGNITUDE_RATIOS_COUNT; j++ )
    {
        pRefMagnitudeRatio[j] = pRefFFTReal[j+1] / pRefFFTReal[j];
        pOutMagnitudeRatio[j] = pOutFFTReal[j+1] / pOutFFTReal[j];
    }
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: CalcHannWindow
///
/// @brief    Calculation of Hanning window.
///
/// @param *pHannWindow Pointer to hanning window buffer.
/// @param length       Length of hanning window buffer.
///
///////////////////////////////////////////////////////////////////////////////
void CalcHannWindow( double *pHannWindow,
                     int    length
                   )
{
    int half, i, idx, n;

    n = length;

    half = n / 2;
    for( i = 0; i < half; i++ ) //CALC_HANNING   Calculates Hanning window samples.
        pHannWindow[i] = 0.5 * ( 1 - cos( 2 * PI * ( i + 1 ) / ( n + 1 ) ) );

    //The window is a symmetric function, thus can be calculated for half and copied
    idx = half - 1;
    for( i = half; i < n; i++ )
    {
        pHannWindow[i] = pHannWindow[idx];
        idx--;
    }

}

///////////////////////////////////////////////////////////////////////////////
///
// Function: InitBuffers
///
/// @brief    Initialize buffers with zeros.
///
/// @param *stDiscDetect Pointer to structure.
///
///////////////////////////////////////////////////////////////////////////////
void InitBuffers( discDetect *stDiscDetect )
{
    int i;
    float *pImagInput;
    double *pXcfOut, *pXcf;

    pXcf = stDiscDetect->xcFunction;
    pXcfOut = stDiscDetect->xcfOut;
    pImagInput = stDiscDetect->imagInput;

    for( i = 0; i < XCF_LENGTH; i++ )
    {
        pXcf[i] = 0;
    }
    for( i=0; i < XCOR_LENGTH; i++ )
    {
        pXcfOut[i] = 0;
    }
    for( i = 0; i < DISC_FFT_LENGTH; i++ )
    {
        pImagInput[i] = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
///
// Function: SilenceDetection
///
/// @brief    Detects silence in the file.
///
/// @param  sndRefFile Pointer to the file.
///
/// @return   Returns number of samples of silence detected in the file.
///
///////////////////////////////////////////////////////////////////////////////
int SilenceDetection( SNDFILE *sndRefFile )
{
    int soundFlagCount, prevFlag, currentFlag, silenceSampleCount;
    int i, j;
    double energy, avgEnergy, energyDB;
    double inbufDouble[FRAMELENGTH];
    sf_count_t readSamples;

    j = 0;
    soundFlagCount = 0;
    prevFlag = 0;
    currentFlag = 0;
    //Reading samples
    readSamples = sf_read_double( sndRefFile, inbufDouble, FRAMELENGTH );

    while( !( FRAMELENGTH > readSamples ) )
    {
        energy = 0;
        //Calculating energy of frame
        for( i = 0; i < FRAMELENGTH; i++ )
        {
            energy += ( inbufDouble[i] * inbufDouble[i] );
        }
        //Average energy of frame
        avgEnergy = energy / ( double )FRAMELENGTH;
        //Energy into dB
        energyDB = 10 * log10( avgEnergy );
        //If energy is greater than silence threshold for continuos two frames
        //then it means data has been detected.
        if( energyDB > SILENCE_THRESHOLD )
        {
            soundFlagCount++;
            if( 1 == soundFlagCount )
                prevFlag = j;
            else if( 2 == soundFlagCount )
                currentFlag = j;
        }
        else
        {
            soundFlagCount = 0;
        }

        if( 2 == soundFlagCount && ( ( prevFlag + 1 ) == currentFlag ) )
            break;

        j++;
        //Reading samples for next frame
        sf_read_double( sndRefFile, inbufDouble, FRAMELENGTH );
    }
    silenceSampleCount = ( prevFlag * FRAMELENGTH );

    return silenceSampleCount;
}

/////////////////////////////END OF FILE///////////////////////////////////////