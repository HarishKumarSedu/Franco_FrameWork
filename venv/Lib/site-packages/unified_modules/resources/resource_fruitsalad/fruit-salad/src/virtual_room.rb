###############################################################################
###
### Copyright (c) 2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   virtual_room.rb
### @brief  Simulates attenuation and phase delay from an arrangement of
###         microphones placed in a virtual room
###
### @version \$Id: virtual_room.rb 1038 2015-05-12 10:04:28Z emmas $
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

#
# Requires
#
require 'configuration'
require 'fruitsalad_utils'
require 'wavefile'
require 'wavefile_analyzer'
require 'tone_generator'
require 'openal'
require 'logfw'

###############################################################################
#
# Allows the simulation of a virtual room containing a number of audio sources
# and microphones connected to the test target.
#
###############################################################################
class VirtualRoom
    include WavefileAnalyzer
    include ToneGenerator

    #
    # The sample rate to open wav format files at
    #
    SampleRate = Conf.property( :SampleRate, 48000 )
    #
    # When attempting to auto-detect the duration of the audio in the scene, what
    # is the length to be assigned to tone and noise generators in the scene.
    #
    MinimumSineLength = Conf.property( :MinimumSineLength, 3 )

    ###########################################################################
    #
    # @function initialize
    #
    # Default constructor
    #
    # (no parameters)
    #
    ###########################################################################
    def initialize
        @sources = []
        @microphones = []
        @open_oalbuffers = []
        @open_oalsources = []
    end

    ###########################################################################
    #
    # @function add_wavfile
    #
    # Add a buffer to the scene containing the contents of a named file.
    #
    # @param [Numeric] x    The x-coordinate of the source
    # @param [Numeric] y    The y-coordinate of the source
    # @param [Numeric] z    The z-coordinate of the source
    # @param [String]  file The name of the wav file to open
    #
    ###########################################################################
    def add_wavfile( x,y,z, file )
        @sources << [[x,y,z], :wavfile, { file:file } ]
    end

    ###########################################################################
    #
    # @function add_sine
    #
    # Add a buffer to the scene containing a sine tone of a fixed frequency.
    #
    # @param [Numeric] x         The x-coordinate of the source
    # @param [Numeric] y         The y-coordinate of the source
    # @param [Numeric] z         The z-coordinate of the source
    # @param [Numeric] frequency The frequency of the sine tone
    #
    ###########################################################################
    def add_sine( x,y,z, frequency )
        @sources << [[x,y,z], :sine, { frequency: frequency } ]
    end

    ###########################################################################
    #
    # @function add_microphone
    #
    # Add a microphone to the scene that will generate a track when the scene is
    # played.
    #
    # @param [Numeric] x The x-coordinate of the microphone
    # @param [Numeric] y The y-coordinate of the microphone
    # @param [Numeric] z The z-coordinate of the microphone
    #
    ###########################################################################
    def add_microphone( x,y,z )
        @microphones << [x,y,z]
    end

    ###########################################################################
    #
    # @function add_noise
    #
    # Add a noise source to the scene using the given SimulatedNoiseModel.
    #
    # @param [Numeric]              x               The x-coordinate of the
    #                                               source's position
    # @param [Numeric]              y               The y-coordinate of the
    #                                               source's position
    # @param [Numeric]              z               The z-coordinate of the
    #                                               source's position
    # @param [SimulatedNoiseModel]  noise_model     The noise model defining the
    #                                               type of noise to use
    # @param [Numeric]              amplitude       The Root-Mean-Square
    #                                               amplitude of the noise source
    #                                               in units dB full-scale
    #
    ###########################################################################
    def add_noise( x,y,z, noise_model, amplitude )
        @sources << [[x,y,z], :noise, { noise_model: noise_model, amplitude: amplitude } ]
    end

    ###########################################################################
    #
    # @function play_scene
    #
    # Use OpenAL to render the scene for each microphone, then pass the resulting
    # audio tracks to the FruitSalad device's multitrack_playback method.
    #
    # @param [FruitSalad::DeviceInterface] device   The FruitSalad device
    # @param [Numeric]                     duration Optional. The duration to
    #                                               record for.
    #
    ###########################################################################
    def play_scene( device, duration=nil)
        if duration.nil?
            duration = calculate_duration
        end

        set_up_scene
        microphone_tracks = @microphones.map { |microphone_position|
            calculate_microphone_track( duration, microphone_position )
        }
        tear_down_scene
        microphone_tracks = write_microphone_tracks( microphone_tracks )
        microphone_tracks = microphone_tracks.zip (1..microphone_tracks.length)
        $LOG.debug "Playing microphone tracks: #{microphone_tracks}"
        device.multitrack_playback( microphone_tracks )
    end

    private

    ###########################################################################
    #
    # @function create_source_from_wavfile
    #
    # Create a source within the OpenAL scene, with data loaded from a wavfile.
    #
    # @param [String]           filename    The name of the wav format file
    # @param [Array<Numeric>]   position    The position of the new source as 3D
    #                                       coordinates
    #
    ###########################################################################
    def create_source_from_wavfile( filename, *position )
        data = FruitSaladUtils::read_wavefile( filename, SampleRate )
        data.map! { |x| x[0] }
        create_source_from_data( data, *position )
    end

    ###########################################################################
    #
    # @function create_source_from_data
    #
    # Create a source within the OpenAL scene, with data given by a 1D Array of
    # samples
    #
    # @param [Array<Numeric>] data      The sample data to load into the OpenAL
    #                                   buffer given as a 1D array of floating
    #                                   point samples on the range [-1,1]
    # @param [Array<Numeric>] position  The position of the new source as 3D
    #                                   coordinates
    #
    ###########################################################################
    def create_source_from_data( data, *position )
        buffer = OpenAL.create_buffer( data )
        @open_oalbuffers << buffer
        source = OpenAL.create_source( buffer, *position )
        @open_oalsources << source
    end

    ###########################################################################
    #
    # @function set_up_scene
    #
    # Set up the OpenAL buffers and sources as needed to render this scene.
    #
    # (no parameters)
    #
    ###########################################################################
    def set_up_scene
        OpenAL.start
        $LOG.debug "Setting up #{@sources.length} sources."
        @sources.each do |position, type, options|
            case type
            when :wavfile
                create_source_from_wavfile( options[:file], *position )
            when :sine
                file = generate_sinewave( options[:frequency], calculate_duration )
                create_source_from_wavfile( file, *position )
            when :noise
                noise_model = options[:noise_model]

                noise_track = noise_model.generate_noise_track( calculate_duration, SampleRate, noise_db:options[:amplitude] )
                create_source_from_data( noise_track, *position )
            end
        end
    end

    ###########################################################################
    #
    # @function tear_down_scene
    #
    # Release all OpenAL buffers and sources associated with this scene.
    #
    # (no parameters)
    #
    ###########################################################################
    def tear_down_scene
        @open_oalsources.each do |source|
            OpenAL.release_source source
        end
        @open_oalbuffers.each do |buffer|
            OpenAL.release_buffer buffer
        end
        OpenAL.stop
    end

    ###########################################################################
    #
    # @function write_microphone_tracks
    #
    # Write the microphone tracks generated by this scene to wav files that can
    # be passed to the FruitSalad test device.
    #
    # @param [Array<Array<Numeric>>] track_list An array containing the raw data
    #                                           from the virtual microphones
    #
    # @return [Array<String>] An array containing the filenames of the written
    #                         tracks
    #
    ###########################################################################
    def write_microphone_tracks( track_list )
        number_of_tracks = track_list.length
        track_list = (0...number_of_tracks).zip track_list
        track_list.map! { |number, track|
            filename = "tmp/virtual_room_mic#{number}.wav"
            write_waveform( filename, track )
            filename
        }
        return track_list
    end

    ###########################################################################
    #
    # @function calculate_microphone_track
    #
    # Set the OpenAL listener position then trigger rendering.
    #
    # @param [Numeric] duration                     The amount of audio to
    #                                               render in seconds
    # @param [Array<Numeric>] microphone_position   The position the OpenAL
    #                                               listener should be set to.
    #
    ###########################################################################
    def calculate_microphone_track( duration, microphone_position )
        $LOG.debug "Recording at #{microphone_position}."
        OpenAL.listener = microphone_position
        data = OpenAL.play( @open_oalsources, duration )
        return data
    end

    ###########################################################################
    #
    # @function calculate_duration
    #
    # Parse each source in the scene to find the duration of the longest file
    # in the scene.
    #
    # (no parameters)
    #
    # @return [Numeric] The duration of the longest source in the scene in
    #                   seconds.
    #
    ###########################################################################
    def calculate_duration
        longest = nil
        @sources.each do |position, function, options|
            length = 0
            case function
            when :wavfile
                length = track_length options[:file]
                $LOG.debug "File #{options[:file]} length is #{length} seconds."
            when :sine,:noise
                length = MinimumSineLength
            end
            if longest.to_f < length
                longest = length
            end
        end
        if longest.nil?
            longest = MinimumSineLength
        end
        return longest
    end

end

##################################### END OF FILE #############################