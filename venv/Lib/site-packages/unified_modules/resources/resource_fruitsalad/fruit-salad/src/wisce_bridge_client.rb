################################################################################
##
## Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
##
## This software as well as any related documentation is furnished under
## license and may only be used or copied in accordance with the terms of the
## license. The information in this file is furnished for informational use
## only, is subject to change without notice, and should not be construed as
## a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
## (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
## that may appear in this document or any software that may be provided in
## association with this document.
##
## Except as permitted by such license, no part of this document may be
## reproduced, stored in a retrieval system, or transmitted in any form or by
## any means without the express written consent of Cirrus Logic International
## (UK) Ltd or affiliated companies.
##
### @file  wisce_bridge_client.rb
### @brief A simple WISCEBridge™ client.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
###
#################################################################################

require 'socket'
require 'configuration'

###############################################################################
#
# Mixin module encapsulating functionality needed to connect and communicate
# with WISCEBridge™.
#
###############################################################################
module WISCEBridgeClient

    # Mapping of core names to DSP control addresses
    DSPControlAddresses = Conf.property( :Firmware_DSPControlAddresses, {} )

    # Map of core names to base addresses of DSP memory regions
    DSPMemoryBaseAddresses = Conf.property( :Firmware_DSPMemoryBaseAddresses, {} )

    # Firmware id address offset
    FirmwareIdAddressOffset = 0x4

    # Firmware revision address offset
    FirmwareRevisionAddressOffset = 0x6

    ###########################################################################
    #
    # @function connect
    #
    # Connects to a device running WISCEBridge™.
    #
    # @param [String]  ip   IP address of the device to connect to.
    # @param [Integer] port Port number to use.
    #
    # @return [String] Welcome message sent by the server.
    #
    ###########################################################################
    def self.connect( ip = '127.0.0.1', port = 22349 )
        @socket = TCPSocket.new( ip, port )
        receive_message
    end

    ###########################################################################
    #
    # @function disconnect
    #
    # Ends a previously established WISCEBridge™ connection.
    #
    # (no parameters)
    #
    # @return void
    #
    ###########################################################################
    def self.disconnect
        if nil != @socket
            @socket.close
            @socket = nil
        end
    end

    ###########################################################################
    #
    # @function select_device
    #
    # Selects a codec to query.
    #
    # @param [String] device_name Name of the codec to select. Defaults to
    #                             arizona.
    #
    # @return void
    #
    # @raise [] An exception is raised if device selection fails.
    #
    ###########################################################################
    def self.select_device( device_name = 'arizona' )
        reply = send_arbitrary_command "device #{device_name}"
        raise "Failed to select codec: #{device_name}" if 'Ok' != reply.chomp!
    end

    ###########################################################################
    #
    # @function get_firmware_id
    #
    # Retrieve the id of a firmware loaded on the specified core.
    #
    # @note The firmware id is retrieved based on a base address of the DSP data
    #       memory provided by the user in the config and a well known offset.
    #
    # @param [Integer] dsp_core_id DSP core id (e.g. 0 for DSP1).
    #
    # @return [String] Firmware id.
    #
    ###########################################################################
    def self.get_firmware_id( dsp_core_id )
        data_memory_base = get_dsp_data_memory_base_address( dsp_core_id )
        register = "#{(data_memory_base + FirmwareIdAddressOffset).to_s(16)}"
        id = read_memory_value( register, 4 )
        id
    end

    ###########################################################################
    #
    # @function get_firmware_revision
    #
    # Retrieve the revision of a firmware loaded on the specified core.
    #
    # @note The firmware revision is retrieved based on a base address of the
    #       DSP data memory provided by the user in the config and a well known
    #       offset.
    #
    # @param [Integer] dsp_core_id DSP core id (e.g. 0 for DSP1).
    #
    # @return [String] Firmware revision.
    #
    ###########################################################################
    def self.get_firmware_revision( dsp_core_id )
        data_memory_base = get_dsp_data_memory_base_address( dsp_core_id )
        register = "#{(data_memory_base + FirmwareRevisionAddressOffset).to_s(16)}"
        rev = read_memory_value( register, 4 )
        parse_revision( rev )
    end

    ###########################################################################
    #
    # @function is_core_started?
    #
    # Checks whether a given DSP core has been started.
    #
    # @note This method relies on reading a DSP control register, specifically
    #       it's first bit. The address of this register must be supplied
    #       through a FruitSalad configuration file.
    #
    # @param [Integer] dsp_core_id DSP core id (e.g. 0 for DSP1).
    #
    # @return [Boolean] true if the core is started, false otherwise.
    #
    ###########################################################################
    def self.is_core_started?( dsp_core_id )
        dsp_control_address = get_dsp_control_address( dsp_core_id )
        dsp_control = read_memory_value( dsp_control_address.to_s(16), 2 )
        0x2 == (dsp_control.hex & 0x2)
    end

    ###########################################################################
    #
    # @function read_memory_value
    #
    # Read a memory value consisting of a given amount of bytes located
    # at a specified address.
    #
    # @param [String]  address A string representing a memory address (in hex).
    # @param [Integer] bytes   The number of bytes to read
    #
    # @return String representing a memory value.
    #
    # @raise [RuntimeError] If WISCEBridge™ returns an error code.
    #
    ###########################################################################
    def self.read_memory_value( address, bytes = 2 )
        reply = send_arbitrary_command "read #{address}"
        raise "WISCEBridge returned: #{reply}" unless nil == (/Error\s\d+/ =~ reply)
        if 2 < bytes
            reply = send_arbitrary_command "blockread #{address} #{bytes}"
        end
        reply.chomp!
    end

    private
    ###########################################################################
    #
    # @function receive_message
    #
    # Receive an entire message using the established connection.
    #
    # @param [Integer] read_length Maximal amount of bytes to read at once.
    #
    # @return [String] A message.
    #
    # @raise [] If a connection has not been established prior to calling this
    #           method an exception is thrown.
    #
    ###########################################################################
    def self.receive_message( read_length = 64 )
        raise 'WISCEBridge connection not established.' if nil == @socket
        previous_length = 0
        message = ''
        loop do
            previous_length = message.length
            message += @socket.recv read_length
            break if message.length - previous_length < read_length
        end
        message
    end

    ###########################################################################
    #
    # @function send_arbitrary_command
    #
    # Sends an arbitrary command through the established connection.
    #
    # @param [String] command Command to send.
    #
    # @return [String] A reply from the server.
    #
    # @raise [] If a connection has not been established prior to calling this
    #           method an exception is thrown.
    #
    ###########################################################################
    def self.send_arbitrary_command( command )
        raise 'WISCEBridge connection not established.' if nil == @socket
        @socket.puts command
        receive_message
    end

    ###########################################################################
    #
    # @function parse_revision
    #
    # Parses revision returned by WISCEBridge™.
    #
    # @param [String] revision A revision string consisting of 8 characters
    #                          formatted as follows - xxMMmmpp - xx is expected
    #                          not to carry information, MM specifies the major
    #                          version, mm specifies the minor version and pp
    #                          indicates the patch. All the values are expected
    #                          to be given in hex.
    #
    # @return [String] A revision string formatted as follows -
    #                  major.minor.patch - or 'invalid revision'.
    #
    ###########################################################################
    def self.parse_revision( revision )
        rev_string = ''
        if 8 == revision.length
            major = revision[2..3]
            minor = revision[4..5]
            patch = revision[6..7]
            rev_string = "#{major.hex.to_i}.#{minor.hex.to_i}.#{patch.hex.to_i}"
        else
            rev_string = 'invalid revision'
        end
        rev_string
    end

    ###########################################################################
    #
    # @function get_dsp_data_memory_base_address
    #
    # Retrieves a data memory base address configured for a given core id.
    #
    # @param [Integer] dsp_core_id DSP core id (e.g. 0 for DSP1).
    #
    # @return [Integer] Base address of the data memory on the given core.
    #
    # @raise [] An exception is thrown if no base address for a DSP with the
    #           given id has been supplied in the configuration.
    #
    ###########################################################################
    def self.get_dsp_data_memory_base_address( dsp_core_id )
        dsp_name = "DSP#{dsp_core_id + 1}"
        data_memory_base = DSPMemoryBaseAddresses[dsp_name]
        if data_memory_base.nil?
            raise 'No data memory base address configured for given DSP core id.'
        end
        data_memory_base = DSPMemoryBaseAddresses[dsp_name]['XM']
        if data_memory_base.nil?
            raise 'No data memory base address configured for given DSP core id.'
        end
        data_memory_base.to_s.hex
    end

    ###########################################################################
    #
    # @function get_dsp_control_address
    #
    # Retrieves the address of a register containing DSP controls configured
    # for a given core id.
    #
    # @param [Integer] dsp_core_id DSP core id (e.g. 0 for DSP1).
    #
    # @return [Integer] Base address of the firmware header on the given core.
    #
    # @raise [] An exception is thrown if no DSP control address for a DSP with
    #           the given id has been configured.
    #
    ###########################################################################
    def self.get_dsp_control_address( dsp_core_id )
        dsp_control_address = DSPControlAddresses["DSP#{dsp_core_id + 1}"]
        if dsp_control_address.nil?
            raise 'No DSP control address configured for given DSP core id.'
        end
        dsp_control_address.to_s.hex
    end
end
##############################END OF FILE######################################