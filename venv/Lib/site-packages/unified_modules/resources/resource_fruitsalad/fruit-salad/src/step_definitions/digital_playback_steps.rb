###############################################################################
###
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file digital_playback_steps.rb
### @brief cucumber steps definition for digital playback testcase
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

require 'logfw'

#################################################################################
#
# @!method Given_I_am_connected_to_a_device
#
# Verify that a device is connected and available for fruit salad testing.
#
#       Usage:
#       Given I am connected to a device
#
#################################################################################
Given( /^I am connected to a device$/ ) do
    raise( "Device not connected." ) unless FruitSalad.get_device().device_connected?
end

###############################################################################
#
# @!method Given_signal_lead_in
#
# Set a lead-in delay to be applied to all playback.
#
#       Usage:
#       Given <time> seconds of lead in
#
# @example Given 5 seconds of lead in
#
###############################################################################
Given( /^(#{Number}) seconds? of lead[\-\s]?in$/ ) do |lead_in|
    @lead_in = lead_in
end

###############################################################################
#
# @!method Given_signal_lead_out
#
# Set a lead-out delay to be applied to all playback.
#
#       Usage:
#       Given 5 seconds of lead out
#
# @example Given 5 seconds of lead out
#
###############################################################################
Given( /^(#{Number}) seconds? of lead[\-\s]?out$/ ) do |lead_out|
    @lead_out = lead_out
end

#################################################################################
#
# @!method Given_I_am_recording_the_output
#
# Begin capturing the output, either in software or by a heath-robinson style
# hardware set-up.
#
#       Usage:
#       Given I am recording the output
#
#################################################################################
Given( /^I am recording the output$/ ) do
    FruitSalad.get_device().record_output()
end

#################################################################################
#
# @!method When_I_chop_off_seconds_at_a_random_place_of
#
# Chop off the given input for the given length and return the file path and its
# start point.
#
#       Usage:
#       When I chop off 3 seconds at a random place of "resources/test.wav"
#
# @param [String]   file       The name of the input file to copy
# @param [Integer]  out_duration   Seconds to chop from the given stream
#
# @note As the filename will change for different runs the path to the output
#       file set as global.
#
#################################################################################
When( /^I chop off "(.*?)" seconds at a random place of "(.*?)"$/ ) do | out_duration, file |
    FruitSaladUtils::chop_at_random_location(
                     file,
                     out_duration:out_duration.to_f
                    )
end

###############################################################################
#
# @!method Then_the_output_is_of_length_seconds
#
# Matches the length of the given chopped file against given length in seconds.
#
#       Usage:
#       Then the output is of length 3 seconds
#
# @param [String]   chopped_file       The name of the chopped file.
# @param [Integer]  out_duration   Seconds to chop from the given stream
#
# @note The path of the chopped file is taken from 'tmp' folder.
#
###############################################################################
Then( /^the "(.*?)" is of length "(.*?)" seconds$/ ) do | chopped_file, out_duration |
    info = WaveFile::Reader.info( chopped_file )
    duration = info.sample_frame_count.to_f / info.sample_rate
    if duration.to_f != out_duration.to_f
        raise "The chopped length #{duration} is not matching with given length #{out_duration}"
    end
end

#################################################################################
#
# @!method When_I_play_the_audio_file
#
# Initiate playback of a file by name. If third party playback is enabled you may
# optionally specify what program to use (Windows Media Player or Metro).
#
#       Usage:
#       When I play the audio file "<filepath>"
#       When I play the audio file "<filepath>" using wmp
#       When I play the audio file "<filepath>" using metro
#       When I play the audio file "<filepath>" using portaudio
#
# @param filepath       The file to play. This may be relative to the current
#                       working directory or an absolute path. Currently
#                       supports non-wav files only if using a Windows test target
#                       and Windows_UseThirdPartyPlayback is set to true.
# @param app_identifier The program to use to play the media file. This is one of
#                       'wmp', 'metro' or portaudio. Optional.
#
#################################################################################
When( /^I play the (?:(.*?) channel )?audio file "(.*?)"(?: using (wmp|metro|portaudio))?$/ ) do | channels, file, app_identifier|
    unless @lead_in.nil? and @lead_out.nil?
        file = FruitSaladUtils::pad_with_lead_in_lead_out( file, @lead_in.to_f, @lead_out.to_f )
    end

    playback_options = { channels: channels,
                         program: app_identifier
                       }.keep_if{ |_,a| !a.nil? }

    FruitSalad.get_device().playback( file, playback_options )
end

#################################################################################
#
# @!method Then_the_output_matches_the_audio_file
#
# Checks that the captured output matches the given audio file. This uses the
# comparison defined by the FruitSalad fixture to determine whether the files
# qualify as a close enough match.
#
# For debugging purposes it also accepts a negated version of itself, although
# this may give false-positives as the similarity measure is intended to be a
# necessary, rather than sufficient property.
#
#       Usage - one of:
#       Then the output matches the audio file "<filepath>"
#       Then the output doesn't match the audio file "<filepath>"
#
# @param filepath Audio file to compare against
#
# @example Then the output matches the audio file "example.wav"
# @example Then the output doesn't match the audio file "counterexample.wav"
#
#################################################################################
Then( /^the output( doesn't)? matche?s? (?:the )?audio file "(.*)"$/ ) do |under_negation,file|
    under_negation = (/ doesn't/ =~ under_negation)
    FruitSalad.get_device().end_capture()
    are_similar = FruitSalad.files_similar?( file, FruitSalad.get_device().output )
    if not are_similar and not under_negation
        similarity = FruitSalad.simple_similarity_measure( file, FruitSalad.get_device().output )
        raise( "Files are not similar, similarity only #{similarity}." )
    elsif are_similar and under_negation
        similarity = FruitSalad.simple_similarity_measure( file, FruitSalad.get_device().output )
        raise( "Files should not be similar, similarity is #{similarity}." )
    end
end

###############################################################################
#
# @!method Then_the_output_was_silence
#
# Determine whether the captured output represents silence by asserting that
# every sample amplitude is less than the dB value of config variable
# Analyzer_RecordingSilenceThreshold
#
#       Usage:
#       Then the output was silence
#       Then the output was not silence
#       Then the recording matches silence
#       Then the recording matches the silence
#       Then the recording matches not silence
#
###############################################################################
Then( /^the (?:recording|output) (?:was|matches) (?:the )?(not )?silence$/ ) do |under_negation|
    under_negation = (/not / =~ under_negation)
    device = FruitSalad::get_device
    device.end_capture

    if under_negation
        raise 'Captured output was silent.' \
            if FruitSalad::is_silence? device.output
    else
        raise 'Captured output was not silent.' \
            unless FruitSalad::is_silence? device.output
    end
end

###############################################################################
#
# @!method Then_the_output_has_no_phase_difference_between_channels
#
# Determine whether the captured output has any phase difference between channels
# comparing the phases of two channels at peak frequency.
#
#       Usage:
#       Then the output has no phase difference between channels
#
###############################################################################
Then( /^the output has no phase difference between channels$/ ) do
    device = FruitSalad::get_device
    device.end_capture
    delta_phase = FruitSalad.find_phase_diff?( device.output )
    $LOG.debug "The delta phase is #{delta_phase}"
    if( delta_phase > 0.07 ) #approx 4 degrees
        raise "Captured output has high phase difference between the channels and the phase difference is #{delta_phase}"
    end
end

#################################### END OF FILE  #############################