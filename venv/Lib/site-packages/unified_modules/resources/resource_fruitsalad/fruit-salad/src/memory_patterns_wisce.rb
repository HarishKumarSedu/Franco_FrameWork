#!/usr/bin/ruby
################################################################################
### Copyright (c) 2016 Cirrus Logic International (UK) Ltd.
###                    All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any errors
### or inaccuracies that may appear in this document or any software that may be
### provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   memory_patterns_wisce.rb
### @brief  Create memory patterns that for initialising DSP memory sections.
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
################################################################################

require 'fileutils'
require 'logfw'
################################################################################
# Generator for creating memory patterns across the various DSP memories for
# a given chip.
#
# Currently using a workaround as SetBlockValues doesn't work through the COM
# API - but loading block write profiles does.
################################################################################
class MemoryPatternGenerator
    ############################################################################
    # Attributes
    ############################################################################

    # protocol to be used in the profile script for block writes
    attr_accessor :protocol

    # Constants
    MAX_CHUNK = 1024
    REGISTER_SIZE = 4 # In terms of bytes
    WORD_MASK = 0xFFFFFF
    WORDS_PER_LINE = 8
    BYTES_PER_WORD = 3
    ############################################################################
    #
    # @function initialize
    #
    # Default constructor.
    #
    # @param [String]   protocol           Name of the protocol to be use
    # @param [Integer]  device_address     Device address to write to.
    # @param [String]   output_dir         path of the directory to create
    # @param [Array]    device_dsp_data    nested data array containing DSP addresses
    #
    ############################################################################
    def initialize( protocol, device_address, output_dir = '.', device_dsp_data = [] )
        # Protocol to use in the generated profiles
        @protocol = protocol
        @device_address = device_address
        @output_dir = output_dir
        @device_dsp_data = device_dsp_data

        unless Dir.exists?( @output_dir )
            set_output_directory(@output_dir)
        end
    end

    ############################################################################
    #
    # @function set_output_directory
    #
    # Setter for the output directory that checks existence, creating if it does
    # not already exist.
    #
    # @param [String] dir_name Directory name/path to output location.
    #
    # @raise Directory creation may fail if the parent directories in the path
    #        also do not exist.
    #
    ############################################################################
    def set_output_directory( dir_name )
        unless Dir.exists?( dir_name )
            FileUtils.mkdir( dir_name )
        end

        @output_dir = dir_name
    end

    ############################################################################
    #
    # @function extract_dsp_data
    #
    # Extract and check the data for a DSP core of the given name from the
    # configuration data provided during initialisation.
    #
    # @param [String] dsp_name dsp core to extract the data
    #
    # @raise if there is no matching dsp content available
    # @raise if found content could be malformed.
    #
    ############################################################################
    def extract_dsp_data( dsp_name )
        found_element = nil
        malformed = false
        @device_dsp_data.each do |element|
            if !element.is_a? Hash
                malformed = true
                break
            end

            if element['name'] == dsp_name
                found_element = element
                malformed = malformed_dsp_data?( found_element )
            end
        end

        unless found_element
            raise $LOG.error( 'No matching DSP core data available' )
        end

        if malformed
            raise $LOG.error( 'Provided DSP core data malformed, check configuration data' )
        end

        return found_element
    end

    ############################################################################
    #
    # @function malformed_dsp_data?
    #
    # Check a given data element for well-formed DSP core data.
    #
    # @param [Hash] element  Data hash element of core data to check.
    #
    ############################################################################
    def malformed_dsp_data?( element )
        #SM is only for DSP2 and DSP3
        if ( element['name'] == 'DSP2' || element['name'] == 'DSP3' )
            memory_regions_size = 4
            memory_type_match = '[ZXYS]M'
        else
            memory_regions_size = 3
            memory_type_match = '[ZXY]M'
        end

        # Must have Memory and Name keys
        unless element.has_key?( 'memory' ) and element.has_key?( 'name' )
            return true
        end

        # Memory should be an array with 3 sub-hashes
        memory_regions = element['memory']
        unless memory_regions.is_a? Array and memory_regions.size == memory_regions_size
            return true
        end

        # Check the memory sub-hash of regions for their type and offsets.
        memory_regions.each do |region|
            unless region.is_a? Hash
                return true
            end
            region.each do |key, value|
                case key
                    when 'region'
                        unless value.is_a? String and value.match( /#{memory_type_match}/i )
                            return true
                        end
                    when 'end', 'start'
                        unless value.is_a? Integer
                            return true
                        end
                    else
                        # mismatched key
                        return true
                end
            end
        end

        # only if all checks pass is the element good
        return false
    end

    ############################################################################
    #
    # @function create_wisce_memory_pattern
    #
    # Creates a WISCE text file containing a block write to create an image in
    # memory for testing.
    #
    # Default pattern to be written will simply increment upwards until the
    # block number of bytes/words have been written.
    #
    # @note Only the valid (24-bit) section of the word will be written (the
    # highest byte will be left set at zero). For example the first two words:
    # 00010203 00040506
    #
    # @param [String]  file_name        File name to be written (without
    #                                   extension).
    # @param [Integer]  write_address   Base memory address to write to.
    # @param [Integer]  device_address  Device address to write to.
    # @param [Integer]  words           Number of (24-bit) words to write out
    # @param [Integer]  fixed_value     The value word to initialise memory_patterns
    #                                   (leave as nil for an modifying pattern)
    # @raise if the file not found provided by the method
    #
    ############################################################################
    def create_wisce_memory_pattern( file_name, write_address, device_address,
                                     words, fixed_value = nil
                                   )
        new_file = File.join( @output_dir, file_name + '.txt' )
        begin
            file = File.open( new_file, 'w' )
        rescue
            raise $LOG.error( 'File can not be opened' )
        end

        max_chunk = MAX_CHUNK
        while ( words > 0 )
            chunk = words
            if ( chunk > max_chunk )
                chunk = max_chunk
            end

            header = "BLOCK_WRITE 0x#{write_address.to_s( 16 )} #{@protocol} "     \
                     "0x#{device_address.to_s( 16 )}"
            write_mem_pattern( file, header, fixed_value, chunk )

            words -= chunk
            write_address += chunk*2
        end

        file.close
    end

    ############################################################################
    #
    # @function write_mem_pattern
    #
    # Writes a memory pattern into a file.
    #
    # @param [File]    file        File object to be written to.
    # @param [String]  header      The write header string to use.
    # @param [Fixnum]  fixed_value A fixed value to output (or nil if otherwise)
    # @param [Integer]  words      Number of (24-bit) words to write out
    # @param [Integer]  start      Number from which to start the increment
    #
    ############################################################################
    def write_mem_pattern( file, header, fixed_value, words, start = 1 )
        words_per_line = WORDS_PER_LINE
        bytes_per_word = BYTES_PER_WORD
        word_mask      = WORD_MASK

        file.puts header
        words.times do |i|
            # first byte is always to remain zero for a 24-bit word.
            file.printf( '00' )
            if fixed_value.nil?
                bytes_per_word.times do |offset|
                    # incrementing each byte - wrapping around 8bits (256)
                    value = ( i * bytes_per_word + offset + start ) % 256
                    file.printf( '%02X', value )
                end
            else
                value = fixed_value & word_mask
                file.printf( '%06X', value )
            end

            # Create a newline or space out the words for easier reading.
            unless ( ( 0 == ( i+1 ) % ( words_per_line ) ) ) or \
                ( i == words - 1 )
                file.printf( ' ' )
            else
                file.puts
            end
        end
        file.puts 'END'
    end

    ############################################################################
    #
    # @function concat_patterns
    #
    # Create a single pattern initialisation file from an array of profiles.
    #
    # @param [String]  file_name    File name to write to.
    # @param [Array]   input_files  Array of files to use as input.
    # @raise if the file not found provided by the method
    #
    ############################################################################
    def concat_patterns( file_name, input_files )
        new_file = File.join( @output_dir, file_name )
        begin
            file = File.open( new_file, 'w' )
        rescue
            raise $LOG.error( 'File can not be opened' )
        end
        input_files.each do |input|
            input_path = File.join( @output_dir, input )
            pattern_write = File.open( input_path, 'r' ){|p| p.readlines}
            file.puts pattern_write
        end
        file.close
    end

    ############################################################################
    #
    # @function create_mem_pattern
    #
    # Helper method for writing memory patterns (names, and sets addresses).
    #
    # @param [String]  dsp_core      The core to generate for (e.g. DSP1).
    # @param [String]  region        The region to generate for.
    # @param [String]  pattern       The pattern to use.
    #
    # @return [String]  name of the output file created.
    #
    # @raise if there is no matching dsp content available
    # @raise if found content could be malformed.
    # @raise if requested core region unavailable from provided core data.
    #
    ############################################################################
    def create_mem_pattern( dsp_core, region, pattern )
        pattern_value =  pattern.to_i
        core_data = extract_dsp_data( dsp_core )

        base_addr, word_count = extract_addr_word_count( core_data, region )

        if pattern_value.is_a? Integer
            pattern_string = pattern_value.to_s(16)
        else
            pattern_string = pattern_value.to_s
        end

        out_name = "#{dsp_core.downcase}_#{region}_init_#{pattern_string}"
        create_wisce_memory_pattern( out_name,
                                     base_addr,
                                     @device_address,
                                     word_count,
                                     pattern_value
                                   )

        return out_name + '.txt'
    end

    ############################################################################
    #
    # @function extract_addr_word_count
    #
    # Extract a base address and word count from the DSP core data.
    #
    # @param [Hash]   core_data   DSP core information with region addresses.
    # @param [String] memory_type Memory region to extract the address and word
    #                             count.
    #
    # @return [Integer]  Base address of the requested region.
    # @return [Integer]  Word count of the requested region.
    #
    # @raise if requested core region unavailable from provided core data.
    #
    ############################################################################
    def extract_addr_word_count( core_data, memory_type )
        target_region = nil
        regions = core_data['memory']
        regions.each do |region|
            if region['region'] == memory_type
                target_region = region
                break
            end
        end

        unless target_region
            raise $LOG.error( 'Requested memory region not found in provided core data' )
        end

        base_addr = target_region['start']
        end_addr  = target_region['end']
        word_count = (end_addr - base_addr) / 2 + 1

        return base_addr, word_count
    end

    ############################################################################
    #
    # @function create_mem_patterns
    #
    # Create a pattern for each of the memory regions on a given DSP. Optionally
    # concat all of the patters into a single file for initialisation.
    #
    # @param [String]  dsp_core     DSP core to generate for.
    # @param [String]  pattern      The pattern to generate.
    # @param [String]  concat_file  If present, generate a concatenated file.
    #
    # @raise if pattern string is unrecognised
    #
    ############################################################################
    def create_mem_patterns( dsp_core, pattern, concat_file )
        if (dsp_core == 'DSP2' || dsp_core == 'DSP3')
          memory_regions = ['XM', 'SM', 'YM', 'ZM']
        else
          memory_regions = ['XM', 'YM', 'ZM']
        end
        pattern_files = []
        memory_regions.each do |memory_type|
            name = create_mem_pattern( dsp_core, memory_type, pattern )
            pattern_files << name
        end

        if concat_file
            concat_patterns( concat_file, pattern_files )
        end
        status = (pattern_files == nil) ? false : true
      return status
    end

    ############################################################################
    #
    # @function check_memory
    #
    # Helper method for confirming that a memory region has been initialised.
    #
    # @param  [WisceSalad]  wisce    WISCEâ„¢ instance for reading device data.
    # @param  [String]      expected_pattern  Pattern string identifier to check for.
    # @param  [String]      core     DSP core to check (e.g. DSP1).
    # @param  [String]      region   region to check (e.g. XM).
    # @param  [Array]       chunks   chunk start address and end address
    #
    # @raise if requested core region unavailable from provided core data.
    # @raise if pattern string is unrecognised
    #
    ############################################################################
    def check_memory( wisce, expected_pattern, core, region, chunks = [] )
        read_from_device = true
        core_data = extract_dsp_data( core )
        base_addr, word_count = extract_addr_word_count( core_data, region )
        max_chunk = MAX_CHUNK
        word_counter = 0
        failed_words = 0
        skipped_words = 0
        numRegisters = 2
        registerSizeInBytes = REGISTER_SIZE
        while ( word_count > 0 )
            chunk = word_count
            if ( chunk > max_chunk )
                chunk = max_chunk
            end
            bytes_to_read = chunk * registerSizeInBytes
            data_array = wisce.read_block_data( base_addr,
                                                bytes_to_read,
                                                read_from_device
            )
            word = 0
            current_address = base_addr

            data_array.each_with_index do |byte, index|
                word = (word << 8) + byte
                if index != 0 and 0 == (index+1) % registerSizeInBytes
                    inside_chunk = false
                    current_address += 1

                    # Skip if current address is in the range of Chunk_start and Chunk_End addresses
                    if ( chunks.length > 0 )
                        chunks.each do |chunk|
                            if ( chunk['start'] != nil && chunk['end'] != nil) &&
                                ((chunk['start']..chunk['end']).include?(current_address.to_s(16)))
                                inside_chunk = true
                                break
                            end
                        end
                    end
                    # Skip comparison when current address falls in the chunk
                    unless inside_chunk
                        if ( expected_pattern != word )
                            failed_words += 1
                            $LOG.debug("#{core} #{region}: At location #{current_address.to_s(16)} - \n
                            word: #{word.to_s(16)} is not matched wth the pattern: #{expected_pattern.to_s(16)} ")
                        end
                    else
                        skipped_words += 1
                    end

                    word = 0
                    word_counter += 1
                end
            end #-- end of data array

            word_count -= chunk
            base_addr += chunk*numRegisters
        end #--- end of while loop for word_count

        $LOG.debug("#{core}:#{region} Words checked: #{word_counter}, failed: #{failed_words}, skipped: #{skipped_words}")
        return failed_words
    end

end