################################################################################
##
## Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
##
## This software as well as any related documentation is furnished under
## license and may only be used or copied in accordance with the terms of the
## license. The information in this file is furnished for informational use
## only, is subject to change without notice, and should not be construed as
## a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
## (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
## that may appear in this document or any software that may be provided in
## association with this document.
##
## Except as permitted by such license, no part of this document may be
## reproduced, stored in a retrieval system, or transmitted in any form or by
## any means without the express written consent of Cirrus Logic International
## (UK) Ltd or affiliated companies.
##
### @file   tone_generator.rb
### @brief  Generate a .wav files describing simple waveforms with specfied properties.
###
### @version \$Id: tone_generator.rb 1010 2015-04-27 09:25:59Z emmas $
###
### @warning
###   This software is specifically written for Cirrus Logic devices.
###   It may not be used with other devices.
###
#################################################################################

require "configuration"

require "wavefile"
require 'matrix'

###############################################################################
#
# Module mixin for FruitSalad platform implementation which encapsulates
# functions for the generation of .wav files that describe waveforms with
# well defined properties: i.e. sine waves or MLS white noise.
#
###############################################################################
module ToneGenerator

    include Math

    # The sample rate to use for all generated waveforms.
    SampleRate = Conf.property( :SampleRate, nil )
    # The number of channels of audio to playback with. Set with the
    # :Playback_Channels key.
    Channels = Conf.property( :Playback_Channels, nil )
    # White Noise MLS, minimum number of bit-registers to use to generate
    # a sequence.
    WhiteNoiseMLSMinimumRegisters = 20
    # Magic number for the base of the logarithm to work out what the nearest
    # power of 2 is.
    Base2 = 2
    # Minimal order of MLS
    MLSMinOrder = 2
    # Maximal supported order for MLS generation
    MLSMaxOrder = 24
    # BitDepth supported
    Bitdepth = Conf.property( :Bitdepth, 16 )

    ###########################################################################
    #
    # Generate a sinewave with a specific frequency and write it to a temporary
    # file.
    #
    # @param [Float]   frequency The frequency of the wave in Hz.
    # @param [Integer] length    The length of the waveform in seconds.
    # @param [Hash]    opts      Optional generate_sinewave arguments. This
    #                            supports: [Float] amplitude - specifies the
    #                            amplitude level of sine tone (defaults to 1).
    #                            [Integer] channels - specified number of
    #                            channels for the sine tone.
    #
    # @return [String] The filename of the temporary file.
    #
    ###########################################################################
    def generate_sinewave( frequency, length, opts = {} )
        amplitude = opts.fetch( :amplitude, 1 )
        channels = opts.fetch( :channels, nil )
        channels = Channels if channels == nil

        unless Dir::exist?( "tmp" )
            Dir::mkdir( "tmp" )
        end
        unless( 1 == amplitude )
            filename = File.join( "tmp", "GeneratedTone_#{frequency}Hz_#{length}s_#{amplitude}amplitude.wav" )
        else
            filename = File.join( "tmp", "GeneratedTone_#{frequency}Hz_#{length}s.wav" )
        end
        waveform = []

        frequency = frequency.to_f
        length = length.to_i

        (1..(SampleRate*length) ).each do |i|
            sample = amplitude * sin( 2*PI * i * frequency / SampleRate )
            subarray = Array.new( channels, sample )
            waveform << subarray
        end

        write_waveform( filename, waveform )
        return filename
    end

    ###########################################################################
    #
    # @function mix_sinewaves_by_channel
    #
    # Create a multichannel signal comprised of different sinewaves being played to
    # different channels from an Array of ordered [frequency, channel] pairs.
    #
    # @param [Array<Array<Fixnum>>] list        List of frequency(in Hz),channel ordered pairs
    # @param [Fixnum]               duration    The duration of the output
    #
    # @return [String] The filename of the output recording
    #
    ###########################################################################
    def mix_sinewaves_by_channel( list, duration )
        filename = File.join( "tmp", "mixed_sinewaves.wav" )
        list.map! do |frequency, channel, amplitude = 1|
            sine = generate_sinewave( frequency, duration, amplitude: amplitude )
            samples = FruitSaladUtils::read_wavefile( sine, SampleRate )
            samples.map! { |a| a[0] } # Take only first channel
            [samples, channel]
        end

        # Create null track for silent tracks
        signal_length = list[0][0].size
        null_track = Array.new( signal_length, 0 )

        # Sort and insert null channels
        sorted_by_channel = []
        list.each do |samples, channel|
            while channel > sorted_by_channel.size
                sorted_by_channel << null_track
            end
            sorted_by_channel[channel] = samples
        end

        # [[1,2,...],[A,B,...],...] => [[1,A,...],[2,B,...],...]
        output_data = Matrix[ *sorted_by_channel ].transpose.to_a

        # Write to disk
        write_waveform( filename, output_data )
        return filename
    end

    ###########################################################################
    #
    # Write an array of samples to disk as a .wav file.
    #
    # @param [String] filename The name of the file to write.
    # @param [Array]  waveform An array of samples describing the waveform.
    #
    ###########################################################################
    def write_waveform( filename, waveform )
        channels = 1
        if waveform[0].is_a? Array
            channels = waveform[0].length
        end

        buffer = WaveFile::Buffer.new( waveform, WaveFile::Format.new( channels, :float, SampleRate ) )
        WaveFile::Writer.new( filename, WaveFile::Format.new( channels, Bitdepth, SampleRate ) ) do |writer|
            writer.write( buffer )
        end
    end

    ###########################################################################
    #
    # Create a Maximum Length Sequence.
    #
    #
    # @param [Integer] length The length of the MLS.
    #
    ###########################################################################
    def mls( length )
        mls = Enumerator.new do |yielder|
            # Initialise MLS registers with vector [1,1,...,1]
            mls_registers = Array.new( length, 1 )
            loop do
                # Yield the register at register[0]
                yielder << mls_registers[0]
                # Shift registers
                mls_registers = mls_registers.drop( 1 )
                # Append register[0] XOR register[1]
                mls_registers << ( mls_registers[0] ^ mls_registers[1] )
            end
        end
        return mls
    end

    ###########################################################################
    #
    # Generate an MLS White Noise signal and save it to a temporary .wav file.
    #
    # @param [Integer] length The length of the signal in seconds.
    #
    # @return [String] The name of the temporary file used to store the signal.
    #
    ###########################################################################
    def generate_mls_whitenoise( length )
        unless Dir::exist?( "tmp" )
            Dir::mkdir( "tmp" )
        end
        number_of_samples = length * SampleRate
        number_of_registers = log( number_of_samples+1, Base2 ).ceil
        # There was a strange degenerate case where requesting signals of
        # length ~5 seconds would result in a complicated periodic signal
        # rather than white-noise. I'm not entirely sure why this should be
        # the case, but clamping the number of bit-registers seems to solve
        # the issue.
        number_of_registers = [number_of_registers, WhiteNoiseMLSMinimumRegisters].max
        mls = mls( number_of_registers )
        filename = File.join( "tmp", "MLS_WhiteNoise_#{length}seconds.wav" )
        waveform = mls.take( number_of_samples )
        waveform.map! { |x| ( 0 == x ) ? -1: 1 }
        waveform.map! { |x| Array.new( Channels, x ) }
        write_waveform( filename, waveform )
        return filename
    end

    ###########################################################################
    #
    # Create a Maximum Length Sequence given its order.
    #
    # @param [Integer] order The order of the MLS (must be between 2 and 24).
    #
    # @return [Array] An MLS sequence of given order.
    #
    # @raise [] If the order is not between 2 and 24 (inclusive) an exception is
    #        raised.
    #
    ###########################################################################
    def mls_of_order( order )
        unless order.is_a?(Numeric) && order>=2 && order<=24
            raise 'MLS order must be a number between 2 and 24 (inclusive).'
        end

        taps = [ [2,1,1,0,0],  [2,1,3,0,0],  [2,1,4,0,0],  [2,2,5,0,0],
                 [2,1,6,0,0],  [2,1,7,0,0],  [4,2,3,4,8],  [2,4,9,0,0],
                 [2,3,10,0,0], [2,2,11,0,0], [4,1,4,6,12], [4,1,3,4,13],
                 [4,1,3,5,14], [2,1,15,0,0], [4,2,3,5,16], [2,3,17,0,0],
                 [2,7,18,0,0], [4,1,2,5,19], [2,3,20,0,0], [2,2,21,0,0],
                 [2,1,22,0,0], [2,5,23,0,0], [4,1,3,4,24] ]

        buffer_len = 2**order-1
        mls = Array.new( buffer_len, 0 )
        shift_buffer = Array.new( 24, 0)
        shift_buffer[0] = 1
        shift_size = (order-1)

        (0...buffer_len).each do |i|
            # calculate next bit
            if 2==taps[order-2][0]
                xor_bit = shift_buffer[taps[order-2][1]-1] ^
                          shift_buffer[taps[order-2][2]-1]
            else
                xor_bit = ( shift_buffer[taps[order-2][1]-1] ^
                            shift_buffer[taps[order-2][2]-1] ) ^
                          ( shift_buffer[taps[order-2][3]-1] ^
                            shift_buffer[taps[order-2][4]-1] )
            end

            # shift buffer
            (0...shift_size).each do |j|
                shift_buffer[shift_size-j] = shift_buffer[shift_size-1-j]
            end
            shift_buffer[0] = xor_bit

            mls[i] = xor_bit
        end

        mls
    end

    ###########################################################################
    #
    # Generate an MLS White Noise signal of the given order and save it to a
    # temporary .wav file.
    #
    # @param [Integer] order The order of the MLS (must be between 2 and 24).
    #                        Defaults to 17.
    #
    # @return [String] The name of the temporary file used to store the signal.
    #
    # @raise []  If the order is not between 2 and 24 (inclusive) an exception is
    #        raised.
    #
    ###########################################################################
    def generate_mls_of_order( order = 17 )
        unless order.is_a?(Numeric) && order>=MLSMinOrder && order<=MLSMaxOrder
            raise 'MLS order must be a number between 2 and 24 (inclusive).'
        end

        tmp_directory = 'tmp'
        unless Dir::exist?( tmp_directory )
            Dir::mkdir( tmp_directory )
        end
        mls = mls_of_order( order )
        filename = File.join( tmp_directory, "MLS_order_#{order}.wav" )
        waveform = mls*3
        waveform.map! { |x| ( 0 == x ) ? -1.0: 1.0 }
        waveform = waveform+Array.new( waveform.length, 0.0 )
        waveform.map! { |x| Array.new( Channels, x ) }
        write_waveform( filename, waveform )
        return filename
    end
end

########################### END OF FILE #######################################