///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Cirrus Logic International (UK) Ltd. All rights reserved.
//
// This software as well as any related documentation is furnished under
// license and may only be used or copied in accordance with the terms of the
// license. The information in this file is furnished for informational use
// only, is subject to change without notice, and should not be construed as
// a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic International
// (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
// that may appear in this document or any software that may be provided in
// association with this document.
//
// Except as permitted by such license, no part of this document may be
// reproduced, stored in a retrieval system, or transmitted in any form or by
// any means without the express written consent of Cirrus Logic International
// (UK) Ltd or affiliated companies.
//
// @file   decompress.c
// @brief  provides decompression wrapper functionality for FruitSalad.
//
// @warning
//   This software is specifically written for Cirrus Logic devices.
//   It may not be used with other devices.
//
///////////////////////////////////////////////////////////////////////////////

//
// Includes
//
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <errno.h>
#include "decompress.h"
#include "unshorten.h"

//
// Defines
//
#define SCRATCH_BUF_LENGTH 768
#define BYTE_DEPTH 2

#define PCM 1
#define WAVE_HEADER_LENGTH 16
#define RIFF_LENGTH ( WAVE_HEADER_LENGTH + 20 )
#define HEADER_LENGTH 44
#define WAVE_FORMAT_TYPE PCM

///////////////////////////////////////////////////////////////////////////////
///
//  Function: Decompress
///
/// @brief Decompresses the given compressed raw data file and generates
///        decompressed WAV file.
///
/// @param *pInputFile       Input file path.
/// @param *pOutputFile      Output file path.
/// @param sampleRate        Sample rate of the captured stream.
/// @param bitDepth          Bit depth of the captured stream.
/// @param channels          Number of channels.
///
/// @retval FILEOPEN_ERROR   Couldn't open files.
/// @retval ENOMEM           Couldn't allocate memory.
/// @retval EBUSY            Data can't be taken denotes busy.
/// @retval SUCCESS          Success.
///
///////////////////////////////////////////////////////////////////////////////
DECOMPRESS_API DecompressRetCode Decompress( char *pInputFile,
                                             char *pOutputFile,
                                             unsigned int sampleRate,
                                             unsigned char bitDepth,
                                             short channels
                                           )
{
    char *pScratchBuf = NULL;
    unsigned int bytesRead = 0;
    struct unshorten stUnshorten;
    FILE *pInputFileHandle, *pOutputFileHandle;
    DecompressRetCode retValue;

    // Opening files.
    pInputFileHandle = fopen( pInputFile, "rb" );
    // Checking for file open success.
    if( NULL == pInputFileHandle )
    {
        retValue = FILEOPEN_ERROR;
        goto done;
    }

    pOutputFileHandle = fopen( pOutputFile, "wb" );
    if( NULL == pOutputFileHandle )
    {
        retValue = FILEOPEN_ERROR;
        goto error_close_input_file;
    }

    // Allocating memory for scratch buffer.
    pScratchBuf = ( char * ) malloc( SCRATCH_BUF_LENGTH * sizeof( char ) );
    if( NULL == pScratchBuf )
    {
        retValue = NO_MEMORY;
        goto error_close_files;
    }

    // Initializes unshorten process.
    retValue = ( DecompressRetCode )init_unshorten( &stUnshorten );
    if ( SUCCESS != retValue )
    {
        retValue = NO_MEMORY;
        goto error_clean;
    }

    // Performs decompression on the given compressed file.
    while ( !feof( pInputFileHandle ) )
    {
        bytesRead = (u32) fread( pScratchBuf, 1, SCRATCH_BUF_LENGTH, pInputFileHandle);

        retValue = ( DecompressRetCode )unshorten_supply_input( &stUnshorten,
                                                                pScratchBuf,
                                                                bytesRead
                                                              );
        if( SUCCESS != retValue )
        {
            retValue = BUSY;
            break;
        }
        do
        {
            retValue = ( DecompressRetCode )unshorten_process( &stUnshorten );
            if ( retValue & UNSHORTEN_OUTPUT_AVAILABLE )
            {
                u32 size = UNSHORTEN_OUTPUT_SIZE( retValue );
#ifdef INCLUDE_PASSTHRU_DATA
                const Sample *pPassthru = unshorten_extract_passthru( &stUnshorten );
                fwrite( (const char *)pPassthru, size, BYTE_DEPTH, pOutputFileHandle );
#else
                const Sample *pDecoded = unshorten_extract_output( &stUnshorten );
                fwrite( (const char *)pDecoded, size, BYTE_DEPTH, pOutputFileHandle );
#endif
            }
            if ( UNSHORTEN_CORRUPT & retValue )
                break;
        } while ( !( retValue & UNSHORTEN_INPUT_REQUIRED ) );

        if ( UNSHORTEN_CORRUPT & retValue )
        {
            retValue = DATA_CORRUPT;
            break;
        }
    }

    if( ( DATA_CORRUPT == retValue ) || ( BUSY == retValue ) )
        goto error;

    if ( retValue & UNSHORTEN_INPUT_REQUIRED )
        retValue = SUCCESS;

    // Add wave header to the output pcm file
    Add_Wave_Header( pOutputFileHandle, sampleRate, bitDepth, channels );

error:
    // De-initializes unshorten process
    free_unshorten( &stUnshorten );

error_clean:
    if ( NULL != pScratchBuf )
        free( pScratchBuf );

error_close_files:
    fclose( pOutputFileHandle );

error_close_input_file:
    fclose( pInputFileHandle );

done:
    return retValue;
}

///////////////////////////////////////////////////////////////////////////////
///
//  Function: Add_Wave_Header
///
/// @brief Adds WAVE header at the begining of the PCM file.
///
/// @param *pOutputFileHandle  Output file path.
/// @param sampleRate          Sampling rate.
/// @param bitDepth            Number of bits to represent each PCM sample.
/// @param channels            Number of channels.
///
/// @retval none.
///
///////////////////////////////////////////////////////////////////////////////
void Add_Wave_Header( FILE *pOutputFileHandle,
                      unsigned int sampleRate,
                      unsigned char bitDepth,
                      short channels
                    )
{
    unsigned int avgBytesPerSecond = 0, fileSize = 0, dataSize = 0;
    short numberOfBytes = 0, waveFormat = 0;

    numberOfBytes = ( bitDepth * channels ) / 8;
    avgBytesPerSecond = ( sampleRate * channels * bitDepth ) / 8;
    dataSize = RIFF_LENGTH;

    fseek( pOutputFileHandle, 0, SEEK_END );
    fileSize = ftell( pOutputFileHandle );
    if( 0 == fileSize )
    {
        fileSize = HEADER_LENGTH;
    }

    fseek( pOutputFileHandle, 0, SEEK_SET );

    // write RIFF to the file
    fprintf( pOutputFileHandle, "RIFF" );

    // write datasize to the file
    dataSize = fileSize - 8;
    fwrite( &dataSize, 1, sizeof( int ), pOutputFileHandle );

    // write  "WAVEfmt " to the file
    fprintf( pOutputFileHandle, "WAVEfmt " );

    dataSize = WAVE_HEADER_LENGTH;
    // write wave header length to the file
    fwrite( &dataSize, 1, sizeof( int ), pOutputFileHandle );

    waveFormat = WAVE_FORMAT_TYPE;
    // write pcm wave format to the file
    fwrite( &waveFormat, 1, sizeof( short ), pOutputFileHandle );

    //writing number of channels info
    fwrite( &channels, 1, sizeof( short ), pOutputFileHandle );

    // writing sampling frequency to the file
    fwrite( &sampleRate, 1, sizeof( int ), pOutputFileHandle );

    // write average bytes per second
    fwrite( &avgBytesPerSecond, 1, sizeof( int ), pOutputFileHandle );

    //writing number number of bytes per sample
    fwrite( &numberOfBytes, 1, sizeof( short ), pOutputFileHandle );

    //write bits per sample
    fwrite( &bitDepth, 1, sizeof( short ), pOutputFileHandle );

    // write "data" to the file
    fprintf( pOutputFileHandle, "data" );

    // subtract header size
    dataSize = fileSize - HEADER_LENGTH;

    // write file size to the file.
    fwrite( &dataSize, 1, sizeof( int ), pOutputFileHandle );

    return;
}
