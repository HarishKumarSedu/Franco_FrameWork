###############################################################################
###
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd.  All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd.  Cirrus Logic International
### (UK) Ltd assumes no responsibility or liability for any errors or inaccuracies
### that may appear in this document or any software that may be provided in
### association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file   fruitsalad_base.rb
### @brief  Interface which implements dummy methods for all test fixtures used.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################

require 'device_factory'
require 'cucumber/errors'
require 'simulated_noise'
require 'faux_installers'
require 'logfw'
require 'result'

#################################################################################
#
# Basic implementation of Fruit Salad which defines the interface and provides
# default behavior (usually doing nothing).
#
# Inherit from this to implement a platform-specific version, and override the
# functions which need changing for your platform.
#
#################################################################################
module FruitSaladBase

    #############################################################################
    ##
    ## Classes
    ##
    #############################################################################
    #############################################################################
    #
    # Interface reference for all methods currently used by FruitSalad. These can
    # be overloaded by specialisations as needed.
    #
    #############################################################################
    class DeviceInterface

        #########################################################################
        ##
        ## Accessors
        ##
        #########################################################################
        #
        # Algorithm components.
        #
        # SoundClear Control (formerly Ez2Control)
        #
        #######################################################################
        attr_reader :soundclear_control
        #
        # Pass through test firmware.
        #
        #######################################################################
        attr_reader :pass_through

        #########################################################################
        #
        # Trace data logging firmware attribute
        #
        #######################################################################
        attr_reader :trace

        #########################################################################
        #
        # API to read host buffer data for all the firmwares or Algorithms
        #
        #######################################################################
        attr_reader :host_buffer_read

        #######################################################################
        #
        # Model to use for simulating noise on input audio.
        #
        #######################################################################
        attr_accessor :simulated_noise_model

        #########################################################################
        #
        # Getter for the module attribute @output. There is no guarantee this
        # attribute will exist and should only be created if the device has been
        # instructed to capture output for analysis.
        #
        # The exact form of the attribute @output is platform specific and
        # should be chosen according to your choice of analyzer such that method
        # calls of the form
        # FruitSalad::is_silence?( FruitSalad::get_device().output ) are valid.
        #
        # If using the WavefileAnalyzer this should be a string containing the
        # path to a .wav file containing the captured output.
        #
        #########################################################################
        attr_reader :output

        #######################################################################
        #
        # Playback history keeps a log of all audio played by the device.
        #
        # This is data should be in a format such that method calls of the form
        # FruitSalad::is_silence?( FruitSalad::get_device().playback_history.last )
        # are valid.
        #
        #######################################################################
        attr_accessor :playback_history

        #######################################################################
        #
        # Stores a list of default usecases to load as an instance variable to
        # allow for overloading. Should be set by the specialisation's initialize
        # method.
        #
        #######################################################################
        attr_accessor :default_usecases


        # Boolean indicates whether to return error code or not.
        ReturnErrorCodes = Conf.property( :ReturnErrorCodes, true )

        #######################################################################
        #
        # @function time_taken
        #
        # Returns the difference in time between now, and the start of the
        # test Scenario.
        #
        # @return [Float] The time since the start of the test in seconds.
        #
        #######################################################################
        def time_taken
            dt = Time.new.to_f - @start_time.to_f
            return dt
        end

        #########################################################################
        #
        # @function device_connected
        #
        # Returns true iff an audio device is connected
        #
        # @return true
        #
        #########################################################################
        def device_connected?
            true
        end

        #######################################################################
        #
        # @function setup
        #
        # Default initialisation that every implementation should perform every
        # time a test begins.
        #
        # Each target should define per_device_setup to specify any setup specific
        # to that target instead of specialising this method.
        #
        #######################################################################
        def setup
            usecase( :reset )
            usecase( :default )
            @playback_history = []
            @simulated_noise_model = SimulatedNoiseModel.new
            @start_time = Time.new
            per_device_setup
            return
        end

        #######################################################################
        #
        # @function per_device_setup
        #
        # Specialise this method with per-device setup that must be completed
        # before each scenario. It will then be automatically called by the
        # target-independent setup method.
        #
        #######################################################################
        def per_device_setup
            return
        end

        #######################################################################
        #
        # @function usecase_from_file
        #
        # Skips loading usecase scripts as they have no meaning on this dummy
        # device.
        #
        # @param [String, Symbol] name The name of the usecase script the
        #                              feature file is requesting.
        # @param [String] source_path  Optional parameter to read the source
        #                              path of usecase file
        # @param [String] destination_path Optional parameter to read the
        #                              destination path for usecase file
        #
        #######################################################################
        def usecase_from_file( name, source_path = nil, destination_path = nil )
            return # Do nothing.
        end

        ###################################################################
        #
        # @function usecase
        #
        # Switch to the given use case.
        #
        # @note Ensure the location pointed to by UsecasePath contains a
        #       script of the same name, with the '.sh' suffix.
        #
        # @note UsecasePath is a location on the host machine, not the
        #       target.
        #
        # @param [String, symbol] type is the name of the file containing
        #                              the usecase script excluding the .sh
        #                              type suffix.
        #
        ###################################################################
        def usecase( type )
            # Indicate that we have loaded at least one usecase.
            @usecase_loaded = true
            case type
            when :default
                $LOG.debug "Loading default usecases: #{default_usecases}."
                default_usecases.each do |name|
                    usecase( name )
                end
            when :reset
                unless Conf.property( :skip_reset, false )
                    usecase( "Reset_paths" )
                end
                # Indicate that we have 'unloaded' all usecases
                @usecase_loaded = false
            else
                # Load a script.
                usecase_from_file( type )
            end
        end

        #########################################################################
        #
        # @function record_output
        #
        # Begins recording the output. In this implementation it stores the
        # number 0 to indicate that this method has been called at least once.
        #
        #########################################################################
        def record_output()
            @output = 0
        end

        #######################################################################
        #
        # @function record_from_compressed_stream
        #
        # Starts recording from a compressed stream on the remote device.
        #
        # @param [String]  filename         Name of the compressed stream to
        #                                   record
        # @param [Integer] sample_rate      Sample rate of the compressed
        #                                   stream
        # @param [Integer] channels         Channels of the compressed stream
        # @param [String]  destination_path Path to store the recorded
        #                                   compressed stream
        #
        # @return void
        #
        # @raise [Cucumber::Pending] If this method is not implemented for the
        #                            target.
        #
        #######################################################################
        def record_from_compressed_stream( filename,
                                           sample_rate,
                                           channels,
                                           destination_path = nil
                                         )
            raise Cucumber::Pending, 'Compressed stream capture is not ' \
                                     'implemented for this target.'
        end

        #########################################################################
        #
        # @function playback
        #
        # Plays a named audio file.
        #
        # @note While implementing a target-specific version of this method it
        #       is strongly advised to raise a meaningful exception when
        #       unsupported options are provided in order to avoid unexpected
        #       behaviour. To do this you can use validate_options.
        #
        # @param [String] file The name of the file to play.
        # @param [Hash]   opts Optional playback arguments.
        #
        #########################################################################
        def playback( file, opts = {} )
            nil
        end

        #######################################################################
        #
        # @function multitrack_playback
        #
        # Plays multiple mono wav files at once, to different playback device channels.
        #
        # @param [Array<Array>] track_list List of [file name, channel number] pairs.
        #
        # @raise [Cucumber::Pending] If this method is not implemented for the target.
        #
        #######################################################################
        def multitrack_playback( track_list )
            raise Cucumber::Pending, "Multitrack playback not implemented for this target."
        end

        #########################################################################
        #
        # @function end_capture
        #
        # Terminates any ongoing recording.
        #
        #########################################################################
        def end_capture()
            nil
        end

        #######################################################################
        #
        # @function end_compressed_stream_capture
        #
        # Ends an ongoing compressed capture on the remote device, decodes
        # the output and downloads the resulting recording.
        #
        # @param [String] record_file_name Name of the compressed stream to
        #                                  stop
        # @param [String] destination_path Path of the compressed stream stored
        # @param [Integer] download_path   Path of the host PC where to
        #                                  download the compressed stream
        #
        # @return void
        #
        # @raise [Cucumber::Pending] If this method is not implemented for the
        #                            target.
        #
        #######################################################################
        def end_compressed_stream_capture( record_file_name,
                                           destination_path = nil,
                                           download_path = nil
                                         )
            raise Cucumber::Pending, 'Compressed stream capture is not ' \
                                     'implemented for this target.'
        end

        #######################################################################
        #
        # @function end_playback
        #
        # Ends playback immediately or waits until it finishes
        # successfully.
        #
        # @param [Boolean] wait Flag indicating whether the playback should
        #                       be ended immediately, or if execution
        #                       should be blocked until the started
        #                       playback finishes successfully.
        #
        # @return void
        #
        # @raise [Cucumber::Pending] If this method is not implemented for the
        #                            target.
        #
        #######################################################################
        def end_playback( wait = false )
            raise Cucumber::Pending, 'This target does not support explicit playback termination yet.'
        end

        ########################################################################
        #
        # @function timed_cmd
        #
        # Measures how long it takes to perform a proc, and prints a friendly
        # message on entry.
        #
        ########################################################################
        def timed_cmd( message, &a_proc )
            $LOG.debug message
            start_time = Time.new
            a_proc.call
            finish_time = Time.new
            delta = finish_time - start_time
            if delta > 60
                min = ( delta / 60 ).floor
                sec = ( delta % 60 ).round
                delta = "#{min} minutes, #{sec} seconds"
            elsif delta > 10
                delta = "#{delta.round(2)} sec"
            else
                delta = "#{(delta*1e3).round} ms"
            end
            $LOG.debug "Finished in #{delta}."
        end

        #######################################################################
        #
        # Firmware methods
        #
        # Each target implementing firmware functionality should respond to the step_definition call
        #
        # Targets requiring special functionality should reimplement the step_definition method to apply any
        # specialised operations as appropriate.
        #
        #######################################################################

        #######################################################################
        #
        # @function initialize_firmware_components
        #
        # Loads the component objects that encapsulate the high-level functionality
        # for each firmware algorithm supported by this test-target.
        #
        #######################################################################
        def initialize_firmware_components()
            raise Cucumber::Pending, "No firmware components defined for this target."
        end

        #######################################################################
        #
        # @function is_firmware_loaded?
        #
        # Check whether the specified firmware is present on the target device.
        #
        # @param [String] algo_name The name of the algorithm to deploy.
        # @param [Hash]              opts     Firmware Information hash
        # @option opts [String|nil] :version  Version string of the firmware that
        #                                     should be present (nil if unspecified).
        # @option opts [nil|String|Integer] :dsp_core Core Identifier string
        #                                    (e.g. 'DSP2') or integer index (1).
        #
        # @return [Boolean] true if the specified firmware was present, otherwise returns false
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def is_firmware_loaded?( algo_name, opts )
            unsupported 'is_firmware_loaded?'
        end

        #######################################################################
        #
        # @function is_firmware_running?
        #
        # Check whether the specified firmware is running on the target device.
        #
        # @param [String] algo_name The name of the algorithm to deploy.
        # @param [Hash]              opts     Firmware Information hash
        # @option opts [String|nil] :version  Version string of the firmware that
        #                                     should be present (nil if unspecified).
        # @option opts [nil|String|Integer] :dsp_core Core Identifier string
        #                                    (e.g. 'DSP2') or integer index (1).
        #
        # @return [Boolean] true if the specified firmware was running otherwise returns false
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def is_firmware_running?( algo_name, opts )
            unsupported 'is_firmware_running?'
        end

        #######################################################################
        #
        # init_saladmix Initializes saladmix binary with the given file.
        #
        # @param [String] local_file  Name of the file to upload.
        # @param [String] temp_dir    Remote temporary directory.
        #
        #######################################################################
        def init_saladmix( local_file, temp_dir )
            unsupported 'init_saladmix'
        end

        #######################################################################
        #
        # @function load_firmware
        #
        # Installs firmware onto the selected device. This is a dummy implementation
        # that marks this functionality as pending.
        #
        # @param [String] firmware_filename The filename of the firmware to install on the target
        # @param [nil|String|Integer] dsp_core Core Identifier string (e.g. 'DSP2') or integer index (1).
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def load_firmware( firmware_filename, dsp_core )
            unsupported 'load_firmware'
        end

        #######################################################################
        #
        # @function start_firmware
        #
        # Locate and start the core with the requested firmware.
        #
        # @param [String] algo_name The name of the algorithm to deploy.
        # @param [nil|String] revision Revision string of the firmware that should be present.
        # @param [nil|String|Integer] dsp_core Core Identifier string (e.g. 'DSP2') or integer index (1).
        #
        # @return [Boolean] true if WMR_SUCCESS reported, false otherwise.
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def start_firmware( algo_name, revision, dsp_core )
            unsupported 'start_firmware'
        end

        #######################################################################
        #
        # @function read_element_value
        #
        # Default implementation, implement for desired platforms.
        #
        # Reads a given element (register, field) from the device.
        #
        # @param [String] element_name  Name of element (field, register) to read from the device.
        #
        # @return [String] Zero-padded hex representation of the requested element's value.
        # @return [nil] if the requested element could not be found.
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def read_element_value( element_name )
            unsupported 'read_element_value'
        end

        #######################################################################
        #
        # @function get_default_element_value
        #
        # Default implementation, implement for desired platforms.
        #
        # Lookup the default value of a given element (register, field).
        #
        # @param [String] element_name Name of an element (register, field) to get the default value of.
        #
        # @return [String] Zero-padded hex representation of the requested element's default value.
        # @return [nil] if the requested element could not be found.
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def get_default_element_value( element_name )
            unsupported 'get_default_element_value'
        end

        #######################################################################
        #
        # @function set_volume_on_playback_channel
        #
        # Sets the volume on one of the playback channels.
        #
        # @param channel The channel to alter
        # @param volume  The volume it should be set to
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def set_volume_on_playback_channel( channel, volume )
            unsupported 'set_volume_on_playback_channel'
        end

        #######################################################################
        #
        # @function set_volume_on_capture_channel
        #
        # Sets the volume on one of the recording capture channels.
        #
        # @param channel The channel to alter
        # @param volume  The volume it should be set to
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def set_volume_on_capture_channel( channel, volume )
            unsupported 'set_volume_on_capture_channel'
        end

        #######################################################################
        #
        # @function set_all_playback
        #
        # Sets the volume on all playback channels.
        #
        # @param volume The volume it should be set to
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def set_all_playback( volume )
            unsupported 'set_all_playback'
        end

        #######################################################################
        #
        # @function set_all_capture
        #
        # Sets the volume on all recording capture channels.
        #
        # @param volume The volume it should be set to
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def set_all_capture( volume )
            unsupported 'set_all_capture'
        end

        #######################################################################
        #
        # @function suspend_for_duration
        #
        # Places the test target in a suspend-to-memory state and automatically
        # wakes the target after the duration has elapsed.
        #
        # @param duration How long to wait before waking the target
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def suspend_for_duration( duration )
            unsupported 'suspend_for_duration'
        end

        #######################################################################
        #
        # @function hibernate_for_duration
        #
        # Places the test target in a suspend-to-disk state and automatically
        # wakes the target after the duration has elapsed.
        #
        # @param duration How long to wait before waking the target
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def hibernate_for_duration( duration )
            unsupported 'hibernate_for_duration'
        end

        #######################################################################
        #
        # @function connect_jack
        #
        # Simulates the connection of a headset jack.
        #
        # @param [Bool] supports_playback  Does the headset have speakers
        # @param [Bool] supports_recording Does the headset have a microphone
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def connect_jack( supports_playback, supports_recording )
            unsupported 'connect_jack'
        end

        #######################################################################
        #
        # @function disconnect_jack
        #
        # Simulates the removal of any headset jack present.
        #
        # @raise [Cucumber::Pending] Always
        #
        #######################################################################
        def disconnect_jack
            unsupported 'disconnect_jack'
        end

        #######################################################################
        #
        # @function mixer_property
        #
        # Retrieve the status of a firmware mixer control.
        #
        # @param key The name of the mixer control to inspect
        #
        # @return The value of that control
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def mixer_property( key )
            unsupported 'mixer_property'
        end

        #######################################################################
        #
        # @function wake
        #
        # Wake the target's firmware from any power saving state it might be in.
        #
        # (no parameters)
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def wake
            unsupported 'wake'
        end

        #######################################################################
        #
        # @function unsupported
        #
        # Raise a Cucumber::Pending exception with help text that a method is
        # not implemented.
        #
        # @param [String] method_name The name of the method that is not implemented.
        #
        # @raise [Cucumber::Pending] Always.
        #
        #######################################################################
        def unsupported( method_name )
            raise Cucumber::Pending, "#{method_name} is not implemented on this target."
        end

        #######################################################################
        # DSP utility functions
        #######################################################################

        #######################################################################
        #
        # @function extract_dsp_index
        #
        # Converts a dsp_core parameter into an index (if needed).
        # Nil (undefined) cores are passed through.
        #
        # @param [nil|String|Integer] dsp_core Core Identifier string (e.g. 'DSP2') or integer index (1).
        #
        # @return [nil]     passes through nil dsp_cores
        # @return [Integer] Index of the core at index or from string
        #                   identifier DSP<\d+>.
        #
        # @raise If dsp_core identifier string is not of the expected form DSP<\d+>
        #
        #######################################################################
        def extract_dsp_index( dsp_core )
            dsp_index = nil
            if dsp_core.nil?
                # pass through nil (undefined) core
                dsp_index = nil
            elsif dsp_core.is_a? Integer
                # aleady an integer, no further changes necessary.
                dsp_index = dsp_core
            else
                # the /reg_ex/i modifier will make the expression case insensitive.
                md = dsp_core.match(/DSP(\d+)/i)
                if md.nil?
                    raise "Unrecognised DSP name '#{dsp_core}', expected DSP\d+."
                end
                dsp_index = md[1].to_i - 1
            end

            return dsp_index
        end

        #######################################################################
        #
        # @function validate_options
        #
        # Checks a list of keyword argument keys against an list of expected
        # keys and throws an exception if the first list contains entries not
        # present in the second.
        #
        # @param [Array]  opts              Array of option keys passed into
        #                                    a function.
        # @param [Array]  supported_opts    Array of option keys supported by
        #                                    the function.
        # @param [String] error_message_tag A tag to prefix the error message
        #                                    with.
        #
        # @return void
        #
        # @raise [RuntimeError] An exception is thrown if opts contains entries
        #                       not contained in supported_opts.
        #
        #######################################################################
        def validate_options( opts, supported_opts, error_message_tag )
            unsupported_opts = opts - supported_opts
            if 0 != opts.length && 0 != unsupported_opts.length
                error_message = "#{error_message_tag} Unsupported options provided - #{unsupported_opts}"
                if ReturnErrorCodes
                    return InternalError.new(:UNSUPPORTED_ARGUMENTS,
                                               error_message,
                                               Thread.current.backtrace)
                else
                    raise error_message
                end
            end
            return ResultSuccess.new() if ReturnErrorCodes
        end
        ########################################################################
        #
        # @function start_dsp_core
        #
        # @param [Fix_num] core_index   firmware core_index to load
        # @raise if target not found.
        #
        ########################################################################
        def start_dsp_core( core_index )
            raise $LOG.error('start_dsp_core is not implemented on this target.')
        end
        ########################################################################
        #
        # @function stop_dsp_core
        #
        # @param [Fix_num] core_index   firmware core_index to load
        # @raise if target not found
        #
        ########################################################################
        def stop_dsp_core( core_index )
            raise $LOG.error('stop_dsp_core is not implemented on this target.')
        end
        ########################################################################
        #
        # @function read_element_value
        #
        # @param [String]        element_name Name of an element (field,
        #                                     register) to read from.
        # @param [String|Fixnum] value        Value to write to the register
        #                                     (strings can be hex or decimal
        #                                     representation).
        # @raise if target not found
        #
        #######################################################################
        def write_element_value( element_name )
            raise $LOG.error('write_element_value is not implemented on this target.')
        end
        ########################################################################
        #
        # @function get_current_device_name
        #
        # Gives current device name
        #
        # @raise if target not found
        #
        ########################################################################
        def get_current_device_name()
            raise $LOG.error('get_current_device_name is not implemented on this target.')
        end

        ########################################################################
        # @function connect_target_device
        #
        # Establish a connection to the given device on given system.
        #
        # @param [Hash]   opts
        #
        ########################################################################
        def connect_target_device( opts = {} )
            unsupported 'connect_target_device'
        end

        ########################################################################
        #
        # @function playback_completed?
        #
        # Checks if playback is completed.
        #
        # @param [String]     type            Playback type (analog/digital).
        # @param [Boolean]    background    Either playback is in background or foreground.
        #                                        Defaults to false(foreground)
        #
        # @raise playback_completed
        #
        ########################################################################
        def playback_completed?( type = 'analog', background = false )
            unsupported 'playback_completed?'
        end

        ########################################################################
        #
        # @function initialize_pa_multitrack
        #
        # Initializes Pa Multitrack
        #
        # @raise initialize_pa_multitrack
        #
        ########################################################################
        def initialize_pa_multitrack
            unsupported 'initialize_pa_multitrack'
        end
    end
end

##################################### END OF FILE ###############################