###############################################################################
###
### Copyright (c) 2014-2015 Cirrus Logic International (UK) Ltd. All rights reserved.
###
### This software as well as any related documentation is furnished under
### license and may only be used or copied in accordance with the terms of the
### license. The information in this file is furnished for informational use
### only, is subject to change without notice, and should not be construed as
### a commitment by Cirrus Logic International (UK) Ltd. Cirrus Logic
### International (UK) Ltd assumes no responsibility or liability for any
### errors or inaccuracies that may appear in this document or any software
### that may be provided in association with this document.
###
### Except as permitted by such license, no part of this document may be
### reproduced, stored in a retrieval system, or transmitted in any form or by
### any means without the express written consent of Cirrus Logic International
### (UK) Ltd or affiliated companies.
###
### @file soundclear_control_steps.rb
### @brief Step-definitions for the loading of DSP firmware.
###
### @warning
###    This software is specifically written for Cirrus Logic devices.
###    It may not be used with other devices.
###
###############################################################################
require 'src/discontinuity.rb'
require 'wavefile'
require 'waveinfo'
require 'logfw'
include WaveFile

MONO = 1
BUF_SIZE = 1024
###############################################################################
#
# @!method Then_Ez2_Control_triggers
#
# Verify whether Ez2 Control trigger or doesn't.
#
#       Usage:
#       Then Ez2 Control triggers
#       Then Ez2 Control doesn't trigger
#
# @example Then Ez2 Control triggers
# @example Then Ez2 Control doesn't trigger
#
# @raise [RuntimeError] If Ez2 Control doesn't trigger but was supposed to
# @raise [RuntimeError] If Ez2 Control triggers but was specified not to
#
###############################################################################
Then( /^Ez2 Control (?:(doesn't) )?triggers?$/ ) do |negated|
    device = FruitSalad::get_device()
    if negated.nil? && !device.soundclear_control.triggered?
        raise 'Ez2 Control did not trigger'
    elsif !negated.nil? && device.soundclear_control.triggered?
        raise 'Ez2 Control triggered'
    end
end

###############################################################################
#
# @!method Then_Ez2_Control_raises_an_interrupt
#
# Verify whether Ez2 Control raises an interrupt to the host.
#
#       Usage:
#       Then Ez2 Control raises an interrupt
#
# @example Then Ez2 Control raises an interrupt
#
# @raise [RuntimeError] If Ez2 control has not raised any interrupt
#
###############################################################################
Then( /^Ez2 Control raises an interrupt$/ ) do
    device = FruitSalad::get_device()
    status = device.soundclear_control.interrupt_raised
    if ( 0 == status )
        raise 'Ez2 control has not raised any interrupt'
    end
end

###############################################################################
#
# @!method Then_the_time_taken_to_empty_the_active_full_buffer_should_be_less_than_3s
#
# Verify whether the time taken for the host to empty the active full buffer
# within 3s
#
#       Usage:
#       Then the time taken for the host to empty the active full buffer after
#       IRQ has been raised should be less than 3s
#
# @raise [RuntimeError] If time taken to empty the active full buffer is more
#                       than the three seconds
#
###############################################################################
Then( /^the time taken to empty the active full buffer should be less than (\d+)s$/ ) do |max_time|

    max_time = max_time.to_f
    device = FruitSalad::get_device

    if( device.soundclear_control.time_taken > max_time )
        raise 'Time taken to empty the active full buffer is more than 3 seconds'
    end
end

###############################################################################
#
# @!method Given_the_IRQ_status_is_cleared
#
# clearing interrupt bit in irq status register.
#
#       Usage:
#       Given the IRQ status is cleared
#
# @example Given the IRQ status is cleared
#
###############################################################################
Given( /^the IRQ status is cleared$/ ) do
    device = FruitSalad::get_device()
    device.soundclear_control.clear_irq
end

###############################################################################
#
# @!method When_I_play_a_trigger_and_start_recording_from_a_compressed_stream
#
# Play a given trigger file and an optional generated sine tone after it and
# record data from a given type of stream. The given type stream will be opened
# with a given delay relative to the trigger phrase and will be stopped once
# playback is finished.
#
#       Usage:
#       When I play a trigger phrase - <filename>.wav - followed by a
#            <duration> second long <frequency> sine tone and start recording
#            from a compressed stream with a delay of <duration> seconds
#            relative to the trigger
#
# @example When I play a trigger phrase - blue_geenie.wav - followed by a 2
#               second long 440 Hz sine tone and start recording from a
#               compressed stream with a delay of 1 second relative to the
#               trigger
#
# @example When I play a trigger phrase - ok_google.wav - followed by a 4 s
#               1 kHz sine tone and start recording from a compressed stream
#               with a delay of 1 second
#
# @example When I play a trigger phrase - blue_geenie.wav and start recording
#               from a compressed stream and include the trigger phrase with a
#               delay of 1 second relative to the trigger
#
# @example When I play a trigger phrase - ok_google.wav and start recording
#               from an uncompressed stream and exclude the trigger phrase with
#               a delay of 1 second
#
# @raise [RuntimeError] An exception is raised if the recorded output is empty,
#                       as this indicates that SoundClear Control failed to
#                       trigger.
#
###############################################################################
When( /^I play a trigger (?:phrase)? \- (.*\.wav)(?: \- followed by a (#{Number}) s(?:econd)?(?: long)? (#{Frequency}) sine tone(?: of amplitude (#{Number}))?)? and start recording from a (\w+) stream(?: and (\w+) the trigger phrase)? with a delay of (#{Number}) s(?:econds?)? (?:relative to the trigger)?$/ ) do |trigger_file, tone_length, frequency, amplitude, type, action, stream_delay|

    if ( tone_length.nil? || frequency.nil? )
        data_file = nil
    else
        tone_length = tone_length.to_f
        frequency = frequency.to_f

        if amplitude.nil?
            amplitude = 0.4  #Defaulting to 0.4 amplitude range, when it is nil
        else
            amplitude = amplitude.to_f
        end
        data_file = FruitSalad::generate_sinewave( frequency,
                                                   tone_length,
                                                   amplitude: amplitude
                                                 )
    end

    buffer_formats = { stream_delay: stream_delay.to_f,
                       type: type,
                       action: action
                     }.keep_if{ |_,a| !a.nil? }

    device = FruitSalad::get_device

    device.soundclear_control.buffer_test( trigger_file,
                                           data_file,
                                           buffer_formats
                                         )

    raise 'The captured compressed stream output is empty. Most likely cause' \
          '- SoundClear Control failed to trigger.' \
          unless 0 < FruitSalad::track_length( device.output )
end

###############################################################################
#
# @!method When_I_play_a_trigger_followed_by_phrase_and_start_recording_from_a_compressed_stream
#
# Play a given trigger file followed by phrase and record data from a given
# type of stream. The given type stream will be opened with a given delay
# relative to the trigger phrase and will be stopped once playback is finished.
#
#       Usage:
#       When I play a trigger phrase - <filename>.wav - followed by phrase
#            "<filename>.wav" and start recording from a compressed stream
#
# @example When I play a trigger phrase - blue_geenie.wav - followed by phrase
#               "whats_the_weather.wav" and start recording from a compressed
#                stream
#
# @example When I play a trigger phrase - blue_geenie.wav - followed by phrase
#               "whats_the_weather.wav" and start recording from a compressed
#                stream and include the trigger phrase with a delay of 1
#                second relative to the trigger
#
# @example When I play a trigger phrase - blue_geenie.wav - followed by phrase
#               "whats_the_weather.wav" and start recording from a compressed
#               stream and exclude the trigger phrase with a delay of 1
#               second relative to the trigger
#
# @raise [RuntimeError] An exception is raised if the recorded output is empty,
#                       as this indicates that SoundClear Control failed to
#                       trigger.
#
###############################################################################
When( /^I play a trigger (?:phrase)? \- (.*\.wav) \- followed by phrase "(.*\.wav)" and start recording from a (\w+) stream(?: and (\w+) the trigger phrase)? with a delay of (#{Number}) s(?:econds?)?(?: relative to the trigger)?$/ ) do |trigger_file, data_file, type, action, stream_delay|

    buffer_formats = { stream_delay: stream_delay.to_f,
                       type: type,
                       action: action
                     }.keep_if{ |_,a| !a.nil? }

    device = FruitSalad::get_device

    device.soundclear_control.buffer_test( trigger_file,
                                           data_file,
                                           buffer_formats
                                         )

    raise 'The captured compressed stream output is empty. Most likely cause' \
          '- SoundClear Control failed to trigger.' \
          unless 0 < FruitSalad::track_length( device.output )
end

###############################################################################
#
# @!method Then_the_recording_matches_the_input
#
# Determine whether the recorded output matches input by using discontinuity
# detection library
#
# @note The actual implementation of the step was not yet done and there are
#       pending steps for this step and calling of this step raises with
#       cucumber pending
#
#    Usage:
#    Then the recording matches the input
#
# @raise [Cucumber::Pending] Actual implementation of the step was not yet done
#                            so raising cucumber pending
#
###############################################################################
Then( /^the recording matches the input$/ ) do
    raise Cucumber::Pending
end

################################################################################
# @!method Then_the_recording_has_at_least_number_bit_data_width
#
# Checks whether the recording has correct data width
#
# Usage: Then the recording has at least (#{Number})-bit data width
#
# @example  Then the recording has at least 16-bit data width
# @example  Then the recording has at least 8-bit data width
#
# @raise [RuntimeError] An exception is raised if the recording does not have
#                       the correct data width
#
###############################################################################
Then(/^the recording has at least (#{Number})-bit data width$/ ) do |data_width|
    device = FruitSalad::get_device

    #initialisations
    device_id = device.device_id
    file_size = File.size( device.output )
    num_channels = Conf.property( :Recording_channels, 1 )
    firmware = Conf.get_firmware_data( device_id , 0, 'Ez2 Control', nil )
    index = firmware.fetch( "core" )
    index += 1
    sample_rate = device.read_dsp_sample_rate_value( index )
    duration = FruitSalad::track_length( device.output )
    bit_depth_bytes = file_size/( duration * num_channels * sample_rate )
    bit_depth_bits = bit_depth_bytes * 8
    if ( data_width <= bit_depth_bits.to_i )
        $LOG.debug " The recording has atleast #{data_width} bit data width "
    else
        raise " The recording does not have #{data_width} bit data width "
    end
end

###############################################################################
#
# @!method Then_the_output_has_no_discontinuity
#
# Determines whether the captured output has discontinuity.
#
#       Usage:
#       Then the output has no discontinuity
#       Then the SoundClear Control output has no discontinuity
#
###############################################################################
Then( /^the(?: SoundClear Control)? output has no discontinuity$/ ) do
    output_file = FruitSalad::get_device().output
    reference_file = FruitSalad::get_device().trace_output

    output_wave = WaveInfo.new( output_file )

    if( MONO == output_wave.channels )
        reference_file_mono = 'trace_output_mono.wav'
        Writer.new( reference_file_mono, Format.new( output_wave.channels,
                                                     output_wave.bits_per_sample,
                                                     output_wave.sample_rate
                                                   )
                  ) do |monowriter|
            Reader.new( reference_file ).each_buffer( BUF_SIZE ) do |buffer|
                monowriter.write( buffer )
            end
        end
        reference_file = reference_file_mono
    end

    exitCode = NativeDiscontinuity::discontinuity( reference_file, output_file )
    if( :NO_DISCONTINUITY == exitCode )
        $LOG.info 'There is no discontinuity in output'
    end
    if( :DISC_DETECTED == exitCode )
        raise 'Discontinuity detected in output'
    end
end

################################################################################
#
# @!method Then_the_recording_has_frequency_sample_rate
#
# Checks that sample rate is correct .
#
# Usage: Then the recording has <samplingfrequency> sample rate
#
# @example Then the recording has 16 kHz sample rate
#
# @raise [RuntimeError] An exception is raised if the recording does not have
#                       the correct sample rate
#
###############################################################################
Then(/^the recording has (#{Frequency}) sample rate$/) do |sampling_frequency|
    device = FruitSalad::get_device

    #initialisations
    device_id = device.device_id
    actualfreq = nil
    firmware = Conf.get_firmware_data( device_id , 0, 'Ez2 Control', nil )
    index = firmware.fetch( "core" )
    index += 1

    # Accessing the dsp name from the configuration file
    actualfreq = device.read_dsp_sample_rate_value( index )
    if ( actualfreq.to_i == sampling_frequency )
       $LOG.debug "The recording has #{actualfreq.to_i} sample rate"
    else
       raise "The recording does not have #{actualfreq.to_i} sample rate "
    end
end

###############################################################################
#
# @!method When_I_play_a_trigger_along_with_measuring_the_time_taken_to_empty_the_active_full_buffer_after_IRQ_has_raised
#
# Play a given trigger file along with measuring the time taken to empty the
# active full buffer after IRQ has raised
#
#       Usage:
#       When I play a trigger phrase - <filename>.wav along with measuring the
#             time taken to empty the active full buffer after IRQ has raised
#
# @example When I play a trigger phrase - blue_geenie.wav along with measuring
#               the time taken to empty the active full buffer after IRQ has
#               raised
#
###############################################################################
When( /^I play a trigger (?:phrase)? \- (.*\.wav) along with measuring the time taken to empty the active full buffer after IRQ has raised$/ ) do |trigger_file|

    device = FruitSalad::get_device

    device.soundclear_control.measure_time( trigger_file )
end

###############################################################################
#
# @!method When_I_capture_SoundClear_Control_output_to_while_I_play
#
# Calls the steps which are all needed for buffer processing.
#
#       Usage:
#       When I capture 'SoundClear Control' output to "<out_file>" while I play "<in_name>"
#
# @param in_file The name of the file to be processed in buffer test.
# @param out_file The name of the file to be copied from the output buffer.
#
# @example When I capture 'SoundClear Control' output to "fn_of_x" while I play "resources/sweep_2s.wav"
#
###############################################################################
When( /^I capture 'SoundClear Control' output to "(.*)" while I play "(.*)"$/ ) do | out_file, in_file |
     steps %Q{
        When I have "Ez2 Control" running
        And use case "soundclear_control"
        And the IRQ status is cleared
        And I play a trigger phrase - resources/bluegeenie7.wav - followed by phrase "#{in_file}" and start recording from a compressed stream and exclude the trigger phrase with a delay of 1 s
        And copy the captured output to "#{out_file}"
    }
end

#################################### end ########################################