Contributing code to Fruit Salad
================================

All Fruit Salad users are encouraged to modify, extend and improve its code
should such a need arise. Furthermore anyone who decides to do so, can share
their effort by contributing their code into the mainline Fruit Salad
code-base. Making such a contribution is a worthwhile undertaking as thanks
to it Fruit Salad's feature set will naturally grow in line with the needs
of its user community, without duplication of effort. However, in order
for the project not to descend into chaos, we need to impose some guidelines
and rules as to what code we accept into the mainline and what it should look
like. The latter part of this document aims to capture those. Following them
might seem a bit tedious at times, but remember it's all for a good cause.

As a part of Fruit Salad we maintain:

* device abstractions, as well as analysis and utility routines
* step definitions
* __examples__ of feature files, configurations and use cases

General guidelines
------------------

In order to make the process of getting your code into mainline Fruit Salad
as smooth as possible, please adhere to the following guidelines:

1. Stick to the coding style described below.
2. If you are changing anything integral to the Fruit Salad framework
(interfaces, analyses, etc), put your design up for review before implementing
new functionality.
3. Try to make your code cross-target if possible (you do not need to implement
it all but try to keep your APIs generic enough for other developers to use
them).
4. Think twice before deciding on a native extension - if you can find
a cross-platform way of implementing it that will be much better.
5. Commit all code to the main git repository, but put large resources -
binaries, sound files, etc. - in a separate repository.

Coding style
------------

Fruit Salad is written mainly in Ruby, but sometimes extensions in other
languages are needed. For all of those languages we try to maintain
a consistent coding style, but there are bound to be differences stemming from
conventions and idioms specific to the languages we use. Our coding standards
are based on the Cirrus UK Tools team coding style.

__All of the following rules are meant to keep all Fruit Salad code readable,
and in turn easy to maintain and extend.__

### Language agnostic rules ###

1. If you encounter a case not covered by this document make your style
consistent with the file you are working on.

2. Always treat compilation warnings as errors, and enable all compiler
warnings.

3. Use a 4-space indentation style (__do not use tabs__).

4. Try sticking to 80 columns (this is not a strict requirement, but it is nice
to have).

5. When comparing a mutable and immutable binding or value, always put
immutable entity first.

        0 == x

6. Avoid multiple returns in functions.

7. Do not use magic numbers, use symbolic constants. Rather than put numeric
literals in your code, create a sensibly named constant for it and use that.

        WindowSize = 1024     #
                              # correct
        if ( WindowSize < n ) #

        if ( 1024 > n )       # incorrect

8. Naming rules:
    * Use meaningful names (variables, functions, classes, etc.).

            # example: choose a name for a function calculating x*x
            ebebebeb( x ) # NO!
            sq( x )       # going in the right direction, but no
            square( x )   # yes
            function_calculating_square_of_its_argument( x ) # overdoing it

9. Rules regarding spaces:
    * Take care not to insert spurious white-space (trailing spaces, tabs
and spaces on empty lines, etc.) characters in your code.
    * Put spaces after opening bracket, before closing bracket and after each
argument in function calls (but remember that, in ruby, brackets in function
calls are optional).

            foo( 5, 'bar' ) # correct
            foo 5, 'bar'    # correct
            foo(5, 'bar')   # incorrect
    * Put spaces around the assignment operator.

            a = 5 # correct
            a=5   # incorrect
    * Put spaces around arithmetic and comparison operators.

            a < b # correct
            a>b   # incorrect
    * Put spaces between if, while, for, etc. keywords and brackets (note -
in ruby brackets are optional and the preferred style is not to use them).

            if ( foo )   # correct
            while( foo ) # incorrect

10. Alignment rules:
    * When breaking function calls, definitions, etc. over multiple lines,
      align brackets as well as arguments. Also in such cases put one argument
      per line.

            foo( some_long_argument,                           #
                 some_other_long_argument,                     # correct
                 another_argument                              #
               )                                               #

            foo( some_long_argument, some_other_long_argument, #
                 another_argument                              # incorrect
               )                                               #

            foo( some_long_argument,                           #
                 some_other_long_argument,                     # incorrect
                 another_argument )                            #
    * Align line break characters to the 80'th column.

11. Empty line at the beginning and end of multi line comments.

            #
            # Comment spanning
            # multiple lines
            #

### Ruby-specific rules ###

1. Follow template.rb (see `docs/code_templates`).
2. Naming rules:
    * Snake case function and variable naming.

            some_function  # correct
            some_variable  # correct
            someFunction   # incorrect
            SomeVariable   # incorrect
            Some_Variable  # incorrect
    * Pascal cased class, module and constant names.

            ClassName     # correct
            ModuleName    # correct
            ConstantName  # correct
            class_name    # incorrect
            moduleName    # incorrect
            Constant_Name # incorrect
    * Prefer snake cased file names, although pascal case is also acceptable
(if you do not know which to pick, go with what's consistent with already
existing files).
    * Use wild card `_` for unused variables in blocks.

            function_taking_block do |_, _, x|
                n = x**x
                puts n
            end
    * Follow ruby naming conventions regarding ?.

            is_something_true?( something ) # preferable
            is_something_true( something )  # acceptable

3. Use single quotes for strings where possible - use double quotes for strings
which need to be processed by the interpreter, i.e. when using interpolation
or inserting escaped characters.

        'some string'
        "#{x} + #{y} = #{x+y}"
        "some string\nwith new line"

4. Use curly braces only for single line blocks.

        [1, 2, 3].each { |x| puts x } # one line block

        [1, 2, 3].each do |x|         #
            n = x**x                  # multi-line block
            puts n                    #
        end                           #

### Step definition specific rules ###

Step definitions are written in ruby and must follow the coding style outlined
above. With one minor caveat - the documentation comments for step definitions
follow a slightly different format.

### C/C++ specific rules ###

1. Naming rules:
    * Use pascal cased function/method names.

            FunctionName( x )
            MethodName( x )
    * Use hungarian notation for pointers.

            int *pSomeVariable; // correct
            int *someVarable;   // incorrect
    * Use `g_` and `m_` prefixes for global and member variables respectively.

            int g_iAmAGlobalVariable;
            int m_iAmAMemberVariable;
            int *m_pIAmAnotherMemberVariable;

2. Alignment rules:
    * Align `*` and `&` with variable name, rather than type.

            int *pSomeVariable; // correct
            int &someVariable;  // correct
            int* pSomeVarable;  // incorrect
            int& someVariable;  // incorrect
    * Always put curly brackets on a new line and align it with
its corresponding closing bracket.

            int foo( int x )
            {
                if ( x )
                {
                    // code
                }
            }

3. For single line blocks you do not have to use brackets. However, if any
block in an "if" spans multiple lines, or is put in brackets for other
reasons, all of its constituent code blocks should be surrounded by braces.

        if ( condition )                   #
            doSomething();                 # correct
        else                               #
            doSomethingElse();             #

        if ( condition )                   #
        {                                  #
            something = getSomething();    #
            processSomething( something ); #
        }                                  # correct
        else                               #
        {                                  #
            doSomething();                 #
        }                                  #

        if ( condition )                   #
        {                                  #
            something = getSomething();    #
            processSomething( something ); # incorrect
        }                                  #
        else                               #
            doSomething();                 #

Design guidelines
-----------------

### Writing step definitions ###

* __Avoid implementation details in the steps__. The features should
concentrate on the behaviour desired, and not make any assumptions about
how they are implemented.

        Good: When I start the firmware
        Bad: When I set the RUN bit on DSP2

* __Avoid writing overly complex steps__. If you find yourself writing a step
containing a lot of logic and/or any duplicated code you should take a step
back and consider which parts of your step may be factored out as utility
routines or included in the device interface.

* __Prefer optional parameters__. If a parameter provides additional
information to a step, and the step can be implemented without using it, make
it optional. In some cases it may also be handy to make a parameter optional
even if it is required by the steps' implementation to allow feature writers
not to get bogged down in technical details. You should then provide
a sensible default for the parameter in question via a configuration file.

* __Design steps with reuse in mind__. Your step definitions are likely
to prove useful to others, as well as you might find step definitions written
by others handy when defining your tests. So avoid monolithic steps and try
not to impose unnecessary constraints on how your steps may be composed
into scenarios.

* __Avoid platform specific code__. Fruit Salad is meant to run on multiple
platforms and targets, so any platform specific implementation details should
be hidden by the device interface.

* __Use exceptions to indicate failure conditions__.

### Extending Fruit Salad ###

* __Stick to ruby__. You can write Fruit Salad extensions in languages other
than ruby but this must be well justified (for instance performance
considerations or the need to access low-level APIs not accessible from ruby).

* __Reuse existing routines and design patterns__. This will ensure your code
works in a fashion consistent with the entire system. If for some reason you
find yourself needing to duplicate large portions of existing routines,
consider refactoring them to maximise reuse.

* __Avoid requiring root access where possible__. Some tests are bound
to require root access on the tested device (for instance most firmware
tests), but avoiding this requirement increases the amount of devices the test
can be run on, making it more useful in turn.

Testing
-------

* Fruit Salad is self-testable in many instances, so leverage that. All
features should pass on the null target, this is especially handy to test
platform independent parts of the framework such as audio analyses, etc.
* Use automated tests if possible. You should write all your automated testing
using TestUnit and place them in the top-level test folder. Those tests will
often require specific hardware (for instance if you are extending a device
interface), in such cases you will also have to indicate in the `Rakefile` that
they are not suitable for CI (Continuous Integration) execution.
* If a feature requires hardware we do not necessarily have, we adopt
a community testing model.
