"""
@brief
A resource library to wrap basic functionality around the Validation CLIVE tool.

@Description
This resource library provide a simplified wrapper for basic features of CLIVE

Supported Features:
- Launching CLIVE with username, project, and hardware configuration
- Shutting down CLIVE properly

Supported Metrics:
- Username
- Project
- Hardware configuration

@b Usage
@code
@endcode

"""

import os
import sys
from unified_modules.resources.resource_cli.resource_cli import ResourceCli


try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging

class ResourceFPGAError(Exception):
    """Define ResourceFPGAError Exception type"""
    pass

class ResourceFPGA(object):
    """
        Resource wrapper for programming FPGAs
    """

    def __init__(self):
        self.bit_file = ''
        self.fpga_device_id = ''
        self.platform_usb_addr = ''
        self.platform_usb_target_id = ''
        self.program_speed = ''
        self.log = logging.getLogger(ResourceFPGA.__name__)
        self.cli = ResourceCli()

    def configure(self, config):
        """ Configures the resource configuration attributes  """
        self.bit_file = os.path.expandvars(config['bit_file'])
        self.fpga_device_id = os.path.expandvars(config['fpga_device_id'])
        self.platform_usb_addr = config.get('platform_usb_addr')
        self.platform_usb_target_id = config.get('platform_usb_target_id')
        self.program_speed = config.get('program_speed')

    def program(self, version=1):
        """
            Programs the FPGA with the specified bit file

            @param bit_file: [str] The full absolute path to the bit file to be programmed
        """
        current_path = os.path.realpath(__file__)
        current_path = os.path.dirname(current_path)
        if version == 2:
            script_name = 'program_fpga_v2.bat'
            command = '%s\\utility\\%s %s %s %s %s' % (current_path, script_name, self.platform_usb_addr, self.bit_file,
                                                       self.platform_usb_target_id, self.fpga_device_id)
        elif version == 3:
            script_name = 'program_fpga_v3.bat'
            command = '%s\\utility\\%s %s %s %s %s' % (current_path, script_name, self.platform_usb_addr, self.bit_file,
                                                       self.platform_usb_target_id, self.fpga_device_id)
        elif version == 4:
            script_name = 'program_fpga_v4.bat'
            command = '%s\\utility\\%s %s %s %s %s %s' % (current_path, script_name, self.bit_file, self.fpga_device_id,
                                                       self.platform_usb_addr, self.platform_usb_target_id, self.program_speed)                                               
        else:
            command = '%s\\utility\\program_fpga.bat %s %s' % (current_path, self.bit_file, self.fpga_device_id)
        self.log.info('Programming FPGA with:\n\tdevice_id: %s' % self.fpga_device_id)

        self.log.info('RUNNING command %s'%(command))
        stdout, stderr = self.cli.run_cmd_log_stdout(command)

        if ('End of startup status: HIGH' not in stdout):
            message = '\nFPGA programming failed!\n\tFPGA device ID: %s' % self.fpga_device_id
            self.log.error(message)
            return False
        else:
            return True


if __name__ == "__main__":
    from unified_modules.test_support.testbaseclass import BaseTest
    if "--unittest" not in sys.argv:
        # Create and start as an interactive command line
        import unified_modules.test_support.cli_support as cli_support

        class ResourceFPGACli(ResourceFPGA, cli_support.CliOptions):
            """Extend the existing class with multiple inheritance,
            the command line and interactive is added
            without changing the implementation of the class"""

            def __init__(self, *args, **kwargs):
                ResourceFPGA.__init__(self, *args, **kwargs)
                cli_support.CliOptions.__init__(self, ResourceFPGA)

        RUN = ResourceFPGACli()
    else:

        class ResourceFPGAUnitTest(BaseTest):
            """
                This unit test requires a Hank board setup with two Xilinx Platform USB dongles.
                The platform_usb_target_id will also vary based on the dongle used.
            """

            def __init__(self, result):
                super(ResourceFPGAUnitTest, self).__init__(result)
                self.k7_fpga = None
                self.x6_fpga = None

            def setup(self):
                path = os.getcwd()
                xc6_test_file = path + '\\utility\\xc6_test_file.bit'
                xcku_test_file = path + '\\utility\\xcku_test_file.bit'
                self.xc6_config =    {  'platform_usb_addr': "localhost:3121",
                                        'fpga_device_id': "xc6slx150_0",
                                        'platform_usb_target_id': "00001615da2f01",
                                        'bit_file':xc6_test_file
                                    }
                self.xcku_config =   {  'platform_usb_addr': "localhost:3121",
                                        'fpga_device_id': "xcku085_1",
                                        'platform_usb_target_id': "00001616047b01",
                                        'bit_file':xcku_test_file
                                    }
                self.k7_fpga = ResourceFPGA()
                self.x6_fpga = ResourceFPGA()

            def initiate(self):
                self.k7_fpga.configure(self.xcku_config)
                self.x6_fpga.configure(self.xc6_config)
                success = self.x6_fpga.program()
                self.result.assert_true(success, 'Programming Spartan6 FPGA')
                success = self.k7_fpga.program()
                self.result.assert_true(success, 'Programming KU7 FPGA')


        from unified_modules.test_support.testresults import TestResults

        RESULTS = TestResults()
        TEST = ResourceFPGAUnitTest(result=RESULTS)
        TEST.run()
