"""
Results record APIs to collect, store and export the test results.
"""
import os
import sys
import bz2
import time
import random
from time import strftime
from junit_xml import TestSuite, TestCase
from datetime import datetime
import csv
from xml.etree import ElementTree as ET
from lxml import etree

import unified_modules.test_support.testlogger as logging


TIME_STAMP_TYPE = "%Y-%m-%d %H:%M:%S"


class ResultRecord(object):
    """
    A result class recording a test's overall outcome and other execution
    related information.
    """

    def __init__(self):
        """
        Construct an empty :obj:`ResultRecord` instance.
        """
        # TODO: Dummmy test id set for now until we hook up a results database
        self.test_id = random.randint(1000, 2000) * 5
        self.results_label = "NO_RESULTS_LABEL_SET"
        self.test_name = "NO_TEST_NAME_SET"
        self.chip_name = "NO_CHIP_NAME_SET"
        self.test_platform = "NO_TEST_PLATFORM_SET"
        self.result = "SYSABORT"
        self.report = "NO_TEST_REPORT_SET"
        self.start_time = ""
        self.stop_time = ""
        self.record_time = ""
        self.run_time = ""
        self.resource = {}
        self.logfile = None
        self.messages = None
        self.log = None
        self.raw = True
        self.errors = 0
        self.failures = 0
        self.skips = 0
        self.tests = 0
        self.suite_execution_time = ""
        self.test_suite_name = "NO_TEST_SUITE_NAME_SET"
        self.resource_name = "NO_RESOURCE_NAME_SET"
        self.resource_type = "NO_RESOURCE_TYPE_SET"

    def dump(self):
        """
        Dumps recorded results to log.
        """
        self.log = logging.getLogger(self.__class__.__name__)
        self.log.info("RESULT RECORD to be uploaded to results storage:")
        self.log.info("===================================================")
        self.log.info("TEST ID:      %d", self.test_id)
        self.log.info("TEST NAME:    %s", self.test_name)
        self.log.info("CHIP_NAME:    %s", self.chip_name)
        self.log.info("TEST_PLATFORM: %s", self.test_platform)
        self.log.info("RESULTS_LABEL:%s", self.results_label)
        self.log.info("RESULT:       %s", self.result)
        self.log.info("REPORT:       %s", self.report)
        self.log.info("START TIME:   %s", self.start_time)
        self.log.info("STOP TIME:    %s", self.stop_time)
        self.log.info("RUN TIME:     %s", time.strftime("%H:%M:%S", time.gmtime(self.get_run_time())))
        self.log.info("RECORD TIME:  %s", self.record_time)
        self.log.info("RESOURCES:")
        for host in self.resource.keys():
            self.log.info("              %s:%s:%s", host, self.resource[host]['name'], self.resource[host]['type'])
        self.log.info("LOGFILE - %d bytes: %s", len(self.get_logfile()), self.get_logfile())
        self.log.info("===================================================")

    def set_test_id(self, test_id):
        """
        Sets an identifier for the result record related test.

        Args:
            test_id (:obj:`int`): the result record related test's id.
        """
        self.test_id = test_id

    def set_test_name(self, test_name):
        """
        Sets the test case name for the result record related test.

        Args:
            test_name (:obj:`str`): the result record related test case name.
        """
        self.test_name = test_name

    def get_test_id(self):
        """
        Gets the result record related test's identifier.

        Returns:
            :obj:`int`: the result record related test's id.
        """
        return self.test_id

    def set_results_label(self, results_label):
        """
        Gives the result record a label.

        Args:
            results_label (:obj:`str`): the result record label.
        """
        self.results_label = results_label

    def get_results_label(self):
        """
        Gets the result record's label.

        Returns:
            :obj:`str`: the result record' label.
        """
        return self.results_label

    def set_basic_details(self, name, chip_name='', test_platform=''):
        """
        Defines result record's details.

        Args:
            name (:obj:`str`): the result record's name.
            chip_name (:obj:`str`, optional): the result record's targeted
                device name.
            test_platform (:obj:`str`, optional): the result record's test
                platform name.
        """
        self.test_name = name
        self.chip_name = chip_name
        self.test_platform = test_platform

    def get_basic_details(self):
        """
        Gets the result record's details (name and targeted device's name).

        Args:
            :obj:`tuple` of :obj:`str`: the result record's name and its
                targeted device's name.
        """
        return [self.test_name, self.chip_name]

    def set_result(self, result):
        """
        Sets the result record's overall outcome.

        Args:
            result (:obj:`str`): the result record's outcome (:obj:`PASS`,
                :obj:`ABORT` or :obj:`FAIL`)
        """
        self.result = result

    def get_result(self):
        """
        Gets the result record overall outcome.

        Returns:
            :obj:`str`: the result record's outcome.
        """
        return self.result

    def set_start_time(self, timestamp=None):
        """
        Sets a timestamp for the result record's related test beginning.

        Args:
            timestamp (:obj:`str`, optional): the related test's start
                timestamp. Defaults to `None` which means current time.
        """
        if timestamp is None:
            self.start_time = time.strftime(TIME_STAMP_TYPE)
        else:
            self.start_time = timestamp

    def get_start_time(self):
        """
        Gets the timestamp of the result record's related test beginning time.

        Returns:
            :obj:`str`: the related test's start timestamp.
        """
        return self.start_time

    def set_stop_time(self, timestamp=None):
        """
        Sets a timestamp for the result record's related test end.

        Args:
            timestamp (:obj:`str`, optional): the related test's stop
                timestamp. Defaults to `None` which means current time.
        """
        if timestamp is None:
            self.stop_time = time.strftime(TIME_STAMP_TYPE)
        else:
            self.stop_time = timestamp

    def get_stop_time(self):
        """
        Gets the timestamp of the result record's related test end time.

        Returns:
            :obj:`str`: the related test's stop timestamp.
        """
        return self.stop_time

    def set_record_time(self, timestamp=None):
        """
        Sets a timestamp for the result record's creation time.

        Args:
            timestamp (:obj:`str`, optional): the result record's creation
                timestamp. Defaults to `None` which means current time.
        """
        if timestamp is None:
            self.record_time = time.strftime(TIME_STAMP_TYPE)
        else:
            self.record_time = timestamp

    def get_record_time(self):
        """
        Gets the timestamp of the result record's creation time.

        Returns:
            :obj:`str`: the result record's creation timestamp.
        """
        return self.record_time

    def get_run_time(self):
        """
        Method to get test run time

        @return [int] test run time in seconds
        """
        if self.run_time == "":
            start_time = datetime.strptime(self.start_time, TIME_STAMP_TYPE)
            stop_time = datetime.strptime(self.stop_time, TIME_STAMP_TYPE)
            run_time = stop_time - start_time
            self.run_time = run_time.seconds
        return self.run_time

    def set_run_time(self, run_time_in_seconds):
        """
        Method to set test run time

        @param run_time_in_seconds: [int] Run time in seconds
        """
        self.run_time = run_time_in_seconds

    def set_resource(self, host, name, dut_type):
        """
        Attaches a resource to the result record.

        Args:
            host (:obj:`str`): the result record's creation
                timestamp. Defaults to `None` which means current time.
            name (:obj:`str`): the resource's name.
            dut_type (:obj:`str`): the resource's type.
        """
        if host not in self.resource.keys():
            self.resource[host] = {'name': name, 'type': dut_type}

    def get_resource(self):
        """
        Lists result record's attached resources.

        Returns:
            :obj:`dict`: the attached resources dictionary.
        """
        return self.resource

    def set_raw_logfile(self, raw=True):
        """
        Toggles the result record log compression.

        Args:
            raw (:obj:`bool`): the result record's log storing mode. Defaults to
                `True`, which means uncompressed.
        """
        self.raw = raw

    def set_logfile(self, logfile):
        """
        Defines the result record's log file location and name.

        Args:
            logfile (:obj:`str`): the full log file path.
        """
        if self.raw:
            self.logfile = logfile
        else:
            with open(logfile, "r") as f:
                self.logfile = bz2.compress(f.read())

    def get_logfile(self):
        """
        Gets the result record's log filename.

        Returns:
            :obj:`str`: the full log file path.
        """
        if self.raw:
            return self.logfile
        else:
            if self.logfile:
                return bz2.decompress(self.logfile)
            else:
                return ''

    def set_messages(self, messages):
        """
        Sets the result record's messages.

        Args:
            logfile (:obj:`list`): the result record's messages.
        """
        if self.raw:
            self.messages = messages
        else:
            self.messages = bz2.compress(messages)

    def get_messages(self):
        """
        Gets the result record's messages.

        Returns:
            :obj:`list`: the result record's messages.
        """
        if self.raw:
            return self.messages
        else:
            if self.messages:
                return bz2.decompress(self.messages)
            else:
                return ''

    def pretty_print_xml(self, xml_file_path):
        """
        Formats an XML file so that it can be read by humans.

        Args:
            xml_file_path (:obj:`str`): the XML file's path.
        """
        if not os.path.exists(xml_file_path):
            raise Exception("File: %s not found" % xml_file_path)
        parser = etree.XMLParser(resolve_entities=False, strip_cdata=False)
        document = etree.parse(xml_file_path, parser)
        document.write(xml_file_path, xml_declaration=True, pretty_print=True, encoding='utf-8', method="xml")

    def export(self, prefix='', export_path=None):
        """
        Dumps recorded results to a CSV file.

        Args:
            prefix (:obj:`str`, optional): a prefix for the exported file's
                name. Defaults to an empty string.
            export_path (:obj:`str`, optional): the exported file's location.
                Defaults to `None` which means the result record's label will
                be use as a sub-directory.

        Raises:
            IOError: if the export directory does not exist and could not be
                created.
        """
        timestamp = strftime('%Y%m%d%H%M%S')
        if not export_path:
            export_path = self.get_results_label()
        if not os.path.isdir(export_path):
            try:
                os.makedirs(export_path)
            except Exception as err:
                self.log.info("Error %s", err)
                raise IOError("%s is not a directory path and cannot be made" % export_path)
        file_name = "-".join([prefix, "TestResultSummary", timestamp])
        if sys.version_info[0] == 3:
            file_mode = "w"
        elif sys.version_info[0] == 2:
            file_mode = "wb"
        with open(os.path.join(export_path, file_name + ".csv"), file_mode) as summary:
            csv_file = csv.writer(summary)
            csv_file.writerow(["TEST ID", "%d" % self.test_id])
            csv_file.writerow(["TEST NAME", "%s" % self.test_name])
            csv_file.writerow(["CHIP NAME", "%s" % self.chip_name])
            csv_file.writerow(["TEST_PLATFORM:", "%s" % self.test_platform])
            csv_file.writerow(["RESULTS_LABEL:", "%s" % self.results_label])
            csv_file.writerow(["RESULT", "%s" % self.result])
            csv_file.writerow(["REPORT", "%s" % self.report])
            csv_file.writerow(["START TIME", "%s" % self.start_time])
            csv_file.writerow(["STOP TIME", "%s" % self.stop_time])
            csv_file.writerow(["RUN TIME", "%s" % time.strftime("%H:%M:%S", time.gmtime(self.get_run_time()))])
            csv_file.writerow(["RECORD TIME", "%s" % self.record_time])
            for host in self.resource.keys():
                csv_file.writerow(["RESOURCE", "%s:%s:%s" % (host,
                                                             self.resource[host]['name'],
                                                             self.resource[host]['type'])])
            logfile = self.get_logfile()
            csv_file.writerow(["Logfile", "%s - %d bytes" % (self.get_logfile(), len(logfile))])
            file_name = "-".join([prefix, 'TEST_LOGS', timestamp])
            messages = self.get_messages()
            csv_file.writerow(["RESULTS METRICS", "%s - %d bytes" % (self.get_messages(), len(messages))])
