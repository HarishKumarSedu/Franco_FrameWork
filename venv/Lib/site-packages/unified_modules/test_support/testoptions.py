#!/usr/bin/env python
"""
@brief
Test options class

@b Description
This class provides support to record options from command line or function call.
Since optparse does not support unexpected options added at runtime, this class parses the commandline and
creates options at run time.

Unit tests: TestOptionsUnitTests
@b Usage
./testoptions.py --unittest to run the unit tests
"""
import os
import sys
import re
from copy import deepcopy


class TestOptions(object):
    """Class to contain all options provided by either, keyword arguments to options method,
    argv or dictionary or additional arguments. expected arguments must be updated
    with the update method"""
    def __init__(self, consume_sysargv=True, default_list=None):
        """Initialise"""
        self.consume_sysargv = consume_sysargv
        self._existing_options = {}
        self.new_options = {}
        self._command = None
        # option prefix for existing options
        self.opt_prefix = ""
        self._cmd = None
        self.dry_run_help = False
        # Example: can send ['unittest'] to run tests with a quick options list
        if default_list is not None:
            for key in default_list:
                self._existing_options[key] = None

    def set_test_options(self, **kwargs):
        """
        Template method with no existing options defined.
        Override this to define default options with default values.
        Call this method in test class that needs cmd options.
        This supports defining new options for each test class
        Usage:
    @code{.py}
class NewOptions(TestOptions):
    def set_test_options(self, opt1=1, opt2=2, opt3='test', **kwargs):
        '''Example options,
            default params when called with no input params
            @param opt1 - take value for opt1
            @param opt2 - take value for opt2
            @param opt3 - take value for opt3
            @param all other kwargs recorded as additional parameters
        '''
        super(NewOptions, self).set_existing_options(opt1=opt1, opt2=opt2, opt3=opt3)
        super(NewOptions, self).add_new_options(kwargs)
@endcode

        """
        # set expected options
        self.set_existing_options()
        # define any unexpected options as new options at runtime
        self.add_new_options(kwargs)

    def set_existing_options(self, **kwargs):
        """
        Define existing options
        """
        self._existing_options.update(kwargs)

    def add_new_options(self, new_options):
        """
        Add new options to the list of supported options
        """
        # update options supplied as dictionary from another class
        for (option_cmd, value) in new_options.items():
            if option_cmd in self._existing_options.keys():
                self._existing_options[option_cmd] = value
            else:
                self.new_options[option_cmd] = value
        # update options from command line
        self.extract_sysargv_options()
        self.update_exist_attributes()

    def update_exist_attributes(self):
        """Create atrributes for each option in TestOptions class"""
        for (option_cmd, value) in self._existing_options.items():
            setattr(self, option_cmd, value)
            self._existing_options[option_cmd] = self._convert_str_to_int_or_float(value)
        for (option_cmd, value) in self.new_options.items():
            setattr(self, option_cmd, value)
            self.new_options[option_cmd] = self._convert_str_to_int_or_float(value)

    @staticmethod
    def _convert_str_to_int_or_float(value):
        if type(value) == str:
            if "." in value:
                try:
                    value = float(value)
                    return value
                except ValueError:
                    return value
            else:
                try:
                    value = int(value)
                    return value
                except ValueError:
                    return value
        else:
            return value

    def help(self):
        """
        Display usage of TestOptions
        """
        self.dry_run_help = True
        return re.sub(r'\@param ', "--%s" % self.opt_prefix, self.set_test_options.__doc__)

    def __repr__(self):
        """Show options"""
        options = ""
        if 'help' in self.new_options.keys():
            options += self.help()
        options += "\nExisting Options: %s" % str(self._existing_options)
        options += "\nNewly added options: %s" % str(self.new_options)
        return options

    def extract_sysargv_options(self):
        """
        parse command line options and populate existing or new options list
        """
        option_key = ""
        copy_sysargv = deepcopy(sys.argv)
        cmd_options_found = []
        sys.argv.append('--')
        while sys.argv:
            cmd_option = sys.argv.pop(0)
            # check for new option key
            if cmd_option.startswith('--'):
                if option_key != "":
                    if option_key in self._existing_options.keys():
                        self._existing_options[option_key] = (self._existing_options[option_key].lstrip(' '))
                        # option is just a flag
                        if self._existing_options[option_key] == "":
                            self._existing_options[option_key] = True
                    else:
                        self.new_options[option_key] = (self.new_options[option_key].lstrip(' '))
                        # option is just a flag
                        if self.new_options[option_key] == "":
                            self.new_options[option_key] = True
                # Store key here and remove prefix
                option_key = cmd_option.lstrip('--')
                option_key = re.sub(self.opt_prefix, '', option_key)
                if option_key != "":
                    if option_key in self._existing_options.keys():
                        self._existing_options[option_key] = ""
                    else:
                        self.new_options[option_key] = ""
                cmd_options_found.append(option_key)
            else:
                # this is a value not an option key
                if option_key != "":
                    if option_key in self._existing_options.keys():
                        self._existing_options[option_key] += ' ' + cmd_option
                    else:
                        self.new_options[option_key] += ' ' + cmd_option
                else:
                    # This is the command, show help for this command if available
                    if self._cmd is None:
                        self._cmd = cmd_option
                    else:
                        print(self.help())
        #TODO: new feature pending: Search for missing mandatory options in environment variables
        self.update_exist_attributes()
        if not self.consume_sysargv:
            sys.argv = deepcopy(copy_sysargv)

        if 'help' in self.new_options.keys():
            if self.__class__.__name__ != 'TestOptions':
                print(self.help(), self.__class__.__name__)
            return self.help()
        else:
            return "Test options set: ", self._existing_options.keys(), self.new_options.keys()
