#!/usr/bin/env python
"""
@file

@brief
Utility for exposing classes via XMLRPC, adds Sessions

@b Usage
@b Server Usage
@code
server = RPCServer(AudioAnalysis, "audio", "localhost", 8002)
# Run forever
server.run()
@endcode

@b Client Usage (Blocking)
@code
remote_client = RPCClient(('localhost', 8002), True)
result = remote_client.my_remote_function(1, "/location/myfile.dat")
@endcode

@b Client Usage (Non-blocking)
@code
remote_client = RPCClient(('localhost', 8002), False)
result = remote_client.my_remote_function(1, "/location/myfile.dat")
@endcode
"""
import sys
if sys.version_info[0] == 3:
    from xmlrpc.server import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler
    from xmlrpc.server import list_public_methods
    from queue import Queue
    from xmlrpc.client import ServerProxy, Binary, Fault
elif sys.version_info[0] == 2:
    from SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler
    from SimpleXMLRPCServer import list_public_methods
    from Queue import Queue
    from xmlrpclib import ServerProxy, Binary, Fault
from uuid import uuid4
from datetime import datetime
from time import sleep
from tempfile import gettempdir
from os import path, fsync, remove, makedirs, stat, urandom, _exit
from io import BytesIO
from inspect import getargspec, getdoc
from threading import Thread, Lock, Semaphore
from collections import deque
from hashlib import md5
import gzip
import sys
import errno
from traceback import print_exc, format_exc, format_tb
import socket
from socket import error as socket_error
import os

import unified_modules.test_support.testlogger as logging


MAX_RPC_FUNC = 5
RPC_SEMA = Semaphore(MAX_RPC_FUNC)

SESSION_TIMEOUT = 60 * 60 * 24

# 200ms poll period
RPC_CLIENT_POLL = 0.2

FILE_LOCKS = []


class Session(Thread):

    '''
    Session Class used to manage sessions and merged with exposed class
    '''

    def __init__(self, client_ip, location, log_prefix=''):
        '''Initialise session vars

        @par client_ip - ip of the client that started session
        @par location - where the session should store data.
        @par log_prefix - used to prepend log calls (optional).
        '''

        self.verbose = True
        Thread.__init__(self, name="XmlRpc Session, %s" % log_prefix)

        self.sessionid = 'xmlrpc-'+str(uuid4())
        self.opened = datetime.now()
        self.lastused = datetime.now()
        self.killed = False

        self.location = location + "/" + self.sessionid
        if not path.isdir(self.location):
            makedirs(self.location)

        self.results = {}
        self.client_ip = client_ip[0]
        self.output = ""
        self.log_prefix = log_prefix
        self._func_queue = Queue()
        self._loglock = Lock()
        self.busy = False
        self._loop = True

        self.sessionlog(self.client_ip + " started Session ID:" + self.sessionid)
        self.start()

    def tick(self):
        '''Update the tick counter'''
        self.lastused = datetime.now()

    def is_busy(self):
        '''return busy flag'''
        return self.busy

    def sessionlog(self, output):
        '''log with prefix
        @par output - string to be logged with prefix.
        '''
        self.sessioncleanlog(self.log_prefix + output)

    def sessioncleanlog(self, output):
        '''Log (without prefix)
        @par output - string to be logged
        '''
        self.tick()
        self._loglock.acquire()
        self.output = self.output + output + "\n"
        with open(self.location + "/log.txt", "a") as logfile:
            logfile.write(output + "\n")
        print(output)
        self._loglock.release()

    def queue_func(self, func, args):
        '''Queue a function for execution
        @par func - function to be called.
        @par args - list of arguments to be passed.
        '''
        self.tick()
        # Item added to queue so we must be busy
        self.busy = True
        count = 0
        for name, _ in self.results.iteritems():
            if func.__name__ in name:
                count = count + 1

        handle = func.__name__ + str(count)

        self.results[handle] = None

        if self.verbose:
            self.sessionlog("Queueing:" + func.__name__ + " Result handle: " +
                            handle)
        self._func_queue.put((func, args, handle))

        return handle

    def run(self):
        '''Session run thread. Works through a Queue of remotely requested
        functions, until told to die'''

        try:
            while self._loop:
                func, args, handle = self._func_queue.get()

                if func == "die":
                    self._loop = False
                    continue

                self.tick()

                # If any of the args are in FILE_LOCKS spin, as they are being
                # decompressed
                file_spin_timeout = 30
                file_spin_time_step = 0.2
                for arg in args:
                    if arg in FILE_LOCKS:
                        timer = 0
                        while arg in FILE_LOCKS:
                            if (not self._loop) or (timer > file_spin_timeout):
                                self._loop = False
                                break
                            timer += file_spin_time_step
                            sleep(file_spin_time_step)

                # Check the to see if loop should continue
                if self._loop:
                    if self.verbose:
                        self.sessionlog("Running:" + func.__name__ +
                                        ", Args:" + str(args))
                    self.busy = True
                    start = datetime.now()
                    with RPC_SEMA:
                        # Pass on arguments from incoming list of calls
                        try:
                            self.results[handle] = func(*args)

                        #pylint: disable=broad-except
                        # Catch all exceptions, record on result queue, log to stdout,
                        # do not re-raise (we are a server)
                        except Exception as error:
                            # Log the exception as the result
                            self.results[handle] = ("XmlRpc: RemoteException",
                                                    str(type(error)),
                                                    str(error),
                                                    format_exc())
                            # Record exception to stdout for logging
                            print_exc()

                    ttime = datetime.now() - start

                    if self.verbose:
                        self.sessionlog("Execution time:" + func.__name__ + ", " +
                                        str(ttime.total_seconds()) + "s")

                else:
                    try:
                        self.sessionlog("Error before running:" + func.__name__)
                    except AttributeError:
                        self.sessionlog("Error before running:" + func)

                    self.results[handle] = -1

                if self._func_queue.qsize() == 0:
                    self.busy = False

        except Exception as error:
            self.sessionlog("Terminated with exception: %s" % str(error))
            print_exc()

            # If we do not terminate the session and raise the exception the client will have
            # wait until SESSION_TIMEOUT before aborting.
            self.stop()
            raise

    def set_verbose(self, verbose_flag):
        '''Set verbosity level, use to avoid flooding logs when polling'''
        self.verbose = verbose_flag

    def stop(self):
        '''close the session and tell the session worker thread to die'''
        print("XML RPC Server Stop called")
        self._loop = False
        self._func_queue.put("die", None, None)
        self.sessionlog("Session closing ID:" + self.sessionid)
        self.busy = False
        self.killed = True

        # Kill all threads
        print("Calling os._exit to stop all servers.")
        _exit(0)

def expose(func):
    '''Decorator to set exposed flag on a function.'''
    func.exposed = True
    return func


def is_exposed(func):
    '''Test whether another function should be publicly exposed.'''
    return getattr(func, 'exposed', False)


# Restrict to a particular path.
class _RequestHandler(SimpleXMLRPCRequestHandler):

    '''
    Request handler class used with RPCServer
    '''
    rpc_paths = ('/rpc',)

    def __init__(self, request, client_address, server):
        '''print client_address # do what you need to do with
        client_address here'''
        SimpleXMLRPCRequestHandler.__init__(self, request, client_address,
                                            server)


class _MyXMLRPCServer(SimpleXMLRPCServer):

    '''
    Wrapper class of SimpleXMLRPCServer to allow the exposure of client
    address to the handler
    '''

    def __init__(self, *args, **kwargs):
        '''Init'''
        SimpleXMLRPCServer.__init__(self, *args, logRequests=False, **kwargs)
        self.client_address = None

    def process_request(self, request, client_address):
        '''Override the process request to store the client_address in the
        class'''
        self.client_address = client_address
        return SimpleXMLRPCServer.process_request(self, request,
                                                  client_address)


class XmlRpcRemoteException(Exception):
    """Exception type for remote exceptions, it is generic because the
    exception class may not be available in the client context, it has no special features"""
    pass


class RpcServer(object):
    '''
    RpcServer Class
    '''

    def __init__(self, sessionclass, prefix, host, session_location=None, *args, **kwargs):
        '''initialise the server
        @par sessionclass - the class to serve
        @par prefix - prefix to use, this helps identify the server function.
        @par host - (host, ip) tuple to start the server
        @par session_location - where to store the session files (optional).'''
        self.sessions = {}
        self.rpc_count = 0

        self.rpc_per_min = deque([0], 60)

        self.prefix = prefix

        self.log_prefix = "Remote " + prefix + " - "
        self.sessionclass_name = sessionclass.__name__
        if not session_location:
            self.session_location = gettempdir()
        else:
            self.session_location = session_location

        self.session_class = self._make_class(sessionclass, *args, **kwargs)

        print("Starting XMLRPC Server %s at:%s" % (prefix, str(host)))
        sys.stdout.flush()

        self.server = _MyXMLRPCServer(host, requestHandler=_RequestHandler,
                                      allow_none=True)

        self.server.register_introspection_functions()
        self.server.register_instance(self)

        # create the list of exposed methods
        self._exposed_class_methods = []

        for method in list_public_methods(self.session_class):
            if is_exposed(getattr(self.session_class, method)):
                self._exposed_class_methods.append(self.prefix + "." + method)

        # If nothing exposed Expose all public methods by default
        if self._exposed_class_methods == []:
            for method in list_public_methods(self.session_class):
                if not method.startswith('_'):
                    self._exposed_class_methods.append(self.prefix + "." + method)

        # create the list of exposed methods
        self._exposed_local_methods = []
        for method in list_public_methods(self):
            if is_exposed(getattr(self, method)):
                self._exposed_local_methods.append(method)

    def _make_class(self, sessionclass, *args, **kwargs):
        '''Make the combined session class
        @par sessionclass - the class to serve'''
        class SessionClass(Session, sessionclass):
            '''Combined session class'''

            def __init__(self, client_ip, location, log_prefix=''):
                '''Call the subclass inits and overload log in the
                sessionclass'''
                Session.__init__(self, client_ip, location, log_prefix)
                sessionclass.__init__(self, *args, **kwargs)
        return SessionClass

    def run(self):
        '''run the server'''
        print("Running Server")
        sys.stdout.flush()

        try:
            self.server.serve_forever()

        #pylint: disable=broad-except
        #Error message given with error details
        except Exception as error:
            print("Server terminated (%s)" % error)

    def server_prefix(self):
        """Prefix of server function"""
        return self.prefix

    @expose
    def get_class_name(self):
        """return the class name"""
        return self.sessionclass_name

    @expose
    def start_session(self):
        '''Start a new session'''
        sesh = self.session_class(self.server.client_address,
                                  self.session_location, self.log_prefix)
        self.sessions[sesh.sessionid] = sesh
        return sesh.sessionid

    @expose
    def stop_session(self, sessionid):
        '''Stop the session and delete the session object
        @par sessionid - the id of the session to stop'''
        if sessionid in self.sessions:
            try:
                self.sessions[sessionid].stop()
            #pylint: disable=broad-except
            # broad-except used on stop to ensure the session is stopped
            # no matter what its state.
            except Exception:
                # May be stopped or not responding
                pass
            self.sessions[sessionid].log = None
            del self.sessions[sessionid]
            return_value = 1
        else:
            return_value = 0

        return return_value

    @expose
    def verify_session(self, sessionid):
        '''Verify that the session exists
        @par sessionid - the id of the session to verify'''
        if sessionid in self.sessions:
            return 1
        return 0

    @expose
    def set_verbose(self, sessionid, verbose_flag):
        '''Is the session busy?
        @par sessionid - the id of the session to check busy'''
        return self.sessions[sessionid].set_verbose(verbose_flag)

    @expose
    def get_session_busy(self, sessionid):
        '''Is the session busy?
        @par sessionid - the id of the session to check busy'''
        return self.sessions[sessionid].is_busy()

    @expose
    def get_session_result(self, sessionid, handle):
        '''Get the session result
        @par sessionid - the id of the session
        @par handle - the handle of the result to return'''
        return self.sessions[sessionid].results[handle]

    @expose
    def get_session_results(self, sessionid):
        '''Get the session result
        @par sessionid - the id of the session'''
        return self.sessions[sessionid].results

    @expose
    def get_session_log(self, sessionid):
        '''Get the session log
        @par sessionid - the id of the session'''
        if self.sessions[sessionid]:
            return self.sessions[sessionid].output
        else:
            with open(self.session_location + "/" + sessionid + "/log.txt",
                      "r") as myfile:
                data = myfile.read()
                return data

    def _dispatch(self, method, args):
        '''Dispatcher override, all requests go via this function'''
        self.rpc_count += 1

        if method in list_public_methods(self):
            func = getattr(self, method)
            # Simply pass on arguments
            return func(*args)

        # Remove our prefix from the method name
        if not method.startswith(self.prefix + '.'):
            raise Exception('method "%s" is not supported' % method)

        if self.verify_session(args[0]):
            sessionid = args[0]

            method_name = method.partition('.')[2]

            func = getattr(self.sessions[sessionid], method_name)
            func_args = list(getargspec(getattr(self.session_class, method_name)).args)

            # If first argument is self get version without it
            if func_args[0] == "self":
                func_args = func_args[1:]

            margs = list(args[1:])

            return self.sessions[sessionid].queue_func(func, margs)

        else:
            raise Exception('No valid session id')

    #pylint: disable=invalid-name
    # Overloaded ServerProxy.system function does not conform to pylint names
    def listMethods(self):
        '''SimpleXMLRPCServer listMethod override'''
        return self._exposed_local_methods + self._exposed_class_methods

    #pylint: disable=invalid-name
    # Overloaded ServerProxy.system function does not conform to pylint names
    def methodHelp(self, method):
        '''SimpleXMLRPCServer methodHelp override'''
        if method in list_public_methods(self):
            func = getattr(self, method)
            return getdoc(func)

        if method not in self._exposed_class_methods:
            raise Exception('method "%s" is not supported' % method)

        func = getattr(self.session_class, method.partition('.')[2])
        docs = getdoc(func)

        return docs

    #pylint: disable=invalid-name
    # Overloaded ServerProxy.system function does not conform to pylint names
    def methodSignature(self, method):
        '''implement methodSignature'''
        if method in list_public_methods(self):
            func = getattr(self, method)
            return getargspec(func)

        if method not in self._exposed_class_methods:
            raise Exception('method "%s" is not supported' % method)

        func = getattr(self.session_class, method.partition('.')[2])
        spec = getargspec(func)

        # Dont include self in args for non-static methods
        if len(spec.args) != 0 and spec.args[0] == 'self':
            args = spec.args[1:]
        else:
            args = spec.args

        return (args, spec.defaults)

class RpcClient(object):
    '''
    Remote client class
    '''

    def _call(self, func, sig, defaults, method):
        '''function call wrapper to allow the addition of the session id
        parameter, and to block if busy and blocking'''

        # Handle no default params
        if defaults is None:
            defaults = []

        # Handle no params
        if sig is None:
            sig = []

        def new_func(*args, **kwargs):
            """
            Build function pointer
            """

            margs = list(args)

            n_m_args = len(sig) - len(defaults)

            # handle keyword arguments
            for (param_location, name) in enumerate(sig):
                # Only process if not dealt with by a positional parameter
                if param_location >= len(margs):
                    # XMLRPC does not support keyword args so add to args
                    # Get default value if available.
                    try:
                        margs.append(kwargs[name])
                    except KeyError:
                        # All mandatory args must be provided
                        if len(margs) < n_m_args:
                            raise Exception(
                                "TypeError: %s takes at least %d arguments (%d given)" % (
                                    method,
                                    n_m_args,
                                    len(args)+len(kwargs)))

                        margs.append(defaults[param_location - n_m_args])

            margs = [self._sessionid] + margs

            # Use constructed list of arguments
            result_handle = func(*margs)

            if self._blocking:
                try:
                    self.wait_busy()
                    self.result = self._remote.get_session_result(self._sessionid, result_handle)

                    # Assess the possibility of an exception
                    try:
                        if self.result[0] == "XmlRpc: RemoteException":
                            # Detected an exception on the remote system
                            raise XmlRpcRemoteException('Remote (%s:%d) %s' % (self._host[0],
                                                                                 self._host[1],
                                                                                 self.result[3]))
                    except (TypeError, KeyError, IndexError):
                        # Result does not require interception
                        pass

                    self.print_output()
                    return self.result
                except socket.error:
                    self.log.info("Connection to resource terminated.")
            else:
                self.print_output()
                return result_handle

        return new_func

    def __init__(self, host, blocking=True, log_prefix=""):
        '''Initialise client class
        @par host - (host, ip) tuple to of the server to connect
        @par blocking - call to remote functions should block (optional).'''

        self._output = ""
        self._blocking = blocking
        self._host = host
        self.result = None
        self.log = logging.getLogger("RpcClient-%s" % log_prefix)
        self._remote = ServerProxy('http://' + host[0] + ':' +
                                   str(host[1]) + '/rpc', allow_none=True)
        remote = self._remote.listMethods()
        self.server_name = self._remote.server_prefix()


        # get methods to expose
        for method in remote:
            if "." in method:
                try:
                    (sig, defaults) = self._remote.methodSignature(method)
                    func = self._call(getattr(self._remote, method),
                                      sig,
                                      defaults,
                                      method)

                    func.__name__ = method.partition('.')[2]
                    func.__doc__ = self._remote.methodHelp(method)
                    func.__annotations__ = sig

                    setattr(func, 'exposed', True)
                    setattr(self, func.__name__, func)

                    self.remote_prefix = method.partition('.')[0]

                #pylint: disable=broad-except
                # We dont really care why this failed, just log it.
                except Exception as error:
                    # If this fails we cant expose it.
                    self.log.info("Failed to expose %s: %s" % (method, error))

        self.log.info(("Connected '" + self.remote_prefix + "' on http://" + host[0] +
               ":" + str(host[1]) + "/rpc"))

        self._sessionid = self._remote.start_session()
        # Records the session logger (of stdout) so that it can be removed when the
        # resource is terminated, not to be confused with the xmlrpc session
        self.session = None

        # Record the testhead so that the resource attribute can be accessed
        self.testhead = None
        self.tag = ""
        self.resource_base = None

    def stop(self):
        '''Close the session'''
        try:
            sys.stdout.flush()
            self._remote.stop_session(self._sessionid)
        except socket_error as serr:
            if serr.errno != errno.ECONNREFUSED:
                # Not the error we are looking for, re-raise
                raise serr

        # Now terminate our log session, if we have one
        if self.session:
            self.session.close()

    @expose
    def get_results(self):
        '''get all the results for this session'''
        return self._remote.get_session_results(self._sessionid)

    @expose
    def get_result(self, handle):
        '''get result at the handle for this session'''
        return self._remote.get_session_result(self._sessionid, handle)

    @expose
    def set_verbose(self, verbose_flag):
        '''set verbosity for this session'''
        return self._remote.set_verbose(self._sessionid, verbose_flag)

    @expose
    def get_session_id(self):
        '''get the session id'''
        return self._sessionid

    def __repr__(self):
        '''Return string representation of a set '''
        return 'xmlrpc_support %s-%s' % (self.tag, self._remote.get_class_name())

    @expose
    def wait_busy(self):
        '''Wait until remote is not busy'''
        try:
            while self._remote.get_session_busy(self._sessionid):
                sleep(RPC_CLIENT_POLL)
                self.print_output()
        except Fault:
            raise Exception("Unable to access xmlrpc server %s on %s" % (self.server_name,
                                                                         self._host))
        except (KeyboardInterrupt, SystemExit):
            raise Exception(
                "Interrupted while waiting for xmlrpc server %s on %s" % (self.server_name,
                                                                          self._host))

    def print_output(self):
        '''Print the new output'''
        new_output = self._remote.get_session_log(self._sessionid)
        new_lines = new_output.splitlines()
        for i in range(len(self._output.splitlines()), len(new_lines)):
            self.log.info(new_lines[i])
        self._output = new_output

    def __str__(self):
        host = self._host[0]
        try:
            hostname = socket.getfqdn(host)
        except socket.herror:
            hostname = host
        repr_str = "%s@%s" % (self.tag, hostname)
        return repr_str
