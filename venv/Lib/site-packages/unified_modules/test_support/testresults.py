#!/usr/bin/env python
"""
@brief
Test Results module in Python.

@b Description
This class provides objects for test result handing through assertions.

Features support to verify measured values:
- Consistent way of verifying measurement using assertion methods
- Module supports extension to project specific assertions
- provides methods to indicate reasons for fail/abort states
- collection of all test step outcomes and overall test outcome.
- completely independent of test framework

UnitTests: UnitTests.

@b Usage
./testresults.py --unittest to run the unit tests\n
Usage in a test class: see unit tests
"""

from sys import _getframe, stdin
import re
import inspect
import select

import unified_modules.test_support.testlogger as logging


# pass/fail bools and abort state is the same as abort step because abort step leads to abort state.
PASS_STATE = True
FAIL_STATE = False
ABORT_STATE = "A"
SKIPPED_STATE = "S"
BLOCKED_STATE = "B"

# pass/fail/abort test step outcome
PASS_STEP = "P"
FAIL_STEP = "F"
ABORT_STEP = "A"
SKIPPED_STEP = SKIPPED_STATE
BLOCKED_STEP = BLOCKED_STATE

# pass/fail/abort strings
PASS = "PASS"
FAIL = "FAIL"
ABORT = "ABORT"
SKIPPED = "SKIPPED"
BLOCKED = "BLOCKED"
RETURN_CODES = {ABORT: -1,
                FAIL: 1,
                PASS: 0,
                SKIPPED: 2,
                BLOCKED: 3}


class TestResults(object):
    """@brief Test Results collector class
     Features:
     - assertion methods.
     - Record list of assertions and their outocmes.
     - Collect overall outcome.
     - Number each test steps in the logs.
    """

    def __init__(self, excuses_tolerated=False, excuses_reported=False):
        """
        Initialise TestResults params
        """
        # make a logger so that tests can run without declaring test name
        self.log = logging.getLogger()
        # initialise test step number
        self.test_step_num = 0
        self.results_title = ""
        # Test passes if no assertions are done. So tests must contain atleast a single assertion
        self.overall_outcome = PASS
        self.outcomes = []
        self.assertions = []
        self.testsummary = []

    def set_test_title(self, title):
        """Set title of the test results
        Logger created with INFO default log level enabled.
        @param title Test title
        """
        # override logger with title. A log file should be created for this call.
        self.log = logging.getLogger(title)

        # Make sure nested tests do not overwrite the title here
        if self.results_title == "":
            self.results_title = title
            if self.results_title != "":
                self.assert_message("---- Test %s started " % title)

    def test_step(self, step_msg):
        """
        Test step logs with a sequential test number.
        @param step_msg Title of test step. Step numbers will be allocated.
        """
        self.test_step_num += 1
        step_description = "TestStep " + str(self.test_step_num) + ": " + step_msg
        self.assert_message(step_description)
        self.testsummary.append(step_description)

    def assert_true(self, state, assert_message):
        """Assert if state is true.
        @param state to compare with True (any type)
        @param assert_message assertion description message
        @return bool outcome of the assertion
        """
        if bool(state):
            assertion_message = "PASS, assert_true - %s" % assert_message
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_true - %s" % assert_message
            outcome = self.record_fail(assertion_message)
        return outcome

    def assert_false(self, state, assert_message):
        """Assert if state is false.
        @Param state to compare with Flase(any type)
        @param assert_message assertion description message
        @return bool outcome of the assertion
        """
        if not bool(state):
            assertion_message = "PASS, assert_false - %s" % assert_message
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_false - %s" % assert_message
            outcome = self.record_fail(assertion_message)
        return outcome

    def assert_equal(self, actual, expected, assert_message):
        """Assert if actual value is equal to the expected value
        @param actual Actual measured value of any type
        @param expected Expected measured value of any type
        @param assert_message assertion description message
        @return bool outcome of the assertion
        """
        if actual == expected:
            assertion_message = "PASS, Assert Equal - %s, got expected value %s" % (assert_message,
                                                                                    actual)
            outcome = self.record_pass(assertion_message)
        else:
            if type(actual) == type(expected):
                assertion_message = (
                    "FAIL, Assert Equal - %s, %s does NOT equal %s") % (assert_message,
                                                                        actual, expected)
            else:
                assertion_message = "FAIL, Assert Equal - %s, %s(%s) does NOT equal %s(%s)"\
                                    % (assert_message, actual,
                                       type(actual), expected, type(expected))

            outcome = self.record_fail(assertion_message)
        return outcome

    def assert_almost_equal(self, actual, expected, within, assert_message):
        """@method Test and record if a value is within a range of another value

        Test and assert that the supplied measured value is within a certain
        tolerance of a given value. A numeric comparison is performed: actual,
        expected and within parameters must look like numbers otherwise the
        assertion fails. The within parameter must be a positive value
        otherwise the assertion fails.
        @param actual Actual value measured, must be a numeric value
        @param expected Expected value, must be a numeric value
        @param within tolerance either side of the expected value, must be a
        numeric value
        @param assert_message String description of check
        @return Boolean indicating the outcome of the check
        """

        # Prerequisite check that all values are numbers and within is non
        # negative
        if (isinstance(actual, Real) and isinstance(expected, Real) and
                isinstance(within, Real)):
            if within >= 0:
                if (expected - within) <= actual <= (expected + within):
                    assert_string = ("PASS, Assert Almost Equal - %s,"
                                     " %s is within "
                                     "%s of %s") % (assert_message, actual,
                                                    within, expected)
                    outcome = self.record_pass(assert_string)
                else:
                    assert_string = ("FAIL, Assert Almost Equal - %s"
                                     ", %s is NOT within"
                                     " %s of %s") % (assert_message, actual,
                                                     within, expected)
                    outcome = self.record_fail(assert_string)
            else:
                assert_string = ("FAIL, Assert Almost Equal - %s, "
                                 "within value is a negative number, "
                                 "%s") % (assert_message, within)
                outcome = self.record_fail(assert_string)
        else:
            assert_string = ("FAIL, Assert Almost Equal - %s, "
                             "input values are not of the "
                             "numeric (Real) type, (actual:%s(%s), "
                             "expected:%s(%s), within:%s(%s))") % (assert_message,
                                                                   type(actual),
                                                                   str(actual),
                                                                   type(expected),
                                                                   str(expected),
                                                                   type(within),
                                                                   str(within))
            outcome = self.record_fail(assert_string)
        return outcome

    def assert_within_percentage(self, actual, expected, percentage, assert_message):
        """@method Test and record if a value is within a range of another value

        Test and assert that the supplied measured value is within +/-percentage
        of the expected value. A numeric comparison is performed: actual,
        expected and percent parameters must look like numbers, otherwise the
        assertion fails. The percent parameter must be in the interval [0, 100],
        otherwise the assertion fails.

        @param actual Actual value measured, must be a numeric value
        @param expected Expected value, must be a numeric value
        @param percentage tolerance either side of the expected value, must be a
        numeric value in the interval [0, 100]
        @param assert_message String description of check
        @return Boolean indicating the outcome of the check
        """

        # Prerequisite check that all values are numbers and percentage is in [0, 100]
        if 0 <= percentage <= 100:
            within = (percentage * abs(expected)) / 100.0
            if (abs(expected) - within) <= abs(actual) <= (abs(expected) + within):
                assert_string = ("PASS, Assert Within Percentage - %s,"
                                 " %s is within"
                                 " %s%% of %s") % (assert_message, actual,
                                                   percentage, expected)
                outcome = self.record_pass(assert_string)
            else:
                assert_string = ("FAIL, Assert Within Percentage - %s"
                                 ", %s is NOT within"
                                 " %s%% of %s") % (assert_message, actual,
                                                   percentage, expected)
                outcome = self.record_fail(assert_string)
        else:
            assert_string = ("FAIL, Assert Within Percentage - %s, "
                             "percentage value is not in [0, 100], "
                             "%s") % (assert_message, percentage)
            outcome = self.record_fail(assert_string)
        return outcome

    def assert_not_within_percentage(self, actual, expected, percentage, assert_message):
        """@method Test and record if a value is within a range of another value

                Test and assert that the supplied measured value is not within +/-percentage
                of the expected value. A numeric comparison is performed: actual,
                expected and percent parameters must look like numbers, otherwise the
                assertion fails. The percent parameter should not be in the interval [0, 100],
                otherwise the assertion fails.

                @param actual Actual value measured, must not be a numeric value
                @param expected Expected value, must be a numeric value
                @param percentage tolerance either side of the expected value, must be a
                numeric value in the interval [0, 100]
                @param assert_message String description of check
                @return Boolean indicating the outcome of the check
                """

        # Prerequisite check that all values are numbers and percentage is in [0, 100]
        if 0 <= percentage <= 100:
            within = (percentage * abs(expected)) / 100.0
            if not (abs(expected) - within) <= abs(actual) <= (abs(expected) + within):
                assert_string = ("PASS, Assert  not Within Percentage - %s,"
                                " %s is within"
                                " %s%% of %s") % (assert_message, actual,
                                                       percentage, expected)
                outcome = self.record_pass(assert_string)
            else:
                assert_string = ("FAIL, Assert  Within Percentage - %s"
                                ", %s is NOT within"
                                 " %s%% of %s") % (assert_message, actual,
                                                       percentage, expected)
                outcome = self.record_fail(assert_string)
        else:
            assert_string = ("FAIL, Assert not Within Percentage - %s, "
                             "percentage value is not in [0, 100], "
                             "%s") % (assert_message, percentage)
            outcome = self.record_fail(assert_string)
        return outcome

    def assert_raises(self, exception, method, assert_message, *args, **kwargs):
        """Assert if the given exception is raised by a function call
        @param method function reference to call
        @param exception check for this exception type
        @param assert_message assertion description message
        @return exception/result - raised exception or the result returned by the function
        """
        return_value = None
        try:
            exception_name = exception.__name__
        except AttributeError:
            # Exception does not have a __name__
            exception_name = str(exception)

        try:
            return_value = method(*args, **kwargs)
        except exception as exc:
            assertion_message = "PASS, assert_raises - %s, %s raised %s" % (assert_message,
                                                                            str(method),
                                                                            exception_name)
            self.record_pass(assertion_message)
            return_value = exc
        else:
            assertion_message = "FAIL, assert_raises - %s, %s does NOT raise %s" % (assert_message,
                                                                                    str(method),
                                                                                    exception_name)
            self.record_fail(assertion_message)
        return return_value

    def assert_regexp_matches(self, actual, regexp, assert_message):
        """Assert if regular expression match found in input string
        @param actual input string
        @param regexp regular expression to match
        @param assert_message assertion description message
        @return bool outcome of the assertion
        """
        if re.search(regexp, actual, flags=re.MULTILINE):
            assertion_message = "PASS, assert_regexp_matches - %s, %s found in '%s'"\
                                % (assert_message, regexp, actual)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_regexp_matches - %s, %s NOT found in '%s'"\
                                % (assert_message, regexp, actual)
            outcome = self.record_fail(assertion_message)
        return outcome

    def assert_regexp_not_matches(self, actual, regexp, assert_message):
        """Assert if regular expression not matched found in input string
                @param actual input string
                @param regexp regular expression not to match
                @param assert_message assertion description message
                @return bool outcome of the assertion
                """
        if not re.search(regexp, actual, flags=re.MULTILINE):
            assertion_message = "PASS, assert_regexp_not_matches - %s, %s Not found in '%s'" \
                                % (assert_message, regexp, actual)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_regexp_not_matches - %s, %s  found in '%s'" \
                                % (assert_message, regexp, actual)
            outcome = self.record_fail(assertion_message)
        return outcome

    def current_outcome(self):
        """Summary of the assertions and aggregated outcomes so far"""
        self.assert_message("---- Results Summary - %s, Overall outcome is, %s"
                            % (self.results_title, self.overall_outcome))
        self.assert_message("List of outcomes - %s" % self.step_outcome())
        self.assert_message("List of assertions -\n%s" % "\n".join(self.assertions))
        self.assert_message("-------------------------------------- %s" % self.overall_outcome)
        return self.overall_outcome

    def get_overall_outcome(self):
        """return overall outcome"""
        # Set overall outcome as FAIL if there are no assertions
        if not self.outcomes:
            self.overall_outcome = FAIL
        return self.overall_outcome

    def step_outcome(self):
        """return a list of test step outcomes.
        @return string that indicates the outcome of each step in a string (string made of P or F)
        """
        outstr = "".join(self.outcomes)
        return outstr

    def test_summary(self, html=True):
        """Return a test summary which includes test steps and assertions
        @param html HTML output (default True)
        @return overall outcome in string format
        """
        if html:
            return " <br>".join(self.testsummary)
        else:
            return "\n".join(self.testsummary)

    def assert_outcome(self, html=True):
        """Return a list of assertions
        @param html HTML output (default True)
        @return overall outcome in string format
        """
        if html:
            outstr = " <br>".join(self.assertions)
        else:
            outstr = "\n".join(self.assertions)
        return outstr

    def result_append(self, result_to_append):
        """Append the results of another results object to this one
        @param result_to_append TestResults object to append
        """
        self.outcomes += result_to_append.outcomes
        self.assertions += result_to_append.assertions
        self.testsummary += result_to_append.assertions
        # If appended results had a fail or abort result update the overall result accordingly
        if result_to_append.overall_outcome == ABORT:
            self.overall_outcome = ABORT
        elif result_to_append.overall_outcome == FAIL:
            self.overall_outcome = FAIL

    def assert_message(self, assertion_message, level=logging.INFO):
        """Record log messages for assertions and outcome
        @param assertion_message log message
        @param level log level - default is INFO
        """
        if self.results_title == "":
            self.set_test_title("Test_Title_not_set")

        log_method = {logging.INFO: self.log.info,
                      logging.ASSERTION: self.log.assertion,
                      logging.WARNING: self.log.warning,
                      logging.ERROR: self.log.error}
        log_method[level](assertion_message)

    def record_fail(self, assertion_message):
        """Record assertion and outcome on failure.
        @param assertion_message log msg for failed assertion
        @return bool - outcome of the assertion
        """
        fail_state = FAIL_STATE
        self.assert_message(assertion_message, logging.ASSERTION)
        self.outcomes.append(FAIL_STEP)
        self.assertions.append(assertion_message)
        self.testsummary.append(assertion_message)
        if self.overall_outcome == PASS:
            self.overall_outcome = FAIL
        return fail_state

    def record_pass(self, assertion_message):
        """Record assertion and outcome on pass.
        @param assertion_message log msg for pass assertion
        @return bool - outcome of the assertion
        """
        pass_state = PASS_STATE
        self.assert_message(assertion_message, logging.ASSERTION)
        self.outcomes.append(PASS_STEP)
        self.assertions.append(assertion_message)
        self.testsummary.append(assertion_message)
        return pass_state

    def record_abort(self, abort_string):
        """Record abort.
        @param abort_string log msg for abort result
        @return outcome of the assertion
        """
        abort_state = ABORT_STATE
        self.overall_outcome = ABORT
        # assertion message should be printed at the end with a stacktrace of the abort reason
        self.assert_message("TEST ABORTED: See result summary for stack trace", logging.ERROR)
        self.outcomes.append(ABORT_STEP)
        self.assertions.append(abort_string)
        self.testsummary.append(abort_string)
        return abort_state

    def report_result_to_tf(self):
        """Send overall result to a test framework
        """
        self.assert_message("Overall result - %s, %s" % (self.results_title, self.overall_outcome))

    def assert_almost_equal(self, actual, expected, within, check_message):
        """
        Checks if two Float numbers are equal up to decimal places specified in within

        @param actual
        @param expected
        @param within
        @param check_message
        @return:
        """
        max_range = expected + within
        min_range = expected - within
        if min_range <= actual <= max_range:
            assertion_message = "PASS, assert_almost_equal - %s %s in between" \
                                "(%s,%s)" % (check_message, actual, min_range, max_range)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_almost_equal - %s, %s not in " \
                                "between (%s,%s)" % (check_message, actual, min_range, max_range)
            outcome = self.record_fail(assertion_message)
        return outcome

    def assert_not_almost_equal(self, actual, expected, within, check_message):
        """
        @param actual:
        @param expected:
        @param within:
        @param check_message:
        @return:
        """
        max_range = expected + within
        min_range = expected - within
        if not min_range <= actual <= max_range:
            assertion_message = "PASS, assert_not_almost_equal - %s,%s not in between " \
                                "(%s,%s)" % (check_message, actual, min_range, max_range)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_not_almost_equal - %s,%s in between " \
                                "(%s,%s)" % (check_message, actual, min_range, max_range)
            outcome = self.record_fail(assertion_message)
        return outcome

    def assert_not_equal(self, actual, expected, check_message):
        """

        @param actual:
        @param expected:
        @param check_message:
        @return:
        """
        if actual != expected:
            assertion_message = "PASS, assert_not_equal - %s, %s not equal to %s" \
                                % (check_message, actual, expected)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_not_equal - %s, %s equal to %s" \
                                % (check_message, actual, expected)
            outcome = self.record_fail(assertion_message)
        return outcome

    # assert_greater(self, actual, expected_greater_than, check_message)
    def assert_greater(self, actual, expected_greater_than, check_message):
        """

        @param actual:
        @param expected_greater_than:
        @param check_message:
        @return:
        """
        if actual > expected_greater_than:
            assertion_message = "PASS, assert_greater - %s, %s is greater than %s" \
                                % (check_message, actual, expected_greater_than)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_greater - %s, %s is not greater than %s" \
                                % (check_message, actual, expected_greater_than)
            outcome = self.record_fail(assertion_message)
        return outcome

    # assert_greater_or_equal(self, actual, expected_greater_or_equal, check_message)
    def assert_greater_or_equal(self, actual, expected_greater_or_equal, check_message):
        """

        @param actual:
        @param expected_greater_or_equal:
        @param check_message:
        @return:
        """
        if actual >= expected_greater_or_equal:
            assertion_message = "PASS, assert_greater_or_equal - %s, %s is greater than %s" \
                                % (check_message, actual, expected_greater_or_equal)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_greater_or_equal - %s, %s is not greater than %s" \
                                % (check_message, actual, expected_greater_or_equal)
            outcome = self.record_fail(assertion_message)
        return outcome

    # assert_interview(self, expected, check_message, timeout=30)
    def assert_interview(self, expected, check_message, timeout=30):
        """
        #    Ask the user to enter a value or pass/fail outcome
        #    @param expected value require to be entered for a pass to be recorded.
        #    @param check_message String describing the data item to be entered.
        #    @param timeout optional number of seconds to wait for the response.
        #    @return value indicating the outcome of the check.
        #    Useful to write semi automated test scripts.
        """
        entered_input = select.select([stdin], [], [], timeout)[0]
        if entered_input:
                if expected == entered_input:
                    assertion_message = "PASS, assert_interview - %s, %s is equal to %s"\
                                        % (check_message, expected, entered_input)
                    outcome = self.record_pass(assertion_message)
                else:
                    assertion_message = "FAIL, assert_interview - %s, %s is not equal to %s" \
                                        % (check_message, expected, entered_input)
                    outcome = self.record_fail(assertion_message)
        else:
            assertion_message = 'FAIL, assert_interview - Nothing entered,Expected a value of ' \
                                'pass/fail outcome to be entered'
            outcome = self.record_fail(assertion_message)
        return outcome

    # assert_isa(self, actual, expected_class, check_message)
    #        Test and record if a object is of a given class
    def assert_isa(self, actual, expected_class, check_message):
        if isinstance(actual, expected_class):
            assertion_message = "PASS, assert_isa - %s, %s is object of %s"\
                                % (check_message, actual, expected_class)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_isa - %s, %s is not object of %s"\
                                % (check_message, actual, expected_class)
            outcome = self.record_fail(assertion_message)
        return outcome

    #    assert_isa_not(self, actual, expected_class, check_message)
    def assert_isa_not(self, actual, expected_class, check_message):
        if not isinstance(actual, expected_class):
            assertion_message = "PASS, assert_isa_not - %s, %s is not an object of %s"\
                                % (check_message, actual, expected_class)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_isa_not - %s, %s is an object of %s"\
                                % (check_message, actual, expected_class)
            outcome = self.record_fail(assertion_message)
        return outcome

    #    assert_less(self, actual, expected_less_than, check_message)
    def assert_less(self, actual, expected_less_than, check_message):
        if actual < expected_less_than:
            assertion_message = "PASS, assert_less - %s, %s is less than %s"\
                                % (check_message, actual, expected_less_than)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_less - %s, %s is not less than %s" \
                                % (check_message, actual, expected_less_than)
            outcome = self.record_fail(assertion_message)
        return outcome

    #    assert_lessthan_or_equal(self, actual, expected_less_or_equal, check_message)
    def assert_less_than_or_equal(self, actual, expected_less_or_equal, check_message):
        if actual <= expected_less_or_equal:
            assertion_message = "PASS, assert_less_than_or_equal - %s, %s is less than or " \
                                "equal to %s" % (check_message, actual, expected_less_or_equal)
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_less_than_or_equal - %s, %s is not less than " \
                                "or equal to %s" % (check_message, actual, expected_less_or_equal)
            outcome = self.record_fail(assertion_message)
        return outcome

    def assert_not_raises(self, exception, method, assert_message, *args, **kwargs):
        """
        """
        return_value = None
        try:
            exception_name = exception.__name__
        except AttributeError:
            # Exception does not have a __name__
            exception_name = str(exception)

        try:
            return_value = method(*args, **kwargs)
        except exception as exc:
            assertion_message = "FAIL, assert_not_raises - %s, %s raised %s" % (assert_message,
                                                                                str(method),
                                                                                exception_name)
            self.record_fail(assertion_message)
            return_value = exc
        else:
            assertion_message = "PASS, assert_not_raises - %s, %s does not raise %s"\
                                % (assert_message, str(method), exception_name)
            self.record_pass(assertion_message)
        return return_value

    def assert_within_range(self, actual_value, lower_value, higher_value, assert_message):
        """Assert assert_within_range
        @Param actual_value Actual value to check
        @param lower_value lower boundary value
        @param higher_value Upper boundary value
        @param assert_message Assertion message
        """
        if lower_value < actual_value < higher_value :
            assertion_message = "PASS, assert_within_range - %s" % assert_message
            outcome = self.record_pass(assertion_message)
        else:
            assertion_message = "FAIL, assert_within_range - %s" % assert_message
            outcome = self.record_fail(assertion_message)
        return outcome


class TestResultsQuiet(TestResults):
    """
    Result Class for quite assertions.
    """
    def assert_message(self, assertion_message, level=logging.INFO):
        """
        Overridden method to clear string logs to reduce memory usage when many checks are made
        """
        # TODO: Ideally we need to clear self.assertions = [].
        # For now, just make this method not print anything to log
        pass


class TestResultsFailures(TestResults):
    """
    Result Class for failure assertions.
    """
    def assert_message(self, assertion_message, level=logging.INFO):
        """
        Overridden method get only failure log messages
        """
        if 'PASS' not in assertion_message:
            log_method = {logging.INFO: self.log.info, logging.ASSERTION: self.log.assertion,
                          logging.WARNING: self.log.warning, logging.ERROR: self.log.error}
            log_method[level](assertion_message)

    def set_test_title(self, title):
        """Set title of the test results
        Logger created with INFO default log level enabled.
        @param title Test title
        """
        # override logger with title. A log file should be created for this call.
        self.log = logging.getLogger(title)
        self.results_title = title
