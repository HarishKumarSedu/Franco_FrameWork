#!/usr/bin/env python
"""
@brief
Generic test framework base class.

@b Description
This module implements the APIs required by the testbaseclass module.

@b Usage
if __name__ == "__main__":
    from unified_modules.test_support.testresults import TestResults
    from unified_modules.test_support.testframework import TestFramework, TestFrameworkOptions

    OPTIONS = TestFrameworkOptions()

    TEST = BaseTest(TestResults(), TestFramework(OPTIONS))
    return_code, _ = TEST.run()

    sys.exit(return_code)
testlogger.getLogger()
"""

import getpass
import os
import platform
import yaml

import unified_modules.test_support.testlogger as logging
from unified_modules.test_support.testoptions import TestOptions
from unified_modules.test_support.testresourceclaimer import ResourceClaimer
from unified_modules.test_support.testresourcebase import LocalResource
from unified_modules.test_support.testresults import PASS, FAIL, ABORT
from unified_modules.test_support.testutils import rawstring
from unified_modules.results.result_record import ResultRecord


class TestFrameworkOptions(TestOptions):
    def set_test_options(self,
                         target_device='dummy-dut',
                         **kwargs):
        """
        Test options for test framework
        @param target_device - optional device to be tested
        @param kwargs additional params set by inherited classes
        """
        super(TestFrameworkOptions, self).set_existing_options(target_device=target_device)
        super(TestFrameworkOptions, self).add_new_options(kwargs)


class TestFrameworkError(Exception):
    """Base exception for all test framework related errors"""
    pass


class TestFramework(object):
    """Base class for test framework implementation"""
    def __init__(self,
                 run_options=None,
                 target_device='dut',
                 no_log_file=False):
        username = getpass.getuser()
        self.default_results_label = username + '_DEFAULT_RESULTS_LABEL'
        self.results_label = os.environ.get('RESULTS_LABEL_NAME',
                                            self.default_results_label)
        self.results_folder = os.path.join(os.getcwd(), self.results_label)

        log_folder = None
        if not no_log_file:
            log_folder = self.get_log_folder()
        self.log_prefix = self.__class__.__name__
        self.log = logging.getLogger(self.log_prefix,
                                     log_folder=log_folder)
        self.name = None
        self.claimed_resources = {}

        self.local_resources = {}
        self.controller_config_file = None
        self.uses_local_resources = True

        self.local_claimed_resources = {}

        if run_options is None:
            self.run_options = TestFrameworkOptions()
        else:
            self.run_options = run_options
        self.run_options.set_test_options()

        self.target_device = self.run_options.target_device
        if self.target_device == '':
            self.target_device = target_device

        self.resource_claimer = None
        self.result_record = ResultRecord()
        self.outcome = None

        self.startup_done = False
        self.result_record.set_start_time()
        self.result_record.set_results_label(self.results_label)
        if self.results_label == self.default_results_label:
            self.log.info("RESULTS_LABEL_NAME not set, using default %s", self.results_label)

    def get_log_folder(self):
        return self.results_folder

    def startup(self, resource_reqs=None, local_resources=None):
        """
        Claim requested resources and start up the framework
        @param resource_reqs: list of requested resources
        @return: return claimed resources dictionary
        """
        if local_resources is None:
            local_resources = []
        if resource_reqs is None:
            resource_reqs = []

        if self.uses_local_resources:
            self.parse_controller_config()

        if len(local_resources) > 0:
            # Parse local resources config xml file and store in test system.
            # This can be accessed in the test that needs the local resources.
            for req_resource in local_resources:
                matching_resource = self.local_resources[req_resource.res_type]
                resource = req_resource.class_of_resource()
                self.local_claimed_resources.update({req_resource.res_type: LocalResource(
                    resource_tag=req_resource.res_type, resource=resource, config=matching_resource)})
        elif len(resource_reqs) > 0:
            if self.startup_done:
                self.claimed_resources.update(self.resource_claimer.additional_claims(resource_reqs))
                return self.claimed_resources

            self.log.info("Test framework starting up...")
            self.resource_claimer = ResourceClaimer()
            self.result_record.set_resource(platform.uname()[1], platform.uname()[4], "Test Controller")
            self.claimed_resources = self.resource_claimer.claim(resource_reqs)
            if self.claimed_resources != {}:
                self.claim_made = True
                try:
                    host = self.resource_claimer.testhead_client.host
                except AttributeError:
                    raise TestFrameworkError("Unable to read to test head hostname details")

                self.result_record.set_resource(host, "Test Head", "Test Head")
            else:
                self.log.warning("Claim already got some resources, they must all be claimed in one go")

            self.startup_done = True

        return self.claimed_resources

    def shutdown(self):
        if not self.startup_done:
            return

        self.claimed_resources.clear()
        if self.resource_claimer is not None:
            self.resource_claimer.release_testhead()

    def label(self, name):
        if self.name is None:
            self.result_record.set_basic_details(name, self.target_device)
            self.name = name
        self.log.info("TEST NAME: %s", name)

    def get_uses_local_resources(self):
        return self.uses_local_resources

    def set_uses_local_resources(self, local_resources=True):
        self.uses_local_resources = local_resources

    def parse_controller_config(self):
        """ This API will returns resource test_config dictionary of requested test controller resource"""
        # TEST_CONTROLLER_CONFIG is an environment variable pointing to test controller resource config file path
        self.controller_config_file = os.environ.get('TEST_CONTROLLER_CONFIG', None)

        if not self.controller_config_file or not os.path.exists(self.controller_config_file):
            self.log.warning('Test controller config file %s does not exist, '
                             'no controller resources available' % self.controller_config_file)
            return
        self.controller_config_file = rawstring(self.controller_config_file)
        with open(self.controller_config_file, 'r') as stream:
            self.local_resources = yaml.safe_load(stream)

    def get_local_resources(self):
        return self.local_resources

    def get_target_device(self):
        return self.target_device

    def set_target_device(self, target_device):
        self.target_device = target_device

    def set_results_prefix(self, results_prefix):
        self.results_prefix = results_prefix

    def get_results_label(self):
        return self.results_label

    def set_log_file(self, filename):
        self.result_record.logfile = filename

    def test_pass(self, reason):
        return self._test_outcome(PASS, reason)

    def test_fail(self, reason):
        return self._test_outcome(FAIL, reason)

    def test_abort(self, reason):
        return self._test_outcome(ABORT, reason)

    def _test_outcome(self, outcome, reason):
        """
        Collect results and write to the results store
        """
        self.outcome = outcome
        # Set results to write to DB
        self.result_record.set_result(outcome)
        # Set messages to the assertions to be displayed
        self.result_record.set_messages(reason)
        # Write the results to the DB
        self.result_record.set_stop_time()
        self.set_log_file(logging.get_filename())
        self.result_record.set_record_time()
        self.result_record.dump()
        self.result_record.export(prefix=self.results_prefix, export_path=self.results_label)
        self.log.info("Results storage record id: %s", self.result_record.get_test_id())
        if outcome == PASS:
            return 0
        if outcome == FAIL:
            return 1
        if outcome == ABORT:
            return 2
