import os
import sys
if sys.version_info[0] == 3:
    import queue
elif sys.version_info[0] == 2:
    import Queue
import threading
import functools
import logging
from functools import wraps
import traceback
import zipfile
import yaml

from unified_modules.test_support.testlogger import WARNING


def timeout(duration, default=None):
    """TODO:
    http://pythonexample.com/code/python-timeout-decorator-windows/
    """
    def decorator(func):
        class InterruptableThread(threading.Thread):
            def __init__(self, args, kwargs):
                threading.Thread.__init__(self)
                self.args = args
                self.kwargs = kwargs
                self.result = default
                self.daemon = True

            def run(self):
                try:
                    self.result = func(*self.args, **self.kwargs)
                except Exception as exc:
                    raise Exception("While executing function %s,error: %s" % (func.__name__, exc))

        @functools.wraps(func)
        def wrap(*args, **kwargs):
            if (not isinstance(duration, dict)) or duration.get('flag', True):
                it = InterruptableThread(args, kwargs)
                it.start()
                timeout_duration = duration
                if isinstance(duration, dict):
                    timeout_duration = duration['duration']
                it.join(timeout_duration)
                if it.is_alive():
                    logging.warning('timeout ({0} seconds) in function {1}: args: {2}, kwargs: {3}'.format(timeout_duration,
                                                                                                           func, args,
                                                                                                           kwargs))
                return it.result
            else:
                try:
                    func(*args, **kwargs)
                except Exception as exc:
                    raise Exception("While executing function %s,error: %s" % (func.__name__, exc))

        return wrap

    return decorator


def run_async(func, join_async=None, store_result=None, log=None, log_level=WARNING, abort=False):
    """Run any function/method in asynchronous mode
    https://docs.python.org/2/library/multiprocessing.html
    @param func - method to be executed asynchronously
    @param join_async - optional thread to join prior to starting the asynchronous execution
    @param store_result - optional list to store results of joined thread,
    @param log - optional logger, to collect warnings about joining threads that are already ended,
    @param log_level - optional logger level, defaults to WARNING,
    @param abort - optional flag to request exception when joining threads that are already ended.
    """

    if join_async is not None:

        func_orig = func

        def func_join(*args, **kwargs):
            """Extend the provided method to join a specific thread before execution"""
            try:
                result = join_async.join_for_result()

                if store_result is not None:
                    store_result.append(result)

            except AttributeError:
                join_async.join()

            res = func_orig(*args, **kwargs)
            return res

        func = func_join

    # Wrap the given function (func) with asynchronous abilities
    @wraps(func)
    def async_func(*args, **kwargs):
        """Wrapper to allow methods to run asynchronously and get the return value"""
        if sys.version_info[0] == 3:
            result_que = queue.Queue()
        elif sys.version_info[0] == 2:
            result_que = Queue.Queue()
        # Collect the outcome with the lambda function and store it in the result que
        async_thread = threading.Thread(target=lambda result_q_l, args_l, kwargs_l:
                                        result_q_l.put(func(*args_l, **kwargs_l)),
                                        args=(result_que, args, kwargs))
        # add the result que to the thread object
        setattr(async_thread, 'result_queue', result_que)

        # and log and abort flag so join can see them
        setattr(async_thread, 'run_async_log', log)
        setattr(async_thread, 'run_async_abort', abort)
        setattr(async_thread, 'run_async_func_name', func.__name__)

        async_thread.start()

        # Define the method that allows the result to be collected once the thread has completed
        def join_for_result(timeout=None):
            """Join and return the result"""
            log = async_thread.run_async_log
            abort = async_thread.run_async_abort
            func_name = async_thread.run_async_func_name

            if not async_thread.is_alive():
                if log:
                    log.log(log_level, "Asynchronous function (%s) completed before join",
                            func_name)
                else:
                    print("Asynchronous function (%s) completed before join" % func_name)

                if abort:
                    raise TestFrameworkException(
                        "Asynchronous function (%s) completed before join" % func_name)

            async_thread.join(timeout)

            if not async_thread.is_alive():
                result = async_thread.result_queue.get()
            else:
                result = None

            return result

        # and add it to the thread object
        setattr(async_thread, 'join_for_result', join_for_result)
        return async_thread

    return async_func

def rawstring(input_string):
    """Returns a raw string representation of text"""
    escape_dict = {'\a': r'\a',
                   '\b': r'\b',
                   '\c': r'\c',
                   '\f': r'\f',
                   '\n': r'\n',
                   '\r': r'\r',
                   '\t': r'\t',
                   '\v': r'\v',
                   '\'': r'\'',
                   '\"': r'\"',
                   '\0': r'\000',
                   '\1': r'\001',
                   '\2': r'\002',
                   '\3': r'\003',
                   '\4': r'\004',
                   '\5': r'\005',
                   '\6': r'\006'}

    new_string = ''
    for char in input_string:
        try:
            new_string += escape_dict[char]
        except KeyError:
            new_string += char
    return new_string


def get_stack_trace(full_stack=False):
    """Provide the stack trace string"""
    if full_stack:
        return traceback.format_exc()
    else:
        return str(sys.exc_info())


def dict_from_class(class_obj):
    """Simple method to convert a class object to a dictionary
       @param class_obj class_obj input"""
    return dict((key, value)
                for (key, value) in class_obj.__dict__.items())


def return_list_from_generator(generator_object):
    """
    Decorator function which calls the generator with given arguments
    and returns the values returned yielded in each in each call as list.
    @param generator_object: Generator object
    """
    def wrapper(*args, **kwargs):
        return_value = list(generator_object(*args, **kwargs))
        return return_value
    return wrapper

def unzip(path_to_zip_file, directory_to_extract_to):
    """
    Extracting ZIP file content to required directory
    :param path_to_zip_file:
    :param directory_to_extract_to:
    :return:
    """
    zip_ref = zipfile.ZipFile(path_to_zip_file, 'r')
    zip_ref.extractall(directory_to_extract_to)
    zip_ref.close()


class ThreadWithReturnValue(object):
    """
    Class for thread running a thread and get its return value
    """
    def __init__(self, target=None, args=(), **kwargs):
        if sys.version_info[0] == 3:
            self._que = queue.Queue()
        elif sys.version_info[0] == 2:
            self._que = Queue.Queue()
        self._t = threading.Thread(target=lambda q,arg1,kwargs1: q.put(target(*arg1, **kwargs1)),
                                   args=(self._que, args, kwargs),)
        self._t.start()

    def join(self):
        self._t.join()
        return self._que.get()


def get_files_by_extension(dir_path, file_extension):
    """
    Get list of all files (with specific file extension) in a directory
    @param dir_path directory to search the files
    @param file_extension file extension
    @return returns all files with paths
    """
    file_paths = []
    for root, dirs, files in os.walk(dir_path):
        for f in files:
            if f.endswith(file_extension):
                file_paths.append(os.path.join(root, f))
    return file_paths


def load_yaml_file(file_path):
    """
    This file load the YAML file and return the data
    @param file_path: YML file path
    @return: yaml data in dictionary
    """
    if not os.path.exists(file_path):
        print("Config file '%s' not found" % file_path)
    else:
        with open(file_path, 'r') as stream:
            config = yaml.safe_load(stream)
            return config
