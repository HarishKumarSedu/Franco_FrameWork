import os
import sys
import argparse
import socket
import select
from threading import Thread
import tempfile
import subprocess
import xml.etree.ElementTree as ET
import yaml
import time

import unified_modules.test_support.testlogger as logging


class TestHeadConfigParser(object):
    """
    Parser for test head configuration file
    """
    def __init__(self, resource_config_yml):
        resource_config_yml = self.rawstring(resource_config_yml)
        if not os.path.exists(resource_config_yml):
            raise OSError('File : %s not found ' % resource_config_yml)
        with open(resource_config_yml, "r") as config_handle:
            self.resource_pool = yaml.safe_load(config_handle)

    @staticmethod
    def rawstring(input_string):
        """Returns a raw string representation of text"""
        escape_dict = {'\a': r'\a',
                       '\b': r'\b',
                       '\c': r'\c',
                       '\f': r'\f',
                       '\n': r'\n',
                       '\r': r'\r',
                       '\t': r'\t',
                       '\v': r'\v',
                       '\'': r'\'',
                       '\"': r'\"',
                       '\0': r'\000',
                       '\1': r'\001',
                       '\2': r'\002',
                       '\3': r'\003',
                       '\4': r'\004',
                       '\5': r'\005',
                       '\6': r'\006'}

        new_string = ''
        for char in input_string:
            try:
                new_string += escape_dict[char]
            except KeyError:
                new_string += char
        return new_string


class TestHeadServerClient(object):
    def __init__(self, ip, port, client_socket):
        self.should_terminate = False
        self.ip = ip
        self.port = port
        self.tag = ":".join([ip, str(port)])
        self.socket = client_socket
        self.thread = None
        self.resources = {}

    def stop(self):
        if self.socket:
            self.socket.close()
            self.socket = None
        for _, resource in self.resources.items():
            resource.should_terminate = True
        self.thread = None


class TestHeadServerResource(object):
    def __init__(self, client, resource_type, port):
        self.should_terminate = False
        self.client = client
        self.type = resource_type
        self.command = None
        self.port = port
        self.socket = None
        self.thread = None
        self.log_file = None
        self.process = None

    def stop(self):
        if self.process:
            self.process.kill()
            self.process = None
        if self.log_file:
            self.log_file.close()
            self.log_file = None
        if self.socket:
            self.socket.close()
            self.socket = None
        self.thread = None


class TestHeadServer(object):
    def __init__(self, ip, port, config_path):
        if ip:
            self.ip = ip
        else:
            self.hostname = socket.gethostname()
            self.ip = socket.gethostbyname(self.hostname)
        self.port = port

        self.socket = None
        self.response_end = "Response complete."
        self.response_fail = "Bad command."
        self.clients = {}

        config_parser = TestHeadConfigParser(config_path)
        self.resource_pool = config_parser.resource_pool

        self.should_terminate = False

    def run(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as error:
            print("Socket creation failed: %s" % str(error))
            return 1

        print("Server socket creation complete")
        # According UNIX-like OS socket handling
        # socket must be set to be reusable
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            self.socket.bind((self.ip, self.port))
        except socket.error as error:
            print("Socket bind failed: %s" % str(error))
            return 1

        print("Server socket bind complete (%s:%s)" % (self.ip, self.port))
        # Listen for max. 10 clients
        self.socket.listen(10)
        print("Server socket now listening")

        while not self.should_terminate:
            try:
                rlist, _, _ = select.select([self.socket], [], [], 1.0)
            except KeyboardInterrupt:
                print("Server interrupted by user!")
                self.should_terminate = True
                continue
            # No input event: should we terminate?
            if not rlist:
                continue

            client_socket, (ip, port) = self.socket.accept()
            print("Accepted connection request from %s:%s" % (ip, port))
            client = TestHeadServerClient(ip, port, client_socket)
            client.socket.send('Connect OK, Data:%s %s End' % (ip, port))
            client.thread = Thread(target=self.on_new_client, args=(client,),
                                   name='%s-client' % client.tag)
            client.thread.start()

            print("Client thread %s started" % client.tag)

            self.clients[client.tag] = client

        self.socket.close()
        print("Server socket closed")
        self.socket = None
        # Make sure we close every client connections
        for _, client in self.clients.items():
            client.should_terminate = True

        return 0

    def _find_available_port(self):
        """
        Finds the first available TCP port.

        Returns:
            int: the port number.
        """
        temporary_socket = socket.socket(socket.AF_INET,
                                         socket.SOCK_STREAM)
        temporary_socket.bind((self.ip, 0))
        _, port = temporary_socket.getsockname()
        temporary_socket.close()

        return port

    def _list_command(self):
        """
        Implements the 'list' client command.
        """
        return "\r\n".join([
            str(self.resource_pool),
            self.response_end
        ])

    def _help_command(self):
        """
        Implements the 'help' client command.
        """
        return "\r\n".join([
            'Some useful commands:', 'list', 'help',
            self.response_end
        ])

    def _start_command(self, client, resource_type):
        """
        Implements the 'start' client command.
        """
        if resource_type not in self.resource_pool:
            print("For", client.tag, resource_type, "is not available...")
            return self.response_fail

        resource_port = self._find_available_port()
        resource_command = self.resource_pool[resource_type]['command']

        try:
            resource_socket = socket.socket(socket.AF_INET,
                                            socket.SOCK_STREAM)
        except IOError as error:
            print("For", client.tag, resource_type, "socket creation failed: %s" % str(error))
            return self.response_fail

        print("For", client.tag, resource_type, "socket creation complete")
        # Enforce SO_REUSEADDR for that socket
        resource_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            resource_socket.bind((self.ip, resource_port))
        except IOError as error:
            print("For", client.tag, resource_type, "socket bind failed: %s" % str(error))
            return self.response_fail

        print("For", client.tag, resource_type, "socket bind complete")
        # Only one client is allowed per resource
        resource_socket.listen(1)
        print("For", client.tag, resource_type, "socket now listening")

        resource = TestHeadServerResource(client, resource_type, resource_port)
        resource.command = resource_command.strip()
        resource.thread = Thread(target=self.on_new_resource_client,
                                 args=(resource_socket, resource),
                                 name='%s-client-%s' % (client.tag, resource_type))
        resource.thread.start()

        client.resources[resource_type] = resource

        return 'Started: OK %s %s' % (self.ip, resource_port)

    def on_new_client(self, client):
        """
        Handles new client, runs in a thread.

        Args:
            :obj:`TestHeadServerClient`: the incoming client object.
        """
        while not client.should_terminate:
            rlist, _, _ = select.select([client.socket], [], [client.socket], 1.0)
            # No input event: should we terminate?
            if not rlist:
                continue

            try:
                command = client.socket.recv(1024).strip()
            except IOError as error:
                print("From", client.tag, "got", str(error))
                client.should_terminate = True
                continue

            print("From", client.tag, "received command:", command)

            if command == 'quit':
                client.socket.send('Connection closed.')
                client.should_terminate = True
            elif command == 'terminate':
                client.socket.send('Connection closed.')
                client.should_terminate = True
                self.should_terminate = True
            elif command == 'list':
                client.socket.send(self._list_command())
            elif command == 'help':
                client.socket.send(self._help_command())
            elif command.startswith('start'):
                try:
                    _, resource_type = command.split()
                except ValueError as error:
                    print("Failed parsing command:  %s" % str(error))
                    client.socket.send(self.response_fail)
                    continue

                client.socket.send(self._start_command(client, resource_type))

        time.sleep(0.3)

        client.stop()

    def _xmlrpc_start_command(self, resource):
        """
        Implements the 'xmlrpc_start' resrouce client command.
        """
        xmlrpc_port = self._find_available_port()
        command_line = [
            'xmlrpc_start',
            '--host', self.ip,
            '--port', str(xmlrpc_port),
        ]

        try:
            resource.process.stdin.write(' '.join(command_line) + '\n')
            resource.process.stdin.flush()
        except IOError as error:
            return 'xmlrpc_start failed, err:%s' % str(error)

        return 'xmlrpc_start: OK %s %s' % (self.ip, xmlrpc_port)

    def _cli_quit_command(self, resource):
        """
        Implements the 'cli_quit' resrouce client command.
        """
        resource.process.kill()
        resource.process = None

        resource.log_file.seek(0)
        # ToDo: We shouldn'thave resource specific code here...
        if 'resource_squish' not in resource.command:
            log_content = resource.log_file.read()
            response = 'RpcServer logs:\n===============\n%s' % log_content
        else:
            log_content = resource.log_file.readlines()
            log_content = [line for line in log_content if 'AUT stderr' not in line]
            response = 'RpcServer logs:\n===============\n%s' % ''.join(log_content)
        resource.log_file.close()
        resource.log_file = None

        return response + '\ncli_quit: OK'

    def on_new_resource_client(self, server_socket, resource):
        """
        Handles new resource client, runs in a thread.
        """
        client_socket = None
        # We expect/allow/handle only one connection here
        while server_socket and resource.client.socket:
            rlist, _, _ = select.select([server_socket], [], [], 1.0)
            if not rlist:
                continue
            client_socket, _ = server_socket.accept()
            break

        if not client_socket:
            server_socket.close()
            return

        log_file = tempfile.TemporaryFile()
        command_line = resource.command.split()
        command_line[0] = sys.executable
        process = subprocess.Popen(command_line, stdin=subprocess.PIPE,
                                   stdout=log_file, stderr=log_file)

        time.sleep(0.3)

        resource.socket = client_socket
        resource.log_file = log_file
        resource.process = process

        while not resource.should_terminate:
            rlist, _, _ = select.select([resource.socket], [], [], 1.0)
            # No input event: should we terminate?
            if not rlist:
                continue

            try:
                command = resource.socket.recv(1024).strip()
            except IOError as error:
                resource.should_terminate = True
                continue

            print("From", resource.client.tag, "for", resource.type, "received command:", command)

            if command == 'quit':
                self._send(resource.socket, 'quit: OK')
                resource.should_terminate = True
            elif command == 'xmlrpc_start':
                response = self._xmlrpc_start_command(resource)
                self._send(resource.socket, response)
            elif command.startswith('cli_quit'):
                response = self._cli_quit_command(resource)
                self._send(resource.socket, response)
                resource.should_terminate = True

        server_socket.close()
        server_socket = None

        resource.stop()

    def _send(self, write_socket, message):
        already_sent = 0
        while already_sent < len(message):
            already_sent += write_socket.send(message[already_sent:])


def main():
    parser = argparse.ArgumentParser(description='Unified Modules test-head server.')
    parser.add_argument('-i', '--ip',
                        help='test-head daemon server ip address',
                        type=str, default=None, required=False)
    parser.add_argument('-p', '--port',
                        help='test-head daemon server port number',
                        type=int, default=8888, required=False)
    parser.add_argument('-c', '--config',
                        help='test-head daemon server configuration file path',
                        type=str, required=True)

    options = parser.parse_args()

    print("Server socket ip address:", options.ip)
    print("Server socket port:", options.port)
    print("Server configuration file:", options.config)

    testhead_server = TestHeadServer(options.ip, options.port, options.config)
    return_code = testhead_server.run()

    sys.exit(return_code)


if __name__ == '__main__':
    main()
