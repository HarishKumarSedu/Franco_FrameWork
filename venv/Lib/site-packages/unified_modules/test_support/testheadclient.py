#!/usr/bin/env python
"""

@brief
Python client for access to a remote instance of test daemon server running on a test machine.

@details
@b Description

- Each resource requires a session with the test daemon server.
- All interaction with test daemon server is request/response and no asynchronous commands support

Features:
- Makes a client connection to a remote test_daemon session
- Sends commands over this socket connection and waits for anticipated responses
- start_resource method, returns host and port to interact with the resource over stdio
- A command method that returns results in python dictionary or list format
- A command method that does not return any information back, returns true or false
@b Usage
@code
import TestHeadClient
session = TestHeadClient(hostname, port=9999, timeout=600)
To run the unit test:
python test_daemon.py --unittest
@endcode
"""

from __future__ import print_function

import os
import sys
import argparse
import inspect
import socket
import re
from traceback import format_exc
from time import sleep

import unified_modules.test_support.testlogger as logging


class TestHeadClientError(Exception):
    """Define TestHeadClient Exception type"""
    pass


class TestHeadClient(object):
    """
    Provide access to Test head server via client connection
    """
    def __init__(self,
                 host,
                 port=8888,
                 timeout=600,
                 verbose=False):
        """Initialise session with test remote server
        """
        self.host = host
        if not self.host:
            self.host = socket.gethostname()
        self.port = int(port)
        self.timeout = timeout
        self.verbose = verbose
        self.os_type = ""
        self.resources_pool = {}

        # Store last transaction information
        self.last_match_obj = None
        self.last_match_id = None
        self.last_match_output = None

        # Handle to communicate with TestHeadServer
        self.test_client = None
        self.log = logging.getLogger("%s-%s" % (self.__class__.__name__, host))
        self.response_end = 'Response complete.'
        self.response_fail = 'Bad command.*'
        self.client_port = None
        self.released = False

        # invoke connection
        self.startup()

    def startup(self):
        """Create the telnet connection to test head"""
        if self.test_client is None:
            # Connect to a remote test_daemon instance with telnet
            import telnetlib
            try:
                self.test_client = telnetlib.Telnet(self.host, self.port, self.timeout)
                # TODO: store this port number for this session.
                response = self.test_client.expect([".*End.*"], 1)
                temp = response[2].split(',')
                for item in temp:
                    if "Data" in item:
                        item = item.strip()
                        item = item.replace('Data:', "")
                        item = item.replace('End', "")

                        client_host, self.client_port, _ = item.split(" ")

                        self.client_port = self.client_port.strip()
                self.log.info("connect successful to testhead: %s:%s", client_host, self.client_port)

            except socket.error as sock_err:
                raise TestHeadClientError("socket.error: Unable to connect to %s:%s - %s %s" % (
                    self.host,
                    self.port,
                    str(sock_err),
                    format_exc()))
        else:
            self.log.warning("test_client session is already established")

    def close(self):
        """Close the telnet connection, no params"""
        return self.test_client.close()

    def send(self, *args, **kwargs):
        """Send commands to the test_daemon connection
        Store the response in the test_daemon object
            last_match_id provides the index to the expected response list
            last_match_obj the match object
            last_match_output - text read up till and including the match
        @param *args - all positional arguments are concatenated to for the command.
        @param expected_response_end keyword - provide the list of possible responses.
        @return status bool - True indicates success
        """
        try:
            expected_response_end = kwargs['expected_response_end']
        except KeyError:
            # Default success and failure completion
            expected_response_end = ['Response complete.',
                                     'Bad command.*']
        try:
            timeout = kwargs['timeout']
        except KeyError:
            # set timeout to 5s by default
            timeout = 5

        command = ' '.join(args)+'\n'
        try:
            self.test_client.write(command)
            response = self.test_client.expect(expected_response_end, timeout=timeout)
        except (AttributeError, socket.error):
            raise TestHeadClientError("ERROR: Unable to send command to test head at %s:%s" % (self.host, self.port))

        (self.last_match_id,
         self.last_match_obj,
         self.last_match_output) = response

        if self.verbose:
            self.log.info("command:%s, last match id = %d, last matched output:%s", command, self.last_match_id, self.last_match_output)

        if self.last_match_id == -1:
            raise TestHeadClientError("ERROR: unexpected response from %s, %s" % (command, self.last_match_output))

        # the first regex in expected_response_end indicates success i.e. 0
        status = self.last_match_id == 0
        return status

    def list(self):
        """Provide the list of resources
        @return dictionary of all resources indexed by resource name
       """
        import ast
        self.send(inspect.currentframe().f_code.co_name)
        resources = ast.literal_eval(re.findall('.*}', self.last_match_output)[0])
        self.resources_pool = resources
        return self.resources_pool

    def start(self, res_type):
        """Start the resource currently claimed, optionally supplying
        additional arguments
        @param args - arguments to be passed to the resource on start, optional
        @return status bool - True indicates success
        """
        self.log.info("START %s", str(res_type))
        status = self.send(inspect.currentframe().f_code.co_name, res_type,
                           expected_response_end=[r'Started: OK.*',
                                                  r'Bad command.*'])
        self.log.info("start resource response %s exp out: %s", status, self.last_match_output)
        host_port = re.search("Started: OK ([.\d]+) (\d+).*", self.last_match_output)
        host, port = host_port.group(1), host_port.group(2)
        return host, port

    def run(self, cmd=""):
        """Start the resource currently claimed with an arbitrary command.
        @param cmd - command to run instead of that in the command tag
        @return status bool - True indicates success
        """
        status = self.send(inspect.currentframe().f_code.co_name,
                           cmd,
                           expected_response_end=[r'started.',
                                                  r'Resource still running.*',
                                                  r'start failed.*',
                                                  r'Bad command.*'
                                                  r'ERROR in start_connection_backend.*'])
        return status

    def stop_resource(self):
        """Stop the resource currently claimed.
        @return status bool - True indicates success
        """
        status = self.send(inspect.currentframe().f_code.co_name,
                           expected_response_end=[r'Backend exited.',
                                                  r'Bad command.*',
                                                  r'Resource not running'])
        return status

    def quit(self):
        """Clean up and exit a connection.
        This stops and frees any resources as appropriate.
        @return status bool - True indicates success
        """
        status = self.send(inspect.currentframe().f_code.co_name,
                           expected_response_end=[r'Connection closed.',
                                                  r'Bad command.*'])
        self.close()
        return status

    def terminate(self):
        """Clean up and exit a connection, requesting server to terminate.
        This stops and frees any resources as appropriate.
        @return status bool - True indicates success
        """
        status = self.send(inspect.currentframe().f_code.co_name,
                           expected_response_end=[r'Connection closed.',
                                                  r'Bad command.*'])
        self.close()
        return status

    def help(self):
        """Help message.
        @return help string - text returned by help command
        """
        self.send(inspect.currentframe().f_code.co_name)
        return self.last_match_output


def main():
    parser = argparse.ArgumentParser(description='Unified Modules test-head client.')
    subparsers = parser.add_subparsers(help='available commands')

    list_parser = subparsers.add_parser('list',
                                        help='list available resources')
    list_parser.set_defaults(
        func=lambda options: setattr(options, 'command','list'))

    terminate_parser = subparsers.add_parser('terminate',
                                             help='request server teardown')
    terminate_parser.set_defaults(
        func=lambda options: setattr(options, 'command','terminate'))

    parser.add_argument('-H', '--host',
                        help='test-head server host name or IP address',
                        type=str, default=None, required=False)
    parser.add_argument('-p', '--port',
                        help='test-head server port number',
                        type=int, default=8888, required=False)
    parser.add_argument('-t', '--timeout',
                        help='connection timeout in seconds',
                        type=int, default=3, required=False)

    options = parser.parse_args()
    options.func(options)

    if not hasattr(options, 'command'):
        print('Specifying a command is mandatory, see --help')
        sys.exit(1)

    try:
        testhead_client = TestHeadClient(options.host,
                                         port=options.port,
                                         timeout=options.timeout)
    except TestHeadClientError as error:
        print("Connection failed:", str(error))
        sys.exit(1)

    if options.command == 'list':
        resources = testhead_client.list()
        for resource_name, _ in resources.items():
            print(resource_name)
    elif options.command == 'terminate':
        testhead_client.terminate()

    try:
        if options.command != 'terminate':
            testhead_client.quit()
    except TestHeadClientError as error:
        print("Disconnection failed:", str(error))
        sys.exit(2)

    sys.exit(0)


if __name__ == '__main__':
    main()
