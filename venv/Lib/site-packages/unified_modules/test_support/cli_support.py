#!/usr/bin/env python
"""
@brief
Automatic command line option generator for python classes

@details
@b Description
This class initialises optparse to provide a parser for command line options
for the given class.

The following features are provided to enable command line access to objects:
- Creates an option for the --execute switch for each method exposed
- Help for parameter takes descriptions from docstrings
- Help for --execute includes all valid parameters for each command

@b Usage
Add command line options for a class through multiple inheritance, the
        command line help is derived from docstrings, the first non blank
        in the docstring for each method is used in the help for that
        method, parameters are included in the help.
@code
    import cli_support\n
    class MyClassCli(cli_support.cliOptions, ClassToAddCliTo):\n
        def __init__(self, *args, **kwargs):\n
            cli_support.CliOptions.__init__(self,\n
                                        ClassToAddCliTo,\n
                                        [self.methods_to_expose])\n
            ClassToAddCliTo.__init__(self, *args, **kwargs)\n
    RUN = MyClassCli()
@endcode

"""


from inspect import getargspec
from optparse import (OptionParser, IndentedHelpFormatter, OptionConflictError)
import inspect
import textwrap
from traceback import print_exc
import re
import sys


def expose(func):
    """Decorator to set exposed flag on a function."""
    try:
        # class methods are accessed like this
        func.__func__.exposed = True
    except AttributeError:
        # static methods are accessed like this
        func.exposed = True
    return func


def is_exposed(func):
    '''Test whether another function should be publicly exposed.'''
    return getattr(func, 'exposed', False)


class IndentedHelpFormatterWithNL(IndentedHelpFormatter):
    """Add newline function to IndentedHelpFormatter"""
    def format_description(self, description):
        """Added new line functionality"""
        if not description:
            return ""
        desc_width = self.width - self.current_indent
        indent = " " * self.current_indent

        bits = description.split('\n')
        formatted_bits = [textwrap.fill(bit,
                                        desc_width,
                                        initial_indent=indent,
                                        subsequent_indent=indent)
                          for bit in bits]
        result = "\n".join(formatted_bits) + "\n"
        return result

    def format_option(self, option):
        """Added new line functionality"""
        self.help_width = 160
        result = []
        opts = self.option_strings[option]
        opt_width = self.help_position - self.current_indent - 2
        if len(opts) > opt_width:
            opts = "%*s%s\n" % (self.current_indent, "", opts)
            indent_first = self.help_position
        else:
            # start help on same line as opts
            opts = "%*s%-*s  " % (self.current_indent, "", opt_width, opts)
            indent_first = 0
        result.append(opts)
        if option.help:
            help_text = self.expand_default(option)

            help_lines = []
            for para in help_text.split("\n"):
                help_lines.extend(textwrap.wrap(para, self.help_width))

            result.append("%*s%s\n" % (indent_first, "", help_lines[0]))
            result.extend(["%*s%s\n" % (self.help_position, "", line)
                           for line in help_lines[1:]])

        elif opts[-1] != "\n":
            result.append("\n")
        return "".join(result)


class CliOptions(object):
    """
    Inherit from this class to enable automatic command line option generation
    on any python class.
    For this to work well:
        Method parameters should be uniquely named
        Method parameters should documented in the docstring for the method
        Pass the class to this object for self documentation in help

    Note:
        All parameters provided on the command line are presented to the
        methods as strings
    """

    def __init__(self, class_to_enable=None, expose_method_list=None):

        # valid arguments for each method
        self.cli_valid_args = {}

        # references to all methods
        self.cli_command_access = {}

        # reference to parsed options.
        self.cli_options = None

        # reference to option parser.
        self.cli_parser = None

        # list of methods to be exposed in CLI.
        self.cli_expose_method_list = []

        # xmlrpc server handle
        self.xmlrpc_server = None

        # Get a list of methods and static methods exposed by decorator
        for (method_name,
             method) in (inspect.getmembers(self,
                                            predicate=inspect.ismethod) +
                         inspect.getmembers(self,
                                            predicate=inspect.isfunction)):

            if not method_name.startswith('_') and is_exposed(method):
                self.cli_expose_method_list.append(method)

        # Also add passed list of methods to expose, set exposed attribute
        if expose_method_list:
            for method in expose_method_list:
                expose(method)
                self.cli_expose_method_list.append(method)

        # class to enable a CLI for.
        self.cli_class_to_enable = class_to_enable

        self.cli_prepare_option_parser()
        self.cli_action_on_command_line()

    @expose
    def xmlrpc_start(self, host, port):
        """Start resource as XMLRPC server"""
        try:
            from unified_modules.test_support.xmlrpc_support import RpcServer
            print("xmlrpc_start: OK", host, port)
            sys.stdout.flush()
            self.xmlrpc_server = RpcServer(self.cli_class_to_enable,
                                           self.cli_class_to_enable.__name__,
                                           (host, int(port)))

            # Not started in a thead, use XMLRPC call to teminate
            sys.stdout.flush()
            self.xmlrpc_server.run()

        except ImportError as error:
            print("xmlrpc_start: FAIL XMLRPC Not available, %s" % error)
            print(sys.path)
            sys.stdout.flush()

    # TODO: write method to stop xmlrpc stop , send remote session id to this as input.

    def cli_prepare_option_parser(self):
        """Configure the option parser with introspection"""
        if self.cli_class_to_enable is not None:
            class_description = self.cli_class_to_enable.__doc__
        else:
            class_description = self.__doc__

        self.cli_parser = OptionParser(description=class_description,
                                       formatter=IndentedHelpFormatterWithNL())

        # Init may not have been called in multiple inheritance usage
        self.cli_command_access = {}
        self.cli_valid_args = {}

        command_help = ""
        method_doc = {}
        param_doc = {}

        # Construct the help for execute command
        for method in self.cli_expose_method_list:

            if is_exposed(method):
                # are the args set in annotations as they would be for remote
                args = getattr(method, '__annotations__', False)

                # no? then get the argspec
                if not args:
                    argspec = getargspec(method)
                    (args,
                     dummy,
                     dummy,
                     dummy) = argspec

                # Extract the doc string to document the parameters later
                # Split into a list of lines
                try:
                    method_doc[method] = method.__doc__.split('\n')
                except AttributeError:
                    # No documentation
                    method_doc[method] = []

                # Get the documentation for this method.
                # First non-blank line in docstring
                method_str = ""
                for doc_line in method_doc[method]:
                    # First line containing non white space character
                    matched_doc = re.search(r'^.*\S.*$', doc_line)
                    if matched_doc:
                        # removed doxygen strings
                        method_str = matched_doc.group()
                        # removed doxygen strings
                        method_str = re.sub(r'\@method +', r'', method_str)
                        break

                # Remember references to methods
                self.cli_command_access[method] = method

                # Construct the help message for execute
                command_help = (command_help + "\n --execute " +
                                method.__name__ + " ")

                self.cli_valid_args[method] = []

                for argument in args:
                    if (argument is not "self") and (not argument.startswith('_')):
                        command_help = command_help + "--" + argument + " "

                        # remember valid arguments for this method
                        self.cli_valid_args[method].append(argument)

                        # Look for documentation for this parameter
                        for doc_line in method_doc[method]:
                            matched_doc = re.search((r' *' + argument +
                                                     r' *[\-:] *(.*)'),
                                                    doc_line)

                            if matched_doc:
                                # removed doxygen strings
                                param_doc_str = matched_doc.group(1)
                                param_doc_str = re.sub(r'\@par +',
                                                       r'',
                                                       param_doc_str)

                                # Warn if already documented differently
                                if argument in param_doc.keys():
                                    if param_doc[argument] != param_doc_str:
                                        warn_str = ("WARNING: same parameter name with different "
                                                    "documentation for " +
                                                    argument +
                                                    "(" + param_doc[argument] + ")" +
                                                    "(" + matched_doc.group(1) + ")")
                                        print(warn_str)

                                param_doc[argument] = param_doc_str

                                # Check method documentation does not
                                # duplicate this
                                matched_doc = re.search((r' *' + argument +r' *[\-:] *(.*)'),
                                                        method_str)
                                if matched_doc:
                                    method_str = ""

                        try:
                            doc_string = param_doc[argument]
                        except KeyError:
                            doc_string = "Not documented in docstring"

                        try:
                            self.cli_parser.add_option("--%s" % argument,
                                                           help=doc_string)
                        except OptionConflictError:
                            # Already warned about conflicting parameters
                            pass

                if method_str != "":
                    command_help += "(" + method_str + ")"

        # add options for execute and interactive mode
        self.cli_parser.add_option("--execute", help="Run a command " + command_help)
        self.cli_parser.add_option("--interactive",help="Run interactive mode", action="store_false")

    def cli_action_on_command_line(self):
        """Act on the command line options"""
        (self.cli_options, dummy) = self.cli_parser.parse_args()
        # TODO, Low priority: After command line processing see if any parameters are set in environment variables
        if sys.version_info[0] == 3:
            cli_options_items = self.cli_options.__dict__.items()
        elif sys.version_info[0] == 2:
            cli_options_items = self.cli_options.__dict__.iteritems()
        for (keyword, value) in cli_options_items:
            if (keyword == 'execute') and (value is not None):
                self.cli_execute_method()
                break
            if (keyword == 'interactive') and (value is not None):
                self.cli_interactive_mode()
                break

    def cli_interactive_mode(self):
        """Take repeated commands (in command line options format) to
        call methods"""
        print("Interactive mode for %s" % self.__class__)
        input_line = ""

        while input_line != "quit":
            try:
                if sys.version_info[0] == 3:
                    input_line = input()
                elif sys.version_info[0] == 2:
                    input_line = raw_input()
            except EOFError:
                input_line = 'quit'

            if input_line != 'xmlrpc_start':
                try:
                    self.cli_act_on_input(input_line)
                #pylint: disable=broad-except
                # OK if we print the error details
                except Exception:
                    print_exc()
            else:
                # Do not catch exceptions when running xmlrpc
                self.cli_act_on_input(input_line)

    def cli_act_on_input(self, input_line):
        """The method to call with the input command line"""
        aliases = {'?': 'help',
                   'h': 'help'}
        try:
            input_line = aliases[input_line]
        except KeyError:
            pass

        if (input_line != 'quit') and (input_line != ""):
            if input_line != 'help':
                # Split by spaces but not those enclosed in quotes
                command = ["--execute"]
                # First character set defines a word
                command += re.findall(r'([A-Za-z0-9_\-\\\/\.]+|["\'].*?["\'])',
                                      input_line)

                (self.cli_options,
                 dummy) = self.cli_parser.parse_args(command)
                self.cli_execute_method()
            else:
                store_execute_option = self.cli_parser.get_option("--execute")
                store_help_option = self.cli_parser.get_option("--help")
                self.cli_parser.remove_option("--execute")
                self.cli_parser.remove_option("--help")
                print("  h, ?, help         help")
                print("  CTRL-D             quit")
                self.cli_parser.print_help()
                self.cli_parser.add_option(store_execute_option)
                self.cli_parser.add_option(store_help_option)

    def cli_execute_method(self):
        """Call the method to execute the command"""
        # prepare the parameters for the function call
        params = {}

        try:
            method = getattr(self, self.cli_options.execute)
        except AttributeError:
            print("\nNameError: method '%s' is not defined" % self.cli_options.execute)
        else:
            # Only attempt this if we got the method and not an exception
            if method in self.cli_command_access:
                if sys.version_info[0] == 3:
                    cli_options_items = self.cli_options.__dict__.items()
                elif sys.version_info[0] == 2:
                    cli_options_items = self.cli_options.__dict__.iteritems()
                # Only attempt this if the method has been exposed
                for (keyword,
                     value) in cli_options_items:
                    # value must be set, valid args for this command

                    if ((value is not None) and
                            (keyword != 'execute') and
                            (keyword in self.cli_valid_args[method])):

                        params[keyword] = value

                self.cli_command_access[method](**params)

            else:
                print("\nNameError: method '%s' is not exposed" % method)
