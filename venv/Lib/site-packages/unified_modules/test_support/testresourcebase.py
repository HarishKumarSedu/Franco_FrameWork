#!/usr/bin/env python
"""
@brief
Python common resource library base class.

@b Usage
@code
from resourcebase import ResourceBase
class MyResource(ResourceBase)
or
resr = ResourceBase(tag='dut')
@endcode
"""
import os
import sys
import re
import telnetlib
import socket
from subprocess import Popen
import time
from threading import Thread
import atexit

from unified_modules.test_support.testheadclient import TestHeadClient, TestHeadClientError
import unified_modules.test_support.testlogger as logging


# Max number of responses held in parsing buffer
MAX_RESPONSE_TEXT_BUFFER_SIZE = 1000
# Size to limit responses in the parsing buffer
MAX_SINGLE_RESONSE_SIZE = 56*1024


class ResourceError(Exception):
    """Base exception for all resource related errors"""
    pass


class ResourceBase(object):
    """Resource base class"""

    def __init__(self, res_type, tag=None, testhead=None, config=None, verbose=True):
        """
        """

        self.testhead = testhead
        self.xmlrpc_client = self
        self.res_type = res_type

        if tag:
            self.tag = tag
        else:
            self.tag = self.__class__.__name__

        if testhead:
            self.host = testhead.host
            self.port = testhead.port
        else:
            self.host = None
            self.port = None

        self.verbose = verbose

        self.response_text = []
        self.response_id = 0
        self.response_checked = -1
        self.config = config
        self.log = logging.getLogger(self.tag)

        if self.host and self.port:
            (host, self.port) = self.testhead.start(res_type)
            self.session = telnetlib.Telnet(self.testhead.host, self.port, 60)
        else:
            error = "Unable to start resource %s, host or port value not supplied" % (res_type)
            self.log.warning(error)
            raise ResourceError(error)

        # Start incoming data logger
        self.response_handler = Thread(target=self.event_generator,
                                       name="%s-response-handler" % self.tag)
        self.response_handler.daemon = True
        self.response_handler.start()

    def cli_quit(self):
        """

        :return:
        """

        # Request server stop
        self.send('cli_quit')
        exp_response = "cli_quit: OK"
        response = self.expect_line(exp_response)
        if response:
            if response not in exp_response:
                raise ResourceError("Unable to stop the remote cli session for resource %s" % self.res_type)
        else:
            raise ResourceError("Did not receive expected response: %s" % exp_response)

    def create_xmlrpc(self):
        """

        :return:
        """
        # Request server start
        self.send('xmlrpc_start')
        host_port = self.expect_line("xmlrpc_start: OK", timeout=5)
        if host_port:
            try:
                host_port = re.findall(r'xmlrpc_start: OK ([^ ]*) ([0-9]*)', host_port)
            except TypeError:
                raise ResourceError("Could not start xmlrpc server for %s", self.tag)

            if host_port:
                host, port = host_port[0]

                try:
                    from unified_modules.test_support.xmlrpc_support import RpcClient
                    _retry = 0
                    retries = 10
                    while _retry < retries:
                        time.sleep(.2)
                        try:
                            self.xmlrpc_client = RpcClient((host, int(port)), log_prefix=self.tag)
                            self.xmlrpc_client.session = self.session
                            self.xmlrpc_client.testhead = self.testhead
                            self.xmlrpc_client.config = self.config

                            # pylint: disable=attribute-defined-outside-init
                            # RpcClient does not normally have an associated client
                            # for use with resource claimer, XMLRPC auto start
                            self.xmlrpc_client.resource_base = self
                            self.log.info("RpcClient successfully created")
                            return self.xmlrpc_client
                        except socket.error as socket_err:
                            _retry += 1
                            self.log.warning("Unable to connect to xmlrpc server for %s, "
                                                "Exception: %s" % (
                                                    self.res_type, socket_err))
                except ImportError:
                    raise ResourceError("xmlrpc_support is not available")

        raise ResourceError("Could not setup xmlrpc server and client for %s", self.tag)

    def event_generator(self):
        """Log all incoming data, log any expected responses"""
        # The event generator is started in a daemon thread: better make sure
        # that server connection will be properly closed on unexpected shutdown
        atexit.register(self.stop)

        self.log.info("Event generator started for %s", self.tag)

        while self.session:
            try:
                # Read until end of line or 1s timeout
                response = self.session.read_until('\n', 1)
                if response != "":
                    # Always report full output
                    self.log.info("rx: %s", response.rstrip())

                    # Limit size for parsing
                    response = response[:MAX_SINGLE_RESONSE_SIZE]

                    # add tuple with unique id, string to buffer
                    self.response_text.append((self.response_id, response))
                    self.response_id += 1

                    # Ensure response_text does not get too big, only needs to be
                    # large enough to store a couple of seconds on output per resource
                    # Trim to max buffer length
                    self.response_text = self.response_text[:MAX_RESPONSE_TEXT_BUFFER_SIZE]
            except AttributeError:
                # This happens if a connection is attempted after EOF
                # report telnet connection closed
                self.log.info("Termination event: telnet connection closed")
                break
            except EOFError as error:
                self.log.info("Termination event: %s", error)
                break

        self.log.info("Logging Event generator for %s, terminated", self.tag)

    def stop(self):
        """ Stop resource"""
        try:
            self.cli_quit()
        except (TestHeadClientError, AttributeError, ResourceError):
            # all resources socket connections are closed by this time anyway. No need to print any warnings
            pass
        try:
            if self.session:
                self.session.close()
        except socket.error:
            self.log.warning("Something went wrong when closing telnet connection for resource %s" % self.tag)
        self.log.info("%s, terminated", self.tag)

    def expect_line(self, matchlist, timeout=60):
        """Each line of input is matched against the match definitions in order.

        @param timeout - how long to wait for the pattern in the 'exp' entry in the match list
        @param matchlist - is a list of 3-tuples or lists with entries for
        exp, code, ret"""

        if not isinstance(matchlist, list):
            matchlist = [matchlist]

        start_time = time.time()

        while time.time() - start_time < timeout:
            expected_line = None
            for match_detail in matchlist:
                try:
                    pattern, dummy_callback, dummy_return_data = match_detail
                except ValueError:
                    pattern = match_detail

                for (response_id, response_string) in self.response_text:
                    # Only check if not already done
                    if response_id > self.response_checked:
                        if re.match(pattern, response_string):
                            expected_line = response_string.rstrip('\n')
                            self.response_text.remove((response_id, response_string))
                            break
                        # keep track of response_id checked
                        self.response_checked = response_id

                if expected_line is not None:
                    break

            if expected_line is not None:
                break
            time.sleep(1)

        return expected_line

    def clear_buffer(self):
        """Return a ref to the buffer and make a new empty one to use."""

        # Convert string tuple of id,string to just strings
        read_lines = []
        for (dummy_line_id, line_str) in self.response_text:
            read_lines.append(line_str)

        # Clear buffer and reset counters
        self.response_text = []
        self.response_id = 0
        self.response_checked = -1

        return read_lines

    def send(self, commands):
        """Write the list of commands to the resource
        @param commands - command or list of instructions for the resource"""

        # Take single command not in a list
        if not isinstance(commands, list):
            commands = [commands]

        for command in commands:
            self.log.info("tx: %s", command)

            try:
                response = self.session.write(command + '\n')
            except socket.error:
                response = (-1, None, "ERROR: Unable to send command to resource")

        return response

    def __str__(self):
        host = self.host
        try:
            hostname = socket.getfqdn(host)
        except Exception as error:
            hostname = 'UNKNOWN"', host, error

        repr_str = ""
        repr_str = " %s@%s %s" % (self.tag, hostname, repr_str)
        repr_str = repr_str.rstrip(' ')

        return repr_str


class LocalResource:
    def __init__(self, resource_tag, resource, config):
        """
        Object for local resource

        @param resource_tag: [str] resource tag
        @aram resource: [object] local resource object
        @param config: [dict] local resource configuration
        """
        self.resource_tag = resource_tag
        self.resource = resource
        self.config = config
