from time import time, sleep
from abc import ABC, abstractmethod


class Temp_BaseClass(ABC):
    """
    Abstract base class for a generic temperature forcing systems.

    Classes for specific systems (i.e Sensata) may inherit from this to define a basic interface including the state
    machine for set_temp_and_soak() and its configuration parameters.
    """

    def __init__(self):
        """Initializes base class attributes needed for the methods provided by the base class."""

        # Child class __init__ can redefine __name to make it more specific. (Add COM port for example).
        self.__name = __class__.__name__

        # property defaults - I guess child classes for specific temperature machines could set new values for these
        # in their __init__ methods.
        self.__msg_style = 'scroll'
        self.__settling_trials = 10
        self.__settling_interval = 1.0
        self.__ramping_interval = 1.0
        self.__soaking_interval = 1.0
        self.__timeout_minutes = 10

        self.__prev_msg = ''

    @property
    def msg_style(self):
        """" Controls formatting of status messages"""
        return self.__msg_style

    @msg_style.setter
    def msg_style(self, style):
        style = style.lower()
        if style not in ['none', 'scroll', 'inline']:
            raise ValueError(f"bad style '{style}', should be one of: 'none', 'scroll', 'inline'.")
        self.__msg_style = style

    @property
    def settling_trials(self):
        return self.__settling_trials

    @settling_trials.setter
    def settling_trials(self, trials):
        trials = int(trials)
        if trials < 0:
            raise ValueError(f"Bad trials, {trials}, should be integer >= 0.")
        self.__settling_trials = trials

    @property
    def settling_interval(self):
        return self.__settling_interval

    @settling_interval.setter
    def settling_interval(self, interval_sec):
        if interval_sec < 0.1 or interval_sec > 10.:
            raise ValueError(f"Bad interval {interval_sec}, should be 0.1 to 10 sec.")
        self.__settling_interval = interval_sec

    @property
    def ramping_interval(self):
        return self.__ramping_interval

    @ramping_interval.setter
    def ramping_interval(self, interval_sec):
        if interval_sec < 0.1 or interval_sec > 10.:
            raise ValueError(f"Bad interval {interval_sec}, should be 0.1 to 10 sec.")
        self.__ramping_interval = interval_sec

    @property
    def soaking_interval(self):
        return self.__soaking_interval

    @soaking_interval.setter
    def soaking_interval(self, interval_sec):
        if interval_sec < 0.1 or interval_sec > 10.:
            raise ValueError(f"Bad interval {interval_sec}, should be 0.1 to 10 sec.")
        self.__soaking_interval = interval_sec

    def get_configs(self):
        return dict(
            msg_style=self.__msg_style,
            settling_trials=self.__settling_trials,
            settling_interval=self.__settling_interval,
            ramping_interval=self.__ramping_interval,
            soaking_interval=self.__soaking_interval)

    def __del__(self):
        """When object is garbage collected, this will get called to reset to a safe temp."""
        print(f"Deleting {self.__name}, returning to room temperature.")
        self.set_temperature(25)

    def _print_msg(self, msg):
        if self.__msg_style == 'inline':
            backspaces = '\b' * len(self.__prev_msg)
            print(backspaces, end='')
            print(msg, end='')
            self.__prev_msg = msg
        elif self.__msg_style == 'scroll':
            print(msg)
            self.__prev_msg = ''
        else:
            self.__prev_msg = ''

    @abstractmethod
    def get_temperature(self):
        pass

    @abstractmethod
    def measure_temperature(self):
        pass

    @abstractmethod
    def set_temperature(self, temperature_degc):
        pass

    def set_temp_and_soak(self, setpoint_degc, soak_time_sec=0, tolerance_degc=2.5):

        temp_min = setpoint_degc - tolerance_degc
        temp_max = setpoint_degc + tolerance_degc

        symbol_degc = u'\xb0' + 'C'

        settling_queue = []
        # Run a state machine...

        self.__prev_msg = ''
        time_entered = time()

        sleep_time = 0
        state = 'START'
        next_state = 'START'
        while True:
            sleep(sleep_time)

            if next_state != 'START':
                full_msg = f"{state:8s} {msg} measured_temp={actual_temp:3.1f}{symbol_degc}."
                self._print_msg(full_msg)

            if state != next_state:
                state = next_state
                time_entered = time()

            if state in ('RAMPING', 'SETTLING') and (time() - time_entered) > self.__timeout_minutes * 60:
                raise ValueError(f"{self.__name}, timeout ({self.__timeout_minutes} minutes) exceeded during {state}.")

            actual_temp = self.measure_temperature()

            if state == 'START':
                msg = f"setting setpoint to {setpoint_degc:3.1f}{symbol_degc}."
                self.set_temperature(setpoint_degc)
                next_state = 'RAMPING'

            elif state == 'RAMPING':
                msg = f"to setpoint {setpoint_degc: 3.1f}{symbol_degc}, after {time() - time_entered:3.0f} sec "
                if abs(actual_temp - setpoint_degc) > tolerance_degc:
                    sleep_time = self.ramping_interval
                    continue
                next_state = 'SETTLING'

            elif state == 'SETTLING':
                if self.settling_trials < 1:
                    msg = f"skipped, {self.settling_trials} settling_trials configured."
                    next_state = 'SOAKING'
                    continue

                # Create a list of last 10 measurements.
                settling_queue.append(actual_temp)
                if len(settling_queue) > self.settling_trials:
                    settling_queue.pop(0)  # remove oldest

                # Create char string depicting the history.
                history = ''.join(['L' if t < temp_min else 'H' if t > temp_max else 'T' for t in settling_queue])

                msg = "to {:3.1f} +/- {:2.1f}{} for {:2d} consecutive readings: {:{width}s}, {:3.1f} sec.". \
                    format(setpoint_degc, tolerance_degc, symbol_degc, self.settling_trials, history[::-1],
                           time() - time_entered, width=self.settling_trials)

                if history.count('T') < self.settling_trials:  # Where all within tolerance?
                    sleep_time = self.settling_interval
                else:
                    next_state = 'SOAKING'

            elif state == 'SOAKING':
                if soak_time_sec < 0.1:
                    msg = f"skipped, 0 sec soak time configured."
                    next_state = 'DONE'
                    continue

                soak_remaining = soak_time_sec - (time() - time_entered)
                if soak_remaining > 0:
                    msg = f"for {soak_time_sec:3.0f} sec, {soak_remaining:3.0f} sec remaining."
                    sleep_time = self.soaking_interval
                else:
                    next_state = 'DONE'
                    sleep_time = 0
                    msg = f"soak for {soak_time_sec:3.0f} sec completed,"

            elif state == 'DONE':
                msg = f"Final "
                next_state = 'EXIT'

            else:
                if self.__msg_style == 'inline':
                    print('')
                return actual_temp
