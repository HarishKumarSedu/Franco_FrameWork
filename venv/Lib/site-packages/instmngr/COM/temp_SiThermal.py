# -*- coding: utf-8 -*-
"""
Created on Tue Oct  1 16:29:16 2019

@author: dkaroly


"""

import re
from time import sleep

# Could not get relative imports to work as expected inside the package, so this horible hack for now...
if 'site-packages' in __file__:
    #print(__name__)
    from instmngr.BaseClasses import temp_BaseClass
else:
    from BaseClasses import temp_BaseClass

pseudo_idn_string = 'SiThermal, SiThermal'

class Temp_SiThermal(temp_BaseClass.Temp_BaseClass):
    """
    Class for controlling Silicon Thermal Temperature forcing system.
    """

    def __init__(self, rmHandle):  #, address=1):
        """ Constructor for Temp_SiThermal class.
        
        Args:
            rmHandle - reference to a pyvisa.resources.ASRL.ASRLInstrument object. rmHandle comes from the method
                       instMgr.checkout, which creates the object using pyvisa.highlevel.ResourceManager.open_resource.
        """
        self._rmHandle = rmHandle

        m = re.search('ASRL(\d+)', rmHandle.resource_name)
        if m is None:
            raise ValueError(f"Bad VISA resource name '{rmHandle.resource_name}', expected something like ASRL<int>.")
        comport_name = 'COM' + m.group(1)

        super().__init__()
        self._comport_name = comport_name
        self.__name = f"{__class__.__name__}('{comport_name}')"

        self.__STX = 2
        self.__ETX = 3
        self.__NUL = 0

        self.address = 1  # Typical value used in MSAVAL today. Previously 50 (0x32) was common.

        # ---------------------------------------------------------------------------

    @property
    def address(self):
        """"The decimal value of the address used by the SiThermal Love Controls control unit."""
        return self.__address

    @address.setter
    def address(self, address):
        address = int(address)
        if address < 1 or address > 0x3FF:
            raise ValueError('address={:d} is outside range 0 to 1023 (0x3FF). MSAVAL typically uses 1 or 50.'.\
                             format(address))

        if address <= 0xFF:
            self.__filter_char = 'L'
        elif address <= 0x1FF:
            self.__filter_char = 'O'
        elif address <= 0x2FF:
            self.__filter_char = 'V'
        else:
            self.__filter_char = 'E'

        self.__address = address
        self.__addr_hex = '{:02X}'.format(address)


    def _love_command(self, data_str):
        cmdstr = self.__addr_hex + data_str

        checksum = sum([ord(x) for x in cmdstr])
        checksum = '{:02X}'.format(checksum)
        checksum = checksum[-2:]

        cmdstr = cmdstr + checksum

        cmdstr = self.__filter_char + cmdstr

        cmddec = [ord(x) for x in cmdstr]

        cmddec = [self.__STX, *cmddec, self.__ETX, self.__NUL]

        # print(cmddec)

        self._rmHandle.write_raw(bytes(cmddec))

        sleep(0.1)

        resp_num_bytes = self._rmHandle.bytes_in_buffer

        return list(self._rmHandle.read_bytes(resp_num_bytes))

    # ---------------------------------------------------------------------------

    def _read_status(self):
        response = self._love_command('00')

        if len(response) != 15:
            raise RuntimeError('SiThermal returned {:d} bytes, should be 15.'.format(len(response)))

        if response[0] != self.__STX:
            raise RuntimeError('No start bit received.')

        filter_char = chr(response[1])
        if filter_char != self.__filter_char:
            raise RuntimeError(
                "Incorrect filter_char returned '{}', expected '{}.".format(filter_char, self.__filter_char))

        addr_hex = ''.join([chr(x) for x in response[2:4]])
        if addr_hex != self.__addr_hex:
            raise RuntimeError("Incorrect address received {}, expected '{}'.".format(addr_hex, self.__addr_hex))

        checksum_hex = ''.join([chr(x) for x in response[12:14]])
        checksum_dec = int(checksum_hex, 16)

        datasum_hex = '{:02X}'.format(sum(response[1:12]))
        datasum_hex = datasum_hex[-2:]
        datasum_dec = int(datasum_hex, 16)

        if checksum_dec != datasum_dec:
            raise RuntimeError('Incorrect checksum value received')

        return response[4:12]

    # ---------------------------------------------------------------------------

    def _read_setpoint(self):
        response = self._love_command('0100')

        if len(response) != 13:
            raise RuntimeError('SiThermal returned {:d} bytes, should be 13.'.format(len(response)))

        if response[0] != self.__STX:
            raise RuntimeError('No start bit received.')

        filter_char = chr(response[1])
        if filter_char != self.__filter_char:
            raise RuntimeError(
                "Incorrect filter_char returned '{}', expected '{}.".format(filter_char, self.__filter_char))

        addr_hex = ''.join([chr(x) for x in response[2:4]])
        if addr_hex != self.__addr_hex:
            raise RuntimeError("Incorrect address received {}, expected '{}'.".format(addr_hex, self.__addr_hex))

        checksum_hex = ''.join([chr(x) for x in response[10:12]])
        checksum_dec = int(checksum_hex, 16)

        datasum_hex = '{:02X}'.format(sum(response[1:10]))
        datasum_hex = datasum_hex[-2:]
        datasum_dec = int(datasum_hex, 16)

        if checksum_dec != datasum_dec:
            raise RuntimeError('Incorrect checksum value received')

        return response[4:10]

    # ---------------------------------------------------------------------------

    def measure_temperature(self):
        status_data = self._read_status()

        # Extract multiplier from 3trd character.        
        field = int(chr(status_data[2]), 16)  # ASCII code to hex char to int.
        bin_data = '{:04b}'.format(field)  # 4-bit binary representation.

        bits = int(bin_data[2:4], 2)
        if bits == 0:
            multiplier = 1.0
        elif bits == 1:
            multiplier = 0.1
        elif bits == 2:
            multiplier = 0.01
        elif bits == 3:
            multiplier = 0.001
        else:
            raise RuntimeError('Two bit field has illegal value: {}. Should be impossible!'.format(bits))

        # Extract sign from 4th character.
        field = int(chr(status_data[3]), 16)  # ASCII code to hex char to int.
        bin_data = '{:04b}'.format(field)  # 4-bit binary representation.
        is_negative = bool(int(bin_data[3]))

        # Data is in the 5th through 8th characters.
        data_str = ''.join(chr(x) for x in status_data[4:9])
        data_dec = int(data_str, 10) * multiplier

        if is_negative:
            return -1 * data_dec
        else:
            return data_dec

    # ---------------------------------------------------------------------------

    def set_temperature(self, temp_degc):

        # Format temperature string.
        temp_str = '{:1.1f}'.format(abs(temp_degc))
        temp_str = temp_str.replace('.', '')
        num_pad = 4 - len(temp_str)
        temp_str = '0' * num_pad + temp_str

        # Create sign string
        if temp_degc < 0:
            sign_str = '01'
        else:
            sign_str = '00'

        data_str = '0200' + temp_str + sign_str

        self._love_command(data_str)

    def get_temperature(self):
        response = self._read_setpoint()

        # Extract multiplier from 1st. character.
        field = int(chr(response[0]), 16)  # ASCII code to hex char to int.
        bin_data = '{:04b}'.format(field)  # 4-bit binary representation.

        bits = int(bin_data[2:4], 2)
        if bits == 0:
            multiplier = 1.0
        elif bits == 1:
            multiplier = 0.1
        elif bits == 2:
            multiplier = 0.01
        elif bits == 3:
            multiplier = 0.001
        else:
            raise RuntimeError('Two bit field has illegal value: {}. Should be impossible!'.format(bits))

        # Extract sign from 2nd. character.
        field = int(chr(response[1]), 16)  # ASCII code to hex char to int.
        bin_data = '{:04b}'.format(field)  # 4-bit binary representation.
        is_negative = bool(int(bin_data[3]))

        # Data is in the 3rd. through 6th characters.
        data_str = ''.join(chr(x) for x in response[3:7])
        data_dec = int(data_str, 10) * multiplier

        if is_negative:
            return -1 * data_dec
        else:
            return data_dec

# ===============================================================================

if __name__ == "__main__":
    from InstMgr import InstMgr
    # NOTE: SiThermal cannot be auto-discovered (it has no IDN cmd) so it has to be specified like this:
    instMgr = InstMgr(resource_driver_dict={'COM1':'temp_SiThermal'})

    sitherm = instMgr.checkout(interface='COM1', moduleSuffix='SiThermal')
    print(f"sitherm.measure_temperature() => {sitherm.measure_temperature()}")

    print(sitherm.measure_temperature())
