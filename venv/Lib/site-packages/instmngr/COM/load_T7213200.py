# -*- coding: utf-8 -*-
"""
Class for controlling Tenma Electronic Load Model 72-13200.

Created on Tue Feb 23 10:00 2021

@author: cperez

TODO:
Command | Description
  *SAV  |   Store to unit
  *RCL  |   Recall the storage unit
  :LIST |   Output all steps in order
  :OCP  |   Over Current Protection test mode
  :OPP  |   Over Power Protection test mode
  :BATT |   Battery test mode
  :DYN  |   Dynamic test modes
Reference: https://uk.farnell.com/tenma/72-13200/dc-electronic-load-prog-30a-120v/dp/2848406#anchorTechnicalDOCS
"""

import re

idnString = 'T7213200'


class Load_T7213200:
    """Class for controlling Tenma Electronic Load Model 72-13200."""

    _ratings = dict()
    _ratings['CURR'] = {'range': (0, 30), 'units': 'Amps', 'unit_short': "A"}
    _ratings['VOLT'] = {'range': (0, 120), 'units': 'Volts', 'unit_short': "V"}
    _ratings['RES'] = {'range': (0.05, 7500), 'units': 'Ohms', 'unit_short': "OHM"}
    _ratings['POW'] = {'range': (0, 150), 'units': 'Watts', 'unit_short': "W"}

    _rating_curr_max_ocp = 35  # Amps (Over Current Protection)
    _rating_pow_max_opp = 165  # Watts (Over Power Protection)

    legal_on_off = {'ON': 1, 'OFF': 0}
    legal_on_off_rev = dict((v, k) for k, v in legal_on_off.items())

    legal_baud = {0: 9600, 1: 19200, 2: 38400, 3: 57600, 4: 115200}
    legal_baud_rev = dict((v, k) for k, v in legal_baud.items())

    legal_params = list(_ratings.keys())
    legal_meas_params = ("CURR", "VOLT", "POW")

    options_ss_modes = ("CC", "CV", "CR", "CW", "SHORT")  # Steady-state modes
    options_dynamic_modes = ("DCC", "DCV", "DCR", "DCW", "DPULSE", "DFLIP")  # Dynamic test functions

    def __init__(self, rmHandle):
        """Constructor for Load_T7213200 class.
        Args:
            rmHandle - (pyvisa inst class) reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using
                       :meth:'pyvisa.highlevel.ResourceManager.open_resource'.
        """
        self.rmHandle = rmHandle
        self.status()

    def reset(self):
        """ !!!Not Supported!!!
        Resets the Electronic Load to its factory defaults.
        """
        print("Warning: Tenma 72-13200 electronic load does not support a reset function.")

    def getIdn(self):
        """Returns product information (str)"""
        return self.rmHandle.query('*IDN?')

    def trigger(self):
        """Simulates an external trigger command, only valid in the pulse mode and the flip mode"""
        self.rmHandle.write('*TRG')

    def baud(self, baud=None):
        """Queries or writes the baud rate setting.
        When writing to the setting, this function turns the device input off.
        Make sure there is no active connection or the lead is disconnected.

        Args:
            baud (int): Baud rate setting - 9600, 19200, 38400, 57600, 115200, or None to query.

        Returns query response (int) if baud=None.
        """
        if baud is None:
            return int(self.rmHandle.query(':SYST:BAUD?').rstrip())
        else:
            if baud not in self.legal_baud_rev.keys():  # Make sure requested setting is valid
                raise ValueError(
                    f"Requested baud rate {baud} is invalid. Supported settings are {list(self.legal_baud_rev.keys())}")
            self.state("OFF")
            self.rmHandle.write(f":SYST:BAUD {baud}")

    def beep(self, beep=None):
        """Queries or writes the beep setting

        Args:
            beep (str): Button sounder settings, not case sensitive - "ON", "OFF" or None to query.

        Returns query response if beep=None.
        """
        if beep is None:
            return self.rmHandle.query(':SYST:BEEP?').rstrip()
        else:
            beep = beep.upper()
            if beep not in self.legal_on_off.keys():  # Make sure requested setting is valid
                raise ValueError(
                    f"Requested beep setting {beep} is invalid. Supported settings are {list(self.legal_on_off.keys())}")
            self.rmHandle.write(f":SYST:BEEP {beep}")

    def status(self):
        """Queries the device status (buzzer and baud rate).
        Returns query response (list): [buzzer, baud rate, reserved, reserved, reserved]
        """
        status = list(map(int, self.rmHandle.query(':STAT?').split(",")))
        print(f"Buzzer status: {status[0]} ({self.legal_on_off_rev[status[0]]})")
        print(f"Baud rate status: {status[1]} ({self.legal_baud[status[1]]})")
        return status

    def ratings(self, param):
        """
        Returns a tuple consisting of minval, maxval and units for the specified parameter.

        Args:
            param (str): Not case sensitive
                'RES' - Resistance, for CR steady-state mode
                'CURR' - Current, for CC steady-state mode
                'POW'  - Power, for CW steady-state mode
                'VOLT' - Voltage, for CV steady-state mode

        Returns tuple: (min (float), max (float) and unit (str))
        """
        param = param.upper()
        if param not in self.legal_params:
            raise ValueError(f"Requested param {param} is invalid. Supported settings are {self.legal_params}")

        min_val, max_val = self._ratings[param]["range"]
        units = self._ratings[param]['unit_short']
        return min_val, max_val, units

    def mode(self, mode=None):
        """Queries or writes operating mode of the Electronic load.

        Args:
            mode (str): Steady-state mode settings, not case sensitive.
                'CC' - Constant Current
                'CV' - Constant Voltage
                'CR' - Constant Resistance
                'CW' - Constant Power
                'SHORT' - Short Circuit test mode (forces DUT to output max current)
                None - Queries current mode setting

        Returns query response (str) if mode=None.
        """
        if mode is None:
            return self.rmHandle.query(':FUNC?').rstrip()
        else:
            mode = mode.upper()
            if mode not in self.options_ss_modes:
                raise ValueError(f"Requested mode {mode} is invalid. Supported settings are {self.options_ss_modes}")
            mode = mode.replace("SHORT", "SHORt")
            self.rmHandle.write(f":FUNC {mode}")

    def state(self, state=None):
        """Queries or writes the state of the electronic load input terminals.

        Args:
            state (str): Device input state, not case sensitive - "ON", "OFF" or None to query

        Returns query response (str) if state=None.
        """
        if state is None:
            return self.rmHandle.query(':INP?').rstrip()
        else:
            state = state.upper()
            if state not in self.legal_on_off.keys():  # Make sure requested setting is valid
                raise ValueError(
                    f"Requested input state {state} is invalid. Supported settings are {list(self.legal_on_off.keys())}")
            self.rmHandle.write(f":INP {state}")

    def range(self, param, range=None):
        """ !!!Not Supported!!!
        Queries or writes the range for the specified parameter.
        """
        print("Warning: Tenma 72-13200 electronic load does not support a range function.")

    def level(self, param, level=None):
        """
        Queries or writes the level for the specified parameter. Active steady-state mode is automatically changed
        when write is performed, but not when query is performed.

        Args:
            param (str): Not case sensitive
                'RES'           - Resistance, for CR steady-state mode
                'CURR'          - Current, for CC steady-state mode
                'POW'           - Power, for CW steady-state mode
                'VOLT'          - Voltage, for CV steady-state mode
            level (str, int or float): Not case sensitive
                None            - Queries from instrument the present level setting for param.
                'MIN?'          - Queries the minimum level of the range presently in effect for param.
                'LOW?'          - Same as 'MIN?'
                'MAX?'          - Queries the maximum level of the range presently in effect for param.
                'UPP?'          - Same as 'MAX?'
                'MIN'           - Minimum level of the range presently in effect for param.
                'MAX'           - Maximum level of the range presently in effect for param.
                'MAX <numeric>' - Sets max level of param. Units are Ohms, Amps, Watts, or Volts.
                <numeric>       - Sets level of param. Units are Ohms, Amps, Watts, or Volts.

        Returns query response (float) if level=None.
        """
        param = param.upper()
        if param not in self.legal_params:
            raise ValueError(f"Requested param {param} is invalid. Supported settings are {self.legal_params}")

        if level is None:
            rslt = self.rmHandle.query(f":{param}?").rstrip()
            ret_value, ret_unit = re.findall("(\d+\.\d+)(\w+)", rslt)[0]
            return float(ret_value)

        # If we got here, we are writing to the instrument.
        min_val, max_val, units = self.ratings(param)
        if type(level) in (int, float):
            if not min_val <= level <= max_val:
                raise ValueError(
                    f"Requested level {level} for {param} is out of range, should be {min_val} to {max_val} {units}.")
            self.rmHandle.write(f":{param} {level}{units}")
        elif re.match("(max|MAX) (\d+$|\d+.\d+$)", level):
            set_range, set_level = re.findall("(\w+) (.*)", level)[0]
            set_range = set_range.upper()
            set_range = set_range.replace("MAX", "UPP")
            set_level = float(set_level)
            if not min_val <= set_level <= max_val:
                raise ValueError(
                    f"Requested level {level} for {param} is out of range, should be {min_val} to {max_val} {units}.")
            self.rmHandle.write(f":{param}:{set_range} {set_level}{units}")
        else:
            level = level.upper()
            if level in ('MIN?', 'MAX?'):
                level = level.replace("MIN", "LOW")
                level = level.replace("MAX", "UPP")
                rslt = self.rmHandle.query(f":{param}:{level}").rstrip()
                ret_value, ret_unit = re.findall("(\d+\.\d+)(\w+)", rslt)[0]
                return float(ret_value)
            elif level in ('MIN', 'MAX'):
                self.rmHandle.write(f":{param} {level}")
            else:
                raise ValueError(
                    f"Requested level '{level}' for {param} is invalid, "
                    f"should be one of: {min_val} to {max_val}, 'MIN', 'MAX', 'MAX <numeric>', "
                    f"'MIN?', 'LOW?', 'MAX?', 'UPP?'")

    def meas(self, param):
        """
        Queries or writes actual measured level of the specified parameter.

        Args:
            param (str): Not case sensitive
                'CURR' - measured Current (Amps)
                'POW'  - measured Power   (Watts)
                'VOLT' - measured Voltage (Volts)

           Args are not case sensitive.
        Returns query response (float).
        """
        param = param.upper()
        if param not in self.legal_meas_params:
            raise ValueError(f"Requested param {param} is invalid. Supported settings are {self.legal_meas_params}")

        rslt = self.rmHandle.query(f"MEAS:{param}?").rstrip()
        ret_value, ret_unit = re.findall("(\d+\.\d+)(\w+)", rslt)[0]
        return float(ret_value)

    def dynamics(self, cc_slew=None, cv_response=None, cr_response=None):
        """ !!!Not Supported!!!
        Queries or sets current slew rate and/or transient response speeds for CV and CR mode.

        SCPI Commands:
        [SOURce:]CURRent:SLEW {<numeric>|MINimum|MAXimum}
        [SOURce:]FUNCtion:RESPonse:CV {NORMal|FAST}
        [SOURce:]FUNCtion:RESPonse:CR {NORMal|FAST}
        """
        print("Warning: Tenma 72-13200 electronic load does not support the dynamics function from Kikusui.")


if __name__ == "__main__":
    import os, sys

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)

    from InstMgr import InstMgr
    # NOTE: pyvisa.ResourceManager.list_resources() sometimes do not show asynchronous serial port (ASRL)
    # so need to declare load here
    instMgr = InstMgr(resource_driver_dict={'COM4':'load_T7213200'})
    tenma = instMgr.checkout(objName='load', interface='COM4', moduleSuffix='T7213200')

    print("IDN: ", tenma.getIdn())
    tenma.baud(9600)
    tenma.baud()
    tenma.beep("OFF")
    tenma.reset()
    tenma.state('off')
    print("MODE: ", tenma.mode())
    tenma.mode('cr')
    print("MODE: ", tenma.mode())
    tenma.range('CURR', 'L')
    print("CURR Level: ", tenma.level('CURR'))
    print("CURR Min Level: ", tenma.level('CURR', "MIN?"))
    tenma.level('CURR', 0.25)
    print("Meas CURR:", tenma.meas('CURR'))
    print("VOLT Max: ", tenma.level('VOLT', "MAX?"))
    tenma.level('POW', "MAX 36.752")
    print("POW Max: ", tenma.level('POW', "max?"))
    # tenma.level('VOLT', "MAX 125")  // raises exception
    tenma.state('on')
    tenma.trigger()
    tenma.mode('short')
    print("Mode: ", tenma.mode())
