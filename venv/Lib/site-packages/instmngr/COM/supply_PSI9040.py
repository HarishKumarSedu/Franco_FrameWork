# -*- coding: utf-8 -*-
"""
@author: dkaroly
"""

import sys
import re

idnString = 'PSI 9040-40 T'

class Supply_PSI9040:
    """Class for controlling EA Power Supply Model PSI-9040-40-T."""

    def __init__(self, rmHandle):
        """ Constructs an object of class Supply_PSI9040.

        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using
                       :meth:'pyvisa.highlevel.ResourceManager.open_resource'.
        """

        self.rmHandle = rmHandle

        self.status_clear()      # Clear previous errors that might block command execution
        self.system_lock('ON')   # PSI9040 requires this to initiate remote control.

    # ---------------------------------------------------------------------------
    # Added these two functions to work around fact that Pyro server is not allowing
    # access to property rmHandle, which is desired as work around to hack other features.

    def write_raw(self, cmdstr):
        """Send cmdstr argument directly to instrument."""
        self.rmHandle.write(cmdstr)

    def query_raw(self, cmdstr):
        """Perform query defined by cmdstr, return string. cmdstr must end with '?'."""

        if cmdstr[-1] != '?':
            raise ValueError(f"Bad query '{cmdstr}' missing '?'.")

        return self.rmHandle.query(cmdstr).strip()

    # ---------------------------------------------------------------------------

    def reset(self):
        """ Resets the Power Supply, turns output off."""

        self.rmHandle.write('*RST')

    # ---------------------------------------------------------------------------

    def system_lock(self, on_off=None):
        """Queries or sets how supply is controlled. Lock must be ON for remote control
        to change settings of the supply.

        Args:
            on_off:
                None: queries present setting.
                'ON': remote control enabled for writing.
                'OFF': Settings can be chnaged on the front panel.
        Returns:
            'REMOTE': remote control mode is in effect
            'NONE':   front panel control is in effect
        """

        if on_off is None:
            result = self.rmHandle.query(f'SYST:LOCK:OWNER?')
            return result.rstrip()

        on_off_u = on_off.upper()
        if on_off is not None and on_off_u not in ('ON', 'OFF'):
            raise ValueError(f"Bad value for on_off '{on_off}, needs to be 'ON' or 'OFF'.")

        return self.rmHandle.write(f'SYST:LOCK {on_off_u}')

    # ---------------------------------------------------------------------------

    def value(self, voltage=None, ilimit=None):
        """ Queries or sets both the output voltage and current compliance limit.

            Args:
                voltage (None or numeric) : Voltage to output in Volts.
                ilimit ( None or numeric) : Current limit to set in Amps.

            Return:
                If both voltage and ilimit are None, then the Power Supply is
                queried and the present voltage and current settings are
                returned as a list of two float values.

            NOTE:
                Voltage and ilimit may be both set together. Specifying a
                voltage value with ilimit=None retains the existing ilimit.
                Specifying just ilimit retains the existing voltage level.

        """

        if voltage is None and ilimit is None:
            # Read and return both output voltage and current limit settings.
            ret_list = []
            ret_val = self.rmHandle.query('VOLT?').rstrip(' V\n')
            ret_list.append(float(ret_val))
            ret_val = self.rmHandle.query('CURR?').rstrip(' A\n')
            ret_list.append(float(ret_val))
            return ret_list

        # Avoids causing instrument error if user supplies non numeric value.
        if voltage is not None and (not isinstance(voltage, (int, float)) or voltage < 0 or voltage > 40.8):
            raise ValueError(f"Bad voltage specified ({voltage}), must be numeric value 0 to 40.8 volts.")

        if ilimit is not None and (not isinstance(ilimit, (int, float)) or ilimit < 0 or ilimit > 40.8):
            raise ValueError(f"Bad ilimit specified ({ilimit}), must be numeric value 0 to 40.8 amps.")

        if voltage is not None:
            self.rmHandle.write('VOLT ' + str(voltage))

        if ilimit is not None:
            self.rmHandle.write('CURR ' + str(ilimit))

    # ---------------------------------------------------------------------------

    def power_limit(self, watts=None):
        """Queries or sets the power compliance value.

        Note this limits the voltage and or current delivered to the load to from exceeding the
        set value. This is different than Over Power protection (opp) which shuts off the output.

        Args:
            watts: None: queries present setting, returns float value in watts.
                   Numeric value in watts to set.
        """

        if watts is None:
            # Read and return voltage output setting and current limit setting.
            ret_val = self.rmHandle.query('POW?').rstrip(' W\n')
            return float(ret_val)

        # Avoids causing instrument error if user supplies non numeric value.
        if watts is not None and (not isinstance(watts, (int, float)) or watts < 0 or watts > 1020):
            # noinspection PyTypeChecker
            raise ValueError(f"Bad power_limit  specified ({watts}), must be numeric value 0 to 1020 watts.")

        if watts is not None:
            self.rmHandle.write('POW ' + str(watts))

    # ---------------------------------------------------------------------------

    def resistance(self, ohms=None):
        """Queries or sets the series resistance value that is in effect in UIR mode.

        Note that the series resistance is not present in the UIP mode. See method mode
        to change modes.

        Args:
            ohms: None: queries present setting, returns float value in Ohms.
                   Numeric value in Ohms to set, value 0.1 to 30. Note that values >30 cause
                   a -222, "Data out if range" error even though supply allows adjustment
                   limit to be 30.6. Firmware bug??

        """

        if ohms is None:
            # Read and return voltage output setting and current limit setting.
            ret_val = self.rmHandle.query('RES?').rstrip(' OHM\n')
            return float(ret_val)

        # Avoids causing instrument error if user supplies non numeric value.
        if ohms is not None and (not isinstance(ohms, (int, float)) or ohms > 30):
            raise ValueError(f"Bad resistance specified ({ohms}), must be numeric value 0 to 30 ohms.")

        if ohms < 0.05:
            raise ValueError(f"Cannot set resistance < 0.05 Ohm. To eliminate series resistance, "
                "use the mode method to select 'UIP' mode.")

        if ohms is not None:
            self.rmHandle.write('RES ' + str(ohms))

    # ---------------------------------------------------------------------------

    def mode(self, modename=None):
        """Queries or selects the operating mode of the supply: power limiting or series resistance.

        Args:
            modename:
                None:   Returns abbreviation of mode currently selected.
                UIP:    Voltage/Current/Power
                UIR:    Voltage/Current/Resistance
        """

        if modename is None:
            return self.rmHandle.query('SYST:CONFIG:MODE?').rstrip()

        modename_u = modename.upper()
        if modename_u not in ('UIP', 'UIR'):
            raise ValueError(f"Invalid mode '{modename}', should be one of 'UIP' or 'UIR'.\n"
                             "'UIP' = Voltage/Current/Power\n"
                             "'UIR' = Voltage/Current/Resistance")

        self.rmHandle.write(f"SYST:CONFIG:MODE {modename_u}")

    # ---------------------------------------------------------------------------

    def state(self, on_off=None):
        """Wrapper around method output for compatibility.
        """

        return self.output(on_off)

    def output(self, on_off=None):
        """
        Queries or writes the state of the Power Supply output.

        Args:
            on_off (str):
                None   - Queries instrument, returns one of the following strings:
                'ON'   - Power Supply is connected to the load.
                'OFF'  - Power Supply is DISconnected to the load.

           Args are not case sensitive.
           Return values are always case shown above.
        """

        if on_off is None:
            return self.rmHandle.query('OUTP:STAT?').rstrip()

        states = ('ON', 'OFF')
        if on_off.upper() in states:
            self.rmHandle.write('OUTP:STAT ' + on_off.upper())
        else:
            raise ValueError(f"Bad on_off state '{on_off}'. Should be 'ON' or 'OFF'.")

    # ---------------------------------------------------------------------------

    def meas(self, param=None):
        """
        Queries the actual measured value of the specified parameter.

        Args:
            param:
                None:  - Reads all 3 measurements and returns as comma separated sting including units.
                'CURR' - measured Current (Amps) as a float
                'POW'  - measured Power   (Watts) as a float
                'VOLT' - measured Voltage (Volts) as a float

           Args are not case sensitive.
        """

        if param is None:
            param = 'ALL'

        param_u = param.upper()
        if param_u not in ('CURR', 'VOLT', 'POW', 'ALL'):
            raise ValueError(f"Bad meas parameter '{param}. Should be one of 'VOLT', 'CURR', 'POW', 'ALL'")

        if param_u == 'ALL':
            return self.rmHandle.query('MEAS:ARR?').rstrip()

        ret_val = self.rmHandle.query('MEAS:' + param_u + '? ')
        return float(ret_val.rstrip(' VAW\n'))

    # ---------------------------------------------------------------------------

    def status_reg_bits(self, regname):
        """Queries OPER or QUES status register and returns dictionary showing name-values of bits.

        Args:
            regname: 'oper' or 'ques'. Not case sensitive.

        """

        regname_u = regname.upper()
        if regname_u == 'OPER':
            conditions = {'CV': 8, 'CC': 9, 'CP': 10, 'CR': 11}
        elif regname_u == 'QUES':
            conditions = {
                'OVP': 0, 'OCP': 1, 'OPP': 2, 'OT': 3, 'OVD': 4, 'UVD': 5, 'OCD': 6, 'UCD': 7, 'OPD': 8,
                'Local': 9, 'Remote': 10, 'Output On': 11, 'Function': 12, 'Power Fail': 12
            }
        else:
            raise ValueError(f"Bad status regname '{regname}', needs to be 'oper' or 'ques'.")

        value = self.rmHandle.query(f'STAT:{regname_u}:COND?')
        value = int(value)

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    # ---------------------------------------------------------------------------

    def ocp_value(self, amps=None):
        """ Queries or sets the Over Current Protection level of the supply.

            OCP shuts off the supply output when the current drawn exceeds the set value.

            Args:
                amps: None or float representing current in Amps.

            Return:
                Query returns the present OCP setpoint in Amps.
        """

        if amps is None:
            rslt = self.rmHandle.query('CURR:PROT?')
            return float(rslt.rstrip(' A\n'))

        if not isinstance(amps, (int, float)) or (amps < 0 or amps > 44):
            raise ValueError(f"Bad ilimit {amps}, should be 0 to 44 A.")

        self.rmHandle.write(f"CURR:PROT {amps}")

    # ---------------------------------------------------------------------------

    def ocp_tripped(self):
        """ Queries if Over Current Protection has tripped.

            OCP shuts off the supply output when the current drawn exceeds the set value.

            Return:
                True if OCP trip has occurred..
        """

        return self.status_reg_bits('QUES')['OCP']

    # ---------------------------------------------------------------------------

    def ocp_clear(self):
        """ Clears Over Current Protection trip.

            OCP shuts off the supply output when the current drawn exceeds the set value.

            Note that after clearing the trip state, the output will remain off until
            reactivated using the output method.

        """

        self.getError()

    # ---------------------------------------------------------------------------

    def ovp_value(self, volts=None):
        """ Queries or sets the Over Voltage Protection level of the supply.

            OVP shuts off the supply output when the voltage exceeds the set value.

            Args:
                volts: None or float representing current in Volts.

            Return:
                Query returns the present OCP setpoint in Volts.
        """

        if volts is None:
            rslt = self.rmHandle.query('VOLT:PROT?')
            return float(rslt.rstrip(' V\n'))

        if not isinstance(volts, (int, float)) or (volts < 0 or volts > 44):
            raise ValueError(f"Bad vlimit {volts}, should be 0 to 44 V.")

        self.rmHandle.write(f"VOLT:PROT {volts}")

    # ---------------------------------------------------------------------------

    def ovp_tripped(self):
        """ Queries if Over Voltage Protection has tripped.

            OCP shuts off the supply output when the volatge exceeds the set value.

            Return:
                True if OCP trip has occurred..
        """

        return self.status_reg_bits('QUES')['OVP']

    # ---------------------------------------------------------------------------

    def ovp_clear(self):
        """ Clears Over Voltage Protection trip.

            OVP shuts off the supply output when the voltage drawn exceeds the set value.

            Note that after clearing the trip state, the output will remain off until
            reactivated using the output method.

        """

        self.getError()

    # ---------------------------------------------------------------------------

    def opp_value(self, watts=None):
        """ Queries or sets the Over Power Protection level of the supply.

            OPP shuts off the supply output when the power exceeds the set value.

            Args:
                watts: None or float representing current in Watts.

            Return:
                Query returns the present OPP setpoint in Watts.
        """

        if watts is None:
            rslt = self.rmHandle.query('POW:PROT?')
            return float(rslt.rstrip(' W\n'))

        if not isinstance(watts, (int, float)) or (watts < 0 or watts > 1100):
            raise ValueError(f"Bad ilimit {watts}, should be 0 to 1100 W.")

        self.rmHandle.write(f"POW:PROT {watts}")

    # ---------------------------------------------------------------------------

    def opp_tripped(self):
        """ Queries if Over Power Protection has tripped.

            OPP, if enabled, shuts down the supply when the power exceeds the set value.

            Return:
                Query returns True if trip has occurred.
        """

        return self.status_reg_bits('QUES')['OPP']

    # ---------------------------------------------------------------------------

    def opp_clear(self):
        """ Clears Over Voltage Protection trip.

            OPP shuts off the supply output when the voltage drawn exceeds the set value.

            Note that after clearing the trip state, the output will remain off until
            reactivated using the output method.

        """

        self.getError()

    # ---------------------------------------------------------------------------

    def adjustment_hilimits(self, param=None, limit=None):
        """Queries or sets upper bounds for output parameters "VOLT', 'CURR', 'POW', 'RES'.

        Args:
            param: None: All 4 limits are read and returned as a dict of name-value pairs.
                   'VOLT', 'CURR', 'POW', 'RES': Any of these with limit=None, results in the value
                    being read and returned as a float.
            limit: int or float value to set.

        Effect of adjustment_limits:
        Under LOCAL control turing the knob 1 click beyond the adjustment_hilimit for the
        parameter results in a Limit message on the fromt panel LCD screen.

        Under REMOTE control attempting to set a value above the limit will set ERR bit in the
        status byte (read with method status(), and an error "-221, 'Settng Conflict' in the error
        queue, read with method getError(),
        """

        legal_params = {'VOLT': 40.8, 'CURR': 40.8, 'POW': 1020, 'RES': 30}
        # See comment on method resistance() for why max here is 30.

        if param is None and limit is None:
            return_val = {}
            for param in legal_params:
                tmp = self.rmHandle.query(f"{param}:LIM:HIGH?")
                tmp = re.sub('[^\d\.$]', '', tmp)
                value = float(tmp)
                name = param
                return_val.update({name: value})

            return return_val

        if param not in legal_params:
            msg = ", ".join(["'{}'".format(x) for x in legal_params])
            raise ValueError(f"Bad param name '{param}', should be one of {msg}.")

        if limit is None:
            tmp = self.rmHandle.query(f"{param}:LIM:HIGH?")
            tmp = re.sub('[^\d\.$]', '', tmp)
            return float(tmp)

        value_max = legal_params[param]
        if limit > value_max:
            raise ValueError(f"Bad high limit for {param}: {limit}, max is {value_max}.")
        else:
            cmd = f"{param}:LIM:HIGH {limit}"
            self.rmHandle.write(cmd)

    # ---------------------------------------------------------------------------

    def getIdn(self):
        """Returns instrument identity string.
        """

        return self.rmHandle.query('*IDN?')

    def getError(self):
        """Reads a single error string (oldest) from supply error queue.

        Error queue is First In First Out. Will return "0, 'No Error" on the read
        following reading the last error.

        Clears device Alarm bits in QUEStionable Status register if the condition that
        caused the alarm is gone.
        """

        return self.rmHandle.query('SYST:ERRor?').rstrip()

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = int(self.rmHandle.query('*STB?').rstrip())

        conditions = {'ERR': 2, 'QUES': 3, 'OPER': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending '*CLS, command."""

        self.rmHandle.write('*CLS')

    def close(self):
        """There is no need for users to call this. If you do instrument will because
        unavailable because rmHandle will be closed.

        This is here for InstMgr to use in its clean up.
        """

        # here, might need to communicate with instrument manager to retire the
        # instance listed there
        self.rmHandle.close()


# ===============================================================================

if __name__ == "__main__":
    import os

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    from InstMgr import InstMgr

    instMgr = InstMgr(resource_driver_dict={'COM4': 'supply_PSI9040'})

    ps = instMgr.checkout(objName='supply', interface='COM4', moduleSuffix='PSI9040')

    ps.reset()
    print(ps.getIdn())
    ps.value(voltage=4.0, ilimit=1.0)
    # outval = ps.value()
    # print(outval)
    # ps.state('ON')
    # print(ps.state())
#    time.sleep(1)

#    ps.close()
