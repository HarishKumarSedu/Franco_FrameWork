import ctypes
import re

# Could not get relative imports to work as expected inside the package, so this horible hack for now...
if 'site-packages' in __file__:
    #print(__name__)
    from instmngr.BaseClasses import temp_BaseClass
else:
    from BaseClasses import temp_BaseClass

"""
Defines class for controlling Sensata IQPhase temperature forcing system.

Note that Sensta communication uses a USB cable - but the connection shows up in Device Manager under COM ports as
a RS485 driver by B&B electronics. Control also depends on a DLL that must be installed. See Jira ticket G3-4362 for
details.
"""

pseudo_idn_string = 'Sensata, IQPhase'

class Temp_SensataIQPhase(temp_BaseClass.Temp_BaseClass):
    """
    Class for controlling a Sensata IQPhase temperature forcing system.
    """

    def __init__(self, rmHandle):
        """Loads DLL and initializes connection to Sensata IQPhase system at specified COM port."""

        # Get comport number from the rmHandle that the import InstMg,check method opened. Then close it so tha the
        # Sensata TC:COMM:OPEN:SER command can open it.
        resource_name = rmHandle.resource_name
        rmHandle.close()

        m = re.search('ASRL(\d+)', resource_name)
        rmHandle.close()   # Note that InstrMgr.checkout will have opened the comport. We need to close it here because

        if m is None:
            raise ValueError(f"Bad VISA resource name '{rmHandle.resource_name}', expected something like ASRL<int>.")
        comport_name = 'COM' + m.group(1)

        self._sensata_id = None

        super().__init__()
        self._comport_name = comport_name
        self.__name = f"{__class__.__name__}('{comport_name}')"

        # Load the DLL
        dll_path = r"C:\Program Files\TC_SCPI\lib\TC_SCPI_Main.dll"
        self._dll_obj = ctypes.cdll.LoadLibrary(dll_path)

        # Open the comport to the machine
        cmdstr = f"TC:COMM:OPEN:SER {self._comport_name}"
        status, sensata_id, response = self._wrap_dll(-1, cmdstr)
        if status != 1:
            raise ValueError(f"{self.__name} initialization failed.")

        self._sensata_id = sensata_id
        print(f"{self.__name} initialized, sensata_id={self._sensata_id}.")

    def __del__(self):
        """When object is garbage collected, this will get called to reset to a safe temp and close the COM port."""
        if self._sensata_id is not None:
            # If _sensata_id doesn't exist (we error-ed out of __init__), niether of these is going to work.
            super().__del__()
            self._wrap_dll(self._sensata_id, "TC:COMM:CLOSE")

    def _wrap_dll(self, sensata_id, command):
        """Encapsulates the conversions needed to interface between Python and the DLL.
        """
        param1 = ctypes.c_int32(sensata_id)
        param1_ptr = ctypes.pointer(param1)
        param2 = ctypes.c_char_p(command.encode())
        param3 = ctypes.create_string_buffer(256)
        status = self._dll_obj.TC_SCPI_IO(param1_ptr, param2, param3)

        return [status, param1_ptr.contents.value, param3.value.decode('utf-8')]

    def get_errors(self):
        error_list = []
        status = 1
        while status:
            status, sensata_id, response = self._wrap_dll(self._sensata_id, 'SYST:ERR?')
            if status:
                tmp = response.split(',')
                resp_tuple = (int(tmp[0]), tmp[1].strip(' ').strip('"'))
                if resp_tuple[0] == 0:
                    break  # Then no actual error, we got the response "0, 'No Error'"
                else:
                    error_list.append(resp_tuple)
            else:
                error_list.append(tuple("Reading error returned status={status}"))

        if status != 1:
            raise ValueError(f"{self.__name}, DLL return code {status} while checking errors.")

        return error_list

    def get_temperature(self):
        status, sensata_id, response = self._wrap_dll(self._sensata_id, 'CONT:SPT?')
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} get_temperature: {error_list}.")
        return float(response)

    def measure_temperature(self):
        status, sensata_id, response = self._wrap_dll(self._sensata_id, 'MEAS?')
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} measure_temperature {error_list}.")
        return float(response)

    def set_temperature(self, temperature_degc):
        cmdstr = f'CONT:SPT {temperature_degc}'
        self._wrap_dll(self._sensata_id, cmdstr)
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} set_temperature({temperature_degc}) {error_list}.")
        self.set_regulation(True)

    def set_regulation(self, enable):
        substr = {False: "OFF", True: "ON"}[enable]
        cmdstr = f"CONT:ENAB {substr}"
        self._wrap_dll(self._sensata_id, cmdstr)
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} regulation({enable})  {self.get_errors()}.")

if __name__ == "__main__":
    from InstMgr import InstMgr
    # NOTE: SensataIQPhase cannot be auto-discovered (it has no IDN cmd) so it has to be specified like this:
    instMgr = InstMgr(resource_driver_dict={'COM4':'temp_SensataIQPhase'})

    sensata = instMgr.checkout(interface='COM4', moduleSuffix='SensataIQPhase')
    print(f"sensata.measure_temperature() => {sensata.measure_temperature()}")
