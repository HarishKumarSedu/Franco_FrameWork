# -*- coding: utf-8 -*-
"""
Created on Fri Mar 29 15:22:52 2019

@author: jmunger
"""

# Instrument Manager Class -- 2nd revision to change concept of checkout to overwrite instead of lockout, also simplifies data structures for managing instruments to
# facilitate GUI

# imports

import os, sys, glob, re
import pyvisa
import logging


class InstMgr():

    def __init__(self, demoMode=False, resource_driver_dict={}):

        self.resource_driver_dict = resource_driver_dict

        self.instInfoDict = {} # initialized in updateInstMgr

        self.resourceManager = pyvisa.ResourceManager()
        self.logger = logging.getLogger('msaval.instMgr')
        self.logger.info('Instrument manager is called')
        self.updateInstMgr()
        self.whatinst()

    # -------------------------------------------------------------------------------

    def updateInstMgr(self):

        # Get names of interfaces from driver folders.
        mgrRootDir = os.path.dirname(os.path.abspath(__file__))

        self.interfaceList = []
        for name in os.listdir(mgrRootDir):
            if os.path.isdir(os.path.join(mgrRootDir, name)) and name in ['GPIB', 'USB', 'COM']:
                self.interfaceList.append(name)

        # for each driver folder, update module information
        for interface in self.interfaceList:
            self.updateInstModules(interface)

        # poll visa for resources on buses
        resourceList = self.resourceManager.list_resources()

        # poll DLL classes (OTHER) - startup base class / check for connected instrument, populate instList accordingly

        # query each resource on bus for information and store in instInfo,
        # as long as resource label matches bus resource label
        # remove instruments on instInfo that are not on bus
        # add instruments on instInfo that are now on bus / not in instInfo

        for rsc in resourceList:
            if not self.instEntryExists(rsc):
                self.addInstEntry(rsc)

        self.cleanupInstInfo()

    # -------------------------------------------------------------------------------

    def parse_rsc(self, rsc):

        bus, address = None, None

        if 'GPIB' in rsc:
            bus, address, instr = rsc.split('::')
        elif 'USB' in rsc:
            bus, addr0, addr1, addr2, instr = rsc.split('::')
            address = addr0 + '::' + addr1 + '::' + addr2
        elif 'ASRL' in rsc:
            m = re.search('^ASRL(\d+)', rsc)
            if m is not None:
                bus = 'COM' + m.group(1)

        return [bus, address]

    # -------------------------------------------------------------------------------

    def instEntryExists(self, rsc):

        for instGrp in self.instInfoDict.keys():
            for moduleSuffix in self.instInfoDict[instGrp].keys():
                for inst in self.instInfoDict[instGrp][moduleSuffix]['instList']:
                    # print('compare', instGrp,moduleSuffix,interface, inst['bus'],addr,inst['addr'])
                    if (rsc == inst['rsc']):
                        # print('found!!', interface, inst['bus'],addr,inst['addr'])
                        return True
        return False

    # -------------------------------------------------------------------------------
    def _parse_idn(self, idn):

        mfg, model, serial, ver = None, None, None, None
        if idn is None:
            return [mfg, model, serial, ver]

        pattern = '^(FTS Systems, Inc.),\s*([^,]+),\s*([^,]+)'
        m = re.search(pattern, idn)
        if m is not None:
            mfg = m.group(1).replace(',', '')
            model = m.group(2)
            serial = None
            ver = m.group(3)
        else:
            fields = [x.strip() for x in idn.split(',')]
            num_fields = len(fields)
            if num_fields == 2:
                mfg, model = fields
            elif num_fields == 4:
                mfg, model, serial, ver = fields
            elif num_fields == 5:
                print(f"{idn} has 5 fields, treating it like Temptronic ECO-710.")
                mfg, model = fields[:2]
                serial = fields[4]
                ver = fields[3]
            else:
                print(f"{idn} IDN has {num_fields} fields, do not know how to handle, skipping this instrument.")
                return

        return [mfg, model, serial, ver]

    # -------------------------------------------------------------------------------

    def addInstEntry(self, rsc):

        bus, address = None, None
        if 'GPIB' in rsc:
            bus, address, instr = rsc.split('::')
            idn = self.getInstMfgidn(rsc)  # typically mfg, model, serial number, sw ver
        elif 'USB' in rsc:
            bus, addr0, addr1, addr2, instr = rsc.split('::')
            address = addr0 + '::' + addr1 + '::' + addr2
            idn = self.getInstMfgidn(rsc)  # typically mfg, model, serial number, sw ver
        elif 'RSNRP' in rsc:
            bus, addr0, addr1,instr = rsc.split('::')
            bus = 'USB'
            address = addr0 + '::' + addr1
            idn = self.getInstMfgidn(rsc)  # typically mfg, model, serial number, sw ver
        elif 'ASRL' in rsc:
            m = re.search('^ASRL(\d+)', rsc)
            if m is None:
                return
            bus = 'COM' + m.group(1)
            idn = None
        else:
            #print(f'Unknown interface: {rsc}')
            return

        mfg, model, serial, version = self._parse_idn(idn)

        # Was resource_driver_dict used to specify a particular driver module? See if this instrument is one of them.

        key = re.sub('::INSTR$', '', rsc)
        instModuleName = self.resource_driver_dict.get(key, None)
        if instModuleName is None and 'ASRL' in rsc:
            key = re.sub('^ASRL', 'COM', key)
            instModuleName = self.resource_driver_dict.get(key, None)

        inst_opts = None

        if instModuleName:
            # Use the Driver specified
            instGrp, moduleSuffix = self._split_module_name(instModuleName)
            moduleHandle = self.instInfoDict[instGrp][moduleSuffix].get('handle', None)
            if moduleHandle is None:
                raise ValueError("resource_driver_dict['{key}'] specified a non-existent driver module '{instModuleName}'.")

            if idn:
                if hasattr(moduleHandle, 'optString'):
                    inst_opts = self.getInstOpt(rsc)  # Go read options from instrument.
                    if moduleHandle.optString not in inst_opts:
                        raise ValueError("Instrument {} does not support options {} in specified driver {}.".\
                            format(rsc, moduleHandle.optString, instModuleName))

            elif hasattr(moduleHandle, 'pseudo_idn_string'):
                mfg, model, serial, version = self._parse_idn(moduleHandle.pseudo_idn_string)

        elif idn:
            # Search the instInfoDict for a driver that matches the model field returned from IDN query on the
            # instrument. If a matching driver specifies an optString, check against instrument.
            generic_drivers_info = []
            specific_drivers_info = []
            for instGrp in self.instInfoDict.keys():
                for moduleSuffix in self.instInfoDict[instGrp].keys():
                    moduleHandle = self.instInfoDict[instGrp][moduleSuffix]['handle']
                    if hasattr(moduleHandle, 'idnString') and model == moduleHandle.idnString:
                        if hasattr(moduleHandle, 'optString'):
                            inst_opts = self.getInstOpt(rsc)  # Go read options from instrument.
                            if moduleHandle.optString in inst_opts:
                                specific_drivers_info.append([instGrp, moduleSuffix, inst_opts])
                        else:
                            generic_drivers_info.append([instGrp, moduleSuffix])

            num_specific = len(specific_drivers_info)
            if num_specific > 1:
                raise RuntimeError('Multiple {} drivers found for instrument {} {} {} {} {}.'.\
                                   format(num_specific, bus, address, mfg, model, inst_opts ))

            num_generic = len(generic_drivers_info)
            if num_generic > 1:
                raise RuntimeError('Multiple {} drivers found for instrument {} {} {} {}.'.\
                                   format(num_generic, bus, address, mfg, model))

            inst_opts = None
            if num_specific > 0:
                instGrp, moduleSuffix, inst_opts = specific_drivers_info[0]
            elif num_generic > 0:
                instGrp, moduleSuffix = generic_drivers_info[0]
            else:
                wrnstr = "No driver found for instrument {} {} {} {}.".format(bus, address, mfg, model)
                self.logger.warning(wrnstr)
                return
        else:
            return


        info = {'rsc': rsc, 'bus': bus, 'addr': address,
                'mfg': mfg, 'model': model, 'serial': serial, 'version': version,
                'status': 'attached',
                'objPtr': None,
                'lastCalledBy': None,
                'thisCaller': None,
                'Name': None}

        if inst_opts:
            info.update({'opts': inst_opts})

        self.instInfoDict[instGrp][moduleSuffix]['instList'].append(info)
        return

    # -------------------------------------------------------------------------------

    # this is a kludge - would like to find a better way to query abstracted DLL instruments, but this is easiest since we have just
    #            if instGrp == 'ap500':
    #                if (instModule.instConnected) == True and (len(self.instInfoDict[instGrp][moduleSuffix]['instList']) == 0):
    #                    self.addInstEntry( interface, 0, moduleSuffix, moduleSuffix )

    def cleanupInstInfo(self):
        # refresh list of what is on bus
        resourceList = self.resourceManager.list_resources()

        for instGrp in self.instInfoDict.keys():
            for moduleSuffix in self.instInfoDict[instGrp].keys():
                for inst in self.instInfoDict[instGrp][moduleSuffix]['instList']:

                    if ('GPIB' in inst['bus']) or ('USB' in inst['bus']):
                        instInRsc = False
                    else:
                        instInRsc = True  # resource list only works for these types

                    for rsc in resourceList:
                        rsc = re.sub('^RSNRP::', 'USB::', rsc)
                        if (inst['bus'] in rsc) and (inst['addr'] in rsc):
                            instInRsc = True
                            break
                    if instInRsc == False:
                        # pop current inst - not found in resource list
                        self.instInfoDict[instGrp][moduleSuffix]['instList'].pop(
                            self.instInfoDict[instGrp][moduleSuffix]['instList'].index(inst))

    # -------------------------------------------------------------------------------

    def findDriverForInst(self, interface, addr, moduleSuffix):
        #        print('in find ',interface,addr,moduleSuffix)
        self.logger.debug('in find ' + interface + ' ' + str(addr) + '-' + moduleSuffix)

        # Find the group the requested instrument belongs to.
        reqGrp = None
        for instGrp in self.instInfoDict.keys():
            if moduleSuffix in self.instInfoDict[instGrp].keys():
                reqGrp = instGrp
                break
        if reqGrp == None:
            errstr = "Error, no driver found matching '" + moduleSuffix + "."
            #           print( errstr )
            self.logger.warning(errstr)
            return False

        # Look to see if instrument associated with specific driver is on bus.
        for inst in self.instInfoDict[reqGrp][moduleSuffix]['instList']:
            if interface in inst['bus'] and str(addr) == str(inst['addr']):
                reqIndx = self.instInfoDict[reqGrp][moduleSuffix]['instList'].index(inst)
                return [reqGrp, moduleSuffix, reqIndx]

        # If we're here, instrument using specified driver matching moduleSuffix was not previously identified on the
        # bus at the specified address.If driver specifies particular instrument option string, then substituting
        # another instrument is not allowed.
        moduleHandle = self.instInfoDict[reqGrp][moduleSuffix]['handle']
        if hasattr(moduleHandle, 'optString') and moduleHandle.optString != '':
            errstr = ("Requested driver '{}', requires specific instrument model '{}' with options '{}'."
                      .format(moduleSuffix, moduleHandle.idnString, moduleHandle.optString))
            #           print( errstr )
            raise RuntimeError(errstr)

        # See if there is another instrument belonging to same group as the
        # requested driver.

        drivers = list(self.instInfoDict[instGrp].keys())
        drivers.pop(drivers.index(moduleSuffix))

        requestedSuffix = moduleSuffix

        for moduleSuffix in drivers:
            for inst in self.instInfoDict[reqGrp][moduleSuffix]['instList']:
                if ((interface in inst['bus']) and (str(addr) == str(inst['addr']))):
                    reqIndx = self.instInfoDict[reqGrp][moduleSuffix]['instList'].index(inst)
                    wrnstr = "WARNING: Substituted {} '{}' for requested type '{}' at {} address {}.".\
                        format(reqGrp, moduleSuffix, requestedSuffix, interface, addr)
                    self.logger.warning(wrnstr)
                    return [reqGrp, moduleSuffix, reqIndx]

        # did not find requested instrument in same group.  exit with error
        errstr = 'Error, did not find ' + requestedSuffix + ' instrument at address ' + str(addr) + '.'
        raise RuntimeError(errstr)

        return False

    # -------------------------------------------------------------------------------

    def getInstMfgidn(self, rsc):
        inst = self.resourceManager.open_resource(rsc)
        try:
            mfgidn = inst.query('*IDN?')
            mfgidn = mfgidn.strip()
        except pyvisa.errors.VisaIOError:
            print(f"IDN timeout '{rsc}'")
            mfgidn = None
        finally:
            inst.close()
        return mfgidn

    # -------------------------------------------------------------------------------

    def getInstOpt(self, rsc):
        inst = self.resourceManager.open_resource(rsc)
        #        print(rsc)
        opts = inst.query('*OPT?')
        inst.close()
        return opts.strip()

    # -------------------------------------------------------------------------------

    def makeInstList(self, headerList=[]):
        # given headers, return list of active and attached instruments
        validHeaderList = ['instGrp', 'idnStr', 'status', 'version', 'addr', 'mfg', 'bus', 'model', 'lastCalledBy',
                           'thisCaller', 'serial']
        retList = []
        for grp in self.instInfoDict.keys():
            for idn in self.instInfoDict[grp].keys():
                if len(self.instInfoDict[grp][idn]['instList']) > 0:
                    for inst in self.instInfoDict[grp][idn]['instList']:
                        indx = self.instInfoDict[grp][idn]['instList'].index(inst)
                        retInstList = []
                        for item in headerList:
                            if item not in validHeaderList:
                                #                                print("Error: invalid header-- " + str(item))
                                self.logger.warning("Error: invalid header-- " + str(item))
                            else:
                                if item == 'instGrp':
                                    retInstList.append(grp)
                                elif item == 'idnStr':
                                    retInstList.append(idn)
                                else:
                                    retInstList.append(self.instInfoDict[grp][idn]['instList'][indx][item])
                        retList.append(retInstList)
        return retList

    # -------------------------------------------------------------------------------

    # this method is used to load the instrument modules that exist locally.
    # by running this method, the instrument manager discovers which instruments have modules.
    # eventually, need to include modules that are for generic instruments ie. meter, power supply rather than a specific instrument.

    def updateInstModules(self, interface):
        """Imports instrument modules located in folders inside InstMgr folder.
        """

        # Get list of files (driver modules) in the directory corresponding to
        # the specified interface. Assumes interface directories are under the
        # directory where instMgr.py is located.

        mgrRootDir = os.path.dirname(os.path.abspath(__file__))
        instModuleDir = os.path.join(mgrRootDir, interface)
        # print(instModuleDir)
        sys.path.append(instModuleDir)
        instModuleList = glob.glob(instModuleDir + '/*.py')
        #        print('interface ' + interface + ' module list ' + str(len(instModuleList)))

        for modulePath in instModuleList:
            if '__init__' in modulePath:
                continue
            #           print('modulePath ' + modulePath)

            instModuleName = os.path.splitext(os.path.basename(modulePath))[0]
            #            print('-'*10 + instModuleName + '-'*10)
            self.logger.debug('-' * 5 + instModuleName)

            instGrp, moduleSuffix = self._split_module_name(instModuleName)

            # new updates
            if instGrp not in self.instInfoDict.keys():
                self.instInfoDict[instGrp] = {}

            # why run this next line for every update?  should only update if doesnt' exist...
            instModule = __import__(instModuleName)  # sources each module file

            if moduleSuffix not in self.instInfoDict[instGrp].keys():
                self.instInfoDict[instGrp][moduleSuffix] = {'moduleName': instModuleName, 'handle': instModule,
                                                            'instList': []}

    def _split_module_name(self, module_name):
        pieces = module_name.split('_')
        if len(pieces) < 2:
            raise ValueError(f"Bad module_name '{module_name}', must begin with name of inst_group followed by '_'.")
        if len(pieces) > 2:
            # This allows for a suffix that contains '_'.
            pieces[1] = '_'.join(pieces[1::])
            pieces = pieces[0:2]
        return pieces

    # -------------------------------------------------------------------------------

    def close(self):
        self.resourceManager.close()

    # -------------------------------------------------------------------------------

    # checkout procedure
    #   test is responsible for knowing interface/address and instrument it wants to talk to.
    #   instrument manager then checks if this is on the bus.
    #       makes pyvisa instance
    #       passes pyvisa instance reference to instrument class
    #       returns instrument class reference to calling routine.
    #   does not lock out if instrument is checked out, only updates last caller.  that way test can keep track if new init is needed
    #   --- assume APx dervied classes will only be called once per setup, so won't have more than one derived class showing active status.

    def checkout(self, objName='inst1', interface='GPIB0', addr=None, moduleSuffix=None):

        if moduleSuffix == None:
            self.logger.error('Error: No instrument driver moduleSuffix entered. Checkout aborted')
            return -1

        # check if requested instrument is connected to the system
        instId = self.findDriverForInst(interface, addr, moduleSuffix)

        if type(instId) is not list:
            #           print('Error: checkout aborted, requested instrument not found.')
            self.logger.warning('Error: checkout aborted, requested instrument not found.')
            return -2

        grp, moduleSuffix, instIndx = instId[0], instId[1], instId[2]

        instrRecord = self.instInfoDict[grp][moduleSuffix]['instList'][instIndx]

        if instrRecord['status'] != 'active':  # not previously checked out

            moduleName = self.instInfoDict[grp][moduleSuffix]['moduleName']
            moduleHandle = self.instInfoDict[grp][moduleSuffix]['handle']
            instClassName = moduleName[0].title() + moduleName[1:]

            if ('GPIB' in interface) or ('USB' in interface) or ('COM' in interface):
                rsc = instrRecord['rsc']
                rscHandle = self.resourceManager.open_resource(rsc)  # opens connection to instrument
                instrInstance = getattr(moduleHandle, instClassName)(rscHandle)
            else:
                instrInstance = getattr(moduleHandle, instClassName)()

            for key, val in [['status', 'active'], ['objPtr', instrInstance],
                             ['thisCaller', sys._getframe(1).f_code.co_name], ['Name', objName]]:
                instrRecord[key] = val

        else:  # instrument object already exists, just change owner to save initialization time.

            instrRecord['lastCalledBy'] = self.instInfoDict[grp][moduleSuffix]['instList'][instIndx]['thisCaller']
            instrRecord['thisCaller'] = sys._getframe(1).f_code.co_name
            instrInstance = instrRecord['objPtr']

        return instrInstance

    # -------------------------------------------------------------------------------

    def resetCaller(self):
        for grp in self.instInfoDict.keys():
            for moduleSuffix in self.instInfoDict[grp].keys():
                for indx in range(len(self.instInfoDict[grp][moduleSuffix]['instList'])):
                    self.instInfoDict[grp][moduleSuffix]['instList'][indx]['thisCaller'] = None
                    self.instInfoDict[grp][moduleSuffix]['instList'][indx]['lastCalledBy'] = None

    # -------------------------------------------------------------------------------

    def sameCaller(self, objName='inst1', interface='GPIB', addr=None, moduleSuffix=None):

        if moduleSuffix == None:
            print('Error: sameCaller aborted, requested instrument not found.')
            self.logger.error('Error: sameCaller aborted, requested instrument not found.')
            return -1

        # check if requested instrument is connected to the system
        instId = self.findDriverForInst(interface, addr, moduleSuffix)
        if type(instId) is list:
            grp, moduleSuffix, instIndx = instId[0], instId[1], instId[2]
            instrRecord = self.instInfoDict[grp][moduleSuffix]['instList'][instIndx]
            if (instrRecord['status'] == 'active') and (
                    instrRecord['lastCalledBy'] == instrRecord['thisCaller']):  # previously checked out
                return True
            else:
                return False

    # -------------------------------------------------------------------------------

    def whatinst(self):
        headings = ['Manufacturer', 'Model', 'group', 'Driver Suffix', 'Name', 'Bus', 'Address']
        inst = []
        self.instrument_list = []
        for grp in self.instInfoDict.keys():
            for moduleSuffix in self.instInfoDict[grp].keys():
                for indx in range(len(self.instInfoDict[grp][moduleSuffix]['instList'])):
                    x = self.instInfoDict[grp][moduleSuffix]['instList'][indx]
                    info = x['mfg'], x['model'], grp, moduleSuffix, x['Name'], x['bus'], x['addr']
                    inst.append(['None' if x == None else x for x in info])
                    x['moduleSuffix'] = moduleSuffix
                    x['in_use'] = ""
                    x[grp] = grp
                    self.instrument_list.append(x)

        widths = [len(val) for val in headings]

        for row in inst:
            new_widths = [len(val) for val in row]
            for i, (new, old) in enumerate(zip(new_widths, widths)):
                widths[i] = max(new, old)

        print('\n')
        print(" ".join(val.ljust(width) for val, width in zip(headings, widths)))
        for row in inst:
            print(" ".join(val.ljust(width) for val, width in zip(row, widths)))


# ===============================================================================

if __name__ == "__main__":
    import os, sys, glob, re

    # create logger for InstMgr
    InstMgr_logger = logging.getLogger('marv')
    if not InstMgr_logger.handlers:
        #InstMgr_logger =  logging.getLogger(__name__)

        # set logger level to DEBUG
        # TODO - may consider to place it in InstMgr with a funciton
        InstMgr_logger.setLevel(logging.INFO)
        fh = logging.FileHandler(filename='InstMgrLog.log', mode='w')
        # fh.setLevel(logging.WARNING)
        fh.setLevel(logging.DEBUG)
        sh = logging.StreamHandler()
        sh.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(levelname)s - %(asctime)s - %(name)s - %(funcName)s - %(message)s')
        fh.setFormatter(formatter)
        sh.setFormatter(formatter)
        InstMgr_logger.addHandler(fh)
        InstMgr_logger.addHandler(sh)
        InstMgr_logger.debug('Logger is created')


    instMgr = InstMgr()

    #ps5 = instMgr.checkout(objName='fred', addr=5, moduleSuffix='E3631A')
    ps6 = instMgr.checkout( objName='wilma', addr=6,  moduleSuffix='E3631A')
    m18 = instMgr.checkout(objName='barney', addr=18, moduleSuffix='DMM2000')
    m19 = instMgr.checkout(objName='betty', addr=19, moduleSuffix='DMM2000SCAN')
    scope = instMgr.checkout( interface='USB', addr='0x0699::0x0401::C022553', moduleSuffix='DPO4034')

    #   meter2 = instMgr.checkout(objName='meter',addr=25,moduleSuffix='34401A')
    #    apx = instMgr.checkout(objName='apx',interface='OTHER',addr=0,moduleSuffix='AP500_DIG_ASIC')
    #    that = 'that'

    instMgr.whatinst()

    fh.close()
    InstMgr_logger.removeHandler(fh)
    InstMgr_logger.removeHandler(sh)