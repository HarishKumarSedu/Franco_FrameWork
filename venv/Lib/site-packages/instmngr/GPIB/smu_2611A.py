# -*- coding: utf-8 -*-
"""
Created on Thu May 10 09:29:40 2018

@author: jmunger
"""

import sys
import time
import logging

idnString = 'Model 2611A'

class Smu_2611A():

    #index 0 in options tuple could be assumed to be the default
    #here, innermost dict is command mmenmoic:{current value,(possible values),SCPI base command,flag that value needs updated to instrument}
    instDict = {
                'source': {
                    'ch1autorangev':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON'},'autorangev'],
                    'ch1voltRange':[200e-3,(1e-6,20),'rangev'],
                    'ch1autorangei':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON'},'autorangei'],
                    'ch1currRange':[100e-9,(1e-9,1.5),'rangei'],
                    'ch1function':['smua.OUTPUT_DCVOLTS',{'I':'smua.OUTPUT_DCAMPS','V':'smua.OUTPUT_DCVOLTS'},'func'],
                    'ch1offFunction':['smua.OUTPUT_DCVOLTS',{'I':'smua.OUTPUT_DCAMPS','V':'smua.OUTPUT_DCVOLTS'},'offfunc'],
                    'ch1offMode':['smua.OUTPUT_NORMAL',{'normal':'smua.OUTPUT_NORMAL','zero':'smua.OUTPUT_ZERO','highz':'smua.OUTPUT_HIGH_Z'},'offmode'],
                    'ch1voltLevel':[0,(-20,20),'levelv'],
                    'ch1currLevel':[0,(-1.5,1.5),'leveli'],
                    'ch1voltLimit':[20,(-20,20),'limitv'],
                    'ch1currLimit':[100e-3,(-1.5,1.5),'limiti'],
                    'ch1powerLimit':[0,(0,30),'limitp'],
                    'ch1output':['smua.OUTPUT_OFF',{'off':'smua.OUTPUT_OFF','on':'smua.OUTPUT_ON','highz':'smua.OUTPUT_HIGH_Z'},'output'],
                    'ch1settling':['smua.SETTLE_SMOOTH',{'smooth':'smua.SETTLE_SMOOTH','fastRange':'smua.SETTLE_FAST_RANGE','fastPolarity':'smua.SETTLE_FAST_POLARITY','directCurr':'smua.SETTLE_DIRECT_IRANGE'},'settling'],
                    'ch1sink':['smua.DISABLE',{'disable':'smua.DISABLE','enable':'smua.ENABLE'},'sink'],
                },
                'measure': {
                    'ch1autorangev':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON','follow':'smua.AUTORANGE_FOLLOW_LIMIT'},'autorangev'],
                    'ch1voltRange':[200e-3,(1e-6,20),'rangev'],
                    'ch1autorangei':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON','follow':'smua.AUTORANGE_FOLLOW_LIMIT'},'autorangei'],
                    'ch1currRange':[100e-9,(1e-9,1.5),'rangei'],
                    'ch1single':['smua.measure.v()',{'voltage':'smua.measure.v()','current':'smua.measure.i()','power':'smua.measure.p()'},''],
                    'ch1display':['display.MEASURE_DCAMPS',{'voltage':'display.MEASURE_DCVOLTS', 'current':'display.MEASURE_DCAMPS', 'resistance':'display.MEASURE_OHMS', 'power': 'display.MEASURE_WATTS'},'display.smua.measure.func=']
                },
    }

    chDict = {1: 'smua'}
    
    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Smu_2611A')
        self.logger.info('Initializing Smu_2611A instrument')

    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('reset()')        
        pass

    def rebelScum(self):
        self.rmHandle.write("beeper.enable = beeper.ON")
        marchList = [(.500,500),(.500,500),(.500,500),(.350,400),(.150,600),(.500,500),(.350,400),(.150,600),(.650,500),(.150,1),(.500,750),(.500,750),(.500,750),(.350,810),(.150,600),(.500,470),(.350,400),(.150,600),(.650,500)]
        for note in marchList:
            self.rmHandle.write("beeper.beep" + str(note))
            self.rmHandle.write("beeper.beep(.1,10)")
            

    def setSrcParam(self,param='ch1autorangev',val='on'):
        inputValid = 0
        cmdhdr = self.chDict[int(param[2])] + '.source.'
        if param in self.instDict['source'].keys():
            if isinstance(self.instDict['source'][param][0],str):
                #it's a string
                if val in self.instDict['source'][param][1].keys():
                    self.instDict['source'][param][0] = self.instDict['source'][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['source'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['source'][param][1] is None ) or ((self.instDict['source'][param][1] is not None) and (val >= self.instDict['source'][param][1][0] ) and (val <= self.instDict['source'][param][1][1] ) ):
                    self.instDict['source'][param][0] = val
                else:
                    self.logger.warning('WARNING: Input value is out of instrument capable range! Min value will be assigned to instrument instead!')
                    self.instDict['source'][param][0] = self.instDict['source'][param][1][0]
                inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
        if inputValid == 1:
            #TODO: check this!
            self.rmHandle.write('smua.source.' + self.instDict['source'][param][2] + ' = ' + str(self.instDict['source'][param][0]))
    
    def setOutputState(self,src=1,val='off'):
        inputValid = 0
        opch = 'ch' + str(src) + 'output'
        cmdhdr = self.chDict[src] + '.source.output = '
           
        if val in self.instDict['source'][opch][1].keys():
            self.instDict['source'][opch][0] = self.instDict['source'][opch][1][val]
            inputValid = 1
        else:
            self.logger.warning('WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['source']['output'][1].keys()))
        if inputValid:
            self.rmHandle.write(cmdhdr + str(self.instDict['source'][opch][0]))
    
    def setMeasParam(self,param='autorangev',val='on'):
        inputValid = 0
        cmdhdr = self.chDict[int(param[2])] + '.measure.'
            
        if param in self.instDict['measure'].keys():
            if isinstance(self.instDict['measure'][param][0],str):
                #it's a string
                if val in self.instDict['measure'][param][1].keys():
                    self.instDict['measure'][param][0] = self.instDict['measure'][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['measure'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['measure'][param][1] is None ) or ((self.instDict['measure'][param][1] is not None) and (val >= self.instDict['measure'][param][1][0] ) and (val <= self.instDict['measure'][param][1][1] ) ):
                    self.instDict['measure'][param][0] = val
                    inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
        if inputValid == 1:
            sendStr = cmdhdr + self.instDict['measure'][param][2] + ' = ' + str(self.instDict['measure'][param][0])
            #print(sendStr)
            self.rmHandle.write(sendStr)

    def getSrcInComplianceLimit(self, src=1):
        #should return true / false.  true indicates instrument is controlled by limit setting, false indicates instrument is controlled by source setting
        if src == 1:
            self.rmHandle.write('compliance = smua.source.compliance')
        else:
            self.logger.error('ERROR - 2611A is single channel SMU')
            
        return self.rmHandle.query('print(compliance)')
        
    
    def getMeas(self,src=1, param='voltage'):
        inputValid = 0
        single = 'ch' + str(src) + 'single'
        display = 'ch' + str(src) + 'display'
        
        if param not in self.instDict['measure'][single][1].keys():
            self.logger.warning('WARNING - requested measurement unavilable to instrument class.  Valid options are ' + ','.join(self.instDict['measure'][single][1].keys()))
        else:
            self.instDict['measure'][single][0] = self.instDict['measure'][single][1][param]
            self.instDict['measure'][display][0] = self.instDict['measure'][display][1][param]
            inputValid = 1
        if inputValid:
            measStr = 'measval = ' + self.instDict['measure'][single][0]
            self.rmHandle.write(measStr)
            retval = self.rmHandle.query('print(measval)')
            displayStr = self.instDict['measure'][display][2] + self.instDict['measure'][display][0]
            self.rmHandle.write(displayStr)
        return retval             
    
    def configVSrc(self, src=1, vlevel=1.8, ilimit=0.1):
        src_setup = [
                     ('ch'+str(src)+'function', 'V'),
                     ('ch'+str(src)+'autorangev','off'),
                     ('ch'+str(src)+'voltRange', abs(vlevel)+1),
                     ('ch'+str(src)+'offMode', 'zero'),
                     ('ch'+str(src)+'voltLevel', vlevel),
                     ('ch'+str(src)+'voltLimit', abs(vlevel)+1),
                     ('ch'+str(src)+'currLimit', ilimit),                
                     ]
        
        for param,val in src_setup:
            #print('\tParamepter ', param, '\t Value ', val )
            self.setSrcParam(param=param, val=val)
            time.sleep(0.2)
            
    def configISrc(self, src=1, ilevel= 0.1, vlimit=1.8):
        if vlimit <=0:
            vlimit = 0.1

        src_setup = [
                     ('ch'+str(src)+'function', 'I'),
                     ('ch'+str(src)+'autorangei','off'),
                     ('ch'+str(src)+'currRange', ilevel + 0.1),
                     ('ch'+str(src)+'offMode', 'zero'),
                     ('ch'+str(src)+'currLevel', ilevel),
                     ('ch'+str(src)+'currLimit', ilevel+ 0.1),
                     ('ch'+str(src)+'voltLimit', vlimit),                
                     ]
        
        for param,val in src_setup:
            #print('\tParamepter ', param, '\t Value ', val )
            self.setSrcParam(param=param, val=val)
            time.sleep(0.2)
    
    def configIMeas(self, src=1, spd=1, filtercount=10):
        IMeasetup = [
                  ('ch'+str(src)+'filterenable', 'on'),
                  ('ch'+str(src)+'autorangei', 'on'),
                  #('autorangev', 'on'),
                  ('ch'+str(src)+'measspeed', spd),
                  ('ch'+str(src)+'filtertype', 'repeat'),
                  ('ch'+str(src)+'filtercount', filtercount),
                 ]
        for param,val in IMeasetup:
            #print('\tParamepter ', param, '\t Value ', val )
            self.setMeasParam(param=param, val=val)
            time.sleep(0.2)
        self.rmHandle.write('display.'+self.chDict[src]+'.measure.func=display.MEASURE_DCAMPS')
        time.sleep(0.2)

    def setMeasAccuracy(self, spd = 1, filtEn = 'off', filtType = 'movingAvg', filterCount = 0):
        self.rmHandle.write('smua.measure.nplc = ' + str(spd))
        
        if(filtEn == 'on'):
            self.rmHandle.write('smua.measure.filter.enable = smua.FILTER_ON')
            if(filtType == 'repeatAvg'):
                self.rmHandle.write('smua.measure.filter.type = smua.FILTER_REPEAT_AVG')
            elif(filtType == 'median'):
                self.rmHandle.write('smua.measure.filter.type = smua.FILTER_MEDIAN')  
            else:
                self.rmHandle.write('smua.measure.filter.type = smua.FILTER_MOVING_AVG') 
            self.rmHandle.write('smua.measure.filter.count = ' + str(filterCount))
        pass

    def sink_enable(self, src=1, en=1):
        if src==1:
            if en == 1 or en is True:
                self.rmHandle.write('smua.source.sink=1')
            else:
                self.rmHandle.write('smua.source.sink=0')

    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass

    pass

if __name__ == "__main__":
    
    import os
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    mi = instMgr.checkout( interface='GPIB', addr=26, moduleSuffix='2611A' )
    mi.reset()
    print(mi.getIdn())
#    mi.setOutputVal(output='p5v')
#    mi.setOutputVal(output='P6V',vSet=5.0,iSet=10e-3)
#    mi.setOutputVal(output='P25V',vSet=15.0,iSet=0.1)
#    mi.setOutputVal(output='N25V',vSet=-15.0,iSet=0.1)
    
    #set up voltage source with unlimited current
    setupList1 = [('ch1autorangev','off'),
                 ('ch1autorangei','on'),
                 ('ch1voltRange', 2),
                 ('ch1function', 'V'),
                 ('ch1offMode', 'highz'),
                 ('ch1voltLevel', 0),
                 ('ch1voltLimit', 0.01),
                 ('ch1currLimit', 0.1),
                 ]             
    for param,val in setupList1:
        mi.setSrcParam(param=param, val=val)
        
    mi.setOutputState(1,'on')
    mi.setOutputState(1,'off')
   
#    mi.close()
    pass    