# -*- coding: utf-8 -*-
"""
Created on Wed Oct 9 14:28:56 2019

@author: dzhang
"""

import sys
from time import sleep
import logging
import time

idnString = 'ECO-710'  

err_msg_dict = {

}

class Temp_Eco710M():
    
    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.soakTimeSec = 120
        self.soakTimeElapsed = 0
        self.currentTempC = None
        self.currentStatus = None
        self.setTempC = None
        self.numDec = 0  #number of decimal places required for commands
        
        # op_mode means 'Operator screen' mode
        # false means cycle screen mode
        self.op_mode = True # default is operator screen mode
        
        self.stateList = ['IDLE','TRANSITION','SOAK','AT_TEMP']
        self.state = 'IDLE'
        self.logger = logging.getLogger('marv.inst.Temp_Eco710M')
        self.logger.info('Initializing Temp_Eco710M instrument')
        
        self.reset()

    
    def reset(self):
        if not self.op_mode: 
            self.rmHandle.write('*RST')     # reset to cycle screen
        else:
            self.rmHandle.write('RSTO')     # reset to operator screen
        # 4 secs wait time is required before sending any command
        sleep(5)
        
        self.state = 'IDLE'
        # after reset config unit for next operation
        self.rmHandle.write('ADMD 100')  # set the air-to-DUT max difference in degC
#        self.rmHandle.write('DTYP 0')   # set the DUT type to smallest DUT mass
#        self.rmHandle.write('DUTC 50')  # set device thermal constant
        self.rmHandle.write('LLIM -60') # set lower air temp to -60C
        self.rmHandle.write('ULIM 150') # set upper air temp to 150C
        self.rmHandle.write('TTIM 9999') # set allowable test time
        # self.rmHandle.write('STIM 720')   # set shutdown time to 12 hours
        self.rmHandle.write('STIM 0')   # disable shutdown timer
        self.setTempWindow()
        self.setTempSensing()
        if self.op_mode == False:
            self.setcycle(1)
        pass
    
    def setSoakTimeSec(self,soaktime=120, Tpoint=0):
        self.soakTimeSec = soaktime
        if self.op_mode:
            if self.setTempC > 25:
                self.rmHandle.write('SETN ' + str(0))
            elif self.setTempC < 25:
                self.rmHandle.write('SETN ' + str(2))
            else:
                self.rmHandle.write('SETN ' + str(1))
        else:
            self.rmHandle.write('SETN ' + str(Tpoint))

        self.rmHandle.write('SOAK ' + str(soaktime))
        
    def getCurrentTemp(self):
        # this is to get the DUT temp 
        self.currentTempC = float(self.rmHandle.query('TMPD?').split(' ')[0])
        return self.currentTempC
        
    def getCurrentTempStatus(self):
        ''' Read the temp event status register:   
                bit7 - datalogging on
                bit6 - not used
                bit5 - stopped cycling ('stop on fail' signal was received)
                bit4 - end of all cycles
                bit3 - end of one cycle
                bit2 - end of test(test time has elaspsed)
                bit1 - not at temperature
                bit0 - at temperature(soak time has elaspsed)
        '''
#        self.rmHandle.write('TESR?')       # Note that these bits are automatically cleared when the temp event status register is read 
        self.rmHandle.write('TECR?')
        self.currentStatus = int(self.rmHandle.read().strip())
        return self.currentStatus

    def setTemp(self,setTempC=25.0, ramp_rate=100, air_flow=8):
        """
        Set target temperature
        :param setTempC: set target temperature in Degree C
        :param ramp_rate: set the ramp rate for the currently selected set point, in Â°C per minute
        :param air_flow: set desired air flow in scfm, range 5-18
        :return:
        """
        self.setTemp_init(Tpoint=0, temp=setTempC)
        self.logger.debug(self.rmHandle.query('SETP?'))
        self.setRAMPrate(ramp_rate)
        self.setAirFlow(air_flow)
        sleep(1)
        if self.headStatus() == 0: #head is up
            self.headMove(move='down') #put head down
        sleep(3)
        if self.op_mode:
            self.airFlow(1)
        else:
            self.startcycle()
        sleep(2)

        self.evalTempState()
        #later, add error checking here & return success or error code
        
    def evalTempState(self, marginC=0.5):
        self.getCurrentTemp()
        # TODO: getCurrentTempStatus funciton is disabled as the Status reg only returns the status for once and further reading remains 0 until status changed
        self.getCurrentTempStatus()
        tempDelta = abs(self.currentTempC - self.setTempC)
        if self.state == 'IDLE':
            if tempDelta > marginC:
#            if self.currentStatus == 0:
                self.state = 'TRANSITION'
                self.logger.info('Temp Transition Begin from idle')
        elif self.state == 'TRANSITION':
            if tempDelta < marginC:
#            if self.currentStatus == 2:
                self.state = 'SOAK'
                self.logger.info('Temp Soak Begin')
        elif self.state == 'SOAK':
            if self.soakTimeElapsed == self.soakTimeSec:
                if bool(1 & self.currentStatus):
                    self.state = 'AT_TEMP'
                    self.soakTimeElapsed = 0
                    self.logger.info('Temp Soak End')
        elif self.state == 'AT_TEMP':
            if tempDelta > marginC:
#            if self.currentStatus == 0:
                self.state = 'TRANSITION'
                self.logger.info('Temp Transition Begin')
            

    def waitTempTransition(self,marginC=0.5):
        timerTick = 1 #second
        while self.state != 'AT_TEMP':
            while self.state == 'TRANSITION':
                self.logger.info('Temp transition: set ' + str(self.setTempC) + ' current ' + str(self.currentTempC))
                sleep(1)            
                self.evalTempState(marginC=marginC)
            while self.state == 'SOAK':
                sleep(timerTick)
                self.soakTimeElapsed = self.soakTimeElapsed + timerTick
                self.evalTempState(marginC=marginC)
                self.logger.debug('Soaking...')
        self.logger.info( 'At Temperature: set ' + str(self.setTempC) + ' current ' + str(self.currentTempC))
                
            
    def setTempSensing(self, TStype=1):
        """
        Set temperature sensing sensor type
        :param TStype:
            0 - no DUT sensor
            1 - type T thermocouple
            2 - type K thermocouple
            3 - RTD
            4 - diode
        :return:
        """
        self.rmHandle.write('DSNS '+str(TStype))
        pass         
        
    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
    
    '''
    Below is the commands that might be useful 
    '''
    def cool(self, status = '1'):
        # status = '1' - set compressor on 
        # status = '0' - set compressor off
        cmd = 'COOL ' + status
        self.rmHandle.write(cmd)
        
    def setcycle(self, num_cycle = 1):
        cmd = 'CYCC ' + str(num_cycle)
        if not self.op_mode:
            self.rmHandle.write(cmd)
    
    def startcycle(self):
        if not self.op_mode:
            self.rmHandle.write('CYCL 1')
        
    def stopcycle(self):
        if not self.op_mode:
            self.rmHandle.write('CYCL 0')
        
    def pausecycle(self):
        if not self.op_mode:
            self.rmHandle.write('CYCP 1')
        
    def restartcycle(self):
        if not self.op_mode:
            self.rmHandle.write('CYCP 0')
    
    def setDUTmode(self, mode = 1):
        # 0: off (air control)
        # 1: on (DUT control)
        # 2: TC Meter mode
        self.rmHandle.write('DUTM ' + str(mode))
        
    def airFlow(self, status = 1):
        # 1: on 
        # 0: off
        self.rmHandle.write('FLOW ' + str(status))
        
    def getAirFlow(self, unit = 'l'):
        if unit == 'l':         # unit in liters/sec
            return self.rmHandle.query('FLRL?')
        else:                   # unit in scfm
            return self.rmHandle.query('FLRE?')
    
    def setAirFlow(self, rate=10):
        if rate < 5 or rate > 18:
            self.logger.warning('WARNING: the rate shoud be in range of 5 and 18 scfm')
        else:
            self.rmHandle.write('FLSE ' + str(rate))
            
    def headMove(self, move='down'):
        """
        Move thermo head up or down
        :param move: default value is 'down', other string will move head up
        :return:
        """
        if self.rmHandle.query('HDLK?') != '0':
            self.rmHandle.write('HDLK 0')   # unlock head movement
            if move == 'down':
                self.rmHandle.write('HEAD 1')
            else:
                self.rmHandle.write('HEAD 0')
                
    def headStatus(self):
        return int(self.rmHandle.query('HEAD?').strip())
    
     
    def setRAMPrate(self, rate=100):
        if rate > 9999 or rate < 0:
            self.logger.error('ERROR: ramp rate is in range of 0 and 9999')
        else:
            if rate < 99.9:
                self.rmHandle.write('RAMP ' + str("%.1f" % rate))
            else:
                self.rmHandle.write('RAMP ' + str(int(rate)))


    def setTemp_init(self, Tpoint=0, temp=25.0):
        if not self.op_mode:
            self.rmHandle.write('SETN ' + str(Tpoint))
        else:
            if temp > 25:       # HOT
                self.rmHandle.write('SETN ' + str(0))
            elif temp < 25:     # COLD
                self.rmHandle.write('SETN ' + str(2))
            else:               # ambient
                self.rmHandle.write('SETN ' + str(1))

        self.rmHandle.write('SETP '+str("%.1f" % temp))
        self.setTempC = temp


    def getOpType(self):
        return self.rmHandle.query('WHAT?')
    
    def setTempWindow(self, window=1):
        if window > 9.9 or window < 0:
            self.logger.error('ERROR: temp window needs to be in range of 0 and 9.9') 
        else:
            self.rmHandle.write('WNDW '+str("%.1f" % window))
            
    def getTempWindow(self):
        return self.rmHandle.query('WNDW?')
    
    def errorStatus(self):
        error_code = self.rmHandle.query('EROR?')
        error_msg = {}
        #TODO: decode error message below
        pass

    def set_shutdown_timer(self, t_in_m=0):
        """
        Set the shutdown timer to shutdown the system after t_in_m minutes
        :param t_in_m:
        :return:
        """
        self.rmHandle.write(f'STIM {str(t_in_m)}')

    def get_shutdown_timer(self):
        """
        Get the shutdown timer and return the value
        :return:
        """
        return int(self.rmHandle.query('STIM?'))

    def get_current_target_temp(self):
        """
        Get the current target temperature in C
        :return:
        """
        return float(self.setTempC)

    def run(self, target_temp=25, soak_time=30):
        """
        Run to set temperature
        :param target_temp:
        :param soak_time: set basic soak_time in s for temp delta less than 0.5C.
            Temp delta less than 10C will be 2 * soak_time + 5
            Temp delta larger than 10C, soak time will be 4 * soak_time + 5
        :return:
        """
        currentTemp1 = self.getCurrentTemp()
        tempDelta = abs(currentTemp1 - float(target_temp))

        self.setTemp(float(target_temp))

        if tempDelta < 0.2:
            soaktime = 0
        elif tempDelta < 0.5:
            # 10 secs
            soaktime = soak_time
        elif tempDelta < 10:
            # 5 mins soak time
            soaktime = soak_time*2 + 5
        else:
            soaktime = soak_time*4 + 5

        self.setSoakTimeSec(soaktime)

        tempMargin = 0.8 * float(self.getTempWindow())
        elapsed_time = 0
        tempsoak = 0
        interval = 5
        while 1:
            self.currentStatus = self.getCurrentTempStatus()

            currentTemp = self.getCurrentTemp()
            tempDelta = abs(currentTemp - float(target_temp))

            sys.stdout.write("\r")
            if (tempDelta < tempMargin):
                tempsoak += interval
                soakstr = f' | Soak: {int(soaktime - tempsoak)}'
                # sys.stdout.write(f"STATUS: {self.thermo.currentStatus} | Temp: {currentTemp} | Soak: {int(soaktime-tempsoak)}")
            else:
                soakstr = ''

            sys.stdout.write(
                f"STATUS: {self.currentStatus} | Temp init {currentTemp1} | Temp now : {currentTemp}{soakstr}")
            sys.stdout.flush()

            time.sleep(interval)
            elapsed_time += interval
            if bool(1 & self.currentStatus):
                print('\n    Target Temperature reached')
                rtn_value = 1
                break
            if elapsed_time > 30 * 60:
                print('\n    Failed to reach target temperature')
                rtn_value = 0
                break
        return rtn_value


if __name__ == "__main__":
    import os
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    ts = instMgr.checkout(interface='GPIB', addr=28, moduleSuffix='Eco710M')
    ts.reset()
    print(ts.getIdn())
    
    print(str(ts.getCurrentTemp()))
    ts.run(30)
    # ts.setSoakTimeSec(10)
    # while 1:
    #     ts.getCurrentTempStatus()
    #     print(ts.currentStatus)
    #     sleep(5)
    #     if bool(1 & ts.currentStatus):
    #         print('Target Temperature reached')
    #         break
    
