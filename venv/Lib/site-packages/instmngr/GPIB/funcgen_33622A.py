# -*- coding: utf-8 -*-
"""
Created on 10 Aug 2018 16:35:30 2018

@author: dzhang

Function list:
     __init__(rmHandle)
    setSource(src=1,shape='SQU',freq=1000,vhi=1.8,vlo=0)
    setOutputImp(src=1,imp='inf')
    setOutputStat(src=1,state='off')
    setInstParam(param, value)
    setMeasParam(param='autorangev',val='on')
    getSrcInComplianceLimit()
    getMeas(param='voltage')
    reset()
    getIdn()
    close()

"""

import sys
import logging

idnString = '33622A'


class Funcgen_33622A():
    instDict = {'discrete': {'function': ['SIN', {'sine': 'SIN', 'square': 'SQU', 'ramp': 'RAMP', 'pulse': 'PULS',
                                                  'noise': 'NOIS', 'dc': 'DC', 'arb':'ARB'}, 'SOUR1:FUNC'],
                             'outputenable': ['OFF', {'on': 'ON', 'ON': 'ON', 'off': 'OFF', 'OFF': 'OFF'}, 'OUTP'],
                             'outputload': ['50', {'50Ohm': '50', 'highz': 'INF'}, 'OUTP1:LOAD'],
                             'voltunit': ['VPP', {'Vpp': 'VPP', 'Vrms': 'VRMS', 'dBm': 'DBM'}, 'VOLT:UNIT'],
                             'polarity': ['NORM', {'normal': 'NORM', 'inverted': 'INV'}, 'OUTP1:POL'],
                             'voltrange': ['ON', {'on': 'ON', 'off': 'OFF', 'once': 'ONCE'}, 'SOUR1:VOLT:RANG:AUTO'],
                             'triggersource': ['IMM', {'immediate': 'IMM', 'external': 'EXT', 'bus': 'BUS'},
                                               'TRIG1:SOUR'],
                             'triggerslope': ['POS', {'positive': 'POS', 'negative': 'NEG'}, 'TRIG1:SLOP'],

                             'track': ['OFF', {'on': 'ON', 'off': 'OFF', 'inverted': 'INV'}, 'SOUR1:TRAC'],

                             'display': ['ON', {'on': 'ON', 'off': 'OFF'}, 'DISP'],
                             'burststate': ['ON', {'on': 'ON', 'off': 'OFF'}, 'BURS:STAT'],
                             'arbfilter': ['STEP', {'off':'OFF', 'norm':'NORM', 'step':'STEP'}, 'SOUR1:FUNC:ARB:FILT'],
                             },

                'continuous': {'frequency':         [1000, (1e-6, 80e6), 'SOUR1:FREQ'],
                               'burstncycle':       [1, (1, 1e9), 'BURS:NCYC'],
                               'burstphase':        [0, (-360, 360), 'BURS:PHAS'],
                               'voltage':           [0.1, (1e-3, 10), 'SOUR1:VOLT'],
                               'voltoffset':        [0, (-10, 10), 'SOUR1:VOLT:OFFS'],
                               # also depends on Vpp, need to be less than Vmax-Vpp/2
                               'volthigh':          [0.1, (1e-3, 10), 'SOUR1:VOLT:HIGH'],
                               'voltlow':           [0, (-10, 10), 'SOUR1:VOLT:LOW'],
                               'dutycycle':         [50, (20, 80), 'SOUR1:FUNC:SQU:DCYC'],
                               'symmetry':          [100, (0, 100), 'SOUR1:FUNC:RAMP:SYMM'],
                               'pulseperiod':       [1e-3, (20e-9, 2e3), 'SOUR1:FUNC:PULS:PER'],
                               'pulsedutycycle':    [50, (1, 100), 'SOUR1:FUNC:PULS:DCYC'],
                               'pulsewidth':        [1e-4, (8e-9, 2e3), 'SOUR1:FUNC:PULS:WIDT'],
                               'pulsetransition':   [3e-9, (3e-9, 1e-3), 'SOUR1:FUNC:PULS:TRAN'],
                               'triggerdelay':      [0, (0, 85), 'TRIG1:DEL'],
                               'triggerlevel':      [3.3, (0.9, 3.8), 'TRIG:LEV'],
                               'phase':             [0, (-360, 360), 'SOUR1:PHAS'],
                               'arbsrate':          [4e4, (0, 4e9), 'SOUR1:FUNC:ARB:SRAT'],
                               },
                }

    def __init__(self, rmhandle):
        self.rmHandle = rmhandle
        self.logger = logging.getLogger('marv.inst.Funcgen_33622A')
        self.logger.info('Initializing Funcgen_33622A instrument')

    def setSource(self, src=1, shape='SQU', freq=1000, vhi=1.8, vlo=0):
        self.instDict['discrete']['function'][0] = shape
        self.rmHandle.write(self.instDict['discrete']['function'][2].replace('1', str(src)) + ' ' + shape)
        self.rmHandle.write(self.instDict['continuous']['frequency'][2].replace('1', str(src)) + ' ' + str(freq))
        self.rmHandle.write(self.instDict['continuous']['volthigh'][2].replace('1', str(src)) + ' ' + str(vhi))
        self.rmHandle.write(self.instDict['continuous']['voltlow'][2].replace('1', str(src)) + ' ' + str(vlo))

        # self.setInstParam(param='frequency', value=freq)
        # self.setInstParam(param='volthigh', value=vhi)
        # self.setInstParam(param='voltlow', value=vlo)
        pass

    def setOutputImp(self, src=1, imp='inf'):
        if imp.upper() == 'INF':
            value = 'highz'
        else:
            value = '50Ohm'
            
        cmd = self.instDict['discrete']['outputload'][2].replace('1', str(src)) + ' ' + self.instDict['discrete']['outputload'][1][value]
        self.rmHandle.write(cmd)
        
        pass

    def setOutputStat(self, src=1, state='off'):
        # self.setInstParam(param='outputenable', value=state)
        cmd = 'OUTP' + str(src) + ' ' + str.upper(state)
        self.rmHandle.write(cmd)
        pass

    def quick_setOutput(self, src=1, shape='square', freq=1000, vpp=1.8, vos=0):
        # APPLy caommand - APPLy:<function> [<frequency> [,<amplitude> [,<offset>] ]]
        if shape in self.instDict['discrete']['function'][1].keys():
            sendStr = 'SOUR' + str(src) + ':APPL:' + shape + ' ' + str(freq) + ', ' + str(vpp) + ' VPP,' + str(vos) + ' V'
            # print('Send APPLY command string ' + sendStr)
            self.rmHandle.write(sendStr)
        else:
            self.logger.warning('WARNING - entered parameter is not recognized by instrument')
        #            print('Error: entered parameter is not recognized by instrument' )
        pass

    # Note - src is placed as the last to reduce the number of mods required with existing code
    def setInstParam(self, param, value, src=1):
        if param in self.instDict['discrete'].keys():
            if value in self.instDict['discrete'][param][1].keys():
                self.instDict['discrete'][param][0] = self.instDict['discrete'][param][1][value]
                sendStr = self.instDict['discrete'][param][2].replace('1', str(src)) + ' ' + self.instDict['discrete'][param][0]
                self.rmHandle.write(sendStr)
            else:
                self.logger.warning('WARNING - entered parameter is not recognized by instrument')
        #                print('Error: entered value is not recognized by instrument' )
        elif param in self.instDict['continuous'].keys():
            if (self.instDict['continuous'][param][1] is None) or (
                    (self.instDict['continuous'][param][1] is not None) and (
                    value >= self.instDict['continuous'][param][1][0]) and (
                            value <= self.instDict['continuous'][param][1][1])):
                self.instDict['continuous'][param][0] = value
                sendStr = self.instDict['continuous'][param][2].replace('1', str(src)) + ' ' + str(self.instDict['continuous'][param][0])
                self.rmHandle.write(sendStr)
            else:
                self.logger.warning('WARNING - entered parameter is not recognized by instrument')
        #                print('Error: entered value is not recognized by instrument' )
        else:
            self.logger.warning('WARNING - entered parameter is not recognized by instrument')
        #            print('Error: entered parameter is not recognized by instrument' )
        pass

    def setDiffOutput(self, func='sine', freq=1000, amplitude=0.1, offset=1.5, phase=0):
        if amplitude < 0.002:
            self.logger.warning('WARNING - The minimume amplitude is 2mV.')
            self.logger.warning('WARNING - Min value will be set to instrument.')
            amplitude = 0.002

        self.setInstParam(param='track', value='inverted')
        self.setOutputImp()
        self.setOutputImp(src=2)
        self.setInstParam(param='function', value=func)
        self.setInstParam(param='frequency', value=freq)
        self.setInstParam(param='voltage', value=amplitude)
        self.setInstParam(param='voltoffset', value=offset)
        self.setInstParam(param='phase', value=phase)
        # self.setOutputStat(1, 'on')
        # self.setOutputStat(2, 'on')

    def reset(self):
        #  just execute *RST command
        self.rmHandle.write('*RST')
        self.rmHandle.write('*CLS')
        pass

    def getIdn(self):
        return self.rmHandle.query('*IDN?')

    def close(self):
        # here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
    
    def arb_load(self, filename=r'"INT:\BUILTIN\EXP_RISE.arb"', src=1):
        """
        param:  filename should include the full path of the file
        """
        mmec_cmd = r'MMEM:LOAD:DATA ' + filename
        self.rmHandle.write(mmec_cmd)  # file already exists in instrument
        arb_cmd = r'SOUR1:FUNC:ARB '.replace('1', str(src)) + filename
        self.rmHandle.write(arb_cmd)


if __name__ == "__main__":
    import os
    import sys
    import time

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)

    from instmngr import instMgr

    sg = instMgr.checkout(interface='GPIB', addr='10', moduleSuffix='33622A')
    time.sleep(0.5)
    sg.reset()
    time.sleep(3)
    print(sg.getIdn())

    # # setup for differential output
    # sg.setDiffOutput()
    # sg.setOutputStat(1, 'on')
    # sg.setOutputStat(2, 'on')
    
    # Burst example
    sg.setInstParam(param='burststate', value='on', src=1)
    sg.setInstParam(param='burstncycle', value=1, src=1)
    sg.setInstParam(param='burstphase', value=0, src=1)
    sg.setInstParam(param='triggersource', value='external', src=1)
    sg.setInstParam(param='triggerslope', value='negative', src=1)
    sg.setInstParam(param='triggerdelay', value=1e-4, src=1)
    sg.setInstParam(param='triggerlevel', value=0.9, src=1)
    sg.setInstParam(param='function', value='arb', src=1)
    sg.setOutputImp(src=1, imp='inf')
    sg.setInstParam(param='arbfilter', value='step', src=1)
    sg.arb_load(filename=r'"INT:\User Files\BPWR_PEAK_ARB.arb"', src=1)
    sg.setInstParam(param='arbsrate', value=1e6, src=1)
    sg.setInstParam(param='volthigh', value=4.8, src=1)
    sg.setInstParam(param='voltlow', value=3.6, src=1)
    sg.setOutputStat(src=1, state='on')
    
    
    # sg.setSource()
    # sg.setOutputStat(state='on')

    # time.sleep(3)
    # sg.setOutputStat(state='off')

    # sg.close()
