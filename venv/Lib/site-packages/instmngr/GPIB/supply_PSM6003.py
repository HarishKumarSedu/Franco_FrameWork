# -*- coding: utf-8 -*-
"""
Created on Wed Sep  4 14:42:35 2019

@author: dkaroly
"""

import sys
import logging

idnString = 'PSM-6003'

class Supply_PSM6003:
    """Class for controlling Instec Power Supply Model PSM-6003."""

    def __init__(self, rmHandle):
        """ Constructor for Supply_PSM6003 class.

        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using
                       :meth:`pyvisa.highlevel.ResourceManager.open_resource`
        """

        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Supply_PSM6003')
        self.logger.info('Initializing Supply_PSM6003 instrument')
        self.__rangeList__ = ('P30V', 'P60V', 'LOW', 'HIGH')

    # ---------------------------------------------------------------------------
    # Added these two functions to work around fact that Pyro server is not allowing
    # access to property rmHandle, which is desired as work around to hack other features.

    def write_raw(self, cmdstr):
        """Send cmdstr argument directly to instrument."""
        self.rmHandle.write(cmdstr)

    def query_raw(self, cmdstr):
        """Perform query defined by cmdstr, return string. cmdstr must end with '?'."""

        if cmdstr[-1] != '?':
            raise ValueError(f"Bad query '{cmdstr}' missing '?'.")

        return self.rmHandle.query(cmdstr).strip()

    # ---------------------------------------------------------------------------

    def reset(self):
        """ Resets the Power Supply to its factory defaults. Output off."""

        self.rmHandle.write('*RST')

    # ---------------------------------------------------------------------------

    def value(self, voltage=None, ilimit=None):
        """ Queries or sets both the voltage output level and the current
            compliance limit for operation in Constant Voltage (CV) mode.

            Args:
                voltage (None or numeric) : Voltage to output in Volts.
                ilimit ( None or numeric) : Current limit to set in Amps.

            Return:
                If both voltage and ilimit are None, then the Power Supply is
                queried and the present voltage and current settings are
                returned as a list of two float values.

            NOTE:
                Voltage and ilimit may be both set together. Specifying a
                voltage value with ilimit=None retains the existing ilimit.
                Specifying voltage=None with a ilimit value retains the
                existing voltage level.

                This method is functionally equivalent to cv_mode and is retained
                for backwards compatibility.
        """

        ret_val = self.cv_mode(voltage, ilimit)
        return ret_val

    # ---------------------------------------------------------------------------

    def cv_mode(self, voltage=None, ilimit=None):
        """ Queries or sets both the voltage output level and the current
            compliance limit for operation in Constant Voltage (CV) mode.

            Note that there is no mode command on this instrument, CV mode
            is selected by the order in which this function writes its
            values into the instrument.

            Args:
                voltage (None or numeric) : Voltage to output in Volts.
                ilimit ( None or numeric) : Current limit to set in Amps.

            Return:
                If both voltage and ilimit are None, then the Power Supply is
                queried and the present voltage and current settings are
                returned as a list of two float values.

            NOTE:
                Voltage and ilimit may be both set together. Specifying a
                voltage value with ilimit=None retains the existing ilimit.
                Specifying voltage=None with a ilimit value retains the
                existing voltage level.

        """

        # Avoids causing instrument error if user supplies non numeric value.
        if voltage is not None and not isinstance(voltage, (int, float)):
            # noinspection PyTypeChecker
            self.logger.error(type(self).__name__ + ".value Error: Illegal voltage '" + voltage + "'.")
            return

        if ilimit is not None and not isinstance(ilimit, (int, float)):
            # noinspection PyTypeChecker
            self.logger.error(type(self).__name__ + ".value Error: Illegal ilimit '" + ilimit + "'.")
            return

        if voltage is None and ilimit is None:
            # Read and return voltage output setting and current limit setting.
            ret_list = []
            ret_val = self.rmHandle.query('VOLT?').rstrip()
            ret_list.append(float(ret_val))
            ret_val = self.rmHandle.query('CURR?').rstrip()
            ret_list.append(float(ret_val))
            return ret_list

        elif voltage is not None and ilimit is None:
            # Write voltage output setting
            self.rmHandle.write('VOLT ' + str(voltage))

        elif voltage is not None and ilimit is not None:
            # Write voltage output setting and current limit setting.
            # NOTE: The ordering of these following two commands defines CV mode.
            self.rmHandle.write('VOLT ' + str(voltage))
            self.rmHandle.write('CURR ' + str(ilimit))

        elif voltage is None and ilimit is not None:
            # Write the current limit setting.
            # NOTE: The ordering of these following two commands defines CV mode, therefore
            # We must to write the voltage and then the current limit.
            ret_val = self.rmHandle.query('VOLT?').rstrip()
            self.rmHandle.write('VOLT ' + ret_val)
            self.rmHandle.write('CURR ' + str(ilimit))

    # ---------------------------------------------------------------------------

    def cc_mode(self, current=None, vlimit=None):
        """ Queries or sets both the current output level and the voltage
            compliance limit for operation in Constant Current (CC) mode.
           
            Note that there is no mode command on this instrument, CC mode
            is selected by the order in which this function writes its
            values into the instrument.


            Args:
                current (None or numeric) : Current to output in Amps.
                vlimit ( None or numeric) : Voltage limit to set in Volts.

            Return:
                If both current and vlimit are None, then the Power Supply is
                querried and the present current and vlimit settings are
                returned as a list of two float values.

            NOTE:
                Current and vlimit may be both set together. Specifying a
                current value with vlimit=None retains the existing vlimit.
                Specifying current=None with a vlimit value retains the
                existing current level.


        """  # Avoids causing instrument error if user supplies non numeric value.
        if current is not None and not isinstance(current, (int, float)):
            # noinspection PyTypeChecker
            self.logger.error(type(self).__name__ + ".value Error: Illegal current '" + current + "'.")
            return

        if vlimit is not None and not isinstance(vlimit, (int, float)):
            # noinspection PyTypeChecker
            self.logger.error(type(self).__name__ + ".value Error: Illegal vlimit '" + vlimit + "'.")
            return

        if current is None and vlimit is None:
            ret_list = []
            retval = self.rmHandle.query('CURR?').rstrip()
            ret_list.append(float(retval))
            retval = self.rmHandle.query('VOLT?').rstrip()
            ret_list.append(float(retval))
            return ret_list

        elif current is not None and vlimit is None:
            self.rmHandle.write('CURR ' + str(current))

        elif current is not None and vlimit is not None:
            # Write current output setting and then the voltage limit setting.
            # NOTE: The ordering of these following two commands defines CC mode.
            self.rmHandle.write('CURR ' + str(current))
            self.rmHandle.write('VOLT ' + str(vlimit))

        elif current is None and vlimit is not None:
            # Write the voltage limit setting.
            # NOTE: The ordering of these following two commands defines CC mode, therefore
            # We must to write the current and then the voltage limit.
            retval = self.rmHandle.query('CURR?').rstrip()
            self.rmHandle.write('CURR ' + retval)
            self.rmHandle.write('VOLT ' + str(vlimit))

    # ---------------------------------------------------------------------------
    def output(self, on_off=None):
        """Wrapper around method state for compatibility.
        """

        return self.state(on_off)

    def state(self, state=None):
        """
        Queries or writes the state of the Power Supply output (all 3 together).

        Args:
            state (str):
                None   - Queries instrument, returns one of the following strings:
                'ON'   - Power Supply is connected to the load.
                'OFF'  - Power Supply is DISconnected to the load.

           Args are not case sensitive.
           Return values are always case shown above.
        """

        if state is None:
            rslt = self.rmHandle.query('OUTP:STAT?')
            if '1' in rslt:
                return 'ON'
            else:
                return 'OFF'
        else:
            states = ('ON', 'OFF')
            if state.upper() in states:
                self.rmHandle.write('OUTP:STAT ' + state.upper())
            else:
                self.logger.error(type(self).__name__ + ".state Error: Invalid state '" + state + "'.")

    # ---------------------------------------------------------------------------

    def meas(self, param):
        """
        Queries or writes actual measured value of the specified parameter on
        on the specified output.

        Args:
            param (str):
                'CURR' - measured Current (Amps)
                'POW'  - measured Power   (Watts)
                'VOLT' - measured Voltage (Volts)

           Args are not case sensitive.
           Return values are of type float.
        """

        if param.upper() in ('CURR', 'VOLT'):
            ret_val = self.rmHandle.query('MEAS:' + param.upper() + '? ')
            return float(ret_val.rstrip())
        else:
            self.logger.error(type(self).__name__ + " meas Error: invalid param '" + param + "'.")

    # ---------------------------------------------------------------------------

    # noinspection PyShadowingBuiltins
    def range(self, range=None):
        """
        Querry or set voltage range of power supply.

        Args:
            range (str) - One of None or 'P30V', 'P60V', 'LOW', 'HIGH'.
                          Not case sensitive.

            Return:
                Query form returns one of 'P30V', 'P60V'.

        """

        if range is None:
            result = self.rmHandle.query(':VOLT:RANG?')
            result = result.rstrip()
            if result == 'P08V':
                # PSM-2010 bug: to program send 'P8V', but readback gives P08V.
                # Make querry result consistent with write value.
                result = 'P8V'
            return result
        elif range is not None and range.upper() in self.__rangeList__:
            self.rmHandle.write(':VOLT:RANG ' + range.upper())
        else:
            self.logger.error(type(self).__name__ + ".range Error: Invalid range: '" + range + "'.")

    # ---------------------------------------------------------------------------

    def ocp_value(self, ilimit=None):
        """ Queries or sets the Over Current Protection level of the supply.
            OCP, if enabled, shuts down the supply when the current drawn from
            it exceeds the set value.

            Args:
                ilimit: None or float representing current in Amps.
            Return:
                Query returns the present OCP setpoint in Amps.
        """

        if ilimit is None:
            rslt = self.rmHandle.query('CURR:PROT?')
            return float(rslt.rstrip())
        elif isinstance(ilimit, (int, float)):
            self.rmHandle.write('CURR:PROT ' + str(ilimit))
        else:
            self.logger.error(type(self).__name__ + ".ocp_val Error: Invalid ilimit: '" + ilimit + "'.")

    # ---------------------------------------------------------------------------

    def ocp_state(self, state=None):
        """ Queries or sets the ON/OFF state of Over Current Protection.
            OCP, if enabled, shuts down the supply when the current drawn from
            it exceeds the set value.

            Args:
                state: One of "ON' or 'OFF'. Not case sensitive.
            Return:
                Query returns one of 'ON' or 'OFF'.
        """
        states = ('ON', 'OFF')

        if state is None:
            rslt = self.rmHandle.query('CURR:PROT:STAT?')
            if '1' in rslt:
                return 'ON'
            else:
                return 'OFF'
        elif state.upper() in states:
            self.rmHandle.write('CURR:PROT:STAT ' + state.upper())
        else:
            self.logger.error(type(self).__name__ + ".ocp_state Error: Invalid state: '" + state + "'.")

    # ---------------------------------------------------------------------------

    def ocp_tripped(self):
        """ Queries if Over Current Protection has tripped.
            OCP, if enabled, shuts down the supply when the current drawn from
            it exceeds the set value.

            Return:
                Query returns True if trip has occured..
        """

        rslt = self.rmHandle.query('CURR:PROT:TRIP?')
        if '1' in rslt:
            return True
        else:
            return False

    # ---------------------------------------------------------------------------

    def ocp_clear(self):
        """ Writes command to clear Over Current Protection trip.
            OCP, if enabled, shuts down the supply when the current drawn from
            it exceeds the set value. Note that after clearing the trip state,
            the output will remain off until reactivated using the state method.

        """
        self.rmHandle.write('CURR:PROT:CLE')

    # ---------------------------------------------------------------------------

    def ovp_value(self, vlimit=None):
        """ Queries or sets the Over Voltage Protection level of the supply.
            OVP, if enabled, shuts down the supply when the voltage at the
            terminals exceeds the set value.

            Args:
                vlimit: None or float representing voltage in Volts.
            Return:
                Query returns the present OVP setpoint in Volts.
        """

        if vlimit is None:
            rslt = self.rmHandle.query('VOLT:PROT?')
            return float(rslt.rstrip())
        elif isinstance(vlimit, (int, float)):
            self.rmHandle.write('VOLT:PROT ' + str(vlimit))
        else:
            self.logger.error(type(self).__name__ + ".ocp_val Error: Invalid vlimit: '" + vlimit + "'.")

    # ---------------------------------------------------------------------------

    def ovp_state(self, state=None):
        """ Queries or sets the ON/OFF state of Over Voltage Protection.
            OVP, if enabled, shuts down the supply when the voltage at the
            terminals exceeds the set value.

            Args:
                state: One of "ON' or 'OFF'. Not case sensitive.
            Return:
                Query returns one of 'ON' or 'OFF'.
        """

        states = ('ON', 'OFF')

        if state is None:
            rslt = self.rmHandle.query('VOLT:PROT:STAT?')
            if '1' in rslt:
                return 'ON'
            else:
                return 'OFF'
        elif state.upper() in states:
            self.rmHandle.write('VOLT:PROT:STAT ' + state.upper())
        else:
            self.logger.error(type(self).__name__ + ".OVPstate Error: Invalid OVPstate: '" + state + "'.")

    # ---------------------------------------------------------------------------

    def ovp_tripped(self):
        """ Queries if Over Voltage Protection has tripped.
            OVP, if enabled, shuts down the supply when the voltage at the
            terminals exceeds the set value.

            Return:
                Query returns True if trip has occured..
        """

        rslt = self.rmHandle.query('VOLT:PROT:TRIP?')
        if '1' in rslt:
            return True
        else:
            return False

    # ---------------------------------------------------------------------------

    def ovp_clear(self):
        """ Writes command to clear Over Voltage Protection trip.
            OVP, if enabled, shuts down the supply when the voltage at the
            terminals exceeds the set value. Note that after clearing the trip state,
            the output will remain off until reactivated using the state method.

        """

        self.rmHandle.write('VOLT:PROT:CLE')

    # ---------------------------------------------------------------------------

    def getIdn(self):
        return self.rmHandle.query('*IDN?')

    # ---------------------------------------------------------------------------

    def getError(self):
        rslt = self.rmHandle.query('SYST:ERRor?')
        return rslt.rstrip()

    # ---------------------------------------------------------------------------

    def close(self):
        # here, might need to communicate with instrument manager to retire the
        # instance listed there
        self.rmHandle.close()


# ===============================================================================

if __name__ == "__main__":
    import os
    import time

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    import InstMgr

    instMgr = InstMgr.InstMgr()
    ps = instMgr.checkout(objName='supply', interface='GPIB', addr=9, moduleSuffix='PSM6003')
    ps.reset()
    print(ps.getIdn())
    ps.value(voltage=4.0, ilimit=1.0)
    outval = ps.value()
    print(outval)
    ps.state('ON')
    print(ps.state())
#    time.sleep(1)

#    ps.close()
