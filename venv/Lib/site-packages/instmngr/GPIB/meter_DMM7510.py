# -*- coding: utf-8 -*-
"""
Created on 10 Aug 2018 

@author: dzhang

Function list
    __init__(self,rmHandle)
    reset(self)
    setMeas(self,measType='DCV')
    setTrigParam(self,param='source',val='immediate')
    setMeasParam(self,measType='DCV',param='range',val=1e-2)
    getMeas(self)
    setTraceMeas(self, meastype='DCI', limit=1e-2, srate = 1e3, numsamples = 1e4, aperture=1e-2)
    getTraceMeas(self,meastype='DCI', limit=1e-2, srate = 1e3, numsamples = 1e4, aperture=1e-2)
    getIdn(self)
    close(self)
"""

import sys
import time
import logging

idnString = 'MODEL DMM7510'

# =============================================================================
# This instrument might be categorised as a seperate group from meter due to its capability
# =============================================================================

class Meter_DMM7510():

    #TODO: need to add digitizing sampling functions back into dictionary 
    #      sampling mode will be decided based on sampling rate 
    #      ie if sampling rate>=1k digitizing, else normaly sampling rate
    instDict = {'DCV': {'range':[1e-3,None,':SENS:VOLT:DC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},':SENS:VOLT:DC:RANG:AUTO'],
                        #resolution':[1e-6,None,'VOLT:DC:RES'],
                        'numPLCycles':[1,(0.0005,12),':SENSE:VOLT:DC:NPLC'],
                        #'analogFilt':['OFF',{'on':'ON','off':'OFF'},'VOLT:DC:FILT'],
                        'digitalAveFilt':['OFF',{'on':'ON','off':'OFF'},':SENS:VOLT:DC:AVER'],
                        'digitizefunc':['"VOLT"', {'V':'"VOLT"', 'I':'"CURR"'}, ':SENS:DIG:FUNC'],
                        'samplerate':[1e3,(1e3, 1e6),':SENS:VOLT:SRATE'], # this is for digitize sampling only
                        'aperture':[1e-3,(1e-5, 0.24),':SENS:VOLT:APER'], # this code is not for Digitize,
                        # for Digitize use Auto
                        'inputimpauto': ['MOHM10', {'off':'MOHM10', 'on':'AUTO'}, ':VOLT:INP'],
                        },
    
                'ACV': {'range':[1e-3,None,':SENS:VOLT:AC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},':SENS:VOLT:AC:RANG:AUTO'],
                        'digitizefunc':['"VOLT"', {'V':'"VOLT"', 'I':'"CURR"'}, ':SENS:DIG:FUNC'],
                        'numPLCycles':[1,(0.0005,12),':SENSE:VOLT:AC:NPLC'],
                        'samplerate':[1e3,(1e3, 1e6),':SENS:VOLT:AC:SRATE'],
                        'aperture':[1e-3,(1e-5, 0.24),':SENS:VOLT:AC:APER']},
                'DCI': {'range':[1e-3,None,':SENS:CURR:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},':SENS:CURR:DC:RANG:AUTO'],
                        'digitizefunc':['"VOLT"', {'V':'"VOLT"', 'I':'"CURR"'}, ':DIG:FUNC'],
                        'numPLCycles':[1,(0.0005,12),':SENSE:CURR:DC:NPLC'],
                        'samplerate':[1e3,(1e3, 1e6),':SENS:CURR:SRATE'],
                        'aperture':[1e-3,(1e-5, 0.24),':SENS:CURR:APER']},
                'ACI': {'range':[1e-3,None,':SENS:CURR:AC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},':SENS:CURR:AC:RANG:AUTO'],
                        'digitizefunc':['"VOLT"', {'V':'"VOLT"', 'I':'"CURR"'}, ':DIG:FUNC'],
                        'numPLCycles':[1,(0.0005,12),':SENSE:CURR:AC:NPLC'],
                        'samplerate':[1e3,(1e3, 1e6),':SENS:CURR:AC:SRATE'],
                        'aperture':[1e-3,(1e-5, 0.24),':SENS:CURR:AC:APER']},
                'RES': {'range':[1e-3,None,':SENS:RES:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},':SENS:RES:RANG:AUTO']},
                #'FREQ': {'range':[1e-3,None,'FREQ:VOLT:RANG'],
                #         'autorange':['ON',{'on':'ON','off':'OFF'},'FREQ:VOLT:AUTO']},
                'measType': ['"VOLT:DC"',{'DCV':'"VOLT:DC"','ACV':'"VOLT:AC"','DCI':'"CURR:DC"','ACI':'"CURR:AC"','RES':'"RES"','FREQ':'"FREQ"'},':SENS:FUNC'],
                'trigger': {'init':[':IMM',{'immediate':':IMM'},':INIT'],
                            #'source':['IMM',{'bus':'BUS','immediate':'IMM','external':'EXT'},'TRIG:SOUR'],
                            'delaySec':[0,(8e-6,1e5),':TRIG:TIM1:DEL'],
                            #'autodelay':['OFF',{'on':'ON','off':'OFF'},'TRIG:DEL:AUTO'],
                            'samplesPerTrigger':[1,(1,1e6),':SENS:COUN'],    #this function is not for Digitize
                            'tracePoints':[1,(1,10e5),':TRAC:POIN'],
                            
                            }
    }


    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Meter_DMM7510')
        self.logger.info('Initializing Meter_DMM7510 instrument')
    
    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('*RST')     
        self.rmHandle.write('*CLS')
        pass
    
    def setMeas(self,measType='DCV'):
        if measType in self.instDict['measType'][1].keys():
            self.instDict['measType'][0] = self.instDict['measType'][1][measType]
            self.rmHandle.write(self.instDict['measType'][2] + ' ' + self.instDict['measType'][0])
        else:
            self.logger.warning('WARNING - requested measurement type not known to instrument class')
            
    def setTrigParam(self,param='source',val='immediate'):
        self.setMeasParam(measType='trigger',param=param,val=val)
    
    def setMeasParam(self,measType='DCV',param='range',val=1e-2):
        inputValid = 0
        if param in self.instDict[measType].keys():
            if isinstance(self.instDict[measType][param][0],str):
                if val in self.instDict[measType][param][1].keys():
                    self.instDict[measType][param][0] = self.instDict[measType][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict[measType][param][1].keys()))
            else:
                if (self.instDict[measType][param][1] is None ) or ((self.instDict[measType][param][1] is not None) and (val >= self.instDict[measType][param][1][0] ) and (val <= self.instDict[measType][param][1][1] ) ):
                    self.instDict[measType][param][0] = val
                    inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
        
        if inputValid == 1:
            dsend = self.instDict[measType][param][2] + ' ' + str(self.instDict[measType][param][0])
            self.logger.debug(dsend)
            self.rmHandle.write(dsend)
            
    def getMeas(self):
        retval = self.rmHandle.query('read?')
        return float(retval)
    
    def setTraceMeas(self, meastype='DCI', limit=1e-2, srate = 1e3, numsamples = 1e4, aperture=1e-2):
        if srate >=1000:
            # use digitize function
            #self.setMeasParam(meastype, 'digitizefunc', meastype[2])
            #self.rmHandle.write(':SENS:DIG:VOLT:APER AUTO')
            #self.setMeasParam(meastype, 'samplerate', srate)
            pass
        else:
            # use measure function
            self.setMeasParam(meastype, 'range', limit)
            self.setMeasParam(meastype, 'aperture', aperture)
        self.setMeasParam('trigger','samplesPerTrigger', numsamples)
        #self.setMeasParam('trigger', 'tracePoints', numsamples*12)
    
    def getTraceMeas(self,meastype='DCI', limit=1e-2, srate = 1e3, numsamples = 1e4, aperture=1e-3):
        # TODO: reduce input paramters, no need for all of them
        # TODO: need to find a way to pass buffer name if customized buffer name is enabled
        self.rmHandle.write(':TRAC:CLE')
        self.rmHandle.write(':TRAC:TRIG')
        self.logger.debug("Measurement triggered")
        acq_time = int(numsamples*1.1/srate) + 30
        for i in range(acq_time):
            time.sleep(1)
            self.logger.debug("Remaining acquisition time is %d secocnds"%(acq_time - i))
        #time.sleep(int(numsamples*aperture) + 60)
        # TODO: add ability to eanble other information in output data, ie time stamp
        try:
            meas_data = self.rmHandle.query(":TRAC:DATA? 1, %d, 'defbuffer1', READ, REL"%(numsamples))
        except:
            self.logger.debug('Data is not ready yet')
            meas_data = None
        return meas_data

    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
    
    
    
if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    from instmngr import instMgr
    mi = instMgr.checkout(interface='GPIB',addr=22,moduleSuffix='DMM7510')
    # mi.reset()
    print(mi.getIdn())

    # mi.setMeas('DCV')
    # mi.setTraceMeas('DCV', 20, 10, 100, 1e-3)
    # time.sleep(3)
    # data = mi.getTraceMeas('DCV', 20, 10, 100, 1e-2)
    # print(data.split(','))
    