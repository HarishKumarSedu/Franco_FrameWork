# -*- coding: utf-8 -*-
"""
Created on Fri July 7 16:20:13 2020

@author: Nilesh More
"""
from meter_DMM2000 import Meter_DMM2000
import sys
import logging

idnString = '8104'

class Meter_DMM8104(Meter_DMM2000):
    # index 0 in options tuple could be assumed to be the default
    # here, innermost dict is command mmenmoic:{current value,(possible values),SCPI base command,flag that value needs updated to instrument}

    instDict = {'DCV': {'range': [0.1, (0.1, 1000), 'RANGE:DC:VOLTAGE ']},
                'ACV': {'range': [0.1, (0.1, 1000), 'RANGE:AC:VOLTAGE ']},
                'DCI': {'range': [1e-8, (1e-8, 30), 'RANGE:DC:CURRENT ']},
                'ACI': {'range': [1e-4, (1e-4, 30), 'RANGE:AC:CURRENT ']},
                '2WIRE_RES': {'range': [10, (10, 1e9), 'RANGE:RESISTANCE ']},
                '2WIRE_RES_LOWI': {'range': [100, (100, 1e4), 'RANGE:RESISTANCE:LOWI ']},
                '4WIRE_RES': {'range': [1, (1, 1e5), 'RANGE:FRESISTANCE ']},
                '4WIRE_RES_LOWI': {'range': [100, (100, 1e4), 'RANGE:FRESISTANCE:LOWI ']},
                'RESOLUTION': {'digits': [7, (4, 8), 'D']},
                # The possible values are digits = 4, 5, 6, 7, 8
                'FILTER_RANGE': {'range': [2, (0, 9), 'F']},
                # The possible values are range = 0(125ms), 1(250ms), 2(500ms), 3(1s), 4(2s), 5(4s), 6(8s), 7(16s), 8(32s), 9(64s)
                'DYNAMIC_FILTER': {'filter': ['1', {'on': '1', 'off': '0'}, 'FD']},
                'measType': ['DC:VOLTAGE',{'DCV': 'DC:VOLTAGE', 'ACV': 'AC:VOLTAGE','DCI': 'DC:CURRENT', 'ACI': 'AC:CURRENT',
                                           '2WIRE_RES': 'RESISTANCE', '2WIRE_RES_LOWI': 'LOWI:RESISTANCE', '4WIRE_RES': 'FRESISTANCE', '4WIRE_RES_LOWI': 'LOWI:FRESISTANCE',}, 'FUNC:'],
                }

    # Todo: Include autorange, trigger, thermocouple, freq, shunt, Electrometer and probe linearization functionality. The SCPI commands for these functionalities are not available from Trasnmille as of now

    def __init__(self, rmHandle):
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Meter_DMM8104')
        self.logger.info('Initializing Meter_DMM8104 instrument')

    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('*RST')
        pass

    def setMeas(self, measType='DCV'):
        if measType in self.instDict['measType'][1].keys():
            self.instDict['measType'][0] = self.instDict['measType'][1][measType]
            self.rmHandle.write(self.instDict['measType'][2] + self.instDict['measType'][0])
        else:
            self.logger.warning('WARNING - requested measurement type not known to instrument class')

    def setTrigParam(self, param='source', val='immediate'):
        self.setMeasParam(measType='trigger', param=param, val=val)

    def setMeasParam(self, measType='DCV', param='range', val=0.1):
        inputValid = 0
        if param in self.instDict[measType].keys():
            if isinstance(self.instDict[measType][param][0], str):
                if val in self.instDict[measType][param][1].keys():
                    self.instDict[measType][param][0] = self.instDict[measType][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning(
                        'error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(
                            self.instDict[measType][param][1].keys()))
            #                    print('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict[measType][param][1].keys()))
            else:
                if (self.instDict[measType][param][1] is None) or ((self.instDict[measType][param][1] is not None) and (
                        val >= self.instDict[measType][param][1][0]) and (val <= self.instDict[measType][param][1][1])):
                    self.instDict[measType][param][0] = val
                    inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
        #            print('error- requested parameter not known to instrument class')

        if inputValid == 1:
            cmdstr = self.instDict[measType][param][2] + str(self.instDict[measType][param][0])
            print( "cmdstr = '%s'" % cmdstr )
            self.rmHandle.write(cmdstr)

    def getMeas(self):  # Initiate measurement and get results.
        retval = self.rmHandle.query('READ?')
        return float(retval)

    def getIdn(self):
        return self.rmHandle.query('*IDN?').strip()

    def setNull(self):
        # set Null
        self.rmHandle.write('n')
        pass

    def clearNull(self):
        # clear Null
        self.rmHandle.write('N')
        pass

    def setTerminals(self, terminals = 'front'):
        # set the Instrument terminals to be front or rear
        if terminals.casefold() == 'front':
            self.rmHandle.write('f')
        elif terminals.casefold() == 'rear':
            self.rmHandle.write('r')
        else:
            self.logger.warning('error - requested discrete value not known to instrument class.  Valid options are front or rear')

    def close(self):
        # here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass


if __name__ == "__main__":
    import os, sys

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)

    import instmngr

    instMgr = instmngr.InstMgr()
    mi = instMgr.checkout(interface='GPIB', addr=22, moduleSuffix='DMM8104')

    print("*IDN = '%s" % mi.getIdn())
    print(mi.getMeas())

    #mi.reset()
    #mi.setTerminals('front')
    #mi.setMeasParam(measType='DCV', param='range', val=10)
    #mi.setMeas(measType='DCV')
    #mi.setMeasParam(measType='4WIRE_RES', param='range', val=100000)
    #mi.setMeasParam(measType='DYNAMIC_FILTER', param='filter', val='off')
    #mi.setMeasParam(measType='RESOLUTION', param='digits', val=8)
    #mi.setMeasParam(measType='FILTER_RANGE', param='range', val=8)
    #mi.clearNull()
    #mi.setTerminals('rear')
    mi.close()
    pass