# -*- coding: utf-8 -*-
"""
Created on Thu Nov  8 14:28:56 2018

@author: testeng
"""

import sys
from time import sleep
import logging

idnString = 'T-2500E'  

class Temp_Thermostream2500E():
    
    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.soakTimeSec = 120
        self.soakTimeElapsed = 0
        self.currentTempC = None
        self.currentStatus = None
        self.setTempC = None
        self.numDec = 0  #number of decimal places required for commands
        self.stateList = ['IDLE','TRANSITION','SOAK','AT_TEMP']
        self.state = 'IDLE'
        self.logger = logging.getLogger('marv.inst.Temp_Thermostream2500E')
        self.logger.info('Initializing Temp_Thermostream2500E instrument')
        
    
    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        # reset will program best operating conditions, t-type thermocouple, dut control, and go to cycle screen.  this minimizes setup
        self.rmHandle.write('*RST')
        self._setTempSensing()
#        self.rmHandle.write('setn 5') # choose setpoint number 5 for all settings
#        self.rmHandle.write('TESE 255') #unmask temp cycle bits
        pass
    
    def setSoakTimeSec(self,soaktime=120):
        self.soakTimeSec = soaktime
        self.rmHandle.write('SOAK1 ' + str(soaktime))
        
    def getCurrentTemp(self):
        # this is the DUT temp
        self.currentTempC = float(self.rmHandle.query('DUTTEMP?').split(' ')[0])
        return self.currentTempC
        
    def getCurrentTempStatus(self):
        # this is the current status:   bit0 future use, bit1 is Soak Time Start, bit2 is Soak Time End
        #                               bit3 EOT/Class received, bit4-7 future use  
        self.rmHandle.write('TESR?')
        self.currentStatus = int(self.rmHandle.read().strip())
        return self.currentStatus


            
    def setTemp(self,setTempC=25.0):
        # state = 1 head is up 
        # state = 0 head is down
        headState = int(self.rmHandle.query('head?').strip())
        if headState == 1: #head is up
            cmdResult = self.rmHandle.write('head 0') #put head down   
        self.setTempC = setTempC
        cmdStr = 'TEMP1 ' + str(int(setTempC * (10 ** self.numDec)))
        cmdResult = self.rmHandle.write(cmdStr)
        self.logger.debug(self.rmHandle.query('TEMP1?'))
        self.rmHandle.write('GOTEMP1')
        #sleep(3)
#        for i in range(10):
#            self.getCurrentTemp()
#            self.getCurrentTempStatus()
#            print( 'in eval: temp ' + str(self.currentTempC) + ' status ' + str(self.currentStatus) )
#            sleep(5)

        #self.evalTempState()
        #later, add error checking here & return success or error code
        
    def evalTempState(self,marginC=0.5):
        self.getCurrentTemp()
        # TODO: getCurrentTempStatus funciton is disabled as the Status reg only returns the status for once and further reading remains 0 until status changed
        self.getCurrentTempStatus()
        tempDelta = abs(self.currentTempC - self.setTempC)
        if self.state == 'IDLE':
            if tempDelta > marginC:
#            if self.currentStatus == 0:
                self.state = 'TRANSITION'
                self.logger.info('Temp Transition Begin from idle')
        elif self.state == 'TRANSITION':
            if tempDelta < marginC:
#            if self.currentStatus == 2:
                self.state = 'SOAK'
                self.logger.info('Temp  Soak Begin')
        elif self.state == 'SOAK':
            if self.soakTimeElapsed == self.soakTimeSec:
                if self.currentStatus > 2:
                    self.state = 'AT_TEMP'
                    self.soakTimeElapsed = 0
                    self.logger.info('Temp  Soak End')
        elif self.state == 'AT_TEMP':
            if tempDelta > marginC:
#            if self.currentStatus == 0:
                self.state = 'TRANSITION'
                self.logger.info('Temp Transition Begin')
            
            
        
    def waitTempTransition(self,marginC=0.5):
        timerTick = 1 #second
        while self.state != 'AT_TEMP':
            while self.state == 'TRANSITION':
                self.logger.info('Temp transition: set ' + str(self.setTempC) + ' current ' + str(self.currentTempC))
                sleep(1)            
                self.evalTempState(marginC=marginC)
            while self.state == 'SOAK':
                sleep(timerTick)
                self.soakTimeElapsed = self.soakTimeElapsed + timerTick
                self.evalTempState(marginC=marginC)
                self.logger.debug('Soaking...')
        self.logger.info( 'At Temperature: set ' + str(self.setTempC) + ' current ' + str(self.currentTempC))
                
            
    def _setTempSensing(self, TStype=1):
        # TStype: 0 - AIR, 1 - K, 2 - T, 3 - RTD
        self.rmHandle.write('TCONTROL '+str(TStype))
        if TStype != 0:
            self.rmHandle.write('TDISPLAY '+str(TStype))
        return         
        
    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
    
    
    
if __name__ == "__main__":
    import os,sys
    import time
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    mi = instMgr.checkout(interface='GPIB',addr=19,moduleSuffix='T-2500E')
    mi.reset()
    print(mi.getIdn())
    
    print(str(mi.getCurrentTemp()))
    mi.setSoakTimeSec(3)
    mi.setTemp(-20)
#    time.sleep(10)
#    mi.rmHandle.write('AIROFF')
#    mi.setTemp(70)
#    mi.waitTempTransition(marginC=3)
    time.sleep(900)
    mi.rmHandle.write('AIROFF')
    st_time = time.time()
    for i in range(120):
        print(str(time.time()-st_time))
        print(mi.getCurrentTemp())
        time.sleep(5)

    pass    