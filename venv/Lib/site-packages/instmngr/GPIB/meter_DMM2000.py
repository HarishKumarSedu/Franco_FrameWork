# -*- coding: utf-8 -*-
"""
Created on Mon Nov 28 11:23:13 2016

@author: jmunger
"""

import sys
import logging

idnString = 'MODEL 2000'

# Meter class settings
#     - look at what it would take to initialize dict from queries after reset?  is this a lengthy process?
#  -Start with measurement configure for each measurement type
#  -Then set current measurement
#  -then take measurement.


#also need maybe a separate dict for math / average, and another for trigger

#also (for all instruments) need to route reads/writes through a proc so that error checking can be added easily later

class Meter_DMM2000():
    #index 0 in options tuple could be assumed to be the default
    #here, innermost dict is command mmenmoic:{current value,(possible values),SCPI base command,flag that value needs updated to instrument}
    
    #how to deal with contiuous or discrete?  check value using isinstance.  if not a string, has to be continuous value.
    instDict = {'DCV': {'range':[0,(0, 1010),'VOLT:DC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'VOLT:DC:RANG:AUTO'],
                        'digits':['DEF',{'4': '4', '5': '5', '6': 6, '7': '7', 'DEF': 'DEF', 'MIN': 'MIN', 'MAX': 'MAX'},'VOLT:DC:DIG'],
                        'numPLCycles':[1,(0.01,10),'VOLT:DC:NPLC'],
                        'digitalAveFilt':['OFF',{'on':'ON','off':'OFF'},'VOLT:DC:AVER:STAT'],
                        'digitalAveFiltType':['REP',{'rep':'REP','mov':'MOV'},'VOLT:DC:AVER:TCON'],
                        'digitalAveFiltCount':[10,(1, 100),'VOLT:DC:AVER:COUN']},
                'ACV': {'range':[0,(0, 757.5),'VOLT:AC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'VOLT:AC:RANG:AUTO'],
                        'numPLCycles':[1,(0.01,10),'VOLT:AC:NPLC'],                                 
                        'bandwidth':[3,(3, 300e3),'VOLT:AC:DET:BAND']},
                'DCI': {'range':[0,(0,3.1),'CURR:DC:RANG'],
                        'numPLCycles':[1,(0.01,10),'CURR:DC:NPLC'],                                 
                        'autorange':['ON',{'on':'ON','off':'OFF'},'CURR:DC:RANG:AUTO']},
                'ACI': {'range':[0,(0,3.1),'CURR:AC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'CURR:AC:RANG:AUTO'],
                        'numPLCycles':[1,(0.01,10),'CURR:AC:NPLC'],                                 
                        'bandwidth':[3,(3, 300e3),'CURR:AC:DET:BAND']},
                'RES': {'range':[0,(0,120e6),'RES:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'RES:RANG:AUTO']},
                'FREQ': {'apperature':[1,(0.01,1),'FREQ:APER']},
                'measType': ['"VOLT:DC"',{'DCV':'"VOLT:DC"','ACV':'"VOLT:AC"','DCI':'"CURR:DC"','ACI':'"CURR:AC"','RES':'"RES"','FREQ':'"FREQ"'},'FUNC '],
                'trigger': { 'source':['IMM',{'bus':'BUS','immediate':'IMM','external':'EXT', 'timer': 'TIM', 'manual': 'MAN'},'TRIG:SOUR'],
                            'delaySec':[0,(0,999999),'TRIG:DEL'],
                            'samplesPerTrigger':[1,(1,1024),'SAMP:COUN'],
                            'triggerCount':[1,(1,9999),'TRIG:COUN'],
                            }
    }

    def __init__(self,rmHandle):
        self.rmHandle = rmHandle

    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('*RST')        
        pass
    
    def setMeas(self,measType='DCV'):
        if measType in self.instDict['measType'][1].keys():
            self.instDict['measType'][0] = self.instDict['measType'][1][measType]
            self.rmHandle.write(self.instDict['measType'][2] + self.instDict['measType'][0])
        else:
            self.logger.warning( 'WARNING - requested measurement type not known to instrument class')
            
    def setTrigParam(self,param='source',val='immediate'):
        self.setMeasParam(measType='trigger',param=param,val=val)
    
    def setMeasParam(self,measType='DCV',param='range',val=1e-3):
        inputValid = 0
        if param in self.instDict[measType].keys():
            if isinstance(self.instDict[measType][param][0],str):
                if val in self.instDict[measType][param][1].keys():
                    self.instDict[measType][param][0] = self.instDict[measType][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict[measType][param][1].keys()))
#                    print('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict[measType][param][1].keys()))
            else:
                if (self.instDict[measType][param][1] is None ) or ((self.instDict[measType][param][1] is not None) and (val >= self.instDict[measType][param][1][0] ) and (val <= self.instDict[measType][param][1][1] ) ):
                    self.instDict[measType][param][0] = val
                    inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
#            print('error- requested parameter not known to instrument class')
        
        if inputValid == 1:
            cmdstr = self.instDict[measType][param][2] + ' ' + str(self.instDict[measType][param][0])
#            print( "cmdstr = '%s'" % cmdstr )
            self.rmHandle.write( cmdstr )
            
    def getMeas(self):                          # Initiate measurement and get results. Will get error -213 if DMM is free running
        retval = self.rmHandle.query('read?')
        return float(retval)

    def getCurrentRdg(self):                    # Read whatever is currently on the display
        retval = self.rmHandle.query('fetch?')
        return float(retval.split('VDC')[0])

    def getIdn(self):
        return self.rmHandle.query('*IDN?').strip()
        
    def getOpt(self):
        return self.rmHandle.query('*OPT?').strip()

    def setInitiateContinuous(self, init_state):
        if not(init_state in ('ON', 'OFF')):
            raise ValueError(f"Bad init_state '{init_state}', should be 'ON' or 'OFF'.")

        self.rmHandle.write(f'INIT:CONT {init_state}')
        
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
    
    
    
if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    mi = instMgr.checkout( interface='GPIB', addr=17, moduleSuffix='DMM2000')
    
    print( "*IDN = '%s" % mi.getIdn() )
    print(mi.getMeas())
    
#    mi.close()
    pass    