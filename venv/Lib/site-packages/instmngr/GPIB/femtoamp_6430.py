# -*- coding: utf-8 -*-
"""
Created on Tue March 12 13:42:00 2019

@author: dzhang

Version: 0.1
History:    
    0.1 - initial

Function list:
    __init__(rmHandle)
    reset()
    setSrcParam(param='ch1autorangev',val='on')
    setOutputState(src=1,val='off')
    setMeasParam(param='ch1autorangev',val='on')
    getSrcInComplianceLimit(src=1)
    getMeas(src=1,val='voltage')
    getIdn()
    timestampReset()
    close()

    configVSrc(src=1, vlevel=1.8, ilimit=0.1)
    configIMeas(src=1, spd=1, filtercount=10)
    
"""
# TODO - 13 Mar 19
# 0. check getMeas() output string format for multiple measurement
# 1. consider adding status data reading function to check instruemnt status - detail in manual page 357
# 2. expand READ function to have multiple readings in buffer and then export 
# 3. external trigger for Vbias measurement
# 4. is there a function to check if Preamp is connected or not?

import time
import logging 

idnString = '6430'

#inst_Logger = logging.getLogger('marv')

class Femtoamp_6430():

    instDict = {
                'source': {
                          'ch1function': ['VOLT', {'V':'VOLT', 'I':'CURR', 'M':'MEM'}, ':SOUR:FUNC:MODE '],
                          'vmode': ['FIX', {'fixed':'FIX', 'list':'LIST', 'sweep':'SWE'}, ':SOUR:VOLT:MODE '],
                          'imode': ['FIX', {'fixed':'FIX', 'list':'LIST', 'sweep':'SWE'}, ':SOUR:CURR:MODE '],
                          'ch1voltRange': [0.2, (0.2, 20), ':SOUR:VOLT:RANG '], # actual max voltage output is 200V. 20V is sufficient for current usage
                          'ch1currRange': [1.05e-12, (1.05e-12, 0.1), ':SOUR:CURR:RANG '],
                          'ch1autorangev': ['ON', {'on':'ON', 'off':'OFF'}, ':SOUR:VOLT:RANG:AUTO '],
                          'ch1autorangei': ['ON', {'on':'ON', 'off':'OFF'}, ':SOUR:CURR:RANG:AUTO '],
                          'ch1voltLevel': [0, (-210, 210), 'SOUR:VOLT:IMM:AMPL '],
                          'ch1currLevel': [0, (-1.05, 1.05), 'SOUR:CURR:IMM:AMPL '],
                          
                          'vprotect': [20, (-210, 210), 'SOUR:VOLT:PROT '],
                          'ch1voltLimit': [0, (-210, 210), 'SENS:VOLT:DC:PROT:LEV '],
                          'ch1currLimit': [0, (-1.05, 1.05), 'SENS:CURR:DC:PROT:LEV '],
#                          'delay': [0.003, (0.003, 999.999), ':SOUR:DEL '],   # this cmd doesn't work, I'll solve it later
                          
                          'ch1output': ['OFF', {'on':'ON', 'off':'OFF'}, ':OUTP:STAT '],
                          
                },
                'measure': {
                          'concurrent': ['ON', {'on':'ON', 'off':'OFF'}, ':SENS:FUNC:CONC '],  
                          'function': ['"VOLT"', {'current':'"CURR"', 'voltage':'"VOLT"', 'resistance':'"RES"'}, ':SENS:FUNC:ON '],
                          'allmeas': [':OFF:ALL', {'on':':ON:ALL', 'off':':OFF:ALL'}, ':SENS:FUNC'],
                          'ch1autorangev':['ON',{'on':'ON', 'off':'OFF'},':SENS:VOLT:RANG:AUTO '],
                          'ch1autorangei': ['ON',{'on':'ON', 'off':'OFF'},':SENS:CURR:RANG:AUTO '],
                          'ch1rangev':[20,(-210, 210),':SENS:VOLT:RANG '],
                          'ch1rangei':[105e-3,(-105e-3,105e-3),':SENS:CURR:RANG '],
                          'vlowlimit': [21,(-21, 21),':SENS:VOLT:RANG:AUTO:LLIM '],
                          'ilowlimit': [-105e-3,(-105e-3, 105e-3),':SENS:CURR:RANG:AUTO:LLIM '],
                          'vhighlimit': [21,(-21, 21),':SENS:VOLT:RANG:AUTO:ULIM '],
                          'ihighlimit': [-105e-3,(-105e-3, 105e-3),':SENS:CURR:RANG:AUTO:ULIM '],
                          'ch1measspeedv': [10, (0.01, 10), ':SENS:VOLT:NPLC '],
                          'ch1measspeedi': [10, (0.01, 10), ':SENS:CURR:NPLC '],
                          'ch1filtercount': [10, (1, 100), ':SENS:AVER:COUN '],
                          'ch1filtertype': ['REP', {'repeat':'REP', 'moving':'MOV'}, ':SENS:AVER:TCON '],
                          'ch1single': [':CURR?', {'current':':CURR?', 'voltage':':VOLT?', 'resistance':':RES?', 'all':'?'}, ':MEAS'],
                          'format': ['VOLT', {'voltage':'VOLT', 'current':'CURR', 'resistance':'RES', 'all':'VOLT,CURR,RES,TIME,STAT'}, ':FORM:ELEM '], 
                          # add TRACE and TRIGGER functions later
                },
    }
     
    # Not used for this instrument, bt it might be useful for identification           
    chDict = {1: 'smua'}

    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Femtoamp_6430')
        self.logger.info('Initializing Femtoamp_6430 instrument')

    def setSrcParam(self,param='ch1autorangev',val='on'):
        inputValid = 0
        if param in self.instDict['source'].keys():
            if isinstance(self.instDict['source'][param][0],str):
                #it's a string
                if val in self.instDict['source'][param][1].keys():
                    self.instDict['source'][param][0] = self.instDict['source'][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('Rrequested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['source'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['source'][param][1] is None ) or ((self.instDict['source'][param][1] is not None) and (val >= self.instDict['source'][param][1][0] ) and (val <= self.instDict['source'][param][1][1] ) ):
                    self.instDict['source'][param][0] = val
                    inputValid = 1
        else:
#            print( 'error- requested parameter not known to instrument class' )
            self.logger.warning('WARNING - Requested parameter %s not known to instrument.'.format(param))
             
        if inputValid == 1:
            send_str = self.instDict['source'][param][2] + str(self.instDict['source'][param][0])
            #print(send_str)
            self.rmHandle.write(send_str)
    
    def setOutputState(self,src=1,val='off'):
        if src != 1:
#            print('Error: entered channel number is not supported!')
            self.logger.error('ERROR - Entered channel number is not supported by this instrument!')
            return -1
        else:
            self.instDict['source']['ch1output'][0] = self.instDict['source']['ch1output'][1][val]
            send_str = self.instDict['source']['ch1output'][2] + self.instDict['source']['ch1output'][0]
            self.rmHandle.write(send_str)
            return 1
    
    def setMeasParam(self,param='ch1autorangev',val='on'):
        inputValid = 0
        if param in self.instDict['measure'].keys():
            if isinstance(self.instDict['measure'][param][0],str):
                #it's a string
                if val in self.instDict['measure'][param][1].keys():
                    self.instDict['measure'][param][0] = self.instDict['measure'][param][1][val]
                    inputValid = 1
                else:
#                    print('error - requested discrete value not known to instrument class.  Valid option+s are ' + ','.join(self.instDict['measure'][param][1].keys()))
                    self.logger.warning('Requested discrete value not known to instrument class.  Valid option+s are ' + ','.join(self.instDict['measure'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['measure'][param][1] is None ) or ((self.instDict['measure'][param][1] is not None) and (val >= self.instDict['measure'][param][1][0] ) and (val <= self.instDict['measure'][param][1][1] ) ):
                    self.instDict['measure'][param][0] = val
                    inputValid = 1
        else:
#            print('error- requested parameter not known to instrument class')
            self.logger.warning('WARNING - Requested parameter %s not known to instrument.'.format(param))
        if inputValid == 1:
            send_str = self.instDict['measure'][param][2] + str(self.instDict['measure'][param][0])
            #print(send_str)
            self.rmHandle.write(send_str)

    def getSrcInComplianceLimit(self):
        #should return true / false.  true indicates instrument is controlled by limit setting, false indicates instrument is controlled by source setting
        #self.rmHandle.write('compliance = smua.source.compliance')
        #return self.rmHandle.query('print(compliance)')
        pass
    
    #TODO: consider to add timestamp fucniton here - an kwarg like timestampenable? by default, it is turned off 
    def getMeas(self,src =1, val='voltage', en_timestamp = True):
#    def getMeas(self,src =1, val='voltage'):
#        en_timestamp = False # 
        inputValid = 0
        if val not in self.instDict['measure']['ch1single'][1].keys():
#            print('error- requested measurement unavilable to instrument class.  Valid options are ' + ','.join(self.instDict['measure']['ch1single'][1].keys()))
            self.logger.warning('WARNING - Requested measurement unavilable to instrument class.  Valid options are ' + ','.join(self.instDict['measure']['ch1single'][1].keys()))
            return -1
        else:
            self.instDict['measure']['ch1single'][0] = self.instDict['measure']['ch1single'][1][val]
            self.instDict['measure']['format'][0] = self.instDict['measure']['format'][1][val]
            inputValid = 1
        if inputValid:
            if val != 'all':
                if en_timestamp == True:
                    self.rmHandle.write(self.instDict['measure']['format'][2] + self.instDict['measure']['format'][0] + ',TIME')
                else:
                    self.rmHandle.write(self.instDict['measure']['format'][2] + self.instDict['measure']['format'][0])
            else:
                self.rmHandle.write(self.instDict['measure']['format'][2] + self.instDict['measure']['format'][0])
            measStr = self.instDict['measure']['ch1single'][2] + self.instDict['measure']['ch1single'][0]
#            print ('Measurement command ' + measStr)

            try: 
                measval = self.rmHandle.query(measStr)
            except:
#                self.logger.exception('Opps, the measurement query didnt work')
                time.sleep(2)
                measval = self.rmHandle.query(measStr)
#            else:
#                measval = None
            time.sleep(0.1)
#            print(measval)
        return measval           
    
    def configVSrc(self, src=1, vlevel=1.8, ilimit=0.1):
        # don't think this is needed
#        print('Invalid command - this command is not activated for 6430')
        self.logger.warning('WARNING - Invalid command - this command is not activated for 6430')
# =============================================================================
#         if src == 1:
#             src_setup = [
#                       ('ch1function', 'V'),
#                       ('vmode', 'fixed'),
#                       ('ch1voltRange', vlevel+1),
#                       ('ch1voltLevel', vlevel),
#                       #('vprotect', 20),     # fixed to 20
#                       ('ch1currRange', ilimit),
#                       ('ch1currLimit', ilimit),
#                       ('delay', 0),
#                      ]
#             for param,val in src_setup:
#                 #print('\tParamepter ', param, '\t Value ', val )
#                 self.setSrcParam(param=param, val=val)
#                 time.sleep(0.2)
#         else: 
#             print('Error: entered channel number is not supported!' )
#             #self.close()
# =============================================================================
        pass
        
    def configIMeas(self, src=1, spd=1, filtercount=10):
        # don't think this is needed
#        print('Invalid command - this command is not activated for 6430')
        self.logger.warning('WARNING - Invalid command - this command is not activated for 6430')
# =============================================================================
#         if src == 1:
#             IMeasetup = [
#                       ('allmeas', 'off'),
#                       ('concurrent', 'off'),
#                       ('function', 'current'),
#                       ('ch1autorangei', 'on'),
#                       ('ch1autorangev', 'on'),
#                       ('ch1measspeedi', spd),
#                       ('ch1filtertype', 'repeat'),
#                       ('ch1filtercount', filtercount),
#                      ]
#             for param,val in IMeasetup:
#                 #print('\tParamepter ', param, '\t Value ', val )
#                 self.setMeasParam(param=param, val=val)
#                 time.sleep(0.2)
#         else: 
#             print('Error: entered channel number is not supported!' )
#             #self.close()
# =============================================================================
        pass
        
    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('*RST')  
        self.logger.debug('Instrument has been reset' )
        pass

    def timestampReset(self):
        self.rmHandle.write(':SYST:TIME:RES')
        self.logger.debug('Instrument time stamp timer has been reset')
        pass
    
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        self.logger.debug('Instrument is disconnected')
        pass
        
    
if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    time.sleep(1)
    femtoamp = instMgr.checkout(interface='GPIB',addr=23,moduleSuffix='6430')
    time.sleep(1)
    femtoamp.reset()
    print(femtoamp.getIdn())

    # Example below is for Vbias measurement
    src_setup = [
                  ('ch1function', 'I'),
                  ('imode', 'fixed'),
                  ('ch1currRange', 1e-11),
                  ('ch1currLevel', 0),
#                  ('ch1voltRange', 20),
                 ]
    for param,val in src_setup:
        #print('\tParamepter ', param, '\t Value ', val )
        femtoamp.setSrcParam(param=param, val=val)
        time.sleep(0.2)
    femtoamp.setOutputState(1, 'on')
    time.sleep(2)
 
    src_setup1 = [('allmeas', 'off'),
                 ('concurrent', 'off'),
                 ('function', 'voltage'),
                 ('ch1autorangev', 'off'),
                 ('ch1rangev', 20),
                 ('vhighlimit', 20),
                 ('ch1measspeedv', 1),
#                 ('ch1measspeedi', 1),
                 ('ch1filtercount',1),
                 ('ch1filtertype', 'sth'),
                 ]
    for param,val in src_setup1:
        #print('\tParamepter ', param, '\t Value ', val )
        femtoamp.setMeasParam(param=param, val=val)
        time.sleep(0.2)
#    result1 = femtoamp.getMeas()
#    print(result1)
    femtoamp.timestampReset()
    for _ in range(2):
        result2 = femtoamp.getMeas()
        print(result2)
# =============================================================================
#     if result2.index(',') > 0:
#         retval2 = result2.split(',')[0]
#         print(retval2)
# =============================================================================
    
#    femtoamp.close()
    pass    
