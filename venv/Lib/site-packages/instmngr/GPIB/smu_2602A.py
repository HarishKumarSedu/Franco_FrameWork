# -*- coding: utf-8 -*-
"""
Created on Mon Jun 11 16:48:10 2018

@author: dzhang
Version: 1.1

History:    
    1.1 - add second channel function
    1.0 - first version with single channel enabled

Function List:
    __init__(rmHandle)
    reset()
    setSrcParam(param='ch1autorangev',val='on')
    setOutputState(src=1,val='off')
    setMeasParam(param='ch1autorangev',val='on')
    getSrcInComplianceLimit(src=1)
    getMeas(src=1,val='voltage')
    getIdn()
    close()

    configVSrc(src=1, vlevel=1.8, ilimit=0.1)
    configIMeas(src=1, spd=1, filtercount=10)
"""

import sys
import time
import logging

idnString = 'Model 2602A'


class Smu_2602A():
    #here, innermost dict is command mmenmoic:{current value,(possible values),TSP command}
    
    # TO-DO 
    # The function of 'offFunction' and 'powerLimit' does not work with 2602A - why!
    instDict = {
                'source': {
                    # channel 1
                    'ch1autorangev':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON'},'autorangev'],
                    'ch1voltRange':[200e-3,(1e-6,20),'rangev'],
                    'ch1autorangei':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON'},'autorangei'],
                    'ch1currRange':[100e-9,(1e-9,1.5),'rangei'],
                    'ch1function':['smua.OUTPUT_DCVOLTS',{'I':'smua.OUTPUT_DCAMPS','V':'smua.OUTPUT_DCVOLTS'},'func'],
                    #'ch1offFunction':['smua.OUTPUT_DCVOLTS',{'I':'smua.OUTPUT_DCAMPS','V':'smua.OUTPUT_DCVOLTS'},'offfunc'],
                    'ch1offMode':['smua.OUTPUT_NORMAL',{'normal':'smua.OUTPUT_NORMAL','zero':'smua.OUTPUT_ZERO','highz':'smua.OUTPUT_HIGH_Z'},'offmode'],
                    'ch1voltLevel':[0,(-20, 20),'levelv'],
                    'ch1currLevel':[0,(-1.5, 1.5),'leveli'],
                    'ch1voltLimit':[20,(-20, 20),'limitv'],
                    'ch1currLimit':[100e-3,(-3,3),'limiti'],
                    'ch1powerLimit':[0,(0,30),'limitp'],
                    'ch1output':['smua.OUTPUT_OFF',{'off':'smua.OUTPUT_OFF','on':'smua.OUTPUT_ON','highz':'smua.OUTPUT_HIGH_Z'},'output'],
                    'ch1settling':['smua.SETTLE_SMOOTH',{'smooth':'smua.SETTLE_SMOOTH','fastRange':'smua.SETTLE_FAST_RANGE','fastPolarity':'smua.SETTLE_FAST_POLARITY','directCurr':'smua.SETTLE_DIRECT_IRANGE'},'settling'],
                    'ch1sink':['smua.DISABLE',{'disable':'smua.DISABLE','enable':'smua.ENABLE'},'sink'],
                    'ch1offmode':['smua.OUTPUT_HIGH_Z', {'normal': 'smua.OUTPUT_NORMAL', 'highz':
                        'smua.OUTPUT_HIGH_Z', 'zero': 'smua.OUTPUT_ZERO'}, 'offmode'],
                    
                    # channel 2
                    'ch2autorangev':['smub.AUTORANGE_ON',{'off':'smub.AUTORANGE_OFF','on':'smub.AUTORANGE_ON'},'autorangev'],
                    'ch2voltRange':[200e-3,(1e-6,20),'rangev'],
                    'ch2autorangei':['smub.AUTORANGE_ON',{'off':'smub.AUTORANGE_OFF','on':'smub.AUTORANGE_ON'},'autorangei'],
                    'ch2currRange':[100e-9,(1e-9,1.5),'rangei'],
                    'ch2function':['smub.OUTPUT_DCVOLTS',{'I':'smub.OUTPUT_DCAMPS','V':'smub.OUTPUT_DCVOLTS'},'func'],
                    #'ch2offFunction':['smub.OUTPUT_DCVOLTS',{'I':'smub.OUTPUT_DCAMPS','V':'smub.OUTPUT_DCVOLTS'},'offfunc'],
                    'ch2offMode':['smub.OUTPUT_NORMAL',{'normal':'smub.OUTPUT_NORMAL','zero':'smub.OUTPUT_ZERO','highz':'smub.OUTPUT_HIGH_Z'},'offmode'],
                    'ch2voltLevel':[0,(-20,20),'levelv'],
                    'ch2currLevel':[0,(-1.5,1.5),'leveli'],
                    'ch2voltLimit':[20,(-20,20),'limitv'],
                    'ch2currLimit':[100e-3,(0,1.5),'limiti'],
                    'ch2powerLimit':[0,(0,30),'limitp'],
                    'ch2output':['smub.OUTPUT_OFF',{'off':'smub.OUTPUT_OFF','on':'smub.OUTPUT_ON','highz':'smub.OUTPUT_HIGH_Z'},'output'],
                    'ch2settling':['smub.SETTLE_SMOOTH',{'smooth':'smub.SETTLE_SMOOTH','fastRange':'smub.SETTLE_FAST_RANGE','fastPolarity':'smub.SETTLE_FAST_POLARITY','directCurr':'smub.SETTLE_DIRECT_IRANGE'},'settling'],
                    'ch2sink':['smub.DISABLE',{'disable':'smub.DISABLE','enable':'smub.ENABLE'},'sink'],
                    'ch2offmode':['smub.OUTPUT_HIGH_Z', {'normal':'smub.OUTPUT_NORMAL', 'highz':
                        'smub.OUTPUT_HIGH_Z', 'zero':'smub.OUTPUT_ZERO'}, 'offmode'],
                },
                'measure': {
                    # channel 1
                    'ch1autorangev':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON','follow':'smua.AUTORANGE_FOLLOW_LIMIT'},'autorangev'],
                    'ch1voltRange':[200e-3,(1e-6,20),'rangev'],
                    'ch1autorangei':['smua.AUTORANGE_ON',{'off':'smua.AUTORANGE_OFF','on':'smua.AUTORANGE_ON','follow':'smua.AUTORANGE_FOLLOW_LIMIT'},'autorangei'],
                    'ch1currRange':[100e-9,(1e-9,1.5),'rangei'],
                    'ch1filterenable':['smua.FILTER_ON', {'on':'smua.FILTER_ON', 'off':'smua.FILTER_OFF'}, 'filter.enable'],
                    'ch1filtercount': [10, (1, 100), 'filter.count'],
                    'ch1filtertype': ['smua.FILTER_REPEAT_AVG', {'repeat':'smua.FILTER_REPEAT_AVG', 'moving':'smua.FILTER_MOVING_AVG', 'median':'smua.FILTER_MEDIAN'}, 'filter.type'],
                    'ch1measspeed': [1,(0.001, 25), 'nplc'],
                    'ch1single':['smua.measure.v()',{'voltage':'smua.measure.v()','current':'smua.measure.i()','resistance':'smua.measure.r()', 'power':'smua.measure.p()'},''],
                    'ch1display':['display.MEASURE_DCAMPS',{'voltage':'display.MEASURE_DCVOLTS', 'current':'display.MEASURE_DCAMPS', 'resistance':'display.MEASURE_OHMS', 'power': 'display.MEASURE_WATTS'},'display.smua.measure.func='],
                    
                    # channel 2 
                    'ch2autorangev':['smub.AUTORANGE_ON',{'off':'smub.AUTORANGE_OFF','on':'smub.AUTORANGE_ON','follow':'smub.AUTORANGE_FOLLOW_LIMIT'},'autorangev'],
                    'ch2voltRange':[200e-3,(1e-6,20),'rangev'],
                    'ch2autorangei':['smub.AUTORANGE_ON',{'off':'smub.AUTORANGE_OFF','on':'smub.AUTORANGE_ON','follow':'smub.AUTORANGE_FOLLOW_LIMIT'},'autorangei'],
                    'ch2currRange':[100e-9,(1e-9,1.5),'rangei'],
                    'ch2filterenable':['smub.FILTER_ON', {'on':'smub.FILTER_ON', 'off':'smub.FILTER_OFF'}, 'filter.enable'],
                    'ch2filtercount': [10, (1, 100), 'filter.count'],
                    'ch2filtertype': ['smub.FILTER_REPEAT_AVG', {'repeat':'smub.FILTER_REPEAT_AVG', 'moving':'smub.FILTER_MOVING_AVG', 'median':'smub.FILTER_MEDIAN'}, 'filter.type'],
                    'ch2measspeed': [1,(0.001, 25), 'nplc'],
                    'ch2single':['smub.measure.v()',{'voltage':'smub.measure.v()','current':'smub.measure.i()','resistance':'smub.measure.r()', 'power':'smub.measure.p()'},''],
                    'ch2display':['display.MEASURE_DCAMPS',{'voltage':'display.MEASURE_DCVOLTS', 'current':'display.MEASURE_DCAMPS', 'resistance':'display.MEASURE_OHMS', 'power': 'display.MEASURE_WATTS'},'display.smub.measure.func='],
                    
                },
    }
                
    chDict = {1: 'smua', 2: 'smub'}

    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Smu_2602A')
        self.logger.info('Initializing Smu_2602A instrument')
    
    def setSrcParam(self, param='ch1autorangev',val='on'):
        inputValid = 0
        cmdhdr = self.chDict[int(param[2])] + '.source.'
        
        if param in self.instDict['source'].keys():
            if isinstance(self.instDict['source'][param][0],str):
                #it's a string
                if val in self.instDict['source'][param][1].keys():
                    self.instDict['source'][param][0] = self.instDict['source'][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['source'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['source'][param][1] is None ) or ((self.instDict['source'][param][1] is not None) and (val >= self.instDict['source'][param][1][0] ) and (val <= self.instDict['source'][param][1][1] ) ):
                    self.instDict['source'][param][0] = val
                else:
                    self.logger.warning('WARNING: Input value is out of instrument capable range! Min value will be assigned to instrument instead!')
                    self.instDict['source'][param][0] = self.instDict['source'][param][1][0]
                inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
        if inputValid == 1:
            sendStr =cmdhdr + self.instDict['source'][param][2] + ' = ' + str(self.instDict['source'][param][0])
            # print(sendStr)
            self.rmHandle.write(sendStr)
    
    def setOutputState(self,src=1,val='off'):
        inputValid = 0
        opch = 'ch' + str(src) + 'output'
        cmdhdr = self.chDict[src] + '.source.output = '
           
        if val in self.instDict['source'][opch][1].keys():
            self.instDict['source'][opch][0] = self.instDict['source'][opch][1][val]
            inputValid = 1
        else:
            self.logger.warning( 'WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['source']['output'][1].keys()))
    
        if inputValid:
            self.rmHandle.write(cmdhdr + str(self.instDict['source'][opch][0]))
    
    def setMeasParam(self,param='ch1autorangev',val='on'):
        inputValid = 0
        cmdhdr = self.chDict[int(param[2])] + '.measure.'
            
        if param in self.instDict['measure'].keys():
            if isinstance(self.instDict['measure'][param][0],str):
                #it's a string
                if val in self.instDict['measure'][param][1].keys():
                    self.instDict['measure'][param][0] = self.instDict['measure'][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['measure'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['measure'][param][1] is None ) or ((self.instDict['measure'][param][1] is not None) and (val >= self.instDict['measure'][param][1][0] ) and (val <= self.instDict['measure'][param][1][1] ) ):
                    self.instDict['measure'][param][0] = val
                    inputValid = 1
        else:
            self.logger.warning('WARNING- requested parameter not known to instrument class')
        if inputValid == 1:
            sendStr = cmdhdr + self.instDict['measure'][param][2] + ' = ' + str(self.instDict['measure'][param][0])
            #print(sendStr)
            self.rmHandle.write(sendStr)

    def getSrcInComplianceLimit(self, src=1):
        #should return true / false.  true indicates instrument is controlled by limit setting, false indicates instrument is controlled by source setting
        if src == 1:
            self.rmHandle.write('compliance = smua.source.compliance')
        else:
            self.rmHandle.write('compliance = smub.source.compliance')
            
        return self.rmHandle.query('print(compliance)')

    def getMeas(self,src=1,param='voltage'):
        inputValid = 0
        single = 'ch' + str(src) + 'single'
        display = 'ch' + str(src) + 'display'
        
        if param not in self.instDict['measure'][single][1].keys():
            self.logger.warning('WARNING - requested measurement unavilable to instrument class.  Valid options are ' + ','.join(self.instDict['measure'][single][1].keys()))
        else:
            self.instDict['measure'][single][0] = self.instDict['measure'][single][1][param]
            self.instDict['measure'][display][0] = self.instDict['measure'][display][1][param]
            inputValid = 1
        if inputValid:
            measStr = 'measval = ' + self.instDict['measure'][single][0]
            self.rmHandle.write(measStr)
            retval = self.rmHandle.query('print(measval)')
            displayStr = self.instDict['measure'][display][2] + self.instDict['measure'][display][0]
            self.rmHandle.write(displayStr)
        return retval            
     
    def configVSrc(self, src=1, vlevel=1.8, ilimit=0.1):
        src_setup = [
                     ('ch'+str(src)+'function', 'V'),
                     ('ch'+str(src)+'autorangev','off'),
                     ('ch'+str(src)+'voltRange', abs(vlevel)+1),
                     ('ch'+str(src)+'offMode', 'zero'),
                     ('ch'+str(src)+'voltLevel', vlevel),
                     ('ch'+str(src)+'voltLimit', vlevel+1),
                     ('ch'+str(src)+'currLimit', ilimit),                
                     ]
        
        for param,val in src_setup:
            #print('\tParamepter ', param, '\t Value ', val )
            self.setSrcParam(param=param, val=val)
            time.sleep(0.2)

    def configISrc(self, src=1, ilevel=1.8, vlimit=0.1):
        if vlimit <=0:
            vlimit = 0.1

        src_setup = [
            ('ch' + str(src) + 'function', 'I'),
            ('ch' + str(src) + 'autorangei', 'off'),
            ('ch' + str(src) + 'currRange', abs(ilevel)+0.1),
            # ('ch' + str(src) + 'offMode', 'zero'),
            ('ch' + str(src) + 'currLevel', ilevel),
            ('ch' + str(src) + 'voltLimit', vlimit),
        ]

        for param, val in src_setup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setSrcParam(param=param, val=val)
            time.sleep(0.2)

    def configIMeas(self, src=1, spd=1, filtercount=10):
        IMeasetup = [
                  ('ch'+str(src)+'filterenable', 'on'),
                  ('ch'+str(src)+'autorangei', 'on'),
                  #('autorangev', 'on'),
                  ('ch'+str(src)+'measspeed', spd),
                  ('ch'+str(src)+'filtertype', 'repeat'),
                  ('ch'+str(src)+'filtercount', filtercount),
                 ]
        for param,val in IMeasetup:
            #print('\tParamepter ', param, '\t Value ', val )
            self.setMeasParam(param=param, val=val)
            time.sleep(0.2)
        self.rmHandle.write('display.'+self.chDict[src]+'.measure.func=display.MEASURE_DCAMPS')
        time.sleep(0.2)

    def set_sense_mode(self, src=1, mode=0):
        # mode 0: 'SENSE_LOCAL'
        # mode 1: 'SENSE_REMOTE'
        # mode 2: 'SENSE_CALA'
        if mode <0 or mode >2:
            print(f'ERROR - invalid mode {mode} entered. Only Mode 0, 1, or 2 are acceptable')
            return -1
        cmd = 'smua.sense=' + str(mode)
        if src==2:
            cmd.replace('a', 'b')
        self.rmHandle.write(cmd)
        
    
    def sink_enable(self, src=1, en=1):
        if src==1:
            if en == 1 or en is True:
                self.rmHandle.write('smua.source.sink=1')
            else:
                self.rmHandle.write('smua.source.sink=0')
        else:
            if en == 1 or en is True:
                self.rmHandle.write('smub.source.sink=1')
            else:
                self.rmHandle.write('smub.source.sink=0')


    def getIdn(self):
        return self.rmHandle.query('*IDN?')


    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('reset()')        
        pass


    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
        
    
if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    smu = instMgr.checkout(interface='GPIB',addr=24,moduleSuffix='2602A')
    smu.reset()
#    print(smu.getIdn())
    
    setupList1 = [('ch1autorangev','off'),
                 ('ch1autorangei','on'),
                 ('ch1voltRange', 2),
                 ('ch1function', 'V'),
                 ('ch1offMode', 'highz'),
                 ('ch1voltLevel', 0),
                 ('ch1voltLimit', 0.01),
                 ('ch1currLimit', 0.1),
                 ]
    for param,val in setupList1:
        print(param, val)
        smu.setSrcParam(param=param, val=val)
    smu.setOutputState(src=1, val='on')
    
    smu.configVSrc()
    smu.setOutputState(src=1,val='on')
    smu.configVSrc(src=2)
    smu.setOutputState(src=2,val='on')
    time.sleep(2)
    complianceState = smu.getSrcInComplianceLimit(src=1)
    complianceState = smu.getSrcInComplianceLimit(src=2)
    smu.configIMeas(src=1)
    print(smu.getMeas(src=1,param='current'))
    smu.configIMeas(src=2)
    print(smu.getMeas(src=2,param='current'))
    
    smu.close()
    pass    
