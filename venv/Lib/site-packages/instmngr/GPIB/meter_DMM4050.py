# -*- coding: utf-8 -*-
"""
Created on Mon Nov 28 11:23:13 2016

@author: jmunger
"""

import sys
import logging

idnString = 'DMM4050'

# Meter class settings
#     - look at what it would take to initialize dict from queries after reset?  is this a lengthy process?
#  -Start with measurement configure for each measurement type
#  -Then set current measurement
#  -then take measurement.


#also need maybe a separate dict for math / average, and another for trigger

#also (for all instruments) need to route reads/writes through a proc so that error checking can be added easily later

class Meter_DMM4050():
    #index 0 in options tuple could be assumed to be the default
    #here, innermost dict is command mmenmoic:{current value,(possible values),SCPI base command,flag that value needs updated to instrument}
    
    #how to deal with contiuous or discrete?  check value using isinstance.  if not a string, has to be continuous value.
    instDict = {'DCV': {'range':[1e-3,None,'VOLT:DC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'VOLT:DC:RANG:AUTO'],
                        'resolution':[1e-6,None,'VOLT:DC:RES'],
                        'numPLCycles':[1,(0.02,100),'VOLT:DC:NPLC'],
                        'analogFilt':['OFF',{'on':'ON','off':'OFF'},'VOLT:DC:FILT'],
                        'digitalAveFilt':['OFF',{'on':'ON','off':'OFF'},'VOLT:DC:FILT:DIG']},
                'ACV': {'range':[1e-3,None,'VOLT:AC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'VOLT:AC:RANG:AUTO']},
                'DCI': {'range':[1e-3,None,'CURR:DC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'CURR:DC:RANG:AUTO']},
                'ACI': {'range':[1e-3,None,'CURR:AC:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'CURR:AC:RANG:AUTO']},
                'RES': {'range':[1e-3,None,'RES:RANG'],
                        'autorange':['ON',{'on':'ON','off':'OFF'},'RES:RANG:AUTO']},
                'FREQ': {'range':[1e-3,None,'FREQ:VOLT:RANG'],
                         'autorange':['ON',{'on':'ON','off':'OFF'},'FREQ:VOLT:AUTO']},
                'measType': ['"VOLT:DC"',{'DCV':'"VOLT:DC"','ACV':'"VOLT:AC"','DCI':'"CURR:DC"','ACI':'"CURR:AC"','RES':'"RES"','FREQ':'"FREQ"'},'FUNC '],
                'trigger': {'source':['IMM',{'bus':'BUS','immediate':'IMM','external':'EXT'},'TRIG:SOUR'],
                            'delaySec':[0,(0,3600),'TRIG:DEL'],
                            'autodelay':['OFF',{'on':'ON','off':'OFF'},'TRIG:DEL:AUTO'],
                            'samplesPerTrigger':[1,(1,50000),'SAMP:COUN'],
                            'triggerCount':[1,(1,50000),'TRIG:COUN'],
                            }
    }


    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Meter_DMM4050')
        self.logger.info('Initializing Meter_DMM4050 instrument')
    
    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('*RST')        
        pass
    
    def setMeas(self,measType='DCV'):
        if measType in self.instDict['measType'][1].keys():
            self.instDict['measType'][0] = self.instDict['measType'][1][measType]
            self.rmHandle.write(self.instDict['measType'][2] + self.instDict['measType'][0])
        else:
            self.logger.warning( 'WARNING - requested measurement type not known to instrument class')
            
    def setTrigParam(self,param='source',val='immediate'):
        self.setMeasParam(measType='trigger',param=param,val=val)
    
    def setMeasParam(self,measType='DCV',param='range',val=1e-3):
        inputValid = 0
        if param in self.instDict[measType].keys():
            if isinstance(self.instDict[measType][param][0],str):
                if val in self.instDict[measType][param][1].keys():
                    self.instDict[measType][param][0] = self.instDict[measType][param][1][val]
                    inputValid = 1
                else:
                    self.logger.warning('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict[measType][param][1].keys()))
#                    print('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict[measType][param][1].keys()))
            else:
                if (self.instDict[measType][param][1] is None ) or ((self.instDict[measType][param][1] is not None) and (val >= self.instDict[measType][param][1][0] ) and (val <= self.instDict[measType][param][1][1] ) ):
                    self.instDict[measType][param][0] = val
                    inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
#            print('error- requested parameter not known to instrument class')
        
        if inputValid == 1:
            self.rmHandle.write(self.instDict[measType][param][2] + ' ' + str(self.instDict[measType][param][0]))
            
    def getMeas(self):
        retval = self.rmHandle.query('read?')
        return float(retval)

    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
    
    
    
if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    mi = instMgr.checkout(interface='GPIB',addr=16,moduleSuffix='DMM4050')
    mi.reset()
    print(mi.getIdn())
#    mi.setOutputVal(output='p5v')
#    mi.setOutputVal(output='P6V',vSet=5.0,iSet=10e-3)
#    mi.setOutputVal(output='P25V',vSet=15.0,iSet=0.1)
#    mi.setOutputVal(output='N25V',vSet=-15.0,iSet=0.1)
    
    
    mi.close()
    pass    