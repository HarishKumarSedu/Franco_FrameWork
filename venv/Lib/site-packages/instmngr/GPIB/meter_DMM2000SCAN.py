# -*- coding: utf-8 -*-
"""
Created on Mon Nov 28 11:23:13 2016

@author: jmunger
"""
from meter_DMM2000 import Meter_DMM2000
import logging
import time

idnString = 'MODEL 2000'
optString = '200X-SCAN'

# Meter class settings
#     - look at what it would take to initialize dict from queries after reset?  is this a lengthy process?
#  -Start with measurement configure for each measurement type
#  -Then set current measurement
#  -then take measurement.


#also need maybe a separate dict for math / average, and another for trigger

#also (for all instruments) need to route reads/writes through a proc so that error checking can be added easily later

class Meter_DMM2000SCAN( Meter_DMM2000 ):
    #index 0 in options tuple could be assumed to be the default
    #here, innermost dict is command mmenmoic:{current value,(possible values),SCPI base command,flag that value needs updated to instrument}

    #how to deal with contiuous or discrete?  check value using isinstance.  if not a string, has to be continuous value.
#    instDict = {'DCV': {'range':[0,(0, 1010),'VOLT:DC:RANG']    }

    def __init__(self,rmHandle):
      #super( Meter_DMM2000SCAN, self ).__init__( rmHandle )
      self.rmHandle = rmHandle
      self.logger = logging.getLogger('marv.inst.Meter_DMM2000SCAN')
      self.logger.info('Initializing Meter_DMM2000SCAN instrument')
      self.rmHandle.write( ':ROUT:OPEN:ALL' )
      if self.getFRSwitch() == 'front':
          self.logger.warning( 'DMM2000SCAN front panel inputs selected, not compatible with using switcher!' )


    def getMeas( self, chan=None ):

        input = self.getFRSwitch()

        if chan == None and input == 'front':
            pass
        elif chan == None and input == 'rear':
            self.logger.warning( 'DMM2000SCAN: rear input selected but chan not specified. Previous switch state used.' )
        elif chan != None and input == 'front':
            raise ValueError( 'DMM2000SCAN: front input selected, specified channel ignored.' )
        else:
            if chan < 1 or chan > 10:
                raise ValueError( "Channel value %d outside range 1 to 10." % chan )
            state_new = '(@%d)' % chan
            state = self.getChanClosures()
            if state != state_new:
                self.rmHandle.write( ':ROUT:CLOS ' + state_new )
                time.sleep(0.01)
                #TODO: maybe put delay for switch bounce here.
                #THEREYOUGO:
                func=self.rmHandle.query('FUNC?').strip('"\n')
                time.sleep(0.01)
                nplc=float(self.rmHandle.query(func + ':NPLC?').strip('"\n'))
                time.sleep(nplc/3)


        return super( Meter_DMM2000SCAN, self ).getCurrentRdg()

    def getFRSwitch( self ):
        state = self.rmHandle.query( ':SYST:FRSW?' ).strip()
        if state == '0':
            return 'rear'
        elif state == '1':
            return 'front'
        else:
            raise RuntimeError( "Unexpected return value '%s'." % state )

    def getChanClosures( self ):
        state = self.rmHandle.query( ':ROUT:CLOS:STAT?' ).strip()
        return state

if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    m19 = instMgr.checkout( objName='meter', addr=19, moduleSuffix='DMM2000SCAN' )
    print( '\n' )
    print( "*IDN = '%s'" % m19.getIdn() )
    print( "*OPT = '%s'" % m19.getOpt())

    print( 'Chan1 = %f' % m19.getMeas(1) )
    print( 'Chan2 = %f' % m19.getMeas(2) )



#    m19.close()
    pass