# -*- coding: utf-8 -*-
"""
Created on Wed Apr 03 16:38:29 2019

@author: dzhang
Version: 1.0 - Initial 

History:    

Function List:
    __init__(rmHandle)
    setSrcParam(param='voltagelevel',val=1.8, ch=1)
    setMeasParam(param='measvoltage',val='dc', ch=1)
    setListParam(param='voltage', val='0,0', ch=1)
    getStatus(param='opcondition', ch=1)
    getMeas(param='fetchvoltage', val='average', ch=1)
    selfTest()
    trigGen()
    getIdn()
    reset()
    close()

# Special functions (for particular setup etc...) can be added based on usage

"""

import sys
import time

idnString = 'N6700C'

class PwrMeter_N6700C():
    #here, innermost dict is command mmenmoic:{current value,(possible values),TSP command}
    
    # TO-DO 
    # The function of 'offFunction' and 'powerLimit' does not work with 2602A - why!
    instDict = {
                'source': {
                    'initacq': ['(@1)',{'1':'(@1)', '2':'(@2)', '3':'(@3)', '4':'(@4)'}, 'INIT:ACQ '], 
                    'initelog': ['(@1)',{'1':'(@1)', '2':'(@2)', '3':'(@3)', '4':'(@4)'}, 'INIT:ELOG '],
                    'inittran': ['(@1)',{'1':'(@1)', '2':'(@2)', '3':'(@3)', '4':'(@4)'}, 'INIT:TRAN '],
                    'initcont': ['1', {'true': '1', 'false': '0'}, 'INIT:CONT:TRAN '],
                    'function': ['VOLT', {'voltage':'VOLT', 'current':'CURR'}, 'SOUR:FUNC '],
                    
                    'voltagelevel':[1.8, (0, 5.5), 'SOUR:VOLT '],
                    'voltageleveltrig': [0.001, (0, 5.5), 'SOUR:VOLT:TRIG '],
                    'voltagelimit':[5.5, (0, 20.4), 'SOUR:VOLT:LIM '],
                    'voltagemode':['FIX', {'fix':'FIX', 'step':'STEP', 'list':'LIST'}, 'SOUR:VOLT:MODE '],
                    'voltagerange':[51, (0, 1000), 'SOUR:VOLT:RANG '],   
                    'voltageslewimm':[9.9e+37, (0, 9.9e+37), 'SOUR:VOLT:SLEW '],# volt/s
                    'voltageslewmax':['OFF', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SOUR:VOLT:SLEW:MAX '],
                    'currentlevelimm': [0.08, (0, 1.5), 'SOUR:CURR '],
                    'currentleveltrig': [0.001, (0, 1.5), 'SOUR:CURR:TRIG '],
                    'currentlimit': [],
                    'currentmode': ['FIX', {'fixed':'FIX', 'step':'STEP', 'list':'LIST'}, 'SOUR:CURR:MODE '],
                    'currentprotection': [],
                    'currentrange': [1.5, (0, 1.5), 'SOUR:CURR:RANG '],
                    'currentslewimm': [0, (0, 100), 'SOUR:CURR:SLEW '],
                    'currentslewmax': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SOUR:CURR:SLEW:MAX '],
                    
                    # digital
                    'digitinput': [],
                    'digitoutput': [],
                    'digittoutbusenable': ['1', {'true': '1', 'false': '0'}, 'SOUR:DIG:TOUT:BUS '],
                    'digitpin1function': ['DIO', {'dio':'DIO', 'dinput':'DINP', 'toutput':'TOUT', 'tinput':'TINP', 'fault': 'FAUL', 'inhibit':'INH', 'oncouple':'ONC', 'offcouple':'OFFC'}, 'SOUR:DIG:PIN1:FUNC '],
                    'digitpin1polarity': ['POS', {'positive': 'POS', 'negative':'NEG'}, 'SOUR:DIG:PIN1:POL '],
                    'digitpin2function': ['DIO', {'dio':'DIO', 'dinput':'DINP', 'toutput':'TOUT', 'tinput':'TINP', 'fault': 'FAUL', 'inhibit':'INH', 'oncouple':'ONC', 'offcouple':'OFFC'}, 'SOUR:DIG:PIN2:FUNC '],
                    'digitpin2polarity': ['POS', {'positive': 'POS', 'negative':'NEG'}, 'SOUR:DIG:PIN2:POL '],
                    'digitpin3function': ['DIO', {'dio':'DIO', 'dinput':'DINP', 'toutput':'TOUT', 'tinput':'TINP', 'fault': 'FAUL', 'inhibit':'INH', 'oncouple':'ONC', 'offcouple':'OFFC'}, 'SOUR:DIG:PIN3:FUNC '],
                    'digitpin3polarity': ['POS', {'positive': 'POS', 'negative':'NEG'}, 'SOUR:DIG:PIN3:POL '],
                    'digitpin4function': ['DIO', {'dio':'DIO', 'dinput':'DINP', 'toutput':'TOUT', 'tinput':'TINP', 'fault': 'FAUL', 'inhibit':'INH', 'oncouple':'ONC', 'offcouple':'OFFC'}, 'SOUR:DIG:PIN4:FUNC '],
                    'digitpin4polarity': ['POS', {'positive': 'POS', 'negative':'NEG'}, 'SOUR:DIG:PIN4:POL '],
                    
                    
                    # list 
                    #TODO - not sure if this should be placed here or a seperate index 'list'???
                    'listrepeatcount':[1, (1, 256), 'SOUR:LIST:COUN '],
                    'liststep': ['ONCE', {'once':'ONCE', 'auto':'AUTO'}, 'SOUR:LIST:STEP '],
                    'listtermination': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SOUR:LIST:TERM:LAST '],
                    # dwell time range max list length 512
                    # 0-0.262133s:          1us 
                    # 0.262144 - 2.62144s:  10us
                    # 2.62144 - 26.2144s:   100us
                    # 26.2144 - 262.144s:   1ms
                    'listtype': ['VOLT', {'voltage':'VOLT', 'current':'CURR', 'dwell':'DWEL', 'toutbos':'TOUT:BOST', 'touteos':'TOUT:EOST'}, 'SOUR:LIST:'],                    
                    
                    'powerlimit': [1, (0, 100), 'SOUR:POW:LIM '],
                    'resistance': [],
                    'step': ['OFF', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SOUR:STEP:TOUT '],

                    
                    # output settings
                    'outputstatus': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'},'OUTP '], 
                    'outputcouplestatus': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'},'OUTP:COUP '], 
                    'outputcouplechnl': ['1,2', {'1n2':'1,2', '1n3':'1,3','1n4':'1,4','2n3':'2,3','2n4':'2,4','3n4':'3,4', 'all':'1,2,3,4'}, 'OUTP:COUP:CHAN '], 
                    'outputcoupledelayoffset': [0, (0, 1.023), 'SOUR:OUTP:COUP:DOFF '],
                    'outputoffdelay': [0, (0, 1023), 'OUTP:DEL:FALL '],     # in sec, resolution is down to .1us
                    'outputondelay': [0, (0, 1023), 'OUTP:DEL:RISE '],      # in sec, resolution is down to .1us
                    'outputponstate': ['RST', {'rst':'RST', 'rcl0':'RCL0'}, 'OUTP:PON:STAT '],
                    'outputrelaypol': ['NORM', {'norm':'NORM', 'reverse':'REV'}, 'OUTP:REL:POL '],
                    
                    
                    # trigger
                    'trigacqimm': ['(@1)',{'1':'(@1)', '2':'(@2)', '3':'(@3)', '4':'(@4)'}, 'TRIG:ACQ '],
                    'trigacqcurrentlevel': [0, (0, 1.5), 'TRIG:ACQ:CURR '],
                    'trigacqcurrentslope': ['POS', {'positive':'POS', 'negative':'NEG'}, 'TRIG:ACQ:CURR:SLOP '],
                    'trigacqsource': ['VOLT', {'volt':'VOLT', 'curr':'CURR','bus':'BUS', 'external':'EXT', 'transient':'TRAN', 'pin':'PIN'}, 'TRIG:ACQ:SOUR '],
                    'trigacqvoltagelevel': [0.5, (0, 5.5), 'TRIG:ACQ:VOLT '],
                    'trigacqvoltageslope': ['POS', {'positive':'POS', 'negative':'NEG'}, 'TRIG:ACQ:VOLT:SLOP '],
                    'trigelogsource': ['BUS', {'bus':'BUS', 'external':'EXT', 'immediate':'IMM', 'pin1':'PIN1', 'pin2':'PIN2', 'pin3':'PIN3', 'pin4':'PIN4'}, 'TRIG:ELOG:SOUR '],
                    'trigmeasure': [], 
                    'trigelogimm':['(@1)',{'1':'(@1)', '2':'(@2)', '3':'(@3)', '4':'(@4)'},'TRIG:ELOG '],
                    'trigtransimm':['(@1)',{'1':'(@1)', '2':'(@2)', '3':'(@3)', '4':'(@4)'},'TRIG:TRAN '],
                    'trigtransource': ['IMM', {'bus':'BUS', 'immediate':'IMM', 'external':'EXT', 'pin1':'PIN1', 'pin2':'PIN2', 'pin3':'PIN3', 'pin4':'PIN4', 'tran1':'TRAN1', 'tran2':'TRAN2', 'tran3':'TRAN3', 'tran4':'TRAN4'}, 'TRIG:TRAN:SOUR '],
            
                    'format': ['ASCII', {'ascii':'ASCII', 'real':'REAL'}, 'FORM:DATA '],
                },
                'measure': {
                    'meascurrent': ['?', {'dc':'?', 'rms':':ACDC?', 'high':':HIGH?', 'low':':LOW?', 'max':':MAX?', 'min':':MIN?'}, 'MEAS:CURR'],
                    'measvoltage': ['?', {'dc':'?', 'rms':':ACDC?', 'high':':HIGH?', 'low':':LOW?', 'max':':MAX?', 'min':':MIN?'}, 'MEAS:VOLT'],
                    'measpower': ['?', {'dc':'?', 'max':':MAX?', 'min':':MIN?'}, 'MEAS:POW'],
#                    'measarray': [':CURR?', {'current':':CURR?', 'voltage':':VOLT?', 'power':':POW?'}, 'MEAS:ARR'],
                    
                    # sense
                    'sensecurrentcomp': ['OFF', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:CURR:CCOM '],
                    'sensecurrentrange': [1.5, (0, 1.5), 'SENS:CURR:RANG '], 
                    'sensecurrentrangeauto': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:CURR:RANG:AUTO '],
                    'senseelogcurrentrange': [1.5, (0,1.5), 'SENS:ELOG:CURR:RANG '],
                    'senseelogfunctioncurrent': ['OFF', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:ELOG:FUNC:CURR '],
                    'senseelogfunctioncurrentminmax': ['OFF', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:ELOG:FUNC:CURR:MINM '],
                    'senseelogfunctionvoltage': ['OFF', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:ELOG:FUNC:VOLT '],
                    'senseelogfunctionvoltageminmax': ['OFF', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:ELOG:FUNC:VOLT:MINM '],
                    'senseelogperiod': [0.1, (0.0001024, 60), 'SENS:ELOG:PER '],   # in sec
                    'sensevoltagerange': [5.0, (0, 51), 'SENS:VOLT:RANG '], 
                    'sensevoltagerangeauto': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:VOLT:RANG:AUTO '],
                    'sensefunctioncurrent': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:FUNC:CURR '],
                    'sensefunctionvoltage': ['ON', {'on':'ON', 'off':'OFF', 'ON':'ON', 'OFF':'OFF'}, 'SENS:FUNC:VOLT '],
                    'sensesweepoffset': [0, (-524287, 2e+9), 'SENS:SWE:OFFS:POIN '],
                    'sensesweeppoint': [1024, (1, 512000), 'SENS:SWE:POIN '],
                    'sensesweeptint': [0.00002048, (0.00000512, 40000), 'SENS:SWE:TINT '],
                    'sensesweeptintres': ['RES20', {'res20':'RES20', 'res40':'RES40'}, 'SENS:SWE:TINT:RES '],
                    
					
                    # fetch
                    'fetchcurrent': ['?', {'average':'?', 'rms':':ACDC?', 'high':':HIGH?', 'low':':LOW?', 'max':':MAX?', 'min':':MIN?'}, 'FETC:CURR'],
                    'fetchvoltage': ['?', {'average':'?', 'rms':':ACDC?', 'high':':HIGH?', 'low':':LOW?', 'max':':MAX?', 'min':':MIN?'}, 'FETC:VOLT'],
                    'fetchpower': ['?', {'average':'?', 'max':':MAX?', 'min':':MIN?'}, 'FETC:POW'],
                    'fetcharray': [':CURR?', {'current':':CURR?', 'voltage':':VOLT?', 'power':':POW?'}, 'FETC:ARR'],
					
                },
                'status': {
                    'opevent': 'STAT:OPER?',
                    'opcondition': 'STAT:OPER:COND?',
                    'openable': 'STAT:OPER:ENAB?',
                    'quesevent': 'STAT:QUES:EVEN?',
                    'quescondition': 'STAT:QUES:COND?',
                    'quesenable': 'STAT:QUES:ENAB?',
                },
    }
                
    chDict = {1:'(@1)', 2:'(@2)', 3:'(@3)', 4:'(@4)'}       

    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
        self.reset()
		
    
    def setSrcParam(self, param='voltagelevel',val=1.8, ch=1):
        inputValid = 0
        if param in self.instDict['source'].keys():
            if isinstance(self.instDict['source'][param][0],str):
                #it's a string
                if val in self.instDict['source'][param][1].keys():
                    self.instDict['source'][param][0] = self.instDict['source'][param][1][val]
                    inputValid = 1
                else:
                    print('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['source'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['source'][param][1] is None ) or ((self.instDict['source'][param][1] is not None) and (val >= self.instDict['source'][param][1][0] ) and (val <= self.instDict['source'][param][1][1] ) ):
                    self.instDict['source'][param][0] = val
                else:
                    print('WARNING: Input value is out of instrument capable range! Min value will be assigned to instrument instead!')
                    self.instDict['source'][param][0] = self.instDict['source'][param][1][0]
                inputValid = 1
        else:
            print('error- requested parameter not known to instrument class')
        if inputValid == 1:
            if ch == None:
                sendStr = self.instDict['source'][param][2] + str(self.instDict['source'][param][0])
            else:
                sendStr = self.instDict['source'][param][2] + str(self.instDict['source'][param][0]) + ',' + self.chDict[ch]
            print( '>'*5 + sendStr )
            self.rmHandle.write(sendStr)
     
        
    def setMeasParam(self,param='measvoltage',val='dc', ch=1):
        inputValid = 0
        if param in self.instDict['measure'].keys():
            if isinstance(self.instDict['measure'][param][0],str):
                #it's a string
                if val in self.instDict['measure'][param][1].keys():
                    self.instDict['measure'][param][0] = self.instDict['measure'][param][1][val]
                    inputValid = 1
                else:
                    print('error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['measure'][param][1].keys()))
            else:
                #it's a number
                if (self.instDict['measure'][param][1] is None ) or ((self.instDict['measure'][param][1] is not None) and (val >= self.instDict['measure'][param][1][0] ) and (val <= self.instDict['measure'][param][1][1] ) ):
                    self.instDict['measure'][param][0] = val
                    inputValid = 1
        else:
            print( 'error- requested parameter not known to instrument class')
        if inputValid == 1:
            if ch == None: 
                sendStr = self.instDict['measure'][param][2] + str(self.instDict['measure'][param][0])
            else:
                sendStr = self.instDict['measure'][param][2] + str(self.instDict['measure'][param][0]) + ',' + self.chDict[ch]
            print( '>'*5 + sendStr )
            self.rmHandle.write(sendStr)
            
            
    def setListParam(self, param='voltage', val='0,0', ch=1):
        if param == 'voltage' or param == 'current':
            modeparam = param + 'mode'
            print(modeparam)
            self.setSrcParam(modeparam, 'list', ch)
        if param in self.instDict['source']['listtype'][1].keys():
            # TODO - add current/voltage and dwell points number check here as well 
            self.instDict['source']['listtype'][0] = self.instDict['source']['listtype'][1][param]
            sendStr = self.instDict['source']['listtype'][2] + self.instDict['source']['listtype'][0] + ' ' + val + ', ' + self.chDict[ch]
            print( '>'*5 + sendStr )
            self.rmHandle.write(sendStr)
        else: 
            print( 'error- incorrect command entered' )
        pass
            
            
    def getStatus(self, param='opcondition', ch=1):
        return self.rmHandle.query(self.instDict['status'][param]+' '+self.chDict[ch])
            
    def getMeas(self, param='fetchvoltage', val='average', ch=1):
        inputValid = 0
        if val in self.instDict['measure'][param][1].keys():
            self.instDict['measure'][param][0] = self.instDict['measure'][param][1][val]
            inputValid = 1
        if inputValid == 1:
            sendStr = self.instDict['measure'][param][2] + str(self.instDict['measure'][param][0]) + ' ' + self.chDict[ch]
            rtnvalue = self.rmHandle.query(sendStr)
        else:
            rtnvalue = None
        # TODO - can add code here to convert output to float format array
        return rtnvalue
	
	
    def selfTest(self):
        status = self.rmHandle.query('*TST?')
		# add status decode here?
        return status
    
    def trigGen(self):
        #TODO - expand this to cover all types of trig  
        self.rmHandle.write('*TRG')
        pass

    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('*RST')        
        pass

    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
        
    
if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    pm = instMgr.checkout(objName='pewmeter', interface='GPIB',addr=7,moduleSuffix='N6700B')
    pm.reset()
    print(pm.getIdn())
    
    #voltage measurement example code with slew rate of 5V/s, this means the mesusremnt should show the voltage increament
    pm.setSrcParam('voltagelevel', 2.8, 1)
    pm.setSrcParam('voltageslewimm', 5, 1)
    pm.setSrcParam('trigacqimm', '1', None)
    pm.setMeasParam('sensefunctionvoltage', 'on', 1)
    pm.setMeasParam('sensefunctioncurrent', 'on', 1)
    pm.setSrcParam('trigacqsource', 'bus', 1)
    pm.setMeasParam('sensesweeppoint', 100, 1)
    pm.setMeasParam('sensesweeptint', 0.01, 1)
    pm.setSrcParam('initacq', '1', None)
    pm.setSrcParam('outputstatus', 'on', 1)
    pm.trigGen()
    time.sleep(1)
    print(pm.getStatus())
    time.sleep(1)
    print(pm.getMeas('fetcharray', 'voltage', 1))
    
    
    # list example
    pm.setSrcParam('outputstatus', 'off', 1)
    pm.setSrcParam('voltageslewmax', 'on', 1)
#    pm.setSrcParam('voltageslewimm', 1000, 1)
    pm.setListParam('voltage', '1,2,4,5,3,1', 1)
    pm.setListParam('current', '0.01,0.01,0.1,0.1,0.01,1',1)
    pm.setListParam('dwell', '1,2,3,2,1,1', 1)
    pm.setListParam('toutbos', '0,0,0,0,0,0',1)
    pm.setListParam('touteos', '0,0,0,0,0,0',1)
    pm.setSrcParam('trigtransource', 'bus', 1)
    pm.setSrcParam('inittran', '1', None)
    pm.setSrcParam('outputstatus', 'on', 1)
    pm.trigGen()
    time.sleep(10)  
    pm.setSrcParam('outputstatus', 'off', 1)
    pass    
