# -*- coding: utf-8 -*-
"""
Created on Mon Jun 11 16:48:10 2018

@author: dkaroly
   
"""

'''
******************************************************************************
15/08/2018
Dev progress:
    
Issue: 
1. single type measurement doesn't work, it always output all measurements
    - could be the command sequence issue or 
    - incorrect commands used 
    current workaround is to select the right meas reading to output
******************************************************************************
'''

import sys
import time
import logging

idnString = 'MODEL 2400'

class Smu_2400():
    """
    Class for controlling Keithley Source Meter Model 2400. Base class for 2400
    series.
    """    

    # Numeric constants are for 2400 series. In derived classes, redefine these
    # for the particular member of the 2400 series family.
    instDict = {
        'source': {
            # param,        discrete values or range,                      SCPI cmd
            'func':         [{'v':'VOLT', 'i':'CURR'},                      ':SOUR:FUNC:MODE'],
            'vmode':        [{'fixed':'FIX', 'list':'LIST', 'sweep':'SWE'}, ':SOUR:VOLT:MODE'],
            'imode':        [{'fixed':'FIX', 'list':'LIST', 'sweep':'SWE'}, ':SOUR:CURR:MODE'],
            'vrange':       [(-210, 210),                                   ':SOUR:VOLT:RANG'],
            'irange':       [(-1.05, 1.05),                                 ':SOUR:CURR:RANG'],
            'vautorange':   [{'on':'1', 'off':'0'},                         ':SOUR:VOLT:RANG:AUTO'],
            'iautorange':   [{'on':'1', 'off':'0'},                         ':SOUR:CURR:RANG:AUTO'],
            'vlevel':       [(-210, 210),                                   'SOUR:VOLT:IMM:AMPL'],
            'ilevel':       [(-1.05, 1.05),                                 'SOUR:CURR:IMM:AMPL'], 
            'vprotect':     [(-210, 210),                                   'SOUR:VOLT:PROT'],
            'vlimit':       [(-210, 210),                                   'SENS:VOLT:DC:PROT:LEV'],
            'vtrip':        [None,                                          'SENS:VOLT:PROT:TRIP'],
            'ilimit':       [(-1.05, 1.05),                                 'SENS:CURR:DC:PROT:LEV'],
            'itrip':        [None,                                          'SENS:CURR:PROT:TRIP'],
            'delay':        [(0, 999.999),                                  ':SOUR:DEL '],
            'output':       [{'on':'1', 'off':'0'},                         ':OUTP:STAT'],
            'beeper':       [{'on':'1', 'off':'0'},                         ':SYST:BEEP:STAT'],            
            'offstate':     [{'himp':'HIMP', 'norm':'NORM', 'zero':'ZERO', 'guard':'GUAR'}, ':OUTP:SMODE']            
        },
        'measure': {
            'concurrent':   [{'on':'1', 'off':'0'},                       ':SENS:FUNC:CONC'],  
            'functions_on': [{'curr', 'volt', 'res'},                     ':SENS:FUNC:ON'],
            'functions_off':[{'curr', 'volt', 'res'},                     ':SENS:FUNC:OFF'],
            'rmode':        [{'auto':'AUTO', 'manual':'MAN'},             ':RES:MODE'],
            'format':       [{'curr', 'volt', 'res', 'time', 'stat'},     ':FORM:ELEM'],
            'vautorange':   [{'on':'1', 'off':'0'},                       ':SENS:VOLT:RANG:AUTO'],
            'iautorange':   [{'on':'1', 'off':'0'},                       ':SENS:CURR:RANG:AUTO'],
            'vlowlimit':    [(-21, 21),                                   ':SENS:VOLT:RANG:AUTO:LLIM'],
            'ilowlimit':    [(-105e-6, 105e-6),                           ':SENS:CURR:RANG:AUTO:LLIM'],
            'vrange':       [(-210, 210),                                 ':SENS:VOLT:RANG'],
            'irange':       [(-1.05, 1.05),                               ':SENS:CURR:RANG'],
            'rrange':       [(0, 2.1e8),                                  ':SENS:CURR:RANG'],
            'vmeasspeed':   [(0.01, 10),                                  ':SENS:VOLT:NPLC'],
            'imeasspeed':   [(0.01, 10),                                  ':SENS:CURR:NPLC'],
            'filtercount':  [(1, 100),                                    ':SENS:AVER:COUN'],
            'filtertype':   [{'repeat':'REP', 'moving':'MOV'},            ':SENS:AVER:TCON'],
            'filterstate':  [{'on':'1', 'off':'0'},                       ':SENS:AVER:STAT'],
            'remsense':     [{'on':'1', 'off':'0'},                       ':SYST:RSEN'],
            'autozero':     [{'on':'1', 'off':'0', 'once':'ONCE'},        ':SYST:AZER:STAT']
        },
    }
     
    def __init__(self,rmHandle ):
        """ Constructor for Smu_2400 class. 
        
        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using 
                       :meth:`pyvisa.highlevel.ResourceManager.open_resource`
        """
        
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('msaval.inst.Smu_2400')
        self.logger.info('Initializing Smu_2400 instrument')   
        
   #----------------------------------------------------------------------------    

    def source_param( self, param, val=None ):
        """
        Queries or sets parameters of the source side of the SourceMeter.
        
           Args:
                param (str): Identifies which parameter is being set. Call with                            
                val:         Value to set. Form depends on param. If val is
                             absent a query is performed.                
            Return:    
                For queries the form of the response depends upon param.
                None is returned when a value is being set.
                
            param        purpose
            ------       --------
            func:        Choose voltage or current source. 'v' or 'i'.
            vmode:       Where voltage source level comes from. 'fixed', 'list', 'sweep'.
            imode:       Where current source level comes from. 'fixed', 'list', 'sweep'.
            vrange:      Instrument chooses largest voltage range that is smaller than what you specify.
            irange:      Instrument chooses largest current range that is smaller than what you specify.
            vautorange:  Enable voltage source to autorange based on vlevel.
            iautorange:  Enable current source to autorange based on ilevel.
            vlevel:      Output voltage in voltage source mode.
            ilevel:      Output current in current source mode.
            vprotect:    V-Source and I-Source Over-voltage protection limit.
                         If specified value is between two limits SourceMeter
                         chooses the smaller limit. Do a query to be sure.
            vlimit:      Current source voltage compliance.
            vtrip:       Query only: returns True if I-Source is in voltage compliance.
            ilimit:      Voltage source current compliance.
            itrip:       Query only: returns True if V-Source is in current compliance.
            delay:       Source settling time (seconds) before measurement is taken.
            output:      Turn source output "on' or 'off'.
            beeper:      Beeper 'on' or 'off'. If on, toggling output beeps.
            offstate:    Source output state when off: 'himp', 'norm', 'zero', 'guard'.
        """
        
        if param not in self.instDict['source'].keys():
            valid = ', '.join(["'{}'".format(k) for k in self.instDict['source'].keys()])
            raise ValueError( "Invalid param '{}', options are: {}.".format( param, valid ) )    
        
        if val is None:
            # Do a GPIB query.
            rslt = self.rmHandle.query( self.instDict['source'][param][1] + '?' ).rstrip()
            
            if self.instDict['source'][param][0] == None :
                return True if rslt == '1' else False                
            elif isinstance( self.instDict['source'][param][0], dict ):
                readDict = {v:k for k,v in self.instDict['source'][param][0].items()}
                return readDict[rslt]
            else:
                return float( rslt )

        # Do a GPIB write
        if self.instDict['source'][param][0] == None:
            raise ValueError( "The parameter '{}' is read only.".format( param) )            
        elif isinstance( self.instDict['source'][param][0], dict ):
            # Expecting a string or an int.
            key = val if isinstance(val, int) else val.lower()
            if key not in self.instDict['source'][param][0].keys():
                valid = ', '.join([f"'{k.upper()}'" if isinstance(k, str) else str(k) for k in self.instDict['source'][param][0].keys()])
                raise ValueError( "Specified discrete value '{}' is not valid. Valid options are {}.".format(val, valid))
            val_str = self.instDict['source'][param][0][key]
        else:
            # Expecting a number.
            if val < self.instDict['source'][param][0][0] or val > self.instDict['source'][param][0][1]:
                raise ValueError( "Value {:G} falls outside range {:G} to {:G}.".format( val, self.instDict['source'][param][0][0], self.instDict['source'][param][0][1] ) )
            val_str = str( val )   
            
        send_str = self.instDict['source'][param][1] + ' ' + val_str
        #print(send_str)
        self.rmHandle.write( send_str )
   
    #---------------------------------------------------------------------------
    
    def meas_param( self, param, *val ):
        """
        Queries or sets parameters of the source side of the SourceMeter.
        
           Args:
                param (str): Identifies which parameter is being set. Call with                            
                val:         Value to set. Form depends on param. If val is
                             absent a query is performed.                
            Return:    
                For queries the form of the response depends upon param.
                None is returned when a value is being set.
                
            param           purpose
            ------          --------
            concurrent:     Turn 'on' or 'off' simultaneous measurements defined by 'functions_on'.
            functions_on:   Specify combination of 'VOLT', "CURR', 'RES' as multiple command line arguments.
            functions_off:  Specify combination of 'VOLT', "CURR', 'RES' as multiple command line arguments.
            rmode:          Resistance mode 'auto' or 'manual'. In 'auto' current sourced depends on range. 
            format:         Specify the set of values in the tuple returned when a measuremt is taken.
                            Names are: 'CURR', 'VOLT', 'RES', 'TIME', 'STAT'.
            vautorange:     Turn autoranging for voltage measurements 'on' or 'off'
            iautorange:     Turn autoranging for current measurements 'on' or 'off'
            vlowlimit:      Autoranging low limit for volts.
            ilowlimit:      Autoranging low limit for current.
            vmeasspeed:     Powerline cycles per integration, voltage measurements.
            imeasspeed:     Powerline cycles per integration, current measurements.
            filtercount:    Number of samples avaraged in filter.
            filtertype:     Select type of filter: 'moving' or 'repeat'. 
            filterstate:    Turns filter 'on' or 'off'.
            remsense:       Enable ('on') or disable ('off') remote sensing (4-wire).
            autozero:       'on' (every measurement), 'off', 'once' (forces an autozero).
        """    

        if param not in self.instDict['measure'].keys():
            valid = ', '.join(["'{}'".format(k) for k in self.instDict['measure'].keys()])
            raise ValueError( "Invalid param '{}', options are: {}.".format( param, valid ) )    

        expected_type = type( self.instDict['measure'][param][0] )            
 
        # Handle no val case - which indicates a query.        
        if len(val) == 0 :
            rslt = self.rmHandle.query( self.instDict['measure'][param][1] + '?' ).rstrip()
            
            if expected_type == dict:
                readDict = {v:k for k,v in self.instDict['measure'][param][0].items()}
                return readDict[rslt]
            
            elif expected_type == set:
                rslt = rslt.replace( '"', "" ).replace( ':DC', '')
                return rslt.split(',') if len(rslt) > 0 else [] # Avoids list containing a single empty string.
            
            elif expected_type == tuple:
                return float( rslt )

        # A value was provided - Format the value for a GPIB write.        
        if expected_type == set:               
            val = set( [x.lower() for x in val] )
        else:
            if len( val ) > 1:
                raise ValueError( "{} only accepts a single value, you entered '{}'".format(param , val) )
            else:
                val = val[0]
        
        if isinstance( self.instDict['measure'][param][0], dict ):
            # Expecting a string...
            if val.lower() not in self.instDict['measure'][param][0].keys():
                valid = ', '.join(["'{}'".format(k) for k in self.instDict['measure'][param][0].keys()])
                raise ValueError( "Specified discrete value '{}' is not valid. Valid options are {}.".format( val, valid ) )
                
            val_str = self.instDict['measure'][param][0][val.lower()] # dict lookup
            
        elif isinstance( self.instDict['measure'][param][0], set ):
            badin = val.difference( self.instDict['measure'][param][0] )
            if len(badin) > 0:
                msg = "Invalid function name '{}', valid options are {}.".format( ', '.join(badin), ', '.join(self.instDict['measure'][param][0] ) ) 
                raise ValueError(msg)
                
            if param == 'format':
                val_str = ', '.join(["{}".format(value.upper()) for value in val]) # convert tuple into comma separated strings.                                    
            else:
                val_str = ', '.join(["'{}'".format(value.upper()) for value in val]) # convert tuple into comma separated QUOTED strings.                                    
            
        else:
            # Expecting a number.
            if  val < self.instDict['measure'][param][0][0] or val > self.instDict['measure'][param][0][1]: 
                raise ValueError( "Value {:G} falls outside range {:G} to {:G}.".format( val, self.instDict['measure'][param][0][0], self.instDict['measure'][param][0][1] ) )
            val_str = str( val )

        if val_str[0] == ':':
            # Special case'functions_all': its SCPI syntax is weird.
            send_str = self.instDict['measure'][param][1] + val_str
        else:
            send_str = self.instDict['measure'][param][1] + ' ' + val_str
            
        #print(send_str)
        self.rmHandle.write(send_str)


    #---------------------------------------------------------------------------
    
    def meas( self, function=None ):
        """
        Performs either the specified measurement or the set of concurrent measurements
        previously defined using the meas_param( 'functions_on', ... ) method.
        
           Args:
                function (str): If None the previously defined set of functions is measured.
                                If 'volt', 'curr' or 'res', the single measurement is performed.

           Return:    
                Measured values are returned as floats.
                Multiple measurements are returned in a tuple with content as previously defined
                using the meas_param( 'format',... ) method.
                NOTE: 'format' method defines which data elements are returned, but the instrument
                       does not allow for altering their order. See manual p18-48.
                       Do a format query to obtain the true order and identity of of the data 
                       elements.                
        """        
        
        functTup = ['volt', 'curr', 'res']

        if function == None:
            send_str = ':MEAS?'
        elif function.lower() in functTup:
            self.meas_param( 'functions_on', function )
            send_str = ':MEAS:' + function.upper() + '?'             
        else:
            valid = ', '.join(["'{}'".format(k) for k in functTup])
            raise ValueError( "Invalid function '{}', options are: {}.".format( function, valid ) )    

        rslt = self.rmHandle.query(send_str).rstrip().split(',')
        rslt = [float(x) for x in rslt]
        
        if function == None:
            return rslt
        else:
            names = self.meas_param( 'format' )
            idx = names.index( function.upper() )
            return rslt[idx]
            
            

    #---------------------------------------------------------------------------
    
    def configVSrc(self, vlevel=1.8, ilimit=0.1):
        src_setup = [
                  ('func', 'V'),
                  ('vmode', 'fixed'),
                  ('vrange', vlevel+1),
                  ('vlevel', vlevel),
                  #('vprotect', 20),     # fixed to 20
                  ('irange', ilimit),
                  ('ilimit', ilimit),
                  ('delay', 0),
                 ]
        
        for param,val in src_setup:
            #print('\tParamepter ', param, '\t Value ', val )
            self.source_param( param, val )
            time.sleep(0.2)
        
    def configIMeas(self, spd=1, filtercount=10):
        IMeasetup = [
                  ('functions_on', 'curr'),
                  ('concurrent', 'off'),
                  ('iautorange', 'on'),
                  ('vautorange', 'on'),
                  ('imeasspeed', spd),
                  ('filtertype', 'repeat'),
                  ('filtercount', filtercount),
                 ]
        
        for param,val in IMeasetup:
            #print('\tParamepter ', param, '\t Value ', val )
            self.meas_param( param, val )
            time.sleep(0.2)
        
    def getIdn(self):    
        """ Queries SourceMeter and returns IDN string. """
        
        return self.rmHandle.query('*IDN?')
        
    def reset(self):
        """ Resets SourceMeter to factory defaults. """
        
        self.rmHandle.write('*RST')        
    
    def getError( self ):
        """ Queries Source-Meter error buffer and returns string. """
        
        rslt = self.rmHandle.query('SYST:ERRor?')
        return rslt.rstrip()        
    
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()       
    
if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    time.sleep(1)
    smu = instMgr.checkout(interface='GPIB',addr=26,moduleSuffix='2400')

    smu.reset()
    print(smu.getIdn())

#    smu.configVSrc()
#    smu.configIMeas()
   
    # Connect 100 Ohm load, to excerise usecases below.
    
    smu.source_param( 'beeper', 'off' ) # If on, toggling output on will beep.

    print( '\nUsecase: Force voltage, measure current, single measurements.' )
    smu.source_param( 'func', 'v' )
    smu.source_param( 'ilimit', 0.1)  # defines "real" compliance.  See p3-15
    smu.source_param( 'vlevel', 1 )
    smu.meas_param( 'concurrent', 'off' )
    smu.meas_param( 'functions_on', 'volt' )
    smu.meas_param( 'irange', 0.1 ) # set to avoid "range compliance". See p3-15
    smu.source_param( 'output','on')    
    print ( 'Voltage = {:.3f} V'.format( smu.meas('volt') ) )
    print ( 'Current = {:.3f} mA'.format ( 1e3 * smu.meas('curr') ) )   
    smu.source_param( 'output','off')
    time.sleep(1)
    
    print( '\nUsecase: Force voltage, measure current and resistance. concurrent measurements.' )
    smu.source_param( 'func', 'v' )
    smu.source_param( 'ilimit', 0.1)     # defines "real" compliance.  See p3-15
    smu.source_param( 'vlevel', 1 )
    smu.meas_param( 'concurrent', 'on' )
    smu.meas_param( 'rmode', 'manual' )
    smu.meas_param( 'functions_on', 'volt', 'curr', 'res' )
    smu.meas_param( 'format', 'volt', 'curr', 'res' )
    smu.meas_param( 'irange', 0.1 )  # set to avoid "range compliance". See p3-15 
    smu.source_param( 'output','on')    
    print( smu.meas() ) 
    smu.source_param( 'output','off')
    time.sleep(1)
    
    print( '\nUsecase: Force current, measure voltage, single measurements.' )
    smu.source_param( 'func', 'i' )
    smu.source_param( 'vlimit', 2)       # defines "real" compliance.  See p3-15
    smu.source_param( 'ilevel', 0.01 )
    smu.meas_param( 'concurrent', 'off' )
    smu.meas_param( 'functions_on', 'volt' )
    smu.meas_param( 'vrange', 2 )  # set to avoid "range compliance". See p3-15  
    smu.source_param( 'output','on')    
    print ( 'Current = {:.3f} mA'.format ( 1e3 * smu.meas('curr') ) )   
    print ( 'Voltage = {:.3f} V'.format( smu.meas('volt') ) )
    smu.source_param( 'output','off')
    time.sleep(1)

    print( '\nUsecase: Force current, measure voltage and resistance. concurrent measurements.' )
    smu.source_param( 'func', 'i' )
    smu.source_param( 'vlimit', 2)       # defines "real" compliance.  See p3-15
    smu.source_param( 'ilevel', 0.01 )
    smu.meas_param( 'concurrent', 'on' )
    smu.meas_param( 'rmode', 'manual' )
    # Format allows omitting data elements but does not re-order them! See
    # Keithley SourceMeter Manual (2400S-900-01 Rev. K / September 2011) p18-48.
    smu.meas_param( 'format', 'res', 'volt' )                                             
    smu.meas_param( 'functions_on', 'res', 'volt', 'curr' )    
    smu.meas_param( 'vrange', 2 )  # set to avoid "range compliance". See p3-15     
    smu.source_param( 'output','on')
    # Reading back the format gives actual ordering.
    print( '{} = {}'.format(  smu.meas_param('format'), smu.meas() ) )
    smu.source_param( 'output','off')
    time.sleep(1)

#    smu.close()
#    pass    
    # Expected results with 100 Ohm load:
    # Usecase: Force voltage, measure current, single measurements.
    # Voltage = 1.000 V
    # Current = 10.013 mA
    # 
    # Usecase: Force voltage, measure current and resistance. concurrent measurements.
    # [1.000066, 0.01001291, 99.87766]
    # 
    # Usecase: Force current, measure voltage, single measurements.
    # Current = 10.000 mA
    # Voltage = 0.999 V
    # 
    # Usecase: Force current, measure voltage and resistance. concurrent measurements.
    # ['VOLT', 'RES'] = [0.9985944, 99.85735]