# -*- coding: utf-8 -*-
"""
Created on Mon Jun 11 16:48:10 2018

@author: dkaroly

"""

import sys
from smu_2400 import Smu_2400
import time
import logging

idnString = 'MODEL 2460'

class Smu_2460(Smu_2400):

    instDict = {
        'source': {
            # param,          discrete values or range,                       SCPI cmd
            'func':         [{'curr': 'CURR', 'volt': 'VOLT'},               ':SOUR:FUNC:MODE'],
            'vrange':       [(-100.0, 100.0),                                ':SOUR:VOLT:RANG'],
            'irange':       [(-7.0, 7.0),                                    ':SOUR:CURR:RANG'],
            'vautorange':   [{'on': '1', 'off': '0'},                        ':SOUR:VOLT:RANG:AUTO'],
            'iautorange':   [{'on': '1', 'off': '0'},                        ':SOUR:CURR:RANG:AUTO'],
            'vlevel':       [(-105.0, 105.0),                                'SOUR:VOLT:IMM:AMPL'],
            'ilevel':       [(-7.35, 7.35),                                  'SOUR:CURR:IMM:AMPL'],
            'vprotect':     [{2: 'PROT2', 5: 'PROT5', 10: 'PROT10', 20: 'PROT20',
                              40: 'PROT40', 60: 'PROT60', 80: 'PROT80',
                              'none': 'NONE'},                               'SOUR:VOLT:PROT'],
            'vlimit':       [(0.2, 105),                                     'SOUR:CURR:VLIM'],
            'vtrip':        [None,                                           'SOUR:CURR:VLIM:TRIP'],
            'ilimit':       [(0., 7.0),                                      'SOUR:VOLT:ILIM'],
            'itrip':        [None,                                           'SOUR:VOLT:ILIM:TRIP'],
            'vdelay':       [(0, 10000),                                     ':SOUR:VOLT:DEL'],
            'idelay':       [(0, 10000),                                     ':SOUR:CURR:DEL'],
            'output':       [{'on': '1', 'off': '0'},                        ':OUTP:STAT'],
            'voffstate':    [{'himp': 'HIMP', 'norm': 'NORM', 'zero': 'ZERO',
                              'guard': 'GUAR'},                              ':OUTP:VOLT:SMODE'],
            'ioffstate':    [{'himp': 'HIMP', 'norm': 'NORM', 'zero': 'ZERO',
                           'guard': 'GUAR'},                                 ':OUTP:CURR:SMODE']
        },
        'measure': {
            'func':          [{'curr', 'res', 'volt'},                        ':SENS:FUNC'],
            'vautorange':    [{'on': '1', 'off': '0'},                        ':SENS:VOLT:RANG:AUTO'],
            'iautorange':    [{'on': '1', 'off': '0'},                        ':SENS:CURR:RANG:AUTO'],
            'rautorange':    [{'on': '1', 'off': '0'},                        ':SENS:RES:RANG:AUTO'],
            'vlowlimit':     [(200e-3, 20.0),                                 ':SENS:VOLT:RANG:AUTO:LLIM'],
            'ilowlimit':     [(1e-6, 5.0),                                    ':SENS:CURR:RANG:AUTO:LLIM'],
            'rlowlimit':     [(2.0, 20e6),                                    ':SENS:RES:RANG:AUTO:LLIM'],
            'vrange':        [(0.2, 100.0),                                   ':SENS:VOLT:RANG'],
            'irange':        [(1e-6, 7.0),                                    ':SENS:CURR:RANG'],
            'rrange':        [(2, 200e6),                                     ':SENS:RES:RANG'],
            'vmeasspeed':    [(0.01, 10),                                     ':SENS:VOLT:NPLC'],
            'imeasspeed':    [(0.01, 10),                                     ':SENS:CURR:NPLC'],
            'rmeasspeed':    [(0.01, 10),                                     ':SENS:RES:NPLC'],
            'vfiltercount':  [(1, 100),                                       ':SENS:VOLT:AVER:COUN'],
            'vfiltertype':   [{'repeat': 'REP', 'moving': 'MOV'},             ':SENS:VOLT:AVER:TCON'],
            'vfilterstate':  [{'on': '1', 'off': '0'},                        ':SENS:VOLT:AVER:STAT'],
            'ifiltercount':  [(1, 100),                                       ':SENS:CURR:AVER:COUN'],
            'ifiltertype':   [{'repeat': 'REP', 'moving': 'MOV'},             ':SENS:CURR:AVER:TCON'],
            'ifilterstate':  [{'on': '1', 'off': '0'},                        ':SENS:CURR:AVER:STAT'],
            'rfiltercount':  [(1, 100),                                       ':SENS:RES:AVER:COUN'],
            'rfiltertype':   [{'repeat': 'REP', 'moving': 'MOV'},             ':SENS:RES:AVER:TCON'],
            'rfilterstate':  [{'on': '1', 'off': '0'},                        ':SENS:RES:AVER:STAT'],
            'vremsense':     [{'on': '1', 'off': '0'},                        ':SENS:VOLT:RSEN'],
            'iremsense':     [{'on': '1', 'off': '0'},                        ':SENS:CURR:RSEN'],
            'rremsense':     [{'on': '1', 'off': '0'},                        ':SENS:RES:RSEN'],
            'vautozero':     [{'on': '1', 'off': '0', 'once': 'ONCE'},        ':SENS:VOLT:AZER:STAT'],
            'iautozero':     [{'on': '1', 'off': '0', 'once': 'ONCE'},        ':SENS:CURR:AZER:STAT'],
            'rautozero':     [{'on': '1', 'off': '0', 'once': 'ONCE'},        ':SENS:RES:AZER:STAT'],
        },
    }
     
    def __init__(self, rmHandle):
        super(Smu_2460, self).__init__(rmHandle)
        self.logger.info('Initializing Smu_2460 instrument')

    # ---------------------------------------------------------------------------

    # Override the inherited 2400 meas method - 2460 works differently...
    def meas(self, function=None):
        """
        Performs either the specified measurement or the set of concurrent measurements
        previously defined using the meas_param( 'functions_on', ... ) method.

           Args:
                function (str): If None the previously defined set of functions is measured.
                                If 'volt', 'curr' or 'res', the single measurement is performed.

           Return:
                Measured values are returned as floats.
                Multiple measurements are returned in a tuple with content as previously defined
                using the meas_param( 'format',... ) method.
                NOTE: 'format' method defines which data elements are returned, but the instrument
                       does not allow for altering their order. See manual p18-48.
                       Do a format query to obtain the true order and identity of of the data
                       elements.
        """

        functTup = ['volt', 'curr', 'res']

        if function is None:
            send_str = ':MEAS?'
        elif function.lower() in functTup:
            self.meas_param('func', function)
            send_str = ':MEAS:' + function.upper() + '?'
        else:
            valid = ', '.join(["'{}'".format(k) for k in functTup])
            raise ValueError("Invalid function '{}', options are: {}.".format(function, valid))

        rslt = self.rmHandle.query(send_str).rstrip()

        return float(rslt)


if __name__ == "__main__":
    import os
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    smu = instMgr.checkout(interface='GPIB', addr=19, moduleSuffix='2460')

    smu.reset()
    print(smu.getIdn())

#    smu.configVSrc()
#    smu.configIMeas()

    if True:
        # Connect 100 Ohm load, to excerise usecases below.

        print('\nUsecase: Force voltage, measure current. Calculate R.')
        smu.source_param('func', 'volt')
        smu.source_param('ilimit', 0.1)  # defines "real" compliance.
        smu.source_param('vlevel', 1)
        smu.meas_param('irange', 0.1)    # set to avoid "range compliance".
        smu.source_param('output', 'on')
        time.sleep(0.5)
        V = smu.meas('volt')
        print('Voltage = {:.3f} V'.format(V))
        I = smu.meas('curr')
        print('Current = {:.3f} mA'.format(1e3 * I))
        R = V/I
        print(f"R = {R:.3f} Ohms")
        smu.source_param('output', 'off')

        print('\nUsecase: Force current, measure voltage. Calculate R.')
        smu.source_param('func', 'curr')
        smu.source_param('vlimit', 2)       # defines "real" compliance.
        smu.source_param('ilevel', 0.010)
        smu.meas_param('vrange', 2)         # set to avoid "range compliance".
        smu.source_param('output', 'on')
        time.sleep(0.5)
        I = smu.meas('curr')
        print('Current = {:.3f} mA'.format(1e3 * I))
        V = smu.meas('volt')
        print('Voltage = {:.3f} V'.format(V))
        R = V/I
        print(f"R = {R:.3f} Ohms")
        smu.source_param('output', 'off')

        print('\nUsecase: Ohmeter')
        smu.source_param('func', 'curr')
        smu.source_param('vlimit', 2)       # defines "real" compliance.
        smu.source_param('ilevel', 0.010)
        smu.meas_param('vrange', 2)         # set to avoid "range compliance".
        smu.source_param('output', 'on')
        time.sleep(0.5)
        I = smu.meas('curr')
        print('Current = {:.3f} mA'.format(1e3 * I))
        V = smu.meas('volt')
        print('Voltage = {:.3f} V'.format(V))
        R = smu.meas('res')
        print(f"R = {R:.3f} Ohms")
        smu.source_param('output', 'off')
