# -*- coding: utf-8 -*-
"""
@author: dkaroly
"""

import sys
import math

idnString = 'PBZ20-20A'

# TODO: Are there SCPI cmds for selecting what is displayed on the the LCD display ?

class Wamp_PBZ2020:
    """Class for controlling Kikusui PBZ20-20A bipolar power supply / waveform amplifier."""

    def __init__(self, rmHandle):
        """ Constructs an object of class Supply_PBZ2020.

        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using
                       :meth:'pyvisa.highlevel.ResourceManager.open_resource'.
        """

        self.rmHandle = rmHandle

        # Define these as a attributes because several methods use them.

        self._meas_legal_items = {
            'VOLTS_DC': 'VOLT:DC',
            'VOLTS_RMS': 'VOLT:AC',
            'VOLTS_PK_MIN': 'VOLT:MIN',
            'VOLTS_PK_MAX': 'VOLT:MAX',
            'CURRENT_DC': 'CURR:DC',
            'CURRENT_RMS': 'CURR:AC',
            'CURRENT_PK_MIN': 'CURR:MIN',
            'CURRENT_PK_MAX': 'CURR:MAX'
        }

        self._legal_on_off = {'ON': 1, 'OFF': 0}
        self._legal_on_off_rev = dict((v, k) for k, v in self._legal_on_off.items())

        self.status_clear()      # Clears all previous errors that might block command execution.

        self.rmHandle.write(f"STAT:OPER:ENAB {0x7FFF}")
        self.rmHandle.write(f"STAT:QUES:ENAB {0x7FFF}")

    # ---------------------------------------------------------------------------
    # Added these two functions to work around fact that Pyro server is not allowing
    # access to property rmHandle, which is desired as work around to hack other features.

    def write_raw(self, cmdstr):
        """Send cmdstr argument directly to instrument."""
        self.rmHandle.write(cmdstr)

    def query_raw(self, cmdstr):
        """Perform query defined by cmdstr, return string. cmdstr must end with '?'."""

        if cmdstr[-1] != '?':
            raise ValueError(f"Bad query '{cmdstr}' missing '?'.")

        return self.rmHandle.query(cmdstr).strip()

    # ---------------------------------------------------------------------------

    def reset(self):
        """ Resets the Power Supply to factory defaults, turns output off.
            NOTE: Sets status enable registers to 0x7FFF.
        """

        self.rmHandle.write('*RST')

        # Enable all status bits ... Kikusui defaults for these regs is 0.
        self.rmHandle.write(f"STAT:OPER:ENAB {0x7FFF}")
        self.rmHandle.write(f"STAT:QUES:ENAB {0x7FFF}")

    # ---------------------------------------------------------------------------

    def value(self, voltage=None, ilimit=None):
        """ Queries or sets both the voltage output level and the current
            compliance limit for operation in Constant Voltage (CV) mode.

            This method provides same interface as Instek PSM6003 and PSM2010,
            and with EA PSI9040T.

            Args:
                voltage (None or numeric) : Voltage to output in Volts.
                ilimit ( None or numeric) : Current limit to set in Amps.

            Return:
                If both voltage and ilimit are None, then the Power Supply is
                queried and the present voltage and current settings are
                returned as a list of two float values.

            NOTE:
                Voltage and ilimit may be both set together. Specifying a
                voltage value with ilimit=None retains the existing ilimit.
                Specifying voltage=None with a ilimit value retains the
                existing voltage level.
        """

        if self.rmHandle.query('FUNC:MODE?').strip() != 'CV':
            raise ValueError(f"Supply is not configured for CV (constant voltage) mode!")

        # Emulate behavior Instek value method:
        # If both are None, return present settings as a list.
        # Set the parameter(s) that is (are) not None.

        v_setting = self.dc_source(voltage)            # If voltage is None, returns present setting as a float.
        i_response = self.prot_curr(pos_level=ilimit)  # If ilimit is None, returns dict of all related settings.

        if voltage is None and ilimit is None:
            return [v_setting, i_response['pos_level']]

    def config(self, polarity=None, mode=None, volt_resp_time=None, curr_resp_time=None, sensing=None):
        """Queries or sets parameters on the config menu, first page.

        Note that if no arguments are supplied, the instrument is queried and a dictionary is
        returned showing all the present settings. The dictionary key/value pairs correspond to the
        parameters of this method.

        Args:
            polarity: cannot be changed while output is ON.
                None: no effect unless all args are None, see above.
               'BIP': bipolar operation (default)
               'UNIP' : unipolar operation
            mode: cannot be changed while output is ON.
                None: no effect unless all args are None, see above.
                'CV': supply regulates a constant output voltage. (default)
                'CC': supply regulates a constant output current
            volt_resp_time: rise/fall time for rated load in CV mode, in seconds.
                None: no effect unless all args are None, see above.
                fixed values: 3.5e-6 (default), 10e-6, 35e-6, 100e-6
            curr_resp_time: rise/fall time for rated load  in CC mode, in seconds.
                None: no effect unless all args are None, see above.
                fixed values:     35e-6 (default), 100e-6, 350e-6, 1e-3
            sensing: Enables remote sense input on rear panel. Cannot be changed while output is ON.
                None: no effect unless all args are None, see above.
                'ON': enabled
                'OFF': disabled (default)

        NOTE: To achieve peak transient current output (120A), configure as follows
        (from the Kikusui reference card):
            Turn output OFF
            polarity = BIP or UNIP,
            mode='CV'
            curr_resp_time = 1e-3
            dc_source(0)
            Turn output ON
            Program the desired output voltage ( BOOM! )
        """

        legal_polarities = ('BIP', 'UNIP')
        legal_modes = ('CC', 'CV')
        legal_resp_volt = (3.5e-6, 10e-6, 35e-6, 100e-6)
        legal_resp_curr = (35e-6, 100e-6, 350e-6, 1e-3)

        if all(v is None for v in {polarity, mode, volt_resp_time, curr_resp_time, sensing}):
            return_val = dict()
            return_val.update(polarity=self.rmHandle.query('FUNC:POL?').strip())
            return_val.update(mode=self.rmHandle.query('FUNC:MODE?').strip())
            return_val.update(volt_resp_time=float(self.rmHandle.query(f"VOLT:RESP?")))
            return_val.update(curr_resp_time=float(self.rmHandle.query(f"CURR:RESP?")))
            tmp = int(self.rmHandle.query('SYST:CONF:RSEN?'))
            return_val.update(sensing=self._legal_on_off_rev[tmp])
            return return_val

        output_state = self.output()

        # Check all before writing anything.
        if polarity is not None:
            if output_state == 'ON':
                raise ValueError(f"Changing output polarity is not allowed while output is ON.")
            if polarity.upper() not in legal_polarities:
                msg = ", ".join([f"'{x}'" for x in legal_polarities])
                raise ValueError(f"Bad polarity '{polarity}', should be one of: {msg}.")

        if mode is not None:
            if output_state == 'ON':
                raise ValueError(f"Changing output mode is not allowed while output is ON.")
            if mode.upper() not in legal_modes:
                msg = ", ".join([f"'{x}'" for x in legal_modes])
                raise ValueError(f"Bad mode '{mode}', should be one of: {msg}.")

        if volt_resp_time is not None:
            # If instrument receives a non spec time, setting doesn't change or generate an error!
            # This picks standard value if request is within 0.1% of one of the standard values.
            tmp = [t for t in legal_resp_volt if math.isclose(volt_resp_time, t, rel_tol=0.001)]
            if len(tmp) == 0:
                msg = ", ".join([f"{v:4.2g}" for v in legal_resp_volt])
                raise ValueError(f"Bad voltage_response_time {volt_resp_time:4.2e}, should be one of {msg}.")
            volt_resp_time = tmp[0]

        if curr_resp_time is not None:
            # If instrument receives a non spec time, setting doesn't change or generate an error!
            # This picks standard value if request is within 0.1% of one of the standard values.
            tmp = [t for t in legal_resp_curr if math.isclose(curr_resp_time, t, rel_tol=0.001)]
            if len(tmp) == 0:
                msg = ", ".join([f"{v:4.2g}" for v in legal_resp_curr])
                raise ValueError(f"Bad current_response_time {curr_resp_time:4.2e}, should be one of {msg}.")
            curr_resp_time = tmp[0]

        if sensing is not None:
            if output_state == 'ON':
                raise ValueError(f"Changing sensing is not allowed while output is ON.")
            if sensing not in self._legal_on_off:
                msg = ", ".join([f"'{k}'" for k in self._legal_on_off])
                raise ValueError(f"Bad sensing {sensing}, should be one of {msg}.")

        # Everything is now checked - write to instrument:

        if polarity is not None:
            self.rmHandle.write(f"FUNC:POL {polarity.upper()}")

        if mode is not None:
            self.rmHandle.write(f"FUNC:MODE {mode.upper()}")

        if volt_resp_time is not None:
            self.rmHandle.write(f"VOLT:RESP {volt_resp_time}")

        if curr_resp_time is not None:
            self.rmHandle.write(f"CURR:RESP {curr_resp_time}")

        if sensing is not None:
            self.rmHandle.write(f"SYST:CONF:RSEN {sensing}")
    # ---------------------------------------------------------------------------

    def signal_source(self, source=None, ext_terminal=None):
        """Defines where input to the waveform amplifier comes from. See Users Manual page 36
        Circuit Configuration Diagram, and page 54 Using External Control Signals.

        Note that if no arguments are supplied, the instrument is queried and a dictionary is
        returned showing all the present settings. The dictionary key/value pairs correspond to the
        parameters of this method.

        Args:
            source: cannot be changed while output is ON.
                'INT': Use only the internal DC and AC sources.
                'EXT': Enables external inputs as selected by ext_terminal.
                'BOTH': Signal is the sum of internal and external sources.
            ext_terminal: cannot be changed while output is ON.
                'BNC': Ext AC signal in from BNC connector EXT SIG IN on front panel.
                'J1': Control DC ouptut (V or I_) using voltage input from rear panel
                'BOTH': Control using both of the above.
        """
        legal_sources = ('INT', 'EXT', 'BOTH')
        legal_terminals = ('BNC', 'J1', 'BOTH')

        if all(v is None for v in {source, ext_terminal}):
            return_val = dict()
            return_val.update(source=self.rmHandle.query('FUNC:SOUR?').strip())
            return_val.update(ext_terminal=self.rmHandle.query('FUNC:EXT:TERM?').strip())
            return return_val

        output_state = self.output()
        if output_state == 'ON':
            raise ValueError(f"Changing signal source or ext_terminal is not allowed while output is ON.")

        # Check both before writing anything.
        if source is not None and source.upper() not in legal_sources:
            msg = ", ".join([f"'{x}'" for x in legal_sources])
            raise ValueError(f"Bad source '{source}', should be one of: {msg}.")

        if ext_terminal is not None:
            if ext_terminal.upper() not in legal_terminals:
                msg = ", ".join([f"'{x}'" for x in legal_terminals])
                raise ValueError(f"Bad ext_terminal '{ext_terminal}', should be one of: {msg}.")

        if source is not None:
            self.rmHandle.write(f"FUNC:SOUR {source.upper()}")
        if ext_terminal is not None:
            self.rmHandle.write(f"FUNC:EXT:TERM {ext_terminal.upper()}")

    # ---------------------------------------------------------------------------

    def ext_source_gain(self, gain=None):
        """When using external signal source, configure the gain for the signal path.

        See Users Manual page 57. Note this method applies the gain to which ever operating
        mode is presently in effect ('CV' or 'CC'). Although the instrument provides separate SCPI
        commands for voltage and current gain, writing to the one not presently in effect does cause
        an error in the instrument.

        Note that if no argument is supplied, the gain is returned as a floating point number.

        Args:
            gain: CV gain is -20 to +20V/V. CC gain is -20A/V to +20 A/V. Negative gain is signal inversion.
        """

        source = self.signal_source()['source']
        if source == 'INT':
            raise ValueError(f"Before reading or setting the gain, set signal_source to 'EXT' or 'BOTH'. "
                             f"Presently source is '{source}'.")

        mode = self.config()['mode']
        if gain is None:
            if mode == 'CV':
                return float(self.rmHandle.query('FUNC:EXT:VOLT:GAIN?').strip())
            else:
                return float(self.rmHandle.query('FUNC:EXT:CURR:GAIN?').strip())

        units = {'CV': 'V/V', 'CC': 'A/V'}
        if gain is not None and (gain < -20.0 or gain > 20.0):
            raise ValueError(f"Bad gain {gain}, should be -20.0 to 20.0 {units[mode]}].")

        if gain is not None:
            if mode == 'CV':
                self.rmHandle.write(f"FUNC:EXT:VOLT:GAIN {gain}")
            else:
                self.rmHandle.write(f"FUNC:EXT:CURR:GAIN {gain}")

    # ---------------------------------------------------------------------------

    def dc_source(self, value=None):
        """Queries or sets parameters the DC source value voltage or current depending on present
        mode of operation.

        Note that if no argument is supplied, the level is returned as a floating point number of
        Volts or Amps.

        Args:
            value: Can only be applied if signal source is 'INT' or 'BOTH'.
                floating point number of volts if operating in CV mode.
                floating point number of amps if operating in CC mode.
        """

        source = self.signal_source()['source']
        if source not in ('INT', 'BOTH'):
            raise ValueError(f"Before reading or setting the source value, set signal source to 'INT' or 'BOTH'. "
                             f"Presently source is '{source}'.")

        tmp = self.config()
        mode, polarity = [tmp[k] for k in ('mode', 'polarity')]

        cmd = {'CV': 'VOLT', 'CC': 'CURR'}

        if value is None:
            return float(self.rmHandle.query(cmd[mode] + '?'))

        if mode == 'CV' and polarity == 'UNIP':
            limit_low = 0
            text = 'for CV UNIP operation'
        else:
            limit_low = -21
            text = ''

        units = {'CV': 'Volts', 'CC': 'Amps'}

        if value is not None and (value < limit_low or value > 21):
            raise ValueError(f"Bad value {value} {text}, should be {limit_low} to 21 {units[mode]}.")

        self.rmHandle.write(f"{cmd[mode]} {value}")

    # ---------------------------------------------------------------------------

    # TODO: Sweep functionality
    # TODO: Warn on combined effect of AC + DC on amplitude ranges.

    def ac_source(self, on_off=None, shape=None, freq_hz=None, phase_enb=None, angle=None, duty=None, amplitude_pkpk=None):
        """Queries or sets many of the parameters on the AC menu. Sweep not supported.

        Note that if no arguments are supplied, the instrument is queried and a dictionary is
        returned showing all the present settings. The dictionary key/value pairs correspond to the
        parameters of this method.

        Args:
            on_off:
             'ON': AC signal on.
             'OFF': AC signal off.
            shape:
                'SIN': sinusoidal waveform. Args phase_enb and angle apply only to this choice.
                'SQU': square wave. Arg duty cycle only applies to this choice.
                'TRI': trangle waveform.
            freq_hz: The frequency in Hz of the AC waveform.
            phase_enb: True: means starting phase of AC signal is controled as per angle Arg.
                       False: starting phase is unspecified.
            duty:   Only applicable SQU waveform.
                Floating point number with allowable ranges and resolution depending on signal freq.
            amplitude_pkpk: floating point number, range depends on operating mode and polarity.
                -42 to 42 Volts(CV) or Amps(CC) in BIP
                -21 to 21 Volts(CV) in UNIP
                -42 to 42 Amps(CC) in UNIP
        """

        legal_shapes = ['SIN', 'SQU', 'TRI']

        source = self.signal_source()['source']
        if source not in ('INT', 'BOTH'):
            raise ValueError(f"Before reading or setting the source value, set signal_source to 'INT' or 'BOTH'. "
                             f"Presently source is '{source}'.")

        # TODO: Is there a way of determining which user shapes have been defined?
        # for i in range(1, 17):
        #     legal_shapes.append(f"USER{i}")

        tmp = self.config()
        mode, polarity = [tmp[k] for k in ('mode', 'polarity')]
        amplitude_param = {'CV': 'VOLT', 'CC': 'CURR'}

        if all(v is None for v in {on_off, shape, freq_hz, phase_enb, angle, duty, amplitude_pkpk}):
            return_val = dict()
            tmp = int(self.rmHandle.query(f"AC:STAT?").strip())
            return_val.update(on_off=self._legal_on_off_rev[tmp])
            return_val.update(shape=self.rmHandle.query(f"FUNC?").strip())
            return_val.update(freq_hz=float(self.rmHandle.query(f"FREQ?")))
            angle, phase_enb = self.rmHandle.query(f"PHAS?").strip().split(',')
            return_val.update(angle=float(angle))
            return_val.update(phase_enb=self._legal_on_off_rev[int(phase_enb)])
            return_val.update(duty=float(self.rmHandle.query(f"SQU:DCYC?")))
            return_val.update(amplitude_pkpk=float(self.rmHandle.query(f"{amplitude_param[mode]}:AC?")))
            return return_val

        # Check all of the inputs before writing anything - all good or nothing happens.

        if on_off is not None and on_off.upper() not in self._legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self._legal_on_off])
            raise ValueError(f"Bad on_off '{on_off}', should be one of: {msg}")

        if shape is not None and shape.upper() not in legal_shapes:
            msg = ", ".join([f"'{x}'" for x in legal_shapes])
            raise ValueError(f"Bad shape '{shape}', should be one of: {msg}")

        if freq_hz is not None and (freq_hz < 1e-2 or freq_hz > 1.05e5):
            raise ValueError(f"Bad freq_hz {freq_hz}, should be 1e-2 to 1.05e5 Hz.")

        if phase_enb is not None and phase_enb.upper() not in self._legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self._legal_on_off])
            raise ValueError(f"Bad phase_enb '{phase_enb}', should be one of: {msg}")

        if angle is not None and (angle < 0 or angle > 359):
            raise ValueError(f"Bad angle {angle}, should be 0 to 359 degrees.")

        if duty is not None:
            # Prevent error that would be caused by attempting to set duty for non-SQU waveform.
            shape_state = shape
            if shape is None:
                shape_state = self.rmHandle.query(f"FUNC?").strip()

            if shape_state != 'SQU':
                raise ValueError(f"Cannot set duty cycle for shape '{shape_state}'.")

            # Duty cycle limits depend on freq.
            freq_state = freq_hz
            if freq_state is None:
                freq_state = float(self.rmHandle.query(f"FREQ?"))

            fixed = False
            if freq_state < 100:
                duty_min, duty_max, duty_res = [0.1, 99.9, 0.1]
            elif freq_state < 1000:
                duty_min, duty_max, duty_res = [1.0, 99.0, 1.0]
            elif freq_state < 10000:
                duty_min, duty_max, duty_res = [10.0, 90.0, 10.0]
            else:
                duty_min, duty_max, duty_res = [50.0, 50.0, 1.0]
                fixed = True

            if duty < duty_min or duty > duty_max:
                if not fixed:
                    raise ValueError(
                        f"Bad duty cycle {duty} for freq {freq_state:.3g} Hz, should be {duty_min:3.1f} to {duty_max:3.1f} percent. Resolution {duty_res}%")
                else:
                    raise ValueError(
                        f"Bad duty cycle {duty} for freq {freq_state:.3g} Hertz, for >= 10kHz must use 50% duty cycle.")

        # Amplitude ranges depend on mode and polarity.
        if mode == 'CV' and polarity == 'UNIP':
            ampl_min, ampl_max = -21.0, 21.0
        else:
            ampl_min, ampl_max = -42.0, 42.0

        units = {'CV': 'VoltsPkPk', 'CC': 'AmpsPkPk'}

        if amplitude_pkpk is not None and (amplitude_pkpk < ampl_min or amplitude_pkpk > ampl_max):
            raise ValueError(f"Bad amplitude_pkpk {amplitude_pkpk} for mode '{mode}', polarity '{polarity}', should be {ampl_min} to {ampl_max} {units[mode]}")

        # End of checks - start writing to instrument.

        if on_off is not None:
            self.rmHandle.write(f"AC:STAT {on_off.upper()}")

        if shape is not None:
            self.rmHandle.write(f"FUNC {shape.upper()}")

        if freq_hz is not None:
            self.rmHandle.write(f"FREQ {freq_hz}")

        # Instrument bundles angle and phase_enb into the same SCPI command!
        tmp = [v is not None for v in (angle, phase_enb)]
        if any(tmp):   # Eliminates [F, F] which is no changes.
            if all(tmp):  # Handles change both
                self.rmHandle.write(f"PHASE {angle}, {phase_enb}")
            else:
                existing_angle, existing_phase_enb = self.rmHandle.query(f"PHAS?").strip().split(',')
                if tmp == [False, True]:
                    self.rmHandle.write(f"PHAS {existing_angle}, {phase_enb}")
                else:
                    self.rmHandle.write(f"PHASE {angle}, {existing_phase_enb}")

        if duty is not None:
            self.rmHandle.write(f"SQU:DCYC {duty}")

        # SCPI command used depends on output mode: CV or CC.
        if amplitude_pkpk is not None:
            self.rmHandle.write(f"{amplitude_param[mode]}:AC {amplitude_pkpk}")

    # ---------------------------------------------------------------------------
    # TODO: Meas trigger features.

    def meas_config(self, function=None, aperture_sec=None):
        """Configure which measurement function will be performed and displayed on the LCD
        when triggered either by AUTO (default) or INT or EXT source (source selection not
        not implemented in driver).

        NOTE: Invoking the meas(item) method also changes what is displayed on the LCD.

        Args:
            function:
                'AC': AC RMS (AC coupling).
                'DC': direct current.
                'DCAC": RMS of both = SQRT(DC^2 + AC^2)
                'PEAK': Maximum and Minimum.
            aperture_sec: measurement time. 0.1e-3 to 3600 seconds.
        """

        legal_functions = ('DC', 'AC', 'DCAC', 'PEAK')

        if all(v is None for v in {function, aperture_sec}):
            return_val = dict()
            return_val.update(function=self.rmHandle.query(f"SENS:FUNC?").strip())
            return_val.update(aperture_sec=float((self.rmHandle.query(f"SENS:APER?").strip())))
            # return_val.update(trigger_source=self.rmHandle.query(f"SENS:TRIG:SOUR?").strip())
            return return_val

        if function is not None and function.upper() not in legal_functions:
            msg = ", ".join([f"'{x}'" for x in legal_functions])
            raise ValueError(f"Bad function {function}, should be one of: {msg}")

        if aperture_sec is not None and (aperture_sec < 1e-4 or aperture_sec > 3600):
            raise ValueError(f"Bad aperture_sec {aperture_sec}, should be 1e-4 to 3600 sec.")

        if function is not None:
            self.rmHandle.write(f"SENS:FUNC {function.upper()}")

        if aperture_sec is not None:
            self.rmHandle.write(f"SENS:APER {aperture_sec}")

    # ---------------------------------------------------------------------------

    def meas_fetch(self, item=None):
        """Fetches already measured data without initiating a new measurement

        Args:
            item:
                'VOLTS_DC': DC component of voltage across the load.
                'VOLTS_RMS': RMS value of waveform voltage across the load
                            = SQRT(Vdc^2 + ACrms^2)
                'VOLTS_PK_MIN': the lowest excursion of the voltage waveform across the load.
                'VOLTS_PK_MAX': the highest excursion of the voltage waveform across the load.
                'CURRENT_DC': DC component of current through the load.
                'CURRENT_RMS': RMS value of current through the load
                              = SQRT(Idc^2 + Iacrms^2)
                'CURRENT_PK_MIN': the lowest excursion of the current through the load.
                'CURRENT_PK_MAX': the highest excursion of the current through the load.
        """

        # TODO: Protect against measuring parameters that are not turned on.

        if item not in self._meas_legal_items:
            msg = ", ".join([f"'{x}'" for x in self._meas_legal_items])
            raise ValueError(f"Bad item '{item}', should be one of: {msg}.")

        result = self.rmHandle.query(f"FETC:{self._meas_legal_items[item]}?")
        return float(result)

    # ---------------------------------------------------------------------------

    def meas(self, item=None):
        """Perform the specified measurement and return the result.

        Args:
            item:
                'VOLTS_DC': DC component of voltage across the load.
                'VOLTS_RMS': RMS value of waveform voltage across the load
                            = SQRT(Vdc^2 + ACrms^2)
                'VOLT_PK_MIN': the lowest excursion of the voltage waveform across the load.
                'VOLT_PK_MAX': the highest excursion of the voltage waveform across the load.
                'CURRENT_DC': DC component of current through the load.
                'CURRENT_RMS': RMS value of current through the load
                              = SQRT(Idc^2 + Iacrms^2)
                'CURRENT_PK_MIN': the lowest excursion of the current through the load.
                'CURRENT_PK_MAX': the highest excursion of the current through the load.
        """

        if item not in self._meas_legal_items:
            msg = ", ".join([f"'{x}'" for x in self._meas_legal_items])
            raise ValueError(f"Bad item '{item}', should be one of: {msg}.")

        result = self.rmHandle.query(f"MEAS:{self._meas_legal_items[item]}?")
        return float(result)

    # ---------------------------------------------------------------------------

    def state(self, on_off=None):
        """Alternate method to control output, Instek driver has state method."""

        return self.output(on_off)

    def output(self, on_off=None):
        """
        Queries or writes the state of the Power Supply output.

        Args:
            on_off (str):
                None   - Queries instrument, returns one of the following strings:
                'ON'   - Power Supply is connected to the load.
                'OFF'  - Power Supply is DISconnected to the load.

           Args are not case sensitive.
           Return values are always case shown above.
        """
        if on_off is None:
            return self._legal_on_off_rev[int(self.rmHandle.query('OUTP:STAT?').strip())]

        if on_off.upper() not in self._legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self._legal_on_off])
            raise ValueError(f"Bad on_off '{on_off}', should be one of: {msg}")

        self.rmHandle.write(f"OUTP:STAT {on_off.upper()}")

    # ---------------------------------------------------------------------------

    def prot_curr(self, prot_mode=None, pos_level=None, neg_level=None):
        """ Define current protection mode and levels.

        prot_mode:
            'LIM': Current excursions will be limited to the values specified.
            'OCP': A current excursion reaching the one of the specified values will cause
                   either the output to be disabled or the power switch to turn off the
                   entire PBZ20-20. The choice is set by the method prot_ocp_ovp_action.
        pos_level: The maximum current in the + direction (out the + terminal).
        neg_level: The maximum current - direction (into the + terminal).
        """
        legal_prot_modes = {'LIMIT': 'LIM', 'OCP': 'TRIP'}
        legal_prot_modes_rev = dict((v, k) for k, v in legal_prot_modes.items())

        if all(v is None for v in {prot_mode, pos_level, neg_level}):
            return_val = dict()
            prot_mode_state = self.rmHandle.query('CURR:PROT:STAT?').strip()
            if prot_mode_state not in legal_prot_modes_rev:
                raise RuntimeError(f"Unknown prot_mode_state '{prot_mode_state}' returned from instrument.")
            return_val.update(pmode=legal_prot_modes_rev[prot_mode_state])
            if prot_mode_state == 'TRIP':
                return_val.update(pos_level=float(self.rmHandle.query('CURR:PROT:OVER?').strip()))
                return_val.update(neg_level=float(self.rmHandle.query('CURR:PROT:UND?').strip()))
            else:
                return_val.update(pos_level=float(self.rmHandle.query('CURR:LIM:UPP?').strip()))
                return_val.update(neg_level=float(self.rmHandle.query('CURR:LIM:LOW?').strip()))
            return return_val

        # Check all inputs, apply only if all good.
        if prot_mode is None:
            # Get present prot_mode, because SCPI cmd for setting levels changes depending on mode.
            prot_mode_state = self.rmHandle.query('CURR:PROT:STAT?').strip()
        elif prot_mode.upper() not in legal_prot_modes:
            msg = ", ".join([f"'{x}'" for x in legal_prot_modes])
            raise ValueError(f"Bad prot_mode '{prot_mode}', should be one of {msg}.")
        else:
            prot_mode_state = legal_prot_modes[prot_mode.upper()]

        # TODO: Do level ranges depend on output mode ?

        if pos_level is not None and (pos_level < 0.2 or pos_level > 22.0):
            raise ValueError(f"Bad level_pos {pos_level}, should be 0.2 to 22.0 A.")

        if neg_level is not None and (neg_level < -22.0 or neg_level > 0.02):
            raise ValueError(f"Bad level_neg {neg_level}, should be -22.0 to -0.20 A.")

        if prot_mode is not None:
            self.rmHandle.write(f"CURR:PROT:STAT {legal_prot_modes[prot_mode.upper()]}")  # dict converts OCP to TRIP.

        if pos_level is not None:
            if prot_mode_state == 'TRIP':
                self.rmHandle.write(f"CURR:PROT:OVER {pos_level}")
            else:
                self.rmHandle.write(f"CURR:LIM:UPP {pos_level}")

        if neg_level is not None:
            if prot_mode_state == 'TRIP':
                self.rmHandle.write(f"CURR:PROT:UND {neg_level}")
            else:
                self.rmHandle.write(f"CURR:LIMIT:LOW {neg_level}")

    # ---------------------------------------------------------------------------

    def prot_volt(self, prot_mode=None, pos_level=None, neg_level=None):
        """ Define voltage protection mode and levels.

        prot_mode:
            'LIM': Voltage excursions will be limited to the values specified.
            'OVP': A voltage excursion reaching the one of the specified values will cause
                   either the output to be disabled or the power switch to turn off the
                   entire PBZ20-20. The choice is set by the method prot_ocp_ovp_action.
            pos_level: The most positive voltage allowed.
            neg_level: The most negative voltage allowed.
        """

        legal_prot_modes = {'LIMIT': 'LIM', 'OVP': 'TRIP'}
        legal_prot_modes_rev = dict((v, k) for k, v in legal_prot_modes.items())

        if all(v is None for v in {prot_mode, pos_level, neg_level}):
            return_val = dict()
            prot_mode_state = self.rmHandle.query('VOLT:PROT:STAT?').strip()
            if prot_mode_state not in legal_prot_modes_rev:
                raise RuntimeError(f"Unknown prot_mode_state '{prot_mode_state}' returned from instrument.")
            return_val.update(pmode=legal_prot_modes_rev[prot_mode_state])
            if prot_mode_state == 'TRIP':
                return_val.update(pos_level=float(self.rmHandle.query('VOLT:PROT:OVER?').strip()))
                return_val.update(neg_level=float(self.rmHandle.query('VOLT:PROT:UND?').strip()))
            else:
                return_val.update(pos_level=float(self.rmHandle.query('VOLT:LIM:UPP?').strip()))
                return_val.update(neg_level=float(self.rmHandle.query('VOLT:LIM:LOW?').strip()))
            return return_val

        # Check all inputs, apply only if all good.
        if prot_mode is None:
            # Get present prot_mode, because SCPI cmd for setting levels changes depending on mode.
            prot_mode_state = self.rmHandle.query('VOLT:PROT:STAT?').strip()
        elif prot_mode.upper() not in legal_prot_modes:
            msg = ", ".join([f"'{x}'" for x in legal_prot_modes])
            raise ValueError(f"Bad prot_mode '{prot_mode}', should be one of {msg}.")
        else:
            prot_mode_state = legal_prot_modes[prot_mode.upper()]

        if pos_level is not None and (pos_level < 0.2 or pos_level > 22.0):
            raise ValueError(f"Bad level_pos {pos_level}, should be 0.2 to 22.0 A.")

        if neg_level is not None and (neg_level < -22.0 or neg_level > 0.02):
            raise ValueError(f"Bad level_neg {neg_level}, should be -22.0 to -0.20 A.")

        if prot_mode is not None:
            self.rmHandle.write(f"VOLT:PROT:STAT {legal_prot_modes[prot_mode.upper()]}")  # dict converts OVP to TRIP.

        if pos_level is not None:
            if prot_mode_state == 'TRIP':
                self.rmHandle.write(f"VOLT:PROT:OVER {pos_level}")
            else:
                self.rmHandle.write(f"VOLT:LIM:UPP {pos_level}")

        if neg_level is not None:
            if prot_mode_state == 'TRIP':
                self.rmHandle.write(f"VOLT:PROT:UND {neg_level}")
            else:
                self.rmHandle.write(f"VOLT:LIMIT:LOW {neg_level}")

    # ---------------------------------------------------------------------------

    def prot_clear(self):
        """If the output switches off due to an OCP or OVP event, youmust call this
        method to clear the alarm condition before re-enabling the output."""

        self.rmHandle.write('OUTP:PROT:CLE')

    # ---------------------------------------------------------------------------

    def prot_ocp_ovp_action(self, action=None):
        """Define what action will be taken when an Over Current Protection or
        Over Voltage Protection is activated.

        action:
            OUT_OFF: Output switches off. PBZ20-20 power switch stays on.
            POW_OFF: PBZ20-20 power switch switches itself off powering down the supply.
        """

        legal_actions = {'OUT_OFF': 0, 'POW_OFF': 1}
        legal_actions_reversed = dict((v, k) for k, v in legal_actions.items())

        if action is None:
            response = self.rmHandle.query(f"SYST:CONF:BTR:PROT?").strip()
            return legal_actions_reversed[int(response)]

        if action.upper() not in legal_actions:
            msg = ", ".join([f"'{x}'" for x in legal_actions])
            raise ValueError(f"Bad action '{action}', should be one of: {msg}.")

        self.rmHandle.write(f"SYST:CONF:BTR:PROT {legal_actions[action.upper()]}")

    # ---------------------------------------------------------------------------

    def status_reg_bits(self, regname):
        """Queries OPER or QUES status register and returns dictionary showing name-values of bits.

        Args:
            regname: 'oper' or 'ques'. Not case sensitive.

        """

        # TODO: Figure out if we need to set the ENABLE registers to non-default values.

        regname_u = regname.upper()
        if regname_u == 'OPER':
            conditions = {'Measuring': 4, 'Waiting for TRIG': 5, 'Constant Voltage': 8,
                          'Constant Current': 10, 'Transient Delay': 11, 'Program': 14}
        elif regname_u == 'QUES':
            conditions = {
                'Over Voltage': 0, 'Over Current': 1, 'AC Power Off': 3, 'Over Temp': 4, 'Over Power': 5,
                'V-Limit': 8, 'I-Limit': 9, 'Shutdown Alarm': 11, 'Power Limit': 12, 'UNLOCKED': 13
            }
        else:
            raise ValueError(f"Bad status regname '{regname}', needs to be 'oper' or 'ques'.")

        value = self.rmHandle.query(f'STAT:{regname_u}:COND?')
        value = int(value)

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    # ---------------------------------------------------------------------------

    def beep(self, on_off=None):
        if on_off is None:
            return self._legal_on_off_rev[int(self.rmHandle.query(f"SYST:CONF:BEEP:STAT?").strip())]

        if on_off.upper() not in self._legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self._legal_on_off])
            raise ValueError(f"Bad on_off '{on_off}', should be one of: {msg}")

        self.rmHandle.write(f"SYST:CONF:BEEP:STAT {on_off.upper()}")

    # ---------------------------------------------------------------------------

    def getIdn(self):
        """Returns instrument identity string.
        """

        return self.rmHandle.query('*IDN?')

    def getError(self):
        """Reads a single error string (oldest) from supply error queue.

        Error queue is First In First Out. Will return "0, 'No Error" on the read
        following reading the last error.

        Clears device Alarm bits in QUEStionable Status register if the condition that
        caused the alarm is gone.
        """

        return self.rmHandle.query('SYST:ERRor?').rstrip()

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = int(self.rmHandle.query('*STB?').rstrip())

        conditions = {'ERR': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPER': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending '*CLS, command."""

        self.rmHandle.write('*CLS')

    def close(self):
        """There is no need for users to call this. If you do instrument will because
        unavailable because rmHandle will be closed.

        This is here for InstMgr to use in its clean up.
        """

        # here, might need to communicate with instrument manager to retire the
        # instance listed there
        self.rmHandle.close()


# ===============================================================================

if __name__ == "__main__":
    import os
    import time

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    from InstMgr import InstMgr

    instMgr = InstMgr()

    ps = instMgr.checkout(objName='wamp', interface='GPIB', addr=23, moduleSuffix='PBZ2020')

    ps.reset()

    print()

    print(ps.getIdn())

    ps.reset()  # Puts everything back to factory defaults - output OFF.

    if False:  # Change to True to run this example code !!!INCLUDES TURNING OUTPUT ON!!!
        # Setup 2V DC with 1KHz 3Vpp sine wave, current limit 0.4A, OVP 3.75V.
        # Load = 8 Ohms ( 4 + 4)

        # Read and show the config parameters. No need to modify these.
        print(f"configs={ps.config()}")

        # Just use the default signal_source parameters, just showing what they are
        print(f"defaults_signal_source={ps.signal_source()}")

        # Setup DC
        ps.dc_source(2)   # Set to 2 Volt.
        print(f"dc_source={ps.dc_source()}")

        # Setup AC
        ps.ac_source('ON', amplitude_pkpk=3)
        print(f"ac_source={ps.ac_source()}")

        # Setup current limit (compliance).
        ps.prot_curr('LIMIT', pos_level=0.4, neg_level=0)
        print(f"prot_curr={ps.prot_curr()}")

        #Setup Voltage protection (disables output when exceeded).
        ps.prot_volt('OVP', pos_level=3.75, neg_level=0)
        print(f"prot_volt={ps.prot_volt()}")

        # ps.output('ON')  # Uncomment this if safe for your setup.

        time.sleep(.5)

        vdc = ps.meas('VOLTS_DC')
        vac =  ps.meas('VOLTS_RMS')
        vmax = ps.meas('VOLTS_PK_MAX')
        print(f"VOLTS_DC={vdc:0.3f}, VOLTS_RMS={vac:0.3f}, VOLTS_PK_MAX={vmax:0.3f}")

        idc = ps.meas('CURRENT_DC')
        iac =  ps.meas('CURRENT_RMS')
        imax = ps.meas('CURRENT_PK_MAX')
        print(f"CURRENT_DC={idc:0.3f}, CURRENT_RMS={iac:0.3f}, CURRENT_PK_MAX={imax:0.3f}")

