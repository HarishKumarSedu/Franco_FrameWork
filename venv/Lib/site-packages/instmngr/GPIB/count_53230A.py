# -*- coding: utf-8 -*-
"""
Class for controlling Agilent/Keysight Frequency Counter, Model 53230A.
Created on Wed Sep 11 16:00 2019

@author: dkaroly
"""

import sys
import inspect

idnString = '53230A'

class Count_53230A:
    """Class for controlling Tek Frequency Counter 53230A."""

    def __init__(self, rmHandle):
        """ Constructor for Count_53230A class.
        
        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using 
                       :meth:`pyvisa.highlevel.ResourceManager.open_resource`
        """

        self.rmHandle = rmHandle
        self.debug_print_enable = 0
        self.reset()

    def reset(self):
        """ Resets the counter its factory defaults.
        """

        self.rmHandle.write('*RST')

    # ----------------------------------------------------------------------------------------------

    def getIdn(self):
        """ Queries Electronic Load IDN and returns string. """

        return self.rmHandle.query('*IDN?')

    def getError(self):
        """ Queries Electronic Load error buffer and returns string. """

        return self.rmHandle.query('SYST:ERRor?').strip()

    def errlog(self):
        err_cmd = 'SYST:ERR?'
        err_list = []
        while True:
            err_msg = self.rmHandle.query(err_cmd)
            if 'No error' in err_msg:
                break
            else:
                err_list.append(err_msg)
        return err_list

    def debug_print(self):
        if self.debug_print_enable == 0:
            return
        err_list = self.errlog()
        if err_list or self.debug_print_enable == 1:
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            caller = frame_record[3]
            lineno = frame_record[2]
            print(f"debug print:{filename}:{caller} line {lineno} inst errors: {err_list}")

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = int(self.rmHandle.query('*STB?').rstrip())

        conditions = {'DREG0': 1, 'EAV': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPR': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending '*CLS, command."""

        self.rmHandle.write('*CLS')

if __name__ == "__main__":
    import os

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    import InstMgr
    from pprint import pprint

    instMgr = InstMgr.InstMgr()
    cntr = instMgr.checkout(objName='supply', interface='GPIB', addr=4, moduleSuffix='53230A')

    print(cntr.getIdn())