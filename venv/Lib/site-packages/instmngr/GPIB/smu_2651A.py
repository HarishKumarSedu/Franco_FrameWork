# -*- coding: utf-8 -*-
"""
Created on Mon Jun 13 2020

@author: tony
Version: 1.1

History:    

Function List:

"""

import sys
import time
import logging
from smu_2602A import Smu_2602A

idnString = 'Model 2651A'

class Smu_2651A(Smu_2602A):
    # here, innermost dict is command mmenmoic:{current value,(possible values),TSP command}

    # TO-DO
    # The function of 'offFunction' and 'powerLimit' does not work with 2602A - why!
    instDict = {
        'source': {
            'ch1autorangev': ['smua.AUTORANGE_ON', {'off': 'smua.AUTORANGE_OFF', 'on': 'smua.AUTORANGE_ON'},
                              'autorangev'],
            'ch1voltRange': [0.1, (5e-9, 40), 'rangev'],
            'ch1autorangei': ['smua.AUTORANGE_ON', {'off': 'smua.AUTORANGE_OFF', 'on': 'smua.AUTORANGE_ON'},
                              'autorangei'],
            'ch1currRange': [100e-9, (2e-12, 20), 'rangei'],
            'ch1function': ['smua.OUTPUT_DCVOLTS', {'I': 'smua.OUTPUT_DCAMPS', 'V': 'smua.OUTPUT_DCVOLTS'}, 'func'],
            # 'ch1offFunction':['smua.OUTPUT_DCVOLTS',{'I':'smua.OUTPUT_DCAMPS','V':'smua.OUTPUT_DCVOLTS'},'offfunc'],
            'ch1offMode': ['smua.OUTPUT_NORMAL',
                           {'normal': 'smua.OUTPUT_NORMAL', 'zero': 'smua.OUTPUT_ZERO', 'highz': 'smua.OUTPUT_HIGH_Z'},
                           'offmode'],
            'ch1voltLevel': [0, (-40, 40), 'levelv'],
            'ch1currLevel': [0, (-20, 20), 'leveli'],
            'ch1voltLimit': [20, (-40, 40), 'limitv'],
            'ch1currLimit': [100e-3, (-20, 20), 'limiti'],
            'ch1powerLimit': [0, (0, 200), 'limitp'],
            'ch1output': ['smua.OUTPUT_OFF',
                          {'off': 'smua.OUTPUT_OFF', 'on': 'smua.OUTPUT_ON', 'highz': 'smua.OUTPUT_HIGH_Z'}, 'output'],
            'ch1settling': ['smua.SETTLE_SMOOTH',
                            {'smooth': 'smua.SETTLE_SMOOTH', 'fastRange': 'smua.SETTLE_FAST_RANGE',
                             'fastPolarity': 'smua.SETTLE_FAST_POLARITY', 'directCurr': 'smua.SETTLE_DIRECT_IRANGE'},
                            'settling'],
            'ch1sink': ['smua.DISABLE', {'disable': 'smua.DISABLE', 'enable': 'smua.ENABLE'}, 'sink'],
        },
        'measure': {
            'ch1autorangev': ['smua.AUTORANGE_ON', {'off': 'smua.AUTORANGE_OFF', 'on': 'smua.AUTORANGE_ON',
                                                    'follow': 'smua.AUTORANGE_FOLLOW_LIMIT'}, 'autorangev'],
            'ch1voltRange': [0.1, (0.1, 40), 'rangev'],
            'ch1autorangei': ['smua.AUTORANGE_ON', {'off': 'smua.AUTORANGE_OFF', 'on': 'smua.AUTORANGE_ON',
                                                    'follow': 'smua.AUTORANGE_FOLLOW_LIMIT'}, 'autorangei'],
            'ch1currRange': [100e-9, (100e-9, 20), 'rangei'],
            'ch1filterenable': ['smua.FILTER_ON', {'on': 'smua.FILTER_ON', 'off': 'smua.FILTER_OFF'}, 'filter.enable'],
            'ch1filtercount': [10, (1, 100), 'filter.count'],
            'ch1filtertype': ['smua.FILTER_REPEAT_AVG',
                              {'repeat': 'smua.FILTER_REPEAT_AVG', 'moving': 'smua.FILTER_MOVING_AVG',
                               'median': 'smua.FILTER_MEDIAN'}, 'filter.type'],
            'ch1measspeed': [1, (0.001, 25), 'nplc'],
            'ch1single': ['smua.measure.v()', {'voltage': 'smua.measure.v()', 'current': 'smua.measure.i()',
                                               'resistance': 'smua.measure.r()', 'power': 'smua.measure.p()'}, ''],
            'ch1display': ['display.MEASURE_DCAMPS',
                           {'voltage': 'display.MEASURE_DCVOLTS', 'current': 'display.MEASURE_DCAMPS',
                            'resistance': 'display.MEASURE_OHMS', 'power': 'display.MEASURE_WATTS'},
                           'display.smua.measure.func='],
        },
        ## Higher current Range for pulse input
        'pulse': {
            'ch1currRange': [100e-9, (100e-9, 50), 'rangei'],
            'ch1currLimit': [100e-3, (-20, 20), 'limiti'],
            'pulsecurrLimit': [(100e-9, 20), (-50, 50)]
        }
    }

    chDict = {1: 'smua'}

    def __init__(self, rmHandle):
        self.rmHandle = rmHandle
        self.logger = logging.getLogger('marv.inst.Smu_2651A')
        self.logger.info('Initializing Smu_2651A instrument')

    def set_pulse_src_param(self, param='ch1autorangev', val='on'):
        inputValid = 0
        cmdhdr = self.chDict[int(param[2])] + '.source.'

        if param in self.instDict['pulse'].keys():
            if (self.instDict['pulse'][param][1] is None) or ((self.instDict['pulse'][param][1] is not None) and (val >= self.instDict['pulse'][param][1][0]) and (val <= self.instDict['pulse'][param][1][1])):
                self.instDict['pulse'][param][0] = val
            else:
                if (self.instDict['pulse'][param][1] is not None) and (val >= self.instDict['pulse']['pulsecurrLimit'][1][0]) and (val <= self.instDict['pulse']['pulsecurrLimit'][1][1]):
                    self.logger.warning('WARNING: Input value is out of instrument max DC current capability! ')
                    self.logger.warning('Max DC Value is assigned to the instrument! We can still source till pulse limit!')
                    self.instDict['pulse'][param][0] = self.instDict['pulse']['pulsecurrLimit'][0][1]
                else:
                    self.logger.warning('WARNING: Input value is out of instrument capability. Min DC Value is assigned to the instrument!')
                    self.instDict['pulse'][param][0] = self.instDict['pulse']['pulsecurrLimit'][0][0]
            inputValid = 1
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
        if inputValid == 1:
            sendStr = cmdhdr + self.instDict['pulse'][param][2] + ' = ' + str(self.instDict['pulse'][param][0])
            # print(sendStr)
            self.rmHandle.write(sendStr)
            # self.rmHandle.write(cmdhdr + self.instDict['source'][param][2] + ' = ' + str(self.instDict['source'][param][0]))

    def configISrc(self, src=1, ilevel=0.1, vlimit=1.8):
        src_setup = [
            ('ch' + str(src) + 'function', 'I'),
            ('ch' + str(src) + 'autorangei', 'off'),
            ('ch' + str(src) + 'currRange', abs(ilevel)),
            ('ch' + str(src) + 'offMode', 'zero'),
            ('ch' + str(src) + 'currLevel', ilevel),
            ('ch' + str(src) + 'currLimit', ilevel + 0.1),
            ('ch' + str(src) + 'voltLimit', vlimit),
        ]


        for param, val in src_setup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setSrcParam(param=param, val=val)
            time.sleep(0.2)


    def configVMeas(self, src=1, range='auto', spd=1, filtercount=10):
        VMeasetup = [
            ('ch' + str(src) + 'filterenable', 'on'),
            ('ch' + str(src) + 'measspeed', spd),
            ('ch' + str(src) + 'filtertype', 'repeat'),
            ('ch' + str(src) + 'filtercount', filtercount),
        ]
        if range == 'auto':
            self.setMeasParam(param='ch1autorangev', val='on')
        else:
            self.setMeasParam(param='ch1autorangev', val='off')
            self.setMeasParam(param='ch1voltRange', val=range)

        for param, val in VMeasetup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setMeasParam(param=param, val=val)
            time.sleep(0.2)

    def configIMeas(self, src=1, range='auto', spd=1, filtercount=10):
        IMeasetup = [
            ('ch' + str(src) + 'filterenable', 'on'),
            ('ch' + str(src) + 'measspeed', spd),
            ('ch' + str(src) + 'filtertype', 'repeat'),
            ('ch' + str(src) + 'filtercount', filtercount),
        ]
        for param, val in IMeasetup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setMeasParam(param=param, val=val)
            time.sleep(0.2)
        if range == 'auto':
            self.setMeasParam(param='ch1autorangei', val='on')
        else:
            self.setMeasParam(param='cch1autorangei', val='off')
            self.setMeasParam(param='ch1currRange', val=range)

    def Pulse_I_Measure_V(self,
                       bias: int = 1,
                       level: int = 2,
                       vlimit: int = 3,
                       ton: float = 0.001,
                       toff: float = 0.001,
                       points: int = 10) -> None:
        srcsetup = [
            ('ch1function', 'I'),
            ('ch1autorangei', 'off'),
            ('ch1currLevel', bias),
            ('ch1voltLimit', vlimit),
        ]

        for param, val in srcsetup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setSrcParam(param=param, val=val)
            time.sleep(0.2)

        pulse_src_setup = [
            ('ch1currRange', abs(level)),
            ('ch1currLimit', level),
        ]

        for param, val in pulse_src_setup :
            # print('\tParamepter ', param, '\t Value ', val )
            self.set_pulse_src_param(param=param, val=val)
            time.sleep(0.2)

        measetup = [
            ('ch1filterenable', 'on'),
            ('ch1measspeed', 1),
            ('ch1filtertype', 'repeat'),
            ('ch1filtercount', 10),
            ('ch1autorangev', 'off'),
            ('ch1voltRange', vlimit)
            ]

        for param, val in measetup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setMeasParam(param=param, val=val)
            time.sleep(0.2)

        sendStr = 'PulseIMeasureV(smua,' + str(bias) + ',' + str(level) + ',' + str(ton)+ ',' + str(toff) + ',' + str(points) + ')'
        self.rmHandle.write(sendStr)

    def Pulse_V_Measure_I(self,
                       bias: int = 1,
                       level: int = 2,
                       ilimit: int = 3,
                       ton: float = 0.001,
                       toff: float = 0.001,
                       points: int = 10) -> None:
        srcsetup = [

            ('ch1function', 'V'),
            ('ch1autorangev', 'off'),
            ('ch1voltRange', abs(level)),
            ('ch1voltLevel', bias),
            ('ch1currLimit', ilimit),
            ('ch1voltLimit', level),
        ]

        for param, val in srcsetup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setSrcParam(param=param, val=val)
            time.sleep(0.2)

        measetup = [
            ('ch1filterenable', 'on'),
            ('ch1measspeed', 1),
            ('ch1filtertype', 'repeat'),
            ('ch1filtercount', 10),
            ('ch1autorangei', 'off'),
            ( 'ch1currRange', ilimit)
            ]

        for param, val in measetup:
            # print('\tParamepter ', param, '\t Value ', val )
            self.setMeasParam(param=param, val=val)
            time.sleep(0.2)
        sendStr = 'PulseVMeasureI(smua,' + str(bias) + ',' + str(level) + ',' + str(ton) + ',' + str(toff) + ',' + str(points) + ')'
        # print(sendStr)
        self.rmHandle.write(sendStr)



if __name__ == "__main__":
    import os, sys

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)

    import InstMgr

    instMgr = InstMgr.InstMgr()
    smu = instMgr.checkout(interface='GPIB', addr=26, moduleSuffix='2651A')
    smu.reset()
    #    print(smu.getIdn())

    setupList1 = [('ch1autorangev', 'off'),
                  ('ch1autorangei', 'on'),
                  ('ch1voltRange', 2),
                  ('ch1function', 'V'),
                  ('ch1offMode', 'highz'),
                  ('ch1voltLevel', 0),
                  ('ch1voltLimit', 0.01),
                  ('ch1currLimit', 0.1),
                  ]
    for param, val in setupList1:
        print(param, val)
        smu.setSrcParam(param=param, val=val)
    smu.setOutputState(src=1, val='on')

    smu.configVSrc()
    smu.setOutputState(src=1, val='on')
    smu.configVSrc(src=2)
    smu.setOutputState(src=2, val='on')
    time.sleep(2)
    complianceState = smu.getSrcInComplianceLimit(src=1)

    smu.configIMeas(src=1)
    print(smu.getMeas(src=1, param='current'))
    smu.configIMeas(src=2)
    print(smu.getMeas(src=2, param='current'))

    smu.close()
    pass
