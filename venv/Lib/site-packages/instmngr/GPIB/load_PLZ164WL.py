# -*- coding: utf-8 -*-
"""
Class for controlling Kikusui Electronic Load Model PLZ164WL.

Created on Wed Sep 11 16:00 2019

@author: dkaroly
"""

import sys
from time import sleep
import numpy as np
import inspect
import os

idnString = 'PLZ164WL'


# TODO: Support for triggered level changes.

class Load_PLZ164WL:
    """Class for controlling Kikusui Electronic Load Model PLZ164WL."""

    _ratings = dict()
    _ratings['COND'] = {'L': (30e-6, 1.65), 'M': (300e-6, 16.5), 'H': (3e-3, 165), 'units': 'Siemens (mhos)'}
    _ratings['CURR'] = {'L': (0, 0.5), 'M': (0, 5.0), 'H': (0, 50), 'units': 'Amps'}
    _ratings['POW'] = {'L': (0.165, 1.65), 'M': (1.65, 16.5), 'H': (16.5, 165.0), 'units': 'Watts'}
    _ratings['VOLT'] = {'L': (0.3, 4.0), 'H': (0.3, 30), 'units': 'Volts'}
    _ratings['SLEW'] = {'L': (25e-6, 250e-3), 'M': (250e-6, 250e-3), 'H': (2.5e-3, 2.5), 'units': 'Amps/usec'}

    _rating_curr_max = 55  # Amps
    _rating_pow_max = 181.5  # Watts

    legal_on_off = {'ON': 1, 'OFF': 0}
    legal_on_off_rev = dict((v, k) for k, v in legal_on_off.items())

    options_pgm_norm_modes = ('NCC', 'NCR', 'NCV', 'NCP')
    options_pgm_fast_modes = ('FCC', 'FCR')

    options_curr_range = {'L': 'LOW', 'M': 'MED', 'H': 'HIGH'}
    options_curr_range_rev = dict((v, k) for k, v in options_curr_range.items())

    options_volt_range = {'L': 'LOW', 'H': 'HIGH'}
    options_volt_range_rev = dict((v, k) for k, v in options_volt_range.items())

    options_pgm_status = ('TRUN', 'RUN', 'STOP', 'PAUS', 'CONT')
    cfg_max_disp_list_errors = 10

    debug_print_enable = 2  # 0 = Don't print anything
                            # 1 = print all calls
                            # 2 = print only when error queue is non-empty

    def __init__(self, rmHandle):
        """ Constructor for Load_PLZ164WL class.
        
        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using 
                       :meth:`pyvisa.highlevel.ResourceManager.open_resource`
        """

        self.rmHandle = rmHandle
        self.reset()

        # Enabling these to allow propagation to the status byte.
        self.rmHandle.write(f'STAT:OPER:ENAB {0x21}')  # Only bits 0 and 5 are used.
        self.rmHandle.write(f'STAT:CSUM:ENAB {0x10F}')  # Only bits 0-3 and 8 are used.
        self.rmHandle.write(f'STAT:QUES:ENAB {0xE1B}')  # Only bits 0,1,3,4,9-11 are used.

    def reset(self):
        """ Resets the Electronic Load to its factory defaults, mostly .
        Does not modify STATUS enable registers.
        """

        self.rmHandle.write('*RST')  # '*RST' doesn't reset STAT:*:ENAB bits on this inst.

    def ratings(self, param, range=None):
        """
        If range is specified, Returns a tuple consisting of minval, maxval and units for the
        specified parameter and range. If range is None, returns a dictionary.

        Args:
            param (str):
                'COND' - Conductance, see attribute ranges_conductance
                'CURR' - Current, see attribute ranges_current
                'POW'  - Power, see attribute ranges_power
                'VOLT' - Voltage, see attribute ranges_voltage
            range: for range setting for the parameter.
                'L': low
                'M': medium, Not valid when param is 'VOLT'.
                'H': high
                None: Returns the self._ratings sub-dictionary for the specified parameter.

           Args are not case sensitive.
        """

        legal_params = ('COND', 'CURR', 'VOLT', 'POW', 'SLEW')
        param_u = param.upper()
        if param_u not in legal_params:
            msg = ", ".join([f"'{x}'" for x in legal_params])
            raise ValueError(f"Bad param '{param}' for {param}. Should be one of: {msg}.")

        if range is not None:
            min_val, max_val = self._ratings[param_u][range]
            units = self._ratings[param_u]['units']
            return min_val, max_val, units
        else:
            return self._ratings[param_u]

    def mode(self, mode=None):
        """
        Queries or writes operating mode of the Electronic load.
            
        Args:
            mode (str): 
                None   - Queries instrument, returns one of the following strings:
                'CC'   - sets Constant Current mode.
                'CV'   - sets Constant Voltage mode.
                'CP'   - sets Constant Power mode.
                'CR'   - sets Constant Resistance mode.
                'CCCV' - sets Constant Current with Constant Voltage mode.
                'CRCV' - sets Constant Resistance with Constant Voltage mode.
                
           Args are not case sensitive. 
           Return values are always case shown above.    
        """
        # TODO: Disallow changing modes if switching is active.

        self.debug_print()

        mode_list = ('CC', 'CV', 'CP', 'CR', 'CCCV', 'CRCV')
        if mode is None:
            rslt = self.rmHandle.query('FUNC?')
            return rslt.rstrip()
        elif mode.upper() in mode_list:
            if self.state() == 'ON':
                raise ValueError("Cannot program mode while load state is ON.")  # Or you get error 24.
            self.rmHandle.write('FUNC ' + mode.upper())
        else:
            msg = ", ".join([f"'{x}'" for x in mode_list])
            raise ValueError(f"Bad mode '{mode}'. Should be one of: {msg}.")

        self.debug_print()

    def state(self, state=None):
        """
        Queries or writes the state of the Electronic Load input terminals.

        Args:
            None   - Queries instrument, returns one of the following strings:
            'ON'   - Load terminals are connected to the DUT.
            'OFF'  - Load terminals are disconnected from the DUT.

           Args are not case sensitive. 
           Return values are always case shown above.
        """

        if state is None:
            tmp = self.rmHandle.query('INPut:STATe:IMMediate?').strip()
            return self.legal_on_off_rev[int(tmp)]

        elif state.upper() in self.legal_on_off:
            self.rmHandle.write(f'INPut:STATe:IMMediate {state.upper()}')
        else:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad state '{state}'. Should be one of: {msg}.")

    def range(self, param, range=None):
        """
        Queries or writes the range for the specified parameter.
        
        Args:
            param (str): 
                'COND' - Conductance, see attribute ranges_conductance
                'CURR' - Current, see attribute ranges_current
                'POW'  - Power, see attribute ranges_power
                'VOLT' - Voltage, see attribute ranges_voltage
            range (str): 
                None   - Queries instrument, returns one of the following strings:
                'L'    - Low range, valid for all param.
                'M'    - Medium range, not valid for VOLT param.
                'H'    - High range, valid for all param. 

           Args are not case sensitive. 
           Return values are always case shown above.
        """

        legal_params = ('COND', 'CURR', 'VOLT', 'POW')
        param_u = param.upper()
        if param_u not in legal_params:
            msg = ", ".join([f"'{x}'" for x in legal_params])
            raise ValueError(f"Bad param '{param}' for {param}. Should be one of: {msg}.")

        if param_u == 'VOLT':
            write_dict = {'L': 'LOW', 'H': 'HIGH'}
        else:
            write_dict = {'L': 'LOW', 'M': 'MED', 'H': 'HIGH'}
        read_dict = {v: k for k, v in write_dict.items()}  # reverse dictionary for reading.

        if range is None:
            rslt = self.rmHandle.query(param_u + ':RANG?')
            return read_dict[rslt.rstrip()]
        elif range.upper() in write_dict.keys():
            self.rmHandle.write(param_u + ':RANG ' + write_dict[range.upper()])
        else:
            tmp = ", ".join([f"'{x}'" for x in write_dict.keys()])
            msg = f"Bad range '{range}' for {param}. Should be one of: {tmp}."
            for k in write_dict:
                minval, maxval, units = self.ratings(param_u, k)
                msg += f"\n   '{k}': {minval} to {maxval} {units}"
            raise ValueError(msg)

    def level(self, param, level=None):
        """
        Queries or writes the level for the specified parameter.
        
        Args:
            param (str): 
                'COND' - Conductance, see attribute ranges_conductance
                'CURR' - Current, see attribute ranges_current
                'POW'  - Power, see attribute ranges_power
                'VOLT' - Voltage, see attribute ranges_voltage
            level (str, int or float):
                None   - Queries from instrument the present level setting for param.
                'MIN'  - Minimum level of the range presently in effect for param.
                'MAX'  - Maximum level of the range presently in effect for param.
                <numeric> - Sets level of param. Units are Seimens, Amps, Watts, or Volts. 

           Args are not case sensitive. 
           Return values are always of type float.
        """

        legal_params = ('COND', 'CURR', 'VOLT', 'POW')
        param_u = param.upper()
        if param_u not in legal_params:
            msg = ", ".join([f"'{x}'" for x in legal_params])
            raise ValueError(f"Bad param '{param}' for {param}. Should be one of: {msg}.")

        if level is None:
            return float(self.rmHandle.query(param_u + '?'))

        # If we got here, we are writing to the instrument.
        min_val, max_val, units = self.ratings(param_u, self.range(param))
        if type(level) in (int, float):
            if level < min_val or level > max_val:
                raise ValueError(f"Bad level for {param}, should be {min_val} to {max_val} {units}.")
            self.rmHandle.write(param_u + ' ' + str(level))
        elif level in ('MIN', 'MAX'):
            self.rmHandle.write(param_u + ' ' + level)
        else:
            raise ValueError(f"Bad level '{level}' for {param}. Should be one of: "
                             "{min_val} to {max_val}, 'MIN' or 'MAX'.")

    def meas(self, param):
        """
        Queries or writes actual measured level of the specified parameter.
        
        Args:
            param (str): 
                'CURR' - measured Current (Amps)
                'POW'  - measured Power   (Watts)
                'VOLT' - measured Voltage (Volts)

           Args are not case sensitive. 
           Return values are of type float.
        """

        legal_params = ('CURR', 'POW', 'VOLT')
        param_u = param.upper()
        if param_u not in legal_params:
            msg = ", ".join([f"'{x}'" for x in legal_params])
            raise ValueError(f"Bad param '{param}'. Should be one of: {msg}.")

        rslt = self.rmHandle.query('MEAS:' + param_u + '?')
        return float(rslt.rstrip())

    def regulate(self, desired_value, tolerance=0.1, max_iterations=10, delay=0.5):
        """
        Alters the level setting of the parameter controlled by the present mode
        to achieve a measured level equal to desired_value.
        
        Args:
            desired_value  - Target measured level for parameter.
            tolerance      - Value is considered to have hit the target when 
                             measured level falls within +/- tolerance percent
                             of the desired_value.
            max_iterations - Upper limit on number of adjustments to level
                             setting before giving up on achieving the
                             desired_value +/- tolerance percent. If 0, then no
                             adjustments are made to present level setting.
            delay          - Settling time between level change and measurement.
            
        Return level (bool):
            True           - measured level is within +/- tolerance percent of
                             desired_value.
            False          - final measured level is not within +/- tolerance.
            
            NOTE: This is checked even if max_iterations == 0.
        """

        param = {'CC': 'CURR', 'CV': 'VOLT', 'CP': 'POW', 'CR': 'COND', 'CCCV': 'CURR', 'CRCV': 'COND'}[self.mode()]

        self.level(param, desired_value)

        self.state('ON')

        sleep(delay)

        delta = self.meas(param) - desired_value
        error_percent = 100 * abs(delta / desired_value)

        iteration = 0
        while iteration < max_iterations:
            if error_percent <= tolerance:
                print('Regulated level is within %4.3f%% of desired after %d iterations.' % (error_percent, iteration))
                return True

            self.level(param, desired_value - delta)

            iteration += 1
            print('iter = %d' % iteration)

            sleep(delay)

            delta = self.meas(param) - desired_value
            error_percent = 100 * abs(delta / desired_value)

        # If we got here, either regulation failed or user put in max_iterations=0.
        print('After %d iterations, level is within %4.3f%% of desired.' % (iteration, error_percent))
        if error_percent > tolerance:
            return False
        else:
            return True

    def switching(self, state=None, level_low=None, percent=None, freq=None, period=None, duty_cycle=None):
        """
        Configures switching between two load currents in CC or CR mode. Attempting to use this in other modes throws
        an exception.

        The higher of the two currents corresponds to the current or conductance set using the level method.
        The lower of the two currents corresponds to the current or conductance set here through the level_low
        parameter or the percent parameter.

        If operating in CC mode, this affects the load current and level_low is interpreted as amps.
        If operating in CR mode, this affects the load conductance and level_low is is interpreted as Siemens.

        Args:
            state: 'ON' or 'OFF'. Enables/Disables toggling between the two load currents. Current in OFF state
                    corresponds to the high level or 100% of the level set by the level method.
            level_low: The current or conductance corresponding to the low level of the resulting waveform.
                       Setting this equal to or greater than the high level defined by the level method just gives a
                       waveform that is constant at the high level.
            percent:   The low level of the wave form expressed as a percentage of the high level. The high level is
                       the level set through the level method. Percent ranges from 0 to 100. A level of 100 just gives a
                       waveform that is constant at the high level.
                       NOTE:  If both level_low and percent are specified, the percent level takes precedence.
            freq: The number of high/low cycles per second, the reciprocal of period.
            period: Time interval (in sec) for one high/low cycle. The reciprocal of freq.
                    NOTE:  If both freq and period are specified, the period level takes precedence.
            duty_cycle: The percentage of each high / low cycle time (period) at the high level.

        SCPI Commands:
            [SOURce:]PULSe[:STATe] {ON|OFF|1|0}

            [SOURce:]PULSe:LEVel[:VALue]:CONDuctance {<numeric>|MINimum|MAXimum}
            [SOURce:]PULSe:LEVel:PERCentage:CONDuctance {<numeric>|MINimum|MAXimum}

            [SOURce:]PULSe:LEVel[:VALue]:CURRent {<numeric>|MINimum|MAXimum}
            [SOURce:]PULSe:LEVel:PERCentage:CURRent {<numeric>|MINimum|MAXimum}

            [SOURce:]PULSe:FREQuency {<numeric>|MINimum|MAXimum}
            [SOURce:]PULSe:PERiod {<numeric>|MINimum|MAXimum}
            [SOURce:]PULSe:DCYCle {<numeric>|MINimum|MAXimum}
        """

        mode = self.mode()
        param = {'CC': 'CURR', 'CR': 'COND'}.get(mode)

        if param is None:
            # Attempting to program these parameters in other modes would cause error 27.
            raise ValueError(f"Cannot set switching parameters in {mode}, only in modes 'CC' and 'CR'.")

        if all(v is None for v in {state, level_low, percent, freq, period, duty_cycle}):
            return_val = dict()
            tmp = self.rmHandle.query('PULS?')
            return_val.update(state=self.legal_on_off_rev[int(tmp)])
            return_val.update(level=float(self.rmHandle.query(f'PULS:LEV:{param}?')))
            return_val.update(percent=float(self.rmHandle.query(f'PULS:LEV:PERC:{param}?')))
            return_val.update(freq=float(self.rmHandle.query('PULS:FREQ?')))
            return_val.update(period=float(self.rmHandle.query('PULS:PER?')))
            return_val.update(duty=float(self.rmHandle.query('PULS:DCYC?')))
            return return_val

        # Check all inputs before writing data.
        if state is not None and state.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad state '{state}'. Should be one of: {msg}.")

        # Out of bound values for other parameters don't cause errors, they just cause the setting to go to one of
        # it extreme values.

        if percent is not None and (percent < 0.0 or percent > 100.0):
            raise ValueError(f"Bad percent {percent}, should be 0 to 100.")

        if freq is not None and (freq < 1.0 or freq > 50e3):
            raise ValueError(f"Bad freq {freq}, should be 1 to 50,000 Hz.")

        if period is not None and (period < 1.0 or period > 1/50e3):
            raise ValueError(f"Bad period {period}, should be 1 to {1/50e3} sec.")

        if duty_cycle is not None and (duty_cycle < 5.0 or duty_cycle > 95):
            raise ValueError(f"Bad duty {duty_cycle}, should be 5 to 95 percent.")

        # Now write the data.
        if state is not None:
            self.rmHandle.write(f'PULS {state.upper()}')

        if level_low is not None and percent is None:
            self.rmHandle.write(f'PULS:LEV:{param} {level_low}')

        if percent is not None:
            self.rmHandle.write(f'PULS:LEV:PERC:{param} {percent}')

        if freq is not None and period is None:
            self.rmHandle.write(f'PULS:FREQ {freq}')

        if period is not None:
            self.rmHandle.write(f'PULS:PER {period}')

        if duty_cycle is not None:
            self.rmHandle.write(f'PULS:DCYC {duty_cycle}')

    def dynamics(self, cc_slew=None, cv_response=None, cr_response=None):
        """
        Queries or sets current slew rate and/or transient response speeds for CV and CR mode.

        SCPI Commands:
        [SOURce:]CURRent:SLEW {<numeric>|MINimum|MAXimum}
        [SOURce:]FUNCtion:RESPonse:CV {NORMal|FAST}
        [SOURce:]FUNCtion:RESPonse:CR {NORMal|FAST}
        """

        if all(v is None for v in {cc_slew, cv_response, cr_response}):
            return_val = dict()
            return_val.update(cc_slew=float(self.rmHandle.query('CURR:SLEW?')))
            return_val.update(cv_response=self.rmHandle.query('FUNC:RESP:CV?').strip())
            return_val.update(cr_response=self.rmHandle.query('FUNC:RESP:CR?').strip())
            return return_val

        if cc_slew is not None:
            curr_range = self.range("CURR")
            min_val, max_val, units = self.ratings('SLEW', curr_range)
            if cc_slew < min_val or cc_slew > max_val:
                raise ValueError(
                    f"Bad cc_slew {cc_slew} for {curr_range} current range, should be {min_val} to {max_val} {units}.")

        legal_responses = ('NORM', 'FAST')

        if cv_response is not None and cv_response.upper() not in legal_responses:
            msg = ", ".join([f"'{x}'" for x in legal_responses])
            raise ValueError(f"Bad cv_response '{cv_response}'. Should be one of: {msg}.")

        if cr_response is not None and cr_response.upper() not in legal_responses:
            msg = ", ".join([f"'{x}'" for x in legal_responses])
            raise ValueError(f"Bad cr_response '{cr_response}'. Should be one of: {msg}.")

        if cc_slew is not None:
            self.rmHandle.write(f'CURR:SLEW {cc_slew}')

        if cv_response is not None:
            self.rmHandle.write(f'FUNC:RESP:CV {cv_response.upper()}')

        if cr_response is not None:
            self.rmHandle.write(f'FUNC:RESP:CR {cr_response.upper()}')

    def ocp_value(self, ilimit=None, action=None):
        """
        Queries or sets Over Current Protection parameters.

        Args:
            ilimit: When load current exceeds this number of Amps, the OCP either limits the current or changes the
                    state of the load to 'OFF'.
            action: Defines what the load does when the OCP ilimit is reached.
                'LIM': Current still flows but is prevented from exceeding the level set by ilimit.
                'TRIP': The state of the load is swicthed to 'OFF'.

        SCPI Commands:
        [SOURce:]CURRent:PROTection[:LEVel][:OVER] {<value>|MINimum|MAXimum}
        [SOURce:]CURRent:PROTection:ACTion {LIMit|TRIP}
        """

        if all(v is None for v in {ilimit, action}):
            return_val = dict()
            return_val.update(ilimit=float(self.rmHandle.query('CURR:PROT?')))
            return_val.update(action=self.rmHandle.query('CURR:PROT:ACT?').strip())
            return return_val

        if ilimit is not None:
            if ilimit < 0 or ilimit > self._rating_curr_max:
                raise ValueError(f"Bad ilimit {ilimit}, should be 0 to {self._rating_curr_max} Amps.")

        legal_actions = ('LIM', 'TRIP')
        if action is not None and action.upper() not in legal_actions:
            msg = ", ".join([f"'{x}'" for x in legal_actions])
            raise ValueError(f"Bad action '{action}'. Should be one of: {msg}.")

        if ilimit is not None:
            self.rmHandle.write(f'CURR:PROT {ilimit}')

        if action is not None:
            self.rmHandle.write(f'CURR:PROT:ACT {action}')

    def ocp_clear(self):
        """ Writes command to clear Over Current Protection trip. If the OCP action is set to 'TRIP', the load state is
            changed to 'OFF' by OCP current through the load exceeding the set level. Note that after clearing the trip
            state, the output will remain off until reactivated using the state method.

        SCPI Commands:
            INPut:PROTection:CLEar
        """

        self.rmHandle.write('INP:PROT:CLE')

    def opp_value(self, plimit=None, action=None):
        """
        Queries or sets Over Power Protection parameters.

        Args:
            plimit: When load power exceeds this number of Watts, the OPP either limits the power or changes the state
                   of the load to 'OFF'.
            action: Defines what the load does when the OPP plimit is reached.
                'LIM': Current still flows but power is prevented from exceeding the level set by plimit.
                'TRIP': The state of the load is switched to 'OFF'.

        SCPI Commands:
        [SOURce:]POWer:PROTection[:LEVel][:OVER] {<value>|MINimum|MAXimum}
        [SOURce:]POWer:PROTection:ACTion?
        """

        if all(v is None for v in {plimit, action}):
            return_val = dict()
            return_val.update(plimit=float(self.rmHandle.query('POW:PROT?')))
            return_val.update(action=self.rmHandle.query('POW:PROT:ACT?').strip())
            return return_val

        if plimit is not None:
            if plimit < 0 or plimit > self._rating_pow_max:
                raise ValueError(
                    f"Bad plimit {plimit}, should be 0 to {self._rating_pow_max}.")

        legal_actions = ('LIM', 'TRIP')
        if action is not None and action.upper() not in legal_actions:
            msg = ", ".join([f"'{x}'" for x in legal_actions])
            raise ValueError(f"Bad action '{action}'. Should be one of: {msg}.")

        if plimit is not None:
            self.rmHandle.write(f'POW:PROT {plimit}')

        if action is not None:
            self.rmHandle.write(f'POW:PROT:ACT {action}')

    def opp_clear(self):
        """ Writes command to clear Over Current Protection trip. If the OCP action is set to 'TRIP', the load state is
            changed to 'OFF' by OCP current through the load  the set level. Note that after clearing the trip state,
            the output will remain off until reactivated using the state method.

        SCPI Commands:
            INPut:PROTection:CLEar
        """

        self.rmHandle.write('INP:PROT:CLE')

    def status_reg_bits(self, regname):
        """Queries OPER or QUES status register and returns dictionary showing name-values of bits.

        Args:
            regname: 'oper', 'csum' or 'ques'. Not case sensitive.

        Note that mode chnages don't show up in the CSUM bits until the load state is switched back 'ON'.
        """

        regname_u = regname.upper()
        if regname_u == 'OPER':
            conditions = {'Calibrating': 0, 'Waiting for TRIG': 5}
        elif regname_u == 'CSUM':
            conditions = {'CC': 0, 'CV': 1, 'CR': 2, 'CP': 3, 'PRUN': 8}
        elif regname_u == 'QUES':
            conditions = {
                'Over Voltage': 0, 'Over Current': 1, 'Over Power': 3, 'Over Temp': 4,
                'Under Voltage': 9, 'External Problem': 10, 'Reverse Voltage': 11
            }
        else:
            raise ValueError(f"Bad status regname '{regname}', needs to be 'oper' or 'csum' or 'ques'.")

        value = self.rmHandle.query(f'STAT:{regname_u}:COND?')
        value = int(value)

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    # ---------------------------------------------------------------------------------------------

    def _pgm_stepval_limits(self, mode, crange, vrange):
        """Helper function used to determine min/max limits, calculates power limit based on current and voltage ranges
        """

        cmin_val, cmax_val, _ = self.ratings('CURR', crange[0])  # Use first letter of range, allow 'L' or 'LOW'.
        vmin_val, vmax_val, _ = self.ratings('VOLT', vrange[0])

        if mode in ('NCC', 'FCC'):
            min_val, max_val = cmin_val, cmax_val
            units = 'Amps'
        elif mode in 'NCV':
            min_val, max_val = vmin_val, vmax_val
            units = 'Volts'
        elif mode in 'NCP':
            # The manual is unclear on how this works...
            # I'm guessing we cannot exceed limits of the crange, vrange combo or the ratings of the instrument.
            min_val = 0  # Because all CURR ranges have a lower bound of 0.
            _, max_val, _ = self.ratings('POW', 'H')        # get max power rating of instrument.
            max_val = min(cmax_val * vmax_val, max_val)  # limited by lessor of top of range, instrument max
            units = 'Watts'
        elif mode in ('NCR', 'FCR'):
            # CONDmax is Imax/Vmin, but Vmin is 0.3 for all vranges, so crange is the controlling parameter.
            min_val, max_val, units = self.ratings('COND', crange[0])
        else:
            raise RuntimeError(f"Bad level of mode {mode}!")

        return min_val, max_val, units

    def _pgm_cfg_check_values(self, pgm_num, memo, mode, crange, vrange, loop, last_state, last_level):
        """Helper function used to check values passed into pgm_norm_cfg and pgm_fast_cfg methods."""

        if memo is not None and (not isinstance(memo, str) or len(memo) > 11):
            raise ValueError(f"Bad memo '{memo}, must be a character string 0 to 11 characters long.")

        if mode is None:
            mode_setting = self.rmHandle.query('PROG:MODE?').strip()
        else:
            modes = self.options_pgm_norm_modes if pgm_num < 11 else self.options_pgm_fast_modes
            if mode not in modes:
                msg = ", ".join([f"'{x}'" for x in modes])
                raise ValueError(f"Bad mode '{mode}'. Should be one of: {msg}.'")
            mode_setting = mode

        if crange is None:
            crange_setting = self.rmHandle.query('PROG:CRAN?').strip()[0]
        else:
            if crange not in self.options_curr_range:
                msg = ", ".join([f"'{x}'" for x in self.options_curr_range])
                raise ValueError(f"Bad crange '{crange}' for a normal sequence. Should be one of: {msg}.")
            crange_setting = crange

        if vrange is None:
            vrange_setting = self.rmHandle.query('PROG:VRAN?').strip()[0]
        else:
            if vrange not in self.options_volt_range:
                msg = ", ".join([f"'{x}'" for x in self.options_volt_range])
                raise ValueError(f"Bad vrange '{vrange}' for a normal sequence. Should be one of: {msg}.")
            vrange_setting = vrange

        if loop is not None:
            if (isinstance(loop, (int, float)) and (loop < 1 or loop > 9998)) or (
                    isinstance(loop, str) and loop.upper() != 'INF'):
                raise ValueError(f"Bad loop {loop}. Should be 1 to 9998 or 'INF'.")

        if last_state is not None and last_state not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad last_state '{last_state}. Should be one of {msg}.")

        if last_level is not None:
            min_val, max_val, units = self._pgm_stepval_limits(mode_setting, crange_setting, vrange_setting)
            if last_level < min_val or last_level > max_val:
                raise ValueError(f"Bad last_level {last_level}, should be {min_val} to {max_val} {units} " +
                                 "for mode {mode}.")

    def pgm_norm_cfg(self, pgm_num, memo=None, mode=None, crange=None, vrange=None, loop=None,
                     last_state=None, last_level=None, chain=None):
        """Configure the parameters that are common to a Program that runs as a Normal Sequence.
        Use the methods pgm_norm_* to add, delete or edit steps that make up the sequence.

        Args:
            pgm_num: Integer from 1 to 10 that identifies the program
            memo:    String of up to 11 characters that describes the program.
            mode:    Identifies load operating mode for the sequence. One of 'CC', 'CR', 'CV', 'CP'.
            crange:  Current range" 'L", 'M', 'H'. Use method ratings to see the numerical values.
            vrange:  Voltage range" 'L", 'H'. Use method ratings to see the numerical values.
            loop:    Repeat the program this many times: 1-9998. Value 'INF' gives infinite loop.
            last_state: The state of the load, 'ON' or 'OFF' after the sequence ends.
            last_level: The level after the sequence ends. Depending on mode this is a conductance, current, voltage or
                        power number.
            chain:    The pgm_num of the program to execute next, 1-10 or 0. 0 ends sequence operation.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]:MEMO "<string>"
            PROGram[:SELected]:MODE {NCC|NCR|NCV|NCP|FCC|FCR}
            PROGram[:SELected]:CRANge {LOW|MEDium|HIGH}
            PROGram[:SELected]:VRANge {LOW|HIGH}
            PROGram:LOOP
            PROGram[:SELected]:LINPut {ON|OFF|1|0}
            PROGram[:SELected]:LVALue {<numeric>|MINimum|MAXimum}
            PROGram[:SELected]:CHAin <NR1>
        """

        self.debug_print()

        if pgm_num < 1 or pgm_num > 10:
            raise ValueError(f'Bad pgm_num {pgm_num}, must be 1-10 for normal sequences.')

        # Determines which program subsequent commands operate upon.
        self.rmHandle.write(f'PROG:NAME {pgm_num}')

        # No Args, perform queries on all values and return as a dict.
        if all(v is None for v in {memo, mode, crange, vrange, loop, last_state, last_level, chain}):
            return_val = dict()
            tmp = self.rmHandle.query(f'PROG:MEMO?').rstrip('\n').strip('"').strip()
            return_val.update(memo='' if tmp.isspace() else tmp)
            return_val.update(mode=self.rmHandle.query('PROG:MODE?').strip())
            tmp = self.rmHandle.query('PROG:CRAN?').strip()
            return_val.update(crange=self.options_curr_range_rev[tmp])
            tmp = self.rmHandle.query('PROG:VRAN?').strip()
            return_val.update(vrange=self.options_volt_range_rev[tmp])
            tmp = int(float(self.rmHandle.query('PROG:LOOP?')))
            return_val.update(loop=tmp if tmp < 9999 else 'INF')
            tmp = self.rmHandle.query('PROG:LINP?')
            return_val.update(last_state=self.legal_on_off_rev[int(tmp)])
            return_val.update(last_level=float(self.rmHandle.query('PROG:LVAL?')))
            return_val.update(chain=int(float(self.rmHandle.query('PROG:CHAIN?'))))
            return return_val

        # Check all values before we write anything.
        self._pgm_cfg_check_values(pgm_num, memo, mode, crange, vrange, loop, last_state, last_level)
        crange = self.options_curr_range.get(crange, None)  # translate single letter to 'LOW', etc.
        vrange = self.options_volt_range.get(vrange, None)  # translate single letter to 'LOW', etc.

        if chain is not None and (chain < 0 or chain > 10):
            raise ValueError(f"Bad chain {chain}, should be 0 to 10. (0 ends sequence execution.)")

        # Now that all supplied values pass the checks, write to the instrument.

        if memo is not None:
            self.rmHandle.write(f'PROG:MEMO "{memo}"')
        if mode is not None:
            self.rmHandle.write(f'PROG:MODE {mode}')
        if crange is not None:
            self.rmHandle.write(f'PROG:CRAN {crange}')
        if vrange is not None:
            self.rmHandle.write(f'PROG:VRAN {vrange}')
        if loop is not None:
            if isinstance(loop, str) and loop.upper() == 'INF':
                self.rmHandle.write(f'PROG:LOOP 9999')
            else:
                self.rmHandle.write(f'PROG:LOOP {loop}')
        if last_state is not None:
            self.rmHandle.write(f'PROG:LINP {last_state}')
        if last_level is not None:
            self.rmHandle.write(f'PROG:LVAL {last_level}')
        if chain is not None:
            self.rmHandle.write(f'PROG:CHAIN {chain}')

        self.debug_print()

    def pgm_fast_cfg(self, memo=None, mode=None, crange=None, vrange=None, loop=None, last_state=None, last_level=None,
                     end_step=None, dwell_sec=None):
        """Configure the parameters that are common to a Program that runs as a Fast Sequence.
        Use the methods pgm_fast_edit to edit steps that make up the sequence.

        Args:
            memo:    String of up to 11 characters that describes the program.
            mode:    Identifies load operating mode for the sequence. One of 'CC', 'CR', 'CV', 'CP'.
            crange:  Current range" 'L", 'M', 'H'. Use method ratings to see the numerical values.
            vrange:  Voltage range" 'L", 'H'. Use method ratings to see the numerical values.
            loop:    Repeat the program this many times. Value 1-9998 or 'INF'.
            last_state: The state of the load, 'ON' or 'OFF' after the sequence ends.
            last_level: The level after the sequence ends. Depending on mode this is a conductance, current, voltage or
                        power number.
            end_step: The index (one based) of the final step in the sequence, max value 1024.
            dwell_sec: The time interval between all points. Can be 25-6 sec to 100e-3 seconds.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]:MEMO "<string>"
            PROGram[:SELected]:MODE {NCC|NCR|NCV|NCP|FCC|FCR}
            PROGram[:SELected]:CRANge {LOW|MEDium|HIGH}
            PROGram[:SELected]:VRANge {LOW|HIGH}
            PROGram:LOOP
            PROGram[:SELected]:LINPut {ON|OFF|1|0}
            PROGram[:SELected]:LVALue {<numeric>|MINimum|MAXimum}
            PROGram[:SELected]:FSPeed[:STEP]:END <NR1>
            PROGram[:SELected]:FSPeed:TIME {<numeric>|MINimum|MAXimum}
        """

        # Determines which program subsequent commands operate on.
        self.rmHandle.write('PROG:NAME 11')

        # No Args, perform queries on all values and return as a dict.
        if all(v is None for v in {memo, mode, crange, vrange, loop, last_state, last_level, end_step, dwell_sec}):
            return_val = dict()
            tmp = self.rmHandle.query(f'PROG:MEMO?').rstrip('\n').strip('"').strip()
            return_val.update(memo='' if tmp.isspace() else tmp)
            return_val.update(mode=self.rmHandle.query(f'PROG:MODE?').strip())
            tmp = self.rmHandle.query('PROG:CRAN?').strip()
            return_val.update(crange=self.options_curr_range_rev[tmp])
            tmp = self.rmHandle.query('PROG:VRAN?').strip()
            return_val.update(vrange=self.options_volt_range_rev[tmp])
            tmp = int(float(self.rmHandle.query('PROG:LOOP?')))
            return_val.update(loop=tmp if tmp < 9999 else 'INF')
            tmp = self.rmHandle.query(f'PROG:LINP?')
            return_val.update(last_state=self.legal_on_off_rev[int(tmp)])
            return_val.update(last_level=float(self.rmHandle.query(f'PROG:LVAL?')))
            return_val.update(end_step=int(float(self.rmHandle.query(f'PROG:FSP:END?'))))
            return_val.update(dwell_sec=float(self.rmHandle.query(f'PROG:FSP:TIME?')))
            return return_val

        # Check all values before we write anything.

        self.debug_print()

        self._pgm_cfg_check_values(11, memo, mode, crange, vrange, loop, last_state, last_level)
        crange = self.options_curr_range.get(crange, None)  # translate single letter to 'LOW', etc.
        vrange = self.options_volt_range.get(vrange, None)  # translate single letter to 'LOW', etc.

        if end_step is not None and (end_step < 1 or end_step > 1024):
            raise ValueError(f"Bad end_step {end_step}, should be 1 to 1024.")

        if dwell_sec is not None and (dwell_sec < 25e-6 or dwell_sec > 100e-3):
            raise ValueError(f"Bad dwell_sec {dwell_sec}, should be 25e-6 to 100e-3 sec.")

        if memo is not None:
            self.rmHandle.write(f'PROG:MEMO "{memo}"')
        if mode is not None:
            self.rmHandle.write(f'PROG:MODE {mode}')
        if crange is not None:
            self.rmHandle.write(f'PROG:CRAN {crange}')
        if vrange is not None:
            self.rmHandle.write(f'PROG:VRAN {vrange}')
        if loop is not None:
            if isinstance(loop, str) and loop.upper() == 'INF':
                self.rmHandle.write(f'PROG:LOOP 9999')
            else:
                self.rmHandle.write(f'PROG:LOOP {loop}')
        if last_state is not None:
            self.rmHandle.write(f'PROG:LINP {last_state}')
        if last_level is not None:
            self.rmHandle.write(f'PROG:LVAL {last_level}')
        if end_step is not None:
            self.rmHandle.write(f'PROG:FSP:END {end_step}')
        if dwell_sec is not None:
            self.rmHandle.write(f'PROG:FSP:TIME {dwell_sec}')

        self.debug_print()

    def pgm_info(self, pgm_num):
        """Retrieves from the instrument all the programming information for the specified Program
        number including any steps that have been defined.

        Args:
              pgm_num: 1-10 are Normal programs, 11 is reserved for Fast programs.
                    Normal programs are limited to a combined total of 256 steps, each with its own dwell_sec time.
                    Normal programs can be chained to together to execute one after another.
                    Fast programs may have up to 1024 steps, all sharing a common dwell_sec time. Fast programs cannot
                    be chained together.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            Call pgm_norm_cfg or pgm_fast_cfg
            PROGram[:SELected]: NSPeed[:STEP]:COUNt?
            Call pgm_norm_read
        """

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')

        self.rmHandle.write(f'PROG:NAME {pgm_num}')

        steps = []
        if pgm_num > 10:
            pgm_cfg = self.pgm_fast_cfg()
            num_steps = int(self.rmHandle.query('PROG:FSP:END?'))
            for step_idx in range(1, num_steps + 1):
                tmp = self.rmHandle.query(f'PROG:FSP:EDIT? {step_idx}').strip().split(',')
                steps.append([float(tmp[0]), int(tmp[1])])
        else:
            pgm_cfg = self.pgm_norm_cfg(pgm_num)
            num_steps = int(self.rmHandle.query('PROG:NSP:COUN?'))
            for step_idx in range(1, num_steps + 1):
                tmp = self.rmHandle.query(f'PROG:NSP:EDIT? {step_idx}').strip().split(',')
                steps.append([float(tmp[0]), float(tmp[1]), int(tmp[2]), int(tmp[3]), int(tmp[4]), int(tmp[5])])

        return {'pgm_num': pgm_num, 'pgm_cfg': pgm_cfg, 'num_steps': num_steps, 'steps': steps}

    def pgm_save(self, pgm_num, filename, use_arrays=True):
        """Save the Program Sequence as a Python module that provides a function pgm_restore. When executed pgm_restore
           will write the cfg and step information into the specified Program Sequence location in the PLZ instrument.
        """

        fileobj = open(filename, mode='w')
        modulename = os.path.splitext(os.path.basename(filename))[0]

        info = self.pgm_info(pgm_num)
        cfg_args = [f"{k}={repr(v)}" for k, v in info['pgm_cfg'].items()]
        cfg_args = ', '.join(cfg_args)

        chain_warn_msg = ''

        if pgm_num < 11:
            # Determine if we have dependency on another program.
            if info['pgm_cfg']['chain'] != 0:
                chain_warn_msg = "This program chains to another program expected to be at " + \
                                 f"pgm_num={info['pgm_cfg']['chain']}!"
                print(chain_warn_msg)

            # Print module header docstring.
            print(f'"""', end='', file=fileobj)
            print(f"Saved PLZ Normal Program Sequence, memo=\"{info['pgm_cfg']['memo']}\".\n", file=fileobj)
            print("To recall this sequence into your PLZ instrument, do this:\n\n"
                  f"import {modulename}\n"
                  f"{modulename}.pgm_norm_recall(plz_obj, pgm_num)\n"
                  "\nwhere:\n"
                  "plz_obj is the instmngr PLZ object controlling your PLZ, and\n"
                  "pgm_num specifies the Program location within the instrument.\n", file=fileobj)
            if chain_warn_msg:
                print(f'{chain_warn_msg}\n', file=fileobj)

            print("If you make changes to this file after importing it, to have your changes take effect you\n"
                  "must reimport using the imp.reload function from Python's imp package.", file=fileobj)
            print(f'"""\n', file=fileobj)

            # Print start of function definition.
            print(f"\ndef pgm_norm_recall(plz_obj, pgm_num):", file=fileobj)

            # Print function docstring.
            print(f'    """', end='', file=fileobj)
            print(f'Recalls a saved PLZ Normal Sequence into the specified PLZ instrument and pgm_num.\n',
                   file=fileobj)
            print('    Args:', file=fileobj)
            print('        plz_obj: An object of the Load_PLZ164WL or Load_PLZ334WL class corresponding to the\n'
                  '                  target machine to be programed with this sequence. Obtained from the instmngr\n'
                  '                  checkout method.', file=fileobj)
            print('        pgm_num: The program sequence number where these setting will be placed in the target \n'
                  '                 machine. Kikusui refers to the as the Seq No. on the front panel LCD and as \n'
                  '                 PROG:NAME in the SCPI commands.', file=fileobj)
            if chain_warn_msg:
                print(f'\n    {chain_warn_msg}', file=fileobj)
            print('    """\n', file=fileobj)

            # Put this in the function to remind user when they execute a recall.
            if chain_warn_msg:
                print(f'    print("{chain_warn_msg}")\n', file=fileobj)

            print(f"    plz_obj.pgm_norm_cfg(pgm_num, {cfg_args})\n", file=fileobj)

            print("    plz_obj.pgm_norm_del(pgm_num, 'ALL')\n", file=fileobj)

            step_keys = ('level', 'dwell_sec', 'state', 'ramp', 'trig', 'pause')
            print_width = 100
            for i, params in enumerate(info['steps']):
                args = [f"{k}={repr(v)}" for k, v in zip(step_keys, params)]
                args = ', '.join(args)
                text = f'    plz_obj.pgm_norm_add(pgm_num, {args})  '
                line_len = len(text)
                print_width = max(print_width, line_len)
                pad = " " * (print_width - line_len)
                print(f"{text}{pad}# {i+1}", file=fileobj)

        else:
            # Print module header docstring.
            print(f'"""', end='', file=fileobj)
            print(f"Saved PLZ Fast Program Sequence, memo=\"{info['pgm_cfg']['memo']}\".\n", file=fileobj)
            print(f"To recall this sequence into your PLZ instrument, do \n"
                  f"import {modulename}\n"
                  f"{modulename}.pgm_fast_recall(plz_obj)\n"
                  "\nwhere plz_obj is the instmngr PLZ object controlling your PLZ.", file=fileobj)

            print("\nIf you make changes to this file after importing it, to have your changes take effect you\n"
                  "must use the imp.reload function from the imp package.", file=fileobj)
            print(f'"""\n', file=fileobj)

            print('import numpy as np\n', file=fileobj)

            # Print start of function definition.
            print(f"def pgm_fast_recall(plz_obj):", file=fileobj)

            # Print function docstring.
            print(f'    """', end='', file=fileobj)
            print(f'Recalls a saved PLZ Fast Sequence into the specified PLZ instrument.\n',
                  file=fileobj)
            print('    Args:', file=fileobj)
            print('        plz_obj: An object of the Load_PLZ164WL or Load_PLZ334WL class corresponding to the\n'
                  '                  target machine to be programed with this sequence. Obtained from the instmngr\n'
                  '                  checkout method.', file=fileobj)
            print('    """\n', file=fileobj)

            print(f"    plz_obj.pgm_fast_cfg({cfg_args})", file=fileobj)

            data_dict = self.pgm_fast_arrays()

            if use_arrays:
                # Dump out as tuple of two element tuples, for ease of editing.
                print(f"    level_trig = (", file=fileobj)
                print('         # level   trig  Kikusui Step No.', file=fileobj)
                prev_end = ''
                for i, (level, trigger) in enumerate(zip(data_dict['levels'], data_dict['triggers'])):
                    print(f'{prev_end}', end='', file=fileobj)
                    print(f"{' '*8}({level:4f}, {trigger:1d})", end='', file=fileobj)
                    prev_end = f',   # {i+1}\n'
                print(f'{prev_end}    )', file=fileobj)

                print('\n    # Convert tuples to separate numpy arrays. ', file=fileobj)
                print(f'    levels = np.array([d[0] for d in level_trig])', file=fileobj)
                print(f'    triggers = np.array([d[1] for d in level_trig])', file=fileobj)

                print('', file=fileobj)
                print(f"    plz_obj.pgm_fast_cfg(end_step=len(level_trig))  # In case someone edits the array",
                      file=fileobj)
                print('    plz_obj.pgm_fast_arrays(levels, triggers)', file=fileobj)
            else:
                print('', file=fileobj)
                step_keys = ('level', 'trig')
                for i, params in enumerate(info['steps']):
                    args = [f"{k}={repr(v)}" for k, v in zip(step_keys, params)]
                    args = ', '.join(args)
                    print(f'    plz_obj.pgm_fast_edit(step_idx={i+1}, {args})', file=fileobj)

        fileobj.flush()
        fileobj.close()

    def pgm_ctrl(self, pgm_num, pgm_state):
        """Controls execution of the specified Program sequence.

        Args:
            pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
            pgm_state:
                TRUN: Set the program to execute using a trigger (valid only for Normal Sequences). Use GPIB bus
                      trigger command: "*TRG'.
                RUN:   Execute the selected program.
                STOP:  Stop execution of the program.
                PAUSE: Pause sequence execution.
                CONT:  Resume sequence execution.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]:EXECuting?
            PROGram[:SELected]:STATe {TRUN|RUN|STOP|PAUSe|CONTinue}
        """

        self.debug_print()

        # TODO: Figure out what happens if another pgm is already running.
        # See if there is already a program executing.
        # status = pgm_status(self)
        # if status['status'] in ('TRUN', 'RUN', 'PAUS'):

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')
        self.rmHandle.write(f'PROG:NAME {pgm_num}')

        if pgm_num == 11 and pgm_state == 'TRUN':
            raise ValueError('TRUN cannot be used with Fast Sequence.')

        if pgm_state.upper() not in self.options_pgm_status:
            msg = ", ".join([f"'{x}'" for x in self.options_pgm_status])
            raise ValueError(f"Bad pgm_status '{pgm_state}'. Should be one of: {msg}.")

        self.rmHandle.write(f'PROG:STAT {pgm_state.upper()}')

        self.debug_print()

    def pgm_status(self):
        """Queries status of the program sequence engine, returns dictionary containing 'pgm_num', 'status',
         'exec_time', 'step_idx', 'loop_num'.
        """

        tmp = self.rmHandle.query('PROG:EXEC?').strip().split(',')
        return {'pgm_num': tmp[4], 'status': tmp[0], 'exec_time': float(tmp[1]), 'step_idx': int(tmp[3]),
                'loop_num': int(tmp[2])}

    def pgm_clear(self, pgm_num):
        """Deletes the specified Program: all cfg parameters are reset to defaults and all steps are deleted.

        Args:
            pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram:CLEar
        """

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')

        self.rmHandle.write(f'PROG:NAME {pgm_num}')
        self.rmHandle.write('PROG:CLE')

    def pgm_norm_read(self, pgm_num, step_idx):
        """Reads from the instrument the data associated with the specified Normal Sequence Program and step within the
        program. Returns data as a dictionary.

        Args:
            pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
            step_idx: Index of the step within the program. First step is step_idx=1.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]:NSPeed[:STEP]:EDIT? <step_NR1>
        """

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')

        self.rmHandle.write(f'PROG:NAME {pgm_num}')

        tmp = self.rmHandle.query(f'PROG:NSP:EDIT? {step_idx}').strip().split(',')
        return_val = dict()
        return_val.update(value=float(tmp[0]))
        return_val.update(dwell=float(tmp[1]))
        return_val.update(state=self.legal_on_off_rev[int(tmp[2])])
        return_val.update(ramp=self.legal_on_off_rev[int(tmp[3])])
        return_val.update(trig=self.legal_on_off_rev[int(tmp[4])])
        return_val.update(pause=self.legal_on_off_rev[int(tmp[5])])
        return return_val

    def pgm_fast_read(self, step_idx):
        """Reads from the instrument the data associated with the specified Fast Sequence Program and the step within
        the program. Returns data as a dictionary.

        Args:
            step_idx: Index of the step within the program. First step is step_idx=1.

            PROGram[:SELected]:FSPeed[:STEP]:EDIT[:POINt]? <step_NR1>
        """

        tmp = self.rmHandle.query(f'PROG:FSP:EDIT? {step_idx}').strip().split(',')
        return_val = dict()
        return_val.update(value=float(tmp[0]))
        return_val.update(trig=self.legal_on_off_rev[int(tmp[1])])
        return return_val

    def pgm_fast_edit(self, step_idx, level=None, trig=None):
        """Edits level or trig fields of a step in a Fast program sequence.

        Args:
            step_idx: Index of the step within the program. First step is step_idx=1.
            level: The level the step transitions to. What this represents (current, voltage,
                    conductance, or power) depends upon the mode defined in the pgm_cfg.
            trig:  1: Output a pulse on the front panel BNC connector when this step is executed.

        Returns:
            step count as read from the instrument.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]:FSPeed[:STEP]:EDIT[:POINt] <step_NR1>,<value_numeric>[,<trig_NR1>]
        """

        self.debug_print()

        self.rmHandle.write('PROG:NAME 11')

        if step_idx < 1 or step_idx > 1024:
            # TODO: What happens if step_nums are not supplied sequentially? Jumps past the current end?
            raise ValueError(f"Bad step_idx {step_idx}, should be 1 to 1024.")

        if level is not None:
            mode = self.rmHandle.query('PROG:MODE?').strip()
            crange = self.rmHandle.query('PROG:CRAN?').strip()[0]
            vrange = self.rmHandle.query('PROG:VRAN?').strip()[0]

            min_val, max_val, units = self._pgm_stepval_limits(mode, crange, vrange)
            if level < min_val or level > max_val:
                raise ValueError(f"Bad level {level}, should be 0 to {max_val}.")

        if trig is not None:
            bool_msg = "0, 1, 'ON', 'OFF'"
            if trig not in (0, 1, 'ON', 'OFF'):
                raise ValueError(f"Bad state {trig}, should be one of {bool_msg}.")

        level_setting, trig_setting = level, trig
        if level is None or trig is None:
            # Same SCPI commamnd sets both so do read to get the other one..
            tmp = self.rmHandle.query(f'PROG:FSP:EDIT? {step_idx}').strip().split(',')
            level_setting = float(tmp[0]) if level is None else level
            trig_setting = int(tmp[1]) if trig is None else trig

        self.rmHandle.write(f'PROG:FSP:EDIT {step_idx}, {level_setting}, {trig_setting}')

        self.debug_print()

    def pgm_fast_arrays(self, levels=None, triggers=None):
        """Reads or writes entire arrays that define the levels and trigger locations of a fast program sequence.

        Args:
            levels: A list or numpy array of values that make up the voltage, current, power or conductance sequence.
            triggers: Elements of this array are in 1:1 correspondence with those of levels. A 1 in this array results
                    in a trigger pulse being output when the corresponding sample is being output.

        SCPI Commands:
            PROGram[:SELected]:FSPeed[:STEP]:END <NR1>
            PROGram[:SELected]:FSPeed[:STEP]:EDIT[:POINt] <step_NR1>,<value_numeric>[,<trig_NR1>]
        """

        self.debug_print()

        if levels is None and triggers is None:
            num_steps = int(self.rmHandle.query('PROG:FSP:END?'))
            levels = np.empty(num_steps, float)
            triggers = np.empty(num_steps, int)
            for i in range(num_steps):
                tmp = self.rmHandle.query(f'PROG:FSP:EDIT? {i+1}').strip().split(',')
                levels[i] = tmp[0]
                triggers[i] = tmp[1]
            return_val = dict()
            return_val.update(levels=levels)
            return_val.update(triggers=triggers)
            return return_val

        if levels is None or triggers is None:
            raise ValueError(f'Must specify both arrays:  levels and triggers.')

        levels_len = len(levels)
        triggers_len = len(triggers)
        if levels_len != triggers_len or levels_len < 1 or levels_len > 1024:
            raise ValueError(f'Arrays levels ({levels_len}) and triggers ({triggers_len}) must be same length, '
                             '1 to 1024 elements.')

        mode = self.rmHandle.query('PROG:MODE?').strip()
        crange = self.rmHandle.query('PROG:CRAN?').strip()[0]
        vrange = self.rmHandle.query('PROG:VRAN?').strip()[0]

        min_val, max_val, units = self._pgm_stepval_limits(mode, crange, vrange)
        msg = self._check_list_values('levels', levels, min_val, max_val, units, self.cfg_max_disp_list_errors)
        if msg:
            raise ValueError(msg)

        msg = self._check_list_values('triggers', triggers, 0, 1, '', self.cfg_max_disp_list_errors)
        if msg:
            raise ValueError(msg)

        for i in range(levels_len):
            self.rmHandle.write(f'PROG:FSP:EDIT {i+1}, {levels[i]}, {triggers[i]}')

        self.rmHandle.write(f'PROG:FSP:END {levels_len}')

        self.debug_print()

    @staticmethod
    def _check_list_values(name, values, val_min, val_max, units, show_maxbad):
        """Check an entire list of values and create error message describing which elements are out of bounds."""

        bad_indicies = [i for i, val in enumerate(values) if (val < val_min or val > val_max)]
        num_bad = len(bad_indicies)
        msg = ''
        if num_bad > 0:
            show_bad = min(num_bad, show_maxbad)
            msg = f"{name} contains {num_bad} values outside range {val_min} to {val_max} {units}. "
            if num_bad > show_bad:
                msg += f"The first {show_bad} are:\n"
            else:
                msg += "They are:\n"
            msg += ",\n".join([f"    {name}[{bad_indicies[i]}]={values[bad_indicies[i]]}" for i in range(show_bad)])

        return msg

    def _pgm_norm_step_checks(self, pgm_num, level, dwell_sec, state, ramp, trig, pause):
        """Used to check the values associated with adding, inserting or editing a step in a Normal Program sequnece."""

        if pgm_num < 1 or pgm_num > 10:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences.')
        self.rmHandle.write(f'PROG:NAME {pgm_num}')

        if level is not None:
            mode = self.rmHandle.query('PROG:MODE?').strip()
            crange = self.rmHandle.query('PROG:CRAN?').strip()[0]
            vrange = self.rmHandle.query('PROG:VRAN?').strip()[0]

            min_val, max_val, units = self._pgm_stepval_limits(mode, crange, vrange)
            if level < min_val or level > max_val:
                raise ValueError(f"Bad level {level}, should be {min_val} to {max_val} {units} for" +
                                 "crange='{crange}', vrange={vrange}")

        if dwell_sec is not None and (dwell_sec < 0.001 or dwell_sec > 3599940):
            raise ValueError(f"Bad dwell_sec {dwell_sec}, should be 0.001 to 3599940 sec.")

        bool_msg = "0, 1, 'ON', 'OFF'"
        if state is not None and state not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad state {state}, should be one of {bool_msg}.")
        if ramp is not None and ramp not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad state {ramp}, should be one of {bool_msg}.")
        if trig is not None and ramp not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad state {trig}, should be one of {bool_msg}.")
        if pause is not None and pause not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad state {pause}, should be one of {bool_msg}.")

    def pgm_norm_add(self, pgm_num, level, dwell_sec, state, ramp, trig, pause):
        """Appends a new step to the end of the specified Normal Program.

        Args:
            pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence.
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
            level: The level the step transitions to. What this represents (current, voltage,
                    conductance, or power) depends upon the mode defined in the pgm_cfg.
            dwell_sec: Time duration of the step in seconds. 0.001 to 3599940 sec. (999h59min).
            state: The load state ('ON' or 'OFF' at the end of the dwell_sec time.
            ramp: Defines how the level transitions.
                0: load transitions instantly to the specified level which is sustained for the dwell_sec time..
                1: load transitions to the new level as a linear ramp over the dwell_sec time.
            trig:  1: Output a pulse on the front panel BNC connector when this step is executed.
            pause: 1: Pause during execution of this step.

        Returns:
            step count as read from the instrument.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]: NSPeed[:STEP]:ADD < value_numeric >, < time_numeric > [, < load_bool >][, < ramp_bool >]
              [, < trig_bool >][, < pause_bool >]
        """

        if any(v is None for v in {pgm_num, level, dwell_sec, state, ramp, trig, pause}):
            raise ValueError("None values for parameters not permitted here.")

        self. _pgm_norm_step_checks(pgm_num, level, dwell_sec, state, ramp, trig, pause)

        self.rmHandle.write(f'PROG:NSP:ADD {level}, {dwell_sec}, {state}, {ramp}, {trig}, {pause}')

        return int(self.rmHandle.query('PROG:NSP:COUN?'))

    def pgm_norm_del(self, pgm_num, step_idx):
        """Deletes the step at step_Idx from the specified Normal Program.

        Args:
            pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
            step_idx: Index of the step within the program. First step is step_idx=1.
                      Use step_idx = 'ALL' to delete all the steps.

        Returns:
            step count as read from the instrument.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]:NSPeed[:STEP]:DELete[:STEP]
            PROGram[:SELected]:NSPeed[:STEP]:DELete:ALL
        """

        if pgm_num < 1 or pgm_num > 10:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences.')
        self.rmHandle.write(f'PROG:NAME {pgm_num}')

        if isinstance(step_idx, int):
            num_steps = int(self.rmHandle.query('PROG:NSP:COUN?'))
            if step_idx > num_steps:
                raise ValueError(f"Bad step_idx {step_idx}, only {num_steps} are currently defined.")
            self.rmHandle.write(f'PROG:NSPeed:DEL {step_idx}')
        elif isinstance(step_idx, str) and step_idx.upper() == 'ALL':
            self.rmHandle.write('PROG:NSP:DEL:ALL')
        else:
            raise ValueError(f"Bad step_idx {step_idx}, should be a specific step 1 - 256, or 'ALL'.")

        return int(self.rmHandle.query('PROG:NSP:COUN?'))

    def pgm_norm_edit(self, pgm_num, step_idx, level=None, dwell_sec=None, state=None, ramp=None, trig=None,
                      pause=None):
        """Allow modification of any of the values of an existing step of the specified Normal Program.

        Args:
            pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
            step_idx: Index of the step within the program. First step is step_idx=1.
            level: The level the step transitions to. What this represents (current, voltage,
                   conductance, power) depends upon the mode in the pgm_cfg.
            dwell_sec: Time duration of the step in seconds. 0.001 to 3599940 sec. (999h59min).
            state: The load state ('ON' or 'OFF' at the end of the dwell_sec time.
            ramp:
                0: load transitions instantly to the specified level which is sustained for the dwell_sec time..
                1: load transitions to the new level as a linear ramp over the dwell_sec time.
            trig:  Output a pulse on the front panel BNC connector when this step is executed.
            pause: 'ON' = Pause during execution of this step.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]: NSPeed[:STEP]:EDIT < step_NR1 >, < value_numeric >, < time_numeric > [, < load_bool >]
              [, < ramp_bool >][, < trig_bool >][, < pause_bool >]
        """

        # Note that None values are allowed in this case in order to support individual parameter modifications.

        self._pgm_norm_step_checks(pgm_num, level, dwell_sec, state, ramp, trig, pause)

        # Do a read-modify-write operation.
        tmp = self.rmHandle.query(f'PROG:NSP:EDIT? {step_idx}').strip().split(',')

        if level is None:
            level = tmp[0]
        if dwell_sec is None:
            dwell_sec = tmp[1]
        if state is None:
            state = tmp[2]
        if ramp is None:
            ramp = tmp[3]
        if trig is None:
            trig = tmp[4]
        if pause is None:
            pause = tmp[5]

        self.rmHandle.write(f'PROG:NSP:EDIT {step_idx}, {level}, {dwell_sec}, {state}, {ramp}, {trig}, {pause}')

    def pgm_norm_insert(self, pgm_num, step_idx, level, dwell_sec, state, ramp, trig, pause):
        """Insert a new program step ahead of the existing step at step_idx in specified
        Normal Program.

        Args:
            pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
            step_idx: Index of the step within the program. First step is step_idx=1.
            level: The level the step transitions to. What this represents (current, voltage,
                   conductance, power) depends upon the mode in the pgm_cfg.
            dwell_sec: Time duration of the step in seconds. 0.001 to 3599940 sec. (999h59min).
            state: The load state ('ON' or 'OFF' at the end of the dwell_sec time.
            ramp:
                0: load transitions instantly to the specified level which is sustained for teh dwell_sec time..
                1: load transitions to the new level as a linear ramp over the dwell_sec time.
            trig:  Output a pulse on the front panel BNC connector when this step is executed.
            pause: 'ON' = Pause during execution of this step.

        SCPI Commands:
            PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
            PROGram[:SELected]:NSPeed[:STEP]:INSert <step_NR1>,<value_numeric>,<time_numeric>[,<load_bool>]
              [,<ramp_bool>][,<trig_bool>][,<pause_bool>]
        """

        if any(v is None for v in {pgm_num, step_idx, level, dwell_sec, state, ramp, trig, pause}):
            raise ValueError("None values for parameters not permitted here.")

        self. _pgm_norm_step_checks(pgm_num, level, dwell_sec, state, ramp, trig, pause)

        self.rmHandle.write(f'PROG:NSP:INS {step_idx}, {level}, {dwell_sec}, {state}, {ramp}, {trig}, {pause}')

    # ----------------------------------------------------------------------------------------------

    def getIdn(self):
        """ Queries Electronic Load IDN and returns string. """

        return self.rmHandle.query('*IDN?')

    def getError(self):
        """ Queries Electronic Load error buffer and returns string. """

        return self.rmHandle.query('SYST:ERRor?').strip()

    def errlog(self):
        err_cmd = 'SYST:ERR?'
        err_list = []
        while True:
            err_msg = self.rmHandle.query(err_cmd)
            if 'No error' in err_msg:
                break
            else:
                err_list.append(err_msg)
        return err_list

    def debug_print(self):
        if self.debug_print_enable == 0:
            return
        err_list = self.errlog()
        if err_list or self.debug_print_enable == 1:
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            caller = frame_record[3]
            lineno = frame_record[2]
            print(f"debug print:{filename}:{caller} line {lineno} inst errors: {err_list}")

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = int(self.rmHandle.query('*STB?').rstrip())

        conditions = {'CSUM': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPER': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending '*CLS, command."""

        self.rmHandle.write('*CLS')

    def close(self):
        # TODO: might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()



if __name__ == "__main__":
    import os

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    import InstMgr
    from pprint import pprint

    instMgr = InstMgr.InstMgr()
    load = instMgr.checkout(objName='load', interface='GPIB', addr=1, moduleSuffix='PLZ164WL')

    ps = instMgr.checkout(objName='supply', interface='GPIB', addr=9, moduleSuffix='PSM6003')
    scope = instMgr.checkout(objName='oscope', interface='USB', addr='0x0699::0x0503::C010643', moduleSuffix='DPO5034')

    # Setup for load debug
    scope.setInstParam('ch1position', -4)
    scope.setInstParam('ch1voltPerDiv', 0.5)
    scope.setInstParam('ch1bandwidth', 'FULL')

    scope.setInstParam('triggerLevel', .25)
    scope.setInstParam('triggerMode', 'normal')
    scope.setInstParam('triggerHoldoff', 'time')
    scope.setInstParam('triggerHoldofftime', 0)

    scope.setInstParam('acqMode', 'hirez')
    scope.setInstParam('secPerDiv', 5e-3)
    scope.setInstParam('horizPosition', 10)
    scope.setInstParam('runSingle', 'continuous')
    scope.setInstParam('runState', 'run')

    scope.trig_force()

    load.reset()
    load.state('off')
    load.mode('CC')
    load.range('CURR', 'L')
    load.level('CURR', 0.25)
    load.dynamics(cc_slew=0.2)

    load.state('on')

    scope.getScreenShot(r'C:\Users\dkaroly\Documents\sandbox_dek\python\scrnshot.png')
    # print(load.getIdn())
