# -*- coding: utf-8 -*-
"""
@author: dkaroly
"""

import sys
import time

idnString = 'N7950A'

class Supply_N7950A:
    """Class for controlling Keysight N7950A power supply"""

    rating_volts = 9
    rating_amps = 100
    rating_ohms = 0.1

    # Define these as a attributes because several methods use them.
    # NOTE: Multiple keys map to same item for compatibility with PSM, PBZ and PSI.
    options_meas_item = {
        'CURR': 'CURR:DC',             # PSI9040, PSM6003 / 2010
        'CURRENT_DC': 'CURR:DC',       # N795xA, PBZ2020
        'CURRENT_RMS': 'CURR:ACDC',    # N795xA, PBZ2020
        'CURRENT_PK_MAX': 'CURR:MAX',  # N795xA, PBZ2020
        'CURRENT_PK_MIN': 'CURR:MIN',  # N795xA, PBZ2020
        'CURRENT_HIGH': 'CURR:HIGH',   # N795xA
        'CURRENT_LOW': 'CURR:LOW',     # N795xA

        'VOLT': 'VOLT:DC',             # PSI9040, PSM6003 / 2010
        'VOLTS_DC': 'VOLT:DC',         # N795xA, PBZ2020
        'VOLTS_RMS': 'VOLT:ACDC',      # N795xA, PBZ2020
        'VOLTS_PK_MAX': 'VOLT:MAX',    # N795xA, PBZ2020
        'VOLTS_PK_MIN': 'VOLT:MIN',    # N795xA, PBZ2020
        'VOLTS_HIGH': 'VOLT:HIGH',     # N795xA
        'VOLTS_LOW': 'VOLT:LOW',       # N795xA

        'POW': 'POW',                  # PSI9040, PSM6003 / 2010
        'POW_DC': 'POW',               # N795xA
        'POW_MAX': 'POW:MAX',          # N795xA
        'POW_MIN': 'POW:MIN',          # N795xA
    }
    legal_on_off = {'ON': 1, 'OFF': 0}
    legal_on_off_rev = dict((v, k) for k, v in legal_on_off.items())

    options_opmode = {'CC': 'CURR', 'CV': 'VOLT'}
    options_transient_mode = ('FIX', 'STEP', 'LIST', 'ARB')

    options_trigger_sources = (
        'BUS', 'EXT',
        'EXPR1', 'EXPR2', 'EXPR3', 'EXPR4', 'EXPR5', 'EXPR6', 'EXPR7', 'EXPR8',
        'IMMED',
        'PIN1', 'PIN2', 'PIN3', 'PIN4', 'PIN5', 'PIN6', 'PIN7', 'PIN8'
    )

    options_acq_trigger_sources = (
        'BUS', 'CURR1', 'EXT'
        'EXPR1', 'EXPR2', 'EXPR3', 'EXPR4', 'EXPR5', 'EXPR6', 'EXPR7', 'EXPR8',
        'PIN1', 'PIN2', 'PIN3', 'PIN4', 'PIN5', 'PIN6', 'PIN7', 'PIN8',
        'TRAN1', 'VOLT1'
    )

    options_delay_start = ('SCH', 'CCTR')

    options_output_z = ('HIGHZ', 'LOWZ')
    options_relay_polarity = ('NORM', 'REV')

    options_arbtype = ('CURR', 'VOLT')
    options_window_type = ('HANN', 'RECT')

    options_list_step = ('ONCE', 'AUTO')

    options_digital_pin_function = (
        'DIO', 'DINP',
        'EXPR1', 'EXPR2', 'EXPR3', 'EXPR4', 'EXPR5', 'EXPR6', 'EXPR7', 'EXPR8',
        'FAULT', 'INHIBIT',
        'ONCOUPLE', 'OFFCOUPLE', 'TINPUT', 'TOUTPUT'
    )
    options_digital_pin_polarity = ('POS', 'NEG')

    def __init__(self, rmHandle):
        """ Constructs an object of class Supply_N7950A.

        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using
                       :meth:'pyvisa.highlevel.ResourceManager.open_resource'.
        """

        self.rmHandle = rmHandle

        self.cfg_timeout = 5
        self.cfg_max_disp_list_errors = 10

        self.status_clear()      # Clears all previous errors that might block command execution.

        # Propagate everything to the status byte - same as PSI9040 and PBZ.
        self.rmHandle.write(f"STAT:OPER:ENAB {0x1FF}")
        self.rmHandle.write(f"STAT:QUES1:ENAB {0x3FFF}")
        self.rmHandle.write(f"STAT:QUES2:ENAB {0x7F}")

    # ---------------------------------------------------------------------------

    def reset(self):
        """ Resets the Power Supply to factory defaults, turns output off.

            NOTE: Sets status enable registers to all bits in OPER, QUES1 and QUES2
            to propagate into the Status Byte register..
        """

        self.rmHandle.write('*RST')

        # Propagate everything to the status byte - same as PSI9040 and PBZ.
        self.rmHandle.write(f"STAT:OPER:ENAB {0x1FF}")
        self.rmHandle.write(f"STAT:QUES1:ENAB {0x3FFF}")
        self.rmHandle.write(f"STAT:QUES2:ENAB {0x7F}")

    # ---------------------------------------------------------------------------

    # N7950A - a proposed API

    # basic supply functionality

    def mode(self, opmode=None):
        """Queries or sets voltage priority or current priority mode.
        For consistency with previous supplies this API uses the 'CV' and 'CC'
        to denote these two operating modes.

        Args:
            opmode:
                'CV': Voltage Priority mode - operates a voltage source
                'CV': Current Priority mode - operates a current source

        SCPI Commands used:
            FUNC CURR|VOLT
        """

        legal_modes_rev = dict((v, k) for k, v in self.options_opmode.items())

        if opmode is None:
            return legal_modes_rev[self.rmHandle.query(f"FUNC?").strip()]

        if opmode.upper() not in self.options_opmode:
            msg = ", ".join([f"'{x}'" for x in self.options_opmode])
            raise ValueError(f"Bad opmode '{opmode}', should be one of: {msg}.")

        self.rmHandle.write(f"FUNC {self.options_opmode[opmode]}")

    def value(self, voltage=None, ilimit=None):
        """ Queries or sets both the voltage output level and the current
            compliance limit for operation in Constant Voltage (CV) opmode.
            This method provided for compatibility with previous supplies.
			Calls method cv_mode.

            Args:
                voltage (None or numeric) : Voltage to output in Volts.
                ilimit ( None or numeric) : Current limit to set in Amps.

            Return:
                If both voltage and ilimit are None, then the Power Supply is
                queried and the present voltage and current settings are
                returned as a list of two float values.

            NOTE:
                Voltage and ilimit may be both set together. Specifying a
                voltage value with ilimit=None retains the existing ilimit.
                Specifying voltage=None with a ilimit value retains the
                existing voltage level.

                This method is functionally equivalent to cv_mode and is retained
                for backwards compatibility.
        """

        ret_val = self.cv_mode(voltage, ilimit)

        if all(v is None for v in {voltage, ilimit}):
            return [val for key, val in ret_val.items()]

    def cv_mode(self, voltage=None, ilimit=None, ilimit_sink=None):
        """Queries or sets voltage voltage and current limit parameters associated with
        operation in voltage priority ('CV') mode.
        Method name chosen for compatibility with previous supplies.

         Args:
             voltage: Output voltage, float value 0 to 102% of rated voltage.
             ilimit:  Limit for sourcing current, 0 to 102% of rated current.
             ilimit_sink: Limit for sinking current, -10.2% rated current to 0.
                          This is without the optional external N7909A power dissipater.

        NOTES: * Rated values are class attributes: rating_volts, rating_amps.
               * If Over Current Protection is enabled (see method ocp_state), then
               output will be switched off rather than just limited.

         SCPI Commands used:
            [SOURce:]VOLTage[:LEVel][:IMMediate][:AMPLitude] <value>|MIN|MAX
            [SOURce:]CURRent:LIMit[:POSitive][:IMMediate][:AMPLitude] <value>|MIN|MAX
            [SOURce:]CURRent:LIMit:NEGative[:IMMediate][:AMPLitude] <value>|MIN|MAX
        """

        if all(v is None for v in {voltage, ilimit, ilimit_sink}):
            return_val = dict()
            return_val.update(voltage=float(self.rmHandle.query('VOLT?').strip()))
            return_val.update(ilimit=float(self.rmHandle.query('CURR:LIM?').strip()))
            return_val.update(ilimit_sink=float(self.rmHandle.query('CURR:LIM:NEG?').strip()))
            return return_val

        # Check all supplied arguments before changing any settings.
        if voltage is not None and (voltage < 0 or voltage > 1.02 * self.rating_volts):
            raise ValueError(f"Bad voltage level {voltage}. Should be 0 to {1.02 * self.rating_volts}.")

        if ilimit is not None and (ilimit < 0 or ilimit > 1.02 * self.rating_amps):
            raise ValueError(f"Bad ilimit level {ilimit}. Should be 0 to {1.02 * self.rating_amps} A.")

        if ilimit_sink is not None and (ilimit_sink < -0.102 * self.rating_amps or ilimit_sink > 0):
            raise ValueError(f"Bad ilimit_sink {ilimit_sink}. Should be -{ -0.102 * self.rating_amps} to 0 A.")

        # OK, now change settings to supplied values.
        if voltage is not None:
            self.rmHandle.write(f"VOLT {voltage}")

        if ilimit is not None:
            self.rmHandle.write(f"CURRent:LIM {ilimit}")

        if ilimit_sink is not None:
            self.rmHandle.write(f"CURR:LIM:NEG {ilimit_sink}")

    def cv_transient(self, transient_mode=None, triggered_ampl=None, trig_source=None):
        """Queries or sets parameters for a voltage transient when operating in 
        voltage priority ('CV') mode.

         Args:
             transient_mode: defines type of transient
                'FIX': A fixed voltage, no transient.
                'STEP': Upon receiving the trigger, the voltage output transition to the
                        triggered_ampl value.
                'LIST': Upon receiving the trigger, output a sequence of voltage steps defined
                        using the list_config method. List allows a dwell time per step.
                'ARB': Upon receiving the trigger, output a sequence of voltage steps defined
                       using the arb_config method. Arb levels all share common dwell time.
             triggered_ampl: Used in FIX transient mode, defines new voltage output jumps to when trigger
                        is received.
             trig_source:
                'BUS': Selects GPIB bus trigger ('*TRG')
                'EXT': Selects ALL digital port pins that have been configured as trigger sources.
                'EXPR'<1-8>: Selects a user-defined expression as the trigger source.
                'IMMED': Triggers the transient as soon as it is INITiated.
                'PIN"<1-8>': Selects a digital port pin configured as a trigger input.

        SCPI Commands used:
            [SOURce:]VOLTage:MODE FIXed|STEP|LIST|ARB
            [SOURce:]VOLTage[:LEVel]:TRIGgered[:AMPLitude] <value>|MIN|MAX
            TRIGger:TRANsient:SOURce <source>
        """
        if all(v is None for v in {transient_mode, triggered_ampl, trig_source}):
            return_val = dict()
            return_val.update(transient_mode=self.rmHandle.query('VOLT:MODE?').strip())
            return_val.update(triggered_ampl=float(self.rmHandle.query('VOLT:TRIG?').strip()))
            return_val.update(trig_source=self.rmHandle.query('TRIG:TRAN:SOUR?').strip())
            return return_val

        # Check all supplied arguments before changing any settings.
        if transient_mode is not None and transient_mode not in self.options_transient_mode:
            msg = ", ".join([f"'{x}'" for x in self.options_transient_mode])
            raise ValueError(f"Bad transient_mode '{transient_mode}', should be one of: {msg}.")

        if triggered_ampl is not None and (triggered_ampl < 0 or triggered_ampl > 1.02 * self.rating_volts):
            raise ValueError(f"Bad triggered_ampl {triggered_ampl}. Should be 0 to {1.02 * self.rating_volts}.")

        if trig_source is not None and trig_source not in self.options_trigger_sources:
            msg = ", ".join([f"'{x}'" for x in self.options_trigger_sources])
            raise ValueError(f"Bad trig_source '{trig_source}', should be one of: {msg}.")

        # OK, now change settings to supplied values.

        # Can't change parameters if system already initiated, prevent +308 error.
        self.trig_abort('TRAN')

        if transient_mode is not None:
            self.rmHandle.write(f"VOLT:MODE {transient_mode}")

        if triggered_ampl is not None:
            self.rmHandle.write(f"VOLT:TRIG {triggered_ampl}")

        if trig_source is not None:
            self.rmHandle.write(f"TRIG:TRAN:SOUR {trig_source}")

    def cv_dynamics(self, slew_vps=None, slew_maxenb=None, bwid_range=None, bwid0_hz=None, bwid1_hz=None):
        """
        Queries or sets voltage mode slew rate and bandwidth parameters.

        Args:
            slew_vps: 0 to 9.9E37 Volts per Second. Affects all prorgammed voltage changes,
                         including output state on and off.
            slew_maxenb: 'ON' overrides slew_vps setting and uses the maximum possible.
            bwid_range: In voltage priority mode, sets the voltage bandwidth to optimize output
                         response time with capacitive loads.
                0: Selects BW set by bwid0Hz.
                1: Selects BW set by bwid1Hz.
            bwid0_hz: 200 to 500,000Hz, optimized for stability with wide range of cap loads.
            bwid1_hz: 10000 to 500,000Hz, fastest transient response.

        SCPI Commands used:
            [SOURce:]VOLTage:SLEW[:IMMediate] <value>|MIN|MAX|INFinity
            [SOURce:]VOLTage:SLEW:MAXimum 0|OFF|1|ON
            [SOURce:]VOLTage:BWIDth:RANGe 0|1
            [SOURce:]VOLTage:BWIDth:LEVel 0|1, <value>|MIN|MAX
        """

        if all(v is None for v in {slew_vps, slew_maxenb, bwid_range, bwid0_hz, bwid1_hz}):
            return_val = dict()
            return_val.update(slew_vps=float(self.rmHandle.query('VOLT:SLEW?').strip()))
            tmp = self.rmHandle.query('VOLT:SLEW:MAX?').strip()
            return_val.update(slew_maxenb=self.legal_on_off_rev[int(tmp)])
            return_val.update(bwid_range=int(self.rmHandle.query('VOLT:BWID:RANG?')))
            return_val.update(bwid0_hz=float(self.rmHandle.query('VOLT:BWID:LEV? 0').strip()))
            return_val.update(bwid1_hz=float(self.rmHandle.query('VOLT:BWID:LEV? 1').strip()))
            return return_val

        # Check all supplied arguments before changing any settings.
        if slew_vps is not None and (slew_vps < 0 or slew_vps > 9.9E37):
            raise ValueError(f"Bad slew_vps level {slew_vps}. Should be 0 to 9.9E37 Volts/sec.")

        if slew_maxenb is not None and slew_maxenb.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad slew_maxenb '{slew_maxenb}', should be one of: {msg}.")

        if bwid_range is not None and bwid_range not in (0, 1):
            raise ValueError(f"Bad bwid_range '{bwid_range}', should be one of: 0, 1.")

        if bwid0_hz is not None and (bwid0_hz < 200 or bwid0_hz > 500e3):
            raise ValueError(f"Bad bwid0_hz {bwid0_hz}. Should be 200 Hz to 500,000 Hz.")

        if bwid1_hz is not None and (bwid1_hz < 1E4 or bwid1_hz > 500e3):
            raise ValueError(f"Bad bwid1_hz {bwid1_hz}. Should be 10,000 Hz to 500,000 Hz.")

        # OK, now change settings to supplied values.
        if slew_vps is not None:
            self.rmHandle.write(f"VOLT:SLEW {slew_vps}")

        if slew_maxenb is not None:
            self.rmHandle.write(f"VOLT:SLEW:MAX {slew_maxenb}")

        if bwid_range is not None:
            self.rmHandle.write(f"VOLT:BWID:RANG {bwid_range}")

        if bwid0_hz is not None:
            self.rmHandle.write(f"VOLT:BWID:LEV 0,{bwid0_hz}")

        if bwid1_hz is not None:
            self.rmHandle.write(f"VOLT:BWID:LEV 1,{bwid1_hz}")

    def resistance(self, ohms=None, on_off=None):
        """
        Queries or sets series output resistance when in voltage priority ('CV') mode.

        Args:
            ohms: Output resistance in,  Ohms 0 to rated value which is a class attribute
                rating_ohms.

            on_off: 'ON' enables the resistance.

        SCPI Commands used:
            [SOURce:]VOLTage:RESistance:STATe 0|OFF|1|ON
            [SOURce:]VOLTage:RESistance[:LEVel][:IMMediate][:AMPLitude] <value>|MIN|MAX
        """

        # NOTE: Made on-off last for compatibility with PSM9040 which does not have on_off.

        if all(v is None for v in {on_off, ohms}):
            return_val = dict()
            return_val.update(ohms=float(self.rmHandle.query('VOLT:RES?')))
            tmp = self.rmHandle.query('VOLT:RES:STAT?').strip()
            return_val.update(on_off=self.legal_on_off_rev[int(tmp)])

            return return_val

        # Check all supplied arguments before changing any settings.
        if on_off is not None and on_off.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad resistance on_off '{on_off}', should be one of: {msg}.")

        if ohms is not None and (ohms < 0 or ohms > self.rating_ohms):
            raise ValueError(f"Bad ohms {ohms}. Should be 0 to {self.rating_ohms} ohms.")

        # OK, now change settings to supplied values.
        if on_off is not None:
            self.rmHandle.write(f"VOLT:RES:STAT {on_off}")

        if ohms is not None:
            self.rmHandle.write(f"VOLT:RES {ohms}")

    def cc_mode(self, current=None, vlimit=None):

        # [SOURce:]CURRent[:LEVel][:IMMediate][:AMPLitude] <value>|MIN|MAX
        # [SOURce:]VOLTage:LIMit[:POSitive][:IMMediate][:AMPLitude] <value>|MIN|MAX
        # TRIGger:TRANsient:SOURce <source>

        if all(v is None for v in {current, vlimit}):
            return_val = dict()
            return_val.update(current=float(self.rmHandle.query('CURR?').strip()))
            return_val.update(vlimit=float(self.rmHandle.query('VOLT:LIM?').strip()))
            return return_val

        if self.mode() != 'CC':
            raise ValueError(f"Set mode to 'CC' (current control priority), before setting these parameters.")

        if current is not None:
            self.rmHandle.write(f"CURR {current}")

        if vlimit is not None:
            self.rmHandle.write(f"VOLT:LIM {vlimit}")

    def cc_transient(self, transient_mode=None, triggered_ampl=None, trig_source=None):

        # [SOURce:]CURRent:MODE FIXed|STEP|LIST|ARB
        # [SOURce:]CURRent[:LEVel]:TRIGgered[:AMPLitude] <value>|MIN|MAX

        if all(v is None for v in {transient_mode, triggered_ampl, trig_source}):
            return_val = dict()
            return_val.update(transient_mode=self.rmHandle.query('CURR:MODE?').strip())
            return_val.update(triggered_ampl=float(self.rmHandle.query('CURR:TRIG?').strip()))
            return_val.update(trig_source=self.rmHandle.query('TRIG:TRAN:SOUR?').strip())
            return return_val

        # Check all supplied arguments before changing any settings.
        if transient_mode is not None and transient_mode not in self.options_transient_mode:
            msg = ", ".join([f"'{x}'" for x in self.options_transient_mode])
            raise ValueError(f"Bad transient_mode '{transient_mode}', should be one of: {msg}.")

        if triggered_ampl is not None and (triggered_ampl < 0 or triggered_ampl > 1.02 * self.rating_amps):
            raise ValueError(f"Bad triggered_ampl {triggered_ampl}. Should be 0 to {1.02 * self.rating_amps} V.")

        if trig_source is not None and trig_source not in self.options_trigger_sources:
            msg = ", ".join([f"'{x}'" for x in self.options_trigger_sources])
            raise ValueError(f"Bad trig_source '{trig_source}', should be one of: {msg}.")

        # OK, now change settings to supplied values.

        # Can't change parameters if system already initiated, prevent +308 error.
        self.trig_abort('TRAN')

        if transient_mode is not None:
            self.rmHandle.write(f"CURR:MODE {transient_mode}")

        if triggered_ampl is not None:
            self.rmHandle.write(f"CURR:TRIG {triggered_ampl}")

        if trig_source is not None:
            self.rmHandle.write(f"TRIG:TRAN:SOUR {trig_source}")

    def cc_dynamics(self, slew_aps=None, slew_maxenb=None):

        # [SOURce:]CURRent:SLEW[:IMMediate] <value>|MIN|MAX|INFinity
        # [SOURce:]CURRent:SLEW:MAXimum 0|OFF|1|ON

        if all(v is None for v in {slew_aps, slew_maxenb}):
            return_val = dict()
            return_val.update(slew_aps=float(self.rmHandle.query('CURR:SLEW?').strip()))
            return_val.update(slew_maxenb=self.rmHandle.query('CURRent:SLEW:MAX?').strip())
            return return_val

        # Check all supplied arguments before changing any settings.
        if slew_aps is not None and (slew_aps < 0 or slew_aps > 9.9E37):
            raise ValueError(f"Bad slew_aps level {slew_aps}. Should be 0 to 9.9E37 Amps/sec.")

        if slew_maxenb is not None and slew_maxenb.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad slew_maxenb '{slew_maxenb}', should be one of: {msg}.")

        # OK, now change settings to supplied values.

        if slew_aps is not None:
            self.rmHandle.write(f"CURR:SLEW {slew_aps}")

        if slew_maxenb is not None:
            self.rmHandle.write(f"CURRent:SLEW:MAX {slew_maxenb}")

    def ovp_value(self, vlimit=None):
        """
        Queries or sets Over Voltage Protection trip point.
        The OVP feature of this supply is always enabled and turns the supply output off when the
        ovp_value is exceeded.

        Args:
            vlimit: float value 0 to 102% of supply rated voltage.
                    Rated voltage is class artibute rating_volts.

        SCPI Commands used:
            [SOURce:]VOLTage:PROTection[:LEVel] <value>|MIN|MAX
        """

        if vlimit is None:
            return float(self.rmHandle.query('VOLT:PROT?').strip())

        # Check all supplied arguments before changing any settings.
        if vlimit < 0 or vlimit > 1.02*self.rating_volts:
            raise ValueError(f"Bad vlimit {vlimit}. Should be 0 to {1.02*self.rating_volts} V.")

        # OK, now change settings to supplied values.
        self.rmHandle.write(f"VOLTage:PROT {vlimit}")

    def ovp_state(self, state=None):
        """
        Dummy method to provide for Instek compatibility. The OVP feature of this supply cannot
        be disabled. Therefore, the query form on this command always returns 'ON'
        Args:
            state: 'ON' or 'OFF', actually does nothing.

        SCPI Commands used:
            None
        """

        if state is None:
            return 'ON'

        if state is not None and state.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad state '{state}', should be one of: {msg}.")

        # Nothing to write. This is a dummy method for Instek compatibility: OVP is always enabled!
        # TODO: Warn if attempt to turn off.

    def ovp_tripped(self):
        """
        Queries the 'QUES1 status register and returns the state of the Over Voltage' bit.

        SCPI Commands used:
            None
        """

        tmp = self.status_reg_bits('QUES')  # Two lines makes for easier debug.
        return tmp['Over Voltage']

    def ovp_clear(self):
        """
        Clears any output protection mode presently in effect.

        SCPI Commands used:
            OUTPut:PROTection:CLEar    # same as ocp
        """

        self.rmHandle.write('OUTP:PROT:CLE')

    def ocp_value(self, ilimit=None, ilimit_sink=None):  # values are same ilimits set by cv_mode
        """
        Queries or sets Over Current Protection trip point.

        The OCP levels are set by the same registers that set the current limit feature.
        The OCP feature shuts off the output of the supply when the limit value is reached rather
        than limiting  the current at a constant value. The OCP feature has to be enabled using the
        ocp_state method.

        Args:
            ilimit: float value 0 to 102% of supply current rating. Current out of the + terminal.
            ilimit_sink: float value -10.2% supply current rating. Current into the + terminal.

                         Rated current is class attribute rating_amps.

        SCPI Commands used:
            [SOURce:]CURRent:LIMit[:POSitive][:IMMediate][:AMPLitude] <value>|MIN|MAX
            [SOURce:]CURRent:LIMit:NEGative[:IMMediate][:AMPLitude] <value>|MIN|MAX
        """

        if all(v is None for v in {ilimit, ilimit_sink}):
            return_val = dict()
            return_val.update(ilimit=float(self.rmHandle.query('CURR:LIM?').strip()))
            return_val.update(ilimit_sink=float(self.rmHandle.query('CURR:LIM:NEG?').strip()))
            return return_val

        # Check all supplied arguments before changing any settings.
        if ilimit is not None and (ilimit < 0 or ilimit > 1.02*self.rating_amps):
            raise ValueError(f"Bad ilimit {ilimit}. Should be 0 to {1.02*self.rating_amps} A.")

        if ilimit_sink is not None and (ilimit_sink < -0.102 * self.rating_amps or ilimit_sink > 0):
            raise ValueError(f"Bad ilimit_sink {ilimit_sink}. Should be -{0.102 * self.rating_amps} to 0 A.")

        # OK, now change settings to supplied values.
        if ilimit is not None:
            self.rmHandle.write(f"CURR:LIM {ilimit}")

        if ilimit_sink is not None:
            self.rmHandle.write(f"CURR:LIM:NEG {ilimit_sink}")

    def ocp_state(self, state=None):
        """
        Queries or sets Over Current Protection enable. When OCP is enabled the output is turned
        off when the current limits set by ocp_value are exceeded.

        Args:
            state: 'ON' or 'OFF'

        SCPI Commands used:
            [SOURce:]CURRent:PROTection:STATe 0|OFF|1|ON
        """

        if state is None:
            tmp = self.rmHandle.query('CURR:PROT:STAT?')
            return self.legal_on_off_rev[int(tmp)]

        if state is not None and state.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad state '{state}', should be one of: {msg}.")

        self.rmHandle.write(f"CURRent:PROT:STAT {state}")

    def ocp_dynamics(self, delay_start=None, delay_sec=None):
        """
        Queries or sets conditions which control activation of Over Current Protection.
        Provides ability to prevent momentary changes in output from triggering OCP.

        Args:
            delay_start:
                'SCH': Starts the over-current delay whenever a command changes the output
                       settings.
                'CCTR': Starts the over-current delay timer by any transition of the output into
                        current limit mode.
            delay_sec: OCP will not be activated during this number of seconds from the
                        delay_start event. 0 to 0.255 seconds.

        SCPI Commands used:
            [SOURce:]CURRent:PROTection:DELay:STARt SCHange|CCTRans
            [SOURce:]CURRent:PROTection:DELay[:TIME] <value>|MIN|MAX
        """

        if all(v is None for v in {delay_start, delay_sec}):
            return_val = dict()
            return_val.update(delay_start=self.rmHandle.query('CURR:PROT:DEL:STAR?').strip())
            return_val.update(delay_time=float(self.rmHandle.query('CURR:PROT:DEL?').strip()))
            return return_val

        # Check all supplied arguments before changing any settings.
        if delay_start is not None and delay_start not in self.options_delay_start:
            msg = ", ".join([f"'{x}'" for x in self.options_delay_start])
            raise ValueError(f"Bad delay_start '{delay_start}'. Should be one of: {msg}.")

        if delay_sec is not None and (delay_sec < 0 or delay_sec > 0.255):
            raise ValueError(f"Bad delay_time {delay_sec}. Should be 0 to 0.255 sec, 0.001 sec resolution.")

        # OK, now change settings to supplied values.
        if delay_start is not None:
            self.rmHandle.write(f"CURR:PROT:DEL:STAR {delay_start}")

        if delay_sec is not None:
            self.rmHandle.write(f"CURR:PROT:DEL {delay_sec}")

    def ocp_tripped(self):
        """
        Queries the 'QUES1 status register and returns the state of the Over Current' bit.

        SCPI Commands used:
            None
        """

        tmp = self.status_reg_bits('QUES')   # Two lines makes for easier debug.
        return tmp['Over Current']

    def ocp_clear(self):
        """
        Clears any output protection mode presently in effect.

        SCPI Commands used:
            OUTPut:PROTection:CLEar    # same as ovp
        """

        # You need to turn output off, before clearing or it will immediately trip again.
        self.rmHandle.write('OUTP:PROT:CLE')

    def state(self, state=None):
        return self.output(state)

    def output(self, on_off=None):

        # OUTPut [:STATe] 0|OFF|1|ON

        if on_off is None:
            tmp = self.rmHandle.query('OUTP?').strip()
            return self.legal_on_off_rev[int(tmp)]

        if on_off is not None and on_off.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad on_off '{on_off}', should be one of: {msg}.")

        self.rmHandle.write(f"OUTP {on_off}")

    def output_behavior(self, output_z=None, relay_lock=None, relay_polarity_enb=None, relay_polarity=None):

        # OUTPut:PROTection:MODE HIGHZ|LOWZ
        # OUTPut:RELay:LOCK[:STATe]0|OFF|1|ON
        # OUTPut:RELay:POLarity:ENABle 0|OFF|1|ON
        # OUTPut:RELay:POLarity NORMal|REVerse

        if all(v is None for v in {output_z, relay_lock, relay_polarity_enb, relay_polarity}):
            return_val = dict()
            return_val.update(output_z=self.rmHandle.query('OUTP:PROT:MODE?').strip())
            return_val.update(relay_lock=self.legal_on_off_rev[int(self.rmHandle.query('OUTP:REL:LOCK?'))])
            return_val.update(relay_polarity_enb=self.legal_on_off_rev[int(self.rmHandle.query('OUTP:REL:POL:ENAB?'))])
            return_val.update(relay_polarity=self.rmHandle.query('OUTP:REL:POL?').strip())
            return return_val

        # Check all supplied arguments before changing any settings.

        self.trig_abort('TRAN')  # cancel initiated trigger to avoid error.

        if output_z is not None and output_z not in self.options_output_z:
            msg = ", ".join([f"'{x}'" for x in self.options_output_z])
            raise ValueError(f"Bad output_z '{output_z}'. Should be one of: {msg}.")

        if relay_lock is not None and relay_lock.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad relay_lock '{relay_lock}', should be one of: {msg}.")

        if relay_polarity_enb is not None and relay_polarity_enb.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad relay_polarity_enb '{relay_polarity_enb}', should be one of: {msg}.")

        if relay_polarity is not None and relay_polarity not in self.options_relay_polarity:
            msg = ", ".join([f"'{x}'" for x in self.options_relay_polarity])
            raise ValueError(f"Bad relay_polarity '{relay_polarity}'. Should be one of: {msg}.")

        # OK, now change settings to supplied values.
        if output_z is not None:
            self.rmHandle.write(f"OUTP:PROT:MODE {output_z}")

        if relay_lock is not None:
            self.rmHandle.write(f"OUTP:REL:LOCK {relay_lock}")

        if relay_polarity_enb is not None:
            self.rmHandle.write(f"OUTP:REL:POL:ENAB {relay_polarity_enb}")

        if relay_polarity is not None:
            self.rmHandle.write(f"OUTP:REL:POL {relay_polarity}")

    def arb_data_get(self):
        """
        Queries arbitrary waveform levels array and related info.

        NOTE: Provided as a seprate method from arb_config, because of the potentuial length of
              the levels array.

        SCPI Commands Used:
            [SOURce:]ARB:FUNCtion:TYPE CURRent|VOLTage
            [SOURce:]ARB:CURRent:CDWell:POINts?    # Is query only
            [SOURce:]ARB:VOLTage:CDWell:POINts?    # Is query only
            [SOURce:]ARB:CURRent:CDWell[:LEVel] <value>{,<value>}|<Block>
            [SOURce:]ARB:VOLTage:CDWell[:LEVel] <value>{,<value>}|<Block>
        """
        return_val = dict()

        arbtype = self.rmHandle.query('ARB:FUNC:TYPE?').strip()
        return_val.update(arbtype=arbtype)

        tmp = self.rmHandle.query(f"ARB:{arbtype}:CDW:POIN?")
        return_val.update(numpts=int(float(tmp)))

        tmp = self.rmHandle.query(f"ARB:{arbtype}:CDW?").strip()
        return_val.update(levels=[float(x) for x in tmp.split(',')])

        return return_val

    def arb_config(self, arbtype=None, dwell_sec=None, levels=None, repeats=None, termination=None, trig_source=None):
        """
        Queries or sets parameters that define an arbitrary waveform consisting of up to 65,535
        points with the same dwell time between every point.

        NOTE: Queries do not include the levels list/array because it is potentially very large,
              and would overwhlem the console during interactive use. A separate method, arb_data_get,
              is provided to query the levels.

        Args:
            arbtype: 'CURR' or 'VOLT'. Only the Arb that corresponds to the active priority mode,
                      either voltage ('CV') or current priority ("CC'), may be generated.
            dwell_sec: dwell time that applies to every point.
            levels:  A list or 1D numpy array of values to output, up to 65535 elements.
                     For CURR, values must be in the range -10.2% to 102% of rated current.
                     For VOLT, values must be in the range 0 to 102% of rated voltage.
            repeats: Number of times to repeat the sequence of levels. 1 to 255.
            termination: Output value when arb sequence ends.
                'ON': The output voltage or current remains at the last Arb value.
                      The last Arb voltage or current value becomes the IMMediate value when
                       the ARB completes.
                'OFF': When the Arb completes, and also when the Arb is aborted, the output
                       returns to the settings that were in effect before the Arb started.
            trig_source:
                'BUS': Selects a remote interface trigger command ('*TRG').
                'EXT': Selects ALL digital port pins that have been configured as trigger sources.
                'EXPR'<1-8>: Selects one of 8 user-defined expressions as the trigger source.
                'IMM': Triggers the transient as soon as it is INITiated. See method trig_initiate.
                'PIN'<1-7>: Selects a digital port pin configured as a trigger input.

        SCPI Commands Used:
            [SOURce:]ARB:FUNCtion:TYPE CURRent|VOLTage
            [SOURce:]ARB:CURRent:CDWell:DWELl <value>
            [SOURce:]ARB:VOLTage:CDWell:DWELl <value>
            [SOURce:]ARB:CURRent:CDWell[:LEVel] <value>{,<value>}|<Block>
            [SOURce:]ARB:VOLTage:CDWell[:LEVel] <value>{,<value>}|<Block>
            [SOURce:]ARB:COUNt <value>|MIN|MAX|INFinity
            [SOURce:]ARB:TERMinate:LAST 0|OFF|1|ON
            TRIGger:ARB:SOURce <source>
            [SOURce:]ARB:CURRent:CDWell:POINts?    # Is query only
            [SOURce:]ARB:VOLTage:CDWell:POINts?    # Is query only
        """

        if levels is None or len(levels) == 0:  # Because if user passes in a list, the next
            # statement would give error it it included levels: "lists are not hashable objects".
            if all(v is None for v in {arbtype, dwell_sec, repeats, termination, trig_source}):
                return_val = dict()

                arbtype = self.rmHandle.query('ARB:FUNC:TYPE?').strip()
                return_val.update(arbtype=arbtype)

                tmp = self.rmHandle.query(f"ARB:{arbtype}:CDW:POIN?").strip()
                return_val.update(numpts=int(float(tmp)))

                tmp = self.rmHandle.query(f"ARB:{arbtype}:CDW:DWEL?")
                return_val.update(dwell_sec=float(tmp))

                tmp = float(self.rmHandle.query('ARB:COUNt?'))
                if float(tmp) < 257:
                    return_val.update(repeats=int(tmp))
                else:
                    return_val.update(repeats='INF')

                tmp = self.rmHandle.query('ARB:TERM:LAST?').strip()
                return_val.update(termination=self.legal_on_off_rev[int(tmp)])

                return_val.update(trig_source=self.rmHandle.query('TRIG:ARB:SOUR?').strip())
                return return_val

        # Check all supplied arguments before changing any settings.
        if arbtype is not None and arbtype not in self.options_arbtype:
            msg = ", ".join([f"'{x}'" for x in self.options_arbtype])
            raise ValueError(f"Bad arbtype '{arbtype}'. Should be one of: {msg}.")

        if dwell_sec is not None and (dwell_sec < 10.24e-6 or dwell_sec > 300.001e-3):
            raise ValueError(f"Bad dwell_sec {dwell_sec}. Should be 10.24e-6 to 300.001e-3 sec,  10.24e-6 sec resolution.")

        if arbtype is None:
            arbtype_setting = self.rmHandle.query('ARB:FUNC:TYPE?').strip()
        else:
            arbtype_setting = arbtype

        if levels is not None:
            levels_len = len(levels)
            if levels_len > 65535:
                raise ValueError(f"levels length {levels_len}, exceeds 65535.")

            if arbtype_setting == 'CURR':
                level_min, level_max, units = -0.102 * self.rating_amps, 1.02 * self.rating_amps, 'A'
            else:
                level_min, level_max, units = 0, 1.02 * self.rating_volts, 'V'
            msg = self._check_list_values('levels', levels, level_min, level_max, units, self.cfg_max_disp_list_errors)
            if msg:
                raise ValueError(msg)

        if repeats is not None:
            if (isinstance(repeats, (int, float)) and (repeats < 1 or repeats > 256)) or (
                    isinstance(repeats, str) and repeats.upper() != 'INF'):
                raise ValueError(f"Bad repeats {repeats}. Should be 1 to 255 or 'INF'.")

        if termination is not None and termination.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad termination '{termination}', should be one of: {msg}.")

        if trig_source is not None and trig_source not in self.options_trigger_sources:
            msg = ", ".join([f"'{x}'" for x in self.options_trigger_sources])
            raise ValueError(f"Bad trig_source '{trig_source}', should be one of: {msg}.")

        # OK, now change settings to supplied values.

        # Can't change parameters if system already initiated, prevent +308 error.
        self.trig_abort('TRAN')

        if arbtype is not None:
            self.rmHandle.write(f"ARB:FUNC:TYPE {arbtype}")

        if dwell_sec is not None:
            self.rmHandle.write(f"ARB:{arbtype_setting}:CDW:DWEL {dwell_sec}")

        if levels is not None:
            asci_list = ",".join([f"{val}" for val in levels])
            self.rmHandle.write(f"ARB:{arbtype_setting}:CDW {asci_list}")

        if repeats is not None:
            self.rmHandle.write(f"ARB:COUN {repeats}")

        if termination is not None:
            self.rmHandle.write(f"ARB:TERM:LAST {termination}")

        if trig_source is not None:
            self.rmHandle.write(f"TRIG:ARB:SOUR {trig_source}")

    # Trigger control commands. Trigger setup is in individual system methods.
    def trig_abort(self, system):

        # ABORt:ACQuire
        # ABORt:ELOG
        # ABORt:TRANsient

        legal_systems = ('ACQ', 'ELOG', 'TRAN')
        system_u = system.upper()

        if system_u not in legal_systems:
            msg = ", ".join([f"'{x}'" for x in legal_systems])
            raise ValueError(f"Bad system '{system}', should be one of: {msg}.")

        self.rmHandle.write(f"ABOR:{system_u}")

        if system_u in ('ACQ', 'ELOG'):
            bitname_wtg, bitname_active = 'WTG-meas', 'MEAS-active'
        else:
            bitname_wtg, bitname_active = 'WTG-tran', 'TRAN-active'

        tstart = time.time()
        ready = False
        while not ready and (time.time() - tstart) < self.cfg_timeout:
            bits = self.status_reg_bits('OPER')
            ready = not bits[bitname_wtg] and not bits[bitname_active]

        if not ready:
            raise RuntimeError(f"Timeout waiting to abort {system_u} after {self.cfg_timeout} sec.")

    def trig_initiate(self, system=None, transient_continuous=None):

        # INITiate[:IMMediate]:ACQuire
        # INITiate[:IMMediate]:ELOG
        # INITiate[:IMMediate]:TRANsient

        # INITiate:CONTinuous:TRANsient 0|OFF|1|ON

        legal_systems = ('ACQ', 'ELOG', 'TRAN')

        if system is None and transient_continuous is None:
            tmp = self.rmHandle.query("INIT:CONT:TRAN?").strip()
            return {'transient_continuous': self.legal_on_off_rev[int(tmp)]}

        if transient_continuous is not None and transient_continuous.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad transient_continuous '{transient_continuous}', should be one of: {msg}.")

        if system is not None:
            system_u = system.upper()
            if system_u not in legal_systems:
                msg = ", ".join([f"'{x}'" for x in legal_systems])
                raise ValueError(f"Bad system '{system}', should be one of: {msg}.")

            if system_u == 'TRAN':
                if self.mode() == 'CV':
                    if self.cv_transient()['transient_mode'] == 'FIX':
                        raise ValueError(f"Cannot initiate, cv_transient mode is FIXed.")
                else:
                    if self.cc_transient()['transient_mode'] == 'FIX':
                        raise ValueError(f"Cannot initiate, cc_transient mode is FIXed.")

            self.rmHandle.write(f"INIT:{system_u}")

            if system_u in ('ACQ', 'TRAN'):
                if system_u == 'ACQ':
                    bitname_wtg, bitname_active = 'WTG-meas', 'MEAS-active'
                else:
                    bitname_wtg, bitname_active = 'WTG-tran', 'TRAN-active'

                tstart = time.time()
                ready = False
                while not ready and (time.time() - tstart) < self.cfg_timeout:
                    bits = self.status_reg_bits('OPER')
                    ready = bits[bitname_wtg]
                if not ready:
                    raise RuntimeError(f"Timeout waiting to initiate {system_u} trigger after {self.cfg_timeout} sec.\n"
                                       "Check the Error Queue.")

        if transient_continuous is not None:
            self.rmHandle.write(f"INIT:CONT:TRAN {transient_continuous.upper()}")

    def trig_immed(self, system):

        # TRIGger:ACQuire[:IMMediate]
        # TRIGger:ELOG[:IMMediate]
        # TRIGger:TRANsient[:IMMediate]

        legal_systems = ('ACQ', 'ELOG', 'TRAN')
        system_u = system.upper()

        if system_u not in legal_systems:
            msg = ", ".join([f"'{x}'" for x in legal_systems])
            raise ValueError(f"Bad system '{system}', should be one of: {msg}.")

        self.rmHandle.write(f"TRIG:{system_u}")

    def meas(self, item=None):

        # N7971A SCPI cmds
        # MEASure[:SCALar]:CURRent[:DC]?
        # MEASure[:SCALar]:CURRent:ACDC?
        # MEASure[:SCALar]:CURRent:MAXimum?
        # MEASure[:SCALar]:CURRent:MINimum?
        # MEASure[:SCALar]:CURRent:HIGH?
        # MEASure[:SCALar]:CURRent:LOW?

        # MEASure[:SCALar]:VOLTage[:DC]?
        # MEASure[:SCALar]:VOLTage:ACDC?
        # MEASure[:SCALar]:VOLTage:MAXimum?
        # MEASure[:SCALar]:VOLTage:MINimum?
        # MEASure[:SCALar]:VOLTage:HIGH?
        # MEASure[:SCALar]:VOLTage:LOW?

        # MEASure[:SCALar]:POWer[:DC]?
        # MEASure[:SCALar]:POWer:MAXimum?
        # MEASure[:SCALar]:POWer:Minimum?

        if item.upper() not in self.options_meas_item:
            msg = ", ".join([f"'{x}'" for x in self.options_meas_item])
            raise ValueError(f"Bad meas item '{item}', should be one of: {msg}.")

        result = self.rmHandle.query(f"MEAS:{self.options_meas_item[item.upper()]}?")
        return float(result)

    def meas_array(self, item=None):

        # MEASure:ARRay:CURRent[:DC]?
        # MEASure:ARRay:VOLTage[:DC]?
        # MEASure:ARRay:POWer[:DC]?
        # TRIGger:ACQuire:INDices[:DATA]?
        # TRIGger:ACQuire:INDices:COUNt?
        # FORMat[:DATA] ASCII|REAL
        # FORMat:BORDer NORMal|SWAPped

        # legal_items = ('CURR', 'VOLT', 'POW')
        # legal_formats = ('ASCII', 'REAL')

        options_item = ('CURR', 'VOLT')
        if item.upper() not in options_item:
            msg = ", ".join([f"'{x}'" for x in options_item])
            raise ValueError(f"Bad meas_array item '{item}', should be one of: {msg}.")

        result = self.rmHandle.query(f"MEAS:ARR:{item.upper()}?")
        data = [float(x) for x in result.split(',')]

        result = self.rmHandle.query(f"TRIG:ACQ:IND?")
        indices = [int(float(x)) for x in result.split(',')]

        return {'meas_data': data, 'trig_indicies': indices}

    def meas_averaging(self, curr_range_auto=None, curr_range=None, NPLcycles=None, window_type=None):

        # SENSe:CURRent[:DC]:RANGe:AUTO 0|OFF|1|ON
        # SENSe:CURRent[:DC]:RANGe[:UPPer] <value>|MIN|MAX
        # SENSe:CURRent[:DC]:RANGe[:UPPer]? [MIN|MAX]  -> returns max for present range
        # SENSe:SWEep:NPLCycles <value>|MIN|MAX
        # SENSe:WINDow[:TYPE] HANNing|RECTangular

        if all(v is None for v in {curr_range_auto, curr_range, NPLcycles, window_type}):
            return_val = dict()
            tmp = self.rmHandle.query('SENS:CURR:RANG:AUTO?')
            return_val.update(curr_range_auto=self.legal_on_off_rev[int(tmp)])
            return_val.update(curr_range=float(self.rmHandle.query('SENS:CURR:RANG?')))
            return_val.update(NPLcycles=float(self.rmHandle.query('SENS:SWE:NPLC?')))
            return_val.update(window_type=self.rmHandle.query('SENS:WIND?').strip())
            return return_val

        # Check all supplied arguments before changing any settings.
        if curr_range_auto is not None and curr_range_auto.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad curr_range_auto '{curr_range_auto}', should be one of: {msg}.")

        if curr_range is not None and (curr_range < 0 or curr_range > self.rating_amps):
            raise ValueError(f"Bad curr_range {curr_range}. Should be 0 to {self.rating_amps} A.")

        if NPLcycles is not None and (NPLcycles < 3.072e-4 or NPLcycles > 1.258291E+12):
            raise ValueError(f"Bad NPLcycles {NPLcycles}. Should be 3.072e-4 to 1.258291E+12.")

        if window_type is not None and window_type.upper() not in self.options_window_type:
            msg = ", ".join([f"'{x}'" for x in self.options_window_type])
            raise ValueError(f"Bad window_type '{window_type}', should be one of: {msg}.")

        # OK, now change settings to supplied values.
        if curr_range_auto is not None:
            self.rmHandle.write(f"SENS:CURR:RANG:AUTO {curr_range_auto.upper()}")

        if curr_range is not None:
            self.rmHandle.write(f"SENS:CURR:RANG {curr_range}")

        if NPLcycles is not None:
            self.rmHandle.write(f"SENS:SWE:NPLC {NPLcycles}")

        if window_type is not None:
            self.rmHandle.write(f"SENS:WIND {window_type}")

    def meas_acquisition(self, pts_total=None, interval_sec=None, pts_offset=None, trig_source=None,
                         curr_level=None, volt_level=None):

        # SENSe:SWEep:POINts <value>|MIN|MAX
        # SENSe:SWEep:TINTerval <value>|MIN|MAX
        # SENSe:SWEep:OFFSet:POINts <value>|MIN|MAX
        # TRIGger:ACQuire:SOURce <source>
        # TRIGger:ACQuire:CURRent[:LEVel] <value>|MIN|MAX
        # TRIGger:ACQuire:VOLTage[:LEVel] <value>|MIN|MAX

        if all(v is None for v in {pts_total, interval_sec, pts_offset, trig_source, curr_level, volt_level}):
            return_val = dict()
            return_val.update(pts_total=int(float(self.rmHandle.query('SENS:SWE:POIN?'))))
            return_val.update(interval_sec=float(self.rmHandle.query('SENS:SWE:TINT?')))
            return_val.update(pts_offset=int(float(self.rmHandle.query('SENS:SWE:OFFS:POIN?'))))
            return_val.update(trig_source=self.rmHandle.query('TRIG:ACQ:SOUR?').strip())
            return_val.update(curr_level=float(self.rmHandle.query('TRIG:ACQ:CURR?')))
            return_val.update(volt_level=float(self.rmHandle.query('TRIG:ACQ:VOLT?')))
            return return_val

        # Check all supplied arguments before changing any settings.
        if pts_total is not None and (pts_total < 1 or pts_total > 524288):
            raise ValueError(f"Bad pts_total {pts_total}. Should be 1 to 524288.")

        if interval_sec is not None and (interval_sec < 5.12e-6 or interval_sec > 4e4):
            raise ValueError(f"Bad interval_sec {interval_sec}. Should be 5.12e-6 to 4e4.")

        if pts_offset is not None and (pts_offset < -524287 or pts_offset > 2e9):
            raise ValueError(f"Bad pts_offset {pts_offset}. Should be -524287 to 2e9.")

        if trig_source is not None and trig_source.upper() not in self.options_acq_trigger_sources:
            msg = ", ".join([f"'{x}'" for x in self.options_acq_trigger_sources])
            raise ValueError(f"Bad trig_source '{trig_source}', should be one of: {msg}.")

        if curr_level is not None and (curr_level < -1.02*self.rating_amps or curr_level > 1.02*self.rating_amps):
            raise ValueError(f"Bad curr_level {curr_level}. Should be -1.02*self.rating_amps to 1.02*self.rating_amps A.")

        if volt_level is not None and (volt_level < -1.02*self.rating_amps or volt_level > 1.02*self.rating_amps):
            raise ValueError(f"Bad volt_level {volt_level}. Should be -1.02*self.rating_volts to 1.02*self.rating_volts V.")

        # OK, now change settings to supplied values.
        if pts_total is not None:
            self.rmHandle.write(f"SENS:SWE:POIN {pts_total}")

        if interval_sec is not None:
            self.rmHandle.write(f"SENS:SWE:TINT {interval_sec}")

        if pts_offset is not None:
            self.rmHandle.write(f"SENS:SWE:OFFS:POIN {pts_offset}")

        if trig_source is not None:
            self.rmHandle.write(f"TRIG:ACQ:SOUR {trig_source}")

        if curr_level is not None:
            self.rmHandle.write(f"TRIG:ACQ:CURR {curr_level}")

        if volt_level is not None:
            self.rmHandle.write(f"TRIG:ACQ:VOLT {volt_level}")

    def list_data_get(self):
        """
        Queries list transient dwell_sec and levels arrays and related info.

        Also, checks that all list transient related arrays are of compatible lengths:
        either length 1 or identical to the levels array.

        NOTE: Provided as a seprate method from list_config, because of the potential length of
              the arrays that would overwhelm the console if used interactively.

        SCPI Commands Used:
            [SOURce:]LIST:CURRent:POINts?
            [SOURce:]LIST:VOLTage:POINts?
            [SOURce:]LIST:DWELl:POINts?
            [SOURce:]LIST:TOUTput:BOSTep:POINts?
            [SOURce:]LIST:TOUTput:EOSTep:POINts?

            [SOURce:]LIST:CURRent[:LEVel]?
            [SOURce:]LIST:VOLTage[:LEVel]?

            [SOURce:]LIST:DWELl?

            [SOURce:]LIST:TOUTput:BOSTep[:DATA]?
            [SOURce:]LIST:TOUTput:EOSTep[:DATA]?
        """

        # Which level cmds will be used depends on present operating mode.
        mode = {'CC': 'CURR', 'CV': 'VOLT'}[self.mode()]

        # Create a dict to contain all the info to be returned.
        return_val = dict()

        return_val.update(mode=mode)

        tmp = self.rmHandle.query(f"LIST:{mode}:POIN?")
        numpts_levels = int(float(tmp))
        return_val.update(numpts=numpts_levels)

        tmp = self.rmHandle.query(f"LIST:DWEL?").strip()
        return_val.update(dwells=[float(x) for x in tmp.split(',')])

        tmp = self.rmHandle.query(f"LIST:TOUT:BOST?").strip()
        return_val.update(trigout_bos=[int(float(x)) for x in tmp.split(',')])

        tmp = self.rmHandle.query(f"LIST:TOUT:EOST?").strip()
        return_val.update(trigout_eos=[int(float(x)) for x in tmp.split(',')])

        tmp = self.rmHandle.query(f"LIST:{mode}:LEV?").strip()
        return_val.update(levels=[float(x) for x in tmp.split(',')])

        # Are the lengths of the 4 arrays compatible? Length either has to be
        # 1 value that applies to all levels or the same length as the levels array.

        numpts_dwell = int(float(self.rmHandle.query(f"LIST:DWEL:POIN?")))
        numpts_tbos = int(float(self.rmHandle.query(f"LIST:TOUT:BOST:POIN?")))
        numpts_teos = int(float(self.rmHandle.query(f"LIST:TOUT:EOST:POIN?")))

        # Find the mismatches and create descriptive error message showing which arrays
        # are mismatched to the number of level points.
        # A mismatch should never happen if you use list_config.
        msg_strs = []
        if numpts_dwell > 1 and numpts_dwell != numpts_levels:
            msg_strs.append(f"numpts_dwell:{numpts_dwell}")
        if numpts_tbos > 1 and numpts_tbos != numpts_levels:
            msg_strs.append(f"numpts_tbos:{numpts_tbos}")
        if numpts_teos > 1 and numpts_teos != numpts_levels:
            msg_strs.append(f"numpts_teos:{numpts_teos}")
        msg = ", ".join(msg_strs)
        if msg != '':
            msg = f"Mismatched array lengths: numpts_levels:{numpts_levels}, " + msg + '.'
            raise ValueError(msg)

        return return_val

    def list_config(self, dwell_sec=None, levels=None, repeats=None, termination=None, step=None):
        """
        Queries or sets parameters that define a list transient consisting of up to 512 points
        with the dwell time independently controlled for each point.

        NOTE: Queries do not include the levels list/array because it is potentially very large,
              and would overwhelm the console during interactive use. A separate method,
              list_data_get, is provided to query the levels.

        Args:
            dwell_sec: A list or numpy 1D array that defines the dwell time in seconds for the levels
                       defined in the levels array. If dwell_sec is of length 1, that value applies to
                       all of the level elements, otherwise dwell_sec must be of the same length as
                       levels. dwell_sec values must be 0 to 262.144 sec, resolution depends on value,
                       see manual p 241.
            levels:  A list or 1D numpy array of values to output, up to 4096 elements. The values
                     are interpreted as either voltages or current depending on the present operating
                     mode of the supply ('CV' or 'CC' as defined by the method mode).
                     For CC, values must be in the range -10.2% to 102% of rated current.
                     For CV, values must be in the range 0 to 102% of rated voltage.
            repeats: Number of times to repeat the sequence of levels. 1 to 4096.
            termination: Output value when arb sequence ends.
                'ON': The output voltage or current remains at the last Arb value.
                      The last Arb voltage or current value becomes the IMMediate value when
                       the ARB completes.
                'OFF': When the Arb completes, and also when the Arb is aborted, the output
                       returns to the settings that were in effect before the Arb started.
            step: Specifies how the list responds to triggers.
                'ONCE': Output to remains at the present step until step until a trigger advances it to
                        the next step. Triggers that arrive during the dwell time are ignored.
                'AUTO': causes the output to automatically advance to each step, after the receipt of an
                        initial starting trigger. Steps are paced by the dwell list. As each dwell time
                         elapses, the next step is immediately output.

        NOTE: Triggering for the list transient is through the trig_source setting of the the
              cv_config or cc_config methods depending on current or voltage. This is unlike the
              arb, which has it own trigger mux. See Trigger Diagram, manual p. 291.

        SCPI Commands Used:
            [SOURce:]LIST:COUNt <value>|MIN|MAX|INFinity
            [SOURce:]LIST:CURRent[:LEVel] <value>{,<value>}
            [SOURce:]LIST:VOLTage[:LEVel] <value>,{<value
            [SOURce:]LIST:DWELl <value>{,<value>}
            [SOURce:]LIST:STEP ONCE|AUTO
            [SOURce:]LIST:TERMinate:LAST 0|OFF|1|ON

        """
        # TODO: Add support for TOUT
        # [SOURce:]LIST:TOUTput:BOSTep[:DATA] 0|OFF|1|ON {,0|OFF|1|ON }
        # [SOURce:]LIST:TOUTput:EOSTep[:DATA] 0|OFF|1|ON {,0|OFF|1|ON }

        mode = {'CC': 'CURR', 'CV': 'VOLT'}[self.mode()]

        if dwell_sec is None and levels is None:
            # Because if user passes in a list, the next statement would give error it it included
            # any lists: "lists are not hashable objects".
            if all(v is None for v in {repeats, termination, step}):
                return_val = dict()

                # Don't return the lists - if they are too long it messes up the interactive console.

                tmp = float(self.rmHandle.query('LIST:COUN?'))
                if float(tmp) < 4097:
                    return_val.update(repeats=int(tmp))
                else:
                    return_val.update(repeats='INF')

                tmp = self.rmHandle.query('LIST:TERM:LAST?')
                return_val.update(termination=self.legal_on_off_rev[int(tmp)])

                return_val.update(step=self.rmHandle.query('LIST:STEP?').strip())

                return return_val

        # Check all supplied arguments before changing any settings.
        if dwell_sec is None:
            dwell_len = int(self.rmHandle.query('LIST:DWEL:POIN?'))
        else:
            dwell_len = len(dwell_sec)
            if dwell_len > 512:
                raise ValueError(f"dwell_sec length {dwell_len}, exceeds 512.")

        if levels is None:
            levels_len = int(self.rmHandle.query('LIST:{mode}:POIN?'))
        else:
            levels_len = len(levels)
            if levels_len > 512:
                raise ValueError(f"levels length {levels_len}, exceeds 512.")

        if dwell_sec is not None:
            if dwell_len != 1 and dwell_len != levels_len:
                raise ValueError(f"Dwell list length {dwell_len}, does not match levels length {levels_len}.)")
            else:
                msg = self._check_list_values('dwell_sec', dwell_sec, 0, 262.144, 'sec', self.cfg_max_disp_list_errors)
                if msg:
                    raise ValueError(msg)

        if levels is not None:
            if dwell_len != 1 and dwell_len != levels_len:
                raise ValueError(f"Dwell list length {dwell_len}, does not match levels length {levels_len}.)")
            else:
                if mode == 'CURR':
                    levels_min, levels_max, units = -0.102*self.rating_amps, 1.02*self.rating_amps, 'A'
                else:
                    levels_min, levels_max, units = 0, 1.02 * self.rating_volts, 'V'
                msg = self._check_list_values('levels', levels, levels_min, levels_max, units, self.cfg_max_disp_list_errors)
                if msg:
                    raise ValueError(msg)

        if repeats is not None:
            if (isinstance(repeats, (int, float)) and (repeats < 1 or repeats > 4096)) or (
                    isinstance(repeats, str) and repeats.upper() != 'INF'):
                raise ValueError(f"Bad repeats {repeats}. Should be 1 to 4096 or 'INF'.")

        if termination is not None and termination.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad termination '{termination}', should be one of: {msg}.")

        if step is not None and step.upper() not in self.options_list_step:
            msg = ", ".join([f"'{x}'" for x in self.options_list_step])
            raise ValueError(f"Bad step '{step}', should be one of: {msg}.")

        # OK, now change settings to supplied values.

        # Can't change parameters if system already initiated, prevent +308 error.
        self.trig_abort('TRAN')

        asci_list = ",".join([f"{val}" for val in dwell_sec])
        if dwell_sec is not None:
            self.rmHandle.write(f"LIST:DWEL {asci_list}")

        if levels is not None:
            asci_list = ",".join([f"{val}" for val in levels])
            self.rmHandle.write(f"LIST:{mode} {asci_list}")

        if repeats is not None:
            self.rmHandle.write(f"LIST:COUN {repeats}")

        if termination is not None:
            self.rmHandle.write(f"LIST:TERM:LAST {termination}")

        if step is not None:
            self.rmHandle.write(f"LIST:STEP {step}")

    # ---------------------------------------------------------------------------

    @staticmethod
    def _check_list_values(name, values, val_min, val_max, units, show_maxbad):
        bad_indicies = [i for i, val in enumerate(values) if (val < val_min or val > val_max)]
        num_bad = len(bad_indicies)
        msg = ''
        if num_bad > 0:
            show_bad = min(num_bad, show_maxbad)
            msg = f"{name} contains {num_bad} values outside range {val_min} to {val_max} {units}. "
            if num_bad > show_bad:
                msg += f"The first {show_bad} are:\n"
            else:
                msg += "They are:\n"
            msg += ",\n".join([f"    {name}[{bad_indicies[i]}]={values[bad_indicies[i]]}" for i in range(show_bad)])

        return msg

    def status_reg_bits(self, regname):
        """Queries OPER, QUES (really QUES1), or QUES2 status register and returns dictionary
         of name-values of bits. The bit names are chosen to be compatible where possible with
         previous supplies. That's why they don't match N7950A manual in all cases.

        Args:
            regname: 'oper' or 'ques'. Not case sensitive.

        """

        regname_u = regname.upper()
        if regname_u == 'OPER':
            conditions = {
                'CV': 0, 'CC': 1, 'OFF': 2, 'WTG-meas': 3, 'WTG-tran': 4,
                'MEAS-active': 5, 'TRAN-active': 6, 'User1': 7
            }
        elif regname_u == 'QUES':  # Instrument accepts this name as alias for QUES1.
            conditions = {
                'Over Voltage': 0, 'Over Current': 1, 'AC Power Off': 2, 'Over Power': 3,
                'Over Temp': 4, 'Over Power-': 5, 'OV-': 6, 'Limit+': 7,
                'Limit-': 8, 'INH': 9, 'UNR': 10, 'PROT': 11, 'EDP': 12, 'SF': 13
            }
        elif regname_u == 'QUES2':
            conditions = {
                'UProt': 0, 'IPK+': 1, 'IPK-': 2, 'CSF': 3
            }
        else:
            raise ValueError(f"Bad status regname '{regname}', shoudl be 'OPER', 'QUES', or 'QUES2.")

        # Instrument accepts QUES as alias for QUES1.
        value = self.rmHandle.query(f'STAT:{regname_u}:COND?')
        value = int(value)

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def digital(self, pin=None, function=None, polarity=None, dataout=None):

        # [SOURce:]DIGital:INPut:DATA?
        # [SOURce:]DIGital:OUTPut:DATA <value>
        # [SOURce:]DIGital:PIN<1-7>:FUNCtion <function>
        # [SOURce:]DIGital:PIN<1-7>:POLarity POSitive|NEGative
        # [SOURce:]DIGital:TOUTput:BUS[:ENABle] 0|OFF|1|ON

        if all(v is None for v in {function, dataout, polarity, tout_bus}):
            return_val = dict()
            # if pin is None:
            #     pins = range(1,8)
            # else:
            #     pins = [pin]

            pins = list(range(1, 8)) if pin is None else [pin]

            tmp = self.rmHandle.query('DIG:TOUT:BUS?').strip()
            return_val.update(tout_bus=self.legal_on_off_rev[int(tmp)])

            data_in = int(self.rmHandle.query('DIG:INP:DATA?'))
            data_out = int(self.rmHandle.query('DIG:OUTP:DATA?'))

            pins = list(range(1,8)) if pin is None else [pin]

            for p in pins:
                pin_info = dict()
                function = self.rmHandle.query(f'DIG:PIN{p}:FUNC?').strip()
                pin_info['function'] = function
                pin_info['polarity'] = self.rmHandle.query(f'DIG:PIN{p}:POL?').strip()
                if function == 'DIO':
                    pin_info['data'] = 1 if (data_in & 2**p) > 0 else 0
                elif function == 'DINP':
                    pin_info['data'] = 1 if (data_in & 2 ** p) > 0 else 0
                elif function == 'INH':
                    pin_info['mode'] = self.rmHandle.query(f'OUTP:INH:MODE?').strip()
                return_val[f'pin{p}'] = pin_info

            if pin is None:
                return return_val
            else:
                return return_val[f'pin{p}']

        # Check all supplied arguments before changing any settings.

        if pin not in range(1,8):
            raise ValueError(f"Bad pin {pin}, must be integer 1 through 7.")

        if function is not None:
            function_u = function.upper()
            if function_u not in self.options_digital_pin_function:
                msg = ", ".join([f"'{x}'" for x in self.options_digital_pin_function])
                raise ValueError(f"Bad function {function}. should be one of: {msg}")
            if function_u == 'FAULT' and pin != 1:
                raise ValueError(f"Bad pin {pin} for FAULT functionality. Pin 1 only.")
            if function_u == 'INHIBIT' and pin != 3:
                raise ValueError(f"Bad pin {pin} for INHIBIT functionality. Pin 3 only.")
            if function_u == 'ONCOUPLE' and pin not in (4,5,6,7):
                raise ValueError(f"Bad pin {pin} for ONCOUPLE functionality. Pins 4,5,6,7 only.")
            if function_u == 'OFFCOUPLE' and pin not in (4,5,6,7):
                raise ValueError(f"Bad pin {pin} for OFFCOUPLE functionality. Pins 4,5,6,7 only.")
            function_setting = function_u
        else:
            function_setting = self.rmHandle.query(f"DIG:PIN{pin}:FUNC?").strip()

        if dataout is not None:
            if dataout not in (True, False):
                raise ValueError(f"Bad dataout {dataout}. Should be True or False.")
            if function_setting is not 'DIO':
                raise ValueError(f"Cannot set pin {pin} output value, with pin function '{function_setting}'.")

        if polarity is not None:
            polarity_u = polarity.upper()
            if polarity_u not in self.options_digital_pin_polarity:
                msg = ", ".join([f"'{x}'" for x in self.options_digital_pin_polarity])
                raise ValueError(f"Bad polarity {polarity}. should be one of: {msg}")

        if tout_bus is not None and on_off.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad trig_bus '{tout_bus}', should be one of: {msg}.")

        # OK, now change settings to supplied values.

        if function is not None:
            self.rmHandle.write(f"DIG:PIN{pin}:FUNC {function_u}")

        if dataout is not None:
            data = int(self.rmHandle.query('DIG:OUTP:DATA?'))
            datanew = data | dataout
            self.rmHandle.write(f"DIG:OUTP:DATA {datanew}")

        if polarity is not None:
            self.rmHandle.write(f"DIG:PIN{pin}:POL {polarity_u}")

        if tout_bus is not None:
            self.rmHandle.write(f"DIG:TOUT:BUS {tout_bus.upper()}")

    # ---------------------------------------------------------------------------

    def getIdn(self):
        """Returns instrument identity string.
        """

        return self.rmHandle.query('*IDN?')

    def getError(self):
        """Reads a single error string (oldest) from supply error queue.

        Error queue is First In First Out. Will return "0, 'No Error" on the read
        following reading the last error.

        Clears device Alarm bits in QUEStionable Status register if the condition that
        caused the alarm is gone.
        """

        return self.rmHandle.query('SYST:ERRor?').rstrip()

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = int(self.rmHandle.query('*STB?').rstrip())

        conditions = {'ERR': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPER': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending '*CLS, command."""

        self.rmHandle.write('*CLS')

    def errlog(self):
        err_cmd = 'SYST:ERR?'
        err_list = []
        while True:
            err_msg = self.rmHandle.query(err_cmd)
            if 'No error' in err_msg:
                break
            else:
                err_list.append(err_msg)
        return err_list

    def close(self):
        """There is no need for users to call this. If you do instrument will because
        unavailable because rmHandle will be closed.

        This is here for InstMgr to use in its clean up.
        """

        # here, might need to communicate with instrument manager to retire the
        # instance listed there
        self.rmHandle.close()


# ===============================================================================

if __name__ == "__main__":
    import os
    import time

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    from InstMgr import InstMgr

    instMgr = InstMgr()

    ps = instMgr.checkout(objName='supply', interface='GPIB', addr=25, moduleSuffix='N7950A')

    ps.reset()

    print()

    print(ps.getIdn())

    ps.reset()  # Puts everything back to factory defaults - output OFF.

