# -*- coding: utf-8 -*-
"""
Created on Mon Nov 28 11:23:13 2016

@author: jmunger
"""

import re

idnString = 'E3646A'

outputTup = ('OUT1', 'OUT2')


class Supply_E3646A:
    
    def __init__(self, rmHandle):
        self.rmHandle = rmHandle
        self.__output_select = 'OUT1'  # Used in value method when caller doesn't provide parameter "output".

    @property
    def output_select(self):
        """" Determines target of value operations when caller doesn't specify output parameter."""
        return self.__output_select

    @output_select.setter
    def output_select(self, output):
        output_u = output.upper()
        if output_u not in outputTup:
            options = ", ".join([f"'{x}'" for x in outputTup])
            raise ValueError(f"bad output '{output}', should be one of: {options}")
        self.__output_select = output_u

    def reset(self):
        # either power off supply & set to 0v output, or just execute *RST command
        self.rmHandle.write('*RST')        
        pass
    
    def setOutputVal(self, output='OUT1', vSet=0.0, iSet=0.1):
        # maybe later add auto range setting based on desired input.
        # Then could also check that value is within max range.

        output_u = output.upper()
        if output_u not in outputTup:
            options = ", ".join([f"'{x}'" for x in outputTup])
            raise ValueError(f"bad output '{output}', should be one of: {options}")

        self.rmHandle.write(f'INST:SEL {output_u}')

        self.rmHandle.write('SOUR:VOLT:LEV:IMM:AMPL ' + str(vSet))
        self.rmHandle.write('SOUR:CURR:LEV:IMM:AMPL ' + str(iSet))

    def setOutputStat(self, state='off'):
        self.rmHandle.write('OUTP:STAT ' + state)
    
    def getOutputStat(self):
        result = self.rmHandle.query('OUTP:STAT?')
        if '0' in result:
            return 'OFF'
        else:
            return 'ON'

    def meas(self, output, param):
        """
        Queries or writes actual measured value of the specified parameter on
        on the specified output.

        Args:
            output (str): One of 'OUT1','OUT2'.
            param (str):
                'CURR' - measured Current (Amps)
                'POW'  - measured Power   (Watts)
                'VOLT' - measured Voltage (Volts)

           Args are not case sensitive.
           Return values are of type float.
        """
        output_u = output.upper()
        if output_u not in outputTup:
            options = ", ".join([f"'{x}'" for x in outputTup])
            raise ValueError(f"bad output '{output}', should be one of: {options}")

        self.rmHandle.write(f'INST:SEL {output_u}')

        if param.upper() in ('CURR', 'VOLT'):
            retval = self.rmHandle.query('MEAS:' + param.upper() + '?')
            return float(retval.rstrip())
        else:
            raise ValueError(f"Bad param '{param}. Should be one of 'CURR', 'VOLT'.")

    def value(self, output=None, voltage=None, ilimit=None):
        """ Queries or sets the voltage and the current limit values of the specified output.

            Provides for parameter combinations that were valid for single output supplies such
            as Instek or EA. In those cases callers are not supplying the output argument,
            in fact their calls will have voltage in the output position. In such cases, the
            values apply to the supply output identified by the object attribute _output_select.

            Typical Args:
                1st: output: Defines the target output: 'OUT1' or 'OUT2'.
                2nd: voltage: (None or numeric) : Voltage to set in Volts.
                3trd: ilimit: ( None or numeric) : Current limit to set in Amps.

            Alternative Args: For compatibility with code written for single output supplies.
                Target output is defined object attribute _output_select.
                1st:  (None or numeric) Voltage to set in Volts.
                2nd: (None or numeric) ilimit to set in Amps
                3trd: This is illegal and throws an error.

            Return:
                If both voltage and ilimit are None, then the Power Supply is queried and the
                present voltage and current settings are returned as a list of two float values.

            NOTE: Voltage and ilimit can be both set together. Alternatively,
                  voltage can be set with ilimit==None. ilimit cannot be
                  set with voltage == None.
        """

        options = ", ".join([f"'{x}'" for x in outputTup])

        if isinstance(output, str) and output.upper() in outputTup:
            # This is the typical call scenario.
            pass
        elif output is None:
            # One of the possible Alternative call scenarios: voltage and ilimit are None or were
            # specified using named arguments.
            output = self.__output_select
        elif isinstance(output, (int, float)):
            # Remainder of the alternative usecases: Voltage and if present ilimit, are shifted to the left.
            if ilimit is not None: # This form does not have a third parameter, so
                raise ValueError(f"Bad output '{output}', should be one of: {options}")
            ilimit = voltage
            voltage = output
            output = self.__output_select
        else:
            raise ValueError(f"Bad output '{output}', should be one of: {options}")

        # Un comment for debug
        # if all(v is None for v in {voltage, ilimit}):
        #     print(f'Read {output} parameters')
        #
        # if voltage is not None:
        #     print(f' For {output} set voltage={voltage}')
        #
        # if ilimit is not None:
        #     print(f' For {output} set ilimit={ilimit}')
        # end debug code

        # The readback case
        if voltage is None and ilimit is None:
            retList = [0.0, 0.0]
            self.rmHandle.write(f'INST {output.upper()}')
            retval = self.rmHandle.query('APPL?')
            for item in range(2):
                retList[item] = float(re.sub('["]', '', retval.split(',')[item]))
            return retList

        # Avoids causing instrument error if user supplies non numeric value.
        # TODO: Check voltage and ilimit for specific model and present range setting.

        if voltage is not None and not isinstance(voltage, (int, float)):
            raise ValueError(f"Bad voltage '{voltage}', should be 0 to 20 V.")

        if ilimit is not None and not isinstance(ilimit, (int, float)):
            raise ValueError(f"Bad ilimit '{ilimit}', should be 0 to 5 A.")

        self.rmHandle.write(f'INST {output.upper()}')

        if voltage is not None:
            self.rmHandle.write(f'VOLT {voltage}')

        if ilimit is not None:
            self.rmHandle.write(f'CURR {ilimit}')

    # ---------------------------------------------------------------------------
    def output(self, on_off=None):
        """Wrapper around method state for compatibility.
        """

        return self.state(on_off)

    def state(self, state=None):
        """
        Queries or writes the state of the Power Supply output (all 2 together).

        Args:
            state (str):
                None   - Queries instrument, returns one of the following strings:
                'ON'   - Power Supply is connected to the load.
                'OFF'  - Power Supply is DISconnected to the load.

           Args are not case sensitive.
           Return values are always case shown above.
        """

        if state is None:
            rslt = self.rmHandle.query('OUTP:STAT?')
            if '1' in rslt:
                return 'ON'
            else:
                return 'OFF'
        else:
            states = ('ON', 'OFF')
            if state.upper() in states:
                self.rmHandle.write('OUTP:STAT ' + state.upper())
            else:
                raise ValueError(f"Bad state '{state}', should be 'ON' or 'OFF'.")

    def getIdn(self):
        return self.rmHandle.query('*IDN?')
        
    def close(self):
        # here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass


if __name__ == "__main__":
    import os
    import sys

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    ps = instMgr.checkout(interface='GPIB', addr=5, moduleSuffix='E3646A')
    ps.reset()
    print(ps.getIdn())
#    mi.setOutputVal(output='p5v')
#    mi.setOutputVal(output='P6V',vSet=5.0,iSet=10e-3)
#    mi.setOutputVal(output='P25V',vSet=15.0,iSet=0.1)
#    mi.setOutputVal(output='N25V',vSet=-15.0,iSet=0.1)
