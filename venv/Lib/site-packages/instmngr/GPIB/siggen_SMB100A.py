# -*- coding: utf-8 -*-
"""
Class for controlling Rohde & Schwarz SMB100A signal generator.
Created on Wed Sep 11 16:00 2019

@author: dkaroly
"""

import sys
import inspect

idnString = 'SMB100A'


class Siggen_SMB100A:
    """Class for controlling Rohde & Schwarz SMB100A signal generator."""

    legal_on_off = {'ON': 1, 'OFF': 0}
    legal_on_off_rev = dict((v, k) for k, v in legal_on_off.items())

    def __init__(self, rmHandle):
        """ Constructor for Siggen_SMB100A class.
        
        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using 
                       :meth:`pyvisa.highlevel.ResourceManager.open_resource`
        """

        self.rmHandle = rmHandle
        self.debug_print_enable = 0
        self.reset()

    def freq(self, freq_hz=None):
        """Sets or queries the frequency of the main (RF) output.
        If called with no arguments, value is read from the instrument and returned.

        Args:
            freq_hz: Frequency in Hertz as a floating point number.
        """

        self.debug_print()

        if freq_hz is None:
            return float(self.rmHandle.query('frequency?'))

        min_val, max_val = 1000, 20.0e9
        if freq_hz < min_val or freq_hz > max_val:
            raise ValueError(f"Bad freq_hz {freq_hz}, should be {min_val} to {max_val}.")
        self.rmHandle.write(f"frequency {freq_hz} Hz")

        self.debug_print()

    def power(self, power_dbm=None):
        """Sets or queries the power of the main (RF) output.
         If called with no arguments, value is read from the instrument and returned.

         Args:
             power_dbm: Power in dBm as a floating point number.
         """

        self.debug_print()

        if power_dbm is None:
            return float(self.rmHandle.query('power?'))

        min_val, max_val = -145, 30.0
        if power_dbm < min_val or power_dbm > max_val:
            raise ValueError(f"Bad power_dbm {power_dbm}, should be {min_val} to {max_val}.")
        self.rmHandle.write(f"power {power_dbm}")

        self.debug_print()

    def output(self, on_off=None):
        """Sets or queries the state of the main (RF) output.
         If called with no arguments, value is read from the instrument and returned as a string.

         Args:
             on_off: 'ON' or 'OFF'. Case insensitive.
         """
        self.debug_print()

        if on_off is None:
            return self.legal_on_off_rev[int(self.rmHandle.query('output?'))]

        if on_off.upper() not in ('ON', 'OFF'):
            raise ValueError(f"Bad on_off {on_off}, can only set 'ON' or 'OFF'.")

        self.rmHandle.write(f'output {on_off.upper()}')

        self.debug_print()

    def modulation_am(self, on_off=None, source=None, am_type=None, depth=None):
        """ Sets or queries AM modulation parameters.
        Set the carrier frequency and power using the freq and power methods.
        The modulating signal is configured at its source, which is either external or the LFO.
        Configure LFO using the lfo method.
        If called with no arguments, values are read from the instrument and returned as a dict.
        To set, specify one or more parameters.

        Parameters:
            on_off: 'ON' enables modulation. 'OFF' disables.
            source: 'INT', 'EXT', 'INT,EXT' allowed for am_type ='LIN'.
                    'INT', 'EXT'   allowed for am_type ='EXP'.
                    Note: 'INT' corresponds to LFO.
            am_type: 'LIN' modulation depth is in percent.
                     'EXP' modulation depth is in dB.
            depth:   modulation depth in percent when am_type = 'LIN'.
                     modulation depth in dB when am_type = 'EXP'.

        SCPI Commands used (these strings searchable in R&S manual):
        [:SOURce<hw>]:AM:STATe <State>
        [:SOURce<hw>]:AM:TYPE <AmType>
        [:SOURce<hw>]:AM:DEPTh:LINear <DepthLin>
        """

        self.debug_print()

        if all(v is None for v in {on_off, source, am_type, depth}):
            return_val = dict()
            return_val.update(on_off=self.legal_on_off_rev[int(self.rmHandle.query('SOUR:AM:STAT?'))])
            return_val.update(source=self.rmHandle.query('SOUR:AM:SOUR?').strip())
            return_val.update(am_type=self.rmHandle.query('SOUR:AM:TYPE?').strip())
            return_val.update(depth=float(self.rmHandle.query('SOUR:AM:DEPT:LIN?')))
            return return_val

        if on_off is not None and on_off.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad modulation_am on_off '{on_off}', should be one of: {msg}.")

        legal_am_types = ('LIN', 'EXP')
        if am_type is not None and am_type.upper() not in legal_am_types:
            msg = ", ".join([f"'{x}'" for x in legal_am_types])
            raise ValueError(f"Bad modulation_am am_type '{am_type}', should be one of: {msg}.")

        if am_type is None:
            am_type_setting = self.rmHandle.query('SOUR:AM:TYPE?').strip()
        else:
            am_type_setting = am_type

        if am_type_setting == 'LIN':
            depth_min, depth_max, depth_units = 0.0, 100.0, '%'
            legal_sources = ('INT', 'EXT', 'INT,EXT')
        else:
            depth_min, depth_max, depth_units = -200.0, 0.0, 'dB'
            legal_sources = ('INT', 'EXT')

        if source is not None and source.upper() not in legal_sources:
            msg = ", ".join([f"'{x}'" for x in legal_sources])
            raise ValueError(f"Bad modulation_am source '{source} for am_type {am_type}', should be one of: {msg}.")

        if depth is not None and (depth < depth_min or depth > depth_max):
            raise ValueError(f"Bad depth {depth}. Should be {depth_min} to {depth_max} {depth_units}.")

        # Now that all parameters have been checked - program the instrument.

        if on_off is not None:
            self.rmHandle.write(f'SOUR:AM:STAT {on_off.upper()}')

        if source is not None:
            self.rmHandle.write(f'SOUR:AM:SOUR {source.upper()}')

        if am_type is not None:
            self.rmHandle.write(f'SOUR:AM:TYPE {am_type.upper()}')

        if depth is not None:
            self.rmHandle.write(f'SOUR:AM:DEPT:LIN {depth}')

        self.debug_print()

    def lfo(self, on_off=None, volts_pk=None, freq_hz=None, shape=None, impedance=None):
        """ Sets or queries LFO operating parameters.
        To query call with no Parameters, returns dict of present settings.
        To set specify one or more of the parameters.

        Parameters:
            on_off: 'ON' enables LFO output. 'OFF' disables.
            volts_pk: Output voltage in Volts peak.
            freq_hz: Output frequency in Hz.
            shape: 'SINE', 'SQU', 'TRI'
            impedance: 'LOW', or 'G600'

        SCPI Commands used (these strings searchable in R&S manual):
        [:SOURce]:LFOutput[:STATe]
        [:SOURce]:LFOutput:VOLTage
        [:SOURce]:LFOutput<ch>:FREQuency
        [:SOURce]:LFOutput:SHAPe
        [:SOURce]:LFOutput:SIMPedance
        """

        self.debug_print()

        if all(v is None for v in {on_off, volts_pk, freq_hz, shape, impedance}):
            return_val = dict()
            return_val.update(on_off=self.legal_on_off_rev[int(self.rmHandle.query('SOUR:LFO:STAT?'))])
            return_val.update(volts_pk=float(self.rmHandle.query('SOUR:LFO:VOLT?')))
            return_val.update(freq_hz=float(self.rmHandle.query('SOUR:LFO:FREQ?')))
            return_val.update(shape=self.rmHandle.query('SOUR:LFO:SHAP?').strip())
            return_val.update(impedance=self.rmHandle.query('SOUR:LFO:SIMP?').strip())
            return return_val

        if on_off is not None and on_off.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad lfo on_off '{on_off}', should be one of: {msg}.")

        volts_pk_min, volts_pk_max = 1e-3, 3.0
        if volts_pk is not None and (volts_pk < volts_pk_min or volts_pk > volts_pk_max):
            raise ValueError(f"Bad volts_pk {volts_pk}, should be {volts_pk_min} to {volts_pk_max}.")

        legal_shapes = ('SINE', 'SQU', 'TRI')  # 'SAW', 'ISAW')  # Must have proper option for SAW, ISAW.
        if shape is not None and shape.upper() not in legal_shapes:
            msg = ", ".join([f"'{x}'" for x in legal_shapes])
            raise ValueError(f"Bad lfo shape '{shape}', should be one of: {msg}.")

        if shape is None:
            shape_setting = self.rmHandle.query('SOUR:LFO:SHAP?').strip()
        else:
            shape_setting = shape

        freq_hz_min = 0.1
        if shape_setting == 'SINE':
            freq_hz_max = 1e6
        else:
            freq_hz_max = 20e3
        if freq_hz is not None and (freq_hz < freq_hz_min or freq_hz > freq_hz_max):
            raise ValueError(f"Bad lfo freq_hz {freq_hz}. Should be {freq_hz_min} to {freq_hz_max} Hz.")

        legal_impedances = ('LOW', 'G600')
        if impedance is not None and impedance.upper() not in legal_impedances:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad lfo impedance '{impedance}', should be one of: {msg}.")

        # Now that all parameters have been checked - program the instrument.

        if on_off is not None:
            self.rmHandle.write(f'SOUR:LFO:STAT {on_off.upper()}')

        if volts_pk is not None:
            self.rmHandle.write(f'SOUR:LFO:VOLT {volts_pk}')

        if freq_hz is not None:
            self.rmHandle.write(f'SOUR:LFO:FREQ {freq_hz}')

        if shape is not None:
            self.rmHandle.write(f'SOUR:LFO:SHAP {shape.upper()}')

        if impedance is not None:
            self.rmHandle.write(f'SOUR:LFO:SIMP {impedance}')

        self.debug_print()

    def modulation_pulse(self, on_off=None, period_sec=None, duty_pcnt=None):
        """ Sets or queries Pulse modulation parameters for a simple case of pulse modulation.
        To query, call with no Parameters, returns dict of present settings.
        To set specify one or more of the parameters.

        Parameters:
            on_off: 'ON' enables modulation. 'OFF' disables.
            period_sec: The pulse repetition period in seconds.
            duty_pcnt: Duty cycle in percent.
            
        NOTE: The instrument does not provide a SCPI command for duty cycle.
            Instead, this method programs the WIDTH based on the either the
            specified value of period_sec or the current period setting of the
            instrument.

            Several items not in the arguments are programmed by this method to ensure simple modulation_pulse works.
            These are: 'PULM:TRIG:MODE AUTO', 'PULM:SOUR INT', and 'PULM: MODE SING'.

        SCPI Commands used (these strings searchable in R&S manual):
        [:SOURce<hw>]:PULM:STATe <State>
        [:SOURce<hw>]:PULM:TRIGger:MODE <Mode>
        [:SOURce<hw>]:PULM:SOURce <Source>
        [:SOURce<hw>]:PULM:PERiod <Period>
        [:SOURce<hw>]:PULM:MODE <Mode>
        [:SOURce<hw>]:PULM:WIDTh <Width>
        """

        self.debug_print()

        period_setting = float(self.rmHandle.query('PULM:PER?'))
        width_setting = float(self.rmHandle.query('PULM:WIDT?'))
        duty_setting = (width_setting / period_setting) * 100.0

        if all(v is None for v in {on_off, period_sec, duty_pcnt}):
            return_val = dict()
            return_val.update(on_off=self.legal_on_off_rev[int(self.rmHandle.query('SOUR:PULM:STAT?'))])
            # return_val.update(trig_mode=self.rmHandle.query('PULM:TRIG:MODE?').strip())
            # return_val.update(source=self.rmHandle.query('PULM:SOUR?').strip())
            return_val.update(period_sec=period_setting)
            # return_val.update(mode=self.rmHandle.query('PULM:MODE?').strip())
            # return_val.update(width=width_setting)
            return_val.update(duty_pcnt=duty_setting)
            return return_val

        # Put instrument into correct mode for simple Pulse Mod setup.
        # Making some assumptions here, but do this because instrument settings
        # could have been changed so simple pulse modulation would work.
        self.rmHandle.write('PULM:TRIG:MODE AUTO')  # Continuous
        self.rmHandle.write('PULM:SOUR INT')
        self.rmHandle.write('PULM:MODE SING')

        if on_off is not None and on_off.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad modulation_pulse on_off '{on_off}', should be one of: {msg}.")

        period_min, period_max = 5e-6, 100
        if period_sec is not None and (period_sec < period_min or period_sec > period_max):
            raise ValueError(f"Bad modulation_pulse period_sec {period_sec}, should be {period_min} to {period_max}.")

        # Calculate width to achieve duty cycle.
        if period_sec is None:
            period = period_setting   # Use existing setting read out previously.
        else:
            period = period_sec       # Use new setting user specified.
        if duty_pcnt is None:
            width = (duty_setting / 100.0) * period
        elif 0.0 <= duty_pcnt <= 100.0:
            width = (duty_pcnt / 100.0) * period
        else:
            raise ValueError(f"Bad modulation_pulse duty_pcnt {duty_pcnt}, should be 0 to 100.")

        width = min(max(10e-9, width), period - 20e-9)  # Stay within bounds or instrument will error.

        # print(f"period={period/1e-9:4.1f}ns, width={width/1e-9:4.1f}ns, duty={100*width/period:3.1f}%")

        if on_off is not None:
            self.rmHandle.write(f'SOUR:PULM:STAT {on_off}')

        if period_sec is not None:
            self.rmHandle.write(f'SOUR:PULM:WIDT 10e-9')           # Avoid generating too big duty cycle.
            self.rmHandle.write(f'SOUR:PULM:PER {period_sec}')
            self.rmHandle.write(f'SOUR:PULM:WIDT {width}')
        elif duty_pcnt is not None:
            self.rmHandle.write(f'SOUR:PULM:WIDT {width}')      # period hasn't changed but user changed duty cycle.

        self.debug_print()
    # ----------------------------------------------------------------------------------------------

    def reset(self):
        """ Resets the signal generator to its factory defaults.
        """

        self.rmHandle.write('*RST')

    def getIdn(self):
        """ Queries signal generator IDN and returns string. """

        return self.rmHandle.query('*IDN?')

    def getError(self):
        """ Queries instrument error buffer and returns string. """

        return self.rmHandle.query('SYST:ERRor?').strip()

    def errlog(self):
        err_cmd = 'SYST:ERR?'
        err_list = []
        while True:
            err_msg = self.rmHandle.query(err_cmd)
            if 'No error' in err_msg:
                break
            else:
                err_list.append(err_msg)
        return err_list

    def debug_print(self):
        if self.debug_print_enable == 0:
            return
        err_list = self.errlog()
        if err_list or self.debug_print_enable == 1:
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            caller = frame_record[3]
            lineno = frame_record[2]
            print(f"debug print:{filename}:{caller} line {lineno} inst errors: {err_list}")

    def status(self):
        """
        Reads the state byte register and returns the names-values of the 3 state bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = int(self.rmHandle.query('*STB?').rstrip())

        conditions = {'EAV': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPR': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (state byte) and the error queue by sending '*CLS, command."""

        self.rmHandle.write('*CLS')


if __name__ == "__main__":
    import os

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    from InstMgr import InstMgr
    instMgr = InstMgr()

    # Obtain a handle to the instrument at specified address:
    siggen = instMgr.checkout(objName='siggen', interface='GPIB', addr=28, moduleSuffix='SMB100A')

    # Set the RF output frequency and level:
    siggen.power(0)        # 0 dBm
    siggen.freq(100e6)     # 100MHz

    # Turn output on:
    siggen.output('ON')

    # Setup the LFO parameters to generate the AM baseband signal:
    siggen.lfo('ON', volts_pk=1.0, freq_hz=50e3, shape='SINE')

    # Setup AM modulation using the lfo as the baseband signal:
    siggen.modulation_am('ON', source='INT', am_type='LIN', depth=25)

    # Modify the depth of AM modulation.
    siggen.modulation_am(depth=75)

    # Modify the modulation signal:
    siggen.lfo(freq_hz=20e3, shape='TRI')

    # Turn AM modulation off
    siggen.modulation_am('OFF')
    siggen.lfo('OFF')

    # Turn on pulse modulation
    siggen.modulation_pulse('ON', period_sec=1e-5, duty_pcnt=20)

    # Change the period, keeping same duty cycle
    siggen.modulation_pulse(period_sec=4e-5)

    # Change the duty cycle, keep same period.
    siggen.modulation_pulse(duty_pcnt=80)

    # Turn off pulse moduluation
    siggen.modulation_pulse('OFF')

    # To read back setting, call methods with no arguments.
    print(siggen.power())
    print(siggen.freq())
    print(siggen.output())
    print(siggen.lfo())
    print(siggen.modulation_am())
    print(siggen.modulation_pulse())


