# -*- coding: utf-8 -*-
"""
Class for controlling Rodhe & Schwarz NRP-Z81 Average Power Sensor.


@author: dkaroly
"""

import sys
import inspect

idnString = 'NRP-Z91'


class Pwrsensor_NRPZ91:
    """Class for controlling Rodhe & Schwarz NRP-Z81 Average Power Sensor.
    """
    legal_on_off = {'ON': 2, 'OFF': 1}
    legal_on_off_rev = dict((v, k) for k, v in legal_on_off.items())

    def __init__(self, rmHandle):
        """ Constructor for Pwrsensor_NRPZ91 class.
        
        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using 
                       :meth:`pyvisa.highlevel.ResourceManager.open_resource`
        """

        self.rmHandle = rmHandle
        self.reset()

    def averaging(self, on_off=None, count=None, tcontrol=None):
        """Queries (no args) or sets specified args related to the averaging of measured values to produce a result.

         NOTE: Turns auto averaging off, it depends on a lot of parameters I have not implemented an API for.

        :param on_off: Switches the averaging filter 'ON' or 'OFF'.
        :param count: Number of measured values averaged to produce the measured result. 1 to 65536.
        :param tcon: Behavior of averaging filter (if on):
            'MOV': A new average computed as each new measured value is shifted in.
            'REP': A new average computed only after filter is fills up with new measured values.
        :return:

        SCPI Cmds:
        SENSe:AVERage:STATe[?] OFF | ON
        SENSe:AVERage:COUNt:AUTO[?] OFF | ON | ONCE
        SENSe:AVERage:COUNt[?] 1 to 65536
        SENSe:AVERage:TCONtrol[?] MOVing | REPeat
        """

        legal_tcon = {'MOV': 1, 'REP': 2}
        legal_tcon_rev = dict((v, k) for k, v in legal_tcon.items())

        if all(v is None for v in {on_off, count, tcontrol}):
            return_val = dict()
            return_val.update(on_off=self.legal_on_off_rev[int(self.rmHandle.query('SENS:AVER:STAT?'))])
            return_val.update(count=int(self.rmHandle.query('SENS:AVER:COUN?')))
            return_val.update(tcontrol=legal_tcon_rev[int(self.rmHandle.query('SENS:AVER:TCON?'))])
            return return_val

        # Check all supplied parameters before changing any settings.
        if on_off is not None and on_off.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad averaging on_off '{on_off}', should be one of: {msg}.")

        if count is not None and (not isinstance(count, (int, float)) or count < 1 or count > 65536):
            raise ValueError(f'Bad averaging count {count}, should be 1 to 65536.')

        if tcontrol is not None and tcontrol.upper() not in legal_tcon:
            msg = ", ".join([f"'{x}'" for x in legal_tcon])
            raise ValueError(f"Bad averaging tcontrol '{tcontrol}', should be one of: {msg}.")

        # Now that all supplied parameters have been checked, program the instrument.

        self.rmHandle.write('SENSe:AVER:COUN:AUTO OFF')

        if on_off is not None:
            self.rmHandle.write(f'SENS:AVER:STAT {on_off.upper()}')
        if count is not None:
            self.rmHandle.write(f'SENS:AVER:COUN {int(count)}')
        if tcontrol is not None:
            self.rmHandle.write(f'SENS:AVER:TCON {tcontrol.upper()}')

    def average_reset(self):
        """Empties the averaging filter of previous measurement results.

        SCPI Cmds:
        SENSe:AVERage:RESet
        """

        self.rmHandle.write('SENS:AVE:RES')

    def meas_config(self, freq_hz=None, aperture_sec=None, buff_state=None, buffer_size=None, auto_range=None,
                    range=None):
        """
        Queries (no args) or sets power measurement frequency, aperture, buffering and range.

        :param freq_hz: Carrier frequency of the RF signal to be meassured, in Hz.
        :param aperture_sec: interval over which measurements values are recorded. 10.0e-6 to 0.3 sec.
        :param buff_state:'ON' activates continuous Average mode.
        :param buffer_size: for Continous Average mode. 1 to 1024
        :param auto_range: 'ON' activates automatic selection of measurement path.
        :param range: LOW, MEDIUM, HIGH corresponds to measurement paths 1, 2 3 respectively.
                            Reference values are: 40uW (-14dBm), 4mW (6dBm), 400mW (26dBm).
        :return:

        SCPI Cmds:
        SENSe:FREQuency[?] 9.0e3 to 6.0e9
        SENSe:POWer:AVG:APERture[?] 10.0eâ€“6 to 0.3
        SENSe:POWer:AVG:BUFFer:STATe[?] OFF | ON
        SENSe:POWer:AVG:BUFFer:SIZE[?] 1 to 1024
        SENSe:RANGe:AUTO[?] OFF | ON
        SENSe:RANGe[?] 0 to 2

        """

        legal_range= {'LOW': 0, 'MEDIUM': 1, 'HIGH': 2}
        legal_range_rev = dict((v, k) for k, v in legal_range.items())

        if all(v is None for v in {freq_hz, aperture_sec, buff_state, buffer_size, auto_range, range}):
            return_val = dict()
            return_val.update(freq_hz=float(self.rmHandle.query('SENS:FREQ?')))
            return_val.update(aperture_sec=float(self.rmHandle.query('SENS:POW:AVG:APER?')))
            return_val.update(buff_state=self.legal_on_off_rev[int(self.rmHandle.query('SENS:POW:AVG:BUFF:STAT?'))])
            return_val.update(buffer_size=int(self.rmHandle.query('SENS:POW:AVG:BUFF:SIZE?')))
            return_val.update(auto_range=self.legal_on_off_rev[int(self.rmHandle.query('SENS:RANG:AUTO?'))])
            return_val.update(range=legal_range_rev[int(self.rmHandle.query('SENS:RANG?'))])
            return return_val

        # Check all supplied parameters before changing any settings.
        if freq_hz is not None and (not isinstance(freq_hz, (int, float)) or freq_hz < 9.0e3 or freq_hz > 6.0e9):
            raise ValueError(f'Bad meas_config freq_hz {freq_hz}, should be  9.0e3 to 6.0e9 Hz.')

        if aperture_sec is not None and (not isinstance(aperture_sec, (int, float))
                                         or aperture_sec < 10e-6 or aperture_sec > 0.3):
            raise ValueError(f'Bad meas_config aperture_sec {aperture_sec}, should be  10e-6 to 0.3 sec.')

        if buff_state is not None and buff_state.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad meas_config buff_state '{buff_state}', should be one of: {msg}.")

        if buffer_size is not None and (not isinstance(buffer_size, (int, float))
                                        or buffer_size < 1 or buffer_size > 1024):
            raise ValueError(f'Bad meas_config buffer_size {buffer_size}, should be 1 to 1024.')

        if auto_range is not None and auto_range.upper() not in self.legal_on_off:
            msg = ", ".join([f"'{x}'" for x in self.legal_on_off])
            raise ValueError(f"Bad meas_config auto_range '{auto_range}', should be one of: {msg}.")

        if range is not None and range not in legal_range:
            msg = ", ".join([f"'{x}'" for x in legal_range])
            raise ValueError(f"Bad meas_config legal_range '{legal_range}', should be one of: {msg}.")

        # Now that all supplied parameters have been checked, program the instrument.
        if freq_hz is not None:
            self.rmHandle.write(f'SENS:FREQ {freq_hz}')
        if aperture_sec is not None:
            self.rmHandle.write(f'SENS:POW:AVG:APER {aperture_sec}')
        if buff_state is not None:
            self.rmHandle.write(f'SENS:POW:AVG:BUFF:STAT {buff_state}')
        if buffer_size is not None:
            self.rmHandle.write(f'SENS:POW:AVG:BUFF:SIZE {int(buffer_size)}')
        if auto_range is not None:
            self.rmHandle.write(f'SENS:RANG:AUTO {auto_range}')
        if range is not None:
            self.rmHandle.write(f'SENS:RANG {legal_range[range.upper()]}')

    def meas_immed(self):
        """From the idle state triggers an immediate measurement and fetches the data.

        :return a single power measurement in watts

        SCPI Cmds:
        SENSe:FUNCtion[?] <sensor_function>
        INITiate:IMMediate
        FETCH?
        """

        self.rmHandle.write('INIT:IMM')
        valstr = self.rmHandle.query('FETCH?').strip()
        return float(valstr.split(',')[0])

    def meas_abort(self):
        """Interrupts current measurement and returns to IDLE state.

        SCPI Cmds:
        ABORt
        INITiate:CONTinuous[?] OFF | ON
        """

        self.rmHandle.write('ABOR')
        self.rmHandle.write('INIT:CONT OFF')


    def sys_info(self):
        """Returns dict containing more detailed info than returned by getIdn().
        """

        return_value = dict()
        for item in self.rmHandle.query('SYST:INFO?').split('\r\n'):
            if ':' in item:
                key, value = item.split(':')
                return_value.update({key: value})
        return return_value

    # ----------------------------------------------------------------------------------------------

    def getIdn(self):
        """ Queries instrument IDN and returns string. """

        return self.rmHandle.query('*IDN?')

    def reset(self):
        """ Resets the counter its factory defaults.
        """

        self.rmHandle.write('*RST')


if __name__ == "__main__":
    import os
    import math
    import time

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()

    pwrsensor = instMgr.checkout(objName='pwrsensor', interface='USB', addr='0x0021::150176', moduleSuffix='NRPZ91')
    pwrsensor.meas_config(freq_hz=100e6, auto_range='OFF', range='HIGH')
    pwrsensor.averaging('OFF')

    siggen = instMgr.checkout(objName='siggen', interface='GPIB', addr=28, moduleSuffix='SMB100A')

    # Set the RF output frequency and level:
    siggen.power(0)        # 0 dBm
    siggen.freq(100e6)     # 100MHz

    siggen.modulation_pulse('OFF', period_sec=0.001, duty_pcnt=100)

    # Turn output on:
    siggen.output('ON')
    time.sleep(1)

    reading_Watts = pwrsensor.meas_immed()
    print('With duty_pcnt = 100%')
    print(f'Sensor reading = {reading_Watts:3.2e} W = {10 * math.log10(reading_Watts / 0.001):3.3f} dBm')

    siggen.modulation_pulse('ON', period_sec=0.001, duty_pcnt=50)
    time.sleep(1)

    reading_Watts = pwrsensor.meas_immed()
    print('With duty_pcnt = 50%')
    print(f'Sensor reading = {reading_Watts:3.2e} W = {10 * math.log10(reading_Watts / 0.001):3.3f} dBm')