# -*- coding: utf-8 -*-
"""
Created on Mon Jun 18 11:10:16 2018

@author: dzhang
"""
import inspect
import time

idnString = 'DPO5034B'

# need dict with all settings
#  setting, mnemonic value, actual scpi value map if string / min/max limits if decimal, flag for whether value is changed.
#   --also need to be able to tell it how to generate the SCPI string given dict values.
#  with flag, can provide procs to read dict & update dict and also to get valid values.
#  update dict proc can have parameter to commit all changes to instrument.

# 

# DK: Converted this from MSO5104B into DPO5034, had and has no logic Bus functionality implemented. No serves as base
# class for MSO versions and other 5K series scopes.

class Oscope_DPO5034B:
    # index 0 in options tuple could be assumed to be the default
    # here, innermost dict is command mnemonic:{current value,(possible values), SCPI base command, flag that value needs updated to instrument}
    instDict = {
        'discrete': {
            'ch1state': ['ON', {'ON': 'ON', 'OFF': 'OFF'}, 'SEL:CH1', False],
            'ch2state': ['ON', {'ON': 'ON', 'OFF': 'OFF'}, 'SEL:CH2', False],
            'ch3state': ['ON', {'ON': 'ON', 'OFF': 'OFF'}, 'SEL:CH3', False],
            'ch4state': ['ON', {'ON': 'ON', 'OFF': 'OFF'}, 'SEL:CH4', False],
            'ch1coupling': ['DC', {'AC': 'AC', 'DC': 'DC', 'GND': 'GND'}, 'CH1:COUP', False],
            'ch2coupling': ['DC', {'AC': 'AC', 'DC': 'DC', 'GND': 'GND'}, 'CH2:COUP', False],
            'ch3coupling': ['DC', {'AC': 'AC', 'DC': 'DC', 'GND': 'GND'}, 'CH3:COUP', False],
            'ch4coupling': ['DC', {'AC': 'AC', 'DC': 'DC', 'GND': 'GND'}, 'CH4:COUP', False],
            'ch1bandwidth': ['FUL', {'20MHz': 'TWE', '250MHz': 'TWO', 'FULL': 'FUL', '500MHz': 'FIV'}, 'CH1:BAN', False],
            'ch2bandwidth': ['FUL', {'20MHz': 'TWE', '250MHz': 'TWO', 'FULL': 'FUL', '500MHz': 'FIV'}, 'CH2:BAN', False],
            'ch3bandwidth': ['FUL', {'20MHz': 'TWE', '250MHz': 'TWO', 'FULL': 'FUL', '500MHz': 'FIV'}, 'CH3:BAN', False],
            'ch4bandwidth': ['FUL', {'20MHz': 'TWE', '250MHz': 'TWO', 'FULL': 'FUL', '500MHz': 'FIV'}, 'CH4:BAN', False],
            'ch1termination': ['1000000', {'50Ohm': '50', '1MOhm': '1000000'}, 'CH1:TER', False],
            'ch2termination': ['1000000', {'50Ohm': '50', '1MOhm': '1000000'}, 'CH2:TER', False],
            'ch3termination': ['1000000', {'50Ohm': '50', '1MOhm': '1000000'}, 'CH3:TER', False],
            'ch4termination': ['1000000', {'50Ohm': '50', '1MOhm': '1000000'}, 'CH4:TER', False],
            'recordLength': ['10000',
                             {'1k': '1000', '10k': '10000', '100k': '100000', '1M': '1000000', '10M': '10000000'}, 'HOR:MODE:RECO', False],
            'triggerType': ['EDG', {'edge': 'EDGE', 'logic': 'LOGI', 'pulse': 'PUL', 'video': 'VID'}, 'TRIG:A:TYP', False],
            'triggerMode': ['AUTO', {'auto': 'AUTO', 'normal': 'NORM'}, 'TRIG:A:MOD', False],
            'triggerEdgeSource': ['CH1', {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4'}, 'TRIG:A:EDGE:SOU', False],
            'triggerEdgeSlope': ['RIS', {'rise': 'RIS', 'fall': 'FALL', 'either': 'EIT'}, 'TRIG:A:EDGE:SLO', False],
            'triggerpulseClass': ['WID', {'glitch': 'GLI', 'runt': 'RUNT', 'width': 'WID'}, 'TRIG:A:PUL:CLA'],
            'triggerpulseSource': ['CH1', {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4'}, 'TRIG:A:PUL:SOU', False],
            'triggerpulseWidthPolarity': ['POSITIV', {'positive': 'POSITIV', 'negative': 'NEGA'}, 'TRIG:A:PUL:WID:POL', False],
            'triggerHoldoff': ['TIM', {'time': 'TIM', 'default': 'DEFA', 'random': 'RAND', 'auto': 'AUTO'}, 'TRIG:A:HOLD:BY', False],
            'runSingle': ['RUNST', {'continuous': 'RUNST', 'single': 'SEQ'}, 'ACQ:STOPA', False],
            'runState': ['RUN', {'run': 'RUN', 'stop': 'STOP', 'OFF': 'OFF', 'ON': 'ON'}, 'ACQ:STATE', False],
            'acqMode': ['SAM', {'samp': 'SAM', 'peak': 'PEAK', 'hirez': 'HIR', 'ave': 'AVE', 'wfmdb': 'WFMDB',
                                'env': 'ENV'}, 'ACQ:MODE', False],

            'measureannotationstate': ['MEAS1',
                                       {'off': 'OFF', 'meas1': 'MEAS1', 'meas2': 'MEAS2', 'meas3': 'MEAS3', 'meas4': 'MEAS4',
                                        'meas5': 'MEAS5', 'meas6': 'MEAS6', 'meas7': 'MEAS7', 'meas8': 'MEAS8'}, 'MEASU:ANNOT:STATE', False],
            'measureannotationtype': ['STAN', {'standard': 'STAN', 'detailed': 'DETA'}, 'MEASU:ANNOT:TYP', False],
            'measuremethod': ['MEAN', {'histogram': 'HIS', 'mean': 'MEAN', 'minmax': 'MINM'}, 'MEASU:METH', False],

            # TODO: think another way to add multiple measurements below, the current format is not efficient
            'meas1state': ['ON', {'on': 'ON', 'off': 'OFF'}, 'MEASU:MEAS1:STATE', False],
            'meas1type': ['AMP', {'amplitude': 'AMP', 'area': 'ARE', 'burst': 'BUR', 'carea': 'CAR', 'cmean': 'CME',
                                  'crms': 'CRM',
                                  'delay': 'DEL',
                                  'distduty': 'DISTDU', 'extinctdb': 'EXTINCTDB', 'extinctpct': 'EXTINCTPCT',
                                  'eyeheight': 'EYEH',
                                  'eyewidth': 'EYEWI',
                                  'fall': 'FALL', 'frequency': 'FREQ', 'high': 'HIGH', 'hits': 'HIT', 'low': 'LOW',
                                  'maximum': 'MAX',
                                  'mean': 'MEAN',
                                  'median': 'MED', 'minimum': 'MINI', 'ncross': 'NCRO', 'nduty': 'NDU',
                                  'novershoot': 'NOV',
                                  'nwidth': 'NWI', 'pbase': 'PBAS',
                                  'pcross': 'PCRO', 'pctcross': 'PCTCRO', 'pduty': 'PDU', 'peakhits': 'PEAKH',
                                  'period': 'PERI',
                                  'phase': 'PHA', 'pk2pk': 'PK2P',
                                  'pkpkjitter': 'PKPKJ', 'pkpknoise': 'PKPKN', 'povershoot': 'POV', 'ptop': 'PTOP',
                                  'pwidth': 'PWI',
                                  'qfactor': 'QFAC',
                                  'rise': 'RIS', 'rms': 'RMS', 'rmsjitter': 'RMSJ', 'rmsnoise': 'RMSN',
                                  'sigma1': 'SIGMA1',
                                  'sigma2': 'SIGMA2', 'sigma3': 'SIGMA3',
                                  'sixsigmajit': 'SIXS', 'snratio': 'SNR', 'stddev': 'STD', 'undefined': 'UNDEFINED',
                                  'waveforms': 'WAVEFORMS'}, 'MEASU:MEAS1:TYP', False],
            'meas1method': ['MEAN', {'histogram': 'HIS', 'mean': 'MEAN', 'minmax': 'MINM'}, 'MEASU:METH', False],
            'meas1source1': ['CH1', {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4',
                                     'math1': 'MATH1', 'math2': 'MATH2', 'math3': 'MATH3', 'math4': 'MATH4',
                                     'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3', 'ref4': 'REF4',
                                     'histogram': 'HIS'}, 'MEASU:MEAS1:SOU1', False],
            'meas1source2': ['CH1', {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4',
                                     'math1': 'MATH1', 'math2': 'MATH2', 'math3': 'MATH3', 'math4': 'MATH4',
                                     'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3', 'ref4': 'REF4'},
                             'MEASU:MEAS1:SOU2', False],
            'meas1source3': ['CH1', {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4', 'math1': 'MATH1',
                                     'math2': 'MATH2',
                                     'math3': 'MATH3', 'math4': 'MATH4', 'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3',
                                     'ref4': 'REF4'}, 'MEASU:MEAS1:SOU3', False],
            'meas1source4': ['CH1', {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4',
                                     'math1': 'MATH1', 'math2': 'MATH2', 'math3': 'MATH3', 'math4': 'MATH4',
                                     'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3', 'ref4': 'REF4'},
                             'MEASU:MEAS1:SOU4', False],
            'meas1delayedge1': ['RIS', {'rise': 'RIS', 'fall': 'FALL'}, 'MEASU:MEAS1:DEL:EDGE1', False],
            'meas1delayedge2': ['RIS', {'rise': 'RIS', 'fall': 'FALL'}, 'MEASU:MEAS1:DEL:EDGE2', False],
            'meas1delaydirection': ['FORW', {'forwards': 'FORW', 'backwards': 'BACKW'}, 'MEASU:MEAS1:DEL:DIRE', False],
            'meas1reflevelmethod': ['PERC', {'percent': 'PERC', 'absolute': 'ABS'}, 'MEASU:MEAS1:REFL:METH', False],

            'meas2state': ['ON', {'on': 'ON', 'off': 'OFF'}, 'MEASU:MEAS2:STATE', False],
            'meas2type': ['AMP', {'amplitude': 'AMP', 'area': 'ARE', 'burst': 'BUR', 'carea': 'CAR', 'cmean': 'CME',
                                  'crms': 'CRM',
                                  'delay': 'DEL',
                                  'distduty': 'DISTDU', 'extinctdb': 'EXTINCTDB', 'extinctpct': 'EXTINCTPCT',
                                  'eyeheight': 'EYEH',
                                  'eyewidth': 'EYEWI',
                                  'fall': 'FALL', 'frequency': 'FREQ', 'high': 'HIGH', 'hits': 'HIT', 'low': 'LOW',
                                  'maximum': 'MAX',
                                  'mean': 'MEAN',
                                  'median': 'MED', 'minimum': 'MINI', 'ncross': 'NCRO', 'nduty': 'NDU',
                                  'novershoot': 'NOV',
                                  'nwidth': 'NWI', 'pbase': 'PBAS',
                                  'pcross': 'PCRO', 'pctcross': 'PCTCRO', 'pduty': 'PDU', 'peakhits': 'PEAKH',
                                  'period': 'PERI',
                                  'phase': 'PHA', 'pk2pk': 'PK2P',
                                  'pkpkjitter': 'PKPKJ', 'pkpknoise': 'PKPKN', 'povershoot': 'POV', 'ptop': 'PTOP',
                                  'pwidth': 'PWI',
                                  'qfactor': 'QFAC',
                                  'rise': 'RIS', 'rms': 'RMS', 'rmsjitter': 'RMSJ', 'rmsnoise': 'RMSN',
                                  'sigma1': 'SIGMA1',
                                  'sigma2': 'SIGMA2', 'sigma3': 'SIGMA3',
                                  'sixsigmajit': 'SIXS', 'snratio': 'SNR', 'stddev': 'STD', 'undefined': 'UNDEFINED',
                                  'waveforms': 'WAVEFORMS'}, 'MEASU:MEAS2:TYP', False],
            #                             'meas2method':['MEAN', {'histogram':'HIS', 'mean':'MEAN', 'minmax':'MINM'}, 'MEASU:METH',False],
            'meas2source1': ['CH1',
                             {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4',
                              'math1': 'MATH1', 'math2': 'MATH2', 'math3': 'MATH3', 'math4': 'MATH4',
                              'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3', 'ref4': 'REF4',
                              'histogram': 'HIS'}, 'MEASU:MEAS2:SOU1', False],
            'meas2source2': ['CH1',
                             {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4',
                              'math1': 'MATH1', 'math2': 'MATH2', 'math3': 'MATH3', 'math4': 'MATH4',
                              'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3', 'ref4': 'REF4'},
                             'MEASU:MEAS2:SOU2', False],
            'meas2source3': ['CH1',
                             {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4',
                              'math1': 'MATH1', 'math2': 'MATH2', 'math3': 'MATH3', 'math4': 'MATH4',
                              'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3', 'ref4': 'REF4'},
                             'MEASU:MEAS2:SOU3', False],
            'meas2source4': ['CH1',
                             {'ch1': 'CH1', 'ch2': 'CH2', 'ch3': 'CH3', 'ch4': 'CH4',
                              'math1': 'MATH1', 'math2': 'MATH2', 'math3': 'MATH3', 'math4': 'MATH4',
                              'ref1': 'REF1', 'ref2': 'REF2', 'ref3': 'REF3', 'ref4': 'REF4'},
                             'MEASU:MEAS2:SOU4', False],
            'meas2delayedge1': ['RIS', {'rise': 'RIS', 'fall': 'FALL'}, 'MEASU:MEAS2:DEL:EDGE1', False],
            'meas2delayedge2': ['RIS', {'rise': 'RIS', 'fall': 'FALL'}, 'MEASU:MEAS2:DEL:EDGE2', False],
            'meas2delaydirection': ['FORW', {'forwards': 'FORW', 'backwards': 'BACKW'}, 'MEASU:MEAS2:DEL:DIRE', False],
            'meas2reflevelmethod': ['PERC', {'percent': 'PERC', 'absolute': 'ABS'}, 'MEASU:MEAS2:REFL:METH', False],

            'saveon': ['', {}, 'SAVEON'],
            # 'savefiledestination': ['',{},'SAVEON:FILE:DEST'],     # this might need different format to enter value
            # 'savefilename':['',{},'SAVEON:FILE:NAME'],             # this might need different format to enter value
            'saveonfiletype': ['AUTO', {'auto': 'AUTO', 'custom': 'CUSTOM'}, 'SAVEON:FILE:TYPE'],
            'saveonimage': ['ON', {'on': 'ON', 'off': 'OFF'}, 'SAVEON:IMAG'],
            'saveonmeas': ['ON', {'on': 'ON', 'off': 'OFF'}, 'SAVEON:MEASU'],
            'saveontrigger': ['ON', {'on': 'ON', 'off': 'OFF'}, 'SAVEON:TRIG'],
            'saveonwaveform': ['ON', {'on': 'ON', 'off': 'OFF'}, 'SAVEON:WAVE'],

        },

        'continuous': {
            'ch1position': [0, (-8, 8), 'CH1:POS'],
            'ch2position': [0, (-8, 8), 'CH2:POS'],
            'ch3position': [0, (-8, 8), 'CH3:POS'],
            'ch4position': [0, (-8, 8), 'CH4:POS'],
            'ch1offset': [0, (-10, 10), 'CH1:OFFS'],
            'ch2offset': [0, (-10, 10), 'CH2:OFFS'],
            'ch3offset': [0, (-10, 10), 'CH3:OFFS'],
            'ch4offset': [0, (-10, 10), 'CH4:OFFS'],
            'ch1voltPerDiv': [1, None, 'CH1:SCA'],
            'ch2voltPerDiv': [1, None, 'CH2:SCA'],
            'ch3voltPerDiv': [1, None, 'CH3:SCA'],
            'ch4voltPerDiv': [1, None, 'CH4:SCA'],
            'secPerDiv': [40e-6, (400e-12, 1e3), 'HOR:MODE:SCA'],
            'horizPosition': [50, (0, 100), 'HOR:POS'],
            'triggerLevel': [0, None, 'TRIG:A:LEV'],
            'triggerpulseWidthlimitH': [1e-10, None, 'TRIG:A:PUL:WID:HIGHL'],
            'triggerpulseWidthlimitL': [1e-10, None, 'TRIG:A:PUL:WID:LOWL'],
            'triggerHoldofftime': [2.5e-7, (25e-8, 12), 'TRIG:A:HOLD:TIM'],

            'meas1reflevelpercenthigh': [90, (0, 100), 'MEASU:MEAS1:REFL:PERC:HIGH'],
            'meas1reflevelpercentlow': [10, (0, 100), 'MEASU:MEAS1:REFL:PERC:LOW'],
            'meas1reflevelabsolutehigh': [1.5, (0, 20), 'MEASU:MEAS1:REFL:ABS:HIGH'],
            'meas1reflevelabsolutelow': [0, (0, 20), 'MEASU:MEAS1:REFL:ABS:LOW'],
            'meas1reflevelabsolutemid': [0.5, (0, 20), 'MEASU:MEAS1:REFL:ABS:MID'],
            'meas2reflevelpercenthigh': [90, (0, 100), 'MEASU:MEAS2:REFL:PERC:HIGH'],
            'meas2reflevelpercentlow': [10, (0, 100), 'MEASU:MEAS2:REFL:PERC:LOW'],
            'meas2reflevelabsolutehigh': [1.5, (0, 20), 'MEASU:MEAS2:REFL:ABS:HIGH'],
            'meas2reflevelabsolutelow': [0, (0, 20), 'MEASU:MEAS2:REFL:ABS:LOW'],
            'meas2reflevelabsolutemid': [0.5, (0, 20), 'MEASU:MEAS2:REFL:ABS:MID'],
        },
    }

    def __init__(self, rmHandle):
        self.rmHandle = rmHandle
        self.debug_print_enable = 0

    def reset(self):
        #  just execute *RST command
        self.rmHandle.write('*RST')
        pass

    # later add method that takes variable arguments to do several parameters at once & uses write flag to commit values to inst after all parameters are processed.
    # Here: param is a string, val is an int, real, or string
    def setInstParam(self, param, val, commit=1):
        if param in self.instDict['discrete'].keys():
            if val in self.instDict['discrete'][param][1].keys():
                self.instDict['discrete'][param][0] = self.instDict['discrete'][param][1][val]
                self.rmHandle.write(self.instDict['discrete'][param][2] + ' ' + self.instDict['discrete'][param][0])
            else:
                self.logger.warning(
                    'WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(
                        self.instDict['discrete'][param][1].keys()))
        elif param in self.instDict['continuous'].keys():
            if (self.instDict['continuous'][param][1] is None) or (
                    (self.instDict['continuous'][param][1] is not None) and (
                    val >= self.instDict['continuous'][param][1][0]) and (
                            val <= self.instDict['continuous'][param][1][1])):
                self.instDict['continuous'][param][0] = val
                self.rmHandle.write(
                    self.instDict['continuous'][param][2] + ' ' + str(self.instDict['continuous'][param][0]))
            pass
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')

        pass

    # other action commands here might include
    #   -set capture mode: auto/triggered
    #   -set run/stop/single
    #   -immediate trigger

    # other data commands here might include
    #   -get measurement (immediate/1-8/stats)
    #   -get waveform

    def saveimage_enable(self, filename="", filepath='\"C:\\screenshots\"'):
        sendStr = 'SAVEON:FILE:DEST ' + filepath
        self.rmHandle.write(sendStr)
        # print(self.rmHandle.query('SAVEON:FILE:DEST?'))
        # print("Filename is " + filename)

        if filename == "":
            self.setInstParam('saveonfiletype', 'auto')
            # self.rmHandle.write('SAVEON:FILE:TYPE AUTO')
        else:
            self.setInstParam('saveonfiletype', 'custom')
            # self.rmHandle.write('SAVEON:FILE:TYPE CUSTOM')
            sendStr = 'SAVEON:FILE:NAME ' + filename
            self.rmHandle.write(sendStr)
            # print(self.rmHandle.query('SAVEON:FILE:NAME?'))

        self.setInstParam('saveontrigger', 'on')
        self.setInstParam('saveonimage', 'on')
        pass

    def saveimage_disable(self):
        self.setInstParam('saveonimage', 'off')
        self.setInstParam('saveontrigger', 'off')
        pass

    def getIdn(self):
        return self.rmHandle.query('*IDN?')

    def getParams(self):
        self.logger.debug(self.rmHandle.query('HOR?'))
        self.logger.debug(self.rmHandle.query('CH1?'))

    def close(self):
        # here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass

    def measurement_enable(self, src1='CH1', src2='CH2'):

        setupList = [('measureannotationstate', 'meas1'),
                     ('meas1state', 'off'),
                     # ('meas1method', 'mean'),
                     ('meas1type', 'delay'),
                     ('meas1source1', src1),
                     ('meas1source2', src2),
                     ('meas1delayedge1', 'rise'),
                     ('meas1delayedge2', 'rise'),
                     ('meas1reflevelmethod', 'percent'),
                     ('meas1reflevelpercenthigh', 80),
                     ('meas1delaydirection', 'forwards'),
                     ('measuremethod', 'mean'),
                     ('meas1state', 'on'),
                     ]
        for param, val in setupList:
            self.setInstParam(param=param, val=val)

    def measure_delay(self):
        # self.rmHandle.write('MEASUrement:MEAS1:STATE ON')
        # time.sleep(0.2)
        return self.rmHandle.query('MEASUrement:MEAS1:MEAN?')

    def measurement_disable(self):
        self.setInstParam('meas1state', 'off')
        self.setInstParam('measureannotationstate', 'off')

    def getScreenShot(self, filename='', data_to_pc=True, read_timeout_ms=None):

        # On 5000 series you have to save scope filesystem, then transfer over bus to PC.

        # Setup saving on C: drive of scope.
        self.rmHandle.write('EXPORT:FORMAT PNG')
        self.rmHandle.write('HARDC:PORT FILE')

        default_scope_dir = 'C:/Users/Public/Tektronix/TekScope'
        # 'C:/TekScope/screenshot_temp.png'

        if data_to_pc:
            scope_filepath =  default_scope_dir + '/' + 'scrnshot_temp.png'
        else:
            scope_filepath = filename

        self.rmHandle.write(f'HARDC:FILEN "{scope_filepath}"')

        # Save the image
        self.rmHandle.write('HARDC START')

        if data_to_pc:
            return self.getFileFromScope(scope_filepath, filename, mode='b', read_timeout_ms=read_timeout_ms)

        return 0

    def saveMarks(self, filename='', data_to_pc=True, read_timeout_ms=None):

        if data_to_pc:
            scope_filepath = 'C:/TekScope/marks_temp.png'
        else:
            scope_filepath = filename

        # Setup saving on scopes C: drive.
        self.rmHandle.write(f'SAVE:MARKS "{scope_filepath}"')

        if data_to_pc:
            return self.getFileFromScope(scope_filepath, filename, mode='t', read_timeout_ms=read_timeout_ms)

        return 0

    def getFileFromScope(self, scope_filepath, pc_filepath='', mode='t', read_timeout_ms=None):

        self.rmHandle.write(f'FILES:READF "{scope_filepath}"')

        if read_timeout_ms is not None:
            timeout_prev = self.rmHandle.timeout
            self.rmHandle.timeout = read_timeout_ms

        if mode == 't':
            result = self.rmHandle.read()  # read as text
        else:
            result = self.rmHandle.read_raw()

        if read_timeout_ms is not None:
            self.rmHandle.timeout = timeout_prev

        if pc_filepath is None or len(pc_filepath) == 0:
            return result

        newfile = open(pc_filepath, 'w' + mode)
        newfile.write(result)
        newfile.close()
        return len(result)  # Return the number of bytes or chars written.

    def trig_force(self):
        self.rmHandle.write('TRIG FORC')

    def errlog(self):
        err_list = []
        while int(self.rmHandle.query('*ESR?').strip()):
            time.sleep(0.10)
            err_msg = self.rmHandle.query('EVM?')
            err_list.append(err_msg)
        return err_list

    def debug_print(self):
        if self.debug_print_enable == 0:
            return
        err_list = self.errlog()
        if err_list or self.debug_print_enable == 1:
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            caller = frame_record[3]
            lineno = frame_record[2]
            print(f"debug print:{filename}:{caller} line {lineno} inst errors: {err_list}")

if __name__ == "__main__":
    import os
    import sys
    import time

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)

    import InstMgr

    instMgr = InstMgr.InstMgr()
    scope = instMgr.checkout(objName='oscope', interface='USB', addr='0x0699::0x0503::C031053', moduleSuffix='DPO5034B')
    # sg = instMgr.checkout(objName='funcgen', interface='GPIB', addr='12', moduleSuffix='33250A')

    scope.reset()
    # sg.reset()
    time.sleep(1)
    print(scope.getIdn())

    # set up sig gen to test the scope, connect sig gen to scope ch3
    scope.setInstParam('ch1state', 'ON')
    scope.setInstParam('ch2state', 'ON')
    scope.setInstParam('ch1coupling', 'DC')
    scope.setInstParam('ch1bandwidth', '20MHz')
    scope.setInstParam('ch1termination', '50Ohm')
    scope.setInstParam('ch1position', 0)
    scope.setInstParam('ch1voltPerDiv', 0.8)
    scope.setInstParam('ch2coupling', 'DC')
    scope.setInstParam('ch2bandwidth', '20MHz')
    scope.setInstParam('ch2termination', '50Ohm')
    scope.setInstParam('ch2position', -4)
    scope.setInstParam('ch2voltPerDiv', 0.8)

    scope.setInstParam('triggerType', 'edge')
    scope.setInstParam('triggerMode', 'auto')
    scope.setInstParam('triggerEdgeSource', 'ch2')
    scope.setInstParam('triggerEdgeSlope', 'rise')
    scope.setInstParam('runSingle', 'continuous')
    scope.setInstParam('triggerLevel', 1)

    scope.setInstParam('horizPosition', 20)
    scope.setInstParam('recordLength', '10M')
    scope.setInstParam('secPerDiv', 50e-9)

    print('\n\n\n ENABLE SCOPE')
    scope.setInstParam('runState', 'run')
    scope.saveimage_enable()
    time.sleep(1)

    # print('\n\n\n START SIGNAL')
    # sg.setOutputImp()
    # sg.quick_setOutput(shape='square', freq=2400000, vpp=1.8, vos=0.9)
    # sg.setOutputStat(state='on')

    time.sleep(3)

#    scope.saveimage_disable()
#    scope.close()
#    sg.close()
