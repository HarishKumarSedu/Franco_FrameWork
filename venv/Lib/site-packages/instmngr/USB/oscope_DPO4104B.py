# -*- coding: utf-8 -*-
"""
Created on Mon Nov 28 11:23:13 2016

@author: jmunger
"""

import sys
import time
import struct
idnString = 'DPO4104B'

# need dict with all settings
#  setting, mnemonic value, actual scpi value map if string / min/max limits if decimal, flag for whether value is changed.
#   --also need to be able to tell it how to generate the SCPI string given dict values.
#  with flag, can provide procs to read dict & update dict and also to get valid values.
#  update dict proc can have parameter to commit all changes to instrument.

# 

class Oscope_DPO4104B():
    #index 0 in options tuple could be assumed to be the default
    #here, innermost dict is command mmenmoic:{current value,(possible values),SCPI base command,flag that value needs updated to instrument}
    instDict = {'discrete': {'ch1state':['ON',{'ON':'ON','OFF':'OFF'},'SEL:CH1',False],
                             'ch2state':['ON',{'ON':'ON','OFF':'OFF'},'SEL:CH2',False],
                             'ch3state':['ON',{'ON':'ON','OFF':'OFF'},'SEL:CH3',False],
                             'ch4state':['ON',{'ON':'ON','OFF':'OFF'},'SEL:CH4',False],
                             'ch1coupling':['ON',{'AC':'AC','DC':'DC','GND':'GND'},'CH1:COUP',False],
                             'ch2coupling':['ON',{'AC':'AC','DC':'DC','GND':'GND'},'CH2:COUP',False],
                             'ch3coupling':['ON',{'AC':'AC','DC':'DC','GND':'GND'},'CH3:COUP',False],
                             'ch4coupling':['ON',{'AC':'AC','DC':'DC','GND':'GND'},'CH4:COUP',False],
                             'ch1bandwidth':['FULL',{'20MHz':'TWE','250MHz':'TWO','FULL':'FULL'},'CH1:BAN',False],
                             'ch2bandwidth':['FULL',{'20MHz':'TWE','250MHz':'TWO','FULL':'FULL'},'CH2:BAN',False],
                             'ch3bandwidth':['FULL',{'20MHz':'TWE','250MHz':'TWO','FULL':'FULL'},'CH3:BAN',False],
                             'ch4bandwidth':['FULL',{'20MHz':'TWE','250MHz':'TWO','FULL':'FULL'},'CH4:BAN',False],
                             'ch1termination':['MEG',{'50Ohm':'FIF','1MOhm':'MEG'},'CH1:TER',False],
                             'ch2termination':['MEG',{'50Ohm':'FIF','1MOhm':'MEG'},'CH2:TER',False],
                             'ch3termination':['MEG',{'50Ohm':'FIF','1MOhm':'MEG'},'CH3:TER',False],
                             'ch4termination':['MEG',{'50Ohm':'FIF','1MOhm':'MEG'},'CH4:TER',False],
                             'recordLength':['10000',{'1k':'1000','10k':'10000','100k':'100000','1M':'1000000','10M':'10000000'},'HOR:RECO',False],
                             'horizDelayMode':['ON',{'ON':'ON','OFF':'OFF'},'HOR:DEL:MOD',False],                
                             'triggerType':['EDG',{'edge':'EDG','logic':'LOGI','pulse':'PUL'},'TRIG:A:TYP',False],
                             'triggerMode':['AUTO',{'auto':'AUTO','normal':'NORM'},'TRIG:A:MOD',False],
                             'triggerEdgeSource':['CH1',{'ch1':'CH1','ch2':'CH2','ch3':'CH3','ch4':'CH4'},'TRIG:A:EDGE:SOU',False],
                             'triggerEdgeSlope':['RIS',{'rise':'RIS','fall':'FALL'},'TRIG:A:EDGE:SLO',False],
                             'runSingle':['RUNST',{'continuous':'RUNST','single':'SEQ'},'ACQ:STOPA',False],
                             'runState':['RUN',{'run':'RUN','stop':'STOP'},'ACQ:STATE',False], 
    
                                                 
                                         },
                'continuous': {'ch1position':[0,(-5,5),'CH1:POS'],
                               'ch2position':[0,(-5,5),'CH2:POS'],
                               'ch3position':[0,(-5,5),'CH3:POS'],
                               'ch4position':[0,(-5,5),'CH4:POS'],
                               'ch1offset':[0,None,'CH1:OFFS'],
                               'ch2offset':[0,None,'CH2:OFFS'],
                               'ch3offset':[0,None,'CH3:OFFS'],
                               'ch4offset':[0,None,'CH4:OFFS'],
                               'ch1voltPerDiv':[1,None,'CH1:SCA'],
                               'ch2voltPerDiv':[1,None,'CH2:SCA'],
                               'ch3voltPerDiv':[1,None,'CH3:SCA'],
                               'ch4voltPerDiv':[1,None,'CH4:SCA'],
                               'secPerDiv':[40e-6,(400e-12,1e3),'HOR:SCA'],
                               'horizPosition':[50,(0,100),'HOR:POS'],
                               'triggerLevel':[0,None,'TRIG:A:LEV'], 
                                              },
               }
    
    def __init__(self,rmHandle):
        self.rmHandle = rmHandle
    
    def reset(self):
        #  just execute *RST command
        self.rmHandle.write('*RST')        
        pass

# later add method that takes variable arguments to do several parameters at once & uses write flag to commit values to inst after all parameters are processed.
# Here: param is a string, val is an int, real, or string
    def setInstParam(self,param,val,commit=1):
        if param in self.instDict['discrete'].keys():
            if val in self.instDict['discrete'][param][1].keys():
                self.instDict['discrete'][param][0] = self.instDict['discrete'][param][1][val]
                self.rmHandle.write(self.instDict['discrete'][param][2] + ' ' + self.instDict['discrete'][param][0])
            else:
                self.logger.warning( 'WARNING - requested discrete value not known to instrument class.  Valid options are ' + ','.join(self.instDict['discrete'][param][1].keys()))
        elif param in self.instDict['continuous'].keys():
            if (self.instDict['continuous'][param][1] is None ) or ((self.instDict['continuous'][param][1] is not None) and (val >= self.instDict['continuous'][param][1][0] ) and (val <= self.instDict['continuous'][param][1][1] ) ):
                self.instDict['continuous'][param][0] = val
                self.rmHandle.write(self.instDict['continuous'][param][2] + ' ' + str(self.instDict['continuous'][param][0]))
            pass
        else:
            self.logger.warning('WARNING - requested parameter not known to instrument class')
                        
        pass

        
# other action commands here might include
#   -set capture mode: auto/triggered
#   -set run/stop/single
#   -immediate trigger
        
    def setRiseFallLevel(self, voh = 0.7, vol = 0.3):
         self.rmHandle.write('MEASUREMENT:REFLEVEL:METHODPERCENT')
         self.rmHandle.write('MEASUREMENT:REFLEVEL:PERCENT:HIGH ' + str(voh*100))
         self.rmHandle.write('MEASUREMENT:REFLEVEL:PERCENT:LOW ' + str(vol*100))
         pass
         
    def setMidLevel(self, srcLvl = 0.5, destLvl = 0.5):
        self.rmHandle.write('MEASUREMENT:REFLEVEL:METHODPERCENT')
        self.rmHandle.write('MEASUREMENT:REFLEVEL:PERCENT:MID1 ' + str(srcLvl*100))
        self.rmHandle.write('MEASUREMENT:REFLEVEL:PERCENT:MID2 ' + str(destLvl*100))
        pass
    
    def setEdgeTrigger(self,ch = 1, slopeType = 'rise' , trigLvl = 1.0):
        self.rmHandle.write('TRIGGER:A:TYPE EDGe')
        self.rmHandle.write('TRIGger:A:EDGE:COUPling DC')
        if slopeType == 'fall':
            self.rmHandle.write('TRIGger:A:EDGE:SLOpe FALL')
        elif slopeType == 'either':
            self.rmHandle.write('TRIGger:A:EDGE:SLOpe EITH')
        else:
            self.rmHandle.write('TRIGger:A:EDGE:SLOpe RISe')
        self.rmHandle.write('TRIGger:A:EDGE:SOUrce CH' + str(ch))
        self.rmHandle.write('TRIGger:A:LEVel:CH' + str(ch) + ' ' + str(trigLvl))
        pass

# other data commands here might include
#   -get measurement (immediate/1-8/stats)        
#   -get waveform

    def getIdn(self):
        return self.rmHandle.query('*IDN?')
    
    def getRiseTime(self, ch = 1):
        self.rmHandle.write('MEASUrement:IMMed:SOUrce1 CH' + str(ch))
        self.rmHandle.write('MEASUREMENT:IMMed:TYPE RISe')
        return float(self.rmHandle.query('MEASUREMENT:IMMed:VAL?'))
        
    def getVoltMean(self, ch = 1):
        self.rmHandle.write('MEASUrement:IMMed:SOUrce1 CH' + str(ch))
        self.rmHandle.write('MEASUREMENT:IMMed:TYPE MEAN')
        return float(self.rmHandle.query('MEASUREMENT:IMMed:VAL?'))

    def getPosPulseWidth(self, ch=1):
        self.rmHandle.write('MEASUrement:IMMed:SOUrce1 CH' + str(ch))
        self.rmHandle.write('MEASUREMENT:IMMed:TYPE PWIdth')
        return float(self.rmHandle.query('MEASUREMENT:IMMed:VAL?'))

    def getNegPulseWidth(self, ch=1):
        self.rmHandle.write('MEASUrement:IMMed:SOUrce1 CH' + str(ch))
        self.rmHandle.write('MEASUREMENT:IMMed:TYPE NWIdth')
        return float(self.rmHandle.query('MEASUREMENT:IMMed:VAL?'))

    def getVoltAmp(self, ch = 1):
        self.rmHandle.write('MEASUrement:IMMed:SOUrce1 CH' + str(ch))
        self.rmHandle.write('MEASUREMENT:IMMed:TYPE AMPlitude')
        return float(self.rmHandle.query('MEASUREMENT:IMMed:VAL?'))
 
    def getFallTime(self, ch = 1):
        self.rmHandle.write('MEASUrement:IMMed:SOUrce1 CH' + str(ch))
        self.rmHandle.write('MEASUREMENT:IMMed:TYPE FALL')
        return float(self.rmHandle.query('MEASUREMENT:IMMed:VAL?'))

    def setAveraging(self, nAvgs=64):
        self.rmHandle.write('ACQuire:MODe AVErage')
        self.rmHandle.write('ACQuire:NUMAVg' + ' ' + str(nAvgs))
        
    def getDelayTime(self, srcCh = 1, srcEdge = 'rise', destCh = 2, destEdge = 'rise'):
        self.rmHandle.write('MEASUrement:IMMed:SOUrce1 CH' + str(srcCh))
        self.rmHandle.write('MEASUrement:IMMed:SOUrce2 CH' + str(destCh))
        self.rmHandle.write('MEASUREMENT:IMMed:TYPE DEL')
        self.rmHandle.write('MEASUREMENT:IMMed:DEL:DIR FOR')     
        if srcEdge == 'fall':
            self.rmHandle.write('MEASUREMENT:IMMed:DEL:EDGE1 FALL')
        else:
            self.rmHandle.write('MEASUREMENT:IMMed:DEL:EDGE1 RISE')
        if destEdge == 'fall':
            self.rmHandle.write('MEASUREMENT:IMMed:DEL:EDGE2 FALL')
        else:
            self.rmHandle.write('MEASUREMENT:IMMed:DEL:EDGE2 RISE')
        return float(self.rmHandle.query('MEASUREMENT:IMMed:VAL?'))

    def getParams(self):
        self.logger.debug(self.rmHandle.query('HOR?'))
        self.logger.debug(self.rmHandle.query('CH1?'))
        
    def close(self):
        #here, might need to communicate with instrument manager to retire the instance listed there
        self.rmHandle.close()
        pass
    
    def recallSetup(self,setup_file_path):
        self.rmHandle.write('RECALL:SETUP "' + setup_file_path + '"')

    def getMeasurementValue(self,measurement_num=1):
        return float(self.rmHandle.query('MEASUrement:MEAS{}:VALue?'.format(measurement_num)))

    def getMeasurementMap(self):
        result={}
        for n in range(1,9):
            ch_data = self.getMeasurement(n)
            result.update({ch_data['channel_str'] + '_' + ch_data['meas_str']: n})
            time.sleep(0.01)
        return result

    def getMeasurement(self,measurement_num=1):
        metadata = self.rmHandle.query('MEASUrement:MEAS{}?'.format(measurement_num))
        metadata = metadata.split(';')
        data = float(self.rmHandle.query('MEASUrement:MEAS{}:VALue?'.format(measurement_num)))
        result = {
            'channel_str': metadata[5],
            'channel_num': metadata[5][2],
            'meas_str'   : metadata[3],
            'value'      : data,
            'units': metadata[4].strip('"')
        }
        return result

    def armSingleTrig(self):
        self.rmHandle.write(':ACQuire:STOPAfter SEQ;:ACQuire:STATE ON')

    def armRunMode(self):
        self.rmHandle.write('ACQuire:STOPAfter RUNSTOP;:ACQuire:STATE ON')

    def triggerNow(self):
        # The triggerNow function only works if the scope is actually waiting for a trigger - not when stopped
        # #Typically you would call armSingleTrig first. The scope will not trigger if not running.
        self.rmHandle.write('FPAnel:PRESS FORCetrig')

    def getScreenShot(self,filename=''):
        self.rmHandle.write('HARDCOPY START')
        result = self.rmHandle.read_raw()
        if len(filename):
            newfile = open(filename, "wb")
            newfile.write(result)
            newfile.close()
            return len(result) # When writing to a file just return the number of bytes written, so as not to clobber an interactive session
        return result # When not writing to a file, just return the binary data

    def getWfmData(self,source='Ch1', data_size=2):
        recordLength=int(self.rmHandle.query('HORIZONTAL:RECORDLENGTH?'))  # returns record length in bytes
        self.rmHandle.write('DATA:SOURCE ' + source)  # sets location of waveform data to be transferred from the scope
        self.rmHandle.write('DATA:START 1')  # Start at first data sample
        self.rmHandle.write('DATA:STOP ' + str(recordLength))  # sets the ending data point for waveform transfer
        self.rmHandle.write('DATA:WIDTH {}'.format(data_size))  # sets data width to two bytes
        self.rmHandle.write('DATA:ENC RIB')  # RP Binary encoding - positive integer data-point representation
        self.rmHandle.write('Curve?')  # Initiates data transfer
        time.sleep(0.5)
        raw_data = self.rmHandle.read_raw()
        #  From OpenChoice.pdf, page 24 paragraph 3:
        #    "The binary block structure consists of #xyyynnnn....LF, where the x
        #    value represents the number of y bytes.  The y bytes represent the
        #    record length.  The n values are digitizing levels for each sample
        #    and a linefeed character terminates the block"
        k = 0
        timeout = 10
        while len(raw_data)==0:
            raw_data = self.rmHandle.read_raw()
            k = k + 1
            time.sleep(1)
            if k==timeout:
                raise Exception('ReadPartialString returned empty value after ~10 seconds of retry')

        if not raw_data[0] == b'#'[0]:
            raise Exception('Incorrect curve header (not #) for CURVE query response: {}'.format(raw_data))

        recordLength = int(raw_data[2:2+raw_data[1]-48])  # second char is length of data
        assert recordLength < len(raw_data), 'Incomplete dataset'

        raw_data=raw_data[-recordLength:]   # Get the actual data

        int_data = []
        for data_2b in [raw_data[pos:pos + 2] for pos in range(0, len(raw_data), 2)]:
            int_data.append(struct.unpack('<h', data_2b)[0])

        if source[1]=='D':
            #  Reading a Digital Channel
            #  128->0, 129->1
            ydata=[1 for i in [0 for i in int_data if i==128] if i==129] # 128 = 0 , 129 = 1
            print('NOTE: Need to test digital channel functionality')

        else:
            #  Reading Analog Channel
            ymult = float(self.rmHandle.query('WFMP:YMULT?'))  # waveform vertical scale factor per digitizing level
            yoff = float(self.rmHandle.query('WFMP:YOFF?'))  # vertical position in digitizing levels
            ydata = [ymult*(out-yoff) for out in int_data]  # converts waveform sample values to Volts

        xmult = float(self.rmHandle.query('WFMP:XINCR?'))  # horizontal point spacing
        xoff = float(self.rmHandle.query('WFMP:PT_OFF?'))  # always returns a 0 - this command is only for compatibility with other Tek scopes
        xzero = float(self.rmHandle.query('WFMP:XZERO?'))  # time coordinate of the first point in the outgoing waveform

        xdata = [xmult * (x - xoff) + xzero for x in range(0, len(ydata))]
        return xdata,ydata


if __name__ == "__main__":
    import os,sys
    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),'..'))
    sys.path.append(mgrRootDir)

    import InstMgr
    instMgr = InstMgr.InstMgr()
    scope = instMgr.checkout(interface='USB',addr='C020331',moduleSuffix='DPO4104B')
    scope.reset()
    print(scope.getIdn())
    
    scope.setInstParam('recordLength','1k')
    
    
    scope.close()
    pass