# -*- coding: utf-8 -*-
"""
Class for controlling Tektronix DMM6500.
A skeleton only at this point to just provide the rmHandle and a few basic functions.

Created on Wed Sep 11 16:00 2019

@author: dkaroly
"""

import sys
import inspect
import time

idnString = 'MODEL DMM6500'


class Meter_DMM6500:
    """Class for controlling Tektronix DMM6500."""
    instDict = {'DCV': {'range': [1e-3, None, ':SENS:VOLT:DC:RANG'],
                       'autorange': ['ON', {'on': 'ON', 'off': 'OFF'}, ':SENS:VOLT:DC:RANG:AUTO'],
                       # resolution': [1e-6,None,'VOLT:DC:RES'],
                       'numPLCycles': [1, (0.0005, 12), 'VOLT:NPLC'],
                       # 'analogFilt':['OFF',{'on':'ON','off':'OFF'},'VOLT:DC:FILT'],
                       'digitalAveFilt': ['OFF', {'on': 'ON', 'off': 'OFF'}, ':SENS:VOLT:DC:AVER'],
                       'digitizefunc': ['"VOLT"', {'V':'"VOLT"', 'I':'"CURR"'}, ':SENS:DIG:FUNC'],
                       'samplerate': [1e3, (1e3, 1e6), ':SENS:VOLT:SRATE'],  # this is for digitize sampling only
                       'aperture': [1e-3, (1e-5, 0.24), ':SENS:VOLT:APER'],  # this code is not for Digitize,
                       # for Digitize use Auto
                       'inputimpauto': ['MOHM10', {'off': 'MOHM10', 'on': 'AUTO'}, ':VOLT:INP'],
                       },

                'ACV': {'range': [1e-3, None, ':SENS:VOLT:AC:RANG'],
                       'autorange': ['ON', {'on': 'ON', 'off': 'OFF'}, ':SENS:VOLT:AC:RANG:AUTO'],
                       'digitizefunc': ['"VOLT"', {'V': '"VOLT"', 'I': '"CURR"'}, ':SENS:DIG:FUNC'],
                       'numPLCycles': [1, (0.0005, 12), 'VOLT:NPLC'],
                       'samplerate': [1e3, (1e3, 1e6), ':SENS:VOLT:AC:SRATE'],
                       'aperture': [1e-3, (1e-5, 0.24), ':SENS:VOLT:AC:APER']},
                'DCI': {'range': [1e-3, None, ':SENS:CURR:RANG'],
                       'autorange': ['ON', {'on': 'ON', 'off': 'OFF'}, ':SENS:CURR:DC:RANG:AUTO'],
                       'digitizefunc': ['"VOLT"', {'V': '"VOLT"', 'I': '"CURR"'}, ':DIG:FUNC'],
                       'numPLCycles': [1, (0.0005, 12), 'VOLT:NPLC'],
                       'samplerate': [1e3, (1e3, 1e6), ':SENS:CURR:SRATE'],
                       'aperture': [1e-3, (1e-5, 0.24), ':SENS:CURR:APER']},
                'ACI': {'range': [1e-3, None, ':SENS:CURR:AC:RANG'],
                       'autorange': ['ON', {'on': 'ON', 'off': 'OFF'}, ':SENS:CURR:AC:RANG:AUTO'],
                       'digitizefunc': ['"VOLT"', {'V': '"VOLT"', 'I': '"CURR"'}, ':DIG:FUNC'],
                       'numPLCycles': [1, (0.0005, 12), 'VOLT:NPLC'],
                       'samplerate': [1e3, (1e3, 1e6), ':SENS:CURR:AC:SRATE'],
                       'aperture': [1e-3, (1e-5, 0.24), ':SENS:CURR:AC:APER']},
                'RES': {'range': [1e-3, None, ':SENS:RES:RANG'],
                       'autorange': ['ON', {'on': 'ON', 'off': 'OFF'}, ':SENS:RES:RANG:AUTO']},
                # 'FREQ': {'range':[1e-3,None,'FREQ:VOLT:RANG'],
                #         'autorange':['ON',{'on':'ON','off':'OFF'},'FREQ:VOLT:AUTO']},
                'measType': ['"VOLT:DC"',
                            {'DCV': '"VOLT:DC"', 'ACV': '"VOLT:AC"', 'DCI': '"CURR:DC"', 'ACI': '"CURR:AC"',
                             'RES': '"RES"',
                             'FREQ': '"FREQ"'}, ':SENS:FUNC'],
                'trigger': {'init': [':IMM', {'immediate': ':IMM'}, ':INIT'],
                           # 'source':['IMM',{'bus':'BUS','immediate':'IMM','external':'EXT'},'TRIG:SOUR'],
                           'delaySec': [0, (8e-6, 1e5), ':TRIG:TIM1:DEL'],
                           # 'autodelay':['OFF',{'on':'ON','off':'OFF'},'TRIG:DEL:AUTO'],
                           'samplesPerTrigger': [1, (1, 1e6), ':SENS:COUN'],  # this function is not for Digitize
                           'tracePoints': [1, (1, 10e5), ':TRAC:POIN'],
    
                           }
                }

    def __init__(self, rmHandle):
        """ Constructor for Count_CX3324A class.
        
        Args:
            rmHandle - reference to a pyvisa.resources.gpib.GPIBInstrument object
                       which has been initialized to the address of the instrument.
                       rmHandle comes from the method instMgr.checkout, which
                       creates the object using
                       :meth:`pyvisa.highlevel.ResourceManager.open_resource`
        """

        self.rmHandle = rmHandle
        self.debug_print_enable = 0
        self.reset()

    def reset(self):
        """ Resets the counter its factory defaults.
        """

        self.rmHandle.write('*RST')

    # ----------------------------------------------------------------------------------------------

    def getIdn(self):
        """ Queries meter IDN and returns string. """

        return self.rmHandle.query('*IDN?')

    def getError(self):
        """ Queries meter error buffer and returns string. """

        return self.rmHandle.query('SYST:ERRor?').strip()

    def errlog(self):
        err_cmd = 'SYST:ERR?'
        err_list = []
        while True:
            err_msg = self.rmHandle.query(err_cmd)
            if 'No error' in err_msg:
                break
            else:
                err_list.append(err_msg)
        return err_list

    def debug_print(self):
        if self.debug_print_enable == 0:
            return
        err_list = self.errlog()
        if err_list or self.debug_print_enable == 1:
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            caller = frame_record[3]
            lineno = frame_record[2]
            print(f"debug print:{filename}:{caller} line {lineno} inst errors: {err_list}")

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = int(self.rmHandle.query('*STB?').rstrip())

        conditions = {'MSB': 0, 'EAV': 2, 'QSB': 3, 'MAV': 4, 'ESB': 5, 'MSS': 6, 'OSB': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending '*CLS, command."""

        self.rmHandle.write('*CLS')

    def setMeas(self, measType='DCV'):
        if measType in self.instDict['measType'][1].keys():
            self.instDict['measType'][0] = self.instDict['measType'][1][measType]
            self.rmHandle.write(self.instDict['measType'][2] + ' ' + self.instDict['measType'][0])
        else:
            print('WARNING - requested measurement type not known to instrument class')

    def setTrigParam(self, param='source', val='immediate'):
        self.setMeasParam(measType='trigger', param=param, val=val)

    def setMeasParam(self, measType='DCV', param='range', val=1e-2):
        inputValid = 0
        if param in self.instDict[measType].keys():
            if isinstance(self.instDict[measType][param][0], str):
                if val in self.instDict[measType][param][1].keys():
                    self.instDict[measType][param][0] = self.instDict[measType][param][1][val]
                    inputValid = 1
                else:
                    print(
                        'error - requested discrete value not known to instrument class.  Valid options are ' + ','.join(
                            self.instDict[measType][param][1].keys()))
            else:
                if (self.instDict[measType][param][1] is None) or ((self.instDict[measType][param][1] is not None) and (
                        val >= self.instDict[measType][param][1][0]) and (val <= self.instDict[measType][param][1][1])):
                    self.instDict[measType][param][0] = val
                    inputValid = 1
        else:
            print('WARNING - requested parameter not known to instrument class')
    
        if inputValid == 1:
            dsend = self.instDict[measType][param][2] + ' ' + str(self.instDict[measType][param][0])
            print(dsend)
            self.rmHandle.write(dsend)

    def getMeas(self):
        retval = self.rmHandle.query('read?')
        return float(retval)

    def setTraceMeas(self, meastype='DCI', limit=1e-2, srate=1e3, numsamples=1e4, aperture=1e-2):
        if srate >= 1000:
            # use digitize function
            self.setMeasParam(meastype, 'digitizefunc', meastype[2])
            self.rmHandle.write(':SENS:DIG:VOLT:APER AUTO')
            self.setMeasParam(meastype, 'samplerate', srate)
            pass
        else:
            # use measure function
            self.setMeasParam(meastype, 'range', limit)
            self.setMeasParam(meastype, 'aperture', aperture)
        self.setMeasParam('trigger', 'samplesPerTrigger', numsamples)
        # self.setMeasParam('trigger', 'tracePoints', numsamples*12)

    def getTraceMeas(self, meastype='DCI', limit=1e-2, srate=1e3, numsamples=1e4, aperture=1e-3):
        # TODO: reduce input paramters, no need for all of them
        # TODO: need to find a way to pass buffer name if customized buffer name is enabled
        self.rmHandle.write(':TRAC:CLE')
        self.rmHandle.write(':TRAC:TRIG')
        print("Measurement triggered")
        acq_time = int(numsamples * 1.1 / srate) + 30
        for i in range(acq_time):
            time.sleep(1)
            print("Remaining acquisition time is %d secocnds" % (acq_time - i))

        # TODO: add ability to eanble other information in output data, ie time stamp
        try:
            meas_data = self.rmHandle.query(":TRAC:DATA? 1, %d, 'defbuffer1', READ, REL" % (numsamples))
        except:
            print('Data is not ready yet')
            meas_data = None
        return meas_data
    
    def close(self):
        self.rmHandle.close()
        pass

if __name__ == "__main__":
    import os

    mgrRootDir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
    sys.path.append(mgrRootDir)
    print("MGRROOTDIR" + '-' * 10 + mgrRootDir)

    import InstMgr
    from pprint import pprint

    instMgr = InstMgr.InstMgr()
    # Note: I don't have a DMM6500 to try thisout, but addr is typically the Serial Number.
    # It's the 3trd of the comma separated fields returned in response to the '*IDN?' query, which
    # you can try out in NI-MAX.
    from instmngr import instMgr

    dmm = instMgr.checkout(interface='USB', addr= '0x05E6::0x6500::04458025', moduleSuffix = 'DMM6500')
    # mi.reset()
    print(dmm.getIdn())

    dmm.setMeas('DCV')
    dmm.setTraceMeas('DCV', 20, 10, 100, 1e-3)
    time.sleep(3)
    data = dmm.getTraceMeas('DCV', 20, 10, 100, 1e-2)
    print(data.split(','))
    
    # dmm.close()