import inspect
import warnings
import time
from enum import Enum

legal_on_off = {'ON': 1, 'OFF': 0}
legal_on_off_rev = dict((v, k) for k, v in legal_on_off.items())

class Oscope_4000_Base:
    def __init__(self, rmHandle):
        self.rmHandle = rmHandle
        self.debug_print_enable = True

        self.num_chan_analog = int(self.rmHandle.query('CONFIG:ANALO:NUMCHAN?'))
        self.num_chan_digital = int(self.rmHandle.query('CONFIG:DIGITA:NUMCHAN?'))
        self.has_auxin = bool(self.rmHandle.query("CONFIG:AUXIN?"))
        self.legal_channels = list(range(1, self.num_chan_analog + 1))

        self._input_range_1megohm = [1e-3, 10.0]
        self._input_range_50ohm = [1e-3, 1.0]
        if int(self.rmHandle.query("CONFIG:ANALO:GNDCPLG?")):
            self.legal_coupling = ['AC', 'DC', 'GND']
        else:
            self.legal_coupling = ['AC', 'DC']

        self.choices_bandwidth = [20e6, 250e6, float(self.rmHandle.query('CONFIG:ANALO:MAXBANDW?'))]

        self._offset_table = (
            (0.0010, 0.0500, 1.0, 1.0),
            (0.0505, 0.0995, 0.5, 0.5),
            (0.1000, 0.500,  10.0, 5.0),
            (0.5050, 0.995,  5.0, 5.0),
            (1.0000, 5.0,  100.0, 5.0),
            (5.0500, 10.0,  50.0, None)
        )
        self._horiz_scale_range = [1.0e-9, 40.0]
        self._record_lengths = [int(x) for x in self.rmHandle.query('CONFIG:ANALO:RECLENS?').split(',')]
        self._horiz_delay_max = 5000  # sec.

        self.trig_edge_sources = []
        if self.has_auxin:
            self.trig_edge_sources.append('AUX')
        self.trig_edge_sources.extend([f'CH{i}' for i in range(1, self.num_chan_analog + 1)])
        self.trig_edge_sources.extend([f'D{i}' for i in range(self.num_chan_digital)])
        self.trig_edge_sources.append('LINE')
        # TODO: Investigate RF triggering, do we have any scopes that have it?

        self.trig_edge_slopes = ['FALL', 'RIS', 'EITH']
        self.trig_edge_coupling = ['AC', 'DC', 'HFR', 'LFR', 'NOISE']

        self.acquire_states = {'STOP': 0, 'RUN': 1}
        self.acquire_stop_after = ('RUNSTOP', 'SEQ')
        self.acquire_sample_modes = ('SAMPLE', 'PEAK', 'HIRES', 'AVE', 'ENV')
        self.acquire_num_averages = [2**i for i in range(1, 10)]

        self.enum_trig_types = Enum('enum_trig_types', {
            'EDGE':           ('EDG',  'TRIG:B:STATE', '0'),
            'SEQUENCE':       ('EDG',  'TRIG:B:STATE', '1'),
            'LOGIC':          ('LOGI', 'TRIG:A:LOGI:CLA', 'LOGI'),
            'SETUP_HOLD':     ('LOGI', 'TRIG:A:LOGI:CLA', 'SETH'),
            'RUNT':           ('PULS', 'TRIG:A:PULS:CLA', 'RUN'),
            'PULSE_WIDTH':    ('PULS', 'TRIG:A:PULS:CLA', 'WID'),
            'RISE_FALL_TIME': ('PULS', 'TRIG:A:PULS:CLA', 'TRAN'),
            'TIMEOUT':        ('PULS', 'TRIG:A:PULS:CLA', 'TIMEO'),
            'VIDEO':          ('VID',  None,               None),
            'BUS1':           ('BUS', 'TRIG:A:BUS:SOU', 'B1'),
            'BUS2':           ('BUS', 'TRIG:A:BUS:SOU', 'B2'),
        })

        self._trig_types_rev = {}
        for enum_ttype in self.enum_trig_types:
            name = enum_ttype.name
            scpi_type, scpi_cmd, scpi_class = enum_ttype.value
            tmp = self._trig_types_rev.get(scpi_type)
            if tmp is None:
                if scpi_cmd is None:
                    tmp = (None, name)
                else:
                    tmp = (scpi_cmd, {scpi_class: name})
            else:
                if scpi_cmd is not None:
                    tmp[1].update({scpi_class: name})
                else:
                    raise RuntimeError(f"scpi_type {scpi_type} appears twice with no scpi_cmd.")
            self._trig_types_rev[scpi_type] = tmp

        # for k, v in self._trig_types_rev.items():
        #     print(k, v)

        self.enum_trig_modes = Enum('enum_trig_modes', 'AUTO NORM')

    @staticmethod
    def _enum_reverse(an_enum):
        return_value = dict((e.value, e.name) for e in an_enum)
        if len(return_value) != len(an_enum):
            raise ValueError(f"Enum {an_enum}, cannot be reverse, values are not unique!")
        return return_value

    def vert_select_ch(self, on_list=None, off_list=None):
        """
        Query or specify which channels are displayed and which are not.

        :param on_list: List of channel numbers to display.
        :param off_list: List of channel numbers to not display. Takes precedence.
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # SELect:CH<x> {ON|OFF|1|0}

        if all([on_list is None, off_list is None]):
            on_list = []
            off_list = []
            for c in self.legal_channels:
                v = int(self.rmHandle.query(f"SEL:CH{c}?"))
                if v:
                    on_list.append(c)
                else:
                    off_list.append(c)
            return {'on_list': on_list, 'off_list': off_list}

        msg = ", ".join([f"{c}" for c in self.legal_channels])
        if on_list is not None:
            bad = [c for c in on_list if c not in self.legal_channels]
            if bad:
                raise ValueError(f"on_list: bad channels {bad}, should be from set {msg}.")

        if off_list is not None:
            bad = [c for c in off_list if c not in self.legal_channels]
            if bad:
                raise ValueError(f"off_list: bad channels {bad}, should be from set {msg}.")

        if on_list is not None:
            for c in on_list:
                self.rmHandle.write(f"SEL:CH{c} ON")

        if off_list is not None:
            for c in off_list:
                self.rmHandle.write(f"SEL:CH{c} OFF")

        self.debug_print()

    def vert(self, chan, scale=None, coupling=None, termination=None, invert=None, bandwidth=None, label=None, offset=None, position=None):
        """
        Query all or set any combination of oscope vertical parameters for a specified channel.

        :param chan: int channel number
        :param scale: volts per division
        :param coupling: 'AC', 'DC', 'GND'
        :param termination: 1e6 or 50
        :param invert: 'ON' or 'OFF'
        :param bandwidth: 20e6, 250e6, and numeric val corresponding to full BW.
        :param label: str up to 30 characters.
        :param offset: voltage, range depends on scale and coupling. Will warn on out-of-bounds, but scope will set to min/max allowed.
        :param position: -8 to +8 divisions.
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # CH<x>:SCAle <NR3>
        # CH < x >: COUPling {AC | DC | DCREJect}  # Actually has GND not DCREJ
        # CH<x>:TERmination {FIFty|MEG|<NR3>}
        # CH<x>:INVert {ON|OFF}
        # CH<x>:BANdwidth {FULl|<NR3>}
        # CH<x>:LABel <Qstring>
        # CH<x>:OFFSet <NR3>
        # CH<x>:POSition <NR3>

        if chan not in self.legal_channels:
            msg = ", ".join([f"{c}" for c in self.legal_channels])
            raise ValueError(f"Bad channel: {chan}, should be one of {msg}.")

        if all(v is None for v in {scale, coupling, termination, invert, bandwidth, label, offset, position}):
            return_vals = {}
            return_vals.update(scale=float(self.rmHandle.query(f"CH{chan}:SCA?")))
            return_vals.update(coupling=self.rmHandle.query(f"CH{chan}:COUP?").strip())
            return_vals.update(termination=float(self.rmHandle.query(f"CH{chan}:TER?")))
            return_vals.update(invert=legal_on_off_rev[int(self.rmHandle.query(f"CH{chan}:INV?"))])
            return_vals.update(bandwidth=float(self.rmHandle.query(f"CH{chan}:BAN?")))
            tmp = self.rmHandle.query(f"CH{chan}:LAB?").rstrip('\n').strip('"').strip()
            return_vals.update(label='' if tmp.isspace() else tmp)
            return_vals.update(offset=float(self.rmHandle.query(f"CH{chan}:OFFS?")))
            return_vals.update(position=float(self.rmHandle.query(f"CH{chan}:POS?")))
            return return_vals

        # Check all settings before applying.

        if termination is not None:
            if termination not in [50, 1e6]:
                raise ValueError(f"Bad termination: {termination}, should be 50 or 1e6.")
            termination_state = termination
        else:
            termination_state = float(self.rmHandle.query(f"CH{chan}:TER?"))

        probe_gain = float(self.rmHandle.query(f"CH{chan}:PROBE:GAIN?"))
        input_range = self._input_range_1megohm if termination_state == 1e6 else self._input_range_50ohm
        input_min, input_max = [v / probe_gain for v in input_range]    # Does Termination change this?

        if scale is not None:
            if not isinstance(scale, (int, float)) or scale < input_min or scale > input_max:
                raise ValueError(f"Bad scale value {scale}, should be {input_min} to {input_max} volts.")

        if coupling is not None and coupling not in self.legal_coupling:
            msg = ", ".join([f"{c}" for c in self.legal_coupling])
            raise ValueError(f"Bad coupling: '{coupling}', should be one of {msg}.")

        if invert is not None and invert.upper() not in ('ON', 'OFF'):
            raise ValueError(f"Bad invert: {invert}, should be 'ON' or 'OFF'.")

        if bandwidth is not None and bandwidth not in self.choices_bandwidth:
            msg = ", ".join([f"{bw}" for bw in self.choices_bandwidth])
            raise ValueError(f"Bad bandwidth {bandwidth}, should be one of {msg}.")

        if label is not None and (not isinstance(label, str) or len(label) > 30):
            raise ValueError(f"Bad label {label}, should be string not longer than 30 characters.")

        if offset is not None:
            if scale is None:
                scale_state = float(self.rmHandle.query(f"CH{chan}:SCA?"))
            else:
                scale_state = scale
            if termination is None:
                termination_state = float(self.rmHandle.query(f"CH{chan}:TER?"))
            else:
                termination_state = termination

            offset_min, offset_max = self._chan_offset_range(scale_state, probe_gain, termination_state)
            if not(offset_min <= offset <= offset_max):
                offset_tmp = min(max(offset, offset_min), offset_max)
                warnings.warn(f"Requested offset {offset} outside range {offset_min} to {offset_max}. Setting to {offset_tmp}.")
                offset = offset_tmp

        if position is not None:
            if not(-8.0 <= position <= 8.0):
                position_tmp = min(max(position, -8), 8)
                warnings.warn(f"Requested position {position} outside range -8.0 to +8.0. Setting to {position_tmp}.")
                position = position_tmp

        # If we got here all new values are good, write them to instrument:

        if termination is not None:
            self.rmHandle.write(f"CH{chan}:TER {termination}")     # Scale max depends on this, order matters!
        if scale is not None:
            self.rmHandle.write(f"CH{chan}:SCA {scale}")
        if coupling is not None:
            self.rmHandle.write(f"CH{chan}:COUP {coupling}")
        if invert is not None:
            self.rmHandle.write(f"CH{chan}:INV {invert}")
        if bandwidth is not None:
            self.rmHandle.write(f"CH{chan}:BAN {bandwidth}")
        if label is not None:
            self.rmHandle.write(f'CH{chan}:LAB "{label}"')
        if offset is not None:
            self.rmHandle.write(f"CH{chan}:OFFS {offset}")
        if position is not None:
            self.rmHandle.write(f"CH{chan}:POS {position}")

        self.debug_print()

    def _chan_offset_range(self, volts_per_div, probe_gain, termination):
        """
        Calculates analog input offset bounds, uses lookup table defined in __init__.
        :param volts_per_div:
        :param probe_gain:
        :param termination:
        :return: [offset_min offset_max]
        """

        scaled_setting = volts_per_div * probe_gain
        for low, high, onemeg, fifty in self._offset_table:
            if low <= scaled_setting <= high:
                if termination == 50.0:
                    if probe_gain != 1.0:
                        raise ValueError(f"With 50 Ohm termination, expected probe gain of 1.0, not {probe_gain}.")
                    else:
                        return [-1.0*fifty, fifty]
                elif termination == 1e6:
                    return [-1.0*onemeg, onemeg]
                else:
                    raise ValueError(f"Bad termination value {termination}, expected 50.0 or 1e6.")

        raise ValueError(f"No offset range found for volts_per_div={volts_per_div}, probe_gain={probe_gain}, termination={termination}")

    def horiz(self, scale=None, delay_mode=None, position_pcnt=None, delay_time=None, record_length=None):
        """
        Queries all or sets any combination of horizontal parameters.

        :param scale: seconds per horizontal division
        :param delay_mode: 'OFF' is horiz position as % of record length. 'ON' is delay time from trigger.
        :param position_pcnt: Shifts view of the captured record from 0 to 100 % point. Takes effect when delay_mode is 'OFF'.
        :param delay_time: Delay in seconds from trigger point. Takes effect when delay_mode is 'ON'.
        :param record_length: Number of sample points captured per acquisition.
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # HORizontal:SCAle <NR3>
        # HORizontal:POSition <NR3>
        # HORizontal:DELay:MODe {OFF|ON|<NR1>}
        # HORizontal:DELay:TIMe <NR3>
        # HORizontal:RECOrdlength <NR1>

        if all(v is None for v in (scale, delay_mode, position_pcnt, delay_time, record_length)):
            return_values = {}
            return_values.update(scale=float(self.rmHandle.query("HOR:SCA?")))
            return_values.update(delay_mode=legal_on_off_rev[int(self.rmHandle.query("HOR:DEL:MOD?"))])
            return_values.update(position_pcnt=float(self.rmHandle.query("HOR:POS?")))
            return_values.update(delay_time=float(self.rmHandle.query("HOR:DEL:TIM?")))
            return_values.update(record_length=int(self.rmHandle.query("HOR:RECO?")))
            return return_values

        if scale is not None:
            scale_min, scale_max = self._horiz_scale_range
            if not isinstance(scale, (int, float)) or scale_min < scale_min or scale > scale_max:
                scale_tmp = min(max(scale, scale_min), scale_max)
                warnings.warn(f"Requested scale {scale} outside range {scale_min} to {scale_max}. Setting to {scale_tmp}.")
                scale = scale_tmp

        if delay_mode is not None and delay_mode not in legal_on_off:
            msg = ", ".join([f"'{x}'" for x in legal_on_off])
            raise ValueError(f"Bad delay_mode {delay_mode}, should be one of {msg}.")

        if position_pcnt is not None:
            if delay_mode is None:
                delay_mode_state = self.rmHandle.query('HOR:DEL:MOD?')
            else:
                delay_mode_state = delay_mode
            if 'ON' == delay_mode_state.upper():
                warnings.warn(f"Must change delay_mode setting to 'OFF' for position_pcnt to take effect.")
            if not isinstance(position_pcnt, (int, float)) or position_pcnt < 0 or position_pcnt > 100:
                position_pcnt_tmp = min(max(position_pcnt, 0.0), 100.0)
                warnings.warn(f"Bad position_pcnt value {position_pcnt}, setting to {position_pcnt_tmp} percent.")

        if delay_time is not None:
            if delay_mode is None:
                delay_mode_state = self.rmHandle.query('HOR:DEL:MOD?')
            else:
                delay_mode_state = delay_mode
            if 'OFF' == delay_mode_state.upper():
                raise ValueError(f"Cannot set delay time percent position while delay_mode is 'OFF'.")
            if scale is None:
                horiz_delay_min = -10 * float(self.rmHandle.query("HOR:SCA?"))
            else:
                horiz_delay_min = -10 * scale
            if not isinstance(delay_time, (int, float)) or delay_time < horiz_delay_min or delay_time > self._horiz_delay_max:
                delay_time_tmp = min(max(delay_time, horiz_delay_min), self._horiz_delay_max)
                warnings.warn(f"delay_time {delay_time}, outside range {horiz_delay_min:4.1G} (-10 divisions) to {self._horiz_delay_max} sec. "
                    f"Setting to {delay_time_tmp:4.1G}.")
                delay_time = delay_time_tmp

        if record_length is not None and record_length not in self._record_lengths:
            msg = ", ".join([f"{x}" for x in self._record_lengths])
            raise ValueError(f"Bad record_length {record_length}, should be one of {msg}.")

        # If we got here all new values are good, write them to instrument:

        if scale is not None:
            self.rmHandle.write(f"HOR:SCA {scale}")
        if delay_mode is not None:                              # Order is important here!
            self.rmHandle.write(f"HOR:DEL:MOD {delay_mode}")
        if position_pcnt is not None:
            self.rmHandle.write(f"HOR:POS {position_pcnt}")
        if delay_time is not None:
            self.rmHandle.write(f"HOR:DEL:TIM {delay_time}")
        if record_length is not None:
            self.rmHandle.write(f"HOR:RECO {record_length}")

        self.debug_print()

    def trig(self, trig_type=None, mode=None, holdoff=None):
        """
        Triggering parameters common to all trigger modes, switch between modes previously setup.
        :param trig_type:
        :param mode:
        :param holdoff:
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # TODO: mode definition.
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:LOGIc:CLAss {LOGIC|SETHold}
        # TRIGger:A:MODe {AUTO|NORMal}
        # TRIGger:A:HOLDoff:TIMe <NR3>

        if all(v is None for v in (trig_type, mode, holdoff)):
            return_values = {}
            # This weirdness is because the selection in the on-screen menu is determined by 2 SCPI cmds working together. The first determines what the
            # second command is.
            scpi_type = self.rmHandle.query("TRIG:A:TYP?").strip()
            scpi_cmd, name_lookup = self._trig_types_rev[scpi_type]
            if scpi_cmd is None:
                return_values.update(trig_type=name_lookup)
            else:
                scpi_class = self.rmHandle.query(f"{scpi_cmd}?").strip()
                return_values.update(trig_type=name_lookup[scpi_class])

            mode = self.rmHandle.query("TRIG:A:MOD?").strip()
            # return_values.update(mode=self.enum_trig_modes[mode])
            return_values.update(mode=mode)
            return_values.update(holdoff=float(self.rmHandle.query("TRIG:A:HOLD:TIM?")))
            return return_values

        # if type_class is not None and type_class.upper() not in self._trig_types:
        #     msg = ", ".join([f'{x}' for x in self._trig_types])
        #     raise ValueError(f"Bad type_class {type_class}, should be one of {msg}.")
        #

        if trig_type is not None and not isinstance(trig_type, self.enum_trig_types):
            if trig_type in self.enum_trig_types.__members__:
                trig_type = self.enum_trig_types[trig_type]
            else:
                msg = ", ".join([f"'{x}'" for x in self.enum_trig_types.__members__])
                raise ValueError(f"Bad trig_type '{trig_type}', should be one of enum_trig_types: {msg}.")

        if mode is not None and not isinstance(mode, self.enum_trig_modes):
            if mode in self.enum_trig_modes.__members__:
                mode = self.enum_trig_modes[mode]
            else:
                msg = ", ".join([f"'{x}'" for x in self.enum_trig_modes.__members__])
                raise ValueError(f"Bad mode '{mode}', should be one of enum_trig_modes: {msg}.")
        #
        # if holdoff is not None and (not isinstance(holdoff, (int, float)) or holdoff < 20e-9 or holdoff > 8)):
        #      raise ValueError(f"Bad holdoff {holdoff}, should be 20e-9 to 8 sec.")

        if trig_type is not None:
            # A typical value of the trig_type enum looks like this:
            #     'b_trigger':      ('EDG',  'TRIG:B:STATE', '1'),
            scpi_type, scpi_cmd, scpi_class = trig_type.value
            self.rmHandle.write(f"TRIG:A:TYP {scpi_type}")
            if scpi_cmd is not None:
                self.rmHandle.write(f"{scpi_cmd} {scpi_class}")

        if mode is not None:
            self.rmHandle.write(f"TRIG:A:MOD {mode.name}")

        if holdoff is not None:
            self.rmHandle.write(f"TRIG:A:HOLD:TIM {holdoff}")

        self.debug_print()

    def trig_edge(self, source=None, level=None, slope=None, coupling=None):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:EDGE:SOUrce {AUX|CH1|CH2|CH3|CH4|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|LINE|RF}
        # TRIGger:A:EDGE:COUPling {AC|DC|HFRej|LFRej|NOISErej}
        # TRIGger:A:EDGE:SLOpe {RISe|FALL|EITHer}
        # TRIGger:A:LEVel:CH<x> {<NR3>|ECL|TTL}
        # TRIGger:A:LEVel:AUXin {<NR3>|ECL|TTL}
        # TRIGger:A:LEVel:D<x> {<NR3>|ECL|TTL}

        if all(v is None for v in (source, level, slope, coupling)):
            return_values = {}
            source = self.rmHandle.query("TRIG:A:EDGE:SOU?").strip()
            return_values.update(source=source)
            return_values.update(level=float(self.rmHandle.query(f"TRIG:A:LEV:{source}?")))
            return_values.update(slope=self.rmHandle.query("TRIG:A:EDGE:SLO?").strip())
            return_values.update(coupling=self.rmHandle.query("TRIG:A:EDGE:COUP?").strip())
            return return_values

        self.rmHandle.write("TRIG:A:TYP EDG")

        # Get source if not supplied because allowable trig_level depends on source.
        if source is None:
            source_state = self.rmHandle.query("TRIG:A:EDGE:SOU?").strip()
        elif source in self.trig_edge_sources:
            source_state = source
        else:
            msg = ", ".join([f"'{x}'" for x in self.trig_edge_sources])
            raise ValueError(f"Bad source {source}, should be one of {msg}.")

        # Get coupling if not supplied because allowable trig_level range depends on coupling.
        if coupling is None:
            coupling_state = self.rmHandle.query("TRIG:A:EDGE:COUP?").strip()
        elif coupling in self.trig_edge_coupling:
            coupling_state = coupling
        else:
            msg = ", ".join([f"'{x}'" for x in self.trig_edge_coupling])
            raise ValueError(f"Bad coupling {coupling}, should be one of {msg}.")

        if level is not None:
            # See trigger Level ranges in scope data sheet.
            check_level = True
            if source_state == 'AUX':
                level_min, level_max = -8, 8
            elif source_state.startswith('D'):
                level_min, level_max = -40, 40   # TODO: Confirm this on MSO scope.
            elif source_state.startswith('CH'):
                scale = float(self.rmHandle.query(f"{source_state}:SCA?"))
                if coupling_state == 'LFR':
                    level_min, level_max = -8.0 * scale, +8.0 * scale
                else:
                    offset = float(self.rmHandle.query(f"{source_state}:OFFS?"))
                    position = float(self.rmHandle.query(f"{source_state}:POS?"))
                    level_min, level_max = -1.0*scale*(8 + position) + offset, scale*(8 - position) + offset
            elif source_state == 'LINE':
                level_min, level_max = 0, 0
            else:
                warnings.warn(f"Level range check not implemented for source {source_state}.")
                check_level = False

            if check_level and (level < level_min or level > level_max):
                # Sending out of bounds level via command doesn't cause error, it just sets level to min or max, so we just warn.
                level_actual = min(max(level, level_min), level_max)
                warnings.warn(f"Requested level {level} out of range {level_min} to {level_max} for source {source_state}. Defaulting to {level_actual}.")

        if slope is not None and slope not in self.trig_edge_slopes:
            msg = ", ".join([f"'{x}'" for x in self.trig_edge_slopes])
            raise ValueError(f"Bad slope {slope}, should be one of {msg}.")

        # If we got here all new values are good, write them to instrument:

        if source is not None:
            self.rmHandle.write(f"TRIG:A:EDGE:SOU {source}")
        if slope is not None:
            self.rmHandle.write(f"TRIG:A:EDGE:SLO {slope}")
        if level is not None:
            self.rmHandle.write(f"TRIG:A:LEV:{source_state} {level}")
        if coupling is not None:
            self.rmHandle.write(f"TRIG:A:EDGE:COUP {coupling}")

        self.debug_print()

    def trig_logic_clked(self, function, pattern, thresholds, clk_source, clk_edge):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:LOGIc:CLAss {LOGIC|SETHold}
        # TRIGger:A:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:A:LOGIc:INPut:CH<x> {HIGH|LOW|X}
        # TRIGger:A:LOGIc:INPut:D<x> {HIGH|LOW|X}
        # TRIGger:A:LOGIc:THReshold:CH<x> {<NR3>|ECL|TTL}
        # TRIGger:A:LOGIc:THReshold:D<x> {<NR3>|ECL|TTL}
        # TRIGger:A:LOGIc:INPut:CLOCk:SOUrce {CH1|CH2|CH3|CH4|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|RF|NONE}
        # TRIGger:A:LOGIc:INPut:CLOCk:EDGE {FALL|RISe}

        # CLOCK:SOURCE cannot be NONE.
        pass

    def trig_logic_pattern(self, function, pattern, thresholds, when, delta_time):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:LOGIc:CLAss {LOGIC|SETHold}
        # TRIGger:A:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:A:LOGIc:INPut:CLOCk:SOUrce {CH1|CH2|CH3|CH4|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|RF|NONE}
        # TRIGger:A:LOGIc:INPut:CH<x> {HIGH|LOW|X}
        # TRIGger:A:LOGIc:INPut:D<x> {HIGH|LOW|X}
        # TRIGger:A:LOGIc:THReshold:CH<x> {<NR3>|ECL|TTL}
        # TRIGger:A:LOGIc:THReshold:D<x> {<NR3>|ECL|TTL}
        # TRIGger:A:LOGIc:PATtern:WHEn {TRUe|FALSe|LESSthan|MOREthan|EQual|UNEQual}
        # TRIGger:A:LOGIc:PATtern:DELTatime <NR3>

        # Sets CLOCK:SOURCE to NONE.
        pass

    def trig_setup_hold(self, sources, thresholds, clk_source, clk_edge, time_setup, time_hold):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:LOGIc:CLAss {LOGIC|SETHold}
        # TRIGger:A:SETHold:DATa:SOUrce {CH1|CH2|CH3|CH4|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|AUX}
        # TRIGger:A:SETHold:DATa:THReshold {<NR3>|TTL}          # Unclear how these interact.
        # TRIGger: A:SETHold: THReshold:CH < x > { < NR3 > | ECL | TTL}
        # TRIGger: A:SETHold: THReshold:D < x > { < NR3 > | ECL | TTL}
        # TRIGger:A:SETHold:CLOCk:SOUrce {CH1|CH2|CH3|CH4|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|AUX}
        # TRIGger:A:SETHold:CLOCk:THReshold {<NR3>|TTL}
        # TRIGger:A:SETHold:CLOCk:EDGE {FALL|RISe}
        # TRIGger:A:SETHold:SETTime <NR3>
        # TRIGger:A:SETHold:HOLDTime <NR3>
        # TRIGger:A:PULSEWidth:HIGHLimit <NR3>
        # TRIGger:A:PULSEWidth:LOWLimit <NR3>

        # DATA:SOU allows comma separated combinations.
        pass

    def trig_pulse_width(self, source, polarity, when, width, thershold):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:PULse:CLAss {RUNt|WIDth|TRANsition|TIMEOut}
        # TRIGger:A:PULSEWidth:SOUrce {CH1|CH2|CH3|CH4|LINE|AUX|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|RF}
        # TRIGger:A:PULSEWidth:POLarity {NEGative|POSitive}
        # TRIGger:A:PULSEWidth:WHEn {LESSthan|MOREthan|EQual|UNEQual|WIThin|OUTside}
        # TRIGger:A:PULSEWidth:WIDth <NR3>
        # TRIGger:A:LEVel:CH<x> {<NR3>|ECL|TTL}
        # TRIGger:A:LEVel:AUXin {<NR3>|ECL|TTL}
        # TRIGger:A:LEVel:D<x> {<NR3>|ECL|TTL}

        pass

    def trig_runt(self, source, polarity, when, width, threshold_lower, threshold_upper):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:PULse:CLAss {RUNt|WIDth|TRANsition|TIMEOut}
        # TRIGger: A:RUNT: SOUrce {CH1 | CH2 | CH3 | CH4 | RF}
        # TRIGger:A:RUNT:POLarity {EITher|NEGative|POSitive}
        # TRIGger:A:RUNT:WHEn {LESSthan|MOREthan|EQual|UNEQual|OCCURS}
        # TRIGger:A:RUNT:WIDth <NR3>
        # TRIGger:A:LEVel:CH<x> {<NR3>|ECL|TTL}
        # TRIGger:A:UPPerthreshold:CH<x> {<NR3>|ECL|TTL}

        # Look out, thresholds are set independently on channels, so changing input changes thresholds!
        pass

    def trig_timeout(self, source, polarity, timeout_sec):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:PULse:CLAss {RUNt|WIDth|TRANsition|TIMEOut}
        # TRIGger:A:TIMEOut:SOUrce {CH1|CH2|CH3|CH4|LINE|AUX|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|RF}
        # TRIGger:A:TIMEOut:POLarity {STAYSHigh|STAYSLow|EITher}
        # TRIGger:A:TIMEOut:TIMe <NR3>
        pass

    def trig_slew(self, source, polarity, when, delta_time):
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:PULse:CLAss {RUNt|WIDth|TRANsition|TIMEOut}
        # TRIGger:A{:TRANsition|:RISEFall}:SOUrce {CH1|CH2|CH3|CH4}
        # TRIGger:A{:TRANsition|:RISEFall}:POLarity {EITher|NEGative|POSitive}
        # TRIGger:A{:TRANsition|:RISEFall}:WHEn {SLOWer|FASTer|EQual|UNEQual}
        # TRIGger:A{:TRANsition|:RISEFall}:DELTatime <NR3>
        pass

    def trig_bus_i2c(self, bus_num, addr_mode, trig_condition, direction, address, data_size, data_value):
        # TRIGger:A:BUS {I2C|SPI|CAN|RS232C|PARallel|USB|LIN|FLEXRay|AUDio|ETHERnet|MIL1553B}
        # TRIGger:A:BUS:B<x>:I2C:ADDRess:MODe {ADDR7|ADDR10}
        # TRIGger:A:BUS:B<x>:I2C:CONDition {STARt|STOP|REPEATstart|ACKMISS|ADDRess|DATA|ADDRANDDATA}
        # TRIGger:A:BUS:B<x>:I2C:ADDRess:VALue <QString>
        # TRIGger:A:BUS:B<x>:I2C:DATa:DIRection {READ|WRITE|NOCARE}
        # TRIGger:A:BUS:B<x>:I2C:DATa:SIZe <NR1>
        # TRIGger:A:BUS:B<x>:I2C:DATa:VALue <QString>

        # check for DPO4EMBD module
        # If trig_condition is changed, check that appropriate parameters are also supplied.
        pass

    def trig_bus_spi(self, bus_num, trig_condition, data_size, miso_data, mosi_data):
        # TRIGger:A:BUS {I2C|SPI|CAN|RS232C|PARallel|USB|LIN|FLEXRay|AUDio|ETHERnet|MIL1553B}

        # TRIGger:A:BUS:B<x>:SPI:CONDition {SS|STARTofframe|MISO|MOSI|MISOMOSI}
        # TRIGger:A:BUS:B<x>:SPI:DATa:SIZe <NR1>
        # TRIGger:A:BUS:B<x>:SPI:DATa{:IN|:MISO}:VALue <QString>
        # TRIGger:A:BUS:B<x>:SPI:DATa{:OUT|:MOSI}:VALue <QString>
        pass

    def trig_b(self, state, source, coupling, slope, level, trig_by, event_count, time_sec):
        # TRIGger:B:STATE {ON|OFF|<NR1>}
        # TRIGger:B:EDGE:SOUrce {CH1|CH2|CH3|CH4|AUX|LINE|RF}
        # TRIGger:B:EDGE:COUPling {DC|HFRej|LFRej|NOISErej}
        # TRIGger:B:EDGE:SLOpe {RISe|FALL}
        # TRIGger:B:LEVel:CH<x> {ECL|TTL|<NR3>}
        # TRIGger:B:BY {EVENTS|TIMe}
        # TRIGger:B:EVENTS:COUNt <NR1>
        # TRIGger:B:TIMe <NR3>

        # If trig_by is changed, check that appropriate parameters are also supplied.
        pass

    def acquire(self, state=None, stop_after=None, sample_mode=None, num_averages=None, num_envelopes=None):
        """Query all or set any combination of scope acquisition related parameters.

        :param state: 'RUN' or 'STOP"
        :param stop_after: 'RUNSTOP' or 'SEQ'
        :param sample_mode: 'SAMPLE', 'PEAK', 'HIRES', 'AVE', or 'ENV'
        :param num_averages: 2, 4, 8, 16, 32, 64, 128, 256, 512. Applies only when sample_mode='AVE'.
        :param num_envelopes: 2 to 2000, or 'INFI'. Applies only when sample_mode='ENV'.

        :return: Query is returned as a dict of parameter name-value pairs.
        """

        # ACQuire:STATE {OFF|ON|RUN|STOP|<NR1>}
        # ACQuire:STOPAfter {RUNSTop|SEQuence}
        # ACQuire:MODe {SAMple|PEAKdetect|HIRes|AVErage|ENVelope}
        # ACQuire:NUMACq?                  # Query only
        # ACQuire:NUMAVg <NR1>             # pertains only to AVE mode
        # ACQuire:NUMEnv {<NR1>|INFInite}  # pertains only to ENV mode

        if all(v is None for v in (state, stop_after, sample_mode, num_averages, num_envelopes)):
            return_values = {}
            return_values.update(state=self.rmHandle.query("ACQ:STATE?").strip())
            return_values.update(stop_after=self.rmHandle.query("ACQ:STOPA?").strip())
            return_values.update(samp_mode=self.rmHandle.query("ACQ:MOD?").strip())
            return_values.update(num_averages=int(self.rmHandle.query("ACQ:NUMAV?")))
            num_envelopes = self.rmHandle.query("ACQ:NUME?").strip()
            if num_envelopes.isnumeric():  # num_envelopes could be 'INFI'.
                num_envelopes = int(num_envelopes)
            return_values.update(num_envelopes=num_envelopes)
            return return_values

        if state is not None and state not in self.acquire_states:
            msg = ", ".join([f"'{x}'" for x in self.acquire_states])
            raise ValueError(f"Bad state {state}, should be one of {msg}.")

        if stop_after is not None and stop_after not in self.acquire_stop_after:
            msg = ", ".join([f"'{x}'" for x in self.acquire_stop_after])
            raise ValueError(f"Bad stop_after {stop_after}, should be one of {msg}.")

        if sample_mode is None:
            sample_mode_state = self.rmHandle.query("ACQ:MOD?").strip()
        else:
            if sample_mode not in self.acquire_sample_modes:
                msg = ", ".join([f"'{x}'" for x in self.acquire_sample_modes])
                raise ValueError(f"Bad sample_mode {sample_mode}, should be one of {msg}.")
            sample_mode_state = sample_mode

        if num_averages is not None:
            if num_averages not in self.acquire_num_averages:
                msg = ", ".join([f"{x}" for x in self.acquire_num_averages])
                raise ValueError(f"Bad num_averages {num_averages}, should be one of: {msg}.")
            if sample_mode_state != 'AVE':
                warnings.warn(f"For new num_averages {num_averages} to take effect, you must set sample_mode to 'AVE'. Present mode is {sample_mode_state}.")

        if num_envelopes is not None:
            if isinstance(num_envelopes, str) and num_envelopes.upper().startswith('INFI'):
                num_envelopes = 'INFI'
            elif isinstance(num_envelopes, (int, float)):
                if int(num_envelopes) > 2000:
                    warnings.warn(f"num_envelopes value {num_envelopes} is > 2000, scope interprets this as 'INFINITE'.")
                elif num_envelopes < 1:
                    raise ValueError(f"Bad num_envelopes {num_envelopes}, should be 1 to 2000 or 'INFI'.")
                num_envelopes = int(num_envelopes)
            else:
                raise ValueError(f"Bad num_averages {num_averages}, should be int from 1 to 2000, or 'INFI'.")
            if sample_mode_state != 'ENV':
                warnings.warn(f"For new num_envelopes '{num_envelopes}' to take effect, you must set sample_mode to 'ENV'. "
                    f"Present mode is '{sample_mode_state}'.")

        if state is not None:
            self.rmHandle.write(f"ACQuire:STATE {state}")
        if stop_after is not None:
            self.rmHandle.write(f"ACQuire:STOPAfter {stop_after}")
        if sample_mode is not None:
            self.rmHandle.write(f"ACQuire:MODe {sample_mode}")
        if num_averages is not None:
            self.rmHandle.write(f"ACQuire:NUMAVg {num_averages}")
        if num_envelopes is not None:
            self.rmHandle.write(f"ACQuire:NUMEnv {num_envelopes}")

        self.debug_print()

    def menu(self, on_off):
        pass

    def math(self):
        pass

    def ref(self):
        pass

    def cursors(self, kind, source, direction, linked, cursor_units):
        pass

    def wave_inspector(self):
        pass

    def measure(self, ):
        pass

    def errlog(self):
        err_list = []
        while int(self.rmHandle.query('*ESR?').strip()):
            time.sleep(0.10)
            err_msg = self.rmHandle.query('EVM?')
            err_list.append(err_msg)
        return err_list

    def debug_print(self):
        if self.debug_print_enable == 0:
            return
        err_list = self.errlog()
        if err_list or self.debug_print_enable == 1:
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            caller = frame_record[3]
            lineno = frame_record[2]
            print(f"debug print:{filename}:{caller} line {lineno} inst errors: {err_list}")
