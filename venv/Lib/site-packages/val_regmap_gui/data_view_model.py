"""
https://github.com/wxWidgets/Phoenix/blob/master/samples/dataview/DataViewModel.py
"""
import re
import wx
import wx.dataview as dv
from cl_test_station.components.component.component import Register, Block, Field


class RegMapModel(dv.PyDataViewModel):  # ToDo: this class SHOULD NOT interact with the HW
    def __init__(self, caller, component):
        dv.PyDataViewModel.__init__(self)
        self.caller = caller
        self.component = component
        self.field_cache_dict = {}
        self.reg_cache_dict = {}
        # Use the color database so the GUI and Model use the same color definition
        self.non_default_color = wx.TheColourDatabase.Find('NON_DEFAULT')  # https://docs.wxpython.org/wx.ColourDatabase.html#wx-colourdatabase
        self.internal_color = wx.TheColourDatabase.Find('INTERNAL')  # https://docs.wxpython.org/wx.ColourDatabase.html#wx-colourdatabase
        self.pending_color = wx.TheColourDatabase.Find('PENDING')  # https://docs.wxpython.org/wx.ColourDatabase.html#wx-colourdatabase
        self.unknown_value = '--------'
        self.num_cols = 8
        self.pending_value_dict = {}  # field:pending value

    def Reset(self):
        # clear out the dicts so that the unknown value is displayed
        self.field_cache_dict = {}
        self.reg_cache_dict = {}
        self.pending_value_dict = {}

    def GetColumnCount(self):
        return self.num_cols

    def GetChildren(self, item, children):
        if not item:  # top level (component)
            blocks = self.component.blocks.values()
            for block in blocks:
                children.append(self.ObjectToItem(block))
            return len(blocks)
        if isinstance(self.ItemToObject(item), Block):
            for reg in self.ItemToObject(item).get_registers():
                children.append(self.ObjectToItem(reg))
            return len(self.ItemToObject(item).get_registers())
        if isinstance(self.ItemToObject(item), Register):
            for field in self.ItemToObject(item).get_fields():
                children.append(self.ObjectToItem(field))
            return len(self.ItemToObject(item).get_fields())
        if isinstance(self.ItemToObject(item), Field):
            return 0

    def IsContainer(self, item):
        if not item:  # top level container
            return True
        elif isinstance(self.ItemToObject(item), Field):
            return False
        else:
            return True

    def GetParent(self, item):
        if not item:  # top level
            return dv.NullDataViewItem
        if isinstance(self.ItemToObject(item), Block):
            return dv.NullDataViewItem
        else:
            return self.ObjectToItem(self.ItemToObject(item).container)

    def HasContainerColumns(self, item):  # so regs and blocks can show values in the columns
        if isinstance(self.ItemToObject(item), Block):
            return True
        if isinstance(self.ItemToObject(item), Register):
            return True

    def GetValue(self, item, col):
        if isinstance(self.ItemToObject(item), Block):
            if col == self.caller.name_col_index:
                return self.ItemToObject(item).name
            if col == self.caller.addr_col_index:
                return self.int_to_value(int(self.ItemToObject(item).min_addr))
            else:
                return ''
        if isinstance(self.ItemToObject(item), Register):
            if col == self.caller.name_col_index:
                return self.ItemToObject(item).name
            if col == self.caller.addr_col_index:
                return self.int_to_value(int(self.ItemToObject(item).addr))
            elif col == self.caller.len_col_index:
                return str(self.ItemToObject(item).length)
            if col == self.caller.access_col_index:
                return self.ItemToObject(item).access.name
            if col == self.caller.default_col_index:
                return self.int_to_value(int(self.ItemToObject(item).reset_val))
            if col == self.caller.value_col_index:
                if self.ItemToObject(item).path in self.reg_cache_dict.keys():
                    return self.reg_cache_dict[self.ItemToObject(item).path]
                else:
                    return self.unknown_value
            if col == self.caller.volatile_col_index:
                if self.ItemToObject(item).volatile:
                    return 'V'
                else:
                    return ''
            else:
                return ''
        if isinstance(self.ItemToObject(item), Field):
            if col == self.caller.name_col_index:
                return self.ItemToObject(item).name
            elif col == self.caller.addr_col_index:
                return self.int_to_value(int(self.ItemToObject(item).container.addr))
            elif col == self.caller.len_col_index:
                return str(self.ItemToObject(item).bit_width)
            elif col == self.caller.bits_col_index:
                bits = list(self.ItemToObject(item).bit_pos.keys())
                lsbit = self.ItemToObject(item).bit_pos[bits[0]]
                bits.sort(reverse=True)
                msbit = self.ItemToObject(item).bit_pos[bits[0]]
                return f'{msbit}:{lsbit}'
            elif col == self.caller.access_col_index:
                return self.ItemToObject(item).ipx_type
            elif col == self.caller.default_col_index:
                return self.int_to_value(int(self.ItemToObject(item).reset_value))
            elif col == self.caller.value_col_index:
                if self.ItemToObject(item).path in self.field_cache_dict.keys():
                    return self.field_cache_dict[self.ItemToObject(item).path]
                else:
                    return self.unknown_value
            elif col == self.caller.volatile_col_index:
                if self.ItemToObject(item).volatile:
                    return 'V'
                else:
                    return ''
            else:
                return ''

    def CompletePendingValueChanges(self):
        keys = self.pending_value_dict.keys()
        values = self.pending_value_dict.values()
        self.pending_value_dict = {}  # empty the dict
        for k in keys:  # clear the dict and restore the color
            self.ValueChanged(self.ObjectToItem(k), self.caller.value_col_index)

    def ClearPendingValueChanges(self):
        keys = self.pending_value_dict.keys()
        values = self.pending_value_dict.values()
        self.pending_value_dict = {}  # empty the dict
        for k, v in zip(keys, values):  # clear the dict, restore the color, restore original values
            self.ChangeValue(str(v), self.ObjectToItem(k), self.caller.value_col_index)

    def GetAttr(self, item, col, attr):
        if col != self.caller.value_col_index:  # everything but the value column
            if isinstance(self.ItemToObject(item), Field):
                attributes = self.ItemToObject(item).attributes
                if 'internal' in attributes or 'test_key' in attributes or 'user_key' in attributes:  # differentiate internal fields
                    attr.SetBold(True)
                    attr.SetItalic(True)
                    attr.SetColour(self.internal_color)
                    return True
                else:
                    attr.SetBackgroundColour(wx.NullColour)
                    return True
        if col == self.caller.value_col_index:  # value column
            if isinstance(self.ItemToObject(item), Field):
                if self.GetValue(item, self.caller.value_col_index) == self.unknown_value:  # catch the unknown case first so we don't try to convert to int
                    attr.SetBackgroundColour(wx.NullColour)
                    return True
                elif self.ItemToObject(item) in self.pending_value_dict.keys():  # does the field have a pending edit?
                    attr.SetBackgroundColour(self.pending_color)
                    return True
                elif self.ItemToObject(item).reset_value != int(self.GetValue(item, self.caller.value_col_index), 16):
                    attr.SetBackgroundColour(self.non_default_color)  # differentiate the column
                    return True
                else:
                    attr.SetBackgroundColour(wx.NullColour)
                    return True
            elif isinstance(self.ItemToObject(item), Register):
                if self.GetValue(item, self.caller.value_col_index) == self.unknown_value:  # catch the unknown case first so we don't try to convert to int
                    attr.SetBackgroundColour(wx.NullColour)
                    return True
                elif self.ItemToObject(item) in self.pending_value_dict.keys():  # does the field have a pending edit?
                    attr.SetBackgroundColour(self.pending_color)
                    return True
                elif self.ItemToObject(item).reset_val != int(self.GetValue(item, self.caller.value_col_index), 16):  # todo because field and reg have different names for "Reset Value" attribute
                    attr.SetBackgroundColour(self.non_default_color)  # differentiate the column
                    return True
                else:
                    attr.SetBackgroundColour(wx.NullColour)
                    return True
            else:
                return True
        else:
            return False

    def SetValue(self, variant, item, col):
        if col == self.caller.value_col_index:  # only support editing the value column
            # only support editing for registers and fields
            if isinstance(self.ItemToObject(item), Register):
                obj = self.ItemToObject(item)
                self.reg_cache_dict[obj.path] = self.int_to_value(self.value_to_int(variant))  # format the value and convert to str
            if isinstance(self.ItemToObject(item), Field):
                obj = self.ItemToObject(item)
                self.field_cache_dict[obj.path] = self.int_to_value(self.value_to_int(variant))  # format the value and convert to str
        return True

    def ChangePendingValue(self, variant, item, col):
        obj = self.ItemToObject(item)
        if obj not in self.pending_value_dict.keys():
            self.pending_value_dict[obj] = self.GetValue(item, col)  # stash the current value in case we cancel the pending edit
        elif self.int_to_value(self.value_to_int(variant)) == self.pending_value_dict[obj]:  # value returned to original value
            self.pending_value_dict.pop(obj)  # no longer pending
        self.ChangeValue(variant=variant, item=item, col=col)

    @staticmethod
    def value_to_int(value):
        str(value)
        if re.match('0x', value):  # hex
            value = value[2:]  # trim off the prefix
            value = int(value, 16)
            # print('hex')
            # print(value)
            return value
        elif re.match('0b', value):  # binary
            value = value[2:]  # trim off the prefix
            value = int(value, 2)
            # print('binary')
            # print(value)
            return value
        elif re.search('[A-F]', value.upper()):  # hex w/o 0x prefix
            value = int(value, 16)
            # print('hex no prefix')
            # print(value)
            return value
        else:  # try int conversion
            try:
                value = int(value)
                # print(f'Value is: {value}')
                return value
            except ValueError:  # value is hex
                # print('fail')
                return None

    @staticmethod
    def int_to_value(value):
        # converts hex value to the familiar CLIVE format where the digits are upper and the 0x is lower
        value = hex(value)
        return value[:2] + value[2:].upper()
