from cl_test_station.board.board import Board
import time
import sys


class EE00L10MB(Board):
    """Template Board class"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def initialize(self, **kwargs):
        self.log.debug('*** Starting EE00L10MB.initialize ***')
        super().initialize(**kwargs)
        if self.__contains__('rails'):
            self.build_rails()
        self.log.debug('*** Finished EE00L10MB.initialize ***')

    def shutdown(self, **kwargs):
        self.log.debug('*** Starting EE00L10MB.shutdown ***')
        super().shutdown(**kwargs)
        self.container.disable_mb_power()
        if self.__contains__('rails'):
            self.log.info('Powering off Board')
            self.power_down_rails()
        self.log.debug('*** Finished EE00L10MB.shutdown ***')

    def build_rails(self):
        """
        Creates rails for aliasing power supply

        :return: None
        :rtype: None
        """
        # default settings
        default_vbias = dict(voltage=5.0, current_limit=3.25) #todo: check current_limit

        self.log.debug('***** Building Rails *****')
        # teststation = self.find_top_level()
        #todo: discuss if want to turn off vbus and vbatt here, or configure to low voltage and current_limit
        # Digital Motherboard Rails
        self.log.debug('Initializing vbias')
        self.rails.vbias.source_voltage(**default_vbias)
        if self.rails.vbias.output_state() == 'OFF':
            self.rails.vbias.output_state('ON')
            time.sleep(40)
        time.sleep(8)
        #todo: revisit vbus and other

    def power_down_rails(self):
        """
        Power sequence for Syd power down

        :return:
        :rtype:
        """
        # TODO: Set icmd to 0 before power down
        self.power_down_dut_rails()
        time.sleep(0.5)
        # Turn off board power
        self.log.debug('Powering Off vbias')
        self.rails.vbias.output_state('OFF')
        time.sleep(0.5)

    def build_dut_rails(self):
        # time.sleep(0.5)
        pass # no dut rails

    def power_down_dut_rails(self):
        # Turn off VIO_GRPs
        # time.sleep(0.5)
        pass

    def set_dac_supply(self, dac_name='', dac_voltage=0.0):
        """Sets the supply to the given voltage
        :param dac_name: (STR) 'IL_PH1','IL_PH2', 'IL_PH3', 'IL_PH4'
        :param voltage: (float) 0 to 2.5"""

        if dac_name== 'IL_PH1':
            dac1=self.offset_dac_1.VOUT_A
        elif dac_name== 'IL_PH2':
            dac1 = self.offset_dac_2.VOUT_A
        elif dac_name== 'IL_PH3':
            dac1 = self.offset_dac_1.VOUT_B
        elif dac_name== 'IL_PH4':
            dac1 = self.offset_dac_2.VOUT_B
        else:
            raise Exception('Invalid supply name')
        
        dac1.source_voltage(dac_voltage)
        time.sleep(1)

    def get_dac_supply(self, dac_name=''):
        """Gets the Code of the DAC and theoretically calculates the set voltage using slope and intercept value.
        Not measured using a voltmeter
        :param dac_name: (STR) 'IL_PH1','IL_PH2', 'IL_PH3', 'IL_PH4' """

        if dac_name == 'IL_PH1':
            dac1 = self.offset_dac_1.VOUT_A
        elif dac_name == 'IL_PH2':
            dac1 = self.offset_dac_2.VOUT_A
        elif dac_name == 'IL_PH3':
            dac1 = self.offset_dac_1.VOUT_B
        elif dac_name == 'IL_PH4':
            dac1 = self.offset_dac_2.VOUT_B
        else:
            raise Exception('Invalid supply name')

        dac_voltage=dac1.source_voltage()
        return dac_voltage

    def config_dacs(self):
        """
        config both dacs on eeb, set GAIN to 0; and load OFFSETCALs from eeproom if DAC_TRIM_DONE
        :return:
        :rtype:
        """
        self.offset_dac_1.VOUTA.GAIN.value = 0x0
        self.offset_dac_1.VOUTB.GAIN.value = 0x0
        self.offset_dac_2.VOUTA.GAIN.value = 0x0
        self.offset_dac_2.VOUTB.GAIN.value = 0x0

        if self.dut_dc.eeprom_dc.GLOBAL.TRIM_STATUS.DAC_TRIM_DONE.value == 1:
            self.offset_dac_1.VOUTA.RW.DATA.value=self.dut_dc.eeprom_dc.GLOBAL.BST_IL_PH1_OFFSETCAL_0.BST_IL_PH1_OFFSETCAL.value
            self.offset_dac_2.VOUTA.RW.DATA.value=self.dut_dc.eeprom_dc.GLOBAL.BST_IL_PH2_OFFSETCAL_0.BST_IL_PH2_OFFSETCAL.value
            self.offset_dac_1.VOUTB.RW.DATA.value=self.dut_dc.eeprom_dc.GLOBAL.BST_IL_PH3_OFFSETCAL_0.BST_IL_PH3_OFFSETCAL.value
            self.offset_dac_2.VOUTB.RW.DATA.value=self.dut_dc.eeprom_dc.GLOBAL.BST_IL_PH4_OFFSETCAL_0.BST_IL_PH4_OFFSETCAL.value

    def program_board_info_to_eeprom(self, barcode_num, board_rev='A0'):
        """
        write the barcode_num and baord_rev to eeprom fields
        :param barcode_num: board number read from the barcode
        :type barcode_num: int
        :param board_rev: board rev read from the barcode
        :type board_rev: str
        :return:
        :rtype:
        """
        self.eeprom_mb.ID.EEPROM_MAP.reset()
        self.eeprom_mb.ID.BARCODE_0.NUM.value = barcode_num
        self.eeprom_mb.ID.BOARD_REVISION_0.NUMBER.value = int(board_rev[1], 16)
        self.eeprom_mb.ID.BOARD_REVISION_1.LETTER.value = int(board_rev[0], 16)

    def get_board_barcode(self) -> str:
        """
        note: override method for franco, no database involved, getting info from eeprom
        :return barcode:
        :rtype barcode: str
        """

        barcode_num = self.eeprom_mb.ID.BARCODE_0.NUM.value
        board_rev_number = self.eeprom_mb.ID.BOARD_REVISION_0.NUMBER.value
        board_rev_letter = self.eeprom_mb.ID.BOARD_REVISION_1.LETTER.value
        if board_rev_letter == 0xFF:
            print(f'EEPROM has not been programmed. Please program it by call methd program_board_info_to_eeprom( barcode_num, board_rev="A0")')
            barcode = None
        else:
            board_rev = hex(board_rev_letter)[2:].upper()+hex(board_rev_number)[2:]
            barcode_num_str = str(barcode_num)
            if len(barcode_num_str)==1:
                barcode_num_str = '00' + barcode_num_str
            elif len(barcode_num_str)==2:
                barcode_num_str = '0' + barcode_num_str
            else:
                pass
            barcode = 'EE00L10-MB-' + board_rev +'-' + barcode_num_str
        return barcode