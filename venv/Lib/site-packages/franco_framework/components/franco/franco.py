from cl_test_station.components.dut.dut import Dut
from cl_test_station.test_station_object import TsoField
from franco_framework.components.franco.enums import SpiInterfaceName
from franco_framework.components.franco.enums import TopMarkBasicRule
from cl_test_station.components.fpga.fpga import Fpga
from cl_test_station.utilities.reusables import revision_to_hex_str
import time
import openpyxl
from openpyxl import Workbook
import csv
import os

class Franco(Dut, Fpga):
    """Franco DUT class"""
    franco_tc_start_addr: int = TsoField(ftype=int, required=False, default=0x0000_0000,
                                         desc="Start address of the franco_tc. "
                                              "Dictates if need to spi bus request/granted")
    franco_tc_end_addr: int = TsoField(ftype=int, required=False, default=0x0000_FFFF,
                                       desc="End address of the franco_tc. "
                                            "Dictates if need to spi bus request/granted")
    tiadc_start_addr: int = TsoField(ftype=int, required=False, default=0x2400_0000,
                                       desc="Start address of ti adcs. "
                                            "Dictates which spi interface to use")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.SPI_auto_switching = True

    def initialize(self, **kwargs):
        super().initialize(**kwargs)
        self.eeprom_trim = self.find_top_level().eeb.dut_dc.eeprom_dc
        self.eeprom_trim_field_list = None # self.eeprom_trim.IVM.get_fields()

    def shutdown(self, **kwargs):
        super().shutdown(**kwargs)

    def enter_reset(self, *args, **kwargs):
        self.block_apis.FRANCO_FPGA.enter_reset() # self.find_top_level().enter_fpga_reset()
        self.ADC3644_0.enter_reset() # self.find_top_level().enter_tiadcs_reset()  # all ADCs share the same reset signal
        self.block_apis.FRANCO_TC.enter_reset() #         self.find_top_level().enter_franco_tc_reset()

    def exit_reset(self, *args, **kwargs):
        self.find_top_level().exit_fpga_reset()
        time.sleep(0.01)
        self.find_top_level().exit_tiadcs_reset()  # all ADCs share the same reset signal
        time.sleep(0.01)
        self.find_top_level().exit_franco_tc_reset()

    def read_register(self, addr, *args, interface=None, controller=None, **kwargs):
        if self.SPI_auto_switching == False:
            # note: need manually set the correct interface and do bus request/grant check outside of this call
            read_value = super().read_register(addr, *args, **kwargs)
        else:
            _interface, need_spi_bus_request = self.get_interface_and_spi_info_by_address(addr)
            if interface is None:
                interface = _interface
            if need_spi_bus_request:
                self.set_spi_bus_request(request1_release0=1)
                spi_bus_granted = self.get_spi_bus_granted()
                if spi_bus_granted:
                    read_value = super().read_register(addr, *args, interface=interface, **kwargs)
                else:
                    pass # todo: error or warning?
                self.set_spi_bus_request(request1_release0=0)
            else:
                read_value = super().read_register(addr, *args, interface=interface, **kwargs)
        return read_value

    def write_register(self, addr, *args, interface=None, **kwargs):
        if self.SPI_auto_switching == False:
            # note: need manually set the correct interface and do bus request/grant check outside of this call
            super().write_register(addr, *args, **kwargs)
        else:
            _interface, need_spi_bus_request = self.get_interface_and_spi_info_by_address(addr)
            if interface is None:
                interface = _interface
            if need_spi_bus_request:
                self.set_spi_bus_request(request1_release0=1)
                spi_bus_granted = self.get_spi_bus_granted()
                if spi_bus_granted:
                    super().write_register(addr, *args, interface=interface, **kwargs)
                else:
                    pass       # todo: error or warning?  
                self.set_spi_bus_request(request1_release0=0)
            else:
                super().write_register(addr, *args, interface=interface, **kwargs)

    def get_interface_and_spi_info_by_address(self, address: int) :
        """
        Returns reference to the interface for a specific address. Uses tiadc_start_addr as the cut-off. Anything
        below will use spi_interface_franco_tc, above spi_interface_tiadc.
        also return boolean need_spi_request. uses franco_tc_start_addr and franco_tc_end_addr to cut-off. if in range, set
        to True, else False.

        :param address: [int] Address of register
        :return:
            [CtrlInterface] Interface object reference
            [need_spi_bus_request] True/False

        """
        # Case 1: Adderss is below mode 11 cutoff
        if address < self.tiadc_start_addr:
            iface = self.interfaces['spi_interface_franco_tc']
        else:
            iface = self.interfaces['spi_interface_tiadc']
        if address in range(self.franco_tc_start_addr, self.franco_tc_end_addr+1):
            need_spi_bus_request = True
        else:
            need_spi_bus_request = False
        return iface, need_spi_bus_request

    def set_spi_bus_request(self, request1_release0 = 1):
        self.find_top_level().set_spi_bus_request(request1_release0)

    def get_spi_bus_granted(self, time_out=5):
        timeout_start = time.time()
        spi_bus_granted = self.find_top_level().get_spi_bus_granted() # todo: polling from the signal & set time out    # todo: error or warning if timeout
        while spi_bus_granted == 0 or time.time() < timeout_start + time_out:
            spi_bus_granted = self.find_top_level().get_spi_bus_granted()
            if spi_bus_granted == 1:
                break
        return spi_bus_granted

    def enable_spi_auto_switching(self, true_or_false=True):
        """
        :param true_or_false: [boolean] True or False
        :return:
        :rtype:
        """
        self.SPI_auto_switching = true_or_false

    def get_revision(self) -> str:
        """

        :return:
        :rtype:
        """
        # rev_id = hex(self.read_register(self.revision_id_addr))
        # self.enable_TrustZone_Switching=x
        revision = 'a0' # rev_id[2:]
        try:  # Can read the registers
            c4_edition = revision_to_hex_str(self.get_c4_edition(), length=4)
            build_count = revision_to_hex_str(self.get_build_count(), length=4)
            return '%s_%s' % (c4_edition, build_count)
        except Exception:  # Return string since the registers can't be read
            return revision

    def startup_procedure(self):
        # disable the SPI interface and bus auto_switching
        self.enable_spi_auto_switching(False)
        self.set_spi_bus_request(0)

        # refer to : franco_platform_CS00L10_DS1331T3.pdf 10.1
        # 1.  Configure ADC Registers
        self.active_interface = self.interfaces[SpiInterfaceName.spi_interface_tiadc.value]
        self.config_ADCs()

        # 2. Write SIMULINK_MODEL.POWERSTATE_CFG[CONFIG_DONE_ADC] bit to 1
        self.active_interface = self.interfaces[SpiInterfaceName.spi_interface_franco_tc.value] # note: simulink_model use same spi interface
        self.SIMULINK_MODEL.POWERSTATE_CFG.CONFIG_DONE_ADC.value = 1

        # 3. Wait for SPI_READY to be high. This is connected to a GPIO.
        # • When SPI_READY = 1 proceed to Configure TC Registers
        self.set_spi_bus_request(1)
        bus_granted = self.get_spi_bus_granted()
        # 4. Configure TC Registers
        if bus_granted == True:
            self.config_TC()
            self.set_spi_bus_request(0)
        else:
            pass # error or warning

        # 5. Write SIMULINK_MODEL.POWERSTATE_CFG[CONFIG_DONE_TC]
        self.set_spi_bus_request(0)
        self.SIMULINK_MODEL.POWERSTATE_CFG.CONFIG_DONE_TC.value = 1

        self.enable_spi_auto_switching(True)
        pass

    def config_ADCs(self):
        for i in range(6): #adc0~5
            exec(f'self.ADC3644_{i}.REG_0E.value = 0x8')
            exec(f'self.ADC3644_{i}.REG_1F.value = 0x10')
            exec(f'self.ADC3644_{i}.REG_21.value = 0xFC')
            exec(f'self.ADC3644_{i}.REG_22.value = 0xF')
        self.ADC3644_SPARE.REG_0E.value = 0x8
        self.ADC3644_SPARE.REG_1F.value = 0x10
        self.ADC3644_SPARE.REG_21.value = 0xFC
        self.ADC3644_SPARE.REG_22.value = 0xF
        # franco_platform_CS00L10_DS1331T3.pdf 10.1
        # • Write some fixed value to ADC3644_0 (value TBD, but will always be the same)
        # • Write some fixed value to ADC3644_1 (value TBD, but will always be the same)
        # • Write some fixed value to ADC3644_2 (value TBD, but will always be the same)
        # • Write some fixed value to ADC3644_3 (value TBD, but will always be the same)
        # • Write some fixed value to ADC3644_4 (value TBD, but will always be the same)
        # • Write some fixed value to ADC3644_5 (value TBD, but will always be the same)
        # • Write some fixed value to ADC3644_SPARE (value TBD, but will always be the same)
        # • There will also be a version using the SARADC instead of one of the ADC3644, but this is TBD for now.
        pass
    
    def config_TC(self):
        self.apply_trims()
        # a) Read from EEPROM. then write to the TC
        # • Write data from EEPROOM to IVM.REG_PWRUP0_RW
        # • Write data from EEPROOM to IVM.REG_PWRUP1_RW
        # • Write data from EEPROOM to IVM.REG_PWRUP2_RW
        # • Write data from EEPROOM to IVM.REG_AON_RW
        # • Write data from EEPROOM to IVM.REG_LDOS_RW
        # • Write data from EEPROOM to IVM.REG_DCO_RW
        # • Write data from EEPROOM to IVM.REG_CFLY_RW
        # • Write data from EEPROOM to IVM.REG_DRV_INDCS_RW
        # • Write data from EEPROOM to IVM.REG_DRV_RW
        # • Write data from EEPROOM to IVM.REG_VBG_THERMAL_RW
        # • Write data from EEPROOM to IVM.REG_IFET_RW
        # • Write data from EEPROOM to IVM.REG_TRIM0_RW
        # • Write data from EEPROOM to IVM.REG_TRIM1_RW
        # • Write data from EEPROOM to IVM.REG_TRIM2_RW
        # • Write data from EEPROOM to IVM.REG_TRIM3_RW
        # • Write data from EEPROOM to IVM.REG_TRIM4_RW
        # • Write data from EEPROOM to IVM.REG_TRIM5_RW
        # • Write data from EEPROOM to IVM.REG_TRIM6_RW
        # • Write data from EEPROOM to IVM.REG_TRIM7_RW
        # • Write data from EEPROOM to IVM.REG_TRIM8_RW
        # • Write data from EEPROOM to IVM.REG_TRIM9_RW
        # • Write data from EEPROOM to IVM.REG_TRIM10_RW
        # • Write data from EEPROOM to IVM.REG_DRIVE_STRENGTH_RW
        # • Write data from EEPROOM to IVM.REG_PULL_UP_DOWN_EN_RW
        # • Write data from EEPROOM to IVM.REG_PULL_INPUT_OUTPUT_EN_RW
        # self.copy_trims_to_dut()
        pass

    def apply_trims(self, from_eeprom0_or_file1 = 0, file_name=None, file_path=None):
        """
        write the trim values to DUT, from eeprom or from file
        :param from_eeprom0_or_file1: specify where to get the trims, two options: eeprom or file
        :type from_eeprom0_or_file1: int: 0 (eeprom), 1 (file)
        :param file_name: specify the file_name if copy from file (when eeprom0_or_file1 == 1). note: currently support .csv and .xlsx
        :type file_name: str
        :param file_path: specify the file_path if copy from file (when eeprom0_or_file1 == 1)
        :type file_path: str
        :return:
        :rtype:
        """
        if from_eeprom0_or_file1 == 0:
            self.copy_trims_from_eeprom_to_dut()
        elif from_eeprom0_or_file1 == 1 and file_name is not None:
            if os.path.isfile(file_name):
                file_path_name = file_name
            else:
                file_path_name = os.path.join(file_path, file_name)
            if os.path.isfile(file_path_name):
                self.copy_trims_from_file_to_eeprom_or_dut(file_path_name, to_eeprom0_or_dut1 = 1)
            else:
                raise ValueError(f'invalud inputs. file {file_name} does not exist!')
        else:
            raise ValueError(f'invalid inputs!')

    def copy_trims_from_eeprom_to_dut(self, eeprom_trimfield_list=None):
        """
            copy the list of fields value from EEPROM to DUT
        :param eeprom_trimfield_list: the list of fields, if None, all IVM fields in EEPROM
        :type eeprom_trimfield_list:
        :return:
        :rtype:
        """
        # Copy trims from IVM block
        if eeprom_trimfield_list is None:
            if self.eeprom_trim_field_list is None:
                self.eeprom_trim_field_list = self.eeprom_trim.IVM.get_fields()
            eeprom_trimfield_list = self.eeprom_trim_field_list # whole list
        for field in eeprom_trimfield_list:
            _, regname, fieldname = field.full_name.split('.')
            self.IVM.__getattr__(regname).__getattr__(fieldname).value = field.value

    def copy_trims_to_eeprom(self, eeprom_trimfield_list=None, eeprom_present = True):
        """
            copy the list of fields value from DUT to EEPROM ( or output in case of eeprom_present == False (socket card))
        :param eeprom_trimfield_list: the list of fields, if None, all IVM fields in EEPROM
        :type eeprom_trimfield_list:
        :param eeprom_present: in case of socket cards, do not write to EEPROM, return the trims
        :type eeprom_present: bool (True or False), default value True
        :return:
        :rtype:
        """
        import  random
        # Copy trims to eeprom IVM block
        if eeprom_trimfield_list is None:
            if self.eeprom_trim_field_list is None:
                self.eeprom_trim_field_list = self.eeprom_trim.IVM.get_fields()
            eeprom_trimfield_list = self.eeprom_trim_field_list # whole list
        output_list =[]
        for field in eeprom_trimfield_list:
            field_fullname = field.full_name
            _, regname, fieldname = field_fullname.split('.')
            dut_fieldvalue = self.IVM.__getattr__(regname).__getattr__(fieldname).value # int(random.random()*2)
            if eeprom_present:
                field.value = dut_fieldvalue
            else:
                output_list.append([field_fullname, dut_fieldvalue])
        if eeprom_present == False:
            return ['field_fullname', 'field_value'], output_list

    def init_eeprom_trims(self, eeprom_trimfield_list=None):
        """
        this method will initilized tc trim fields in EEPROM to device default
        :param eeprom_trimfield_list:
        :type eeprom_trimfield_list:
        :return:
        :rtype:
        """
        if eeprom_trimfield_list is None:
            if self.eeprom_trim_field_list is None:
                self.eeprom_trim_field_list = self.eeprom_trim.IVM.get_fields()
            eeprom_trimfield_list = self.eeprom_trim_field_list # whole list
        for field in eeprom_trimfield_list:
            field_fullname = field.full_name
            _, regname, fieldname = field_fullname.split('.')
            field.value = self.IVM.__getattr__(regname).__getattr__(fieldname).reset_value
        self.eeprom_trim.GLOBAL.TRIM_STATUS.IVM_TRIM_DONE.value = 0 # clear the IVM_TRIM_DONE bit since all trim goes back to device default

    def copy_trims_from_file_to_eeprom_or_dut(self, filename, sheetname=None, to_eeprom0_or_dut1=0):
        """
        this method will read the file with filename and sheetname info, then write all the field to EEPROM or DUT
        Note: the file should be .csv or .xlsx, with columns: 'field_fullname' and 'field_value'
        :param filename: full path and file name
        :type filename: str
        :param sheetname: in case of xlsx file, specify the sheetname (use active sheet if sheetname is None)
        :type sheetname: str
        :param to_eeprom0_or_dut1: default to 0 (EEPROM)
        :type to_eeprom0_or_dut1: int: 0 (EEPROM), 1 (DUT)
        :return:
        :rtype:
        """
        fname, fext = filename.split('.')
        if os.path.isfile(filename):
            file_name_full = filename
        else:
            file_name_full = os.path.join(os.path.dirname(os.path.realpath(__file__)), filename)
            if os.path.isfile(file_name_full)==False:
                raise ValueError(f'file {filename} does not exist!')
        # print(f'file name full = {file_name_full}')

        if self.eeprom_trim_field_list is None:
            self.eeprom_trim_field_list = self.eeprom_trim.IVM.get_fields()
        if fext == 'csv':
            with open(file_name_full, newline='') as csvfile: #'unit_1_trims.csv'
                reader = csv.DictReader(csvfile)
                col_names = reader.fieldnames
                if 'field_value' in col_names and 'field_fullname' in col_names:
                    for row in reader:
                        # print(row[col_names[0]], row[col_names[1]])
                        if  to_eeprom0_or_dut1 == 0: # to eeprom
                            for ee_f in self.eeprom_trim_field_list:
                                if ee_f.full_name == row['field_fullname']:
                                    ee_f.value = int(row['field_value'])
                                    break
                        else:
                            _, regname, fieldname = row['field_fullname'].split('.')
                            self.IVM.__getattr__(regname).__getattr__(fieldname).value = int(row[col_names[1]])
                else:
                    raise ValueError(f'Input file has cols {col_names}, does not match the required cols: "field_fullname" and "field_value"!')

        elif fext == 'xlsx':
            trims_wb = openpyxl.load_workbook(file_name_full)
            trims_sheet = trims_wb.active if sheetname is None else trims_wb[sheetname]

            col_num = trims_sheet.max_column
            row_num = trims_sheet.max_row
            if col_num == 2:
                col_fieldname = 'A' if trims_sheet['A1'].value == 'field_fullname' else 'B'
                col_fieldvalue = 'B' if trims_sheet['B1'].value == 'field_value' else 'A'
            for i in range(2, row_num+1):
                fieldname_i = trims_sheet[col_fieldname + str(i)].value
                fieldvalue_i = trims_sheet[col_fieldvalue + str(i)].value

                if type(fieldname_i) is str and fieldname_i.find('IVM') >= 0:

                    if  to_eeprom0_or_dut1 == 0: # to eeprom
                        for ee_f in self.eeprom_trim_field_list:
                            if ee_f.full_name == fieldname_i:
                                ee_f.value = int(fieldvalue_i)
                                break
                    else: # to dut
                        _, regname, fieldname = fieldname_i.split('.')
                        self.IVM.__getattr__(regname).__getattr__(fieldname).value = int(fieldvalue_i)

        pass

    def save_trims_to_file_from_eeprom_or_dut(self, filename, from_eeprom0_dut1=0):
        """
        save the trims to file, from EEPROM or DUT
        :param filename:  filename should be full path
        :type filename:  str
        :param from_eeprom0_dut1:  specify from EEPROM or DUT
        :type from_eeprom0_dut1:  int: 0 (EEPROM), 1 (DUT)
        :return:
        :rtype:
        """

        if from_eeprom0_dut1==1:
            fields, trim_list = self.copy_trims_to_eeprom(None, False)

        elif from_eeprom0_dut1==0: # from EEPROM
            if self.eeprom_trim_field_list is None:
                self.eeprom_trim_field_list = self.eeprom_trim.IVM.get_fields()
            trim_list =[]
            fields = ['field_fullname', 'field_value']
            for field in self.eeprom_trim_field_list:
                trim_list.append([field.full_name, field.value])
        else:
            raise ValueError('Invalid inputs!')
        # writ to file
        wb = Workbook()
        sheet = wb.active
        sheet.append(fields)
        for i in range(len(trim_list)):
            # print(f'trim_list[i]: {trim_list[i]}')
            sheet.append(trim_list[i])
        wb.save(filename)
        pass

    def _get_image_name(self, request_version:str):
        """
        Based on requested image version and image_file_suffix, provide the image file name

        :param request_version: requested image version
        :type request_version: str
        :return: file_name
        :rtype: str
        """
        req_c4_edition = request_version[1:5]
        req_build_count = int(request_version[-4:])
        if req_build_count < 10:
            req_build_count = request_version[-2:]
        else:
            req_build_count = str(req_build_count)
        file_name = "e%s_%s%s" % (req_c4_edition, req_build_count,self.image_file_suffix)
        return file_name

    def get_c4_edition(self):
        """
        Reads register at address 'c4_reg_addr' and returns value of the C4 Edition field

        :return: C4 edition field value
        :rtype: int
        """
        c4_reg_value = self.read_register(self.c4_reg_addr)             # Get raw register value
        mask = 2 ** 16 - 1                                              # Create mask
        c4_edition = (c4_reg_value >> 0) & mask                         # Shift and mask c4 edition field
        return c4_edition

    def get_build_count(self):
        """
        Reads register at address 'build_cnt_addr' and returns value of the Build Count field

        :return: Build Count field value
        :rtype: int
        """
        build_count_reg_value = self.read_register(self.build_cnt_addr)             # Get raw register value
        mask = 2 ** 16 - 1                                                          # Create mask
        build_count = (build_count_reg_value >> 0) & mask                           # Shift and mask build count field
        return build_count

    def set_top_mark_in_eeprom(self, top_mark_str):
        """
        write the top_mark to eeprom
        :param top_mark_str:
        :type top_mark_str:
        :return:
        :rtype:
        """

        if len(top_mark_str) == 5:
            w_str = top_mark_str[0]
            x_str = top_mark_str[1:3]
            y_str = top_mark_str[3:]

            w_num = self.top_mark_wafer_id_rule(w_str)
            x_num = self.top_mark_vvhh_rule(x_str)
            y_num = self.top_mark_vvhh_rule(y_str)

            self.eeprom_trim.GLOBAL.TOP_MARK_W.value = w_num
            self.eeprom_trim.GLOBAL.TOP_MARK_XX_0.TOP_MARK_XX.value = x_num
            self.eeprom_trim.GLOBAL.TOP_MARK_YY_0.TOP_MARK_YY.value = y_num
        else:
            raise ValueError(f'Invalid input top_mark {top_mark_str} with length of {len(top_mark_str)}, it should be length of 5!')

    def get_top_mark_from_eeprom(self):
        """
        read top mark fields from eeprom, then convert it to letter follow the TopMarkBasicRule and VVHH rule
        :return top_mark_str:
        :rtype top_mark_str: str, 5 letter
        """
        w_num = self.eeprom_trim.GLOBAL.TOP_MARK_W.TOP_MARK_W.value
        x_num = self.eeprom_trim.GLOBAL.TOP_MARK_XX_0.TOP_MARK_XX.value
        y_num = self.eeprom_trim.GLOBAL.TOP_MARK_YY_0.TOP_MARK_YY.value
        if w_num > 25 or x_num > 2499 or y_num >2499: #Max Wafer ID is 25, max X/Y is 2499
            raise ValueError('top_mark in eeprom is not set yet, please set it before read it')
        else:
            w_str = self.top_mark_wafer_id_rule(w_num)
            x_str = self.top_mark_vvhh_rule(x_num)
            y_str = self.top_mark_vvhh_rule(y_num)

            top_mark_str = w_str + x_str + y_str
            return top_mark_str

    def top_mark_wafer_id_rule(self, w):
        """
        convert w(wafer ID) between letter(top marking letter) <-> num (wafer id) based on TopMarkBasicRule
        :param w:
        :type w: str or int
        :return w_output:
        :rtype w_output: int or str

        note: Wafer ID Marking Rule: BasicRule + 1; and max Wafer ID is 25
        refer to Die_Traceability_Rule_06-08-18.xlsx
        """
        if type(w) is str:
            w_output = TopMarkBasicRule.__getitem__(w).value + 1
        elif type(w) is int:
            w_output =   TopMarkBasicRule(w-1).name
        else:
            raise ValueError('Invalid input!')
        return w_output

    def top_mark_vvhh_rule(self, xy):
        """
        convert topmark xx or yy between letter and num follow the TopMarkBasicRule and VVHH rule
        :param xy:
        :type xy:
        :return:
        :rtype:

        note: refer to Die_Traceability_Rule_06-08-18.xlsx
        """
        if type(xy) is str:
            x1=xy[0]
            x2=xy[1]
            x1_num = TopMarkBasicRule.__getitem__(x1).value
            x2_unm = TopMarkBasicRule.__getitem__(x2).value
            xy_num = x1_num *50 + x2_unm
            return_value = xy_num
        elif type(xy) is int:
            x1_num = int(xy/50)
            x2_num = xy%50
            x1_str = TopMarkBasicRule(x1_num).name
            x2_str = TopMarkBasicRule(x2_num).name
            xy_str = x1_str + x2_str
            return_value = xy_str
        else:
            raise ValueError('Invalid input!')
        return return_value