from cl_test_station.register_map.custom_block import CustomBlock
from franco_framework.components.franco.blocks.interrupts.enums import EnumIRQBitOffset


class INTERRUPTS(CustomBlock):
    """Template class for new Block classes"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    # ToDo: uncomment if you add aliasing the alias YAML does not support
    # def alias(self, **kwargs):
    #     super().alias(**kwargs)
    #     self.attribute = custom logic
    
    def get_irq_status(self, irq_bit = None):
        """
        Read all IRQ_STATUS bit (if input is None), or read the specified bit
        
        :param irq_bit: bit that need to read. default to None: will read all bits.
        :type irq_bit: int (0 ~ 10) or EnumIRQBitOffset
        :return: irq_status
        :rtype: dict of _STATUS
        """     
        irq_status ={}
        reg_value = self.irq_status.value
        if irq_bit is None: # return all bits
            for e in EnumIRQBitOffset:
                bit_name = e.name+'_STATUS'
                bit_offset = e.value
                irq_status[bit_name] =  (reg_value & (2** bit_offset)) >> bit_offset
        else:
            bit_offset = irq_bit if type(irq_bit) == int else irq_bit.value
            bit_name = EnumIRQBitOffset(bit_offset).name + '_STATUS'
            irq_status[bit_name] = (reg_value & (2** bit_offset)) >> bit_offset
        return irq_status

    def get_irq_sticky(self, irq_bit = None):
        """
        Read all IRQ_STICKY bit (if input is None), or read the specified bit
        
        :param irq_bit: bit that need to read. default to None: will read all bits.
        :type irq_bit: int (0 ~ 10) or EnumIRQBitOffset
        :return: irq_sticky
        :rtype: dict
        """

        irq_sticky ={}
        reg_value = self.irq_sticky.value
        if irq_bit is None: # return all bits
            for e in EnumIRQBitOffset:
                bit_name = e.name+'_STICKY'
                bit_offset = e.value
                irq_sticky[bit_name] =  (reg_value & (2** bit_offset)) >> bit_offset
        else:
            bit_offset = irq_bit if type(irq_bit) == int else irq_bit.value
            bit_name = EnumIRQBitOffset(bit_offset).name + '_STICKY'
            irq_sticky[bit_name] = (reg_value & (2** bit_offset)) >> bit_offset
        return irq_sticky

    def get_irq_mask(self, irq_bit = None):
        """
        Read all IRQ_MASK bit (if input is None), or read the specified bit
        
        :param irq_bit: bit that need to read. default to None: will read all bits.
        :type irq_bit: int (0 ~ 10) or EnumIRQBitOffset
        :return: irq_mask
        :rtype: dict
        """
        
        irq_mask ={}
        reg_value = self.irq_mask.value
        if irq_bit is None: # return all bits
            for e in EnumIRQBitOffset:
                bit_name = e.name+'_MASK'
                bit_offset = e.value
                irq_mask[bit_name] =  (reg_value & (2** bit_offset)) >> bit_offset
        else:
            bit_offset = irq_bit if type(irq_bit) == int else irq_bit.value
            bit_name = EnumIRQBitOffset(bit_offset).name + '_MASK'
            irq_mask[bit_name] = (reg_value & (2** bit_offset)) >> bit_offset
        return irq_mask
    
    def set_irq_mask(self, irq_bit = None, bit_value = 1):
        """
        set specified (or all bits if None) IRQ_MASK bit to bit_value
        
        :param irq_bit: bit that need to set. default to None: will set all bits.
        :type irq_bit: int (0 ~ 10) or EnumIRQBitOffset
        :param bit_value: 0 or 1, default 1
        :type bit_value:  int
        :return: 
        :rtype: 
        """
        if irq_bit is None: # set all mask bits
            reg_value = 0
            if bit_value == 1:
                for e in EnumIRQBitOffset:
                    reg_value += 2** e.value
            self.irq_mask.value = reg_value
        else:
            bit_offset = irq_bit if type(irq_bit) == int else irq_bit.value
            bit_name = EnumIRQBitOffset(bit_offset).name + '_MASK'
            bit_obj = self.irq_mask.__getattr__(bit_name)
            bit_obj.value = bit_value
