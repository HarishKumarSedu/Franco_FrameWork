from cl_test_station.register_map.custom_block import CustomBlock
from franco_framework.components.franco.blocks.block_template.enums import EnumTemplate
import pandas as pd
import os
import csv
import inspect

class Visibility(CustomBlock):
    """Template class for new Block classes"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.active_config_file = None
        self.import_vis_table()

    def alias(self, **kwargs):
        super().alias(**kwargs)
        self.vis_rows = [self.vis_row_1, self.vis_row_2, self.vis_row_3, self.vis_row_4]
        self.vis_cols = [self.vis_col_1, self.vis_col_2, self.vis_col_3, self.vis_col_4]

    def import_vis_table(self, file='u_vis_matrix_vis.csv'):
        """
        Import csv with all of the visibility signals and their corresponding mappings into the framework
        """
        # Load block to vis_addr dictionary
        vis_dir = os.path.split(inspect.getfile(self.__class__))[0]
        self.vis_table = pd.read_csv(vis_dir + '/' + file, skipinitialspace=True)

    def get_location_from_name(self, name):
        """ Gets the row and column values from the visibility matrix based on signal name

        :param name: Name of the target signal
        :type name: String
        :return: row, col
        :rtype: tuple(int, int)
        """
        item = self.vis_table.loc[self.vis_table['name'] == name]
        if len(item['row'])==0:
            raise ValueError(f'pin "{name}" does not exist!')
        return int(item['row'].values[0]), int(item['col'].values[0])

    def get_location_from_path(self, path):
        """ Gets the row and column values from the visibility matrix based on the complete signal path

        :param path: Full rtl path of the target signal
        :type path: String
        :return: row, col
        :rtype: tuple(int, int)
        """
        item = self.vis_table.loc[self.vis_table['path'] == path]
        return int(item['row'].values[0]), int(item['col'].values[0])

    def get_name_from_location(self, row, col):
        """ Gets the signal name from the visibility matrix based on input row and column values

        :param row: row value to search for
        :type row: int
        :param col: column value to seach for
        :type col: int
        :return: name of the signal located at input row and column
        :rtype: String
        """
        item = self.vis_table.loc[(self.vis_table['row']==row) & (self.vis_table['col']==col)]
        return item['name'].values[0]

    def get_path_from_location(self, row, col):
        """ Gets the signal rtl path from the visibility matrix based on input row and column values

        :param row: row value to search for
        :type row: int
        :param col: column value to seach for
        :type col: int
        :return: full rtl path of the signal located at input row and column
        :rtype: String
        """
        item = self.vis_table.loc[(self.vis_table['row'] == row) & (df['col'] == col)]
        return item['path'].values[0]

    def get_active_output(self, pin):
        """ Gets the name of the signal on the specified pin

        :param pin: visiblity pin to get
        :type pin: int
        :return: name of the signal currently output to visibility
        :rtype: String
        """
        # TODO: Read register and get name from matrix
        row = self.vis_rows[int(pin/8)][int(pin%8)].value
        col = self.vis_cols[int(pin/8)][int(pin%8)].value
        try:
            name = self.get_name_from_location(row, col)
        except KeyError:
            name = ''
        return name

    def get_active_output_all(self):
        """ Gets the name of the signal on all 32 visibility pins

        :return: names of the signals currently output to visibility
        :rtype: list[String]
        """
        names = []
        for i in range(32):
            names.append(self.get_active_output(i))
        return names

    def set_visibility_by_location(self, pin, row, col):
        """ Sets a pin's visibility output based on a given row and column value

        :param pin: pin number to be configured
        :type pin: int
        :param row: row number to set
        :type row: int
        :param col: column number to set
        :type col: int
        """
        # Get pin's corresponding register
        self.vis_rows[int(pin/8)][int(pin%8)].value = row
        self.vis_cols[int(pin/8)][int(pin%8)].value = col
        # Assign row and column value
        print(f'{pin} :: {row} | {col}')

    def set_visibility_by_name(self, pin, name, use_path_as_name=False):
        """ Sets a pin's visibility output based on a given signal name (or path)

        :param pin: pin number to be configured
        :type pin: int
        :param name: signal name to set
        :type name: String
        :param use_path_as_name: (optional)(default False) set as True to use path as reference instead of name
        :type use_path_as_name: bool
        """
        if use_path_as_name:
            row, col = self.get_location_from_path(name)
        else:
            row, col = self.get_location_from_name(name)
        self.set_visibility_by_location(pin, row, col)

    def set_visibility_by_configuration(self, config_num=0, config_file=None, debug=False):
        """ Configures visibility on all available output pins based on a csv file.

        CSV should be formatted as:
            signal_name0, signal_name1, signal_name2, ..., signal_name31

        Each csv can hold multiple configurations. Each configuration should be one row in the csv file.
        By default this function will load the first config in the csv. If the user specifies a config_num, that number row will be loaded (zero-indexed).
        The csv file in use will be remembered within each test, so the file must only be specified on the first call. The user can then reference
        different configurations in that file throughout the test without having to re-enter the file each time.

        The config_file should specify the full path to the file being used. ex. '$PROJECT_ROOT/Utils/vis_config_example.csv'

        Example:
            self.dut.block_apis.VISIBILITY.set_visibility_by_configuration(config_num=2, config_file='$PROJECT_ROOT/Utils/vis_config_example.csv')
                - This would load the configuration on the third line of vis_config_example.csv
            self.dut.block_apis.VISIBILITY.set_visibility_by_configuration(config_file='$PROJECT_ROOT/Utils/vis_config_example.csv')
                - This would load the configuration on the first line of vis_config_example.csv
            self.dut.block_apis.VISIBILITY.set_visibility_by_configuration(config_num=1)
                - This would load the configuration on the second line of the most recent file
                - If the above statements are called in order, the most recent file is vis_config_example.csv

        :param config_num: (optional)(default 0) The row number to load from the csv
        :type config_num: int
        :param config_file: (optional)(default None) The config file to load from. Will use the previous file if none is specified here.
        :type config_file: String
        :param debug: (optional)(default False) Enable to see debug information
        :type debug: bool
        """
        # Sets all visibility pins based on a mapping from a csv file
        if config_file == None and self.active_config_file == None:
            raise Exception('Need valid visibility configuration file')
        if config_file != None:
            self.active_config_file = os.path.expandvars(config_file)
        configs = []
        with open(self.active_config_file) as csv_file:
            reader = csv.reader(csv_file)
            for row in reader:
                configs.append(row)
            csv_file.close()
        if len(configs) > config_num:
            active_config = configs[config_num]
        else:
            raise ValueError(f'config_num {config_num} does not exist in the config_file {config_file}! note: config_num is 0 based.')
        # set pins
        pin = 0
        if len(active_config) >32:
            raise ValueError(f'There are {len(active_config)} pins in the loaded config! should be pin 0 - 31. please check the config_file {config_file}!')
        for vis_name in active_config:
            if vis_name != '':
                if debug:
                    self.log.info(f'PIN {pin} :: {vis_name}')
                self.set_visibility_by_name(pin, vis_name)
            pin = pin + 1

    def find(self, search_term, search_by_path=False, return_list=False):
        """ Searches the visibility matrix for a signal name (or path) that contains the given search term.

        :param search_term: Substring to search for in the visibility matrix
        :type search_term: String
        :param search_by_path: (optional)(default False) Set as True to search the path strings instead the names
        :type search_by_path: bool
        :param return_list: (optional)(default False) Set as True to return a list of all results
        :type return_lsit: bool
        :return: Prints results and optionally returns a list of names
        :rtype: list<String>
        """
        search_col = 'name'
        if search_by_path:
            search_col = 'path'
        rows = self.vis_table.loc[self.vis_table[search_col].str.contains(search_term, case=False)==True]
        # Strip whitespace and index from results
        names = [x.strip() for x in str.split(rows['name'].to_string(index=False), '\n')]
        for n in names:
            print(n)
        if return_list:
            return names

    def export_active_configuration(self, config_file=None):
        """ Appends the current active configuration to the given config file (or most recently used file)

        :param config_file: Name of the file to write to
        :type config_file: String
        """
        # Get active items
        vis_list = []
        for i in range(32):
            vis_list.append(self.get_active_output(i))
        # Identify file
        if config_file == None and self.active_config_file == None:
            raise Exception('Need valid visibility configuration file')
        if config_file != None:
            self.active_config_file = os.path.expandvars(config_file)
        # Append to file
        with open(self.active_config_file, 'a') as csv_file:
            writer = csv.writer(csv_file)
            writer.writerow(vis_list)
            csv_file.close()
