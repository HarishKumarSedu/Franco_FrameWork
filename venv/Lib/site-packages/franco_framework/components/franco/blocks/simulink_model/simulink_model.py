from cl_test_station.register_map.custom_block import CustomBlock
from franco_framework.components.franco.blocks.block_template.enums import EnumTemplate
import pandas as pd
import os, sys

class SimulinkModel(CustomBlock):
    """Template class for new Block classes"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        file_name= os.path.join(os.path.dirname(os.path.realpath(__file__)), 'control_loop_thlds.csv')
        self.df_control_loop_thlds = pd.read_csv(file_name)

    # ToDo: uncomment if you add aliasing the alias YAML does not support
    # def alias(self, **kwargs):
    #     super().alias(**kwargs)
    #     self.attribute = custom logic

    ibat_buck_thld_dict = {
        'min_A': 0.1,
        'max_A': 14,
        'step_A': 0.002
    }
    def get_ibat_buck_thld_A(self):
        """
        Target current for Ibat regulation in buck modes. Range from 100 mA to 14 A in 2 mA increments.
        """
        x = self.ibat_buck_thld.value #todo: double check to see if need bound it to the valid range
        x_A = self.ibat_buck_thld_dict['min_A'] + x * self.ibat_buck_thld_dict['step_A']
        return x_A

    def set_ibat_buck_thld_A(self, ibat_buck_thld_A):
        """
        Target current for Ibat regulation in buck modes. Range from 100 mA to 14 A in 2 mA increments.
        """
        if ibat_buck_thld_A <self.ibat_buck_thld_dict['min_A'] or ibat_buck_thld_A > self.ibat_buck_thld_dict['max_A']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        ibat_buck_thld_fieldvalue = round((ibat_buck_thld_A - self.ibat_buck_thld_dict['min_A'])/self.ibat_buck_thld_dict['step_A']) #todo: convert _A to field_value
        self.ibat_buck_thld.value = ibat_buck_thld_fieldvalue

    vbat_buck_thld_dict = {
        'min_V': 3,
        'max_V': 4.6,
        'step_V': 0.0005
    }
    def get_vbat_buck_thld_V(self):
        """
        Target voltage for Vbat regulation in buck mode. Range from 3 V to 4.6 V in 0.5 mV increments.
        """
        x = self.vbat_buck_thld.value
        #todo: double check to see if need bound it to the valid range
        x_V =  self.vbat_buck_thld_dict['min_V'] + x * self.vbat_buck_thld_dict['step_V']
        return x_V

    def set_vbat_buck_thld_V(self, vbat_buck_thld_V):
        """
        Target voltage for Vbat regulation in buck mode. Range from 3 V to 4.6 V in 0.5 mV increments.
        """
        if vbat_buck_thld_V < self.vbat_buck_thld_dict['min_V'] or vbat_buck_thld_V > self.vbat_buck_thld_dict['max_V']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        vbat_buck_thld_fieldvalue = round((vbat_buck_thld_V - self.vbat_buck_thld_dict['min_V'])/self.vbat_buck_thld_dict['step_V']) #todo: convert _A to field_value
        self.vbat_buck_thld.value = vbat_buck_thld_fieldvalue

    ibus_buck_thld_dict = {
        'min_A': 0.09,
        'max_A': 3.3,
        'step_A': 0.01
    }
    def get_ibus_buck_thld_A(self):
        """
        Maximum current from Ibus in buck mode. Range from 90 mA to 3.3 A in 10 mA increments.
        """
        x = self.ibus_buck_thld.value #todo: read from field, convert to _A
        x_A = self.ibus_buck_thld_dict['min_A'] + x * self.ibus_buck_thld_dict['step_A']
        return x_A

    def set_ibus_buck_thld_A(self, ibus_buck_thld_A):
        """
        Maximum current from Ibus in buck mode. Range from 90 mA to 3.3 A in 10 mA increments.
        """
        if ibus_buck_thld_A <self.ibus_buck_thld_dict['min_A'] or ibus_buck_thld_A > self.ibus_buck_thld_dict['max_A']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        ibus_buck_thld_fieldvalue = round((ibus_buck_thld_A - self.ibus_buck_thld_dict['min_A'])/self.ibus_buck_thld_dict['step_A']) #todo: convert _A to field_value
        self.ibus_buck_thld.value = ibus_buck_thld_fieldvalue

    vbus_buck_thld_dict = {
        'min_V': 3.9,
        'max_V': 20,
        'step_V': 0.1
    }
    def get_vbus_buck_thld_V(self):
        """
        Vbus minimum voltage during buck mode. Range from 3.9 V to 20 V in 100 mV increments.
        """
        x = self.vbus_buck_thld.value
        #todo: double check to see if need bound it to the valid range
        x_V =  self.vbus_buck_thld_dict['min_V'] + x * self.vbus_buck_thld_dict['step_V']
        return x_V

    def set_vbus_buck_thld_V(self, vbus_buck_thld_V):
        """
        Vbus minimum voltage during buck mode. Range from 3.9 V to 20 V in 100 mV increments.
        """
        if vbus_buck_thld_V < self.vbus_buck_thld_dict['min_V'] or vbus_buck_thld_V > self.vbus_buck_thld_dict['max_V']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        vbus_buck_thld_fieldvalue = round((vbus_buck_thld_V - self.vbus_buck_thld_dict['min_V'])/self.vbus_buck_thld_dict['step_V']) #todo: convert _A to field_value
        self.vbus_buck_thld.value = vbus_buck_thld_fieldvalue

    max_icmd_ph_dict = {
        'min_A': 1,
        'max_A': 6,
        'step_A': 0.1
    }
    def get_max_icmd_ph_A(self):
        """
        Maximum Icmd allowed per phase. This gets multiplied by the max number of phases allowed to limit the current at
        outer loop output. Range from 1 A to 6 A in 0.1 A increments.
        """
        x = self.max_icmd_ph.value #todo: read from field, convert to _A
        x_A = self.max_icmd_ph_dict['min_A'] + x * self.max_icmd_ph_dict['step_A']
        return x_A

    def set_max_icmd_ph_A(self, max_icmd_ph_A):
        """
        Maximum Icmd allowed per phase. This gets multiplied by the max number of phases allowed to limit the current at
        outer loop output. Range from 1 A to 6 A in 0.1 A increments.
        """
        if max_icmd_ph_A <self.max_icmd_ph_dict['min_A'] or max_icmd_ph_A > self.max_icmd_ph_dict['max_A']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        max_icmd_ph_fieldvalue = round((max_icmd_ph_A - self.max_icmd_ph_dict['min_A'])/self.max_icmd_ph_dict['step_A']) #todo: convert _A to field_value
        self.max_icmd_ph.value = max_icmd_ph_fieldvalue

    max_icmd_total_dict = {
        'min_A': 1,
        'max_A': 16,
        'step_A': 0.1
    }
    def get_max_icmd_total_A(self):
        """
        Maximum Icmd allowed at outer loop output. Range from 1 A to 16 A in 0.1 A increments.
        """
        x = self.max_icmd_total.value #todo: read from field, convert to _A
        x_A = self.max_icmd_total_dict['min_A'] + x * self.max_icmd_total_dict['step_A']
        return x_A

    def set_max_icmd_total_A(self, max_icmd_total_A):
        """
        Maximum Icmd allowed at outer loop output. Range from 1 A to 16 A in 0.1 A increments.
        """
        if max_icmd_total_A <self.max_icmd_total_dict['min_A'] or max_icmd_total_A > self.max_icmd_total_dict['max_A']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        max_icmd_total_fieldvalue = round((max_icmd_total_A - self.max_icmd_total_dict['min_A'])/self.max_icmd_total_dict['step_A']) #todo: convert _A to field_value
        self.max_icmd_total.value = max_icmd_total_fieldvalue

        
    def set_inner_loop_cfg(self,max_phases = 3,dcm_en = 1,dith_en = 1):
        self.max_ph.value = max_phases
        self.dcm_en.value = dcm_en
        self.dith_en.value = dith_en
        

    def get_current_icmd_stat(self,valuein):
        """
        This will be formatted in the s6.10 format
        """
        icmd_stat = int(self.icmd_current_stat.value)
        icmd_stat_amps = int(icmd_stat /1024)
        icmd_stat_fract = ((icmd_stat - (icmd_stat_amps * 1024))/1024)
        return icmd_stat_amps,icmd_stat_fract
        
        
    
    vbat_boost_thld_dict = {
        'min_V': 2.7,
        'max_V': 3.4,
        'step_V': 0.1
    }
    def get_vbat_boost_thld_V(self):
        """
        Vbat minimum voltage during boost mode. Range from 2.7 V to 3.4 V in 100 mV increments.
        """
        x = self.vbat_boost_thld.value
        #todo: double check to see if need bound it to the valid range
        x_V =  self.vbat_boost_thld_dict['min_V'] + x * self.vbat_boost_thld_dict['step_V']
        return x_V

    def set_vbat_boost_thld_V(self, vbat_boost_thld_V):
        """
        Vbat minimum voltage during boost mode. Range from 2.7 V to 3.4 V in 100 mV increments.
        """
        if vbat_boost_thld_V < self.vbat_boost_thld_dict['min_V'] or vbat_boost_thld_V > self.vbat_boost_thld_dict['max_V']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        vbat_boost_thld_fieldvalue = round((vbat_boost_thld_V - self.vbat_boost_thld_dict['min_V'])/self.vbat_boost_thld_dict['step_V']) #todo: convert _A to field_value
        self.vbat_boost_thld.value = vbat_boost_thld_fieldvalue

    vbus_boost_thld_dict = {
        'min_V': 5,
        'max_V': 20,
        'step_V': 0.1
    }
    def get_vbus_boost_thld_V(self):
        """
        Target Vbus voltage during boost mode. Range from 5 V to 20 V in 100 mV increments.
        """
        x = self.vbus_boost_thld.value
        #todo: double check to see if need bound it to the valid range
        x_V =  self.vbus_boost_thld_dict['min_V'] + x * self.vbus_boost_thld_dict['step_V']
        return x_V

    def set_vbus_boost_thld_V(self, vbus_boost_thld_V):
        """
        Target Vbus voltage during boost mode. Range from 5 V to 20 V in 100 mV increments.
        """
        if vbus_boost_thld_V < self.vbus_boost_thld_dict['min_V'] or vbus_boost_thld_V > self.vbus_boost_thld_dict['max_V']:
            #todo: error or bound it to 0.1 ~ 14
            #todo: double check to see if need bound it to the valid range
            pass
        vbus_boost_thld_fieldvalue = round((vbus_boost_thld_V - self.vbus_boost_thld_dict['min_V'])/self.vbus_boost_thld_dict['step_V']) #todo: convert _A to field_value
        self.vbus_boost_thld.value = vbus_boost_thld_fieldvalue
        
    def get_operating_state(self):
        """
        Indicates latest operating state.
        """
        from franco_framework.components.franco.blocks.simulink_model.enums import EnumOperatingState
        x = self.operation_state.value
        return EnumOperatingState(x if x<11 else 11).name

    d_phn_dict = {
        'min': 0,
        'max': 0.98,
        'step': 0.00390625
    }
    
    alpha_phn_dict = {
        'min': -.5,
        'max': 0.49609375,
        'step': 0.00390625
    }
    
    
    def get_d_value_phn(self, phase_n):
        """
        Indicates the instantaneous value of D for Phase 4. D goes from 0 to 0.98 at max in steps of ~0.004 ( 0.00390625 to be precise)
        
        [param]: phase_n: [int] 1 ~ 4
        """
        if phase_n in range(1, 5):
            d_ph_n = self.__getattr__(f'd_ph{phase_n}')
        else:
            raise ValueError('invalid phase_n, should be 1 ~ 4')
        x = d_ph_n.value
        return x * self.d_phn_dict['step']

    def get_d_value_all(self):
        ph1 = self.get_d_value_phn(1)
        ph2 = self.get_d_value_phn(2)
        ph3 = self.get_d_value_phn(3)
        ph4 = self.get_d_value_phn(4)
        return ph1,ph2,ph3,ph4

    def get_alpha_value_phn(self, phase_n):
        """
        Indicates the instantaneous value of alpha for any of the 4 phases. Alpha goes from -.5 to 0.496 at max in steps of ~0.004 ( 0.00390625 to be precise)

        [param]: phase_n: [int] 1 ~ 4
        """
        if phase_n in range(1, 5):
            alpha_ph_n = self.__getattr__(f'alpha_ph{phase_n}')
        else:
            raise ValueError('invalid phase_n, should be 1 ~ 4')
        x = alpha_ph_n.value # field value
        # 8 bits signed value with step of 0.00390625
        signed_x = self.fieldvalue_convert_to_signed_value(x, alpha_ph_n.bit_width)
        return signed_x * self.alpha_phn_dict['step']

    def get_alpha_value_all(self):
        """

        """
        alpha1 = self.get_alpha_value_phn(1)
        alpha2 = self.get_alpha_value_phn(2)
        alpha3 = self.get_alpha_value_phn(3)
        alpha4 = self.get_alpha_value_phn(4)
        return alpha1,alpha2,alpha3,alpha4

    def set_d_override_en(self,override):
        """
        
        """
        self.dset_override_en.value = override

    def set_d_override_value(self, dvalue_set, dvalue_set_unit='ratio'):
        """
        Note that the duty cycle is a test register that needs to have the override set for the overriden duty cycle to take effect
        :param dvalue_set:
        :type dvalue_set:
        :param dvalue_set_unit: if None, dvalue_set is field value format; if 'ratio', dvalue_set need to be converted to format u8.24
        :type dvalue_set_unit:
        :return:
        :rtype:
        """

        if dvalue_set_unit is None:
            dset_override_value = dvalue_set
        elif (dvalue_set >= 0) or (dvalue_set < .9801):
            dsetuse = hex(int(((2 ** 24) ) * dvalue_set)) # format u8.24
            dset_override_value = int(dsetuse,16)
        else:
            print("duty cycle is out of bounds")
        self.dset_override_value.value = dset_override_value

    def set_alpha_override_en(self,override):
        """

        :param override:
        :type override:
        :return:
        :rtype:
        """
        self.alpha_override_en.value = override

    def set_alpha_override_value(self, alphavalue_set, value_unit = 'ratio'):
        """
        write the value to the reg field. if value_unit is None: write alphavalue_set directly to the field;
        if value_unit = 'ratio': convert alphavalue_set to the correct format before write.
        Note that the duty cycle is a test register that needs to have the override set for the overriden duty cycle to take effect

        :param alphavalue_set:
        :type alphavalue_set: int(if unit is None), or float (if unit is 'ratio')
        :param value_unit: the unit for alphavalue_set. valid options: None, 'ratio'
        :type value_unit: None or str
        :return:
        :rtype:
        """

        # field is in s8.24 format.
        if value_unit is None:
            alphaset_value_field = alphavalue_set
        # elif (alphavalue_set >= 0) and (alphavalue_set < .501):
        #     alphasetuse = hex(int(((2 ** 24) ) * alphavalue_set))
        #     alphaset_value_field = int(alphasetuse,16)
        # elif  (alphavalue_set >= -.5) and (alphavalue_set < 0):
        elif value_unit == 'ratio':
            if (alphavalue_set >=-0.5) and (alphavalue_set<0.5):
            # todo: implement the conversion here ratio -> s8.24
                alphaset_value_field = self.signed_float_to_signed_m_n(alphavalue_set, format_m=8, format_n=24)
            else:
                raise ValueError(f'input {value_unit} value alphavalue_set = {alphavalue_set} is out of bounds! should be in (-0.5, 0.49...)!')
        else:
            raise ValueError(f'input value_unit = {value_unit} is invalid! valid options are: None, "ratio"')

        #dvalue_set_value  = round((vbus_boost_thld_V - self.vbus_boost_thld_dict['min_V'])/self.vbus_boost_thld_dict['step_V']) #todo: convert _A to field_value
        self.alpha_override_value.value = alphaset_value_field

    def set_icmd_override_en(self, override_en = 1):
        """

        :param override_en: Icmd override options
                *** 00 Ovr off
                >>> 01 Ovr on use ICmdSet
                >>> 10 Ovr on use Ramp Gen
                >>> 11 Ovr on prev value
        :type override_en: [int] valid value: 0, 1, 2, 3
        :return:
        :rtype:
        """
        self.icmd_override_en.value = override_en

    def set_icmd_override_value(self, value, value_unit=None):
        """
            write the value(or after conversion) to field self.dut.SIMULINK_MODEL.TEST_ICMD_OVR_PARAMS.TEST_ICMDSET.value
        :param value: the value to write to the field, may need conversion depends on the value_unit
        :type value: int
        :param value_unit: string or None, if None means the value is in the field value format, if 'A' or 'a', need convert the decimal number to field format u6.10
        :type value_unit: string or None, valid options: 'A', 'a'
        :return:
        :rtype:
        """
        if value_unit is None: # if None, the value is in the correct format for the field
            value_to_write = value
        elif value_unit in ['A', 'a']: # if A, then need conversion
            value_to_write = self.convert_to_unsigned_m_n(value, 6, 10) # need convert float value to format of u6.10
        else:
            raise ValueError(f"Invalid value for input value_unit, valid options are: None, 'A', 'a'!")
        self.icmd_override_setvalue.value = value_to_write # note: reg field in u6.10 format

    def config_icmd_override(self, use_icmd_readvalue=True, icmdset_value=None, icmdset_value_unit = None):
        """
        this method is to config icmd override field TEST_ICMDSET(two options), then enable the override_en bit:
        in case of: use_icmd_readvalue == True: set it to the value read from self.dut.SIMULINK_MODEL.ICMD_VALUE.ICMD_VALUE.value
        else: set it to the input icmdset_value

        :param use_icmd_readvalue: bool value to decide what value to use. if True, use value read from above field
        :type use_icmd_readvalue: [bool], default to True
        :param icmdset_value: icmdset_value, could be field value, or float value with unit ('A',or 'a')
        :type icmdset_value: int (if field value), or float if current value with unit of 'A'/'a'
        :param icmdset_value_unit: the unit for icmdset_value, valid options: None, 'A', 'a'
        :type icmdset_value_unit: None or str
        :return:
        :rtype:
        """
        self.set_icmd_override_en(0) # disable it before changing value
        if use_icmd_readvalue:
            read_icmd_value = self.icmd_value.value #note: read value in s6.10 format.  #todo: read once or average on multiple reads?
            print(f'\033[93m NOTE: read back icmd_value = {read_icmd_value}; Please manually write it to the override field! \033[0m')
            # TODO: experiment it before enable below line
            # self.set_icmd_override_value(read_icmd_value, value_unit = None) # note: the override set field is in u6.10 format)
        elif icmdset_value is not None:
            #todo: convert it to the format needed for field
            self.set_icmd_override_value(icmdset_value, value_unit = icmdset_value_unit) # in Override value of Icmd to be used if test_icmd_override_en=1. This value is in u6.10 format.
            pass
        else:
            raise ValueError(f'Input parameter icmdset_value should not be None in case of use_icmd_value == {use_icmd_value} ')
        self.set_icmd_override_en(1) # enable it

    def config_dref_override(self, use_dref_readvalue=True, drefset_value=None, drefset_value_unit = None):
        """
        this method is to config dref override field TEST_DREFSET(two options), then enable the override_en bit:
        in case of: use_dref_readvalue == True: set it to the value read from self.dut.SIMULINK_MODEL.D_VALUE.value
        else: set it to the input drefset_value

        :param use_dref_readvalue: bool value to decide what value to use. if True, use value read from above field
        :type use_dref_readvalue: [bool], default to True
        :param drefset_value: icmdset_value, could be field value, or float value with unit ('ratio')
        :type drefset_value: int (if field value), or float if current value with unit of 'ratio'
        :param drefset_value_unit: the unit for drefset_value, valid options: None(field_value), 'ratio'
        :type drefset_value_unit: None or str
        :return:
        :rtype:
        """
        self.set_d_override_en(0) # disable it before changing value
        if use_dref_readvalue:
            #todo: there are multiple phases, so use phase_inductor_map to decide the primary phase
            pri_phase = self.phase_inductor_map.value + 1
            read_d_phn_value = self.get_d_value_phn(pri_phase) #todo: read once or average on multiple reads?
            #note: d_phx format step size 0.0039...; drefset: format s8.24
            print(f'\033[93m NOTE: read back d_ph{pri_phase} value = {read_d_phn_value}; Please manually write it to the override field! \033[0m')
            # TODO: experiment it before enable below line
            # self.set_d_override_value(read_d_phn_value, dvalue_set_unit = 'ratio') # note: the override set field is in u6.10 format)
        elif drefset_value is not None:
            #todo: convert it to the format needed for field
            self.set_d_override_value(drefset_value, dvalue_set_unit = drefset_value_unit) # in Override value of Icmd to be used if test_icmd_override_en=1. This value is in u6.10 format.
        else:
            raise ValueError(f'Input parameter icmdset_value should not be None in case of use_icmd_value == {use_icmd_value} ')
        self.set_d_override_en(1) # enable it

    def config_alpha_override(self, use_alpha_readvalue=True, alphaset_value=None, alphaset_value_unit = None):
        """
        this method is to config dref override field TEST_ALPHASET(two options), then enable the override_en bit:
        in case of: use_alpha_readvalue == True: set it to the value read from self.dut.SIMULINK_MODEL.ALPHA_VALUE.value
        else: set it to the input value

        :param use_alpha_readvalue: bool value to decide what value to use. if True, use value read from above field
        :type use_alpha_readvalue: [bool], default to True
        :param alphaset_value: alphaset_value, could be field value (unit None), or float value with unit ('ratio')
        :type alphaset_value: int (if field value), or float if value with unit of 'ratio'
        :param alphaset_value_unit: the unit for alphaset_value, valid options: None(field_value), 'ratio'
        :type alphaset_value_unit: None or str
        :return:
        :rtype:
        """
        self.set_alpha_override_en(0) # disable it before changing value
        if use_alpha_readvalue:
            #todo: there are multiple phases, so use phase_inductor_map to decide the primary phase
            pri_phase = self.phase_inductor_map.value + 1
            alpha_value_ratio = self.get_alpha_value_phn(pri_phase)  #todo: read once or average on multiple reads?
            print(f'\033[93m NOTE: read back alpha_value_ratio = {alpha_value_ratio}; Please manually write it to the override field! \033[0m')
            # TODO: experiment it before enable below line
            # self.set_alpha_override_value(alpha_value_ratio, value_unit = 'ratio') # note: the override set field is in s8.24 format)
        elif alphaset_value is not None:
            self.set_alpha_override_value(alphaset_value, value_unit = alphaset_value_unit) # in Override value of Icmd to be used if test_icmd_override_en=1. This value is in u6.10 format.
            pass
        else:
            raise ValueError(f'Input parameter icmdset_value should not be None in case of use_icmd_value == {use_icmd_value} ')
        self.set_alpha_override_en(1) # enable it

    def set_bst_en(self,en):
        """

        """
        self.bst_en.value = en

    def set_batfet_disable_b(self, dis):
        """

        """
        self.bfet_dis.value = dis

    def set_standby_en(self, en):
        """

        """
        self.stby_en.value = en

    def set_clr_flt(self, en):
        """

        """
        self.clr_flt.value = en

    def set_sw_rst(self, en):
        """

        """
        self.sw_reset.value = en

    def buck_control_loop_test_exclusive(self, control_loop_under_test ):
        """
        Buck control loop tests:
        Set one of the (Vbat,Ibat, Vbus, Ibus) threshold in line.
        Set other three out of line
        Set the control to buck mode
        Set the Vbat and Vbus and Ibat power supply conditions
        
        :param control_loop_under_test: str, valid options: vbus, vbat, ibus, ibat
        :return:
        """
        #todo: check if in buck mode: bst_en=0
        if control_loop_under_test in ['vbus', 'vbat', 'ibus', 'ibat']:
            vbat_buck_thld_V, vbus_buck_thld_V, ibus_buck_thld_A, ibat_buck_thld_A = self.find_thld_values_by_index_name(index_name=control_loop_under_test, mode='buck')
            print(f'vbat_buck_thld_V={vbat_buck_thld_V}, vbus_buck_thld_V={vbus_buck_thld_V}, ibus_buck_thld_A={ibus_buck_thld_A}, ibat_buck_thld_A={ibat_buck_thld_A}')
            self.set_all_buck_thlds(vbat_buck_thld_V, vbus_buck_thld_V, ibus_buck_thld_A, ibat_buck_thld_A )
        else:
            print(f'ERROR: control_loop_under_test: {control_loop_under_test} is not valid, valid options: vbus, vbat, ibus, ibat')
            # todo: error

    def boost_control_loop_test_exclusive(self, control_loop_under_test):
        """
        Boost control loop tests:
        Set one of the (Vbat,Vbus) threshold in line.
        Set the other out of line
        Set the control to buck mode
        Set the Vbat and Vbus and Ibat power supply conditions

        :param control_loop_under_test: str, valid options: vbus, vbat
        :return:
        """
        #todo: check if in boost mode: bst_en=1
        if control_loop_under_test in ['vbus', 'vbat']:
            vbat_boost_thld_V, vbus_boost_thld_V = self.find_thld_values_by_index_name(index_name=control_loop_under_test, mode='boost')
            self.set_all_boost_thlds(vbus_boost_thld_V, vbat_boost_thld_V)
        else:
            print(f'ERROR: control_loop_under_test: {control_loop_under_test} is not valid, valid options: vbus, vbat')
            # todo: error

    def set_all_buck_thlds(self, vbat_buck_thld_V, vbus_buck_thld_V, ibus_buck_thld_A, ibat_buck_thld_A ):
        """
        
        :param vbat_buck_thld_V: float
            vbus_buck_thld_V: float
            ibus_buck_thld_A: float
            ibat_buck_thld_A: float
        :return:
        """
        self.set_vbat_buck_thld_V(vbat_buck_thld_V)
        self.set_vbus_buck_thld_V(vbus_buck_thld_V)
        self.set_ibus_buck_thld_A(ibus_buck_thld_A)
        self.set_ibat_buck_thld_A(ibat_buck_thld_A)
    
    def set_all_boost_thlds(self, vbus_boost_thld_V, vbat_boost_thld_V):
        """
        
        :param vbus_boost_thld_V: float
            vbat_boost_thld_V: float
        :return:        
        """
        self.set_vbus_boost_thld_V(vbus_boost_thld_V)
        self.set_vbat_boost_thld_V(vbat_boost_thld_V)

    def find_thld_values_by_index_name(self, index_name='vbus', mode='buck', vbus=6, vbat=3.6):
        """

        :param index_name: str, valid options:
            mode: str, valid options: buck or boost
            vbus: float
            vbat: float
        :return:     
            in buck mode: vbat_buck_thld_V, vbus_buck_thld_V, ibus_buck_thld_A, ibat_buck_thld_A
            in boost mode: vbat_boost_thld_V, vbus_boost_thld_V
        
        """
        row_i = self.df_control_loop_thlds[(self.df_control_loop_thlds['control_loop_under_test']==index_name) & (self.df_control_loop_thlds['mode']==mode) ]
        # print(f'row_i = {row_i}')
        if mode.lower() == 'buck':
            vbat_buck_thld_V = row_i['vbat_buck_thld_V'].values[0]
            vbus_buck_thld_V = row_i['vbus_buck_thld_V'].values[0]
            ibus_buck_thld_A = row_i['ibus_buck_thld_A'].values[0]
            ibat_buck_thld_A = row_i['ibat_buck_thld_A'].values[0]
            return vbat_buck_thld_V, vbus_buck_thld_V, ibus_buck_thld_A, ibat_buck_thld_A
        elif mode.lower() == 'boost':
            vbat_boost_thld_V = row_i['vbat_boost_thld_V'].values[0]
            vbus_boost_thld_V = row_i['vbus_boost_thld_V'].values[0]
            return vbat_boost_thld_V, vbus_boost_thld_V
        else:
            #todo: error
            print(f'mode {mode} is not supported, please use buck or boost!')
            pass

    def convert_to_unsigned_m_n(self, value_in, format_m = 6, format_n = 10):
        """
            convert value_in (float number) to binary format u(m.n)2
        :param value_in:
        :type value_in: float
        :param format_m:
        :type format_m: int
        :param format_n:
        :type format_n: int
        :return: value_unsigned_m_n
        :rtype: int
        """
        dec_d = math.floor(value_in) # int part
        dec_f = value_in - dec_d # fraction part
        bin_d=format(dec_d, f'>0{format_m}b') # '000010'
        # bin_f = '0000000000' #todo: convert dec_f
        bin_f=''
        for i in range(format_n):
            x=dec_f*2
            bit_i = math.floor(x)
            bin_f += str(bit_i)
            dec_f = x - bit_i
            # print(f'bin_{i} = {bit_i}; bin_f = {bin_f}')

        value_unsigned_m_n = int('0b'+bin_d+bin_f, 2) # todo: convert from value_in
        return value_unsigned_m_n

    def convert_from_unsigned_m_n(self, value_in, format_m=6, format_n = 10):
        """
            convert unsigned value_in (field value read fronm field in format of unsigned m.n) to float number
        :param value_in:
        :type value_in:
        :return:
        :rtype:
        """
        #format u6.10
        # format_m = 6
        # format_n = 10
        x=format(value_in, f'>0{format_m+format_n}b')
        bin_d = x[:format_m]
        bin_f = x[format_m:]
        dec_d=0
        for i in range(format_m):
            dec_d += int(bin_d[i])*2**(format_m - i -1)
        dec_f = 0
        for i in range(format_n):
            dec_f += int(bin_f[i])*2**(-1-i)

        value_float = dec_d +  dec_f# todo convert from value_in
        return value_float

    def fieldvalue_convert_to_signed_value(self, i_num, f_width):
        """
            convert int field_value i_num to signed_value with info of field_width

        :param i_num: field_value
        :type i_num: int
        :param f_width: field_width
        :type f_width: int
        :return: signed value
        :rtype: float
        """
        b_num=format(i_num,f'>0{f_width}b')
        sign_bit = b_num[0]
        value_bits = b_num[1:]
        signed_value = int('0b'+value_bits, 2) - int(sign_bit)*2**(f_width-1)
        return signed_value

    def signed_float_to_signed_m_n(self, signed_float, format_m=8, format_n=24):
        """

        :param signed_float:
        :type signed_float:
        :param format_m:
        :type format_m:
        :param format_n:
        :type format_n:
        :return:
        :rtype:
        """

        sign_bit = 1 if signed_float<0 else 0
        unsigned_value = signed_float + sign_bit*2**(format_m-1)
        x = self.convert_to_unsigned_m_n(unsigned_value, (format_m-1), format_n)
        signed_m_n = x + sign_bit * 2 ** (format_m+format_n-1)
        return signed_m_n
