import logging
import os
import socket
import sys
import threading
import time
import traceback
import warnings
from dataclasses import dataclass, field
from io import StringIO
from multiprocessing import Lock
from time import sleep
from typing import Any, Dict, List, Union

import Pyro5
import Pyro5.api
import Pyro5.errors
import Pyro5.nameserver
import Pyro5.server

from cl_test_station.utilities.reusables import get_station_ip, LOCALHOST
from cl_test_station.utilities.ts_logging import add_file_handler
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.clive_tcp.clive_tcp_client import CliveTcpClient
from cl_test_station.instrumentation.instrument import Instrument
from cl_test_station.instrumentation.instrument_adapter import InstrumentAdapter
from cl_test_station.pyro_support.pyro_transmitter import PyroTransmitter
from  cl_test_station.test_station_object import InvalidTsobject
# - - - - - deprecated - - - - -
from cl_test_station.instrumentation.instrument_server import InstrumentBuilder
from cl_test_station.instrumentation.instrument_server import InstrumentServerControl
# - - - - - - - - - - - - - - - -


@dataclass(repr=False)
class ServerInfo:
    """Dataclass that holds information about what objects from the TestStation config are registered to the Pyro
    name server."""
    name_server: Pyro5.nameserver.NameServer
    host_controllers: List[str] = field(default_factory=lambda: [])  # ref_names for all host controllers in server
    instruments: List[str] = field(default_factory=lambda: [])  # ref_names for all instmngr instruments in server
    config: Dict[str, Union[str, dict]] = field(default_factory=lambda: [])  # Full config dictionary
    # Holds extra information for classes with internal transmitters
    transmitter_wrappers: Dict[str, dict] = field(default_factory=lambda: {})
    # Normal pyro transmitters that are just going to be proxies
    transmitters: List[str] = field(default_factory=lambda: [])
    log: logging.LoggerAdapter = field(default=None)

    def __post_init__(self):
        """
        Get basic logger if none is passed in

        :return: None
        :rtype: None
        """
        if self.log is None:
            self.log = logging.getLogger()

    def __repr__(self):
        return f"{self.__class__.__name__}({len(self.host_controllers)} host controllers, {len(self.instruments)} legacy instruments)"

    def get_config(self) -> Dict[str, Union[str, dict]]:
        """
        Gets test station config as a dictionary. If the legacy instrument builder is used, an empty dictionary will be
        returned (InstrumentBuilder mutates the dictionary and adds nonserializable data).

        :return: Config used to create the Test Station
        :rtype: Dict[str, Union[str, dict]]
        """
        # todo: Fix this workaround (or stop supporting instmngr1)
        for ref_name, sub_cfg in self.config.items():
            if 'class_type' in sub_cfg and 'InstrumentBuilder' in sub_cfg['class_type']:
                return {}
        return self.config

    def list_nameserver_entries(self) -> str:
        """
        Builds newline separated string that contains all objects registered to the name server.

        :return: Pyro name server information
        :rtype: str
        """
        lines = []
        self.name_server._pyroClaimOwnership()
        for name, data in self.name_server.list(return_metadata=True).items():
            lines.append(f"{name}: {data}")
        return '\n'.join(lines)

    def add_transmitter_wrapper(self, name: str, obj: Any):
        """
        Creates metadata for pyro transmitters of classes that use the 'internal_transmitter' decorator. Stores any
        serializable arguments used to construct the local object and all names of internal transmitter attributes.

        :param name: Name of object, ie ref_name for TSOs
        :type name: str
        :param obj: Object that has been decorated
        :type obj: Any
        :return: None
        :rtype: None
        """
        self.transmitter_wrappers[name] = {
            'class_type': f"{obj.__class__.__module__}.{obj.__class__.__name__}",
            'init_kwargs': obj._pyro_init_kwargs,
            'attr_names': obj._pyro_attr_names
        }


class TestStationServer(TestStationObject):
    """Launches a Pyro nameserver if one does not exist and registers all resources to it"""

    def __init__(self, *args, **kwargs):
        self.ip_addr: str = LOCALHOST
        self.name_server: Pyro5.nameserver.NameServer = None
        self.pyro4_daemon: Pyro5.server.Daemon = None
        self.clive_tcp_client = None
        self.objects = {}
        super().__init__(*args, **kwargs)
        self.ns_port = self.find_top_level().ns_port    # retrieve Pyro Name Server port from Test Station

    def launch_name_server(self):
        Pyro5.nameserver.start_ns_loop(port=self.ns_port, host=self.ip_addr)

    def get_name_server(self) -> Pyro5.nameserver.NameServer:
        # Check if name server exists and create if it doesn't
        try:
            self.name_server = Pyro5.api.locate_ns(port=self.ns_port, host=self.ip_addr)  # find the name server
            self.log.info('Found name server: %s' % self.name_server)
        except Pyro5.errors.NamingError:  # Launch name server
            self.log.info_line()
            self.log.info("Launching pyro name server:")
            stream = StringIO()
            old_stream = sys.stdout
            sys.stdout = stream
            thr = threading.Thread(
                target=self.launch_name_server,
                daemon=True)
            thr.start()
            elapsed = 0
            start = time.time()
            while elapsed < 8:
                try:
                    self.name_server = Pyro5.api.locate_ns(port=self.ns_port, host=self.ip_addr)  # find the name server
                    break
                except Pyro5.errors.NamingError:
                    elapsed = time.time() - start
            stream.seek(0)
            for line in stream.readlines():
                self.log.info('    ' + line.strip())
            sys.stdout = old_stream
            self.log.info_line()

    def init_pyro_server(self):
        """
        Instantiates Pyro server objects and launches name server if necessary. Clears name server of all existing entries

        :return: None
        :rtype: None
        """
        Pyro5.config.SERVERTYPE = "thread"
        Pyro5.config.SERPENT_BYTES_REPR = True  # Allow raw bytes to be sent over serpent without encoding
        self.pyro4_daemon = Pyro5.server.Daemon(host=self.ip_addr)  # Instantiate daemon
        self.get_name_server()
        # Clear all entries from name server
        for entry in self.name_server.list().keys():
            self.name_server.remove(entry)

    def register_resource(self, obj: Any, name: str, transmitter_depth: int = 3, allow_attr_setting: bool = False) -> PyroTransmitter:
        """
        Takes in any object and creates a PyroTransmitter then registers it to the name server.

        :param obj: Object to expose over the Pyro server
        :type obj: Any
        :param name: Name registered with object to the name server
        :type name: str
        :param transmitter_depth: Recursive depth of PyroTransmitter
        :type transmitter_depth: int
        :return: None
        :rtype: None
        """
        transmitter = PyroTransmitter(obj, Lock(), '', 0, transmitter_depth, name, '', self.log.logger,
                                      allow_attr_setting=allow_attr_setting)
        uri = self.pyro4_daemon.register(transmitter)
        self.name_server.register(name, uri)
        self.objects[name] = transmitter

    def configure(self, config, *args, **kwargs):
        """

        :param config:
        :param args:
        :param kwargs:
        :return:
        """
        self.log.info("Initializing test station server", border='=')
        super().configure(config, *args, **kwargs)

        # Create the daemon server
        self.init_pyro_server()

        # Create dataclass to hold all server information
        server_info = ServerInfo(self.name_server, config=self.config, log=self.log)

        # Go through attributes and register them in the server
        for resource_name in self.resources:  # Note, might have to switch key with ts_object.ref_name
            ts_object = self.__dict__[resource_name]

            # Check that resource was properly constructed
            if isinstance(ts_object, InvalidTsobject):
                self.log.error(f"Cannot expose unconstructed object '{ts_object.ref_name}' to the Pyro Server. See construction traceback:")
                self.log.print(ts_object.trace)

            # Host controllers have their own list in server_info
            if isinstance(ts_object, HostController):
                server_info.host_controllers.append(resource_name)

            # All other resources
            if isinstance(ts_object, TestStationObject) and resource_name != 'container':

                # - - - - - deprecated - - - - -
                if isinstance(ts_object, InstrumentBuilder):  # deprecated
                    ts_pyro_obj = InstrumentServerControl(ts_object.resources)
                    resource_name = 'instrument_server'
                    uri = self.pyro4_daemon.register(ts_pyro_obj)
                    self.name_server.register(resource_name, uri)
                    ts_object.register_instruments(self.name_server, self.pyro4_daemon)
                    server_info.transmitters.extend(ts_object.instruments)
                    server_info.instruments.extend(ts_object.instruments)
                # - - - - - - - - - - - - - - - -

                # Register adapter with known name "_server_instruments" and register all instrument drivers under it
                elif isinstance(ts_object, InstrumentAdapter):
                    resource_name = '_server_instruments'
                    self.register_resource(ts_object, resource_name, transmitter_depth=1)
                    for inst_name, inst_handle in ts_object.instruments.items():  # Register all visa resource handles
                        if inst_handle.rm_handle is not None:  # Non-simulation instrument driver
                            combined_name = f'{resource_name}_{inst_name}'
                            self.register_resource(inst_handle.rm_handle, combined_name, allow_attr_setting=True)
                            server_info.transmitters.append(combined_name)
                    server_info.transmitters.append(resource_name)

                # Any classes that use the "internal_transmitter" decorator
                elif hasattr(ts_object, '_pyro_attr_names'):
                    # Create server info entry
                    server_info.add_transmitter_wrapper(resource_name, ts_object)
                    # Make pyro transmitters for each attribute
                    for internal_attr_name in ts_object._pyro_attr_names:
                        internal_attr = getattr(ts_object, internal_attr_name)
                        self.register_resource(internal_attr, f'{resource_name}_{internal_attr_name}')

                # Every other resource type will just be a basic PyroTransmitter-Receiver pair
                else:
                    self.register_resource(ts_object, resource_name)
                    server_info.transmitters.append(resource_name)

        # Create client for pushing updates to Clive's GUI via its TCP Server.
        self.clive_tcp_client = CliveTcpClient()
        # register client with Pyro server to allow access from Console / test script interpreters.
        self.register_resource(self.clive_tcp_client, 'clive_tcp_client')

        # Print CLIVE update message
        if 'clive_server_host_port' in self.config:
            # Establish the connection to Clive now if yml file provided TCP "address". An address is a list like this: ['localhost', 5020].
            self.log.info(self.clive_tcp_client.connect(*self.config['clive_server_host_port']))
        else:
            self.log.info('\033[93mCLIVE GUI updates from Python have not been enabled in the project_config .yml file.'
                          '\033[0m')
            self.log.info('\033[93m    To enable at server startup, add this line under cl_test_station_server: '
                          '"clive_server_host_port: [\'localhost\', 5020]".\033[0m')
            self.log.info('\033[93m    To enable on an already running server, start CLIVE, '
                          'then use self.test_station.clive_tcp_client.connect() from the Console.\033[0m')
            self.log.info('\033[93m    NOTE: In either case, CLIVE 4.0.0-92+ must be running before enabling '
                          'the connection.\033[0m\033[0m')
            self.log.info_line()

        # Register server info last
        self.register_resource(server_info, '_server_info')

    def get_ts_logger(self, logger, resources):
        """
        Replaces Test Station logger file handler with a server specific one.
        """
        ts_adapter = super().get_ts_logger(logger, resources)
        for handler in ts_adapter.logger.handlers:
            if hasattr(handler, 'baseFilename') and handler.baseFilename.endswith("test_station_log.log"):
                # Remove this handle
                ts_adapter.logger.removeHandler(handler)
                # Replace with server log file handler
                filename = handler.baseFilename.replace('test_station_log.log', 'server_log.log')
                add_file_handler(ts_adapter.logger, filename)
        return ts_adapter

    def serve(self):
        """
        Blocking function that starts Pyro server request loop.

        :return: None
        :rtype: None
        """
        self.log.info('\033[92m' + "READY." + '\033[0m')
        # TODO: Remove this file?
        server_up = os.path.expandvars('$PROJECT_ROOT') + "\\server_up.txt"
        with open(server_up, 'w') as f:
            f.write('PASS')
        self.pyro4_daemon.requestLoop()
