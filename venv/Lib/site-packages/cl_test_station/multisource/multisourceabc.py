from importlib import import_module
from typing import Any, Callable, Dict, List, Optional, Union

import cl_test_station.utilities.iter_priority as iter_priority
from cl_test_station.multisource.tso_group import TSOGroupableMixin
from cl_test_station.test_station_object import TestStationObject, TsoField


class MultiSourceABC(TSOGroupableMixin, TestStationObject):
    """Generic multiple source abstract class. Defines the basic source.

    Derived classes must implement `get_src_from_path`.

    Derived classes should implement active_source.setter. Something like:

    .. code-block:: python

       @MultiSourceABC.active_source.setter
       def active_source(self, selection: str):
           if MultiSourceABC.active_source.fset(self, selection):
               # Type specific connection activities
               print("Type specific connection activities")
    """
    _post_initialize_group = iter_priority.HIGH
    has_dynamic_attrs = True
    connect_function: Union[Callable, None] = TsoField(
        ftype=str,
        required=False,
        desc="Function to call when selecting active_source.\n"
        "This can either be: \n"
        "\t(1) a function monkey-patched onto the root TestStation, or \n"
        "\t(2) an importable top-level module function. \n"
        "Function should expect params: (selection: str, active_source: Any, new_source: Any, "
        "multisource: MultiSourceABC, test_station: TestStation)",
    )
    sources: Dict[str, Any] = TsoField(ftype=dict, required=True, desc="List of sources available for obj")
    default_source: str = TsoField(ftype=str, required=False, desc="Selects initial active_source, if it exists")
    connect_at_initialization: bool = TsoField(ftype=bool, required=False, default=True, desc="Automatically call connect_function at post_system_initialization")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # This will be the internal collection of name->source with all sources valid for this instance
        self._sources = {}
        self._active_source_name = None

        self._connect_function = None
        if self.connect_function:

            # option 1, monkey patch a function on to TS instance
            self._connect_function = self.resolve_path(self.connect_function)

            # option 2, importable top-level module function
            if not self._connect_function:
                try:
                    pkg_path, sep, func_name = self.connect_function.rpartition(".")
                    module = import_module(pkg_path)
                    self._connect_function = getattr(module, func_name)
                except Exception as e:
                    self.log.error(
                        f"{self.path} could not import connect_function {self.connect_function}"
                    )
                    raise e

            # verify connection function is callable
            if not callable(self._connect_function):
                err = ValueError(f"connect_function `{self.connect_function}` {type(self._connect_function)} (of "
                                 f"MultiSource `{self.path}` {type(self)}) is not callable.")
                self._connect_function = None
                raise err
            # ToDo: Verify connect_function prototype is compatible
            # else:

    def resolve_source(self, path: str) -> Optional[Any]:
        """
        Resolves and returns the given source using TestStationObject.resolve_path.
        Maybe overridden by children to add additional checks.

        :param path: Path to the source object defined in the project configuration YAML
        :type path: str
        :return: The source object, or None if N/A or not present
        :rtype: Any | None
        """
        return self.resolve_path(path)

    def post_system_initialize(self, **kwargs):
        """
        Performs basic checks for a MultiSource and selects initial active_source to use
        Checks Performed
        1. Verifies at least a single source is present
        2. Warns if default source is not present

        Calls connect_function if connect_at_initialization = True

        :param kwargs: Additional keyword arguments
        :type kwargs: Any
        :return: None
        :rtype: None
        """
        # Populate available sources after all objects have been constructed
        if self.sources is None:
            self.log.error('No sources have been defined.')
            return
        self._sources = {
            name: self.resolve_source(path) for name, path in self.sources.items()
        }
        # verify at least a single source is available
        if not self.available_sources:
            self.log.error(
                f"{self.path} has no valid sources. Please verify that a least one listed source exists in the system."
                f"\nSources:\n{self.all_source_names}"
            )
            return
        # select default source, if specified
        if self.default_source:
            if self.default_source in self.available_source_names:
                self._active_source_name = self.default_source
            else:
                self.log.warning(f"{self.path} default source ({self.default_source}) is not available, selecting next "
                                 f"available source {self.available_source_names[0]}")
        # select first available source, if no default specified or available
        if not self.active_source:
            self._active_source_name = self.available_source_names[0]

        if self.connect_at_initialization:
            self.active_source = self._active_source_name

    @property
    def available_sources(self) -> Dict[str, Any]:
        """All sources currently present in the system.

        :return: Dictionary of source name and their objects
        :rtype: Dict[str, Any]
        """
        # sources whose value is not None
        return {k: v for k, v in self._sources.items() if v is not None}

    @property
    def available_source_names(self) -> List[str]:
        """Get all available source names. Equivalent to
        `list(source.available_sources.keys())`.

        :return: List of available source names
        :rtype: List[str]
        """
        return [k for k, v in self._sources.items() if v is not None]

    @property
    def invalid_source_names(self) -> List[str]:
        """All source names that were defined in the project config but were not currently available on the system.

        :return: List of invalid source names
        :rtype: List[str]
        """
        return [k for k, v in self._sources.items() if v is None]

    @property
    def all_sources(self) -> Dict[str, Any]:
        """All sources defined in the config.

        :return: Dict(source_path->source_obj) of available source objects.
            If source_path is N/A, source_obj will be None
        :rtype: Dict[str, Any]
        """
        return self._sources

    @property
    def all_source_names(self) -> List[str]:
        """All source names that were defined in the project config.

        :return: List of all source names defined in config
        :rtype: List[str]
        """
        return list(self.all_sources.keys())

    @property
    def active_source(self) -> Optional[Any]:
        """Returns the currently active source object.

        :return: Active Source object
        :rtype: Any
        """
        if self._active_source_name:
            return self.available_sources[self._active_source_name]

        return None

    @active_source.setter
    def active_source(self, selection: str):
        """Changes the active source to the given source name. If defined, it also calls the connect function.

        :param selection: Name of the available source to be made active
        :type selection: str
        :return: None
        :rtype: None
        """
        # verify requested source is available
        if selection not in self.available_source_names:
            raise ValueError(f"{selection} is not an available source.\nAvailable sources:\n{self.available_source_names}")

        # call connection function if defined
        if self._connect_function:
            self._connect_function(
                selection=selection,
                active_source=self.active_source,
                new_source=self._sources[selection],
                multisource=self,
                test_station=self.find_top_level(),
            )
        self._active_source_name = selection

    @property
    def active_source_name(self) -> Optional[str]:
        """Get the name of the currently active source.

        :return: Name of the currently active source
        :rtype: str
        """
        return self._active_source_name
