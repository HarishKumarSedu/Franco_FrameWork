from typing import Dict, List

from cl_test_station.test_station_object import TestStationObject, TsoField


class TSOGroup(TestStationObject):
    """Derived types can impletment belongs_in_group to enforce only valid
    types are admitted, then devired types can implement specific functions to
    perform on groups os TSOs."""

    has_dynamic_attrs = True
    contains: List[str] = TsoField(
        ftype=list,
        required=False,
        desc="List of TSO paths to associate with this group",
        default_factory=list,
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._elements: Dict[str, TestStationObject] = {}

    def __len__(self) -> int:
        return len(self._elements.keys())

    def post_construct_system(self):
        super().post_construct_system()
        # find and add all elements to model

        for elm in self.contains:
            obj = self.resolve_path(elm)
            if obj:
                self.add_to_group(obj)
            else:
                self.log.warning(f"Could not find {elm}! Not adding to {self.path}")

    @property
    def elements(self) -> Dict[str, TestStationObject]:
        """All TSOs associated with this group.

        :return: Dict of tso_path->tso_obj associated with this group
        :rtype: Dict[str, TestStationObject]:
        """
        return self._elements

    @property
    def element_names(self) -> List[str]:
        """All TSOs names(paths) associated with this group.

        :return: List of names(paths) of all elements associated with this group
        :rtype: List[str]:
        """
        return [elm.path for elm in self.elements.values()]

    def belongs_in_group(self, obj: TestStationObject) -> bool:
        """Basic group admittance filter. Override this to control what can be
        added to a group.

        :param obj: Candidate TSO to add to the group
        :type obj: TestStationObject
        :return: True if the obj was added, otherwise, False
        :rtype: bool
        """
        return True

    def add_to_group(self, obj: TestStationObject) -> bool:
        """Add obj to group. If obj is type TSOGroupableMixin, group is added
        to obj's groups property by calling obj.add_to_group.

        :param obj: Candidate TSO to add to the group
        :type obj: TestStationObject
        :return: True if the obj was added, otherwise, False
        :rtype: bool
        """
        if obj.path in self.elements:
            return False

        if not self.belongs_in_group(obj):
            return False

        self._elements[obj.path] = obj

        if hasattr(obj, "add_to_group") and callable(obj.add_to_group):
            obj.add_to_group(self)

        return True


class TSOGroupableMixin(TestStationObject):
    """Mixin for easily adding group functionality to any TSO."""

    belongs_to: List[str] = TsoField(
        ftype=list,
        required=False,
        desc="List of groups this TSO belongs to",
        default_factory=list,
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._groups: List[TSOGroup] = []

    def post_construct_system(self):
        super().post_construct_system()

        # Populate group relationship
        for group_path in self.belongs_to:
            group: TSOGroup = self.resolve_path(group_path)
            if group is not None and isinstance(group, TSOGroup):
                self.add_to_group(group)
            else:
                self.log.warning(
                    f"Could not find group {group_path}, cannot add {self.path} to {group_path}"
                )

    def add_to_group(self, group: TSOGroup) -> bool:
        """Add this TSO to group. Returns whether this TSO was actually added.

        :param group: Candidate TSO to add to the group
        :type group: TSOGroup
        :return: True if the obj was added, otherwise, False
        :rtype: bool
        """
        if group in self._groups:
            return False

        self._groups.append(group)

        if not group.add_to_group(self):
            # If the TSOGroup declines membership, do not track it, return False(not added)
            # TSOGroup will call this function, so self._groups needs to have group in it to avoid recursion
            self._groups.pop()
            return False

        return True

    @property
    def groups(self) -> List[TSOGroup]:
        """Get all groups this TSO is associated with.

        :return: List of TSOGroups this obj is associated with
        :rtype: List[TSOGroup]
        """
        return self._groups

    @property
    def group_paths(self) -> List[str]:
        """Get all group names(paths) this TSO is associated with.

        :return: List of TSOGroups names(paths) this obj is associated with
        :rtype: List[str]
        """
        return [group.path for group in self._groups]
