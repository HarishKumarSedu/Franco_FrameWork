from cl_test_station.test_station_server import TestStationServer
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.test_station import TestStation
import os, sys
from pydoc import locate
import Pyro5
import Pyro5.api
import Pyro5.errors
import Pyro5.server
import threading
from time import sleep
from unified_modules.test_support.testresults import TestResults
import warnings
import socket


class RemoteUmTestRunnerServer(TestStationServer):
    """Place Holder"""
    def __init__(self, *args, test_lock=None, **kwargs):
        self.test_lock = test_lock
        super().__init__(*args, **kwargs)

    def configure(self, config, *args, **kwargs):
        """
        Place Holder

        :param config:
        :param args:
        :param kwargs:
        :return:
        """
        Pyro5.config.SERVERTYPE = "multiplex"
        Pyro5.config.SERPENT_BYTES_REPR = True
        self.ns_port = self.container.ns_port
        # Create the daemon server
        self.pyro_daemon = Pyro5.server.Daemon()
        self.ip_addr = socket.gethostbyname(socket.gethostname())

        # Check if name server exists and create if it doesn't
        try:
            self.name_server = Pyro5.api.locate_ns(port=self.ns_port, host=self.ip_addr)  # find the name server
        except Pyro5.errors.NamingError:
            thr = threading.Thread(
                target=self.launch_name_server,
                daemon=True)
            thr.start()
            sleep(5)
            self.name_server = Pyro5.api.locate_ns(port=self.ns_port, host=self.ip_addr)  # find the name server

        super(TestStationServer, self).configure(config, *args, **kwargs)

        for key, value in self.resources.items():
            # We only want to deal with remote test runners in this server
            if type(value) == RemoteUmTestRunner:
                value.set_lock(self.test_lock)
                remote_runner_uri = self.pyro_daemon.register(value)
                self.name_server.register(key, remote_runner_uri)
                self.pyro_daemon.resetMetadataCache(value)

@Pyro5.api.expose
class RemoteUmTestRunner(TestStationObject):
    """Place Holder"""
    def configure(self, config, *args, **kwargs):
        super().configure(config, *args, **kwargs)
        self.test_result = locate(config['result_processor'])()
        self.proj_framework = locate(config['project_framework'])()
        self.lock = None
        self.test_objects = {}
        # Load all tests in the folder mentioned in test_controller_resource_config.yml
        self.tests = self.load_test_paths()
        print()

    def set_lock(self, test_lock):
        """
        Place Holder

        :param test_lock:
        :return:
        """
        self.lock = test_lock

    def load_test_paths(self):
        """
        Place Holder

        :return:
        """
        sys.path.append(os.path.expandvars('$PYTHONPATH'))
        classes = {}
        paths_to_walk = []

        for value in self.test_folders:
            relative_path = os.path.normpath(os.path.relpath(os.path.expandvars(value),
                                                             start=os.path.expandvars('$PROJECT_ROOT')))
            dot_path = ''
            for dir in relative_path.split('\\' if sys.platform == 'win32' else '/'):
                dot_path += dir + '.'
            paths_to_walk.append((os.path.expandvars(value), dot_path[:-1]))

        # Iterate through all paths
        for rootdir, prefix in paths_to_walk:
            classes.update(self.load_classes_from_path(rootdir, prefix))
        return classes

    def run_test(self, test_name, execution_mode=0, test_parameters_keys=[], test_parameters_values=[], trim_src="VAL",
                 apply_trims_from="NONE", db_version=0, categories=[], tcorner_str='ROOM', vcorner_str='TYP'):
        """
        Place Holder

        :param test_name:
        :param execution_mode:
        :param test_parameters_keys:
        :param test_parameters_values:
        :param trim_src:
        :param apply_trims_from:
        :param db_version:
        :param categories:
        :param tcorner_str:
        :param vcorner_str:
        :return:
        """
        # t = Thread(target=self.run_test_thread, args=(test_name, *args, ), daemon=True)
        # t.start()
        # with futures.ProcessPoolExecutor() as pool:
        #    future_result = pool.submit(run_test_thread, self.test_folders, test_name, self.result_processor, self.project_framework, *args)
        #    result = future_result.result()
        # return result

        #Convert parameters keys and values list into a single dictionary
        test_parameters = {test_parameters_keys[i]: test_parameters_values[i] for i in range(len(test_parameters_keys))}
        print('********************************************************************************************')
        print("Test Parameters:", test_parameters)
        print('***************************')
        print("Active Tcorner = %s" % tcorner_str)
        print("Active Vcorner = %s" % vcorner_str)
        print('***************************')
        print("Trim Source = %s" % trim_src)
        print("Trims Applied From = %s" % apply_trims_from)
        print("DB Version = %d" % db_version)
        print("Categories = %s" % categories)
        print('********************************************************************************************')

        # # Load all tests in the folder mentioned in test_controller_resource_config.yml
        # self.tests = self.load_test_paths()

        # Instantiate the test required
        if test_name not in self.test_objects.keys():
            test = self.tests[test_name](self.test_result, self.proj_framework, test_params=test_parameters, trim_src=trim_src,
                                         apply_trims_from=apply_trims_from, db_version=db_version, categories=categories,
                                         tcorner_str=tcorner_str, vcorner_str=vcorner_str)
            self.test_objects[test_name] = test
        else:
            test = self.test_objects[test_name]
            test.test_parameters = test_parameters
            test.trim_src = trim_src
            test.apply_trims_from = apply_trims_from
            test.db_version = db_version
            test.categories = categories
            test.tcorner_str = tcorner_str
            test.vcorner_str = vcorner_str
            test.df_data_float = None
            test.df_data_string = None
            test.df_data_file = None
            test.df_data_sweep = None
            test.df_user_data_float_TS = None
            test.df_user_data_string_TS = None
            test.result = TestResults()


        # Instatiate Return Code to 0
        RETURN_CODE = 0

        # Check if execution is normal mode: setup --> instatiate --> teardown
        if execution_mode == 1:
            print('\033[4m''\033[1m''\033[92m'"Execution Mode: Setup"'\033[0m''\033[0m''\033[0m')
            test.run_setup()
        elif execution_mode == 2:
            print('\033[4m''\033[1m''\033[92m'"Execution Mode: Initiate"'\033[0m''\033[0m''\033[0m')
            test.run_test()
            RETURN_CODE = test.report_result()
        elif execution_mode == 3:
            print('\033[4m''\033[1m''\033[92m'"Execution Mode: Teardown"'\033[0m')
            test.run_teardown()
        else:
            print('\033[4m''\033[1m''\033[92m'"Execution Mode: Setup --> Initiate --> Teardown"'\033[0m''\033[0m''\033[0m')
            RETURN_CODE, _ = test.run()

        # Check if test passed or failed and update return value accordingly
        test_pass = (RETURN_CODE == 0)

        # Retrieve all float data information
        float_datas = self.get_all_float_data_information(test.df_data_float)

        # Retrieve all string data information
        string_datas = self.get_all_string_data_information(test.df_data_string)

        # Retrieve all file data information
        file_datas = self.get_all_file_data_information(test.df_data_file)

        # Retrieve all sweep data information
        sweep_datas = self.get_all_sweep_data_information(test.df_data_sweep)

        # Retrieve all user float data to be returned to TS
        user_float_datas = self.get_all_user_float_data_TS(test.df_user_data_float_TS)

        # Retrieve all user string data to be returned to TS
        user_string_datas = self.get_all_user_string_data_TS(test.df_user_data_string_TS)

        return (test_pass, float_datas, string_datas, file_datas, sweep_datas, user_float_datas, user_string_datas)

    def get_all_float_data_information(self, float_data_table):
        """
        Place Holder

        :param float_data_table:
        :return:
        """
        float_data_names = []
        float_data_values = []
        float_data_units = []
        float_data_description = []
        float_data_tp_val = []

        try:
            for row in float_data_table['float_data']:
                float_data_names.append(row['measurement'])
                float_data_description.append((row['description']))
                float_data_values.append(row['value'])
                float_data_units.append(row['units'])

            for float_tp_val_row in float_data_table['tp_val']:
                values = tuple(float_tp_val_row.values())
                float_data_tp_val.append(values)
        except:
            print('\033[93m''WARNING: No Float Data to log''\033[0m')

        # Group all lists in a tuple
        float_data_info_tuple = (float_data_names, float_data_values, float_data_units, float_data_description, float_data_tp_val )

        return float_data_info_tuple

    def get_all_string_data_information(self, string_data_table):
        """
        Place holder

        :param string_data_table:
        :return:
        """
        string_data_names = []
        string_data_values = []
        string_data_units = []
        string_data_description = []
        string_data_tp_val = []

        try:
            for row in string_data_table['string_data']:
                string_data_names.append(row['measurement'])
                string_data_description.append((row['description']))
                string_data_values.append(row['value'])
                string_data_units.append(row['units'])

            for string_tp_val_row in string_data_table['tp_val']:
                values = tuple(string_tp_val_row.values())
                string_data_tp_val.append(values)
        except:
            print('\033[93m''WARNING: No String Data to log''\033[0m')

        # Group all lists in a tuple
        string_data_info_tuple = (string_data_names, string_data_values, string_data_units, string_data_description, string_data_tp_val)

        return string_data_info_tuple

    def get_all_file_data_information(self, file_data_table):
        """
        Place Holder

        :param file_data_table:
        :return:
        """
        file_data_names = []
        file_data_paths = []
        file_data_directories = []
        file_data_file_names = []
        file_data_extensions = []
        file_data_descriptions = []
        file_data_tp_val = []

        try:
            for row in file_data_table['file_data']:
                file_data_names.append(row['measurement'])
                file_data_descriptions.append(row['description'])
                file_data_paths.append(row['file_path'])
                file_data_directories.append(row['file_dir'])
                file_data_file_names.append(row['file_name'])
                file_data_extensions.append(row['file_extension'])

            for file_tp_val_row in file_data_table['tp_val']:
                values = tuple(file_tp_val_row.values())
                file_data_tp_val.append(values)

        except:
            print('\033[93m''WARNING: No File Data to log''\033[0m')

        file_data_info_tuple = (
        file_data_names, file_data_paths, file_data_directories, file_data_file_names, file_data_extensions,
        file_data_descriptions, file_data_tp_val)

        return file_data_info_tuple

    def get_all_sweep_data_information(self, sweep_data_table):
        """
        Place Holder

        :param sweep_data_table:
        :return:
        """
        sweep_names = []
        sweep_series_details = []
        sweep_series_data = []
        sweep_data_tp_val = []


        try:
            for row in sweep_data_table['sweep_name']:
                sweep_names.append(row)

            for row in sweep_data_table['series_list']:
                current_meas_details = []
                current_meas_data = []
                for each_dict in row:
                    current_meas_details.append((each_dict['label'], each_dict['series_type'], each_dict['units']))
                    current_meas_data.append(each_dict['series_data'])
                sweep_series_details.append((current_meas_details, "DUMMY_TO_ENABLE_TUPLE_IN_TESTSTAND"))
                sweep_series_data.append((current_meas_data, "DUMMY_TO_ENABLE_TUPLE_IN_TESTSTAND"))

            for sweep_tp_val_row in sweep_data_table['tp_val']:
                values = tuple(sweep_tp_val_row.values())
                sweep_data_tp_val.append(values)
        except:
            print('\033[93m''WARNING: No Sweep Data to log''\033[0m')

        sweep_data_info_tuple = (sweep_names, sweep_series_details, sweep_series_data, sweep_data_tp_val)

        return sweep_data_info_tuple

    def get_all_user_float_data_TS(self,user_float_data_TS_table):
        """
        Place Holder

        :param user_float_data_TS_table:
        :return:
        """
        return_data_values = []
        try:
            for row in user_float_data_TS_table['user_float_data_TS']:
                return_data_values.append(row['value'])

        except:
            print('\033[93m''WARNING: No User Float Data to send to TestStand''\033[0m')

        # Group all lists in a tuple
        user_float_data_info_tuple = (return_data_values, "DUMMY_TO_ENABLE_TUPLE_IN_TESTSTAND")

        return user_float_data_info_tuple

    def get_all_user_string_data_TS(self, user_string_data_TS_table):
        """
        Place Holder

        :param user_string_data_TS_table:
        :return:
        """
        return_data_values = []
        try:
            for row in user_string_data_TS_table['user_string_data_TS']:
                return_data_values.append(row['value'])

        except:
            print('\033[93m''WARNING: No User String Data to send to TestStand''\033[0m')

        # Group all lists in a tuple
        user_string_data_info_tuple = (return_data_values, "DUMMY_TO_ENABLE_TUPLE_IN_TESTSTAND")

        return user_string_data_info_tuple
