import re
from dataclasses import dataclass
from math import isclose
from typing import Dict, Set, Union
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC
from cl_test_station.board.board import Board
from cl_test_station.components.dacs.dac.dac import Dac
from cl_test_station.components.dacs.dac_channels.dac_channel_base import DacChannelBase
from cl_test_station.components.dacs.dac_channels.dac_channel import DacChannel
from cl_test_station.components.dacs.dac_channels.dac_supply_channel import DacSupplyChannel
from cl_test_station.test_station_object import TestStationObject, TsoField

NO_OP = 'NO-OP'

class RailAssignmentException(Exception):
    pass

# Wrapper that allows a function to access protected attributes of rails
def full_attribute_access(func):
    """Wrapper that allows a function to access protected attributes of rails"""
    def inner(self, *args, **kwargs):
        # Unlock rail attributes
        setattr(self, '_Rails__constructed', False)
        # Call function
        func(self, *args, **kwargs)
        # Lock rail attributes
        setattr(self, '_Rails__constructed', True)
    return inner

@dataclass
class RailSource:
    """Class defining rail sources"""
    def __repr__(self):
        if is_no_op(self.src):
            return self.src
        elif hasattr(self.src, 'get_mro'):  # Get object from mro
            return f'{self.src.get_mro()[0]} object: {self.path}'
        else:  # For objects without objects
            return f'{self.src} object: {self.path}'
    name: str
    src: Union[PSChannel_ABC, DacChannel, DacSupplyChannel, str]
    path: str


class RailContainer(TestStationObject):
    """
    Rails container class for organizing yaml better
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @full_attribute_access
    def post_construct_system(self):
        super().post_construct_system()

    def __setattr__(self, name, value):
        if not hasattr(self, '_Rails__constructed'):
            super().__setattr__(name, value)
        else:
            if self._Rails__constructed and isinstance(self.resources[name], Rail):
                raise RailAssignmentException(f'Cannot assign rail object to a new value after it has been '
                                                  f'constructed.\nTry using {self.path}.{name}.source_voltage() or {self.path}.{name}.active_src')
            super().__setattr__(name, value)

    def output_state_all(self, on_off: Union[str, int, bool] = None, zero_volt_out: bool = None,
                               restore: bool = False, *args, **kwargs) -> Dict[str, str]:
        """
        Set the output_state for every rail defined within the RailContainer. If called with no parameters, return a
            dict of channels with their output state as key values.

        :param on_off: 'ON', '1', 1, True to power on, 'OFF', '0', 0, False to power off
        :type on_off: str, int, bool
        :param zero_volt_out: Turn on teh zero_volt_out setting for every rail within RailContainer. This setting forces
            0V instead of a HIGH-Z state when the rail if OFF.
        :type zero_volt_out: bool
        :param restore: When rail is set to "OFF" output state, it will save the voltage it was outputting before
            turning off. When turning the output state back to "ON" and having this parameter set to True will set the rail
            to the voltage the rail was at before turning off. This parameter is especially helpful when using zero_volt_out
            configuration on rails as this method changes the rail voltage to zero.
        :type restore: bool
        :return: A dictionary containing all rails within the RailContainer and their corresponding output_state as
            their key values.
        :rtype: dict
        """

        # Readback channel output states.
        if on_off is None:
            return_vals = {}
            for rail in self.get_rails():
                return_vals[f'{rail[1].ref_name}'] = rail[1].output_state(on_off, zero_volt_out=zero_volt_out,
                                                                    restore=restore)
            return return_vals

        for rail in self.get_rails():
            rail[1].output_state(on_off=on_off, zero_volt_out=zero_volt_out, restore=restore)

    def get_rails(self):
        return self.find_all(Rail)

    def generate_id(self, *args, **kwargs):
        return 0

class Rail(TestStationObject):
    """Rail class for rail construction in system"""

    has_dynamic_attrs = True

    # Lists used for tracking active rails and sources
    __system_active_rails__ = []
    __system_active_srcs__ = []

    sources: Dict[str, RailSource] = TsoField(ftype=dict, required=True, desc="List of power sources "
                                                                              "available for rail")
    default_src: Union[str, RailSource] = TsoField(ftype=str, required=False, desc="Default active rail")
    zero_volt_out: bool = TsoField(ftype=bool, required=False, default=False, desc="Set True to have the rail output"
                                                                                   "zero volts instead of a high z"
                                                                                   "state when set to 'OFF'")

    rail_sources: Set[RailSource] = set()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.has_dynamic_attrs = True
        self.invalid_sources = {}

        self.__system_active_rails__.append(self)

        self.sources = self.sources.copy()

        self._restore_voltage = None
        self._on_vals = ['ON', 1, '1', True]
        self._off_vals = ['OFF', 0, '0', False]

    def post_construct_system(self):
        super().post_construct_system()
        # Ensure sources are listed for rails
        if self.sources is None:
            # TODO: Is this check necessary?
            raise EnvironmentError(f'{self.ref_name} has no sources listed. List possible sources for rail')
        # Ensure rail is constructed underneath a Board and RailContainer
        if not isinstance(self.container, RailContainer):
            raise AttributeError(f'{self.ref_name} is not constructed beneath a RailContainer object.')
        if not isinstance(self.container.container, Board):
            raise AttributeError(f'{self.ref_name} container {self.container.ref_name} is not constructed beneath a '
                                 f'Board object.')
        # Create rail sources
        for name, rail in self.sources.items():
            if not isinstance(rail, str):
                raise ValueError(f'Bad source: {name}: {rail} is of type {type(rail)}. Needs to be of type str')
            # NO_OP
            if is_no_op(rail):
                rail = RailSource(name=name, src=NO_OP, path=rail)
                setattr(self, name, rail)
                self.sources[name] = rail
            else:
                src = self.resolve_path(rail)
                if src is not None:
                    rail = RailSource(name=name, src=src, path=rail)
                    # Power Supply Channel
                    if isinstance(src, (PSChannel_ABC)):
                        setattr(self, name, rail)
                        self.sources[name] = rail
                    # Dac Channel
                    elif isinstance(src, DacChannelBase):
                        setattr(self, name, rail)
                        self.sources[name] = rail
                    else:
                        # TODO: FIX get_mro() error occuring here
                        self.log.debug(f'{name} in {self.ref_name} is not a valid power source')
                        self.invalid_sources[name] = rail
                else:
                    self.invalid_sources[name] = rail
                    self.log.debug(f'{name} with value {rail} could not be defined')
        # Remove invalid sources from sources dict
        for name in list(self.sources.keys()):
            if name in self.invalid_sources.keys():
                self.sources.pop(name)

        # Check for any available sources
        if not self.sources.items():
            raise EnvironmentError(f'{self.ref_name} has no sources that are valid. Connect/setup valid power sources')

        # If not default source is given or is None
        if not self.default_src:
            self.default_src = list(self.sources.items())[0][0]
        # If defined in station env file
        if isinstance(self.default_src, str):
            for key, value in self.sources.items():
                if value.path == self.default_src:
                    self.default_src = key
        self.default_src = self.sources[self.default_src]
        self._active_src = self.default_src

        self.update_attr()
        self._active_src_handling(self._active_src)

    def update_attr(self):
        """
        Give rail methods that belongs to its current active source.

        :return: None
        :rtype: None
        """
        for method in ['measure_voltage', 'measure_current', 'measure_power']:
            # Set attributes for active_src at rail level
            if hasattr(self._active_src.src, method):
                setattr(self, method, self._active_src.src.__getattribute__(method))
            # Delete attributes if active_src does not provide them
            if hasattr(self, method) and not hasattr(self._active_src.src, method):
                delattr(self, method)
        self.__power_meas_handling()
        if not hasattr(self, 'measure_power') and hasattr(self, 'measure_voltage') and hasattr(self, 'measure_current'):
            setattr(self, 'measure_power', self.estimate_power)

    def source_voltage(self, voltage: float = None, current_limit: float = None, **kwargs) -> Dict[str, float]:
        """
        Set voltage settings and configure source.

        :param voltage: Desired output voltage of rail
        :type voltage: float
        :param current_limit: Maximum current limit of source
        :type current_limit: float
        :return: Return configured voltage value
        :rtype: Dict of voltage and current limit values
        """
        if is_no_op(self._active_src.src):
            raise ValueError(f'Active source on rail {self.ref_name} is NO_OP. Cannot be configured or read.')
        if voltage is not None:
            # Hanlding for PS specific parmaeters
            if kwargs:
                if 'forcing_range' in kwargs.keys():
                    self.active_src.source_voltage(voltage=voltage, current_limit=current_limit,
                                                     forcing_range=kwargs['forcing_range'])
                elif 'write_only' in kwargs.keys():
                    if kwargs['write_only'] is True:
                        self.active_src.set_next_voltage(voltage=voltage, **kwargs)
                    else:
                        self.active_src.source_voltage(voltage, **kwargs)
            else:
                self.active_src.source_voltage(voltage, current_limit, **kwargs)
        else:
            return self.active_src.source_voltage()

    @property
    def active_src(self) -> Union[PSChannel_ABC, DacChannel, DacSupplyChannel]:
        """
        Function to set or use current active src of rail.

        :return: None
        :rtype: RailSource
        """
        return self._active_src.src

    @active_src.setter
    def active_src(self, src: str):
        # Check if src is in list of valid power sources
        if src not in self.sources:
            raise AttributeError(f'{src} is not a valid power source. Try from the following: {self.sources}')
        if is_no_op(self._active_src.src):
            self._active_src = self.sources[src]
            self.update_attr()
        else:
            # Check to make sure no other power sources are active
            if self._active_src.src.output_state() == 'OFF':
                self._active_src = self.sources[src]
                self.update_attr()
            else:
                raise EnvironmentError(f'ERROR: The current active_src \'{self._active_src.name}\' '
                                       f'is still active. Power off active source first.')
            self._active_src_handling(self._active_src)

        # Repopulate active source list
        self.__system_active_srcs__.clear()
        for rail in self.__system_active_rails__:
            self.__system_active_srcs__.append(rail._active_src.path)

    def output_state(self, on_off: Union[str, int, bool] = None, zero_volt_out: bool = None, restore: bool = False,
                     *args, **kwargs) -> str:
        """
        Sets rails source in 'ON' or 'OFF' state.

        :param on_off: 'ON', '1', 1, True to power on, 'OFF', '0', 0, Flase to power off
        :type on_off: str, int, bool
        :param zero_volt_out: Set to True for rail output to drive zero volts instead of HIGH-Z in 'OFF' state
        :type zero_volt_out: bool
        :param restore: When rail is set to "OFF" output state, it will save the voltage it was outputting before
            turning off. When turning the output state back to "ON" and having this parameter set to True will set the rail
            to the voltage the rail was at before turning off. This parameter is especially helpful when using zero_volt_out
            configuration on rails as this method changes the rail voltage to zero.
        :type restore: bool
        :return: Current output state
        :rtype: str
        """
        if is_no_op(self._active_src.src):
            return 'ON'
        # Check if zero_volt_out was set in yaml
        if zero_volt_out is None:
            zero_volt_out = self.zero_volt_out
        if on_off is not None:  # Set output state
            # Setup tracking to restore voltage if desired.
            if on_off in self._on_vals and restore:
                self._active_src.src.source_voltage(self._restore_voltage)
            elif on_off in self._off_vals:
                self._restore_voltage = self._active_src.src.source_voltage()['voltage']
            # Power Supply Channel
            if isinstance(self._active_src.src, PSChannel_ABC):
                if zero_volt_out and on_off in self._off_vals:  # Zero volt drive mode handling
                    self._active_src.src.source_voltage(0)
                    if self._active_src.src.power_supply.outputs_independent_on_off() is True:
                        self._active_src.src.output_state('ON')
                    else:
                        self.log.info(
                            f"Turning all channels of {self._active_src.src.power_supply.__class__.__name__} ON")
                        self._active_src.src.power_supply.output_state('ON')
                else:
                    if self._active_src.src.power_supply.outputs_independent_on_off() is True:
                        self._active_src.src.output_state(on_off)
                    else:
                        self.log.info(
                            f"Turning all channels of {self._active_src.src.power_supply.__class__.__name__} {on_off}")
                        self._active_src.src.power_supply.output_state(on_off)
            # Dac Channel
            else:
                self._active_src.src.output_state(on_off, zero_volt_out=zero_volt_out)
        else:  # Readback output state
            if zero_volt_out and isclose(0, self._active_src.src.source_voltage()['voltage'], abs_tol=0.01):  # Within 10mV of 0V
                return 'OFF'
            return self._active_src.src.output_state(on_off)

    def __estimate_power(self) -> float:
        """
        Function used if power source has no internal power function.

        Power source does need measure_voltage() and measure_current() methods to work.

        :return: Power measurement
        :rtype: float
        """
        if hasattr(self.active_src, 'measure_voltage'):
            if hasattr(self.active_src, 'measure_current'):
                self.log.warning(f'{self._active_src.name} does not support instantaneous power measurement. '
                                 f'This power measurement\n is the product of voltage and current measured '
                                 f'consecutively, not simultaneously.')
                return self.measure_voltage() * self.measure_current()
            else:
                raise AttributeError(f'{self._active_src.name} has no current measurement capability')
        else:
            raise AttributeError(f'{self._active_src.name}: {self._active_src.src.ref_name} '
                                 f'has no voltage measurement capability')

    def measure_all(self) -> Dict[str, Union[float, None]]:
        """
        Calls measure_voltage(), measure_current(), and measure_power() consecutively.

        The power measurement returned will rarely be exactly the product of the voltage
        and current values returned since measure_power() makes it own call either to
        an internal measure_power() method or from the product of a measure_voltage()
        and measure_current() it makes itself. So measure_power() should be close but
        not exactly the product of the returned voltage and current values.

        None will be returned if rail doesn't have the capability of measuring a value
        for voltage, current, or power.

        :return: dictionary of measurement values
        :rtype: Dict[str, Union[float, None]]
        """
        meas_vals = {}
        if hasattr(self, 'measure_voltage'):
            meas_vals['voltage'] = self.measure_voltage()
        else:
            meas_vals['voltage'] = None
        if hasattr(self, 'measure_current'):
            meas_vals['current'] = self.measure_current()
        else:
            meas_vals['current'] = None
        if hasattr(self, 'measure_power'):
            meas_vals['power'] = self.measure_power()
        else:
            meas_vals['power'] = None
        return meas_vals

    def _active_src_handling(self, src: RailSource):
        """
        Internal handling to ensure no rail is attempting to use the same source at the same time.

        :param src: Source currently being checked
        :type src: RailSource
        :return: None
        :rtype: None
        """
        # Checking if source is already used as active source in a different rail
        if src.path in self.__system_active_srcs__ and src.path != 'NO-OP':
            self.log.warning(f'{self.ref_name} {src.name} {src} is currently being used by another rail. This may'
                             f'\ncause rails to be configured incorrectly '
                             f'AND MAY DAMAGE THE INSTRUMENTATION OR BOARDS.')
        else:
            self.__system_active_srcs__.append(src.path)

    def __power_meas_handling(self):
        if hasattr(self, 'measure_voltage') and hasattr(self, 'measure_current'):
            self.estimate_power = self.__estimate_power
        else:
            if hasattr(self, 'estimate_power'):
                delattr(self, 'estimate_power')

    def generate_id(self, *args, **kwargs):
        # return super().generate_id(*args, **kwargs)
        return 0

    def gen_pyi(self, indent=0, top=False):
        pyi_str, imports = super().gen_pyi(indent=indent, top=top)
        if isinstance(self._active_src.src, PSChannel_ABC):
            src_cls = PSChannel_ABC
            pyi_str = re.sub('active_src?(.*)', 'active_src: PSChannel_ABC', pyi_str)
        else:
            src_cls = self._active_src.src.__class__
        pyi_str = re.sub('active_src?(.*)', f'active_src: {src_cls.__name__}', pyi_str)
        imports.add((src_cls.__module__, src_cls.__name__))
        pyi_contents = [pyi_str]
        return ''.join(pyi_contents), imports

def is_no_op(val):
    return val == NO_OP
