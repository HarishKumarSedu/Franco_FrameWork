import time
from enum import Enum, auto
from typing import Any, Dict, TYPE_CHECKING, Union

from cl_test_station.utilities.reusables import read_bool_value

if TYPE_CHECKING:
    from cl_test_station.components.component.component import Component
    from cl_test_station.register_map.block import Block
    from cl_test_station.register_map.register import Register


class ACCESS_TYPE(Enum):
    """Enumeration for old incomplete IPX access list"""
    RW = 0
    RO = 1
    WO = 2
    W1C = 3
    W1T = 4
    RC = 5
    WC = 6
    W1S = 7
    RM = 8


class ACCESS_PERMISSION(Enum):
    """Enumeration of basic read/write access permissions"""
    DNK = 0  # Do Not Know
    RO = 1
    WO = 2
    RW = 3

    def __or__(self, other):
        """Overriding bitwise or to help building up register's access from its contained fields"""
        return ACCESS_PERMISSION(int(self._value_) | int(other._value_))


class InternalAccessModes(Enum):
    IGNORE = auto()
    WARNING = auto()
    EXCEPTION = auto()


_PROTECTED_ATTRIBUTES = ['volatile', 'ipx_type', 'access', 'reset_value', 'bit_width', 'bit_offset', 'name',
                         'max_value', 'mask', 'internal']


class Field:
    """Class that represents a field within a register"""

    ACCESS_DECODING = dict(RW=ACCESS_PERMISSION.RW, W0C=ACCESS_PERMISSION.RW, W0CRS=ACCESS_PERMISSION.RW,
                           W0S=ACCESS_PERMISSION.RW, W0SRC=ACCESS_PERMISSION.RW, W0T=ACCESS_PERMISSION.RW,
                           W1=ACCESS_PERMISSION.RW, W1C=ACCESS_PERMISSION.RW, W1SRC=ACCESS_PERMISSION.RW,
                           W1S=ACCESS_PERMISSION.RW, W1T=ACCESS_PERMISSION.RW, WC=ACCESS_PERMISSION.RW,
                           WCRS=ACCESS_PERMISSION.RW, WMR=ACCESS_PERMISSION.RW, WRC=ACCESS_PERMISSION.RW,
                           WRM=ACCESS_PERMISSION.RW, WRS=ACCESS_PERMISSION.RW,  WS=ACCESS_PERMISSION.RW,
                           WSRC=ACCESS_PERMISSION.RW, RC=ACCESS_PERMISSION.RO, RM=ACCESS_PERMISSION.RO,
                           RO=ACCESS_PERMISSION.RO, RS=ACCESS_PERMISSION.RO, WO=ACCESS_PERMISSION.WO,
                           WO1=ACCESS_PERMISSION.WO, WOC=ACCESS_PERMISSION.WO, WOS=ACCESS_PERMISSION.WO)
    """IPX Access type to R/W permissions lookup dictionary"""
    # ToDo: add protection to this, if possible

    def __init__(self, name: str, bit_offset: int, bit_width: int, access_type: ACCESS_PERMISSION, reset_value: int,
                 description: str, container: object, volatile: bool, ipx_type: str, attributes: Dict[str, Any] = None,
                 internal: bool = None):
        """
        Field constructor

        :param name: Name of the field
        :type name: str
        :param bit_offset: Offset in the register
        :type bit_offset: int
        :param bit_width: Width of the field
        :type bit_width: int
        :param access_type: Ipx access type
        :type access_type: ACCESS_PERMISSION
        :param reset_value: Reset value of the field
        :type reset_value: int
        :param description: Field description
        :type description: str
        :param container: Register that the field is contained in
        :type container: Register
        :param volatile: Indicator for if the field is volatile
        :type volatile: bool
        :param ipx_type: String representation of IPX access type
        :type ipx_type: str
        :param attributes: Optional, dictionary of attributes from reg map
        :type attributes: Dict[str, Any]
        """
        self.name = name
        self.bit_offset = bit_offset
        self.bit_width = bit_width
        self.access = access_type
        self.reset_value = reset_value
        # Use container to get parent references
        self.container: Register = container  # Register
        self.block: Block = self.container.container  # Block -> Register
        self.component: Component = self.block.container  # Component -> Block -> Register
        self.encoded_vec = None
        self.raw_full_name = ''
        self.full_name = ''
        self.__cache_value = None
        self.__description = description
        self.volatile = volatile
        self.ipx_type = ipx_type
        if attributes is None:  # Default to an empty dictionary
            attributes = {}
        self.attributes = attributes
        if internal is not None:
            self.internal = internal
        else:
            self.internal = read_bool_value(self.attributes.get("internal", False))

        # Create the mask to use for read and write
        # First create a binary string representation of mask
        mask_bin = ''.join(['1'] * self.bit_width)
        # Convert to int and then shift over by bit_offset
        self.mask = int(mask_bin, 2) << self.bit_offset
        self.bit_pos = {}
        self.max_value = 2 ** self.bit_width - 1
        # Set constructed
        self.__constructed = True

    def __setattr__(self, key, value):
        # Attribute protection
        # NOTE: Cannot blindly get attribute in this method, as getting 'value' will perform a read operation
        if hasattr(self, '_Field__constructed') and self.__constructed:
            if key in _PROTECTED_ATTRIBUTES and hasattr(self, key):
                self.container.container.log.error("Cannot assign value to field internal '%s'" % key)
                return
        object.__setattr__(self, key, value)

    @property
    def readable(self):
        return self.access in [ACCESS_PERMISSION['RO'], ACCESS_PERMISSION['RW']]

    @property
    def writeable(self):
        return self.access in [ACCESS_PERMISSION['WO'], ACCESS_PERMISSION['RW']]

    def serialize(self, compress=True):
        if compress:
            order = [self.bit_offset, self.bit_width, self.access.name, self.reset_value, int(self.volatile),
                          self.ipx_type]
            return {'_f': order}
        else:
            return {
                'bit_offset': self.bit_offset,
                'bit_width': self.bit_width,
                'access_type': self.access.name,
                'reset_value': self.reset_value,
                'volatile': self.volatile,
                'ipx_type': self.ipx_type
            }

    def gen_pyi(self, indent: int = 0) -> str:
        """
        Generates class definition of dynamic field for .pyi files

        :param indent: Current .pyi indent level
        :type indent: int
        :return: Python stub contents
        :rtype: str
        """
        pyi_contents = ['    ' * (indent + 1), 'class ', self.name, '(', self.__class__.__name__, '): pass\n']
        return ''.join(pyi_contents)

    @property
    def path(self) -> str:
        """
        Returns attribute path: BLOCK.REGISTER.FIELD

        :return: Path to field from component
        :rtype: str
        """
        return f"{self.container.container.name}.{self.container.name}.{self.name}"

    @property
    def value_call(self):
        """
        Returns the fully qualified field reference. Should return <block>.<register>.<field>.value

        :return: str
        """
        return '%s.%s.%s.value' % (self.container.container.name, self.container.name, self.name)

    @value_call.setter
    def value_call(self):
        """
        Cannot be set

        :return:
        """
        pass

    @property
    def description(self):
        """Returns the objects description"""
        return self.__description

    @description.setter
    def description(self, value):
        """
        Cannot be set

        :return:
        """
        raise AttributeError('The description attribute is not writeable.')

    def print_description(self):
        print(self.description)

    @property
    def cache_value(self):
        """
        Represents a cached value of the field value. Setting this property does not initiate any transaction. It should
        be used with write_cache method at the register level

        :return:
        """
        return self.__cache_value

    @cache_value.setter
    def cache_value(self, data):
        if not type(data) == int:
            raise TypeError('Expecting integer assignment value for cache_value')
        if data > self.max_value:
            raise ValueError("value is too large for the field")
        elif data < 0:
            raise ValueError("value is negative, it has to be >= 0")
        self.__cache_value = data

    def reset_cache(self):
        """Sets the cache value to None"""
        self.__cache_value = None


    @property
    def spans_multiple_regs(self) -> bool:
        """
        Returns whether or not this field instance spans multiple registers or not.

        :return: True if field spans multiple registers, False otherwise
        :rtype: bool
        """
        block = self.container.container
        return self.full_name in block.spanned_fields and len(block.spanned_fields[self.full_name]) > 1

    def __value_to_hex(self, value):
        num_chars = (self.bit_width-1>>2) + 1
        return '0x' + hex(value)[2:].zfill(num_chars)

    @property
    def value(self) -> int:
        """
        Returns field value from register read.

        :return: Field value
        :rtype: int
        """
        return self.__read_value()

    def __read_value(self, desc:str ='READ (Field)', **kwargs) -> int:
        """
        Calls Component.read_register() to get the entire register value, then calcluates and returns the field value.

        :param kwargs: Any additional keyword arguments will get passed into component.read_register()
        :return: Field value
        :rtype: int
        """
        register = self.container
        block = self.container.container
        component = self.container.container.container
        if self.internal:
            if self.component.internal_field_access is InternalAccessModes.WARNING:
                component.log.warning(f"Reading internal field {self.path}")
            elif self.component.internal_field_access is InternalAccessModes.EXCEPTION:
                raise PermissionError(f"Cannot read internal field {self.path} "
                                      f"({component.ref_name}.internal_field_access is set to EXCPETION)")
        if not self.readable:  # Log error and return None
            block.log.error('Cannot read field %s: Field not readable' % self.name)
            raise PermissionError('Attempting to access non-readable Field: %s' % self.name)

        if not self.spans_multiple_regs:  # Normal field read
            reg_value = component.read_register(register.addr, update_clive=component.full_clive_history,
                                                field_name=self.path, reg_name=register.path, desc=desc,
                                                field_offset=self.bit_offset, field_mask=self.mask,
                                                field_fmt=self.__value_to_hex, default_value=register.reset_val, **kwargs)
            self.__cached_reg_value = reg_value
            field_value = (reg_value & self.mask) >> self.bit_offset
        else:
            field_value = 0
            for reg, bit_mapping in block.spanned_fields[self.full_name].items():  # Block attr has registers and mappings
                reg_value = reg.value
                component.log.debug("Read %s from %s with mapping: %s"
                                    % (hex(reg_value).upper(), reg.name, str(bit_mapping)))
                for dest, source in bit_mapping.items():  # Iterate though register's bit mapping
                    field_value += ((reg_value >> source) & 0x1) << dest  # Map source bit from register into field

        # update CLIVE
        if component.server_present:
            test_station_obj = component.find_top_level()
            test_station_obj.clive_tcp_client.update_field_read(component.ref_name, self.raw_full_name, field_value)

        return field_value

    def poll(self, value:int, timeout_sec:float=60, log_all_transactions=True, error_on_fail:bool = True, poll_rest_sec:float=0, **kwargs) -> bool:
        """
        Poll field until value is reached or timeout occurs.

        :param value: Value to poll for
        :type value: int
        :param timeout_sec: length of time in seconds to poll for specified value
        :type timeout_sec: float
        :param log_all_transactions: True if desire to log every read transaction while polling. False to log only the summary transaction.
        :type log_all_transactions: bool
        :param error_on_fail: If true, raises a timeout exception if timeout occurs before value is reached
        :type error_on_fail: bool
        :param poll_rest_sec: Wait time in between poll reads. Defaults to 0 sec
        :type poll_rest_sec: float
        :param kwargs:
        :type kwargs:
        :return: Whether the value was reached
        :rtype: bool
        """
        start = time.time()
        timeout_reached=False
        transaction_exc = None
        ellapsed_time = 0
        try:
            register = self.container
            cached_log_en_setting = self.component.transaction_logging_enable
            if not log_all_transactions:
                self.component.transaction_logging_enable = False
            value_read = self.__read_value(desc='POLL (Field)')
            num_tries = 1
            while value_read!=value:
                time.sleep(poll_rest_sec)
                ellapsed_time = time.time()-start
                value_read = self.__read_value(desc='POLL (Field)')
                num_tries += 1
                if ellapsed_time >= timeout_sec:
                    timeout_reached=True
                    if error_on_fail:
                        raise TimeoutError(f"{self.name} did not reach poll value of {value} in {timeout_sec} sec.")
                    break

            self.component.transaction_logging_enable = cached_log_en_setting

        except Exception as e:
            transaction_exc = e

        notes = f'Poll value {value} reached in {"{:.3f}".format(ellapsed_time)} sec ({num_tries} tries)' if timeout_reached == False else \
            f'Poll value {value} was not reached in specified timeout duration of {timeout_sec} sec ({num_tries} tries)'
        self.component._Component__log_poll_transaction(register.addr, update_clive=self.component.full_clive_history,
                               field_name=self.path, reg_name=register.path, desc='POLL (Field)',
                               field_fmt=self.__value_to_hex, default_value=register.reset_val, field_value=value_read, reg_value=self.__cached_reg_value, notes=notes, transaction_exc=transaction_exc, **kwargs)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc
        return value_read==value

    @value.setter
    def value(self, value:int):
        self.__write_value(value)

    def __write_value(self, value: Union[int, bool], modify_desc: str = 'READ (Modify)', desc: str = 'WRITE (Field)',
                      skip_verify:bool=False, **kwargs):
        """
        Uses Component functions to perform a read-modify-write to set field's value to 'value'. If the component's
        verify_writes=True and skip_verify=False, a final verify read will take place to check the value was successfully
        written.

        :param value: New value of the field
        :type value: int|bool
        :param modify_desc: Description in the logs in the read modify row
        :type modify_desc: str
        :param desc: Description in the logs in the register write row
        :type desc: str
        :param skip_verify: When True, will skip the verify step regardless of the component's verify_writes flag value
        :type skip_verify: bool
        :param kwargs: Any additional keyword arguments will get passed into component.write_register()
        :return: None
        """
        # Container aliases
        register = self.container
        block = self.container.container
        component = self.container.container.container
        # Check typing of value
        if not isinstance(value, (int, bool)):
            raise ValueError(f'Invalid value for field: {self.name}. Needs to be of type int or bool. Current value is '
                             f'{value} and is of type {type(value)}.')
        # Cast bool to int
        value = int(value)
        if self.internal:
            if self.component.internal_field_access is InternalAccessModes.WARNING:
                component.log.warning(f"Writing to internal field {self.path}")
            elif self.component.internal_field_access is InternalAccessModes.EXCEPTION:
                raise PermissionError(f"Cannot write to internal field {self.path} "
                                      f"({component.ref_name}.internal_field_access is set to EXCPETION)")
        if not self.writeable:  # Log error and dont do transaction
            block.log.error('Cannot write %d to field %s: Field not writeable' % (value, self.name))
            raise PermissionError('Attempting to access non-writeable Field: %s' % self.name)
        if value > self.max_value:
            block.log.error("Field value %d is larger than maximum value %d" % (value, self.max_value))
            raise ValueError("value is too large for the field")
        elif value < 0:
            block.log.error("Given value %d is negative, it must be >= 0" % value)
            raise ValueError("value is negative, it must be >= 0")

        if not self.spans_multiple_regs:  # Field is contained in single register
            # if register.readable:  # Mask, or, write
            #     # Get raw register value
            #     reg_value = component.read_register(register.addr, update_clive=component.full_clive_history, desc=modify_desc,
            #                                         reg_name=register.path, field_name=self.path, field_offset=self.bit_offset,
            #                                         field_mask=self.mask, field_fmt=self.__value_to_hex, default_value=register.reset_val)
            #     # Force bits (For W1C, W0S, etc)
            #     if register.w1x_mask:
            #         block.log.debug("Applying mask for W1X Fields: %s" % bin(register.w1x_mask))
            #         reg_value &= ~register.w1x_mask
            #     if register.w0x_mask:
            #         block.log.debug("Applying mask for W0X Fields: %s" % bin(register.w0x_mask))
            #         reg_value |= register.w0x_mask
            #     # Set bits for field write
            #     masked_reg = reg_value & ~self.mask
            #     new_value = masked_reg | ((value << self.bit_offset) & self.mask)
            # else:  # WO register, raw write
            #     new_value = (value << self.bit_offset) & self.mask
            # component.write_register(register.addr, new_value, update_clive=component.full_clive_history, field_name=self.path,
            #                          reg_name=register.path, desc=desc, field_value=self.__value_to_hex(value), **kwargs)
            # # Write verification
            # if component.verify_writes and register.readable and not skip_verify:  # Verification
            #     register._verify_reg_write(new_value, field_name=self.path, field_offset=self.bit_offset,
            #                                field_mask=self.mask, field_fmt=self.__value_to_hex)
            component.write_field(register.addr, value, self.mask, register.readable, w1x_mask=register.w1x_mask,
                                  w0x_mask=register.w0x_mask, reg_name=register.path, field_name=self.path,
                                  field_offset=self.bit_offset,field_fmt=self.__value_to_hex, desc=desc,
                                  modify_desc=modify_desc, verify_mask=register.read_mask, skip_verify=skip_verify,
                                  default_value=register.reset_val, **kwargs)

            self.__cache_value = value
        else:  # Need to write multiple reigsters to write full field value
            for reg, bit_mapping in block.spanned_fields[self.full_name].items():  # Block attr has registers and mappings
                reg_value = 0  # Sum for register's new value
                for source, dest in bit_mapping.items():  # Iterate though register's bit mapping
                    reg_value += ((value >> source) & 0x1) << dest  # Map source bit from register into register
                component.log.debug("Writing %s to %s with mapping: %s" % (hex(reg_value).upper(), reg.name, str(bit_mapping)))
                reg.value = reg_value

        # update CLIVE
        if component.server_present:
            test_station_obj = component.find_top_level()
            test_station_obj.clive_tcp_client.update_field_write(component.ref_name, self.raw_full_name, value)

    def reset(self):
        self.value = self.reset_value

    def __str__(self):
        return self.__description

    def __len__(self):
        return self.bit_width
