import inspect
import json
import os
import re
import sys
import textwrap
import types
import xml.etree.ElementTree as xml
from copy import deepcopy
from typing import Any, Callable, Dict, List, TYPE_CHECKING, ValuesView

import yaml
from cl_test_station.register_map.register import Field
from cl_test_station.register_map.register import Register
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.utilities.cl_yaml_loader import yaml_load
from cl_test_station.utilities.reusables import alias, read_int_value, get_revision_file, get_attr_safe
from cl_test_station.utilities.ts_logging import TsLoggingAdapter, get_logger, add_file_handler, add_stream_handler
from cl_test_station.utilities.varilist import VariList, enumerate

if TYPE_CHECKING:
    from cl_test_station.components.component.component import Component


class RegisterAssignmentException(Exception):
    pass


def full_attribute_access(func: Callable) -> Callable:
    """
    Wrapper that allows a function to access protected attributes of the block (Registers)

    :param func: Function to wrap
    :type func: Callable
    :return: Wrapped function
    :rtype: Callable
    """
    def inner(self, *args, **kwargs):
        # Unlock block attributes
        setattr(self, '_Block__constructed', False)
        # Call function
        func(self, *args, **kwargs)
        # Lock attributes
        setattr(self, '_Block__constructed', True)
    return inner


class Block:
    """Represents a functional block of register objects in a component"""
    # todo: exp with removing base_addr and calculating based on registers
    __constructed = False

    def __init__(self, name: str, base_addr: int, container: object, logger=None, component=None, **kwargs):
        self.name = name
        self.base_addr = base_addr
        self.container = container
        # Set component reference (block could be in TsoContainer or Component)
        self.component: Component = component if component else self.container
        self.encoded_vec = None
        self.registers = {}
        self.spanned_fields = {}
        self.aliases = {}
        self._alias_yaml_dict = {}
        self.alias_base_name = None
        self.alias_path = None
        self.min_addr = None
        self.max_addr = None
        # Create tso specific logger if none is passed in
        self.log = TestStationObject.get_ts_logger(self, logger)
        # Set attribute for any kwarg that made it though constructor
        for name, value in kwargs.items():
            setattr(self, name, value)

    # TODO: PLATDEV-1080 remove this
    def configure(self, config: dict):
        """
        Deprecated configure function

        :param config: Config dictionary
        :type config: dict
        :return: None
        :rtype: None
        """
        pass

    # TODO: PLATDEV-1080 remove this
    def construct_objects(self):
        """
        Deprecated construction function.

        :return: None
        :rtype: None
        """
        pass

    def alias(self, rev_formatter: Callable = None):
        """
        Wrapper for alias function. Can only alias custom blocks.

        :param rev_formatter: Revision formatter function
        :type rev_formatter: Callable
        :return: None
        :rtype: None
        """
        # Can only alias custom blocks
        if self.__class__ is not Block:
            alias(self, self.component, rev_formatter)  # Now located in reusable

    def serialize(self, compress: bool = True) -> Dict[str, Any]:
        """
        Serializes instance, including all Register information

        :param compress: Flag that when True, reduces size of dictionary by shortening names and positionally placing
            arguments.
        :type compress: bool
        :return: Dictionary containing serialized representation for the block instance
        :rtype: Dict[str, Any]
        """
        block_dict = {
            'base_addr': self.base_addr,
            'registers': {},
        }
        if self._alias_yaml_dict is not None:
            block_dict['_alias_yaml_dict'] = self._alias_yaml_dict
        for reg in self.get_registers():
            block_dict['registers'][reg.name] = reg.serialize(compress=compress)
        return block_dict

    def get_ts_path(self) -> str:
        """
        Returns full path to this block, starting at the top level, eg. test_station.board.dc.dut_name.BLOCK_NAME

        :return: Period separated path to the block instance
        :rtype: str
        """
        return f"{self.container.get_ts_path()}.{self.name}"

    def parse_val_csv(self, csv_row: Dict[str, Any]):
        """
        Parses a row from the val_csv. It will check if the register already exists and create one if it doesnt. It will
        then call the parse_val_csv function in the register class to extract the field.

        :param csv_row: Dictionary from read csv row from a validation csv register map
        :type csv_row: Dict[str, Any]
        :return: None
        :rtype: None
        """
        reg_name = csv_row['REG NAME'].split('.')[1].upper().replace('[', '').replace(']', '')
        this_reg = None
        for register in self.get_registers():
            if reg_name == register.name:
                this_reg = register
                break
        else:  # Did not encounter name collision
            reg_addr = read_int_value(csv_row['REG ADDR'])
            reg_len = read_int_value(csv_row['REG LEN']) if 'REG LEN' in csv_row else None
            # Parse Regsister default value if present in CSV. Unknown bits (X's) will be interpreted as 0's
            if 'REG DEFAULT' in csv_row:
                reset_val = csv_row['REG DEFAULT'].lower()
                prefix = reset_val[:2]
                if prefix == "0x" or prefix == "0b":  # Replace X's with 0's
                    reset_val = f"{prefix}{reset_val[2:].replace('x', '0')}"
                reset_val = read_int_value(reset_val)
            # No reg default, pass None in to tell register to use field reset values
            else:
                reset_val = None
            # Create new register instance and assign it to this block instance
            new_reg = Register(name=reg_name, addr=reg_addr, reset_val=reset_val, container=self, length=reg_len)
            this_reg = new_reg
            setattr(self, reg_name, new_reg)
            self.registers[reg_name] = new_reg
        # Parse field within register
        this_reg.parse_val_csv(csv_row)

    def parse_svd_xml(self, xml_node):
        """
        Parses the contents inside the XML node passed in to extract the registers.
        It is assumed that the XML node is from the SVD register map XML file

        :param xml_node: [xml.etree.ElementTree.Element] registers XML node

        :return:
        """
        registers = xml_node.findall('register')
        for register in registers:
            # Extract the relevant information from the register
            reg_name = register.find('name').text.upper()
            reg_offset = int(register.find('addressOffset').text, 16)
            reg_addr = self.base_addr + reg_offset
            reg_rst_val = int(register.find('resetValue').text, 16)
            # Check if the %s exists in the name, indicating that this is an indexed register
            if '[%S]' in reg_name:
                # Indicates the number of generated registers
                dim = int(register.find('dim').text)
                # Indicates the increment of the address between each register
                dimIncrement = int(register.find('dimIncrement').text)
                # Indicates the explicitly indexes for each register
                dimIndexes = register.find('dimIndex').text.split(',')
                for index in dimIndexes:
                    new_reg_name = reg_name.replace('[%S]', index)
                    new_reg = Register(new_reg_name, reg_addr, reg_rst_val, self)
                    new_reg.parse_svd_xml(register.find('fields'), reg_rst_val)
                    setattr(self, new_reg.name.upper(), new_reg)
                    self.registers[new_reg.name.upper()] = new_reg
                    reg_addr += dimIncrement
            else:
                new_reg = Register(reg_name, reg_addr, reg_rst_val, self)
                new_reg.parse_svd_xml(register.find('fields'), reg_rst_val)
                setattr(self, new_reg.name.upper(), new_reg)
                self.registers[new_reg.name.upper()] = new_reg

        # Cluster is another type of method to define registers in the SVD
        clusters = xml_node.findall('cluster')
        for cluster in clusters:
            # Extract all of the cluster information
            cluster_name = cluster.find('name').text.upper()
            cluster_dim = cluster.find('dim').text
            cluster_dim_inc = int(cluster.find('dimIncrement').text)
            cluster_dim_indexes = cluster.find('dimIndex').text.split(',')
            cluster_base = int(cluster.find('addressOffset').text, 16)
            base = cluster_base

            for index in cluster_dim_indexes:
                name = cluster_name.replace('[%S]', index)

                # Now we loop through the register nodes inside the cluster
                registers = cluster.findall('register')
                for register in registers:
                    # Extract the relevant information from the register
                    reg_name = name + "_" + register.find('name').text.upper()
                    reg_offset = base + int(register.find('addressOffset').text, 16)
                    reg_addr = self.base_addr + reg_offset
                    reg_rst_val = int(register.find('resetValue').text, 16)
                    # Check if the %s exists in the name, indicating that this is an indexed register
                    if '[%S]' in reg_name:
                        # Indicates the number of generated registers
                        dim = int(register.find('dim').text)
                        # Indicates the increment of the address between each register
                        dimIncrement = int(register.find('dimIncrement').text)
                        # Indicates the explicitly indexes for each register
                        dimIndexes = register.find('dimIndex').text.split(',')
                        count = 0
                        for index in dimIndexes:
                            new_reg_name = reg_name.replace('[%S]', index)
                            reg_addr += count * dimIncrement
                            count += 1
                            new_reg = Register(new_reg_name, reg_addr, reg_rst_val, self)
                            new_reg.parse_svd_xml(register.find('fields'), reg_rst_val)
                            setattr(self, new_reg.name.upper(), new_reg)
                            self.registers[new_reg.name.upper()] = new_reg
                    else:
                        new_reg = Register(reg_name, reg_addr, reg_rst_val, self)
                        new_reg.parse_svd_xml(register.find('fields'), reg_rst_val)
                        setattr(self, new_reg.name.upper(), new_reg)
                        self.registers[new_reg.name.upper()] = new_reg

                base += cluster_dim_inc

    def parse_register_dict(self, reg_dict: Dict[str, Any]):
        """
        Deserializes register dictionary (compressed or uncompressed) and creates Register objects.

        :param reg_dict: Dictionary containing serialized register information
        :type reg_dict: Dict[str, Any]
        :return: None
        :rtype: None
        """
        for name, config in reg_dict.items():
            if '_r' in config:  # This is compressed, follow specific order
                addr, reset_val, length = config['_r']
            else:
                addr = config['addr']
                reset_val = config['reset_val']
                length = config['length']
            reg = Register(name, addr, reset_val, self, length)
            if 'fields' in config:
                reg.parse_field_dict(config['fields'])
            self.__setattr__(name, reg)
            self.registers[reg.name.upper()] = reg
        if isinstance(self, Block):
            self.alias()

    def post_construction(self):
        """
        Perform any operations that requires all registers within the block to be constructed

        :return: None
        :rtype: None
        """
        try:
            self.alias()  # Create alises
        except AttributeError:
            self.log.exception(f"Failed to create aliases for {self.name}")
        self.parse_spanned_fields()  # Find any fields that span multiple registers
        if self.get_registers():  # Calculate min and max address from registers
            addresses = [r.addr for r in self.get_registers()]
            self.min_addr = min(addresses)
            self.max_addr = max(addresses)

    def set_all_constructed(self, value: bool):
        """
        Sets instance constructed state to value, enabling attribute protection. Also sets all registers objects state
        to value.

        :param value: Value to set, either True or False
        :type value: bool
        :return: None
        :rtype: None
        """
        self.__constructed = value
        for reg in self.get_registers():
            reg.set_fields_constructed(True)

    def parse_spanned_fields(self):
        """
        Iterates through all fields and finds ones that span multiple registers. Creates spanned fields dictionary that
        maps the field name with its bitpos dictionary.

        :return: None
        :rtype: None
        """
        temp_dict = {}  # {Field name: {Register: bit_pos}}
        for reg in self.get_registers():
            for field_name, bit_pos in [(f.full_name, f.bit_pos) for f in reg.get_fields() if hasattr(f, 'bit_pos')]:
                if field_name in temp_dict.keys():  # update entry
                    temp_dict[field_name].update({reg: bit_pos})
                else:  # create new entry
                    temp_dict[field_name] = {reg: bit_pos}
        for field_name, bitpos_dict in temp_dict.items():
            if len(bitpos_dict) > 1:  # Pop this entry
                self.spanned_fields[field_name] = bitpos_dict

    def get_fields(self) -> List[Field]:
        """Gets the fields from registers.

        :return:  Fields in list format.
        :rtype: List[Field]
        """
        fields = []
        for reg in self.get_registers():
            for field in reg.get_fields():
                fields.append(field)
        return fields

    def get_fields_dict(self):
        """
        Gets fields and the field name from registers.

        :return: Fields and fields name in dictionary format.
        """
        fields = {}
        for reg in self.get_registers():
            for field in reg.get_fields():
                fields[field.name] = field
        return fields

    def get_registers(self) -> ValuesView[Register]:
        """
        Returns an iterable containing all register objects contained within the block.

        :return: Dict Values of Register objects
        :rtype: ValuesView[Register]
        """
        return self.registers.values()

    def dump_registers(self):
        """
        Prints out all registers and their values. Performs a read transaction for each register contained in the block.

        :return: None
        :rtype: None
        """
        self.log.info('Dumping %s registers' % self.name)
        for reg in [reg for reg in self.get_registers() if reg.readable]:
           self.log.print('%s: %s' % (reg.name, hex(reg.value)))

    def __setattr__(self, key, value):
        # Attribute protection
        if hasattr(self, '_Block__constructed') and self.__constructed and hasattr(self, key):
            # Check if this attribute is a register or aliased field
            obj = getattr(self, key)
            if isinstance(obj, (Block, Register, Field)) or key in self.aliases:
                self.log.error(f"Cannot set protected {obj.__class__.__name__} {key} to {value}")
                return
        return object.__setattr__(self, key, value)

    def __getattr__(self, item):
        if ((item not in self.__dict__) and (self.component.reg_match_enable_flag) and (item.isupper())):
            # The requested register does not exist within the specified block in the new reg map. Try to repair...
            # Get the index of the block name in the new column of the diff file
            # This will be the index at which we start our search for the register name in the old column
            # Otherwise, we risk grabbing a register with the same name that belongs to a different block
            # Search the old column starting at the start index for the broken reg name
            # Then grab that same index from reg name in the new column
            # Return the new reg name
            start_index = self.component.new_blocks.index(self.name)  # scope the reg search to start within the current block
            repaired_name = self.component.new_regs[self.component.old_regs.index(item,start_index)]
            self.log.warning('REG: %s does not exist. Using %s instead.' % (item, repaired_name))  # warn the user
            new_register = self.__getattribute__(repaired_name)
            self.component.old_reg_name = item  # store this for use in block and register auto repair
            self.component.new_reg_name = repaired_name  # store this for use in block and register auto repair
            return new_register
        return self.__getattribute__(item)

    def gen_pyi(self, indent=0):
        """
        Generates pyi stub info for Block. Adds relative import if Block is custom class.

        :param indent: current nest level
        :return: String containing stub information for all registers
        """
        tab = ' '*4
        primatives = [int,bool,float,dict,set,list,str,bytes, type(None)]
        imports = set({(Register.__module__, Register.__name__),
                       (Field.__module__, Field.__name__)})
        parent = self.__class__.__bases__[0]
        imports.add((parent.__module__, parent.__name__))
        imports.add((self.container.__class__.__module__, self.container.__class__.__name__))
        pyi_contents = []
        if self.__class__ is not Block:  # Generate custom stub file for block
            pyi_contents.append('class %s(%s):\n' % (self.__class__.__name__, parent.__name__))
            base_dir = dir(Block)
            # Get all attributes of this block that are unique to it
            block_dir = [d for d in dir(self) if d not in base_dir and not d.startswith('_') and not isinstance(get_attr_safe(self, d), (Register, Field))]
            block_func = [f for f in block_dir if inspect.isfunction(get_attr_safe(self, f))]
            block_aliases = [a for a in dir(self) if a in self.aliases]
            # Parse normal attributes
            for attr_name, attr in [(a, get_attr_safe(self, a)) for a in block_dir if a not in block_func and a not in self.aliases.keys()]:
                if attr is None:
                    pyi_contents.extend([tab, attr_name, '=', 'None\n'])
                    continue
                # todo: VALTECH-561 hotfix - This whole function is messy and needs a rework
                if type(attr) is property:
                    ftype = inspect.signature(attr.fget).return_annotation
                    if ftype in primatives:
                        ftype = ftype.__name__
                    elif ftype is inspect._empty:
                        ftype = 'None'
                    else:
                        imports.add((ftype.__class__.__module__, ftype.__class__.__name__))
                        ftype = ftype.__class__.__name__
                    type_str = ':' + ftype
                else:
                    type_str = ':'+type(attr).__name__ if type(attr) in primatives else ''  # Primative type
                if hasattr(attr, '__module__'):  # Type that we can import
                    type_str = ':'+attr.__class__.__name__
                    imports.add((attr.__class__.__module__, attr.__class__.__name__))
                pyi_contents.extend([tab, attr_name, type_str, '\n'])
            # Parse functions and write signature to string
            for func_name, func in [(f, get_attr_safe(self, f)) for f in block_func]:
                # sig = inspect.signature(func)
                # pyi_contents.extend([tab, 'def ', func_name, str(sig), ': pass\n'])
                func_src = inspect.getsource(func)  # Get function source code
                for comment in re.findall('(\#(.*?))\n', func_src):  # Remove all comments from header lines
                    func_src = func_src.replace(comment[0], '')
                sig_str = re.search(r'((.|\n)+?):\s*\n', func_src).group().rstrip()
                sig_str += 'pass\n'
                sig_str = textwrap.dedent(sig_str)  # Removes higest indentation while maintaining structure
                sig = inspect.signature(func)
                for param_name, param in sig.parameters.items():  # Find any enums/special defaults that need to be imported
                    if param.annotation not in [inspect._empty, None] and param.annotation.__class__.__name__ not in types.__builtins__:
                        imports.add((param.annotation.__module__, param.annotation.__class__.__name__))
                    if param.default not in [inspect._empty, None] and param.default.__class__.__name__ not in types.__builtins__:
                        imports.add((param.default.__module__, param.default.__class__.__name__))
                pyi_contents.extend([tab, sig_str])
            # Parse registers
            for reg in self.get_registers():
                pyi_contents.append(reg.gen_pyi(indent=0))
            # parse aliases after registers so that we can subclass to get field auto-complete
            for key, value in self.aliases.items():
                if isinstance(value, list):  # list or VariList
                    start_index = value.start_index if type(value) is VariList else 0
                    imports.add(('typing', 'List'))
                    ltype = type(value[start_index]).__name__  # Type of value in list
                    if ltype == 'dict':
                        imports.add(('typing', 'Dict'))
                        key_type = type(list(value[start_index].keys())[0]).__name__  # Type of key
                        val_type = type(value[start_index][list(value[start_index].keys())[0]]).__name__  # Type of value
                        ltype = 'Dict[' + key_type + ',' + val_type + ']'
                    line = [tab, key, ':List[', ltype, ']']
                elif type(value) is dict:
                    imports.add(('typing', 'Dict'))
                    key_type = type(list(value.keys())[0]).__name__  # Type of key
                    val_type = type(value[list(value.keys())[0]]).__name__  # Type of value
                    line = [tab, key, ':Dict[', key_type, ',', val_type, ']']
                elif type(value) is Register:
                    line = [tab, key, '=', self.container.__class__.__name__, '.', value.path]
                elif type(value) is Field:
                    line = [tab, key, '=', self.container.__class__.__name__, '.', value.path]
                elif isinstance(value, Block):
                    imports.add((value.__class__.__module__, value.__class__.__name__))
                    line = [tab, key, ':', value.__class__.__name__]
                else:  # Unsupported type
                    self.log.warning("Unsupported type for PYI generation: %s" % type(value))
                pyi_contents.extend(line)
                pyi_contents.append('\n')

            for mod, cls in sorted(imports):
                pyi_contents = ['from %s import %s\n' % (mod, cls)] + pyi_contents
            # pyi_fpath = os.path.dirname(inspect.getfile(self.__class__))
            # pyi_fname = os.path.basename(inspect.getfile(self.__class__)) + 'i'
            # with open(os.path.join(pyi_fpath, pyi_fname), 'w', encoding='utf-8') as f:
            #     f.write(''.join(pyi_contents))
            self.ref_name = self.name
            TestStationObject.update_pyi_file(self, ''.join(pyi_contents))
            del self.ref_name
            pyi_contents = [tab*indent, self.name, ':', self.__class__.__name__, '\n']
        else:
            pyi_contents = [tab*indent, 'class ', self.name, '(', self.__class__.__name__, '):\n']
            for reg in self.get_registers():
                pyi_contents.append(reg.gen_pyi(indent=indent+1))
            pyi_contents.extend([tab*indent, self.name, ':', self.name, '\n'])
        return ''.join(pyi_contents)


if __name__ == "__main__":
    my_block = Block('test', 0x10000, None)
