import re
import time
import yaml
from typing import Any, Dict, Union, ValuesView

# TODO: Project specific ST code
#  -----------------------------
import re
from collections import namedtuple
# TODO --------------------------

from cl_test_station.register_map.field import ACCESS_PERMISSION, Field
from cl_test_station.utilities.reusables import read_int_value
from cl_test_station.utilities.reusables import read_bool_value


try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


_PROTECTED_ATTRIBUTES = ['volatile', 'access', 'addr', 'name', 'full_name']


class Register:
    """Class that resprents a physical register in a component"""

    def __init__(self, name: str, addr: int, reset_val: int, container: object, length: int = None):
        """
        Constructs the register object

        :param name: Name of the register
        :type name: str
        :param addr: Full address of the register
        :type addr: int
        :param reset_val: Reset value of the register
        :type reset_val: int
        :param container: Block class this register is contained within
        :type container: Block
        :param length: Bit width or register
        :type length: int
        """
        self.__constructed = False
        self.name = name
        self.addr = addr
        # If no reset value is passed in, all nested field reset values will be concatenated
        self.reset_val = reset_val if reset_val is not None else 0
        self._concat_field_defaults = reset_val is None
        self.container = container
        self.length = length
        self.encoded_vec = None
        self.fields = {}
        self.full_name = container.name+'.'+name
        self.component = self.container.container  # Registers must belong to a block as of now.
        self.volatile = False
        self.access = ACCESS_PERMISSION['DNK']
        # TODO: Project specific ST code
        #  -----------------------------
        self.num_fmt = None
        # TODO --------------------------
        self.w1x_mask = 0   # Used to clear bits (& ~mask)
        self.w0x_mask = 0   # Used to set bits (| mask)
        self.read_mask = 0  # Used to mask off volatile, WO, and undefined bits (& ~read_mask)

    @property
    def readable(self):
        if self.access is ACCESS_PERMISSION['DNK']:
            self.container.log.warning("%s access permission is unknown, continuing" % self.name)
            return True
        return self.access in [ACCESS_PERMISSION['RO'], ACCESS_PERMISSION['RW']]

    @property
    def writeable(self):
        if self.access is ACCESS_PERMISSION['DNK']:
            self.container.log.warning("%s access permission is unknown, continuing" % self.name)
            return True
        return self.access in [ACCESS_PERMISSION['WO'], ACCESS_PERMISSION['RW']]

    def parse_val_csv(self, csv_row):
        """
        Parses a row from the val_csv. It will check if the field already exists and create one if it does not.

        :param csv_row: [dict] represents a csv row from the validation csv register map file
        :return:
        """
        # The field name is in the FIELD NAME column. The value of the cell is <reg name>.<field name>
        field_name_split = csv_row['FIELD NAME'].split('.')
        field_name = field_name_split[len(field_name_split) - 1].upper().replace('[', '').replace(']', '')
        if field_name not in self.__dict__:
            raw_full_name = csv_row['FIELD NAME']
            full_name = raw_full_name.upper().replace('[', '').replace(']', '')
            field_ipx = csv_row['ACCESS'].upper()
            field_access_enum = Field.ACCESS_DECODING[field_ipx]
            if 'DEFAULT' in csv_row:
                reset_val = csv_row['DEFAULT'].lower()
                prefix = reset_val[:2]
                if prefix == "0x" or prefix == "0b":  # Replace X's with 0's
                    reset_val = f"{prefix}{reset_val[2:].replace('x', '0')}"
                field_reset_val = read_int_value(reset_val)
            else:
                reset_val = None
            field_description = csv_row['DESCRIPTION']
            field_internal = csv_row.get('INTERNAL', None)
            if field_internal is not None:
                field_internal = read_bool_value(field_internal)
            # determine location within register
            # Find the offset in the BIT LOCATION cell. Individual bit information is split by ',' and then the bit
            # position in the register is split by ':'
            field_offset = int(csv_row['BIT LOCATION'].split(',')[0].split(':')[1])
            field_width = int(csv_row['FIELD LEN'])
            bit_list = csv_row['BIT LOCATION'].split(',')
            bit_pos = {}
            for bit in bit_list:
                bit_split = str(bit).split(':')
                bit_pos[int(bit_split[0])] = int(bit_split[1])
            # Check VOLATILE column is present. If not, assume not volatile
            if csv_row['VOLATILE']:
                field_volatile = read_bool_value(csv_row['VOLATILE'])
            else:
                field_volatile = False
            # Attributes column
            field_attributes = {}
            if 'ATTRIBUTES' in csv_row:
                for key, value in re.findall(r'(\w+)\s*:\s*(\w+)', csv_row['ATTRIBUTES']):
                    field_attributes[key] = value
            # built new field
            new_field = Field(field_name, field_offset, field_width, field_access_enum, field_reset_val,
                              field_description, self, field_volatile, field_ipx,
                              attributes=field_attributes, internal=field_internal)
            new_field.bit_pos = bit_pos
            new_field.full_name = full_name
            new_field.raw_full_name = raw_full_name
            # TODO: Project specific ST code
            #  -----------------------------
            deci_bits, total_bits = None, None
            if 'ALWAYS_ON_RAM' in full_name and 'NUMBER FORMAT' in csv_row:
                num_fmt_fields = namedtuple('num_fmt_fields', ['TOTAL_BITS', 'DECIMAL_BITS'])
                num_fmt = csv_row['NUMBER FORMAT']
                # Search for Number format in register description if it is not found then read from CSV
                number_fmt = re.search(r' (\w+?-*?(\d+)\.(\d+))', field_description)
                if number_fmt:
                    number_fmt = number_fmt.groups()
                else:
                    number_fmt = re.search(r'(\w+?-*?(\d+).(\d+))', num_fmt).groups()
                deci_bits, total_bits = int(number_fmt[2]), int(number_fmt[1]) + int(number_fmt[2])
                if number_fmt[0].startswith('s'):
                    total_bits += 1
                number_fmt_fields = num_fmt_fields(total_bits, deci_bits)
                self.num_fmt = number_fmt_fields
            # TODO --------------------------
            setattr(self, field_name, new_field)
            self.fields[field_name] = new_field
            # compute register values off new register
            self.volatile |= field_volatile
            self.access |= field_access_enum
            self.update_masks(field_volatile, field_ipx, new_field.max_value << field_offset)
            if self._concat_field_defaults:
                self.reset_val |= new_field.reset_value << new_field.bit_offset

    def parse_wisce_xml(self, xml_node):
        """
        Parses the contents inside the XML node passed in to extract the fields.
        It is assumed that the XML node is from the WISCE register map XML file

        :param xml_node: [xml.etree.ElementTree.Element] fields XML node
        :return:
        """
        wisce_access = {'ReadWrite': 'RW',
                        'Read': 'RO',
                        'Write': 'WO',
                        'writeOnce': 'W1C',
                        'read-writeOnce': 'W1T'
                        }

        field_nodes = xml_node.findall('BitField')

        for field_node in field_nodes:
            field_name = field_node.find('Name').text.upper()
            field_reset_val = int(field_node.find('Default').text.lower().replace('x', ''), 16)
            field_width = int(field_node.get("width"))
            field_offset = int(field_node.get("top")) + 1 - field_width
            field_access = ''
            for access_type in field_node.find("Access").getchildren():
                field_access += access_type.tag
            field_ipxtype = wisce_access.get(field_access, 'RW')
            field_access_enum = Field.ACCESS_DECODING[field_ipxtype]

            # Create field
            field_description = ''
            # todo: Can this param be pulled in from wisce?
            field_volatile = False
            new_field = Field(field_name, field_offset, field_width, field_access_enum,
                              field_reset_val, field_description, self, field_volatile, field_ipxtype)
            new_field.full_name = self.full_name + '.' + field_name
            # Create attribute
            setattr(self, field_name.upper(), new_field)
            self.fields[field_name.upper()] = new_field
            self.access |= field_access_enum
            self.volatile |= field_volatile
            self.update_masks(field_volatile, field_ipxtype, new_field.max_value << field_offset)

    def parse_svd_xml(self, xml_node, reg_rst_value):
        """
        Parses the contents inside the XML node passed in to extract the fields.
        It is assumed that the XML node is from the SVD register map XML file

        :param xml_node: [xml.etree.ElementTree.Element] fields XML node
        :return:
        """
        svd_access = {'read-write': 'RW',
                      'read-only': 'RO',
                      'write-only': 'WO',
                      'writeOnce': 'W1C',
                      'read-writeOnce': 'W1T'
                      }

        field_nodes = xml_node.findall('field')

        for field_node in field_nodes:
            field_name = field_node.find('name').text
            field_offset = int(field_node.find('bitOffset').text)
            field_width = int(field_node.find('bitWidth').text)
            field_access = field_node.find('access').text
            # Convert the access type to the enum
            field_ipxtype = svd_access[field_access]
            field_access_enum = Field.ACCESS_DECODING[field_ipxtype]

            if '[%S]' in field_name:
                # Indicates the number of generated field_nodes
                dim = int(field_node.find('dim').text)
                # Indicates the increment of the address between each field_node
                dim_increment = int(field_node.find('dimIncrement').text)
                # Indicates the explicitly indexes for each field_node
                dim_indexes = field_node.find('dimIndex').text.split(',')
                count = 0
                for index in dim_indexes:
                    field_name = field_name.replace('[%S]', index)
                    field_offset += count * dim_increment
                    count += 1
                    # Get field reset value form register reset value
                    field_reset_val = Register.__get_field_rst_val(reg_rst_value, field_offset, field_width)
                    field_description = ''
                    # todo: Can these params be pulled in from wisce?
                    field_volatile = False
                    # Create field
                    new_field = Field(field_name, field_offset, field_width, field_access_enum,
                                      field_reset_val, field_description, self, field_volatile, field_ipxtype)
                    new_field.full_name = "%s.%s.%s" % (self.container.name, self.name, new_field.name)
                    # Create attribute
                    setattr(self, field_name.upper(), new_field)
                    self.fields[field_name.upper()] = new_field
                    self.access |= field_access_enum
                    self.volatile |= field_volatile
                    self.update_masks(field_volatile, field_ipxtype, new_field.max_value << field_offset)
            else:
                # Figure out reset value from the register reset value
                field_reset_val = Register.__get_field_rst_val(reg_rst_value, field_offset, field_width)
                field_description = ''
                # todo: Can this param be pulled in from wisce?
                field_volatile = False
                # Create field
                new_field = Field(field_name, field_offset, field_width, field_access_enum,
                                  field_reset_val, field_description, self, field_volatile, field_ipxtype)
                new_field.full_name = "%s.%s.%s" % (self.container.name, self.name, new_field.name)
                # Create attribute
                setattr(self, field_name.upper(), new_field)
                self.fields[field_name.upper()] = new_field
                self.access |= field_access_enum
                self.volatile |= field_volatile
                self.update_masks(field_volatile, field_ipxtype, new_field.max_value << field_offset)

    def parse_field_dict(self, field_dict: Dict[str, Dict[str, Any]]):
        """
        Deserializes field dictionary (compressed or uncompressed) and creates Field objects.

        :param field_dict: Dictionary containing serialized field data. Format is either:
            * Compressed: {field_name: {'_f': [bit_offset, bit_width, access_type, reset_value, volatile, ipx_type]}}
            * Uncompressed: {field_name: {'bit_offset': bit_offset, 'bit_width': bit_width, ... , 'ipx_type': ipx_type}}
        :type field_dict: Dict[str, Dict[str, Any]]
        :return: None
        :rtype: None
        """
        for name, config in field_dict.items():
            if '_f' in config:  # This is compressed, pull out values from list
                bit_offset, bit_width, access_type, reset_value, volatile, ipx_type = config['_f']
                volatile = bool(volatile)
                field_access_enum = Field.ACCESS_DECODING[access_type]
            else:
                bit_offset = config['bit_offset']
                bit_width = config['bit_width']
                access_type = config['access_type']
                reset_value = config['reset_value']
                volatile = config['volatile'] if 'volatile' in config else False
                field_access_enum = Field.ACCESS_DECODING[config['access_type']]
                ipx_type = config['ipx_type'] if 'ipx_type' in config else field_access_enum.name

            field = Field(name, bit_offset, bit_width, field_access_enum, reset_value, "", self, volatile, ipx_type)
            self.__setattr__(name, field)
            field.full_name = "%s.%s.%s" % (self.container.name, self.name, field.name)
            self.fields[field.name.upper()] = field
            # compute register values off new field
            self.volatile |= volatile
            self.access |= field_access_enum
            self.update_masks(volatile, ipx_type, field.max_value << bit_offset)

    def update_masks(self, field_volatile, field_ipx, bit_mask):
        """
        Sets bits in bit_mask in certain mask attributes depending on ipx type and volatile paramters.

        :param field_volatile: [bool] flag for if the field is volatile
        :param field_ipx: [str] Name of ipx access type
        :param bit_mask: [int] 1's for each bit in the field
        :return: None
        """
        if not field_volatile and 'R' in field_ipx:  # Add readable, non-volatile fields to the read mask for verifying
            self.read_mask |= bit_mask
        if field_ipx != 'W1' and field_ipx.startswith('W1'):  # Add 1's to w1x
            self.w1x_mask |= bit_mask
        elif field_ipx.startswith('W0'):  # Add 1's to w0x
            self.w0x_mask |= bit_mask

    def clear_fields(self, field_list):
        """
        Sets the list of fields in the field_list input parameter to 1 with one register write

        :param field_list: [list] list of field names
        :return:
        """
        mask = 0xFFFFFFFF
        for field_name in field_list:
            field_sel = self.__getattribute__(field_name)
            field_mask = int(''.join(['1'] * field_sel.bit_width), 2)
            mask &= ~(field_mask << field_sel.bit_offset)
        self.value = self.value & mask

    def __get_field_rst_val(self, reg_rst_val: int, bit_offset: int, bit_width: int) -> int:
        """
        Internal function that uses field position attributes to get reset val from register reset val

        :param reg_rst_val: Register reset value
        :type reg_rst_val: int
        :param bit_offset: Field bit offset
        :type bit_offset: int
        :param bit_width: Field bit width
        :type bit_width: int
        :return: Field reset value
        :rtype: int
        """
        rst_val_shifted = reg_rst_val >> bit_offset
        bit_mask = int(''.join(['1'] * bit_width), 2)
        return rst_val_shifted & bit_mask

    def set_fields_constructed(self, value: bool):
        """
        Setter for __constructed flag. Enables attribute protection in __setattr__

        :param value: New flag value
        :type value: bool
        :return: None
        :rtype: None
        """
        self.__constructed = value

    def dump_fields(self, return_output: bool = False) -> Union[str, None]:
        """
        Prints Field values to console in format:

        FIELD1: value

        FIELD2: value

        ...

        :param return_output: When True, returns output string instead of printing to console
        :type return_output: bool
        :return: Either nothing (Print to console), or returns string output
        :rtype: None | str
        """
        output = ''
        field_values = self.get_field_values()
        for field_name, field_value in field_values.items():
            output += '%s: %s \n' % (field_name, hex(field_value))
        if return_output:
            return output
        else:
            print(output)

    def get_field_values(self) -> Dict[str, int]:
        """
        Get all field values in a dictionary with one register read

        :return: Dictionary where key is field name and value is field value read
        :rtype: Dict[str, int]
        """
        field_values = {}
        reg_value = self.value
        for field in self.get_fields():
            # mask is the number of 1s based on the field width
            # Left shift by bit offset to position the mast in the right place
            mask = int(''.join(['1'] * field.bit_width), 2) << field.bit_offset
            # And mask with register value and right shift back by offset
            field_value = (reg_value & mask) >> field.bit_offset
            field_values[field.name] = field_value
        return field_values

    def get_fields(self) -> ValuesView[Field]:
        """
        Returns field objects

        :return: Field objects iterable
        :rtype: ValuesView[Field]
        """
        return self.fields.values()

    def serialize(self, compress=True):
        """
        Serializes register to dictionary containing needed fields and attributes

        :return: dictionary
        """
        if compress:
            order = [self.addr, self.reset_val]
            reg_dict = {'_r': [self.addr, self.reset_val, self.length], 'fields': {}}
        else:
            reg_dict = {
                'addr': self.addr,
                'reset_val': self.reset_val,
                'length': self.length,
                'fields': {},
            }
        for field in self.get_fields():
            reg_dict['fields'][field.name] = field.serialize(compress=compress)
        return reg_dict

    def deserialize(self):
        """
        Placeholder for deserializing Fields.

        :return: None
        :rtype: None
        """
        # TODO: PLATDEV-1080 remove this?
        pass

    def __getattr__(self, item):
        if item not in self.__dict__ and object.__getattribute__(self, 'component').reg_match_enable_flag and item.isupper():
            # Block name and field name repaired, but not reg name
            if self.component.old_reg_name == self.component.new_reg_name and self.component.old_block_name != self.component.new_block_name:
                # find the first row in the old column that contained the old reg name
                old_reg = self.name
                start = self.component.old_regs.index(old_reg)
                field_index = self.component.old_fields.index(item, start)
                new_field_name = self.component.new_fields[field_index]
                new_reg_name = self.component.new_regs[field_index]
                new_block_name = self.component.new_blocks[field_index]
            # Reg name and field name repaired, but not block name
            elif self.component.old_reg_name != self.component.new_reg_name and self.component.old_block_name == self.component.new_block_name:
                # find the first row in the old column that contained the old reg name
                old_reg = self.component.old_reg_name
                start = self.component.old_regs.index(old_reg)
                field_index = self.component.old_fields.index(item, start)
                new_field_name = self.component.new_fields[field_index]
                new_reg_name = self.component.new_regs[field_index]
                new_block_name = self.container.name
            # Block name field name, and reg name repaired
            elif self.component.old_reg_name != self.component.new_reg_name and self.component.old_block_name != self.component.new_block_name:
                # find the first row in the old column that contained the old reg name
                old_reg = self.component.old_reg_name
                start = self.component.old_regs.index(old_reg)
                field_index = self.component.old_fields.index(item, start)
                new_field_name = self.component.new_fields[field_index]
                new_reg_name = self.component.new_regs[field_index]
                new_block_name = self.component.new_blocks[field_index]
            # Block and Reg have not been/did not need to be repaired
            else:
                # find the current reg name in the old regs starting at the block index
                block_index = self.component.old_blocks.index(self.container.name)  # old block exists in new map
                reg_index = self.component.old_regs.index(self.name, block_index)
                field_index = self.component.old_fields.index(item, reg_index)
                new_field_name = self.component.new_fields[field_index]
                new_block_name = self.component.new_blocks[field_index]
                new_reg_name = self.component.new_regs[field_index]

            new_block = self.component.__getattribute__(new_block_name)
            new_reg = new_block.__getattribute__(new_reg_name)
            new_field = new_reg.__getattribute__(new_field_name)

            # reset the state variables for the next repair
            self.component.old_block_name = ''
            self.component.new_block_name = ''
            self.component.old_reg_name = ''
            self.component.new_reg_name = ''

            print('\033[93m', 'FIELD:', self.container.name+'.'+self.name+'.'+item, ' does not exist. \n       ', new_block.name+'.'+new_reg.name+'.'+new_field.name,
                  ' used instead.', '\033[0m')  # warn the user

            return new_field
        return self.__getattribute__(item)

    def gen_pyi(self, indent: int = 0) -> str:
        """
        Generates python stub content containing all field information

        :param indent: Current .pyi indent level
        :type indent: int
        :return: Python stub contents
        :rtype: str
        """
        pyi_contents = ['    ' * (indent + 1), 'class ', self.name, '(', self.__class__.__name__, '):\n']
        for field in self.get_fields():
            pyi_contents.append(field.gen_pyi(indent=indent + 1))
        pyi_contents.extend(['    ' * (indent + 1), self.name, ':', self.name, '\n'])
        return ''.join(pyi_contents)

    def set_fields(self, field_list=None, yml_file=None, **kwargs):
        """
        Set multiple fields either using a config defined in a yml file or passing in a dictionary. This method is
        intended for efficiency as it writes all the field values in one transaction.

        :param field_list: Sets the list of fields in the field_list input parameter to 1 with one register write. This
                           parameter takes first priority in that if it's defined, the yml and kwargs will be ignored.
        :param yml_file: YAML file with a single layer depth where the key is the field name and the value is the field
                         value to write. This parameter takes second priority.
        :param kwargs: Use keyword parameters where the key is the field name and the value is the value to write to field.
                       This parameter takes last priority.
        :return:
        """

        if yml_file is not None:
            with open(yml_file, 'r') as f:
                reg_dict = yaml.full_load(f.read())
        elif field_list is not None:
            if type(field_list) is not list:
                raise ValueError('Parameter field_list expected to be of list type')
            mask = 0
            for field_name in field_list:
                field_sel = self.__getattribute__(field_name)
                field_mask = int(''.join(['1'] * field_sel.bit_width), 2)
                mask |= field_mask << field_sel.bit_offset
            self.value = self.value | mask
        else:
            reg_dict = kwargs
        for key, value in reg_dict.items():
            self.__getattr__(key).cache_value = value
        self.write_cache()

    def update_fields(self):
        """
        Reads the register and updates the cache_value in each of the field objects

        :return:
        """
        current_value = self.value  # Call the value property to read the register
        for field in self.get_fields():
            field.cache_value = (current_value & field.mask) >> field.bit_offset

    def reset_cache(self):
        for field in self.get_fields():
            field.reset_cache()

    def write_cache(self):
        write_value = 0
        current_value = self.value
        for field in self.get_fields():
            if field.cache_value is not None:
                write_value |= field.cache_value << field.bit_offset
            else:
                write_value |= (current_value & field.mask)
        self.value = write_value

    @property
    def path(self):
        return '%s.%s' % (self.container.name, self.name)


    @property
    def value(self):
        return self.__read_value()

    def __read_value(self, desc:str ='READ (Register)', **kwargs):
        # Check that entire reg is readable
        if not self.readable:
            self.container.log.error('Cannot read %s: Register not readable' % self.name)
            raise PermissionError("Attempting to access non-readable Register: %s" % self.name)
        # Check each field for permission
        for field in self.get_fields():
            if not field.readable:  # Field is not readable, raise warning
                self.container.log.warning("[%s] Cannot read field %s: Field is not Readable" % (self.name, field.name))

        component = self.container.container
        reg_value = component.read_register(self.addr, reg_name=self.path, desc=desc, default_value=self.reset_val, **kwargs)
        return reg_value

    def poll(self, value:int, timeout_sec:float=60, log_all_transactions=True, error_on_fail:bool = True, poll_rest_sec:float=0, **kwargs) -> bool:
        """
        Poll register until value is reached or timeout occurs.

        :param value: Value to poll for
        :type value: int
        :param timeout_sec: length of time in seconds to poll for specified value
        :type timeout_sec: float
        :param log_all_transactions: True if desire to log every read transaction while polling. False to log only the summary transaction.
        :type log_all_transactions: bool
        :param error_on_fail: If true, raises a timeout exception if timeout occurs before value is reached
        :type error_on_fail: bool
        :param poll_rest_sec: Wait time in between poll reads. Defaults to 0 sec
        :type poll_rest_sec: float
        :param kwargs:
        :type kwargs:
        :return: Whether the value was reached
        :rtype: bool
        """
        start = time.time()
        timeout_reached=False
        transaction_exc = None
        ellapsed_time = 0
        try:
            cached_log_en_setting = self.component.transaction_logging_enable
            if not log_all_transactions:
                self.component.transaction_logging_enable = False
            value_read = self.__read_value(desc='POLL (Register)')
            num_tries = 1
            while value_read!=value:
                time.sleep(poll_rest_sec)
                ellapsed_time = time.time()-start
                value_read = self.__read_value(desc='POLL (Register)')
                num_tries += 1
                if ellapsed_time >= timeout_sec:
                    timeout_reached=True
                    if error_on_fail:
                        raise TimeoutError(f"{self.name} did not reach poll value of {value} in {timeout_sec} sec.")
                    break

            self.component.transaction_logging_enable = cached_log_en_setting

        except Exception as e:
            transaction_exc = e

        notes = f'Poll value {value} reached in {"{:.3f}".format(ellapsed_time)} sec ({num_tries} tries)' if timeout_reached == False else \
            f'Poll value {value} was not reached in specified timeout duration of {timeout_sec} sec ({num_tries} tries)'
        self.component._Component__log_poll_transaction(self.addr, update_clive=self.component.full_clive_history,
                                                        reg_name=self.path, desc='POLL (Register)', field_fmt=None,
                                                        default_value=self.reset_val, readback=None, reg_value=value_read,
                                                        notes=notes, transaction_exc=transaction_exc, **kwargs)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc
        return value_read==value

    @value.setter
    def value(self, value):
        self.__write_value(value)

    def __write_value(self, value, skip_verify=False, **kwargs):
        # Check entire reg permission
        if not self.writeable:  # Not writable, log error and return nothing
            self.container.log.error("Cannot write %s to %s: Register not writable" % (hex(value), self.name))
            raise PermissionError("Attempting to access non-writeable Register: %s" % self.name)
        if self.length and value > (2 ** self.length - 1):
            raise ValueError("Given value %d is too large for register of length %d" % (value, self.length))
        # Check each field for permission
        for field in self.get_fields():
            if value & field.mask and not field.writeable:  # Field is not writable, raise warning
                self.container.log.warning("[%s] Cannot write %s to field %s: Field is not writable"
                                           % (self.name, (value & field.mask) >> field.bit_offset, field.name))

        component = self.container.container
        component.write_register(self.addr, value, reg_name=self.path, verify_mask=self.read_mask,
                                 skip_verify=not self.readable, **kwargs)

    def __setattr__(self, key, value):
        # Attribute protection. Fields and internal attributes that come from the regmap
        # NOTE: Cannot blindly get attribute in this method, as getting 'value' will perform a read operation
        if hasattr(self, '_Register__constructed') and self.__constructed:
            if key in _PROTECTED_ATTRIBUTES and hasattr(self, key):
                self.component.log.error(f"Cannot assign regmap attribute {self.path}.{key} to {value}")
                return
            elif key in [f.name for f in self.get_fields()]:
                self.component.log.error(f"Cannot set protected Field {key} to {value}. "
                                         f"Try using:\b {getattr(self, key).path}.value = {value}")
                return
        super().__setattr__(key, value)

    def set_cache(self, value):
        for field in self.get_fields():
            cur_value = value >> field.bit_offset
            mask = (1 << field.bit_width) - 1
            field.cache_value = mask & cur_value

    def get_cache(self):
        value = 0
        for field in self.get_fields():
            value += (field.reset_value if field.cache_value is None else field.cache_value) << field.bit_offset
        return value

    def reset(self):
        """
        Writes reset value to register.

        :return: None
        :rtype: None
        """
        self.value = self.reset_val
        self.reset_cache()

    def __len__(self):
        return self.length

    def get_field_dict_from_value(self, value: int) -> Dict[Field, int]:
        """
        Builds field dictionary from a given register value. Keys are field instances, values are their calculated
        values.

        *Note:* Spanned field values will only contain the portion contained within the register.

        :param value: Register value
        :type value: int
        :return: Field dictionary
        :rtype: Dict[Field, int]
        """
        field_dict = {}
        for field in self.get_fields():
            if not field.spans_multiple_regs:  # Normal field
                field_value = (value & field.mask) >> field.bit_offset
                field_dict[field] = field_value
            else:  # Get bit mapping from block attribute
                field_value = 0
                bit_mapping = self.container.spanned_fields[field.full_name][self]
                for dest, source in bit_mapping.items():  # Iterate though register's bit mapping
                    field_value += ((reg_value >> source) & 0x1) << dest  # Map source bit from register into field
                    field_dict[field] = field_value
            self.container.log.debug(f"{field.path} = 0x{field_value:0{field.bit_width>>2}X}")
        return field_dict
