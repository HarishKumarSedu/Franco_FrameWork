"""SQL Database TestStationObject"""
import os
from typing import Dict, List, Tuple, Union
import pandas as pd
import sqlalchemy as sqldb
from cl_test_station.test_station_object import TestStationObject, TsoField


class ValDatabaseTool(TestStationObject):
    """SQL Database TestStationObject"""

    dbuser : str = TsoField(ftype=str, required=False, default='$DB_USERNAME')
    pw: str = TsoField(ftype=str, required=False, default='$DB_PASSWORD')
    host_name: str = TsoField(ftype=str, required=False, default='brown.crystal.cirrus.com', desc='Database server name/address')
    dbname: str = TsoField(ftype=str, desc='Database name')
    port_num: int = TsoField(ftype=int, required=False, default=3306, desc='Database server port number')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.engine = None
        self.tables = {}

    def configure(self, config, *args, **kwargs):
        super().configure(config, *args, **kwargs)
        # check for and evaluate environment variables
        if self.dbuser.startswith('$'):
            self.dbuser = os.environ[self.dbuser[1:]]
        if self.pw.startswith('$'):
            self.pw = os.environ[self.pw[1:]]
        # attempt to open connection to database
        try:
            # dialect+driver://username:password@host:port/database
            # ToDo: add support for encrypted password, potentially from registry created by CAPO
            engine_str = f'mysql+pymysql://{self.dbuser}:{self.pw}@{self.host_name}:{self.port_num}/{self.dbname}?charset=latin1'
            self.engine = sqldb.create_engine(engine_str)
            table_list = self.engine.table_names()
            self.tables = {'table_list': table_list}

            for tablename in table_list:
                try:
                    tb_keys = self.get_table_keys(tablename)
                except Exception as err:
                    # print(err)
                    pass
                else:
                    self.tables[tablename] = tb_keys
                    setattr(self, tablename, Table(tb_keys))
        except Exception as err:
            self.log.error(err)
            self.close()

    def connect(self):
        print('please use connect_and_execute() instead')

    def close(self):
        """
        Closes connection to database if opened

        :return: None
        :rtype: None
        """
        if self.engine is not None:
            self.engine.dispose()

    def get_record_id(self, table:str, new_row:Dict) -> List[int]:
        """
        Retrieves the IDs of new_row in the given table, if it exists. Otherwise, it will create it and return the newly
        created ID

        :param table: Database table name
        :type table: str
        :param new_row: Dictionary of row. Keys should match table columns
        :type new_row: Dict
        :return: List of IDs
        :rtype: List[int]
        """
        ids=None
        id_last=None
        exist, ids = self.check_record_exist(table=table, new_row=new_row)
        if exist:
            id_last = ids[-1]
        else:
            id_last = self.insert_new_row(table=table, new_rows=new_row)
            ids=[id_last]
        return ids

    def check_record_exist(self, table:str, new_row:Dict):
        """
        Checks if new_row exists in table

        :param table: Database table name
        :type table: str
        :param new_row: Dictionary of new row
        :type new_row: Dict
        :return: Tuple of if row exists and list of IDs
        :rtype: Tuple[bool, List[int]]
        """
        row_id = []
        exist = False
        my_dict = {key: val for key, val in new_row.items() if val is not None}
        if len(my_dict)==0:
            raise ValueError('new_row: all values are None')
        columns = ', '.join("`" + str(x).replace('/', '_') + "`" for x in my_dict.keys())
        values = ', '.join("'" + str(x).replace('/', '_') + "'" for x in my_dict.values())
        query = f'SELECT id FROM {table} WHERE ( {columns} ) = ( {values} );'

        result_set = self.connect_and_execute(query)
        row_count = len(result_set)
        if row_count > 0:
            exist = True
            for row in result_set:
                key = 'id'
                row_id.append(row[key])
        return exist, row_id

    def connect_and_execute(self, query:str=None, return_expected:bool=True):
        """
        Connect to dababase and execute input query, if None, execute default query.
        try multiple times if fail connect to database.

        :param query:
        :return: ResultSet: the output from execute the query
        """
        # ToDo: Add warning about failures to check database password/credentials
        if query is None:
            table_0 = self.tables['table_list'][0]
            query = f'SELECT * FROM {table_0} LIMIT 1;'
        try:
            result_set = self.__connect_and_execute(query, return_expected)
        except Exception as e1:
            print('database re_connect - try 1')
            try:
                result_set = self.__connect_and_execute(query, return_expected)
                print('database re_connect - try 1 - pass')
            except Exception as e2:
                print('database re_connect - try 2')
                try:
                    result_set = self.__connect_and_execute(query, return_expected)
                    print('database re_connect - try 2 - pass')
                except Exception as e3:
                    print('database re_connect - try 3')
                    result_set = self.__connect_and_execute(query, return_expected)
                    print('database re_connect - try 3 - pass')
        return result_set

    def __connect_and_execute(self, query:str, return_expected:bool=True):
        with self.engine.connect() as connection:
            if return_expected:
                result_proxy = connection.execute(query)
                result_set = result_proxy.fetchall()
            else:
                connection.execute(query)
                result_set = None
        return result_set

    def insert_new_row(self, table:str, new_rows:Union[Dict,List[Dict]]) -> int:
        """
        Inserts new row(s) to given database table

        :param table: Database table name
        :type table: str
        :param new_rows: New row(s) to be inserted to table
        :type new_rows: Dict | List[Dict]
        :return: ID of new row or last new row
        :rtype: int
        """
        if isinstance(new_rows, list):
            data = pd.DataFrame(new_rows)
        else:  # dict
            data = pd.DataFrame([new_rows])
        try:
            data.to_sql(table, self.engine, if_exists='append', index=False)
            _, records = self.run_query('SELECT LAST_INSERT_iD()')
            id_last_insert = records[0]['LAST_INSERT_iD()']
            return id_last_insert
        except Exception as e:  # pylint: disable=invalid-name
            self.connect_and_execute()
            data.to_sql(table, self.engine, if_exists='append', index=False)
            _, records = self.run_query('SELECT LAST_INSERT_iD()')
            id_last_insert = records[0]['LAST_INSERT_iD()']
            return id_last_insert

    def run_query(self, query:str, internal:bool=False, return_expected:bool=True) -> Tuple[bool,List[Dict]]:
        """
        Executes given SQL query

        :param query: SQL query to execute
        :type query: str
        :param internal: Controls the return format. True=ResultSet (Default: False=List[Dict])
        :type internal: bool
        :param return_expected: Is a result expected? (Default: True)
        :type return_expected: bool
        :return: Query result of if result returned and result
        :rtype: Tuple[bool, ResultSet | List[Dict]]
        """
        # check query, block certain sql commands: drop, delete, create, alter
        nogo_list = ['drop', 'create', 'delete', 'alter']
        query_str_low = query.lower()
        for nogo_item in nogo_list:
            if query_str_low.find(nogo_item) >= 0:
                error_str = f'{nogo_item} is not supported here!'
                raise ValueError(error_str)

        list_of_dict=[]
        exist=False
        result_set = self.connect_and_execute(query, return_expected)
        if return_expected:
            row_count = len(result_set)
            if row_count > 0:
                exist = True
                for row in result_set:
                    dict_row = dict(zip(row.keys(), list(row)))
                    list_of_dict.append(dict_row)  # dict_row)
        if internal:
            return exist, result_set
        return exist, list_of_dict

    def get_table_keys(self, table:str):
        """
        Queries database to get the column names of the specified table

        :param table: Table name to get the column names of
        :type table: str
        :return: List of table column names
        :rtype: List[str]
        """
        query = f'SHOW COLUMNS FROM {table} '
        exist, result = self.run_query(query, internal=True)
        if exist:
            table_keys = [xi[0] for xi in result]
        else:
            table_keys = None
            raise ValueError(f'Table "{table}" does not exist in database {self.dbname} on {self.host_name}:'
                             f'{self.port_num} for user {self.dbuser}')
        return table_keys

    def get_category_id(self, category_desc:str) -> List[int]:
        """
        Retrieves the IDs of the given category description, if it exists. Otherwise, it will create it and return the
        newly created ID

        :param category_desc: Category description
        :type category_desc: str
        :return: List of IDs
        :rtype: List[int]
        """
        ids=None
        new_row = {'description': category_desc}
        ids = self.get_record_id(table='category', new_row=new_row)
        return ids

    def get_records(self, table:str, new_row:Dict) -> Tuple[bool, List[Dict]]:
        """
        Returns matting rows in the given table

        :param table: Database table name
        :type table: str
        :param new_row: Dictionary of row to find
        :type new_row: Dict
        :return: Tuple of if found and found results
        :rtype: Tuple[bool, List[Dict]]
        """
        list_records = []
        exist = False
        if self.check_table_and_keys(table=table, new_row=new_row):  # table exist
            columns = ', '.join("`" + str(x).replace('/', '_') + "`" for x in new_row.keys())
            values = ', '.join("'" + str(x).replace('/', '_') + "'" for x in new_row.values())
            query = f'SELECT * FROM {table} WHERE ( {columns} ) = ( {values} );'

            exist, list_records = self.run_query(query, internal=False)
        else:
            print('table/keys do not match database table')
        return exist, list_records

    def get_latest_record(self, table:str, new_row:Dict) -> Tuple[bool, List[Dict]]:
        """
        Returns the latest matching row in the table

        :param table: the table name in database
        :param new_row:  it's a dict with keys matching table columns, could be partial of the table columns
        :return:

            exist : True/False

            list_record: list of dict values (the latest matching row)
        """
        exist, records_list = self.get_records(table=table, new_row=new_row)
        if exist & (len(records_list)>1):
            list_record = []
            list_record.append(records_list[-1])
        else:  # len(db_trims_list) == 1
            list_record = records_list
        return exist, list_record

    def check_table_and_keys(self, table:str, new_row:Dict) -> bool:
        """
        Checks table to see if it exists and that it matches the row format

        :param table: Database table name
        :type table: str
        :param new_row: Dictionary of row format
        :type new_row: Dict
        :return: if table exists and all row columns exist in the table
        :rtype: bool
        """
        table_exist = table in self.tables['table_list']
        keys_match = True
        for key in new_row.keys():
            keys_match = keys_match & (key in self.tables[table])
        return table_exist & keys_match

    def create_new_dut(self, board_id, assembly_lot_id=None, chip_package=None, chip_design_rev=None, site=1):
        """ **Note: not tested yet**

        :param board_id:
        :param assembly_lot_id:
        :param chip_package: it's ignored if assembly_lot_id is valid
        :param chip_design_rev: it's ignored if assembly_lot_id is valid
        :param site: default to 1
        :return: id of the new dut
        """
        new_dut_id = None
        if assembly_lot_id is None:  # use chip_package/chip_design_rev to find assembly_lot_id
            if chip_package is not None and chip_design_rev is not None:
                assembly_lot = {'package': chip_package, 'design_rev': chip_design_rev}
                assembly_lot_exist, assembly_lot_id_list = self.check_record_exist(table='assembly_lot', new_row = assembly_lot)
                if assembly_lot_exist:
                    assembly_lot_id = assembly_lot_id_list[0]
                else:
                    print("\033[93m please insert a new assembly lot to assembly_lot table: assembly lot does not exist for input package and design_rev \033[0m")
            else:
                error_str = "please input either assembly_lot_id or chip_package/chip_design_rev info"
                raise ValueError(error_str)
        if assembly_lot_id is not None:
            new_chip = {'assembly_lot_id': assembly_lot_id}
            chip_id = self.insert_new_row(table='chip', new_rows=new_chip)  # insert a new chip with assembly_lot_id
            new_dut = {'board_id': board_id, 'chip_id': chip_id, 'site': site}
            new_dut_id = self.insert_new_row(table='dut', new_rows = new_dut)  # insert a new dut with assembly_lot_id
        else:
            error_str = "please input either assembly_lot_id or chip_package/chip_design_rev info"
            raise ValueError(error_str)
        return new_dut_id

    def generate_id(self, level=1, recursive=True, dbg_dict=None):
        return 0

class Table:
    """Dynamically crated table container class"""
    def __init__(self, tb_keys):
        self.columns = [str(col) for col in tb_keys]
        self.init_columns() # dynamic attributes based on the query result of columns in each table.

    def init_columns(self):
        """
        Creates attributes for all entries in columns

        :return: None
        :rtype: None
        """
        for col in self.columns:
            setattr(self, col, None)
