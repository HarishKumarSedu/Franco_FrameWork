"""Start of rewrite to use a single TestStationObject class to contain all Validation Database actions"""
import os
from decimal import Decimal
from typing import Any, Dict
import pymysql
from cl_test_station.test_station_object import TestStationObject, TsoField


class ValDatabase(TestStationObject):
    """
    Shared validation val_database access class.
    Functionality is using context manager that is constantly opening and closing connections to the database
    """

    username: str = TsoField(ftype=str, required=False, default='$DB_USERNAME', desc='Validation val_database username')
    password: str = TsoField(ftype=str, required=False, default='$DB_PASSWORD', desc='Validation val_database password')
    host_name: str = TsoField(ftype=str, required=False, default='brown.crystal.cirrus.com',
                              desc='Database server name/address')
    port_num: int = TsoField(ftype=int, required=False, default=3306, desc='Database server port number')
    project_db: str = TsoField(ftype=str, desc='Name of the project val_database')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._connection = None
        self._active_database = ''

    def __del__(self):
        """
        Verify database connection is closed

        :return: None
        :rtype: None
        """
        self.disconnect()
        if self._connection:
            self._connection.close()

    def connect(self, force: bool=False, **kwargs):
        """
        Opens connection to validation database, if not already connected

        :param force: Force connect to be called, if already connected
        :type force: bool
        :param kwargs: Keyword arguments passed to pymysql.connect
        :type kwargs: Any
        :return: None
        :rtype: None
        """
        if not self._connection or force:
            # open connection
            self.log.debug(f'Connecting to {self.host_name}:{self.port_num} as {self.username}')
            try:
                self._connection = pymysql.connect(host=self.host_name, port=self.port_num, user=self.username,
                                                   password=self.password, **kwargs)
                if 'database' in kwargs and isinstance(kwargs['database'], str):
                    self._active_database = kwargs['database']
                else:
                    self._active_database = ''
            except pymysql.OperationalError as err:
                self.log.error(f'Unable to connect to the database on {self.host_name}:{self.port_num} as {self.username}')
                raise err
        else:
            self.log.debug('Already connected to database')

    def disconnect(self):
        """
        Closes connection to validation database, if already connected

        :return: None
        :rtype: None
        """
        if self._connection:
            self.log.debug('Disconnecting from database')
            if self._connection.open:
                self._connection.close()
            self._connection = None
            self._active_database = ''
        else:
            self.log.debug('Already disconnected from database')

    class Connection:
        """Context manager class to make single sources database connection syntax. Also logs connection errors"""

        def __init__(self, val_database, database: str=None, **kwargs):
            self.log = val_database.log
            # verify connection to database
            if not val_database._connection:
                val_database.connect(**kwargs)
                self.log.debug('Connection.__init__: Connecting to database')
            else:
                val_database._connection.ping()
            # verify database selection, if given
            if database:
                self.log.debug(f'Connection.__init__: Selecting {database} database')
                val_database._connection.select_db(database)
                val_database._active_database = database
            # save values needed later
            self._connection = val_database._connection

        def __enter__(self):
            self.log.debug('Entering ValDatabase.Connection')
            return self._connection

        def __exit__(self, *args):
            self.log.debug('Exiting ValDatabase.Connection')

    def generate_id(self, level=1, recursive=True, dbg_dict=None):
        """
        Ignoring contents for test system differences

        :return: ID value = 0
        :rtype: int
        """
        return 0

    def configure(self, config, *args, **kwargs):
        super().configure(config, *args, **kwargs)
        # verify database name is lower case
        self.project_db = self.project_db.lower()
        # check for and evaluate environment variables
        if self.username.startswith('$'):
            self.username = os.environ[self.username[1:]]
        if self.password.startswith('$'):
            self.password = os.environ[self.password[1:]]
        # verify ability to connect to database
        try:
            with self.Connection(self, database=self.project_db) as connection:
                cursor = connection.cursor()    # pylint: disable=unused-variable
                self.log.info(f'Able to connect to the {self.project_db} database on {self.host_name}:{self.port_num} '
                              f'as {self.username}')
        except pymysql.OperationalError as err:  # pylint: disable=unused-variable
            self.log.error("Please verify the user's password and database permissions")

    def get_voltage_corner(self, vcorner: str = 'TYP') -> Dict[str, Any]:
        """
        Queries the project database for the specified voltage corner

        :param vcorner: Voltage corner to retrieve (Default: TYP)
        :type vcorner: str
        :return: Dictionary of the project's vcorner row. An empty dictionary is returned if corner is not found.
        :rtype: Dict[str, Any]
        """
        self.log.debug(f'Querying {vcorner} voltage corner for {self.project_db}')
        with self.Connection(self, database=self.project_db) as connection:
            cursor = connection.cursor(pymysql.cursors.DictCursor)
            cursor.execute('SELECT * FROM vcorner WHERE vcorner_str=%s', (vcorner,))
            data = cursor.fetchone()
            # build returned dictionary
            result = {}
            if data is None:
                self.log.error(f'{vcorner} voltage corner does not exist in {self.project_db}.vcorner!')
            else:
                for key, value in data.items():
                    # convert Decimal to float
                    if isinstance(value, Decimal):
                        value = float(value)
                    result[key] = value
            return result

    def verify_dut_id(self, dut_id, board_id) -> bool:
        """
        Check for a combination of the DUT ID and Board ID in the project dut database table.
        :param dut_id: DUT database_id
        :type dut_id: int
        :param board_id: board database_id
        :type board_id: int
        :return: returns whether the combination exists in the database table
        :rtype: bool
        """
        self.log.debug('Checking database for DUT ID and Board ID combination')
        with self.Connection(self, database=self.project_db) as connection:
            cursor = connection.cursor(pymysql.cursors.DictCursor)
            cursor.execute(f'SELECT * FROM dut WHERE id={dut_id} and board_id={board_id}')
            data = cursor.fetchone()
            if data is None:
                self.log.error(f"DUT ID {dut_id} and Board ID {board_id} is not valid in the {self.project_db}.dut table.")
                found = False
            else:
                found = True
            return found

    def get_temperature_corner(self, tcorner: str = 'ROOM') -> Dict[str, Any]:
        """
        Queries the project database for the specified temperature corner

        :param tcorner: Temperature corner to retrieve (Default: ROOM)
        :type tcorner: str
        :return: Dictionary of the project's tcorner row. An empty dictionary is returned if corner is not found.
        :rtype: Dict[str, Any]
        """
        self.log.debug(f'Querying {tcorner} temperature corner for {self.project_db}')
        with self.Connection(self, database=self.project_db) as connection:
            cursor = connection.cursor(pymysql.cursors.DictCursor)
            cursor.execute('SELECT * FROM tcorner WHERE tcorner_str=%s', (tcorner,))
            data = cursor.fetchone()
            # build returned dictionary
            result = {}
            if data is None:
                self.log.error(f'{tcorner} temperature corner does not exist in {self.project_db}.tcorner!')
            else:
                for key, value in data.items():
                    # convert Decimal to float
                    if isinstance(value, Decimal):
                        value = float(value)
                    result[key] = value
            return result

    def get_board_barcode(self, board_id: int) -> str:
        """
        Queries the barcode for the given boards.board ID. Will return an empty string if ID does not exist.

        :param board_id: boards.board ID
        :type board_id: int
        :return: Board's Barcode
        :rtype: str
        """
        self.log.debug(f'Querying barcode for boards.board ID={board_id}')
        with self.Connection(self, database='boards') as connection:
            cursor = connection.cursor()
            cursor.execute('SELECT barcode FROM board WHERE id=%s', (board_id,))
            result = cursor.fetchone()
            if result is None:
                self.log.error(f'Board ID {board_id} does not exist in boards.board table')
                return ''
            return result[0]
