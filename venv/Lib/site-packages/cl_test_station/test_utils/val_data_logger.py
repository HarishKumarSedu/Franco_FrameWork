import os
from abc import ABCMeta
from time import strftime
import numpy as np
import pandas as pd
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.test_utils.val_data_collector import Float_data, Series, File_data, String_data, Sweep_data


class ValDataLogger(TestStationObject, metaclass=ABCMeta):
    """Place holder"""
    float_data_keys = ['measurement', 'description', 'value', 'units']
    float_data_row_keys = ['float_data', 'tp_x',  'tp_val']
    string_data_keys = ['measurement', 'description', 'value', 'units']
    string_data_row_keys = ['string_data', 'tp_x', 'tp_val']
    file_data_keys = ['measurement', 'description', 'file_path', 'file_dir', 'file_name', 'file_extension'] # ['measurement', 'description', 'file_path', 'file_directory', 'file_name', 'extenstion']
    file_data_row_keys = ['file_data', 'tp_x', 'tp_val']
    series_keys = ['label', 'units', 'series_type', 'series_data']
    sweep_data_keys = ['sweep_name', 'series_list', 'dut_id', 'tp_x',  'tp_val']
    user_float_data_to_TS_keys = ['value']
    user_float_data_to_TS_row_keys = ['user_float_data_TS']
    user_string_data_to_TS_keys = ['value']
    user_string_data_to_TS_row_keys = ['user_string_data_TS']
    db_logging_dict = dict.fromkeys(['dut_group_id', 'dut_id', 'board_group_id', 'test_station_id', 'operator_id', 'test_table_name',
         'params_table_name', 'limits_table_name', 'tcorner_str', 'vcorner_str', 'tcorner_id', 'vcorner_id', 'environment_id', 'session_id',
         'measurement_group', 't_table_desc', 'category_id', 'ignore_data', 'test_parameters_id', 'test_id',
         'datagroup_id', 'limits_id', 'sweep_id', 'series_id', 't_table_desc_use_measurement_name'])

    def __init__(self,  *args, **kwargs): #config, container=None, local_project=None, excluded_classes=None, ref_name=None, preloaded_classes=None):
        super().__init__(*args, **kwargs) #config, container, local_project, excluded_classes, ref_name, preloaded_classes)
        self.db_proj = self.container.db_proj # test_station.val_database_tool.db_proj
        self.db_boards = self.container.db_boards # test_station.val_database_tool.db_boards
        self.db_lab = self.container.db_lab # test_station.val_database_tool.db_lab

    def configure(self, config, *args, **kwargs):
        super().configure(config, *args, **kwargs)

    # def setup_data_logging(self, file_or_database=0, filename_enable_timestamp=True, ignore_data=3, bay_number=5, test_category_desc=None,  test_table_name='validation'):
    #     # TEST.log_val_data(file_or_database=1, enable_timestamp=True, ignore_data=3, bay_number=5,
    #     #                   test_category_desc=None, measurement_group=None, measurement_group_desc=None,
    #     #                   test_table_name='validation')
    #
    #     self.select_test_table(test_table_name)
    #     tp_table_name = self.db_logging_dict['params_table_name']
    #     self.tp_table = getattr(self.container.db_proj, tp_table_name)
    #     return self.tp_table
    #     pass

    def write_df_data_to_file(self, folder, filename, df_data, enable_timestamp=True, dut_id=-1):
        """
        this method checks the df_data type (float/sweep/file/string) prefix the filename with data_type,
        reformat it to a flat dataframe, then write(or append if exist) it to a csv file.

            - name = data_type-filename-timestamp.csv  if enable_timestamp = True
            - or name = data_type-filename.csv if enable_timestamp = False*

        :param folder:
        :param filename:
        :param df_data:
        :param enable_timestamp: if True: suffix the filename with timestamp, if False: no timestamp on filename,
            append data to the file if exist

        """
        try:
            data_type = self.check_df_data_type(df_data)
            if enable_timestamp:
                timestamp_suffix = strftime('-%Y%m%d%H%M%S')
            else:
                timestamp_suffix = ''
            filename = "%s-%s%s.csv" % (data_type, filename, timestamp_suffix)
            if folder is not None and not os.path.exists(folder):
                os.mkdir(folder)
            if folder is not None:
                filename = os.path.join(folder, filename)

            print(f"\033[93m Logging {data_type}_data as csv_file to {filename} ...\033[0m")
            if data_type == 'sweep':
                df_data_flat = self.sweep_data_to_flat_table(df_data)
            else:
                df_data_flat = self.float_data_to_flat_table(df_data)
            if dut_id > -1:
                df_data_flat.insert(0, 'dut_id', [dut_id] * df_data_flat.shape[0], True)
            sheet_name = 'test_' + data_type
            self.write_flat_df_data_to_file(filename, sheet_name, df_data_flat)
        except Exception as err:
            print(err)

    def write_flat_df_data_to_file(self, filename,  sheet_name, df_data_flat):
        """
        Place Holder

        :param filename:
        :param sheet_name:
        :param df_data_flat:
        :return:
        """
        if os.path.exists(filename):  # append if exist
            df_data_flat.to_csv(filename, mode='a', index=False, header=False)
            # match, file_rowcount = self.check_file_vs_data(filename, sheet_name, df_data_flat)
            # if match:
            #     df_data_flat.to_csv(filename, mode='a', index=False)
            # else:
            #     print('Warning: data keys doesn''t match existing file keys')
        else:  # if enable_timestamp or not os.path.exists(filename):
            df_data_flat.to_csv(filename, index=False)

    def check_df_data_type(self, df_data):
        """
        Place Holder

        :param df_data:
        :return:
        """
        data_keys = df_data.keys()
        if 'float_data' in data_keys:
            data_type = 'float'
        elif 'sweep_name' in data_keys:
            data_type = 'sweep'
        elif 'string_data' in data_keys:
            data_type = 'string'
        elif 'file_data' in data_keys:
            data_type = 'file'
        else:
            data_type = 'dummy'
        return data_type

    def float_data_to_flat_table(self, df_data):
        """
        Place Holder

        :param df_data:
        :return:
        """
        # to flat tp_val with the data
        df_data_flat = pd.DataFrame()
        for col in df_data.columns:
            if type(df_data.iloc[0][col]) is dict:
                df_col = pd.DataFrame(df_data[col].to_list())
                df_data_flat = pd.concat([df_data_flat, df_col], axis=1, sort=False)
            elif type(df_data.iloc[0][col]) is Float_data or type(df_data.iloc[0][col]) is String_data or type(df_data.iloc[0][col]) is File_data :
                df_col_list =[]
                for i in range(df_data.shape[0]):
                    df_col_list.append(vars(df_data.iloc[i][col]))
                df_col = pd.DataFrame(df_col_list)
                df_data_flat = pd.concat([df_data_flat, df_col], axis=1, sort=False)
            else:
                df_col = df_data[col]
                df_data_flat = pd.concat([df_data_flat, df_col], axis=1, sort=False)
        return df_data_flat

    def sweep_data_to_flat_table(self, df_data):
        """
        Place Holder

        :param df_data:
        :return:
        """
        #todo: check data type Sweep_data
        df_sweep_flat = pd.DataFrame()
        row_count, col_count = df_data.shape
        keys = df_data.keys()
        for i in range(row_count):
            df_data_sweep_i = pd.DataFrame()
            if 'series_list' in keys:
                series_list = df_data.loc[i, 'series_list']
                df_series = pd.DataFrame()
                for j in range(len(series_list)):
                    series_j = series_list[j]
                    if type(series_j)==Series:
                        series_j_data = series_j.series_data
                        series_j_label = series_j.label
                        series_j_units = series_j.units
                    elif series_j is dict:
                        series_j_data = series_j['series_data']
                        series_j_label = series_j['label']
                        series_j_units = series_j['units']
                    columns = series_j_label + '_' + series_j_units
                    pd_se_j = pd.DataFrame(series_j_data, columns=[columns])
                    df_series = pd.concat([df_series, pd_se_j], axis=1, sort=False)

            series_len = df_series.shape[0]
            if 'sweep_name' in keys:
                sweep_name = df_data.loc[i, 'sweep_name']
                df_sweep_name = pd.DataFrame([sweep_name] * series_len, columns=['sweep_name'])
            if 'tp_x' in keys:
                tp_x = df_data.loc[i, 'tp_x']
                df_tp_x = pd.DataFrame([tp_x] * series_len)
            if 'tp_val' in keys:
                tp_val = df_data.loc[i, 'tp_val']
                df_tp_val = pd.DataFrame([tp_val] * series_len)
            df_data_sweep_i = pd.concat([df_sweep_name, df_series, df_tp_x, df_tp_val], axis=1, sort=False)
            df_sweep_flat = pd.concat([df_sweep_flat, df_data_sweep_i], axis=0, sort=False)
        return df_sweep_flat

    def log_df_data_to_database(self, df_data_list):
        for df_data in df_data_list:
            if df_data is not None:
                data_type = self.check_df_data_type(df_data)
                print(f"\033[93m Logging {data_type}_data to database ...\033[0m")
                if data_type == 'float':
                    self.log_df_data_float_to_database(df_data)
                elif data_type == 'sweep':
                    self.log_df_data_sweep_to_database(df_data)
                else:  # 'file' or 'string'
                    self.log_df_data_file_or_string_to_database(df_data, data_type)

    def log_df_data_float_to_database(self, df_data_float):
        """
        Place Holder

        :param df_data_float:
        :return:
        """
        # print(f'df_data_float_keys = {df_data_float.keys()}')
        # todo: df_data_float -> full df with all other column
        list_float =[]
        for i in range(df_data_float.shape[0]):
            data_row_i = df_data_float.iloc[i] # from the ith of df_data_float
            float_data_i_r = data_row_i['float_data'] # float_data_row_keys = ['float_data', 'tp_x',  'tp_val'] # todo: check float_data_i type if Float_data -> dict
            if type(float_data_i_r ) == dict:
                float_data_i = float_data_i_r
            elif type(float_data_i_r )== Float_data:
                float_data_i = dict(zip(['measurement', 'description', 'value', 'units'], [float_data_i_r.measurement, float_data_i_r.description,float_data_i_r.value, float_data_i_r.units]))
                # float_data_i['measurement'] =  float_data_i_r.measurement
                # float_data_i['description'] = float_data_i_r.description
                # float_data_i['value'] = float_data_i_r.value
                # float_data_i['units'] = float_data_i_r.units
            else:
                pass # todo: not supported format

            tp_val_i = data_row_i['tp_val'] # todo: check tp_val_i type if Float_data -> dict
            # todo: check if tp_x has corner info, and if it's different from previous data, if yes, need update the env_id again; maybe check it outside the loop, generate a corner_change_flag for each row
            # tp_x = data_row_i['tp_x']
            # if tp_x != {} :

            self.get_tp_id(tp_val_i)
            if self.db_logging_dict['t_table_desc_use_measurement_name']:  # this is set to false if user specify measurement_group_desc during log_val_data call; if not use measurement name or sweep_name
                # todo: this is debatable, use input if user specify it during log_val_data call; if not use the measurement name or sweep_name which will result in each datapoint if t_test(datagroup) 1::1 datapoint
                t_table_desc = float_data_i['measurement']
            else:
                t_table_desc = None
            self.get_test_id(t_table_desc)
            self.get_datagroup_id()
            spec_tag_i = float_data_i['spec_tag'] if 'spec_tag' in float_data_i.keys() else None
            self.get_float_data_limits_id(float_data_i['measurement'], spec_tag_i)
            # self.insert_to_float_data_table(float_data_i ) #step 3
            float_data_i['dut_id'] = self.db_logging_dict['dut_id']
            float_data_i['datagroup_id'] = self.db_logging_dict['datagroup_id']
            float_data_i['limits_id'] = self.db_logging_dict['limits_id']
            float_data_i['limits_version'] = 0  # hard-code to 0
            float_data_i['error_code'] = 0  # hard-code to 0
            list_float.append(float_data_i)
        self.db_proj.insert_new_row(table='float_data', new_rows=list_float)


    def log_df_flat_data_float_to_database(self, df_data_float_flat, tp_val_keys):
        """
        Place Holder

        :param df_data_float_flat:
        :param tp_val_keys:
        :return:
        """
        # print(f'df_data_float_keys = {df_data_float.keys()}')
        # todo: df_data_float -> full df with all other column
        list_float =[]
        for i in range(df_data_float_flat.shape[0]):
            data_row_i = df_data_float_flat.iloc[i] # from the ith of df_data_float
            float_data_i = data_row_i.filter(items=self.float_data_keys).to_dict()#data_row_i['float_data'] # float_data_row_keys = ['float_data', 'tp_x',  'tp_val']
            # if type(float_data_i['units']) == float:
            #     float_data_i['units'] = ''
            tp_val_i = data_row_i.filter(items=tp_val_keys).to_dict() #data_row_i['tp_val']
            # todo: check if tp_x has corner info, and if it's different from previous data, if yes, need update the env_id again; maybe check it outside the loop, generate a corner_change_flag for each row
            # tp_x = data_row_i['tp_x']
            # if tp_x != {} :

            self.get_tp_id(tp_val_i)
            if self.db_logging_dict['t_table_desc_use_measurement_name']:  # this is set to false if user specify measurement_group_desc during log_val_data call; if not use measurement name or sweep_name
                # todo: this is debatable, use input if user specify it during log_val_data call; if not use the measurement name or sweep_name which will result in each datapoint if t_test(datagroup) 1::1 datapoint
                t_table_desc = float_data_i['measurement']
            else:
                t_table_desc = None
            self.get_test_id(t_table_desc)
            self.get_datagroup_id()
            spec_tag_i = float_data_i['spec_tag'] if 'spec_tag' in float_data_i.keys() else None
            self.get_float_data_limits_id(float_data_i['measurement'], spec_tag_i)
            # self.insert_to_float_data_table(float_data_i ) #step 3
            float_data_i['dut_id'] = self.db_logging_dict['dut_id']
            float_data_i['datagroup_id'] = self.db_logging_dict['datagroup_id']
            float_data_i['limits_id'] = self.db_logging_dict['limits_id']
            float_data_i['limits_version'] = 0  # hard-code to 0
            float_data_i['error_code'] = 0  # hard-code to 0
            list_float.append(float_data_i)
        self.db_proj.insert_new_row(table='float_data', new_rows=list_float)
        pass

    def log_df_data_sweep_to_database(self, df_data_sweep):
        """
        Place Holder

        :param df_data_sweep:
        :return:
        """
        # df_data_sweep.iloc[0]
        # sweep_name        # vimon_thdn_vs_freq
        # series_list[{'label': 'imon_THDN', 'units': 'dB', 'series...
        #     tp_x               {'tcorner_str': 'ROOM', 'vcorner_str': 'TYP'}
        #                  tp_val         {'clpc_version': 'todo in teststand', 'fpga_re...
        for i in range(len(df_data_sweep)): # loop over sweeps
            sweep_i = df_data_sweep.iloc[i] # ['sweep_name', 'series_list', 'tp_x', 'tp_val']
            self.log_sweep_to_database(sweep_i)

    def log_df_data_file_or_string_to_database(self, df_data, data_type):
        """
        Place Holder

        :param df_data:
        :param data_type: should be 'file_data' or 'string_data'
        :return:
        """
        df_data_keys = df_data.keys()
        data_tablename = data_type + '_data'
        list_data = []
        for i in range(df_data.shape[0]):
            data_row_i = df_data.iloc[i]
            data_i =data_row_i[data_tablename]

            tp_val_i = data_row_i['tp_val']
            # todo: check if tp_x has corner info, and if it's different from previous data, if yes, need update the env_id again; maybe check it outside the loop, generate a corner_change_flag for each row
            # tp_x = data_row_i['tp_x']
            # if tp_x != {} :

            self.get_tp_id(tp_val_i)
            if self.db_logging_dict['t_table_desc_use_measurement_name']:  # this is set to false if user specify it during log_val_data call; if not use measurement name or sweep_name
                # todo: this is debatable, use input if user specify it during log_val_data call; if not use the measurement name or sweep_name which will result in each datapoint if t_test(datagroup) 1::1 datapoint
                t_table_desc = data_i['measurement']
            else:
                t_table_desc = None
            self.get_test_id(t_table_desc) #todo: debateable, for now use x_data desc (datagroup 1::1 datapoint); for (1::n) should leave the input None
            self.get_datagroup_id()
            # self.insert_to_file_or_string_data_table(data_i, data_tablename) #step 3
            data_i['dut_id'] = self.db_logging_dict['dut_id']
            data_i['datagroup_id'] = self.db_logging_dict['datagroup_id']
            list_data.append(data_i)
        self.db_proj.insert_new_row(table=data_tablename, new_rows=list_data)

    def log_df_flat_data_file_or_string_to_database(self, df_data, data_type, tp_val_keys):
        """
        Place Holder

        :param df_data:
        :param data_type: should be 'file' or 'string'
        :return:
        """
        df_data_keys = df_data.keys()
        if data_type.find('data')<0:
            data_tablename = data_type + '_data'
        if data_type == 'file':
            data_keys = self.file_data_keys
        else:
            data_keys = self.string_data_keys
        list_data = []
        for i in range(df_data.shape[0]):
            data_row_i = df_data.iloc[i]
            data_i =data_row_i.filter(items=data_keys).to_dict() #data_row_i[data_tablename]

            tp_val_i = data_row_i.filter(items=tp_val_keys).to_dict()  #data_row_i['tp_val']
            # todo: check if tp_x has corner info, and if it's different from previous data, if yes, need update the env_id again; maybe check it outside the loop, generate a corner_change_flag for each row
            # tp_x = data_row_i['tp_x']
            # if tp_x != {} :

            self.get_tp_id(tp_val_i)
            if self.db_logging_dict['t_table_desc_use_measurement_name']:  # this is set to false if user specify it during log_val_data call; if not use measurement name or sweep_name
                # todo: this is debatable, use input if user specify it during log_val_data call; if not use the measurement name or sweep_name which will result in each datapoint if t_test(datagroup) 1::1 datapoint
                t_table_desc = data_i['measurement']
            else:
                t_table_desc = None
            self.get_test_id(t_table_desc) #todo: debateable, for now use x_data desc (datagroup 1::1 datapoint); for (1::n) should leave the input None
            self.get_datagroup_id()
            # self.insert_to_file_or_string_data_table(data_i, data_tablename) #step 3
            data_i['dut_id'] = self.db_logging_dict['dut_id']
            data_i['datagroup_id'] = self.db_logging_dict['datagroup_id']
            list_data.append(data_i)
        self.db_proj.insert_new_row(table=data_tablename, new_rows=list_data)

    def log_float_data_to_db(self, float_data_list, tp_val_i):
        """
        Place Holder

        :param float_data_list:
        :param tp_val_i:
        :return:
        """
        list_float = []
        self.get_tp_id(tp_val_i)
        for float_data_i_r in float_data_list:
            if type(float_data_i_r ) == dict:
                float_data_i = float_data_i_r
                spec_tag = float_data_i['spec_tag'] if 'spec_tag' in float_data_i.keys() else None
            elif type(float_data_i_r )== Float_data:
                float_data_i = dict(zip(['measurement', 'description', 'value', 'units', 'dut_id'], [float_data_i_r.measurement, float_data_i_r.description,float_data_i_r.value, float_data_i_r.units, float_data_i_r.dut_id]))
                spec_tag = float_data_i_r.spec_tag
            else:
                pass # todo: not supported format

            if self.db_logging_dict['t_table_desc_use_measurement_name']:  # this is set to false if user specify measurement_group_desc during log_val_data call; if not use measurement name or sweep_name
                # todo: this is debatable, use input if user specify it during log_val_data call; if not use the measurement name or sweep_name which will result in each datapoint if t_test(datagroup) 1::1 datapoint
                t_table_desc = float_data_i['measurement']
            else:
                t_table_desc = None
            self.get_test_id(t_table_desc)
            self.get_datagroup_id()

            self.get_float_data_limits_id(float_data_i['measurement'], spec_tag)
            dut_id = self.db_logging_dict['dut_id'] if float_data_i['dut_id'] is None else float_data_i['dut_id'] # use default if not specified
            float_data_i['dut_id'] = dut_id #self.db_logging_dict['dut_id']
            float_data_i['datagroup_id'] = self.db_logging_dict['datagroup_id']
            float_data_i['limits_id'] = self.db_logging_dict['limits_id']
            float_data_i['limits_version'] = 0  # hard-code to 0
            float_data_i['error_code'] = 0  # hard-code to 0
            list_float.append(float_data_i)
        self.db_proj.insert_new_row(table='float_data', new_rows=list_float)

    def log_string_or_file_data_to_db(self, data_list, data_type, tp_val_i):
        """
        Place Holder

        :param data_list:
        :param data_type: should be 'string_data', 'file_data', 'file' or 'string'
        :param tp_val_i:
        :return:
        """

        if data_type in ['string','file']:
            data_tablename = data_type + '_data'
        elif data_type in ['string_data','file_data']:
            data_tablename = data_type
        else:
            raise ValueError("data_type: should be 'string_data', 'file_data', 'file' or 'string'")
        if data_type.find('file')>=0:
            data_keys = self.file_data_keys
        else:
            data_keys = self.string_data_keys

        list_data =[]
        self.get_tp_id(tp_val_i)
        for data in data_list:
            if type(data)  == dict:
                data_i = data
            else: # String_data or File_data:
                data_i = vars(data) # data.__dict__


            if self.db_logging_dict['t_table_desc_use_measurement_name']:  # this is set to false if user specify measurement_group_desc during log_val_data call; if not use measurement name or sweep_name
                # todo: this is debatable, use input if user specify it during log_val_data call; if not use the measurement name or sweep_name which will result in each datapoint if t_test(datagroup) 1::1 datapoint
                t_table_desc = data_i['measurement']
            else:
                t_table_desc = None
            self.get_test_id(t_table_desc)
            self.get_datagroup_id()
            if data_i['dut_id'] is None:
                data_i['dut_id'] = self.db_logging_dict['dut_id']  # use default if not specified
            data_i['datagroup_id'] = self.db_logging_dict['datagroup_id']
            list_data.append(data_i)
        self.db_proj.insert_new_row(table=data_tablename, new_rows=list_data)
        pass

    def log_sweep_to_database(self, sweep_i):
        """
        Place Holder

        :param sweep_i:
        :return:
        """
        sweep_name = sweep_i['sweep_name'] # ['sweep_name', 'series_list', 'tp_x', 'tp_val']
        series_list = sweep_i['series_list'] #dict_keys(['label', 'units', 'series_type', 'series_data'])
        tp_x_i = sweep_i['tp_x']
        tp_val_i = sweep_i['tp_val']
        self.get_tp_id(tp_val_i)
        if self.db_logging_dict['t_table_desc_use_measurement_name']:  # this is set to false if user specify it during log_val_data call; if not use measurement name or sweep_name
        # todo: this is debatable, use input if user specify it during log_val_data call; if not use the measurement name or sweep_name which will result in each datapoint if t_test(datagroup) 1::1 datapoint
            t_table_desc = sweep_name
        else:
            t_table_desc = None
        self.get_test_id(t_table_desc) #todo: debateable, for now use sweep_name (datagroup 1::1 datapoint); for (1::n) should leave the input None
        self.get_datagroup_id()
        dut_id = sweep_i['dut_id'] if 'dut_id' in sweep_i.keys() else None # use default if not specified

        # sweep_data table: datagroup_id, dut_id, sweep_name -> sweep_id
        self.get_sweep_id(sweep_name, dut_id)
        # for each series_i in series_list:
        for series_i_r in series_list: # ['label', 'units', 'series_type', 'series_data']
            #todo: check series_i type: dict or Series type->dict
            if type(series_i_r ) == dict:
                series_i = series_i_r
            elif type(series_i_r )== Series:
                series_i = dict(zip(['label', 'units', 'series_type', 'series_data'],
                                        [series_i_r.label, series_i_r.units, series_i_r.series_type, series_i_r.series_data]))
                pass
            self.get_series_id(series_i)
            series_data = series_i['series_data']
            self.log_series_data_to_database(series_data)

    def log_csv_to_database(self, data_filename = None, ignore_data = 1, test_station=None, tp_val_keys=None,bay_number=5):
        """
        Place Holder

        :param data_filename:
        :param ignore_data:
        :param test_station:
        :param tp_val_keys:
        :param bay_number:
        :return:
        """
        measurement_group_desc=None

        # if data_filename is None:
        #     data_filename = 'C:\\temp\\mahoney_temp_data\\logging_csv\\float-TestStandLogging-mahoney_emu-win10-20210510165714.csv'
        if data_filename is None or (not os.path.exists(data_filename)):
            raise ValueError(f'please enter valid csv file! file {data_filename} does not exist')
        df_data_flat = pd.read_csv(data_filename)
        df_data_flat = df_data_flat.replace(np.nan, '', regex=True)

        # find data_type
        fkeys = df_data_flat.keys()
        if 'file_path' in fkeys:
            data_type = 'file'
        elif 'sweep_name' in fkeys:
            data_type = 'sweep'
        else:
            if type(df_data_flat.loc[0,'value']) == str:
                data_type = 'string'
            else:
                data_type = 'float'

        group_by_list = ['dut_id', 'vcorner_str', 'tcorner_str', 'dc_board_id', 'eeb_board_id']
        df_data_list = self.df_flat_group_by(df_data_flat, group_by_list)
        list_2 = [df_data_flat]
        for df_data in df_data_list: #list_2:#df_data_list:
            test_category_desc = df_data.loc[df_data.index[0], 'test_category_desc']  # df_data_float['test_category_desc']
            measurement_group = df_data.loc[df_data.index[0], 'measurement_group']
            test_table_name = df_data.loc[df_data.index[0], 'test_table_name']  # 'validation'
            vcorner_str_csv = df_data.loc[df_data.index[0], 'vcorner_str']
            tcorner_str_csv = df_data.loc[df_data.index[0], 'tcorner_str']

            dut_id = int(df_data.loc[df_data.index[0], 'dut_id'])
            dc_board_id = int(df_data.loc[df_data.index[0], 'dc_board_id'])
            eeb_board_id = int(df_data.loc[df_data.index[0], 'eeb_board_id'])
            dut_id_list = dut_id
            board_id_list = [dc_board_id, eeb_board_id]
            self.setup_database_logging(test_station, dut_id_list, board_id_list, bay_number)
            # self.check_dutid_vs_otp_trim_info(dut_id, otp_trim_info)  # this is added to link dut_site to trims table with XYWAFER... info of the DUT
            self.select_test_table(test_table_name)

        # maybe multiple in one run, depends on how you sequence the test
            self.update_environment(vcorner_str_csv, tcorner_str_csv)
            self.start_new_session()
            self.set_measurement_group(measurement_group, measurement_group_desc)
            self.get_category_id(test_category_desc)
            self.set_ignore_data(ignore_data)

            if data_type == 'float':
                self.log_df_flat_data_float_to_database(df_data, tp_val_keys)
            elif data_type == 'sweep':
                print('TODO: implement sweep type')
                # TODO: implement later
                # self.log_df_flat_data_sweep_to_database(df_data, tp_val_keys)
            else:  # 'file' or 'string'
                self.log_df_flat_data_file_or_string_to_database(df_data, data_type, tp_val_keys)

    def df_flat_group_by(self, df_data_flat, group_by_list=['dut_id', 'vcorner_str', 'tcorner_str', 'dc_board_id',
                                                            'eeb_board_id']):
        """
        Place Holder

        :param df_data_flat:
        :param group_by_list:
        :return:
        """
        df_data_list=[]
        gkk = df_data_flat.groupby(group_by_list)
        for key in gkk.groups.keys():
            rows = gkk.groups[key]
            df_i = df_data_flat.iloc[gkk.groups[key]]
            df_data_list.append(df_i)
        return df_data_list

    def get_category_id(self, test_category_desc):
        """
        Place Holder

        :param test_category_desc:
        :return:
        """
        print(f'test_category_desc = {test_category_desc}')
        ids = self.db_proj.get_record_id(table='category', new_row={'description': test_category_desc})
        if len(ids) == 0:
            self.db_logging_dict['category_id']=None
            print('fail to find or insert to table category')
        else:
            self.db_logging_dict['category_id']  = ids[0]

    def set_ignore_data(self, ignore_data):
        """
        Place Holder

        :param ignore_data:
        :return:
        """
        self.db_logging_dict['ignore_data'] = ignore_data

    def get_tp_id(self, tp_val_i):
        """
        Place Holder

        :param tp_val_i:
        :return:
        """
        ids = self.db_proj.get_record_id(table=self.db_logging_dict['params_table_name'], new_row=tp_val_i)
        if len(ids) == 0:
            self.db_logging_dict['test_parameters_id'] = None
            error_str = f"Fail to find or insert to table {self.db_logging_dict['params_table_name']}"
            raise ValueError(error_str)
        else:
            self.db_logging_dict['test_parameters_id'] = ids[0]

    def get_test_id(self, t_table_desc=None):
        """
        Place Holder

        :param t_table_desc:
        :return:
        """
        # table t_validation keys:
        # ['id', 'environment_id', 'session_id', 'test_parameters_id', 'category_id', 'measurement_group', 'description', 'timestamp', 'ignore_data']

        test_table_name = self.db_logging_dict['test_table_name']
        if self.db_logging_dict['t_table_desc_use_measurement_name']:
            if t_table_desc is None:
                t_table_desc = self.db_logging_dict['measurement_group'] # if both are not specified, make it same as measurement_group
            self.db_logging_dict['t_table_desc'] = t_table_desc
        t_test_row = {'environment_id': self.db_logging_dict['environment_id'], 'session_id': self.db_logging_dict['session_id'],
                        'test_parameters_id': self.db_logging_dict['test_parameters_id'], 'category_id': self.db_logging_dict['category_id'],
                        'measurement_group': self.db_logging_dict['measurement_group'], 'description': self.db_logging_dict['t_table_desc'],
                        'ignore_data': self.db_logging_dict['ignore_data']}

        # #todo: uncomment below if choose datagroup(test_id) 1::1 data_point
        # id_last_insert = self.db_proj.insert_new_row(table=test_table_name, new_rows=t_test_row)
        # self.db_logging_dict['test_id'] = id_last_insert

        #todo: note: SCM Data correction tool may need 1::1 relation; uncomment below if choose datagroup(test_id) 1::n data_point
        ids = self.db_proj.get_record_id(table=test_table_name, new_row=t_test_row)
        if len(ids)==0:
            print(f'Fail in found or insert to table {test_table_name}') #todo error out?
            self.db_logging_dict['test_id'] = None
        else:
            self.db_logging_dict['test_id'] = ids[-1]

    def get_datagroup_id(self):
        """
        Place Holder

        :return:
        """
        ids = self.db_proj.get_record_id(table='datagroup', new_row={'test_table_name': self.db_logging_dict['test_table_name'],
                                                                 'test_id': self.db_logging_dict['test_id'],
                                                                 'session_id': self.db_logging_dict['session_id']})

        self.db_logging_dict['datagroup_id'] = ids[-1]
        #self.db_proj.insert_new_row(table='datagroup', new_rows={'test_table_name': self.db_logging_dict['test_table_name'], 'test_id': self.db_logging_dict['test_id'],'session_id': self.db_logging_dict['session_id']})

    def get_float_data_limits_id(self, float_measurement, spec_tag=None):
        """
        Place Holder

        :param float_measurement:
        :param spec_tag:
        :return:
        """
        if spec_tag is None:
            spec_id = None
        else:
            spec_exist, spec_ids = self.db_proj.check_record_exist(table='spec', new_row={'spec_tag':spec_tag})
            if spec_exist:
                spec_id = spec_ids[-1] #get the latest, may have multiple with different datasheet rev
            else:
                raise ValueError('spec_tag %s does not exist in table spec!' % (spec_tag))

        limits_table = self.db_logging_dict['limits_table_name']
        exist, ids = self.db_proj.check_record_exist(table=limits_table, new_row={'measurement': float_measurement, 'spec_id': spec_id, 'spec_tag': spec_tag})
        #todo: check for case measurement already exist in the tl_table, but the spec_id does not match the existing one, maybe error_out
        if exist:
            if len(ids) == 1:
                self.db_logging_dict['limits_id'] = ids[0]
            else:
                error_str = f'ERROR: table {limits_table} has {len(ids)} records with measurement = {float_measurement}, should be single entry for each measurement name!'
                raise ValueError(error_str)
        else:
            #todo: check for case measurement already exist in the tl_table, but the spec_id does not match the existing one, maybe error_out
            measurement_exist, ids = self.db_proj.check_record_exist(table=limits_table, new_row={'measurement': float_measurement})
            if measurement_exist:
                raise Exception('measurement %s already exist in the table %s with a different spec_id!' % (float_measurement, limits_table))
            #todo: error out
            else:
                # limits_id_list = self.db_proj.get_record_id(table=limits_table, new_row={'measurement':float_measurement, 'spec_id': spec_id})
                limits_id_list = self.db_proj.get_record_id(table=limits_table, new_row={'measurement':float_measurement, 'spec_id': spec_id, 'spec_tag':spec_tag, 'owner':os.getlogin()})

                pass
                # todo: syd tl_ table doesn't have 'spec_tag' and 'owner', should we add these two columns to it?
                # self.db_logging_dict['limits_id'] = self.db_proj.get_record_id(table=self.db_logging_dict['limits_table_name'], new_row={'measurement':float_measurement, 'spec_id': NOSPEC_spec_id[0], 'spec_tag':'NOSPEC', 'owner':os.getlogin()})
                if len(limits_id_list) == 0:
                    self.db_logging_dict['limits_id'] = None
                    error_str = f"Fail to find or insert to table {self.db_logging_dict['limits_id']}"
                    raise ValueError(error_str)
                else:
                    self.db_logging_dict['limits_id'] = limits_id_list[0]

    def insert_to_string_data_table(self, file_data_i):
        """
        Place Holder

        :param file_data_i:
        :return:
        """
        # file_data table: ['id', 'datagroup_id', 'dut_id', 'measurement', 'description', 'file_path', 'file_dir', 'file_name', 'file_extension']
        new_file_data = file_data_i #file_data keys: ['measurement', 'description', 'file_path', 'file_dir', 'file_name', 'file_extension']
        new_file_data['dut_id'] = self.db_logging_dict['dut_id']
        new_file_data['datagroup_id'] = self.db_logging_dict['datagroup_id']
        self.db_proj.insert_new_row(table='file_data', new_rows=new_file_data)

    def get_sweep_id(self, sweep_name, dut_id = None):
        """
        Place Holder

        :param sweep_name:
        :param dut_id:
        :return:
        """
        # sweep_data table: datagroup_id, dut_id, sweep_name -> sweep_id
        if dut_id is None:
            dut_id = self.db_logging_dict['dut_id']
        ids = self.db_proj.get_record_id(table='sweep_data', new_row={'datagroup_id':self.db_logging_dict['datagroup_id'], 'dut_id':dut_id, 'sweep_name':sweep_name})
        self.db_logging_dict['sweep_id'] = ids[0]
        pass

    def get_series_id(self, series):  #['label', 'units', 'series_type', 'series_data']
        """
        Place Holder

        :param series:
        :return:
        """
        #   series table: sweep_id, series_i(label, units, series_type) -> series_id
        ids = self.db_proj.get_record_id(table='series', new_row={'sweep_id':self.db_logging_dict['sweep_id'], 'label':series['label'], 'units':series['units'], 'series_type':series['series_type']})
        self.db_logging_dict['series_id'] = ids[0]

    def log_series_data_to_database(self, series_data):
        """
        Place Holder

        :param series_data:
        :return:
        """
        # table series_data: series_id, index, value, limits_id-0, limits_version-0, error_code-0
        series_data_limits_id = 0  # fix to 0 for sweep
        series_data_limits_version = 0
        series_data_error_code = 0
        list_series_data = []
        for index in range(len(series_data)):
            list_series_data.append({'series_id': self.db_logging_dict['series_id'], 'index': index, 'value':series_data[index], 'limits_id':series_data_limits_id, 'limits_version':series_data_limits_version, 'error_code':series_data_error_code })

        self.db_proj.insert_new_row(table='series_data', new_rows=list_series_data)

    def setup_database_logging(self, dut_id_list, board_id_list, bay_number, user=None):
        """
        Place Holder

        :param dut_id_list:
        :param board_id_list:
        :param bay_number:
        :param user:
        :return:
        """
        # self.get_dbs(test_station)

        self.get_dut_group_id(dut_id_list)
        self.get_board_group_id(board_id_list)
        self.get_test_station_id(bay_number)
        self.get_operator_id(user)

    def select_test_table(self, test_name='validation'):
        """
        Place Holder

        :param test_name:
        :return:
        """
        t_table_name = f't_{test_name}'
        exist, tests_list = self.db_proj.get_records(table='tests', new_row={'test_table_name': t_table_name})
        if exist:
            self.db_logging_dict['test_table_name'] = tests_list[0]['test_table_name']
            self.db_logging_dict['params_table_name'] = tests_list[0]['params_table_name']
            self.db_logging_dict['limits_table_name'] = tests_list[0]['limits_table_name']
        else:
            error_str = f'tables for {test_name} do not exist in tests table, please create set of tables in database {self.db_proj.dbname}'
            raise ValueError(error_str)

    def update_environment(self, vcorner_str=None, tcorner_str=None, temp=None):
        """
        Place Holder

        :param vcorner_str:
        :param tcorner_str:
        :param temp:
        :return:
        """
        # todo: for corner cases does not exist in database
        self.db_logging_dict['vcorner_str'] = vcorner_str
        self.db_logging_dict['tcorner_str'] = tcorner_str
        self.get_tcorner_id(tcorner_str, temp)
        self.get_vcorner_id(vcorner_str)

        id_list = self.db_proj.get_record_id(table='environment', new_row={'tcorner_id': self.db_logging_dict['tcorner_id'], 'vcorner_id':self.db_logging_dict['vcorner_id']})
        self.db_logging_dict['environment_id'] = id_list[0]

    def start_new_session(self, force_start = True):
        """
        Place Holder

        :param force_start:
        :return:
        """
        if (self.db_logging_dict['session_id'] is None) or force_start:
            new_row_id = self.db_proj.insert_new_row(table='session', new_rows={'dut_group_id': self.db_logging_dict['dut_group_id'],
                                                               'board_group_id': self.db_logging_dict['board_group_id'],
                                                               'test_station_id': self.db_logging_dict['test_station_id'],
                                                               'operator_id': self.db_logging_dict['operator_id'],
                                                               'logfile_path': ' ', # todo: session logfile path? are we generate session file in python?
                                                               'logfile_name': ' '}) #self.db_logging_dict['logfile_name']

            self.db_logging_dict['session_id'] = new_row_id
            print(f'start new session: session_id = {new_row_id}')
        pass

    def set_measurement_group(self, measurement_group, measurement_group_desc):
        """
        Place Holder

        :param measurement_group:
        :param measurement_group_desc: if is None, t_table will use each measurement name as desc -> 1:1 between t_table/datagroup and measurement; else 1:n between t_table/datagroup and measurement
        :return:
        """
        if measurement_group_desc is None:
            self.db_logging_dict['t_table_desc_use_measurement_name'] = True #todo: 1:1. or 1:multiple
        else:
            self.db_logging_dict['t_table_desc_use_measurement_name'] = False
            self.db_logging_dict['t_table_desc'] = measurement_group_desc
        self.db_logging_dict['measurement_group'] = measurement_group

    def get_dbs(self, test_station):
        #todo: delete this method
        pass
    #     self.db_proj = self.container.db_proj # test_station.val_database_tool.db_proj
    #     self.db_boards = self.container.db_boards # test_station.val_database_tool.db_boards
    #     self.db_lab = self.container.db_lab # test_station.val_database_tool.db_lab

    def get_tcorner_id(self, tcorner_str=None, temp=None):
        """
        Place Holder

        :param tcorner_str:
        :param temp:
        :return:
        """
        pass
        tcorner_id = None
        if tcorner_str is not None:
            exist, id_list = self.db_proj.check_record_exist(table='tcorner', new_row={'tcorner_str': tcorner_str})
            if exist:# & len(id_list)==1:
                tcorner_id = id_list[0]
            else:
                exist, tcorner_str_list = self.db_proj.run_query('SELECT tcorner_str FROM tcorner')
                error_str = f'tcorner_str {tcorner_str} does not exist in database, here is the valid list: {tcorner_str_list}'
                raise ValueError(error_str)
        elif temp is not None:
            exist, id_list = self.db_proj.check_record_exist(table='tcorner', new_row={'tempeture': temp})
            if exist:
                tcorner_id = id_list[0]
            else:
                exist, temperature_list = self.db_proj.run_query('SELECT temperature FROM tcorner')
                error_str = f'temperature {temp} does not exist in database, here is the valid list: {temperature_list}'
                raise ValueError(error_str)
        else:
            error_str = 'please input tcorner_str or temp'
            raise ValueError(error_str)
        self.db_logging_dict['tcorner_id'] = tcorner_id

    def get_vcorner_id(self, vcorner_str):
        """
        Place Holder

        :param vcorner_str:
        :return:
        """
        vcorner_id = None
        exist, id_list = self.db_proj.check_record_exist(table='vcorner', new_row={'vcorner_str': vcorner_str})
        if exist:
            vcorner_id = id_list[0]
        else:
            exist, vcorner_str_list = self.db_proj.run_query('SELECT vcorner_str FROM vcorner')
            error_str = f'vcorner_str {vcorner_str} does not exist in database, here is the valid list: {vcorner_str_list}'
            raise ValueError(error_str)
        self.db_logging_dict['vcorner_id'] = vcorner_id

    def get_board_group_id(self, board_id_list):
        """
        Place Holder

        :param board_id_list:
        :return:
        """
        #todo: check below query to see if able to simplyfy the step
        # SELECT DISTINCT board_group_id FROM boards.board_group_member WHERE board_id IN (20768, 21817) GROUP BY board_group_id HAVING COUNT(*)=2

        # x, brd_grp_list_i = self.db_boards.run_query(f'SELECT board_group_id FROM boards.board_group_member WHERE board_id = {board_id_list[0]}')
        # list_0 = []
        # for brd_grp_i in brd_grp_list_i:
        #     list_0.append(brd_grp_i['board_group_id'])
        #
        # common_list = list_0
        # for idx in range(1,len(board_id_list)):
        #     x, brd_grp_list_i = self.db_boards.run_query(f'SELECT board_group_id FROM boards.board_group_member WHERE board_id = {board_id_list[idx]}')
        #     list_i = []
        #     for brd_grp_i in brd_grp_list_i:
        #         list_i.append(brd_grp_i['board_group_id'])
        #     common_list = list(set(common_list) & set(list_i))
        #     # print(f'idx ={idx}; common_list = {common_list}')
        # if len(common_list) == 0:
        #     # does not exist, insert a new in board_group, -> board_group_id
        #     board_group_id = self.db_boards.insert_new_row(table='board_group', new_rows={})
        #
        #     # then insert all boards from board_id_list with board_group_id to board_group_member table
        #     for board_id in board_id_list:
        #         self.db_boards.insert_new_row(table='board_group_member', new_rows={'board_group_id': board_group_id, 'board_id': board_id})
        # else:
        #     board_group_id = common_list[0]

        converted_list = [str(element) for element in board_id_list]
        board_id_list_str = f'({",".join(converted_list)})'
        q_str = f"SELECT DISTINCT board_group_id FROM boards.board_group_member WHERE board_id IN {board_id_list_str} GROUP BY board_group_id HAVING COUNT(*)={len(board_id_list)}"
        exist, list_dict = self.db_boards.run_query(q_str)
        if exist:
            board_group_id = list_dict[0]['board_group_id']
        else:
            # does not exist, insert a new in board_group, -> board_group_id
            board_group_id = self.db_boards.insert_new_row(table='board_group', new_rows={})

            # then insert all boards from board_id_list with board_group_id to board_group_member table
            for board_id in board_id_list:
                self.db_boards.insert_new_row(table='board_group_member', new_rows={'board_group_id': board_group_id, 'board_id': board_id})

        self.db_logging_dict['board_group_id'] = board_group_id

    def get_dut_group_id(self, dut_id_list):
        """
        Place Holder

        :param dut_id_list:
        :return:
        """
        if type(dut_id_list) == int:
            dut_id = dut_id_list
        elif type(dut_id_list) == list and len(dut_id_list) == 1:
            dut_id = dut_id_list[0]
        else:
            dut_id=None # multip DUTs
            pass

        if dut_id is not None:
            exist, dut_grp_id = self.db_proj.run_query(f'SELECT dut_group_id FROM dut_group_member WHERE dut_id={dut_id}')
            if exist:
                dut_group_id = dut_grp_id[0]['dut_group_id']
            else:
                # if new dut_id does not exist in table dut_group_member, need insert a row in table dut_group
                dut_group_id = self.db_proj.insert_new_row(table='dut_group', new_rows={})
                # then insert a new row in dut_group_member table with pair of dut_group_id and dut_id
                self.db_proj.insert_new_row(table='dut_group_member', new_rows={'dut_group_id': dut_group_id, 'dut_id': dut_id})
        else:
            # todo: if multiple duts in the test, modify below
            print('TO DO: multiple duts in the test, modify below codes')
            pass
            # x, brd_grp_list_i = self.db_boards.run_query(f'SELECT board_group_id FROM boards.board_group_member WHERE board_id = {board_id_list[0]}')
            # list_0 = []
            # for brd_grp_i in brd_grp_list_i:
            #     list_0.append(brd_grp_i['board_group_id'])
            #
            # common_list = list_0
            # for idx in range(1,len(board_id_list)):
            #     x, brd_grp_list_i = self.db_boards.run_query(f'SELECT board_group_id FROM boards.board_group_member WHERE board_id = {board_id_list[idx]}')
            #     list_i = []
            #     for brd_grp_i in brd_grp_list_i:
            #         list_i.append(brd_grp_i['board_group_id'])
            #     common_list = list(set(common_list) & set(list_i))
            #     # print(f'idx ={idx}; common_list = {common_list}')
            #     if len(common_list) == 0:
            #         # print(f'common is empty')
            #         break
            #
            # print(f'common_list = {common_list}')
            # if len(common_list) == 0:
            #     # does not exist, insert a new in board_group, -> board_group_id
            #     exist, id_max_list = self.db_boards.run_query(f'SELECT MAX(id) FROM boards.board_group')
            #     id_max_old = id_max_list[0]['MAX(id)']
            #     self.db_boards.insert_new_row(table='board_group', new_rows={'id':id_max_old+1})
            #     exist, id_max_list = self.db_boards.check_record_exist(table='board_group', new_row={'id': id_max_old + 1})
            #     if exist:
            #         board_group_id = id_max_list[0]
            #         # then insert all boards from board_id_list with board_group_id to board_group_member table
            #         for board_id in board_id_list:
            #             self.db_boards.insert_new_row(table='board_group_member',
            #                                                                          new_rows={'board_group_id': board_group_id, 'board_id': board_id})
            #     else:
            #         # it should exist, add more check here ...
            #         pass
            # else:
            #     board_group_id = common_list[0]
            # return board_group_id
        self.db_logging_dict['dut_group_id'] = dut_group_id
        self.db_logging_dict['dut_id'] = dut_id

    def get_operator_id(self, user_name=None):
        """
        Place Holder

        :param user_name:
        :return:
        """
        if user_name is None:
            user_name = os.getlogin()
        exist, operator_id_list = self.db_lab.check_record_exist(table='operator', new_row={'username': user_name})
        if exist:
            self.db_logging_dict['operator_id'] = operator_id_list[0]
        else:
            # error out?
            pass

    def get_test_station_id(self, bay_number, station_description=None):
        """
        Place Holder

        :param bay_number:
        :param station_description:
        :return:
        """
        if station_description is None:
            ids = self.db_lab.get_record_id(table='test_station', new_row={'bay_number':bay_number})
        else:
            ids = self.db_lab.get_record_id(table='test_station', new_row={'bay_number': bay_number,
                                                                                 'description': station_description})
        self.db_logging_dict['test_station_id'] = ids[0]

    def generate_id(self, level=1, recursive=True, dbg_dict=None):
        return 0
    # def check_dutid_vs_otp_trim_info(self, dut_id, otp_trim_info):
    #     # this is added for mahoney to record dut to trims table (otp_dev_id, X/Y/WAFER/lot_id ...) set dut.site = trims_id
    #     trims_id = self.db_proj.get_record_id(table='trims', new_row=otp_trim_info)
    #     exist, dut_list = self.db_proj.run_query(f'SELECT * from dut WHERE id = {dut_id}')
    #     if exist & len(trims_id)>0:
    #         if dut_list[0]['site'] == 1:
    #             try:
    #                 self.db_proj.run_query(f'UPDATE dut SET site = {trims_id[0]} WHERE id = {dut_id}', return_expected=False)
    #             except Exception as e:
    #                 print(e)

# vdt = ValDataTool()
