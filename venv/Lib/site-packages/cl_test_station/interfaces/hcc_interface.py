"""
Module for HCC interface and related classes.
Author: Evan Canter <evan.canter@gmail.com>
"""
from queue import Empty
from typing import Callable
from typing import List, Union

import cl_test_station.host_controllers.host_controller.host_controller as host_controller
import cl_test_station.interfaces.hcc as hcc
import cl_test_station.interfaces.hcc.config as hcc_cfg
import cl_test_station.interfaces.hcc.exceptions as hcc_exc
from cl_test_station.interfaces.ctrl_interface import CtrlInterface, map_word, build_word, \
    build_words_from_bytes, map_words_to_bytes, CtrlInterfaceError
from cl_test_station.interfaces.hcc.enums import HccDMaxOps, HccDMaxRegIncr, HccDMaxFifoIncr
from cl_test_station.interfaces.hcc.packets import HccPacket, DeviceDMaxReadPacket, DeviceReadBlockPacket, \
    DeviceWriteBlockPacket, DeviceNoOpPacket, DeviceDMaxWritePacket, HccDevicePacket, HccHostPacket, \
    HostDMaxWritePacket, HostWriteBlockPacket, HostReadBlockPacket, HostNoOpPacket, HostDMaxReadPacket, \
    parse_read_packet
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.ts_function_serializer import func_dumps


class PacketQueueAdder:
    """Custom context manager that queues up hcc function calls without having to specify the 'queue' key word argument

    Supported operations:

        - Register writes (including .value calls), block writes, chain writes
        - All hcc specific functions (any class method that starts with hcc\_)

    Unsupported operations:

        - All high level read operations (read_register, block_read, chain_read, verify)
        - Field reads and writes
        - Optimized writes and reads
    """

    def __init__(self, hcc_interface):
        self.hcc_interface: HccInterface = hcc_interface
        self.log = self.hcc_interface.log

    def __enter__(self):
        """Enables force queuing, disables component write verification"""
        # TODO: Enable register reads and field transactions
        self.interface_force_queue = self.hcc_interface.force_queue_all_packets
        self.hcc_interface.force_queue_all_packets = True  # Enable queuing by default
        self.component_verify_writes = self.hcc_interface.component.verify_writes
        # Cannot perform verification since queue'ing prevents immediate returns
        self.hcc_interface.component.verify_writes = False
        self.log.debug(f"Turning {self.hcc_interface.path}'s write verification off")
        # Track how many packets were added inside the with block
        self.init_queue_len = self.hcc_interface.queue_length

    def __exit__(self, exc_type, exc_val, exc_tb):
        """restore any altered flags, executes packet queue if 'packets_in' list was passed into __init__"""
        self.hcc_interface.force_queue_all_packets = self.interface_force_queue  # Resotre property to original value
        self.log.debug(f"Added {self.hcc_interface.queue_length - self.init_queue_len} packets to the queue")
        # Restore original verify_writes value
        self.hcc_interface.component.verify_writes = self.component_verify_writes
        self.log.debug(f"Restoring {self.hcc_interface.path}'s write verification flag to {self.component_verify_writes}")


class PacketQueueExecutor(PacketQueueAdder):
    """Custom context manager that extends PacketQueueAdder functionality by executing the queue on __exit__."""

    def __init__(self, hcc_interface, packets_in: list):
        super().__init__(hcc_interface)
        self.packets_in: list = packets_in  # Mutable list reference to populate with HccDevicePackets

    def __exit__(self, exc_type, exc_val, exc_tb):
        super().__exit__(exc_type, exc_val, exc_tb)
        self.log.debug("Executing packet queue")
        self.packets_in.extend(self.hcc_interface.execute_packet_queue())


class HccInterface(CtrlInterface):
    """HCC interface. Handles packet building and parsing."""
    num_endpoints: int = TsoField(ftype=int, desc='Number of endpoints supported by HCC Device')
    raise_status_errors: bool = TsoField(ftype=bool, required=False, default=True,
                                         desc='When True, any HCC Status errors received will result in an exception')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.hcc_config = hcc.config
        self.hcc_config.EP_WORD_WIDTH = self.read_reg_data_size
        self.hcc_config.DMAX_WORD_WIDTH = self.read_reg_data_size
        self.__packet_list = []
        self.__prev_packet = None  # Pointer to previous packet sent for error handling
        self._hint_handler = None
        self.force_queue_all_packets = False

    def construct_registers(self):  # TODO: Find better spot for this, and make it controller generic
        """
        After host controllers have been connected, enable HCC in active controller.

        :return: None
        :rtype: None
        """
        # This function runs after all host controllers are connected
        self.enable()

    def enable(self, controller=None):
        """
        Enables HCC and sets the bus speed

        :param controller: Target Host controller. If none given, will use component's active_controller
        :type controller: object
        :return: None
        """
        if controller is None:
            controller = self.component.active_controller
        controller.enable_hcc(**self.fields)
        controller.hcc_set_speed(**self.fields)

    def disable(self, controller=None):
        """
        Disables HCC

        :param controller: Target Host controller. If none given, will use component's active_controller
        :type controller: object
        :return: None
        """
        if controller is None:
            controller = self.component.active_controller
        controller.disable_hcc(**self.fields)

    # # ----- Generic Interface functions -----  # #

    def read_register(self, host_controller: object, reg_addr: int, **kwargs) -> int:
        """
        Uses DMAX command to read value at address 'reg_addr'

        :param host_controller: Reference to controller to use **NOTE: This parameter is currently not being used**
        :type host_controller: host_controller.HostController
        :param reg_addr: Register address
        :type reg_addr: int
        :return: Register value
        :rtype: int
        """
        if self.force_queue_all_packets:  # Cannot perform reads when force queueing since read_payload will be None
            raise CtrlInterfaceError("Cannot perform register read while queuing packets")
        return build_word(self.hcc_dmax_reg_read(dmax_addr=reg_addr, hcc_count=self.read_reg_data_size).read_payload,
                          4, hcc_cfg.HCC_BYTE_ORDER)

    def write_register(self, host_controller: object, reg_addr: int, write_data: int, **kwargs):
        """
        Uses DMAX command to write 'write_data' to address 'reg_addr'

        :param host_controller: Reference to controller to use **NOTE: This parameter is currently not being used**
        :type host_controller: host_controller.HostController
        :param reg_addr: Register address
        :type reg_addr: int
        :param write_data: Value to write
        :type write_data: int
        :return: None
        """
        self.hcc_dmax_reg_write(dmax_addr=reg_addr, payload=map_word(write_data, self.write_reg_data_size, hcc_cfg.HCC_BYTE_ORDER))

    def block_read(self, host_controller: object, start_addr: int, word_count: int) -> List[int]:
        """
        Uses DMAX RREG to read 'word_count' words from start address 'start_addr'

        :param host_controller: Reference to controller to use **NOTE: This parameter is currently not being used**
        :type host_controller: host_controller.HostController
        :param start_addr: Start address of the block read
        :type start_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :return: List of words read
        :rtype: List[int]
        """
        if self.force_queue_all_packets:  # Cannot perform reads when force queueing since read_payload will be None
            raise CtrlInterfaceError("Cannot perform block read while queuing packets")
        rreg_packet_d = self.hcc_dmax_reg_read(dmax_addr=start_addr, hcc_count=word_count*self.read_reg_data_size)
        return build_words_from_bytes(rreg_packet_d.read_payload, 4, hcc_cfg.HCC_BYTE_ORDER)

    def block_write(self, host_controller: object, start_addr: int, write_data: List[int]):
        """
        Uses DMAX WREG to write 'write_data' to start address 'start_addr'

        :param host_controller: Reference to controller to use **NOTE: This parameter is currently not being used**
        :type host_controller: host_controller.HostController
        :param start_addr: Start address of the block write
        :type start_addr: int
        :param write_data: List of words to write
        :type write_data: List[int]
        :return: None
        """
        payload = map_words_to_bytes(write_data, self.write_reg_data_size, hcc_cfg.HCC_BYTE_ORDER)
        self.hcc_dmax_reg_write(dmax_addr=start_addr, payload=payload)

    # # ----- HCC Specific functions -----  # #

    def hcc_no_op(self, hdr_chk_h: int = None, queue: bool = False, cs_delay: int = None) -> DeviceNoOpPacket:
        """
        Sends a NOOP Command to the Device and returns a tuple containing the HCC_STATUS, HCC_RSP_CHK_D, and HCC_HDR_CHK_D

        :param hdr_chk_h: (Optional) HDR checksum error injection. If None, correct checksum is calculated
        :type hdr_chk_h: int
        :param queue: When True, will add NOOP Packet to a queue instead of issuing it. Use execute_packet_queue() to issue
        :type queue: bool
        :param cs_delay: CS deassertion time in usec
        :type cs_delay: int
        :return: Return packet from device
        :rtype: DeviceNoOpPacket
        """
        out_packet = HostNoOpPacket(hdr_chk_h=hdr_chk_h)
        return self.__handle_packet_request(out_packet, queue, cs_delay)

    def hcc_dmax_reg_write(self, dmax_addr: int, payload: List[int], dmax_incr=HccDMaxRegIncr.PLD_1_ADDR_1,
                           hcc_count: int = None, hdr_chk_h: int = None, wpld_chk_h: int = None, queue: bool = False,
                           cs_delay: int = None) -> DeviceDMaxWritePacket:
        """
        Issues a DMAX WREG command

        :param dmax_addr: Address of reg write
        :type dmax_addr: int
        :param payload: Write payload, list of Bytes
        :type payload: list
        :param dmax_incr: value of DMAX_INCR (bits [5:4] of D_ARGS)
        :type dmax_incr: HccDMaxRegIncr
        :param hcc_count: (Optional) HCC_COUNT error injection. If None, uses length of payload as count
        :type hcc_count: int
        :param hdr_chk_h: (Optional) HDR checksum error injection. If None, correct checksum is calculated
        :type hdr_chk_h: int
        :param wpld_chk_h: (Optional) Payload checksum error injection. If None, correct checksum is calculated
        :type wpld_chk_h: int
        :param queue: When True, will add WREG Packet to a queue instead of issuing it. Use execute_packet_queue() to issue
        :type queue: bool
        :param cs_delay: CS deassertion time in usec
        :type cs_delay: int
        :return: Return packet from device
        :rtype: DeviceDMaxWritePacket
        """
        # Create packet dataclass
        out_packet = HostDMaxWritePacket(dmax_op=HccDMaxOps.WREG, dmax_incr=dmax_incr, dmax_addr=dmax_addr,
                                         write_payload=payload, hcc_count=hcc_count, hdr_chk_h=hdr_chk_h, wpld_chk_h=wpld_chk_h)
        # Check ranges of fields
        if out_packet.hcc_count % hcc_cfg.DMAX_WORD_WIDTH:  # Not aligned
            raise hcc_exc.HccAlignmentError(out_packet.hcc_count, hcc_cfg.DMAX_WORD_WIDTH)
        if out_packet.hdr_chk_h < 0 or out_packet.hdr_chk_h > 256**hcc_cfg.HCC_HDR_CHK_SIZE-1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_HDR_CHK_SIZE)
        if out_packet.wpld_chk_h < 0 or out_packet.wpld_chk_h > 256**hcc_cfg.HCC_PLD_CHK_SIZE-1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_PLD_CHK_SIZE)
        # Send packet and return response
        return self.__handle_packet_request(out_packet, queue, cs_delay)

    def hcc_dmax_fifo_write(self, dmax_addr: int, payload: List[int], dmax_incr=HccDMaxFifoIncr.PLD_4_ADDR_0,
                            hdr_chk_h: int = None, hcc_count: int = None, wpld_chk_h: int = None, queue: bool = False,
                            cs_delay: int = None) -> DeviceDMaxWritePacket:
        """
        Issues a DMAX WFIFO command

        :param dmax_addr: Address of fifo write
        :type dmax_addr: int
        :param payload: Write payload, list of Bytes
        :type payload: list
        :param dmax_incr: value of DMAX_INCR (bits [5:4] of D_ARGS)
        :type dmax_incr: HccDMaxRegIncr
        :param hcc_count: (Optional) HCC_COUNT error injection. If None, uses length of payload as count
        :type hcc_count: int
        :param hdr_chk_h: (Optional) HDR checksum error injection. If None, correct checksum is calculated
        :type hdr_chk_h: int
        :param wpld_chk_h: (Optional) Payload checksum error injection. If None, correct checksum is calculated
        :type wpld_chk_h: int
        :param queue: When True, will add WFIFO Packet to a queue instead of issuing it. Use execute_packet_queue() to issue
        :type queue: bool
        :param cs_delay: CS deassertion time in usec
        :type cs_delay: int
        :return: Return packet from device
        :rtype: DeviceDMaxWritePacket
        """
        # Create packet dataclass
        out_packet = HostDMaxWritePacket(dmax_op=HccDMaxOps.WFIFO, dmax_incr=dmax_incr, dmax_addr=dmax_addr,
                                         write_payload=payload, hcc_count=hcc_count, hdr_chk_h=hdr_chk_h, wpld_chk_h=wpld_chk_h)
        # Check ranges of fields
        if out_packet.hcc_count % hcc_cfg.DMAX_WORD_WIDTH:  # Not aligned
            raise hcc_exc.HccAlignmentError(out_packet.hcc_count, hcc_cfg.DMAX_WORD_WIDTH)
        if out_packet.hdr_chk_h < 0 or out_packet.hdr_chk_h > 256 ** hcc_cfg.HCC_HDR_CHK_SIZE - 1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_HDR_CHK_SIZE)
        if out_packet.wpld_chk_h < 0 or out_packet.wpld_chk_h > 256 ** hcc_cfg.HCC_PLD_CHK_SIZE - 1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_PLD_CHK_SIZE)
        # Send packet and return response
        return self.__handle_packet_request(out_packet, queue, cs_delay)

    def hcc_dmax_reg_read(self, hcc_count:int, dmax_addr: int, dmax_incr=HccDMaxRegIncr.PLD_1_ADDR_1,
                          hdr_chk_h: int = None, queue: bool = False, cs_delay: int=None) -> DeviceDMaxReadPacket:
        """
        Issues a DMAX RREG command

        :param hcc_count: value of HCC_COUNT, number of Bytes to read
        :type hcc_count: int
        :param dmax_addr: Address of reg read
        :type dmax_addr: int
        :param dmax_incr: value of DMAX_INCR (bits [5:4] of D_ARGS)
        :type dmax_incr: HccDMaxRegIncr
        :param hdr_chk_h: (Optional) HDR checksum error injection. If None, correct checksum is calculated
        :type hdr_chk_h: int
        :param queue: When True, will add RREG Packet to a queue instead of issuing it. Use execute_packet_queue() to issue
        :type queue: bool
        :param cs_delay: CS deassertion time in usec
        :type cs_delay: int
        :return: Return packet from device
        :rtype: DeviceDMaxReadPacket
        """
        # Create packet dataclass
        out_packet = HostDMaxReadPacket(dmax_op=HccDMaxOps.RREG, dmax_incr=dmax_incr, dmax_addr=dmax_addr,
                                         hcc_count=hcc_count, hdr_chk_h=hdr_chk_h)
        # Check ranges of fields
        if out_packet.hcc_count % hcc_cfg.DMAX_WORD_WIDTH:  # Not aligned
            raise hcc_exc.HccAlignmentError(out_packet.hcc_count, hcc_cfg.DMAX_WORD_WIDTH)
        if out_packet.hdr_chk_h < 0 or out_packet.hdr_chk_h > 256 ** hcc_cfg.HCC_HDR_CHK_SIZE - 1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_HDR_CHK_SIZE)
        # Send packet and return response
        return self.__handle_packet_request(out_packet, queue, cs_delay)

    def hcc_dmax_fifo_read(self, hcc_count: int, dmax_addr: int, dmax_incr=HccDMaxFifoIncr.PLD_4_ADDR_0,
                           hdr_chk_h: int = None, queue: bool = False, cs_delay: int=None) -> DeviceDMaxReadPacket:
        """
        Issues a DMAX RFIFO command

        :param hcc_count: value of HCC_COUNT, number of Bytes to read
        :type hcc_count: int
        :param dmax_addr: Address of fifo read
        :type dmax_addr: int
        :param dmax_incr: value of DMAX_INCR (bits [5:4] of D_ARGS)
        :type dmax_incr: HccDMaxRegIncr
        :param hdr_chk_h: (Optional) HDR checksum error injection. If None, correct checksum is calculated
        :type hdr_chk_h: int
        :param queue: When True, will add RFIFO Packet to a queue instead of issuing it. Use execute_packet_queue() to issue
        :type queue: bool
        :param cs_delay: CS deassertion time in usec
        :type cs_delay: int
        :return: Return packet from device
        :rtype: DeviceDMaxReadPacket
        """
        # Create packet dataclass
        out_packet = HostDMaxReadPacket(dmax_op=HccDMaxOps.RFIFO, dmax_incr=dmax_incr, dmax_addr=dmax_addr,
                                         hcc_count=hcc_count, hdr_chk_h=hdr_chk_h)
        # Check ranges of fields
        if out_packet.hcc_count % hcc_cfg.DMAX_WORD_WIDTH:  # Not aligned
            raise hcc_exc.HccAlignmentError(out_packet.hcc_count, hcc_cfg.DMAX_WORD_WIDTH)
        if out_packet.hdr_chk_h < 0 or out_packet.hdr_chk_h > 256 ** hcc_cfg.HCC_HDR_CHK_SIZE - 1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_HDR_CHK_SIZE)
        # Send packet and return response
        return self.__handle_packet_request(out_packet, queue, cs_delay)

    def hcc_write_block(self, endpoint: int, payload: List[int], hcc_count: int = None, hdr_chk_h: int = None,
                        wpld_chk_h: int = None, queue: bool = False, cs_delay: int = None) -> DeviceWriteBlockPacket:
        """
        Issues a WBLK command

        :param endpoint: Target endpoint
        :type endpoint: int
        :param payload: Write payload, list of Bytes
        :type payload: list
        :param hcc_count: (Optional) HCC_COUNT error injection. If None, uses length of payload as count
        :type hcc_count: int
        :param hdr_chk_h: (Optional) HDR checksum error injection. If None, correct checksum is calculated
        :type hdr_chk_h: int
        :param wpld_chk_h: (Optional) Payload checksum error injection. If None, correct checksum is calculated
        :type wpld_chk_h: int
        :param queue: When True, will add WBLK Packet to a queue instead of issuing it. Use execute_packet_queue() to issue
        :type queue: bool
        :param cs_delay: CS desertion time in usec
        :type cs_delay: int
        :return: Return packet from device
        :rtype: DeviceWriteBlockPacket
        """
        # Create packet dataclass
        out_packet = HostWriteBlockPacket(hcc_ep=endpoint, hcc_count=hcc_count, write_payload=payload,
                                          hdr_chk_h=hdr_chk_h, wpld_chk_h=wpld_chk_h)
        # Check ranges of fields
        if out_packet.hcc_count % hcc_cfg.EP_WORD_WIDTH:  # Not aligned
            raise hcc_exc.HccAlignmentError(out_packet.hcc_count, hcc_cfg.EP_WORD_WIDTH)
        if out_packet.hdr_chk_h < 0 or out_packet.hdr_chk_h > 256 ** hcc_cfg.HCC_HDR_CHK_SIZE - 1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_HDR_CHK_SIZE)
        if out_packet.wpld_chk_h < 0 or out_packet.wpld_chk_h > 256 ** hcc_cfg.HCC_PLD_CHK_SIZE - 1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_PLD_CHK_SIZE)
        if out_packet.hcc_ep > self.num_endpoints:
            raise hcc_exc.HccEndpointError(out_packet.hcc_ep, self.num_endpoints)
        # Send packet and return response
        return self.__handle_packet_request(out_packet, queue, cs_delay)

    def hcc_read_block(self, endpoint: int, hcc_count: int, hdr_chk_h=None, queue: bool = False,
                       cs_delay: int = None) -> DeviceReadBlockPacket:
        """
        Issues a RBLK command

        :param endpoint: Target endpoint
        :type endpoint: int
        :param hcc_count: value of HCC_COUNT, number of Bytes to read
        :type hcc_count: int
        :param hdr_chk_h: (Optional) HDR checksum error injection. If None, correct checksum is calculated
        :type hdr_chk_h: int
        :param queue: When True, will add WBLK Packet to a queue instead of issuing it. Use execute_packet_queue() to issue
        :type queue: bool
        :param cs_delay: CS desertion time in usec
        :type cs_delay: int
        :return: Return packet from device
        :rtype: DeviceReadBlockPacket
        """
        out_packet = HostReadBlockPacket(hcc_ep=endpoint, hcc_count=hcc_count, hdr_chk_h=hdr_chk_h)
        # Check ranges of fields
        if out_packet.hcc_count % hcc_cfg.EP_WORD_WIDTH:  # Not aligned
            raise hcc_exc.HccAlignmentError(out_packet.hcc_count, hcc_cfg.EP_WORD_WIDTH)
        if out_packet.hdr_chk_h < 0 or out_packet.hdr_chk_h > 256 ** hcc_cfg.HCC_HDR_CHK_SIZE - 1:
            raise ValueError("hdr_ch_k must be %d Bytes" % hcc_cfg.HCC_HDR_CHK_SIZE)
        if out_packet.hcc_ep > self.num_endpoints:
            raise hcc_exc.HccEndpointError(out_packet.hcc_ep, self.num_endpoints)
        # Send packet and return response
        return self.__handle_packet_request(out_packet, queue, cs_delay)

    # # ----- HCC Interrupt functions -----  # #
    def enable_interrupt_processing(self, handler: Callable = None):
        """
        Registers server python process with the HINT signal (44) and maps a handler. The Handler gets called every
        HINT negedge, and the return value from the handler is stored in a Queue. Use ... to grab the response from the Queue

        :return: None
        """
        controller = self.component.active_controller
        if not hasattr(controller, 'hcc_driver_register'):
            raise AttributeError("Active controller is not an Audiohub. an AH3 is required for interrupt processing")
        # Serialize function
        handler_serialized = func_dumps(handler)
        # See if test station needs to be embedded
        if handler is not None and controller.ping_test_station() != str(self.find_top_level().generate_id()):
            self.log.info("Embedding Test Station into thrift server")
            self.component.find_top_level().embed_in_controller(controller)
        # Register Signal and pipe down handler
        controller.hcc_driver_unregister()
        controller.hcc_driver_register(handler_serialized)

    def disable_interrupt_processing(self):
        """
        Tells thrift server to spot responding to the HCC Interrupt line

        :return: None
        """
        controller = self.component.active_controller
        if not hasattr(controller, 'hcc_driver_unregister'):
            raise AttributeError("Active controller is not an Audiohub. an AH3 is required for interrupt processing")
        controller.hcc_driver_unregister()  # Stops sending signal 44 to python process

    def get_interrupt_response(self, timeout: float = 0):
        """
        Pops an interrupt response (handler return value) from the FIFO Queue and returns it

        :param timeout: If no response is found in queue after timeout seconds, raises exception
        :type timeout: float
        :return: Value from HCC Interrupt Queue
        :rtype: Any
        """
        controller = self.component.active_controller
        if not hasattr(controller, 'hcc_hint_queue_get'):
            raise AttributeError("Active controller is not an Audiohub. an AH3 is required for interrupt processing")
        result = controller.hcc_hint_queue_get(timeout)
        if result == '__empty':
            raise Empty
        return result

    # # ----- Custom packet functions -----  # #

    def send_bytes(self, bytes_out: List[int], cs_delay: int = None) -> List[int]:
        """
        Sends list of bytes onto physical bus and returns bytes sent from device

        :param bytes_out: Bytes to send
        :type bytes_out: list
        :param cs_delay: Chip select deassertion time in usec
        :type cs_delay: int
        :return: Return Bytes
        :rtype: list
        """
        self.log.debug("Sending: %s" % bytes_out)
        self.check_args(self.component.active_controller.hcc_send_packet, extra=['packet', 'cs_delay'])
        bytes_in = self.component.active_controller.hcc_send_packet(packet=bytes_out, cs_delay=cs_delay, **self.fields)
        self.log.debug("Received: %s" % bytes_in)
        return bytes_in

    def send_packet(self, packet: HccHostPacket, cs_delay: int = None) -> HccDevicePacket:
        """
        Sends hcc 'packet' over the physical bus and returns the response packet

        :param packet: Host packet to send over the physical bus
        :type packet: HccHostPacket
        :param cs_delay: Chip select desertion time in usec
        :type cs_delay: int
        :return: Return packet from the device
        :rtype: HccDevicePacket
        """
        if cs_delay is None:
            cs_delay = hcc_cfg.DEFAULT_CS_DELAY
        if type(cs_delay) is not int:
            raise TypeError(f"cs_delay: expected int, received {type(cs_delay)}: {cs_delay}")
        bytes_in = self.send_bytes(packet.packet, cs_delay=cs_delay)
        self.__prev_packet = packet
        in_packet = parse_read_packet(bytes_in, type(packet))
        if self.raise_status_errors:
            hcc.packets.raise_errors(self.__prev_packet, in_packet)
        return in_packet

    def __handle_packet_request(self, packet: HccHostPacket, q: bool, cs_delay: int) -> HccDevicePacket:
        """
        Either sends a packet to the bus or queues it up

        :param packet: Packet to send/queue
        :type packet: HccPacket
        :param q: flag, when True adds packet to queue instead of sending it to the bus
        :type q: bool
        :param cs_delay: CS deassertion time in usec
        :type cs_delay: int
        :return: Return packet if q is False, None if q is True
        :rtype: HccPacket
        """
        if q or self.force_queue_all_packets:
            self.queue_packet(packet, cs_delay=cs_delay)
        else:
            return self.send_packet(packet, cs_delay=cs_delay)

    @property
    def force_queue_all_packets(self) -> bool:
        """
        Property that controls packet queuing. When True, all HCC transaction functions will be queued regardless of
        input parameter.

        :return: Property value, True or False
        :rtype: bool
        """
        return self.__force_queue_all_packets

    @force_queue_all_packets.setter
    def force_queue_all_packets(self, value: bool):
        """
        Property setter. Only accepts True or False.

        :param value: New property value
        :type value: bool
        :return: None
        :rtype: None
        """
        if type(value) is not bool:
            raise ValueError(f"force_queue_all_packets setter: Expected bool, received {type(value)}: {value}")
        self.__force_queue_all_packets = value

    @property
    def queue_length(self) -> int:
        """
        Property that returns the current number of HCC packets queued

        :return: HCC Packet queue length
        :rtype: int
        """
        return len(self.__packet_list)

    def dump_queue(self):
        """
        Prints all currently queue packets to the console, in the order that they would appear on the bus.

        :return: None
        :rtype: None
        """
        self.log.info("HCC Packets currently queued, in order of transmission:")
        for pkt, _ in self.__packet_list:
            self.log.print(pkt)

    def queue_packet(self, packet:HccHostPacket, cs_delay: int = None):
        """
        Adds packet to the queue. if cs_delay is none, hcc config global DEFAULT_CS_DELAY will be used

        :param packet: Packet object to queue
        :type packet: HccHostPacket
        :param cs_delay: Number of microseconds the CS line is deasserted after packet is finished transferring
        :type cs_delay: int
        :return: None
        """
        if cs_delay is None:
            cs_delay = hcc_cfg.DEFAULT_CS_DELAY
        if type(cs_delay) is not int:
            raise TypeError(f"cs_delay: expected int, received {type(cs_delay)}: {cs_delay}")
        self.__packet_list.append((packet, cs_delay))

    def queue_packets(self, packets:Union[HccHostPacket, List[HccHostPacket]]):
        """
        Adds packets to internal queue so that they can all be issued sequentially

        :param packets: Either a single host packet or a list of host packets
        :type packets: HccHostPacket, list
        :return: None
        """
        # todo: Need to add some checking to break up into multiple lists if bytes exceed Driver tx buffer size? Find max size from Dakota
        if isinstance(packets, HccHostPacket):
            packets = [packets]
        pkt_tuples = [(p, hcc_cfg.DEFAULT_CS_DELAY) for p in packets]
        self.__packet_list.extend(pkt_tuples)

    def execute_packet_queue(self) -> List[HccDevicePacket]:
        """
        Issues entire packet queue in order, and then returns a list of the response packets in the same order

        :return: List of device packets
        :rtype: list
        """
        host_packets, cs_delays = zip(*self.__packet_list)  # Unzip list of tuples into two equal length lists
        bytes_list_out = [p.packet for p in host_packets]  # Convert list of packet objects to list of bytes
        self.check_args(self.component.active_controller.hcc_queue_packets, extra=['packets', 'cs_delays'])
        self.component.active_controller.hcc_queue_packets(packets=bytes_list_out, cs_delays=cs_delays, **self.fields)
        self.__packet_list = []
        self.log.debug('PACKETS OUT:\n' + '\n'.join([str(l) for l in host_packets]))
        self.check_args(self.component.active_controller.hcc_execute_packet_queue)
        bytes_list_in = self.component.active_controller.hcc_execute_packet_queue(**self.fields)  # Get back full list of byte lists
        device_packets = []
        for bytes_in, host_packet in zip(bytes_list_in, host_packets):
            device_packets.append(parse_read_packet(bytes_in, type(host_packet)))
        self.log.debug('PACKETS IN:\n' + '\n'.join([str(l) for l in device_packets]))
        return device_packets

    def clear_packet_queue(self):
        """
        Removes all packets from local queue

        :return: None
        """
        self.__packet_list = []

    def PacketQueueAdder(self) -> PacketQueueAdder:
        """
        Factory method that creates a PacketQueueAdder, passing reference to this interface as 1st parameter.

        :return: PacketQueueAdder instance
        :rtype: PacketQueueAdder
        """
        return PacketQueueAdder(self)

    def PacketQueueExecutor(self, packets_in: list) -> PacketQueueExecutor:
        """
        Factory method that creates a PacketQueueExecutor, passing reference to this interface as 1st parameter.

        :param packets_in: Mutable list that will get populated with Device packets after execution
        :type packets_in: list
        :return: PacketQueueAdder instance
        :rtype: PacketQueueAdder
        """
        return PacketQueueExecutor(self, packets_in)
