"""
Definitions of Packet classes for the HCC Interface

*Author:* Evan Canter <evan.canter@cirrus.com>
"""
from enum import Enum
from dataclasses import dataclass, field
from typing import List, Tuple, Type

import cl_test_station.components.component.component as component
import cl_test_station.interfaces.hcc.config as hcc_cfg
import cl_test_station.interfaces.hcc.exceptions as hcc_exc
from cl_test_station.interfaces.ctrl_interface import ByteOrder, map_word, build_word
from cl_test_station.interfaces.hcc.enums import HccCmd, HccDMaxOps, HccDMaxRegIncr, HccDMaxFifoIncr
from cl_test_station.interfaces.hcc.algorithms import hcc_hdr_checksum, hcc_rsp_checksum, hcc_pld_checksum


# # ----- HCC Status definiton ----- # #

@dataclass
class HccStatus:
    """Dataclass that processes the 4 byte HCC_STATUS from an HCC device"""
    bus_err: int = field(init=False)
    lnk_chk_fail: int = field(init=False)
    hdr_chk_fail: int = field(init=False)
    wpld_chk_fail: int = field(init=False)
    gp_int_status: int = field(init=False)
    ep_int_status: int = field(init=False)
    hcc_status_int: int = field(repr=False)

    def __post_init__(self):
        self.bus_err = self.hcc_status_int >> 8 & 0x1F         # STATUS[12:8]
        self.lnk_chk_fail = self.hcc_status_int >> 13 & 1      # STATUS[13]
        self.hdr_chk_fail = self.hcc_status_int >> 14 & 1      # STATUS[14]
        self.wpld_chk_fail = self.hcc_status_int >> 15 & 1     # STATUS[15]
        self.gp_int_status = self.hcc_status_int >> 16 & 0xFF  # STATUS[23:16]
        self.ep_int_status = self.hcc_status_int >> 24 & 0xFF  # STATUS[31:24]

    def __repr2__(self):
        return "HccStatus()"

# # ----- BaseClass definitons ----- # #

@dataclass
class HccPacket:
    """Base dataclass for all HCC packet types"""
    pass


@dataclass
class HccHostPacket(HccPacket):
    """Base dataclass for all HCC packets sent out by the Host"""
    hcc_cmd: int = HccCmd.NOOP
    hdr_chk_h: int = field(default=None)
    _hdr_chk_h: int = field(init=False, repr=False, default=None)

    def __post_init__(self):
        if type(self.hdr_chk_h) is property:
            self.hdr_chk_h = None

    @property
    def hdr_chk_h(self) -> int:
        """
        HDR host checksum. If hdr_chk_h was passed in the constructor, it will be returned. If none was passed in,
        the checksum is calculated based on the HDR bytes.

        :return: HDR host Checksum
        :rtype: int
        """
        if self._hdr_chk_h is None:  # No override, use checksum algorithm on hdr bytes
            return hcc_hdr_checksum(self.hdr)
        else:  # User override, pass it on
            return self._hdr_chk_h

    @hdr_chk_h.setter
    def hdr_chk_h(self, hdr_chk_h: int):
        """
        Setter for HDR host checksum. If set, the checksum will no longer be calculated.

        :param hdr_chk_h: Override value for HDR host checksum
        :type hdr_chk_h: int
        :return: None
        :rtype: None
        """
        self._hdr_chk_h = hdr_chk_h

    def __ser__(self, segments):
        """
        Serializes all segments into a list a bytes
        :param segments: List of Tuples containing segment value and byte width
        :return:None
        """
        bytes_out = []
        for field, size in segments:
            if not size:
                continue
            if field is 'pad_1s':  # Keyword match
                bytes_out.extend([0xff]*size)
            else:
                if size > 1:
                    bytes_out.extend(map_word(field, size, hcc_cfg.HCC_BYTE_ORDER))
                else:
                    bytes_out.append(field)
        return bytes_out

    @property
    def packet(self):
        """
        Returns packet as a list of bytes as they would appear on the Physical Bus
        :return: List of bytes
        :rtype: list
        """
        pass

    @property
    def hdr(self):
        """
        Gets HDR contents as a list of bytes

        :return: List of Bytes
        :rtype: list
        """
        pass


@dataclass
class HccHostWritePacket(HccHostPacket):
    """Base dataclass for HCC Host Write Packets, e.g. DMAX write, WBLK, etc."""
    write_payload: list = None  # List of bytes, assumed data is LSByte first
    hcc_count: int = None
    wpld_chk_h: int = field(default=None)
    _wpld_chk_h: int = field(init=False, repr=False, default=None)

    def __post_init__(self):
        if self.write_payload is None:
            if self.hcc_count:
                num_bytes = self.hcc_count
            else:
                num_bytes = hcc_cfg.EP_WORD_WIDTH if self.hcc_cmd is HccCmd.WBLK else hcc_cfg.DMAX_WORD_WIDTH
            self.write_payload = [0] * num_bytes
        if self.hcc_count is None:
            self.hcc_count = len(self.write_payload)
        super().__post_init__()
        if type(self.wpld_chk_h) is property:
            self._wpld_chk_h = None

    @property
    def wpld_chk_h(self) -> int:
        """
        Write payload host checksum. If wpld_chk_h was passed in the constructor, it will be returned. If none was
        passed in, the checksum is calculated based on the write payload bytes.

        :return: Write payload checksum
        :rtype: int
        """
        if self._wpld_chk_h is None:  # No override, calculate checksum
            return hcc_pld_checksum(self.hcc_count, self.write_payload)
        else:  # User override, pass it on
            return self._wpld_chk_h

    @wpld_chk_h.setter
    def wpld_chk_h(self, wpld_chk_h: int):
        """
        Setter for write payload host checksum. If set, the checksum will no longer be calculated.

        :param wpld_chk_h: Override value for write payload host checksum
        :type wpld_chk_h: int
        :return: None
        :rtype: None
        """
        self._wpld_chk_h = wpld_chk_h


@dataclass(repr=False)
class HccDevicePacket(HccPacket):
    """Base dataclass for all HCC packets received from an HCC device"""
    rsp_bytes: list = field(init=False, repr=False)
    hcc_status: HccStatus
    rsp_chk_d: int
    hdr_chk_d: int

    def __post_init__(self):
        self.rsp_bytes = map_word(self.hcc_status.hcc_status_int, hcc_cfg.HCC_RSP_SIZE, hcc_cfg.HCC_BYTE_ORDER)

    def non_status_repr(self) -> str:
        """
        Prints class repr without Hcc status dataclass, since it renders the other fields unreadable.

        :return: repr string
        :rtype: str
        """
        result = ''
        for name, value in self.__dict__.items():
            if name == 'hcc_status':
                result += 'hcc_status=HccStatus(), '
                continue
            elif name == 'rsp_bytes':
                continue
            result += '%s=%s, ' % (name, str(value))
        if result.endswith(', '):
            result = result[:-2]
        return result

    def __repr__(self):
        return self.__class__.__name__ + '(' + self.non_status_repr() + ')'


# # ----- No Op Packet definitons ----- # #

@dataclass(repr=False)
class DeviceNoOpPacket(HccDevicePacket):
    """Packet class for a NoOp received from a device"""
    pass

@dataclass
class HostNoOpPacket(HccHostPacket):
    """Packet class for a NoOp operation sent to a device"""
    hcc_cmd: HccCmd = HccCmd.NOOP

    def __post_init__(self):
        super().__post_init__()

    @property
    def packet(self):
        return self.__ser__([(int(self.hcc_cmd), 1), (0, hcc_cfg.HCC_HDR_SIZE-1), (0, hcc_cfg.HCC_RSP_CHK_SIZE),
                             (self.hdr_chk_h, hcc_cfg.HCC_HDR_CHK_SIZE)])

    @property
    def hdr(self):
        return self.__ser__([(int(self.hcc_cmd), 1), (0, hcc_cfg.HCC_HDR_SIZE-1)])


# # ----- R/WBLK Packet definitons ----- # #

@dataclass(repr=False)
class DeviceReadBlockPacket(HccDevicePacket):
    """Packet class for a RBLK response received from a device"""
    read_payload: list
    rpld_chk_d: int


@dataclass
class HostReadBlockPacket(HccHostPacket):
    """Packet class for a RBLK operation sent to a device"""
    hcc_cmd: HccCmd = HccCmd.RBLK
    hcc_ep: int = 0
    hcc_count: int = None

    def __post_init__(self):
        super().__post_init__()
        if self.hcc_count is None:
            self.hcc_count = hcc_cfg.EP_WORD_WIDTH

    @property
    def packet(self):
        pad_value = 0 if hcc_cfg.HCC_PAD_VALUE is 0 else 'pad_1s'
        return self.__ser__([(int(self.hcc_cmd), 1), (self.hcc_ep, 1), (self.hcc_count, 2), (0, hcc_cfg.HCC_HDR_SIZE-4),
                             (0, hcc_cfg.HCC_RSP_CHK_SIZE), (self.hdr_chk_h, hcc_cfg.HCC_HDR_CHK_SIZE),
                             (pad_value, hcc_cfg.HCC_PROC_DLY), (pad_value, self.hcc_count), (pad_value, hcc_cfg.HCC_PLD_CHK_SIZE)])

    @property
    def hdr(self):
        return self.__ser__([(int(self.hcc_cmd), 1), (self.hcc_ep, 1), (self.hcc_count, 2), (0, hcc_cfg.HCC_HDR_SIZE-4)])


@dataclass(repr=False)
class DeviceWriteBlockPacket(HccDevicePacket):
    """Packet class for a WBLK response received from a device"""
    wpld_chk_d: int


@dataclass
class HostWriteBlockPacket(HccHostWritePacket):
    """Packet class for a WBLK operation sent to a device"""
    hcc_cmd: HccCmd = HccCmd.WBLK
    hcc_ep: int = 0
    hcc_count: int = None

    @property
    def packet(self):
        payload_bytes = [(pld_byte, 1) for pld_byte in self.write_payload]
        pad_value = 0 if hcc_cfg.HCC_PAD_VALUE is 0 else 'pad_1s'
        return self.__ser__([(int(self.hcc_cmd), 1), (self.hcc_ep, 1), (self.hcc_count, 2), (0, hcc_cfg.HCC_HDR_SIZE-4),
                             (0, hcc_cfg.HCC_RSP_CHK_SIZE), (self.hdr_chk_h, hcc_cfg.HCC_HDR_CHK_SIZE),
                             (pad_value, hcc_cfg.HCC_PROC_DLY)] + payload_bytes + [(self.wpld_chk_h, hcc_cfg.HCC_PLD_CHK_SIZE)])

    @property
    def hdr(self):
        return self.__ser__([(int(self.hcc_cmd), 1), (self.hcc_ep, 1), (self.hcc_count, 2), (0, hcc_cfg.HCC_HDR_SIZE-4)])


# # ----- DMAX Packet definitons ----- # #

@dataclass(repr=False)
class DeviceDMaxReadPacket(DeviceReadBlockPacket):
    """Packet class for a DMAX read response received from a device"""
    pass


@dataclass
class HostDMaxReadPacket(HccHostPacket):
    """Packet class for a DMAX read operation sent to a device"""
    hcc_cmd: HccCmd = HccCmd.DMAX
    dmax_op: HccDMaxOps = HccDMaxOps.RREG
    dmax_incr: Enum = HccDMaxRegIncr.PLD_1_ADDR_1  # Default to 0
    hcc_count: int = None
    dmax_addr: int = 0

    def __post_init__(self):
        super().__post_init__()
        if self.hcc_count is None:
            self.hcc_count = hcc_cfg.DMAX_WORD_WIDTH

    @property
    def packet(self):
        d_args = (int(self.dmax_incr) << 4) + int(self.dmax_op)
        pad_value = 0 if hcc_cfg.HCC_PAD_VALUE is 0 else 'pad_1s'
        return self.__ser__([(int(self.hcc_cmd), 1), (d_args, 1), (self.hcc_count, 2), (self.dmax_addr, 4),
                             (0, hcc_cfg.HCC_RSP_CHK_SIZE), (self.hdr_chk_h, hcc_cfg.HCC_HDR_CHK_SIZE),
                             (pad_value, hcc_cfg.HCC_PROC_DLY), (pad_value, self.hcc_count), (pad_value, hcc_cfg.HCC_PLD_CHK_SIZE)])

    @property
    def hdr(self):
        d_args = (int(self.dmax_incr) << 4) + int(self.dmax_op)
        return self.__ser__([(int(self.hcc_cmd), 1), (d_args, 1), (self.hcc_count, 2), (self.dmax_addr, 4)])


@dataclass(repr=False)
class DeviceDMaxWritePacket(DeviceWriteBlockPacket):
    """Packet class for a DMAX write response received from a device"""
    pass


@dataclass
class HostDMaxWritePacket(HccHostWritePacket):
    """Packet class for a DMAX write operation sent to a device"""
    hcc_cmd: HccCmd = HccCmd.DMAX
    dmax_op: HccDMaxOps = HccDMaxOps.WREG
    dmax_incr: Enum = HccDMaxRegIncr.PLD_1_ADDR_1  # Default to 0
    hcc_count: int = None
    dmax_addr: int = 0

    @property
    def packet(self):
        payload_bytes = [(pld_byte, 1) for pld_byte in self.write_payload]
        d_args = (int(self.dmax_incr) << 4) + int(self.dmax_op)
        pad_value = 0 if hcc_cfg.HCC_PAD_VALUE is 0 else 'pad_1s'
        return self.__ser__([(int(self.hcc_cmd), 1), (d_args, 1), (self.hcc_count, 2), (self.dmax_addr, 4),
                             (0, hcc_cfg.HCC_RSP_CHK_SIZE), (self.hdr_chk_h, hcc_cfg.HCC_HDR_CHK_SIZE),
                             (pad_value, hcc_cfg.HCC_PROC_DLY)] + payload_bytes + [(self.wpld_chk_h, hcc_cfg.HCC_PLD_CHK_SIZE)])

    @property
    def hdr(self):
        d_args = (int(self.dmax_incr) << 4) + int(self.dmax_op)
        return self.__ser__([(int(self.hcc_cmd), 1), (d_args, 1), (self.hcc_count, 2), (self.dmax_addr, 4)])


# # ----- Pairs ----- # #
RESPONSES = {
    HostNoOpPacket: DeviceNoOpPacket,
    HostReadBlockPacket: DeviceReadBlockPacket,
    HostWriteBlockPacket: DeviceWriteBlockPacket,
    HostDMaxReadPacket: DeviceDMaxReadPacket,
    HostDMaxWritePacket: DeviceDMaxWritePacket
}


# # ----- Parsing ----- # #

def parse_read_packet(bytes_in:List[int], pkt_type:Type) -> HccDevicePacket:
    """
    Takes in raw rx bytes from physical bus and returns the corresponding DevicePacket object

    :param bytes_in: List of bytes sent from the Device
    :type bytes_in: list
    :param pkt_type: Class of expected packet, eg DeviceNoOpPacket
    :type pkt_type: Type
    :return: Packet Object
    :rtype: HccDevicePacket
    """
    pkt_type = RESPONSES[pkt_type]
    if not bytes_in:
        raise ValueError("Input list is empty, cannot parse.")
    noop_len = hcc_cfg.HCC_HDR_SIZE + hcc_cfg.HCC_HDR_CHK_SIZE + hcc_cfg.HCC_RSP_CHK_SIZE
    if len(bytes_in) < noop_len:
        raise ValueError("Expected packet of at least length %d, got %d" % (noop_len, len(bytes_in)))
    hcc_status = build_word(bytes_in[0:hcc_cfg.HCC_RSP_SIZE], hcc_cfg.HCC_RSP_SIZE, hcc_cfg.HCC_BYTE_ORDER)
    rsp_chk_d = build_word(bytes_in[hcc_cfg.HCC_HDR_SIZE:hcc_cfg.HCC_HDR_SIZE + hcc_cfg.HCC_RSP_CHK_SIZE],
                           hcc_cfg.HCC_RSP_CHK_SIZE, hcc_cfg.HCC_BYTE_ORDER)
    hdr_chk_d = build_word(bytes_in[noop_len - hcc_cfg.HCC_HDR_CHK_SIZE:noop_len], hcc_cfg.HCC_HDR_CHK_SIZE, hcc_cfg.HCC_BYTE_ORDER)
    if pkt_type is DeviceNoOpPacket:
        return pkt_type(hcc_status=HccStatus(hcc_status), rsp_chk_d=rsp_chk_d, hdr_chk_d=hdr_chk_d)
    elif pkt_type is DeviceReadBlockPacket or pkt_type is DeviceDMaxReadPacket:
        rpld_chk_d = build_word(bytes_in[-1*hcc_cfg.HCC_PLD_CHK_SIZE:], hcc_cfg.HCC_PLD_CHK_SIZE, hcc_cfg.HCC_BYTE_ORDER)
        read_payload = bytes_in[noop_len+hcc_cfg.HCC_PROC_DLY:-1*hcc_cfg.HCC_PLD_CHK_SIZE]
        return pkt_type(hcc_status=HccStatus(hcc_status), rsp_chk_d=rsp_chk_d, hdr_chk_d=hdr_chk_d,
                        read_payload=read_payload, rpld_chk_d=rpld_chk_d)
    elif pkt_type is DeviceWriteBlockPacket or pkt_type is DeviceDMaxWritePacket:
        wpld_chk_d = build_word(bytes_in[-1*hcc_cfg.HCC_PLD_CHK_SIZE:], hcc_cfg.HCC_PLD_CHK_SIZE, hcc_cfg.HCC_BYTE_ORDER)
        return pkt_type(hcc_status=HccStatus(hcc_status), rsp_chk_d=rsp_chk_d, hdr_chk_d=hdr_chk_d,
                        wpld_chk_d=wpld_chk_d)
    return None


def raise_errors(prev_pkt:HccHostPacket, in_pkt: HccDevicePacket):
    """
    Raises expections based on hcc status

    :param prev_pkt: Packet object sent to device before packet with hcc status
    :type prev_pkt: HccHostPacket
    :param in_pkt: Packet object received from device
    :type in_pkt: HccDevicePacket
    :return: None
    """
    # TODO: Find out if order matters? Raising one error will block other errors from being raised
    hcc_sts = in_pkt.hcc_status
    if hcc_sts.bus_err:
        raise hcc_exc.HccBusError(hcc_sts.bus_err)
    elif hcc_sts.lnk_chk_fail:
        raise hcc_exc.LinkLayerChecksumError()
    elif hcc_sts.hdr_chk_fail:
        raise hcc_exc.HdrChecksumError(prev_pkt.hdr_chk_h, prev_pkt.hdr)
    elif hcc_sts.wpld_chk_fail:
        if isinstance(prev_pkt, HccHostWritePacket):
            raise hcc_exc.WritePayloadChecksumError(prev_pkt.wpld_chk_h, prev_pkt.write_payload)
        else:
            raise hcc_exc.WritePayloadChecksumError()


# # ----- Unit Test ----- # #
if __name__ == '__main__':
    # Example from the 2.1.3 spec
    print(" Generic Packet Usage ".center(80, '='))
    wreg = HostDMaxWritePacket(hcc_count=8, dmax_op=HccDMaxOps.WREG, dmax_incr=HccDMaxRegIncr.PLD_1_ADDR_1,
                               write_payload=[0x11, 0x22, 0x33, 0x44, 0xF1, 0xE2, 0xD3, 0xC4])
    print("Serialized packet:")
    print(list(map(hex, wreg.packet)))
    print("HDR phase:")
    print(list(map(hex, wreg.hdr)))
    expected_wpld_chk = build_word([0xFD, 0xFA, 0xF8, 0xF6], 4, hcc_cfg.HCC_BYTE_ORDER)
    print('packet checksum:  %d, expected: %d' % (wreg.wpld_chk_h, expected_wpld_chk))
    print()

    print(" Testing all packet classes ".center(80, '='))
    import inspect
    host_cls_list = [item for item in globals().values() if inspect.isclass(item) and issubclass(item, HccHostPacket)]
    ljust = len(max([cls.__name__ for cls in host_cls_list], key=len)) + 2
    for pkt_cls in host_cls_list:
        if pkt_cls is HccHostPacket or pkt_cls is HccHostWritePacket:
            continue
        pkt = pkt_cls()
        print('Default %s: %s' % (pkt_cls.__name__.ljust(ljust), pkt))
        in_pkt = parse_read_packet([0] * len(pkt.packet), pkt_cls)
        print("Parsed  %s: %s" % (in_pkt.__class__.__name__.ljust(ljust), in_pkt))
        print()

    # Hcc Status parsing
    print(" RSP Parsing ".center(80, '='))
    rsp = [0, 0xAA, 0x55, 0xAA]  # bus_err = 10, lnk=1, hdr=0, wpld=1, gp=85, ep=170
    bytes_in = rsp + [0] * (hcc_cfg.HCC_HDR_SIZE - hcc_cfg.HCC_RSP_SIZE + hcc_cfg.HCC_RSP_CHK_SIZE + hcc_cfg.HCC_HDR_CHK_SIZE)
    pkt = parse_read_packet(bytes_in, HostNoOpPacket)  # type: DeviceNoOpPacket
    print("Simulated RSP phase:", rsp)
    print(pkt)
    print(pkt.hcc_status)
    print()

    # Error checking
    print(" Error checking ".center(80, '='))
    pkt_out = HostNoOpPacket(hdr_chk_h=0x1234)
    cases = [
        (hcc_exc.HccBusError, [0, 0x1F, 0, 0]),
        (hcc_exc.LinkLayerChecksumError, [0, 0x20, 0, 0]),
        (hcc_exc.HdrChecksumError, [0, 0x40, 0, 0]),
        (hcc_exc.WritePayloadChecksumError, [0, 0x80, 0, 0])
    ]
    for exc, rsp_bytes in cases:
        try:
            bytes_in = rsp_bytes + bytes_in[4:]
            pkt_in = parse_read_packet(bytes_in, HostNoOpPacket)  # type: DeviceNoOpPacket
            raise_errors(pkt_out, pkt_in)
        except exc as err:
            print("Injected error: %s" % err)
    print()
