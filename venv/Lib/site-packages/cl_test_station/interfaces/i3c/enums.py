from enum import Enum, auto, unique

from cl_test_station.utilities.packets.packets import PacketBase, packet_frame, PacketSteps, packetclass


class I3cEvents(Enum):
    """Enumeration for Target/Secondary controller events. used by ENEC/DISEC CCCs"""
    TARGET_INT_REQ = auto()
    MASTERSHIP_REQ = auto()
    HOT_JOIN_EVENT = auto()

    @property
    def mask(self) -> int:
        return {
            self.TARGET_INT_REQ: 0x0,
            self.MASTERSHIP_REQ: 0x2,
            self.HOT_JOIN_EVENT: 0x8
        }[self]

    def __or__(self, other) -> int:
        if isinstance(other, I3cEvents):
            other = other.mask
        return int.__or__(self.mask, other)

    def __ror__(self, other):
        if isinstance(other, I3cEvents):
            other = other.mask
        return int.__ror__(self.mask, other)

    def __invert__(self) -> int:
        return int.__invert__(self.mask)


@unique
class StatusActivityModes(Enum):
    """Enumeration for the activity mode frame in the I3C status response packet."""
    BOOT_RESET = 0
    LINK_IDLE = 1
    STANDBY = 2
    ACTIVE = 3


@unique
class BcrDeviceRoles(Enum):
    """Enumeration for the device role frame in the I3C status response packet."""
    I3C_TARGET = 0
    I3C_CONTROLLER = 1
    RESERVED_2 = 2
    RESERVED_3 = 3


@packetclass(static=True)
class I3cStatus(PacketBase):
    """Packet class for I3C Status bytes."""
    vendor_reserved: int = packet_frame(step=PacketSteps.BIT, width=8)
    activity_mode: StatusActivityModes = packet_frame(step=PacketSteps.BIT, width=2)
    protocol_error: bool = packet_frame(step=PacketSteps.BIT, width=1)
    reserved: int = packet_frame(step=PacketSteps.BIT, width=1, default=0, init=False, repr=False)
    pending_interrupt: int = packet_frame(step=PacketSteps.BIT, width=4)


@packetclass(static=True)
class I3cBcr(PacketBase):
    """Packet class for I3C Bus Characteristic Register (BCR) value."""
    device_role: BcrDeviceRoles = packet_frame(step=PacketSteps.BIT, width=2)
    reserved: int = packet_frame(step=PacketSteps.BIT, width=1, default=0, init=False, repr=False)
    is_bridge: bool = packet_frame(step=PacketSteps.BIT, width=1)
    offline_capable: bool = packet_frame(step=PacketSteps.BIT, width=1)
    ibi_payload: bool = packet_frame(step=PacketSteps.BIT, width=1)
    ibi_req_capable: bool = packet_frame(step=PacketSteps.BIT, width=1)
    max_data_speed_limited: bool = packet_frame(step=PacketSteps.BIT, width=1)
