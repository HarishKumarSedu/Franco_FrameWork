import time
import random
import logging
from typing import Union

from cl_test_station.register_map.register import Field
from cl_test_station.register_map.register import Register
from unified_modules.resources.resource_data_lib.resource_data_lib import ResourceDataLib as DataLib
from cl_test_station.interfaces.jlink_i2c_interface import JlinkI2cInterface
from cl_test_station.interfaces.nucleo_lib.sqa_packet_definitions import TestPacket
import cl_test_station.interfaces.nucleo_lib.packet_namedtuples as pkt_params
import cl_test_station.interfaces.nucleo_lib.domino_namedtuples as params

class NucleoI2cInterface(JlinkI2cInterface):

    NUCLEO_F767ZI_CONFIG = {
        'polling_timeout_sec':          25,
        'polling_interval_sec':         0.1,
        'tx_start_address':             0x20000000,
        'rx_start_address':             0x20035000,
        'tx_size_address':              0x2007d000,
        'rx_size_address':              0x2007d004,
        'test_start_address':           0x2007d008,
        'test_done_address':            0x2007d00c,
        'test_error_address':           0x2007d010,
        'fw_version_address':           0x2007d02c,
        'packet_index_address':         0x2007d014,
        'polling_timeout_address':      0x2007d018,
        'tick_rate_address':            0x2007d01c,
        'sequence_iterations_address':  0x2007d020,
        'sequence_delay_us_address':    0x2007d024,
        'add_time_stamp':               0x2007d028,
        'max_tx_size_bytes':            0x35000,
        'fpga_boot_time_secs':          35,
        'cdb_boot_time_secs':           8,
        'git_sha_address':              0x1006c
    }

    # NUCLEO_L476RG_CONFIG = {
    #     'polling_timeout_sec': 20, 'polling_interval_sec': 0.5, 'tx_start_address': 268435456,
    #     'rx_start_address': 536870912, 'tx_size_address': 536965120, 'rx_size_address': 536965124,
    #     'test_start_address': 536965128, 'test_done_address': 536965132, 'error_address': 536965136,
    #     'fw_version_address': 536965164, 'packet_index_address': 536965140, 'packet_iterations_address': 536965144,
    #     'tick_rate_address': 536965148, 'sequence_iterations_address': 536965152,
    #     'sequence_delay_us_address': 536965156, 'max_tx_size_bytes': 32768,
    #     'fpga_boot_time_secs': 35, 'cdb_boot_time_secs': 8, 'git_sha_address': 65644
    # }

    OPERATION_MODES = {
        params.i2c.STD_8: params.i2c_std.STD_8_BITS,
        params.i2c.STD_16: params.i2c_std.STD_16_BITS,
        params.i2c.STD_32: params.i2c_std.STD_32_BITS
    }

    I2C_MODE_BYTES_PER_WORD = {
        params.i2c.MODE_00: 2,
        params.i2c.MODE_11: 4,
        params.i2c.STD_16: 2,
        params.i2c.STD_32: 4
    }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.i2c_device_address = 0x74  # Default value, can be overwritten by test
        self.device_config = self.NUCLEO_F767ZI_CONFIG
        self.DataLib = DataLib()
        self.dummy_address = 0x00
        self.polling_operation_timeout_ms = None

        # Packet initializations - This functionality should be specific to nucleo_i2c_interface
        self.stimulus_packets = []
        self.response_packets = []

        self.add_time_stamp = False
        self.dut_port_mode = pkt_params.dut_port_mode.I2C_MODE

        self._log = logging.getLogger(NucleoI2cInterface.__name__)

    # @property
    # def _log(self):
    #     return self.container._log

    """
    ====================================================================================================
    Nucleo Read/Write Functions
    ====================================================================================================
    """

    def write_register(self, host_controller, reg_addr, write_data):
        super().write_register(host_controller, reg_addr, write_data)

    def read_register(self, host_controller, reg_addr):
        return super().read_register(host_controller, reg_addr)

    # def read_reg(self, target, addr, word_count, i2c_mode=None):
    #     return super().read_reg(target, addr, word_count, i2c_mode)
    #
    # def write_reg(self, target, addr, data, i2c_mode=None):
    #     return super().write_reg(target, addr, data, i2c_mode)

    """
    ====================================================================================================
    Nucleo Packet Management Functions
    ====================================================================================================
    """
    # region Nucleo Packet Management Functions

    def clear_packets(self):
        self.stimulus_packets.clear()

    def append_packet(self, packet):
        self.stimulus_packets.append(packet)

    def execute(self, wait_for_done, sequence_count=None, sequence_delay=0):
        self.stop_test()  # Performed in case previous execute aborted and test wasn't stopped
        self.write_stimulus_packets(self.stimulus_packets)
        self.enable_iterate_test(sequence_count, sequence_delay)
        self.start_test()
        return_tuple = (0, 'Return code not read')
        self.response_packets = []
        if wait_for_done:
            self.poll_test_completion()
            return_tuple = self.read_return_code()
            self.response_packets = self.get_response_packets()
        self.stop_test()
        return self.response_packets, return_tuple

    def write_stimulus_packets(self, stimulus_packets):
        """
        Write all packets contained in the stimulus packets list to the nucleo device
        """
        # Serialize all the packets in the packet list
        stimulus_buffer_bytes = []
        for packet in stimulus_packets:
            packet.serialize()
            stimulus_buffer_bytes += packet.raw_packet_bytes

        tx_size_bytes = len(stimulus_buffer_bytes)
        if tx_size_bytes > self.device_config['max_tx_size_bytes']:
            ram_available = self.device_config['max_tx_size_bytes'] / 1024.0
            ram_required = tx_size_bytes / 1024.0
            error_message = f"Not enough RAM on ST Board to transmit buffer. " \
                            f"RAM required: {ram_required:.1f} KB, RAM available: {ram_available} KB"
            raise Exception(error_message)
        addr = f"buffer address: {hex(self.device_config['tx_start_address'])}"
        self._log.info(f"Writing {len(stimulus_packets)} packets ({len(stimulus_buffer_bytes)} Bytes) to device {addr}")
        self.write_to_memory(self.device_config['tx_start_address'], stimulus_buffer_bytes, word_length=8)
        self.write_to_memory(self.device_config['tx_size_address'], tx_size_bytes, word_length=32)
        self.write_to_memory(self.device_config['add_time_stamp'], data=int(self.add_time_stamp), word_length=32)

    # endregion Nucleo Packet Management Functions
    """
    ====================================================================================================
    Nucleo Generate Packet Functions
    ====================================================================================================
    """
    # region Nucleo Generate Packet Functions
    def generate_read_packet(self, register_or_address, words_to_read=1, i2c_mode=None):
        """
        Generate an I2C read packet and append to stimulus_packets list
        :param register_or_address: A Register object, Integer address, or hex string address
        :param words_to_read: Integer number of words to read.
        :param i2c_mode: (Optional) Set packet I2C mode. Defaults based on input address.
        :return: TestPacket Object
        """
        # create a test packet with default header values
        packet = self._generate_packet(register_or_address, i2c_mode, pkt_params.op.I2C_READ)
        if not i2c_mode:
            i2c_mode = packet.header.i2c_mode
        packet.header.bytes_to_rw = words_to_read * self.I2C_MODE_BYTES_PER_WORD.get(i2c_mode, 1)
        packet.serialize()

        # Now that header is populated, serialize the packet, including the header+payload
        self.append_packet(packet)
        return packet

    def generate_write_packet(self, register_or_address: Union[Register, int, str], data=None, i2c_mode=None):
        """
        Generate an I2C write packet and append to stimulus_packets list
        :param register_or_address: A Register object, Integer address, or hex string address
        :param data: The integer data to write to the given register. If not supplied, register cache values are used
        :param i2c_mode: (Optional) Set packet I2C mode. Defaults based on input address.
        :return: TestPacket Object
        """
        if not any(isinstance(register_or_address, x) for x in [Register, int, str]):
            raise TypeError('generate_write_packet only supports Register object, int address, or hex string address')
        packet = self._generate_packet(register_or_address, i2c_mode, pkt_params.op.I2C_WRITE)

        # Write from the register cache values if no value is specified
        if data is None:
            data = register_or_address.get_cache()

        # Convert the payload to byte data and update packet fields accordingly
        packet.reg_values = [data] if not isinstance(data, list) else data
        packet.convert_register_words_to_payload_bytes()
        packet.header.bytes_to_rw = len(packet.payload_bytes)
        packet.header.payload_size_in_bytes = len(packet.payload_bytes)

        # Now that header is populated, serialize the packet, including the header+payload
        packet.serialize()
        self.append_packet(packet)
        return packet

    def generate_write_field_packet(self, bit_field: Union[Field, list], value: Union[int, list], i2c_mode=None):
        """
        Generate an I2C Polling Packet for a single or list of bit fields and append to stimulus_packets list
        :param bit_field: A Field object or list of Field objects
        :param value: Integer value or list of int values to write to the submitted bit field(s)
        :param i2c_mode: (Optional) Set packet I2C mode. Defaults based on input address.
        :return: TestPacket Object
        """
        packet = self.generate_polling_packet(bit_field, value, i2c_mode)
        return self._update_packet_operation(packet, pkt_params.op.WRITE_FIELD)

    def generate_time_delay_packet(self, time_delay_us):
        """
        Generate an I2C Time Delay Packet and append to stimulus_packets list
        :param time_delay_us: Integer time delay in micro seconds
        :return: TestPacket Object
        """
        packet = self.generate_write_packet(self.dummy_address, [time_delay_us], params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.INSERT_PACKET_DELAY)

    @staticmethod
    def _verify_max_field_value(bit_field, value):
        max_value = (2 ** bit_field.bit_width) - 1
        if value > max_value:
            raise AttributeError(f'Max bitfield value is {max_value}, attempting to write or poll {value}')

    def generate_polling_packet(self, bit_field: Union[Field, list], expected_value: Union[int, list], i2c_mode=None):
        """
        Generate an I2C Polling Packet for a single or list of bit fields and append to stimulus_packets list.
        This function is also utilized by generate_write_field_packet()

        :param bit_field: A Field object or list of Field objects
        :param expected_value: Expected integer value for the Field object or list of expected int values
        :param i2c_mode: (Optional) Set packet I2C mode. Defaults based on input address.
        :return: TestPacket Object
        """
        if isinstance(bit_field, Field):
            self._verify_max_field_value(bit_field, expected_value)
            register = bit_field.container
            mask = bit_field.mask
            poll_or_write_value = expected_value << bit_field.bit_offset
        elif isinstance(bit_field, list):
            register = bit_field[0].container
            mask = poll_or_write_value = 0
            for field, val in zip(bit_field, expected_value):
                mask += field.mask
                poll_or_write_value += val << field.bit_offset
                self._verify_max_field_value(field, val)
        else:
            raise TypeError("Only bit field Field objects are accepted as input. See function parameter signature.")

        packet = self._generate_packet(register, i2c_mode, pkt_params.op.I2C_POLL)
        i2c_mode = packet.header.i2c_mode if not i2c_mode else i2c_mode
        shift_amount = 16 if packet.header.i2c_mode == 0 else 0
        payload_words = [mask << shift_amount, poll_or_write_value << shift_amount]
        packet.reg_values = payload_words
        packet.convert_register_words_to_payload_bytes()

        packet.header.bytes_to_rw = self.I2C_MODE_BYTES_PER_WORD[i2c_mode]
        packet.header.payload_size_in_bytes = len(packet.payload_bytes)

        # Now that header is populated, serialize the packet, including the header+payload
        packet.serialize()
        self.append_packet(packet)
        return packet

    def generate_randomization_packet(self, register_or_address, byte_count, i2c_mode=None):
        """
        Generate an I2C randomization packet and append to stimulus_packets list
        :param register_or_address: A Register object, Integer address, or hex string address
        :param byte_count: Integer number of bytes to write
        :param i2c_mode: (Optional) Set packet I2C mode. Defaults based on input address.
        :return: TestPacket Object
        """
        packet = self._generate_packet(register_or_address, i2c_mode, pkt_params.op.I2C_RANDOM_WRITE)
        packet.header.bytes_to_rw = byte_count
        seed = random.randint(0, 2 ** 32)

        packet.reg_values = [seed]
        packet.convert_register_words_to_payload_bytes()
        packet.header.payload_size_in_bytes = 4

        # Now that header is populated, serialize the packet, including the header+payload
        packet.serialize()
        self.append_packet(packet)
        return packet

    def generate_set_i2c_speed_tick_packet(self, i2c_speed=pkt_params.i2c_speed.S500KHZ, tick_us=1000):
        packet = self.generate_write_packet(self.dummy_address, [int(i2c_speed), tick_us], i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.SET_I2C_SPEED_AND_TICK)

    def generate_toggle_tick_verification_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.TOGGLE_TIMING_CHECK)

    def generate_enable_pwm_output_packet(self, output, polarity, period_clk_cycles, duty_clk_cycles, output_mode):
        payload_words = [output, polarity, period_clk_cycles, duty_clk_cycles, output_mode]
        packet = self.generate_write_packet(self.dummy_address, payload_words, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.SET_PWM_OUTPUT)

    def generate_disable_pwm_output_packet(self, output=0):
        packet = self.generate_write_packet(self.dummy_address, [output], i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.CLEAR_PWM_OUTPUT)

    def generate_set_output_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.SET_OUTPUT)

    def generate_clear_output_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.CLEAR_OUTPUT)

    def generate_wait_if_input_is_set_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.WAIT_IF_INPUT_IS_SET)

    def generate_wait_if_input_is_clear_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.WAIT_IF_INPUT_IS_CLEAR)

    def generate_start_timer_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.START_TIMER)

    def generate_read_timer_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.READ_TIMER)

    def generate_skip_nak_packet(self, enable):
        packet = self.generate_write_packet(self.dummy_address, [enable], i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.SKIP_NAK)

    def generate_read_nak_packet(self):
        packet = self.generate_read_packet(self.dummy_address, i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.READ_NAK)

    def generate_select_dut_port_mode(self, port_mode):
        packet = self.generate_write_packet(self.dummy_address, [port_mode], i2c_mode=params.i2c.MODE_11)
        self.dut_port_mode = port_mode  # Updates in Python side what is the current mode
        return self._update_packet_operation(packet, pkt_params.op.SELECT_DUT_PORT_MODE)

    def generate_set_pwm_clock_divisor_packet(self, divisor1, divisor2):
        packet = self.generate_write_packet(self.dummy_address, [divisor1, divisor2], i2c_mode=params.i2c.MODE_11)
        return self._update_packet_operation(packet, pkt_params.op.SET_PWM_CLOCK_DIVISOR)

    def _generate_packet(self, register_or_address, i2c_mode, operation):

        packet = TestPacket(self.i2c_device_address)

        if isinstance(register_or_address, int):
            address = register_or_address
        elif isinstance(register_or_address, str):
            address = int(register_or_address, 16)
        elif isinstance(register_or_address, Register):
            address = register_or_address.addr
        elif isinstance(register_or_address, Field):
            address = register_or_address.container.addr
        else:
            raise Exception(f"Invalid parameter passed to generate_xxx_packet: {type(register_or_address)}\n"
                            f"Accepted types: int address, hex string address, Register object, Register Field object")

        # Update I2C mode if necessary
        if i2c_mode is None:
            i2c_mode = params.i2c.MODE_00 if address < 0x600 else params.i2c.MODE_11

        updated_i2c_mode = i2c_mode
        I2C_MODE_MASK = 0b11
        if i2c_mode in [params.i2c.STD_8, params.i2c.STD_16, params.i2c.STD_32]:
            # Saves the 2 lower of EMU I2C as they were i2c mode
            updated_i2c_mode = self.i2c_device_address & I2C_MODE_MASK

        packet.header.index = len(self.stimulus_packets)
        packet.header.i2c_mode = updated_i2c_mode
        packet.header.operation = operation
        packet.header.operation_mode = self.OPERATION_MODES.get(i2c_mode, params.i2c_std.NOT_STD)
        packet.header.payload_size_in_bytes = 0
        packet.header.address = address
        return packet

    @staticmethod
    def _update_packet_operation(packet, operation):
        packet.header.operation = operation
        if len(packet.reg_values) > 0:
            packet.convert_register_words_to_payload_bytes()
        packet.serialize()
        return packet

    # endregion Nucleo Generate Packet Functions
    """
    ====================================================================================================
    Nucleo Test Functions
    ====================================================================================================
    """

    def start_test(self):
        # Write a 1 to "test_start" register in Nucleo to trigger the sequencer to process stimulus packets
        if self.polling_operation_timeout_ms:
            self.write_to_memory(self.device_config['polling_timeout_address'],
                                 data=self.polling_operation_timeout_ms * 1000,
                                 word_length=32)
        self.write_to_memory(self.device_config['test_start_address'], data=1, word_length=32)
        start_address_written = super().read_from_memory(self.device_config['test_start_address'], word_length=32) == 1
        self._log.info(f"Test Started: {start_address_written}")

    def stop_test(self):
        # Write a 0 to "test_start" register in Nucleo to trigger the sequencer to stop
        self.write_to_memory(self.device_config['test_start_address'], data=0, word_length=32)
        test_stopped = super().read_from_memory(self.device_config['test_start_address'], word_length=32) == 0
        self._log.info(f"Test Stopped: {test_stopped}")

    def poll_test_completion(self):
        # if test_done == 0, then test is not done, else test is done
        start_time = time.time()
        test_done = False
        self._log.info(f"Polling test completion bit... (Timeout will occur in {self.device_config['polling_timeout_sec']}s)")
        while not test_done and (time.time() - start_time) < self.device_config['polling_timeout_sec']:
            val = super().read_from_memory(self.device_config['test_done_address'], word_length=32)
            test_done = val > 0
            if not test_done:
                time.sleep(self.device_config['polling_interval_sec'])

        if test_done is False:
            raise Exception(f"Timeout expired waiting for test to complete on Nucleo."
                            f"Timeout: {self.device_config['polling_timeout_sec']}sec)")

        self._log.info("Test completed")

    def read_return_code(self):
        error_code = int(super().read_from_memory(self.device_config['test_error_address'], word_length=32))
        error_message = f"RETURN CODE: {self.JLINK_ERROR_CODES.get(error_code, 'UKNOWN ERROR CODE')}"
        self._log.info(error_message)
        return error_code, error_message

    def get_response_packets(self):
        self._log.info('Reading data from response buffer...')
        response_buffer_size_in_bytes = super().read_from_memory(self.device_config['rx_size_address'], word_length=32)
        response_bytes = super().read_from_memory(self.device_config['rx_start_address'], response_buffer_size_in_bytes)
        if response_bytes is None or len(response_bytes) == 0:
            raise Exception('No response received from Co-Emulation platform.')

        if response_buffer_size_in_bytes != len(response_bytes):
            raise Exception(f'Number of response bytes received ({len(response_bytes)}B) '
                            f'does not match expected ({response_buffer_size_in_bytes}).')

        self._log.info(f'Rx Buffer Size (B): {len(response_bytes)}')
        response_packets = self.deserialize_packets(response_bytes)
        self._log.info(f'Number of Rx Packets: {len(response_packets)}')
        return response_packets

    def get_packet_response_value(self, reference_packet, response_packets=None, reg_index=0):
        return self.get_packet_response_values(reference_packet, response_packets)[reg_index]

    def get_packet_response_values(self, reference_packet, response_packets=None):
        if response_packets is None:
            response_packets = self.response_packets
        response_packet = response_packets[reference_packet.header.index]
        if reference_packet.header.address != response_packet.header.address:
            self._log.warning(f"Response packet address {reference_packet.header.address} does not match "
                              f"reference packet address {response_packet.header.address}. "
                              f"Possible mismatch of index in reference packets list")
        return response_packet.reg_values

    def deserialize_packets(self, raw_bytes):
        packets = []
        # Make a deep copy of the raw bytes so we don't destroy the input data
        # (this algorithm pops!)
        working_bytes = raw_bytes[:]
        while len(working_bytes) > 0:
            packet = TestPacket(self.i2c_device_address)

            # Read header bytes and deserialize
            header_size = packet.header.get_header_size(working_bytes[2], working_bytes[3])
            if len(working_bytes) < header_size:
                raise ValueError('raw_bytes does not contain enough bytes to process a full header.')

            # Pop the working bytes off the list and set to packet header
            packet.header.raw_bytes = working_bytes[:header_size]
            if self.add_time_stamp:
                timestamp_bytes = working_bytes[header_size:header_size + 4]
                working_bytes = working_bytes[header_size + 4:]
                packet.timestamp = self.DataLib.pop_slice(timestamp_bytes, 0, 4)
            else:
                working_bytes = working_bytes[header_size:]
            packet.header.deserialize()

            # read payload bytes
            payload_size = packet.header.payload_size_in_bytes
            if len(working_bytes) < payload_size:
                raise ValueError('raw_bytes does not contain enough bytes to process a full header.')

            # TODO add setter method to packet.payload_bytes to convert to registers
            packet.payload_bytes = self.DataLib.pop_slice(working_bytes, 0, payload_size)
            packet.convert_payload_bytes_to_register_values()

            packets.append(packet)

        return packets

    def get_test_platform_fw_version(self):
        """
        Read the Nucleo Device Firmware Address
        :return: Returns the Major, Minor, and Subminor version numbers in a list
        """
        nucleo_firmware_version = self.read_from_memory(self.device_config['fw_version_address'], word_length=32)
        versions = [(nucleo_firmware_version >> shft) & 0xFF for shft in [0, 8, 16]]
        return versions[::-1]

    def enable_iterate_test(self, sequence_count, sequence_delay):
        if sequence_count:
            self.write_to_memory(self.device_config['sequence_iterations_address'], data=sequence_count, word_length=32)
            self.write_to_memory(self.device_config['sequence_delay_us_address'], data=sequence_delay, word_length=32)
            iterations = super().read_from_memory(self.device_config['sequence_iterations_address'], word_length=32)
            self._log.info(f"Test Iterations: {iterations == sequence_count}")
