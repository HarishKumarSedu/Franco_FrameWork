from unified_modules.resources.resource_data_lib.resource_data_lib import ResourceDataLib as DataLib
from unified_modules.test_support.testresults import TestResults
import cl_test_station.interfaces.nucleo_lib.packet_namedtuples as params


class TestPacket(object):
    # Packet object for all Test Packets, including stimulus and response vectors

    def __init__(self, i2c_device_address):
        self.header = PacketHeader(i2c_device_address)
        self.header_size_in_bytes = self.header.size_in_bytes

        self._reg_values = []
        self._expected_reg_values = []
        self._expected_mask = []
        self._expected_value = []
        self.payload_bytes = []
        self.raw_packet_bytes = []
        self.timestamp = []
        # raw header bytes are stored in the header object itself
        self.data_lib = DataLib()
        self.comment = ""

    @property
    def expected_reg_values(self):
        return self._expected_reg_values

    @expected_reg_values.setter
    def expected_reg_values(self, value):
        self._expected_reg_values = DataLib.convert_to_list(value)

    @property
    def reg_values(self):
        return self._reg_values

    @reg_values.setter
    def reg_values(self, value):
        self._reg_values = DataLib.convert_to_list(value)

    @property
    def expected_object(self):
        return self._expected_value

    @expected_object.setter
    def expected_object(self, value):
        self._expected_value = value

    @property
    def expected_mask(self):
        return self._expected_mask

    @expected_mask.setter
    def expected_mask(self, value):
        self._expected_mask = DataLib.convert_to_list(value)

    def serialize(self):
        """
        Serialize header bytes, then assign header+payload to raw_packet_bytes
        :return: None
        """
        self.header.serialize()
        self.raw_packet_bytes = self.header.raw_bytes + self.payload_bytes

    def deserialize(self):
        """
        Extract header and payload bytes from raw_packet_bytes and deserialize header bytes
        into object.

        :return:
        """
        if len(self.raw_packet_bytes) == 0:
            raise ValueError('Cannot deserialize packet, since raw_packet_bytes is empty.')

        self.header.raw_bytes = self.raw_packet_bytes[0:self.header_size_in_bytes]
        self.header.deserialize()
        self.payload_bytes = self.raw_packet_bytes[self.header_size_in_bytes:]

    def convert_polling_reg_values_to_words(self):

        if self.header.i2c_mode == 0:
            self.reg_values = self.data_lib.convert_bytes_to_words(self.payload_bytes[0:2],
                                                                   bytes_per_word=2,
                                                                   little_endian=False)
        elif self.header.i2c_mode == 3:
            self.reg_values = self.data_lib.convert_bytes_to_words(self.payload_bytes[0:4],
                                                                   bytes_per_word=4,
                                                                   little_endian=False)
        else:
            raise NotImplementedError('Invalid I2C mode type defined in header ({0})'
                                      .format(self.header.i2c_mode))

        self.reg_values += self.data_lib.convert_bytes_to_words(self.payload_bytes[4:],
                                                                bytes_per_word=4,
                                                                little_endian=False)

    def convert_write_field_reg_values_to_words(self):
        if self.header.i2c_mode == params.i2c.MODE_00 or self.header.operation_mode == params.i2c_std.STD_16_BITS:
            # Only the first two bytes are meaningful in mode00
            slice_mode00_bytes = self.payload_bytes[0:2] + self.payload_bytes[4:6] + self.payload_bytes[8:10]
            self.reg_values = self.data_lib.convert_bytes_to_words(slice_mode00_bytes,
                                                                   bytes_per_word=2,
                                                                   little_endian=False)
        elif self.header.i2c_mode == params.i2c.MODE_11 or self.header.operation_mode == params.i2c_std.STD_32_BITS:
            self.reg_values = self.data_lib.convert_bytes_to_words(self.payload_bytes,
                                                                   bytes_per_word=4,
                                                                   little_endian=False)

    def convert_payload_bytes_to_register_values(self):

        self._extract_payload_bytes_if_empty()
        polling_data_size_in_bytes = 8
        if self.header.operation == params.op.I2C_POLL and len(self.payload_bytes) >= polling_data_size_in_bytes:
            self.convert_polling_reg_values_to_words()
        elif self.header.operation == params.op.WRITE_FIELD:
            self.convert_write_field_reg_values_to_words()
        elif self.header.i2c_mode == params.i2c.MODE_00 or self.header.operation_mode == params.i2c_std.STD_16_BITS:
            self.reg_values = self.data_lib.convert_bytes_to_words(self.payload_bytes,
                                                                   bytes_per_word=2,
                                                                   little_endian=False)
        elif self.header.i2c_mode == params.i2c.MODE_11 or self.header.operation_mode == params.i2c_std.STD_32_BITS:
            self.reg_values = self.data_lib.convert_bytes_to_words(self.payload_bytes,
                                                                   bytes_per_word=4,
                                                                   little_endian=False)
        elif self.header.i2c_mode in [params.i2c.MODE_01, params.i2c.MODE_10] \
                or self.header.operation_mode == params.i2c_std.STD_8_BITS:
            self.reg_values = self.payload_bytes
        else:
            raise NotImplementedError('Invalid I2C mode type defined in header ({0})'
                                      .format(self.header.i2c_mode))

    def _extract_payload_bytes_if_empty(self):
        if len(self.payload_bytes) == 0:
            if len(self.raw_packet_bytes) > 0:
                self._extract_payload_from_raw_packet_bytes()
            else:
                raise ValueError(
                    'Cannot extract payload bytes: payload_bytes and raw_packet_bytes are empty.')

    def convert_register_words_to_payload_bytes(self):
        if len(self.reg_values) == 0:
            raise ValueError('Cannot convert to payload bytes, since no register values are defined.')

        # In Operation = 2 payload words always are 4 bytes,mask and expected value
        if self.header.operation in [params.op.INSERT_PACKET_DELAY, params.op.SET_OUTPUT, params.op.CLEAR_OUTPUT,
                                     params.op.SET_I2C_SPEED_AND_TICK, params.op.SET_PWM_OUTPUT,
                                     params.op.CLEAR_PWM_OUTPUT, params.op.DISABLE_PWM,  params.op.SKIP_NAK,
                                     params.op.SELECT_DUT_PORT_MODE, params.op.SET_PWM_CLOCK_DIVISOR]:
            self.payload_bytes = self.data_lib.convert_words_to_bytes(self.reg_values,
                                                                      bytes_per_word=4,
                                                                      little_endian=True)
        # POLL, RANDOM_WRITE and TOGGLE_TIMING_CHECK always have 4 bytes per word despite the mode
        elif self.header.i2c_mode == params.i2c.MODE_11 or self.header.operation_mode == params.i2c_std.STD_32_BITS or\
                self.header.operation in [params.op.I2C_POLL, params.op.WRITE_FIELD, params.op.I2C_RANDOM_WRITE,
                                          params.op.TOGGLE_TIMING_CHECK]:

            self.payload_bytes = self.data_lib.convert_words_to_bytes(self.reg_values,
                                                                      bytes_per_word=4,
                                                                      little_endian=False)
        elif self.header.i2c_mode == params.i2c.MODE_00 or self.header.operation_mode == params.i2c_std.STD_16_BITS:

            self.payload_bytes = self.data_lib.convert_words_to_bytes(self.reg_values, bytes_per_word=2,
                                                                      little_endian=False)
        elif self.header.i2c_mode in [params.i2c.MODE_01, params.i2c.MODE_10] or \
                self.header.operation_mode == params.i2c_std.STD_8_BITS:

            self.payload_bytes = self.reg_values
        else:
            raise NotImplementedError('Invalid I2C mode type defined in header ({0})'.format(self.header.i2c_mode))

    def get_total_byte_count(self):
        # Calculate packet size based on header size (determined in YAML) + payload bytes
        packet_size = self.header_size_in_bytes + len(self.payload_bytes)
        return packet_size

    def _extract_payload_from_raw_packet_bytes(self):
        # Copy slice of bytes from start of data payload until end of payload
        payload_offset = self.header_size_in_bytes
        self.payload_bytes = self.raw_packet_bytes[payload_offset:]


class HeaderFieldSizes(object):
    """
    Sizes in bits:

        * Index: 16 bits
        * Wait Tick: 1 bit
        * I2C Slave Address: 5 bits
        * I2C Mode: 2 bits
        * Operation: 8 bits
        * Payload Size: 16 bits
        * Bytes RW: 16 bits
        * Register Address: 0 or 32 bits
    """
    index_bit = 16
    wait_for_tick_bits = 1
    i2c_slave_address_bits = 5
    i2c_mode_bits = 2
    operation_bits = 6
    operation_mode_bits = 2
    payload_size_bits = 16
    bytes_rw_bits = 16
    register_address_bits = 32
    byte_bits = 8

    @classmethod
    def index_in_bytes(cls):
        return cls.index_bit // cls.byte_bits

    @classmethod
    def i2c_slave_address_i2c_mode_wait_tick_in_bytes(cls):
        total_size_bits = cls.i2c_slave_address_bits\
                          + cls.i2c_mode_bits\
                          + cls.wait_for_tick_bits
        return total_size_bits // cls.byte_bits

    @classmethod
    def operation_in_bytes(cls):
        return (cls.operation_bits + cls.operation_mode_bits) // cls.byte_bits

    @classmethod
    def payload_size_in_bytes(cls):
        return cls.payload_size_bits // cls.byte_bits

    @classmethod
    def bytes_rw_in_bytes(cls):
        return cls.bytes_rw_bits // cls.byte_bits

    @classmethod
    def register_address_in_bytes(cls):
        return cls.register_address_bits // cls.byte_bits


class PacketHeader(object):
    def __init__(self, i2c_device_address):
        self.size_in_bytes_mode_00_11 = 12
        self.size_in_bytes_mode_01_10 = 8
        self.size_in_bytes = self.size_in_bytes_mode_00_11
        self.raw_bytes = []

        # Assigned values are defaults. Parameters specific to an i2C transaction are set to None
        self.index = 0
        self.i2c_slave_address = i2c_device_address
        self.i2c_mode = None
        self.wait_for_tick = 0
        self.operation = None
        self.operation_mode = None
        self.payload_size_in_bytes = None
        self.bytes_to_rw = None
        self.address = None
        self.sizes = HeaderFieldSizes()

    def serialize(self):
        """
        Serialize a PacketHeader object into a byte array
        """
        header_bytes = []
        header_bytes += DataLib.num_to_bytes(self.index, self.sizes.index_in_bytes())
        i2c_slave_address_i2c_mode_wait_for_tick = self.wait_for_tick << 7 | self.i2c_slave_address | self.i2c_mode
        header_bytes += DataLib.num_to_bytes(i2c_slave_address_i2c_mode_wait_for_tick, 1)
        header_bytes += DataLib.num_to_bytes(self.operation_mode << 6 | self.operation, self.sizes.operation_in_bytes())
        header_bytes += DataLib.num_to_bytes(self.payload_size_in_bytes,
                                             self.sizes.payload_size_in_bytes())
        header_bytes += DataLib.num_to_bytes(self.bytes_to_rw, self.sizes.bytes_rw_in_bytes())
        if self.i2c_mode in [params.i2c.MODE_00, params.i2c.MODE_11] or self.operation_mode != params.i2c_std.NOT_STD:
            header_bytes += DataLib.num_to_bytes(self.address, self.sizes.register_address_in_bytes())

        self.raw_bytes = header_bytes

    def deserialize(self):
        header_bytes = self.raw_bytes[0:len(self.raw_bytes)]
        self.verify_data_is_complete(header_bytes)
        self.address = 0
        index_bytes = DataLib.pop_slice(header_bytes, end_index=self.sizes.index_in_bytes())
        self.index = DataLib.bytes_to_num(index_bytes)
        i2c_address_i2c_mode_wait_tick_bytes = DataLib.bytes_to_num(DataLib.pop_slice(header_bytes))

        self.i2c_mode, self.i2c_slave_address, self.wait_for_tick = \
            self.get_i2c_address_i2c_mode_wait_tick_bytes(i2c_address_i2c_mode_wait_tick_bytes)

        operation_bytes = DataLib.bytes_to_num(DataLib.pop_slice(header_bytes))
        self.operation, self.operation_mode = self.get_operation_mode(operation_bytes)
        payload_size_bytes = DataLib.pop_slice(header_bytes, end_index=self.sizes.payload_size_in_bytes())
        self.payload_size_in_bytes = DataLib.bytes_to_num(payload_size_bytes)
        bytes_to_rw_bytes = DataLib.pop_slice(header_bytes, end_index=self.sizes.bytes_rw_in_bytes())
        self.bytes_to_rw = DataLib.bytes_to_num(bytes_to_rw_bytes)

        if self.i2c_mode in [params.i2c.MODE_00, params.i2c.MODE_11] or self.operation_mode != params.i2c_std.NOT_STD:
            address_bytes = DataLib.pop_slice(header_bytes, end_index=self.sizes.register_address_in_bytes())
            self.address = DataLib.bytes_to_num(address_bytes)

    def get_operation_mode(self, operation_byte):
        operation_bit_position = 0
        operation_mode_bit_position = 6
        operation = DataLib.get_bit_field(operation_byte, operation_bit_position, self.sizes.operation_bits)
        oper_mode = DataLib.get_bit_field(operation_byte, operation_mode_bit_position, self.sizes.operation_mode_bits)
        return operation, oper_mode

    def get_i2c_address_i2c_mode_wait_tick_bytes(self, i2c_mode_address_wait_tick):

        i2c_slave_address_bit_position = 2
        i2c_mode_bit_position = 0
        wait_for_tick_bit_position = 7
        i2c_slave_address_offset_by_i2c_mode = 2
        i2c_address = DataLib.get_bit_field(i2c_mode_address_wait_tick,
                                            i2c_slave_address_bit_position,
                                            self.sizes.i2c_slave_address_bits)
        i2c_address <<= i2c_slave_address_offset_by_i2c_mode
        i2c_mode = DataLib.get_bit_field(i2c_mode_address_wait_tick,
                                         i2c_mode_bit_position,
                                         self.sizes.i2c_mode_bits)

        wait_for_tick = DataLib.get_bit_field(i2c_mode_address_wait_tick,
                                              wait_for_tick_bit_position,
                                              self.sizes.wait_for_tick_bits)
        return i2c_mode, i2c_address, wait_for_tick

    def verify_data_is_complete(self, header_bytes):
        if len(header_bytes) != self.size_in_bytes:
            raise ValueError(
                'Insufficient number of header bytes to deserialize. Need {0} bytes.'
                ' Received {1} bytes.'.format(
                    self.size_in_bytes, len(header_bytes)
                )
            )

    def get_header_size(self, byte_with_i2c_mode, byte_operation_info):
        header_size = self.size_in_bytes_mode_01_10
        self.i2c_mode = DataLib.get_bit_field(byte_with_i2c_mode, 0, 2)
        self.operation_mode = DataLib.get_bit_field(byte_operation_info, 6, 2)
        if self.i2c_mode in [params.i2c.MODE_00, params.i2c.MODE_11] or self.operation_mode != params.i2c_std.NOT_STD:
            header_size = self.size_in_bytes_mode_00_11
        self.size_in_bytes = header_size
        return header_size


if __name__ == "__main__":
    packet_header = PacketHeader(i2c_device_address=0x74)
    test_data = [0, 0, 119, 4, 1, 0, 0, 20, 0, 252, 0, 0]
    packet_header.raw_bytes = test_data
    packet_header.deserialize()
    results = TestResults()
    results.set_test_title("Packet header")

    results.log.info("header.index = {}".format(packet_header.index))
    results.log.info("header.i2c_slave_address = 0x{0:2X}".format(packet_header.i2c_slave_address))
    results.log.info("header.i2c_mode = 0b{0:2b}".format(packet_header.i2c_mode))
    results.log.info("header.wait_for_tick = {}".format(packet_header.wait_for_tick))
    results.log.info("header.payload_size_in_bytes = {}".format(
        packet_header.payload_size_in_bytes))
    results.log.info("header.bytes_to_rw = {} bytes".format(packet_header.bytes_to_rw))
    results.log.info("header.register_address = 0x{0:2X}".format(packet_header.address))

    packet_header.serialize()
    results.log.info(packet_header.raw_bytes)
    results.assert_equal(packet_header.raw_bytes, test_data, "It must match!")
