import math

from cl_test_station.interfaces.ctrl_interface import CtrlInterface
from unified_modules.resources.resource_data_lib.resource_data_lib import ResourceDataLib as DataLib

class JlinkI2cInterface(CtrlInterface):

    JLINK_ERROR_CODES = {
        0:  'SUCCESS',
        1:  'CRUS_API_ERROR',
        2:  'CRUS_API_NAK_TIMEOUT',
        11: 'MALFORMED_HEADER',
        21: 'RX_BUFFER_OVERFLOW',
        22: 'BUSY_DURING_TICK',
        23: 'TX_BUFFER_EMPTY',
        24: 'INCOMPLETE_TX_PACKET',
        25: 'POLLING_TIMEOUT',
        26: 'TICK_MISSED_ERROR',
        33: 'APPLICATION_ERROR',
        34: 'PARAMETER_1_VALUE_RANGE',
        35: 'PARAMETER_2_VALUE_RANGE',
        36: 'I2C2_COMMUNICATION_ERROR',
        37: 'PARAMETER_3_VALUE_RANGE',
        38: 'PARAMETER_4_VALUE_RANGE',
        39: 'PARAMETER_5_VALUE_RANGE'
    }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.DataLib = DataLib()

    """
    ====================================================================================================
    Nucleo Read/Write Functions
    ====================================================================================================
    """
    def write_register(self, host_controller, reg_addr, write_data):
        return host_controller.write_to_memory(reg_addr, write_data, word_length=32)

    def read_register(self, host_controller, reg_addr):
        return [host_controller.read_from_memory(reg_addr, words_to_read=1, word_length=32)]

    def read_from_memory(self, address, words_to_read=1, word_length=8):
        # STUB FOR TESTING, REPLACE LATER
        jlink_controller = self.component.active_controller
        return jlink_controller.read_from_memory(address, words_to_read=words_to_read, word_length=word_length)

    def write_to_memory(self, address, data, word_length=8):
        # STUB FOR TESTING, REPLACE LATER
        self.component.active_controller.write_to_memory(address, data, word_length=word_length)

    # def read_reg(self, target, addr, word_count, i2c_mode=None):
    #     return [self.read_from_memory(addr, words_to_read=word_count, word_length=32)]
    #
    # def write_reg(self, target, addr, data, i2c_mode=None):
    #     self.write_to_memory(addr, [data], word_length=32)
    #     return [0]

    # def write_to_memory(self, address, data, word_length=8):
    #     """
    #     Write to memory at the specified address
    #     :param address: Register or memory address
    #     :param data: Value or list of values to be written in memory
    #     :param word_length: number of bits per word for write operation: 8, 16 or 32
    #     :return None
    #     """
    #     if not isinstance(data, list):
    #         data = [data]
    #     # Call the respective memory_write_X based on the input word length
    #     getattr(self.container.jlink, f'memory_write{word_length}')(address, data)
    #
    # def read_from_memory(self, address, words_to_read=1, word_length=8):
    #     """
    #     Write to memory at specified address
    #     :param address: Register or memory address
    #     :param words_to_read: Number of words to read
    #     :param word_length: number of bits per word for write operation: 8, 16 or 32
    #     :return Returns a array of words read
    #     """
    #     if word_length == 8:
    #         words_to_read_32 = int(math.ceil(words_to_read / 4.0))
    #         extra_bytes = (words_to_read % 4)
    #         word_list = self.container.jlink.memory_read32(address, words_to_read_32)
    #         word_list = self.DataLib.convert_words_to_bytes(word_list, 4)
    #         if extra_bytes:
    #             del word_list[-(4 - extra_bytes):]
    #     elif word_length == 16:
    #         word_list = self.container.jlink.memory_read16(address, words_to_read)
    #     elif word_length == 32:
    #         word_list = self.container.jlink.memory_read32(address, words_to_read)
    #     else:
    #         raise NotImplementedError(f'SWD only supports 8, 16 or 32-bit words. Provided {word_length} word length')
    #
    #     if len(word_list) == 1:
    #         return word_list[0]
    #     else:
    #         return word_list
