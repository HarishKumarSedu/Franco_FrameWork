"""
Module for Control Interface base class.
Author: Evan Canter <evan.canter@cirrus.com>
"""
import inspect
from enum import Enum
from typing import Callable, List, Union

import serpent
from cl_test_station.components.component import component
from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.pyro_support.pyro_receiver import PyroReceiver
from cl_test_station.test_station_object import TestStationObject, TsoField


class CtrlInterfaceError(Exception):
    """Base class for all control interface related errors."""
    pass


class ByteOrder(Enum):
    """Enumeration for word byte order"""
    LSB_FIRST = 0
    MSB_FIRST = 1


class CtrlInterface(TestStationObject):
    """Control Interface base class"""
    read_reg_data_size: int = TsoField(ftype=int, desc='Size in Bytes of read data')
    read_reg_addr_size: int = TsoField(ftype=int, desc='Size in Bytes of read address')
    write_reg_data_size: int = TsoField(ftype=int, desc='Size in Bytes of write data')
    write_reg_addr_size: int = TsoField(ftype=int, desc='Size in Bytes of write address')
    data_byte_order: ByteOrder = TsoField(ftype=ByteOrder, required=False, default=ByteOrder.MSB_FIRST,
                                          desc='Byte order of register data, can be MSB_FIRST or LSB_FIRST')
    addr_byte_order: ByteOrder = TsoField(ftype=ByteOrder, required=False, default=ByteOrder.MSB_FIRST,
                                          desc='Byte order of register address, can be MSB_FIRST or LSB_FIRST')
    address_stride: int = TsoField(ftype=int, required=False, default=-1,
                                   desc='Number of memory locations per word. If default is given (-1), read_reg_data_size will be used')
    require_component_container: bool = TsoField(ftype=bool, required=False, default=True,
                                                 desc="Forces the interfaces container to be of the component type")

    def __init__(self, *args, **kwargs):
        self.fields = {'_comp_path': ''}  # Holds the kwargs for HostController functions
        self.non_tso_fields = {}  # Dictionary for all non-tso fields to display in the repr
        self.component = None
        super().__init__(*args, **kwargs)
        if self.require_component_container:
            if not isinstance(self.container, component.Component):  # Interface needs to be under component
                raise TypeError("%s %s needs to be defined under a Component, not %s" %
                                (self.__class__.__name__, self.ref_name, self.container.__class__.__name__))
            self.component = self.container
            self.fields['_comp_path'] = self.component.path
        if self.address_stride is -1:  # User didnt specifiy, default to size of reigster (Byte addressable)
            self.address_stride = self.read_reg_data_size

    def __repr__(self):
        return f"{self.__class__.__name__}({', '.join([k + '=' + str(v) for k, v in self.non_tso_fields.items()])})"

    def __setattr__(self, key, value):
        if hasattr(self, 'fields') and key in self.fields:
            self.fields[key] = value
            self.non_tso_fields[key] = value
        object.__setattr__(self, key, value)

    def post_construct_system(self, *args, **kwargs):
        """
        Builds fields dictionary and filters out any fields that are not serializable.

        :return: None
        :rtype: None
        """
        super().post_construct_system(*args, **kwargs)
        # Add all config fields to attr
        for key, value in self.config.items():
            if type(value) is dict or key == 'class_type':
                continue
            self.fields[key] = value
        # Add all TsoFields to self.fields (may overwrite config items)
        for tso_field in self.get_class_fields():
            self.fields[tso_field.name] = getattr(self, tso_field.name)
        # Remove any non-serializable fields
        for key in list(self.fields.keys()):
            value = self.fields[key]
            if isinstance(value, (TestStationObject, PyroReceiver)):  # Pop all fields that reference other TSO's
                self.log.debug(f"Removing TestStationObject {key} from self.fields: {self.fields[key]}")
                self.fields.pop(key)
                continue
            try:  # Attempt to serialze with serpent (Pyro's default serializer)
                serpent.dumps(self.fields[key])
            except (TypeError, ValueError) as err:  # This field will break Pyro calls, remove it from fields dict
                self.log.debug(f"Removing non-serializable field {key} from self.fields: {self.fields[key]}")
                self.fields.pop(key)
        # Add non-tso fields to repr_dict
        tso_field_names = [f.name for f in self.get_class_fields()]
        for key, value in self.fields.items():
            if key in tso_field_names or key == '_comp_path':
                continue
            self.non_tso_fields[key] = value

    def check_args(self, iface_func: Callable, extra: List[str] = None):
        """
        Gets the signature of iface_func and makes sure that all the arguments required are in self.fields
        If a field is missing, this function will raise a KeyError

        :param iface_func: Function to check args for
        :type iface_func: Callable
        :param extra: Extra arguments that may not be provided in fields
        :type: extra: List[str]
        :return: None
        :rtype: None
        """
        if extra is None:
            extra = []
        parameters = inspect.signature(iface_func).parameters
        missing_args = []
        supplied_args = list(self.fields.keys()) + extra
        for name, param in parameters.items():
            if param.kind in [inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD]:  # These are *arg, **kw
                continue
            if param.default is inspect._empty and name not in supplied_args:  # This param is positional and missing
                missing_args.append(name)
        if missing_args:
            msg = "Missing required field(s) %s in YAML, cannot call %s()." % (str(missing_args), iface_func.__name__)
            self.log.error(msg)
            raise KeyError(msg)

    def write_register(self, host_controller: HostController, reg_addr: int, write_data: int, *args, **kwargs):
        """
        Base method definition for a write register operation.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param reg_addr: Register address
        :type reg_addr: int
        :param write_data: Value to write
        :type write_data: int
        :return: None
        :rtype: None
        """

    def read_register(self, host_controller: HostController, reg_addr: int, *args, **kwargs) -> int:
        """
        Base method definition for a read register operation.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param reg_addr: Register address
        :type reg_addr: int
        :return: Register value
        :rtype: int
        """

    def block_read(self, host_controller: HostController, start_addr: int, word_count: int, *args, **kwargs) -> List[int]:
        """
        Base method definition for a block read operation. Reads a block of successive addresses starting at start_addr.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param start_addr: Start address of block read
        :type start_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :return: List of words read
        :rtype: List[int]
        """

    def block_write(self, host_controller: HostController, start_addr: int, write_data: List[int], *args, **kwargs):
        """
        Base method definition for a block write operation. Writes data to successive addresses starting at start_addr.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param start_addr: Start address of block write
        :type start_addr: int
        :param write_data: List of words to write
        :type write_data: List[int]
        :return: None
        :rtype: None
        """

    def chain_read(self, host_controller: HostController, reg_addr: int, word_count: int, *args, **kwargs) -> List[int]:
        """
        Base method definition for a chain read operation. Reads multiple words from a single address.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param reg_addr: Start address of block read
        :type reg_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :return: List of words read
        :rtype: List[int]
        """

    def chain_write(self, host_controller: HostController, reg_addr: int, write_data: List[int], *args, **kwargs):
        """
        Base method definition for a chain write operation. Writes multiple words to single addresses.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param reg_addr: Start address of block write
        :type reg_addr: int
        :param write_data: List of words to write
        :type write_data: List[int]
        :return: None
        :rtype: None
        """

    def prepare_address(self, address: int) -> int:
        """
        Placeholder function for adding any configuration bits or other operations on address.

        :param address: Input address
        :type address: int
        :return: New address
        :rtype: int
        """

    def add_config_bit(self, address: int, bit_pos: int, active_level: int, enable: bool) -> int:
        """
        Adds a config bit to the given address.

        :param address: Raw input address
        :type address: int
        :param bit_pos: Bit position of the config bit
        :type bit_pos: int
        :param active_level: 0 = active low, 1 = active high
        :type active_level: int
        :param enable: True = set bit to active, False = set to inactive
        :type enable: bool
        :return: Configured address
        :rtype: int
        """
        address &= ~(1 << bit_pos)                       # Mask off bit from address
        new_bit_value = active_level ^ int(not enable)   # Get value of the bit
        address |= new_bit_value << bit_pos              # Set bit in address
        active_str = 'active' if new_bit_value == active_level else 'inactive'
        self.log.debug(f"Setting bit {bit_pos} of address to {new_bit_value} ({active_str})")
        return address

    @staticmethod
    def word_to_hex(word: int, size: int) -> str:
        """
        Returns hex string zero-filled to size

        :param word: Word to convert
        :type word: int
        :param size: Size of word in bytes
        :type size: int
        :return: Zero-filled hex string, e.g. 0x00123
        :rtype: str
        """
        return f"0x{word:0{size<<1}X}"

    def raise_error(self, error_code: int):
        """
        Takes in an error code (negative integer) and raises the exception that maps to that code. if code is 0 or
        positive, no exception will be raised.

        :param error_code: Error code
        :type error_code: int
        :return: None
        :rtype: None
        """
        if type(error_code) is int:
            if error_code < 0:
                raise self.ERROR_CODES[error_code]


def map_word(word: int, word_size: int, byte_order: Union[ByteOrder, int]) -> List[int]:
    """
    Converts a word to a list of bytes.

    :param word: Word to convert
    :type word: int
    :param word_size: Size in bytes of the word
    :type word_size: int
    :param byte_order: Order that the bytes will be placed, either ByteOrder.MSB_FIRST or ByteOrder.LSB_FIRST
    :type byte_order: ByteOrder
    :return: List of bytes (ints)
    :rtype: List[int]
    """
    if type(byte_order) is int:
        byte_order = ByteOrder(byte_order)
    bytes_out = []
    for i in range(word_size):  # 0 : size-1
        byte_index = word_size - 1 - i if byte_order is ByteOrder.MSB_FIRST else i
        bytes_out.append((word >> 8 * byte_index) & 0xFF)
    return bytes_out


def build_word(bytes: List[int], word_size: int, byte_order: Union[ByteOrder, int]) -> int:
    """
    Converts a list of bytes into a single word.

    :param bytes: List of bytes
    :type bytes: List[int]
    :param word_size: Size of word in bytes
    :type word_size: int
    :param byte_order: Order that the bytes will be placed, either ByteOrder.MSB_FIRST or ByteOrder.LSB_FIRST
    :type byte_order: ByteOrder
    :return: Constructed word
    :rtype: int
    """
    if type(byte_order) is int:
        byte_order = ByteOrder(byte_order)
    if bytes.__class__.__name__ == "McuI2cReadResponse":
        bytes.convert_to_int = True
        bytes.word_size = word_size
        bytes.byte_order = byte_order
        return bytes
    word = 0
    for i in range(word_size):
        byte_index = word_size - 1 - i if byte_order is ByteOrder.MSB_FIRST else i
        word += (bytes[i] & 0xFF) << 8 * byte_index
    return word


def build_words_from_bytes(byte_list: List[int], word_size: int, byte_order: ByteOrder) -> List[int]:
    """
    Takes in a list of bytes and builds a list of words.

    :param byte_list: List of bytes
    :type byte_list: List[int]
    :param word_size: Size of word in bytes
    :type word_size: int
    :param byte_order: Order that the bytes will be placed, either ByteOrder.MSB_FIRST or ByteOrder.LSB_FIRST
    :type byte_order: ByteOrder
    :return: List of words
    :rtype: List[int]
    """
    if byte_list.__class__.__name__ == "McuI2cReadResponse":
        byte_list.convert_to_list = True
        byte_list.word_size = word_size
        byte_list.byte_order = byte_order
        return byte_list
    words_out = []
    # Get sub list of bytes in each word
    for word_bytes in [byte_list[i:i+word_size] for i in range(0, len(byte_list), word_size)]:
        words_out.append(build_word(word_bytes, word_size, byte_order))  # Build each word and add to list
    return words_out


def map_words_to_bytes(words: List[int], word_size: int, byte_order: ByteOrder) -> List[int]:
    """
    Converts a list of words into a single list of bytes, maintaining the original word order.

    :param words: List of words to convert
    :type words: List[int]
    :param word_size: Size of word in bytes
    :type word_size: int
    :param byte_order: Order that the bytes will be placed, either ByteOrder.MSB_FIRST or ByteOrder.LSB_FIRST
    :type byte_order: ByteOrder
    :return: List of bytes
    :rtype: List[int]
    """
    bytes_out = []
    for word in words:
        bytes_out.extend(map_word(word, word_size, byte_order))
    return bytes_out
