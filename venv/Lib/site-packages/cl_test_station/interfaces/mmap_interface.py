from cl_test_station.host_controllers.thrift_controller.thrift_controller import ThriftController
from cl_test_station.interfaces.ctrl_interface import CtrlInterface, map_word, build_word
from cl_test_station.test_station_object import TsoField


class MmapInterface(CtrlInterface):
    """Interface class used to access memory mapped files on a ThriftController's Linux OS."""

    start_addr: int = TsoField(ftype=int, desc="First address of Memory space.")
    end_addr: int = TsoField(ftype=int, desc="Last address of Memory space.")
    use_virtual_base: bool = TsoField(ftype=bool, required=False, default=False,
                                      desc="When enabled, will use start address as a virtual base address of 0. "
                                           "e.g. reading address 0x4 with start address 0x100 will actually read 0x104")
    controller: ThriftController = TsoField(ftype=str, required=False,
                                            desc="Ref name of host controller. Must be Audiohub or ZDC. If None given, "
                                                 "this class will search its parent Component for one and select the "
                                                 "frist one it finds.")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.mmap_size: int = self.end_addr - self.start_addr + self.read_reg_data_size  # Size of Memory Space

    def post_construct_system(self, *args, **kwargs):
        """
        Links a host controller to this interface. Will resolve the controller's ref_name if given. If no ref_name is
        given, the first ThriftController found under this interface's parent Component will be used.

        :return: None
        """
        # Resolve host controller reference
        if not self.controller:  # Find first instance of AH/ZDC
            for controller in self.component.host_controllers.values():
                if isinstance(controller, ThriftController):
                    self.controller = controller
                    break
            else:
                raise AttributeError(f"Component {self.component.ref_name} does not have a ThriftController "
                                     f"listed as a host controller")
        elif self.controller in self.component.host_controllers:  # Came in as a string, grab from parent's dictionary
            self.controller = self.component.host_controllers[self.controller]

        if not isinstance(self.controller, ThriftController):  # Couldn't find an ThriftController to use
            raise NameError(f"Could not find {self.controller} in {self.component.ref_name}'s host_controllers: "
                            f"{self.component.host_controllers.keys()}")

        super().post_construct_system(*args, **kwargs)  # Need to call super after controller has been resolved

    def initialize(self, *args, **kwargs):
        super().initialize(*args, **kwargs)
        # Add Memory map on controller's thrift server
        self.controller.mmap_add(base_addr=self.start_addr, size=self.mmap_size, word_size=self.read_reg_data_size)

    def _get_offset(self, reg_addr: int) -> int:
        """
        Gets register offset from raw address. If 'use_virtual_base' is True, reg_addr=offset.

        :param reg_addr: Regsiter address
        :type reg_addr: int
        :return: Offset
        :rtype: int
        """
        if self.use_virtual_base:  # reg_addr is already the offset
            true_addr = self.start_addr + reg_addr
            offset = reg_addr
        else:  # Calulate offset using start addr
            true_addr = reg_addr
            offset = reg_addr - self.start_addr
        # Check address is in range
        if true_addr < self.start_addr or true_addr > self.end_addr:
            start = 0 if self.use_virtual_base else self.start_addr
            end = self.end_addr - self.start_addr if self.use_virtual_base else self.end_addr
            addr_len = self.read_reg_addr_size<<1
            raise ValueError(f"Address 0x{reg_addr:0{addr_len}X} out of range "
                             f"0x{start:0{addr_len}X}-0x{end:0{addr_len}X}")
        return offset

    def read_register(self, host_controller: ThriftController, reg_addr: int, **kwargs) -> int:
        """
        Reads value from register at address 'reg_addr'

        :param host_controller: Reference to controller to use
        :type host_controller: ThriftController
        :param reg_addr: Register address
        :type reg_addr: int
        :return: Register value
        :rtype: int
        """
        # Check that host controller is correct reference
        if host_controller is not self.controller:
            raise ValueError(f"Given HostController {host_controller.ref_name} not linked to this Memory Map: "
                             f"{self.controller.ref_name}")
        offset = self._get_offset(reg_addr)
        self.check_args(host_controller.mmap_read, extra=['base_addr', 'offset', 'num_bytes'])
        bytes_in = host_controller.mmap_read(base_addr=self.start_addr, offset=offset, num_bytes=self.read_reg_data_size, **self.fields)
        return build_word(bytes_in, self.read_reg_data_size, self.data_byte_order)

    def write_register(self, host_controller: ThriftController, reg_addr: int, write_data: int, **kwargs):
        """
        Writes 'write_data' to register at address 'reg_addr'

        :param host_controller: Reference to controller to use
        :type host_controller: ThriftController
        :param reg_addr: Register address
        :type reg_addr: int
        :param write_data: New register value
        :type write_data: int
        :return: None
        """
        # Check that host controller is correct reference
        if host_controller is not self.controller:
            raise ValueError(f"Given HostController {host_controller.ref_name} not linked to this Memory Map: "
                             f"{self.controller.ref_name}")
        bytes_out = map_word(write_data, self.write_reg_data_size, self.data_byte_order)
        offset = self._get_offset(reg_addr)
        self.check_args(host_controller.mmap_write, extra=['base_addr', 'offset', 'bytes_out'])
        host_controller.mmap_write(base_addr=self.start_addr, offset=offset, bytes_out=bytes_out, **self.fields)

