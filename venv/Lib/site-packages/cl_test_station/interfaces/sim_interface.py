from cl_test_station.interfaces.ctrl_interface import CtrlInterface, ByteOrder


class SimWriteError(Exception):
    """Exception for Simulation write error"""
    pass


class SimReadError(Exception):
    """Exception for Simulation read error"""
    pass


# TODO PLATDEV-1080 remove this entire module
class SimInterface(CtrlInterface):
    """Simulation interface that stores transatoin data in an internal data structure.

    **NOTE: This class is deprecated. Use SimHostController and its child classes instead.**"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # This will create cache dictionary in the containing component
        if not hasattr(self.container, 'reg_dict'):
            self.container.reg_dict = {}
        self.__reg_dict = self.container.reg_dict

    def write_register(self, host_controller, reg_addr, write_data, *args, **kwargs):
        """
        Simulates a register write

        :param host_controller:
        :type host_controller:
        :param reg_addr:
        :type reg_addr:
        :param write_data:
        :type write_data:
        :param args:
        :type args:
        :param kwargs:
        :type kwargs:
        :return:
        :rtype:
        """
        self.__reg_dict[reg_addr] = write_data

    def read_register(self, host_controller, reg_addr, *args, **kwargs):
        """
        Simulates a register read

        :param host_controller:
        :type host_controller:
        :param reg_addr:
        :type reg_addr:
        :param args:
        :type args:
        :param kwargs:
        :type kwargs:
        :return:
        :rtype:
        """
        if reg_addr in self.__reg_dict:
            return self.__reg_dict[reg_addr]
        else:
            return 0

    def block_read(self, host_controller, start_addr, word_count, *args, **kwargs):
        """Reads a block of word_count words from start_addr. Will issue multiple transfers if word_count exceeds the
        max_tranfer_size defined

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block read
        :param word_count: [int] number of words to read
        :return: [list<int>] List of length word_count containing register values
        """
        readback = []
        for i in range(start_addr, start_addr + word_count):
            readback.append(self.read_register(None, i))
        return readback

    def block_write(self, host_controller, start_addr, write_data, *args, **kwargs):
        """
        Writes each word from write_data starting at start_addr (incrementing)

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block write
        :param write_data: [list<int>] List of words to write
        :return: None
        """
        current_addr = start_addr
        for data in write_data:
            self.__reg_dict[current_addr] = data
            current_addr += 4

    def chain_read(self, host_controller, reg_addr, word_count, *args, **kwargs):
        """
        Reads words from single address 'reg_addr', without incrementing. Returns list of words read.

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :return: List of words
        :rtype: list
        """
        val = self.__reg_dict[reg_addr] if reg_addr in self.__reg_dict else 0
        return [val] * word_count

    def chain_write(self, host_controller, reg_addr, write_data, *args, **kwargs):
        """
        Writes words sequentially to single address, without incrementing.

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param write_data: List of words to write
        :type write_data: list
        :return: None
        """
        self.__reg_dict[reg_addr] = write_data[-1]
