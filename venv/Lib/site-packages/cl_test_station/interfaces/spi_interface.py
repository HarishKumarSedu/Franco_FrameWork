"""
Module for SPI interface class.
Author: Evan Canter <evan.canter@cirrus.com>
"""
from enum import Enum
from typing import List, Union

from cl_test_station.interfaces.ctrl_interface import CtrlInterface, ByteOrder
from cl_test_station.interfaces.ctrl_interface import map_word, build_words_from_bytes
from cl_test_station.test_station_object import TsoField


class SpiInterface(CtrlInterface):
    """Control interface for SPI. Allows for SPI reading and writing at the component level"""

    # Pad fields
    padding: int = TsoField(ftype=int, desc="Number of pad Bytes between address and data frames")
    pad_value: int = TsoField(ftype=int, required=False, default=0, desc="Value of pad bits")
    # AINC fields
    ainc_bit_pos: int = TsoField(ftype=int, required=False, desc="Bit position in address of the auto-increment bit.")
    ainc_active_level: int = TsoField(ftype=int, required=False, default=0, desc="Active state for AINC bit")
    ainc: bool = TsoField(ftype=bool, required=False, default=False,
                          desc="Flag that indicated if AINC is being used. Will be set to True if ainc_bit_pos is defined")
    # RW bit fields
    rw_bit_pos: int = TsoField(ftype=int, required=False, desc="Bit position in address of the R/W bit.")
    write_active_level: int = TsoField(ftype=int, required=False, default=0, desc="Active state of R/W bit for Writes")
    # Max transfer field
    max_transfer_size: int = TsoField(ftype=int, required=False, default=2048, desc="Max number of bytes per FD transfer")
    # Address shift field
    address_shift: int = TsoField(ftype=int, required=False, default=0, desc="Number of bits to shift address. Positive "
                                                                             "shifts left, negative shifts right.")

    class FdAccessModes(Enum):
        READ = False
        WRITE = True

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.ainc_bit_pos is not None:
            self.ainc = True

    def write_register(self, host_controller, reg_addr, write_data, **kwargs):
        """
        Creates a single register write packet and sends it to the host controller. Currently only supports FD transfers

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param reg_addr: [int] Address of the register
        :param write_data: [int] Data to write to the register
        :return: None
        """
        if type(write_data) is list:
            self.log.error("Cannot input list into write_register, use block_write")
            raise ValueError("Cannot input list into write_register, use block_write")

        packet = self.build_packet(reg_addr, ainc=False, access_mode=self.FdAccessModes.WRITE, data_out=write_data)
        self.check_args(host_controller.spi_fd, extra=['bytes_out', 'access_mode'])
        host_controller.spi_fd(bytes_out=packet, access_mode=self.FdAccessModes.WRITE.value, **self.fields, **kwargs)

    def read_register(self, host_controller, reg_addr, **kwargs):
        """
        Creates a single register read packet and sends it to the host controller. Currently only supports FD transfers

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param reg_addr: [int] Address of the register
        :return: [int] Readback value
        """
        packet = self.build_packet(reg_addr, ainc=False, access_mode=self.FdAccessModes.READ, word_count=1)
        self.check_args(host_controller.spi_fd, extra=['bytes_out', 'access_mode'] + list(kwargs))
        bytes_in = host_controller.spi_fd(bytes_out=packet, access_mode=self.FdAccessModes.READ.value, **self.fields, **kwargs)
        read_bytes = bytes_in[self.read_reg_addr_size + self.padding:]  # Chop off the beginning of fd transaction
        return build_words_from_bytes(read_bytes, self.read_reg_data_size, self.data_byte_order)[0]

    def __block_write(self, host_controller, start_addr:int, write_data:List[int], ainc:bool):
        # Max number of write bytes per transfer
        max_write_bytes = self.max_transfer_size - self.write_reg_addr_size - self.padding
        max_write_words = int(max_write_bytes / self.write_reg_data_size)
        if len(write_data) <= max_write_words:  # Can be issued in a single transfer
            write_packet = self.build_packet(start_addr, ainc=ainc, access_mode=self.FdAccessModes.WRITE, data_out=write_data)
            self.log.debug('Block write: Writing %d words from address %s (%d)'
                           % (len(write_data), self.word_to_hex(start_addr, self.write_reg_addr_size), start_addr))
            self.check_args(host_controller.spi_fd, extra=['bytes_out'])
            host_controller.spi_fd(bytes_out=write_packet, **self.fields)
        else:  # Need to chunk up the data
            packets = []
            divisions = range(0, len(write_data), max_write_words)  # Slices of write_data to tranfer
            # Create packets for each chunk of writes
            for i, chunk in enumerate([write_data[n:n + max_write_words] for n in divisions]):
                address = start_addr + i * max_write_words * self.address_stride  # address for the current transfer
                packets.append(self.build_packet(address, ainc=ainc, access_mode=self.FdAccessModes.WRITE, data_out=chunk))
                self.log.debug('Block write: Writing %d words to address %s (%d)'
                               % (len(chunk), self.word_to_hex(address, self.write_reg_addr_size), address))
            # Send out all transfers
            for packet in packets:
                self.check_args(host_controller.spi_fd, extra=['bytes_out'])
                host_controller.spi_fd(bytes_out=packet, **self.fields)

    def block_write(self, host_controller, start_addr, write_data):
        """
        Writes each word from write_data starting at start_addr (incrementing)

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block write
        :param write_data: [list<int>] List of words to write
        :return: None
        """
        if self.ainc:
            self.__block_write(host_controller, start_addr, write_data, self.ainc)
        else:  # Individual transactions
            self.log.debug("Block write: Issuing %d individual transfers" % len(write_data))
            for word_num, word in enumerate(write_data):
                address = start_addr + word_num * self.address_stride
                self.log.debug("Wrote %s to address %s (%d)" % (self.word_to_hex(word, self.write_reg_data_size),
                                                                self.word_to_hex(address, self.write_reg_addr_size),
                                                                address))
                self.write_register(host_controller, reg_addr=address, write_data=word)

    def __block_read(self, host_controller, start_addr:int, word_count:int, ainc:bool) -> List[int]:
        # Max numbers of read bytes per transfer
        max_read_bytes = self.max_transfer_size - self.read_reg_addr_size - self.padding
        max_read_words = int(max_read_bytes / self.read_reg_data_size)
        if word_count <= max_read_words:  # Can be issued in a single transfer
            self.log.debug('Block read: Reading %d words from address %s (%d)'
                           % (word_count, self.word_to_hex(start_addr, self.read_reg_addr_size), start_addr))
            read_packet = self.build_packet(start_addr, ainc=ainc, access_mode=self.FdAccessModes.READ,
                                            word_count=word_count)
            self.check_args(host_controller.spi_fd, extra=['bytes_out'])
            bytes_in = host_controller.spi_fd(bytes_out=read_packet, **self.fields)
            read_bytes = bytes_in[self.read_reg_addr_size + self.padding:]
            return build_words_from_bytes(read_bytes, self.read_reg_data_size, self.data_byte_order)
        else:  # Need to chunk up the data
            packets = []
            divisions = range(0, word_count, max_read_words)  # Slices of write_data to tranfer
            # Create packets for each chunk of writes
            for i, chunk in enumerate([min(word_count - div, max_read_words) for div in divisions]):
                address = start_addr + i * max_read_words * self.address_stride  # Address for current transfer
                self.log.debug('Block read: Reading %d words from address %s (%d)'
                               % (chunk, self.word_to_hex(address, self.read_reg_addr_size), address))
                packets.append(self.build_packet(address, ainc=ainc, access_mode=self.FdAccessModes.READ,
                                                 word_count=chunk))
            # Send out all transfers
            words_out = []
            for packet in packets:
                self.check_args(host_controller.spi_fd, extra=['bytes_out'])
                bytes_in = host_controller.spi_fd(bytes_out=packet, **self.fields)
                read_bytes = bytes_in[self.read_reg_addr_size + self.padding:]
                words_out.extend(build_words_from_bytes(read_bytes, self.read_reg_data_size, self.data_byte_order))
            return words_out

    def block_read(self, host_controller, start_addr, word_count):
        """
        Reads a block of word_count words from start_addr. Will issue multiple transfers if word_count exceeds the
        max_tranfer_size defined

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block read
        :param word_count: [int] number of words to read
        :return: [list<int>] List of length word_count containing register values
        """
        if self.ainc:
            return self.__block_read(host_controller, start_addr, word_count, self.ainc)
        else:  # individual transactions
            self.log.debug("Block read: Issuing %d individual transfers" % word_count)
            words_out = []
            for address in range(start_addr, start_addr + word_count * self.address_stride, self.address_stride):
                word = self.read_register(host_controller, reg_addr=address)
                words_out.append(word)
                self.log.debug("Read %s from address %s (%d)" % (self.word_to_hex(word, self.read_reg_data_size),
                                                                 self.word_to_hex(address, self.read_reg_addr_size),
                                                                 address))
            return words_out

    def chain_read(self, host_controller, reg_addr: int, word_count: int) -> List[int]:
        """
        Reads words from single address 'reg_addr', without incrementing. Returns list of words read.

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :return: List of words
        :rtype: list
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, data may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        return self.__block_read(host_controller, reg_addr, word_count, False)

    def chain_write(self, host_controller, reg_addr: int, write_data: List[int]):
        """
        Writes words sequentially to single address, without incrementing.

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param write_data: List of words to write
        :type write_data: list
        :return: None
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, data may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        return self.__block_write(host_controller, reg_addr, write_data, False)

    def prepare_address(self, address, ainc, access_mode=FdAccessModes.READ):
        """
        Shifts address and adds ainc/rw bits if specified.

        :param address: [int] raw address
        :param ainc: [bool] True = enable ainc bit in address, False = disable
        :param access_mode: [FdAccessModes] Enum for type of transaction. Determines value of rw bit (if specified)
        :return: [int] Configured address
        """
        # Shift address
        if self.address_shift > 0:  # Positive, use left shift
            address <<= self.address_shift
        elif self.address_shift < 0:  # Negative, use right shift
            address >>= -1 * self.address_shift
        # Add config bits
        if self.ainc_bit_pos is not None:  # Add ainc bit
            address = self.add_config_bit(address, self.ainc_bit_pos, self.ainc_active_level, ainc)
        if self.rw_bit_pos is not None:  # Add rw bit
            address = self.add_config_bit(address, self.rw_bit_pos, self.write_active_level, access_mode.value)
        return address

    def build_packet(self, reg_addr: int, ainc: bool, access_mode: Enum, word_count: int = None,
                     data_out: Union[int, List[int]] = None) -> List[int]:
        """
        Builds SPI packet, including any configuration bits (if specified).

        :param reg_addr: Register address
        :type reg_addr: int
        :param ainc: Auto increment flag
        :type ainc: bool
        :param access_mode: Access mode enum that denotes whether the packet will be a read or a write
        :type access_mode: FdAccessModes
        :param word_count: If access_mode is a read, must specify number of words to read
        :type word_count: int
        :param data_out: If access_mode is a write, must specify data to send over MOSI
        :type data_out: int | List[int]
        :return: Spi FD packet, list of bytes to be transmitted over MOSI
        :rtype: List[int]
        """
        # Check arguements
        if access_mode is self.FdAccessModes.READ:
            if word_count is None:
                raise ValueError("keyword argument 'word_count' required for reads")
        else:
            if data_out is None:
                raise ValueError("keyword argument 'data_out' required for reads")
        # Make sure data_out is a list
        if type(data_out) is int:
            data_out = [data_out]
        # Get register sizes based on operation
        reg_addr_size = getattr(self, '%s_reg_addr_size' % access_mode.name.lower())  # 'read' or 'write'
        reg_data_size = getattr(self, '%s_reg_data_size' % access_mode.name.lower())
        bytes_out = []  # List of bytes to send out to MOSI
        reg_addr = self.prepare_address(reg_addr, ainc=ainc, access_mode=access_mode)  # Add config bits to address
        # Add address bytes to the data packet
        bytes_out.extend(map_word(reg_addr, reg_addr_size, self.addr_byte_order))
        # Add padding
        pad_byte = 0xFF if self.pad_value else 0x00
        bytes_out.extend([pad_byte] * self.padding)
        if access_mode is self.FdAccessModes.READ:  # Read, add padding for however many words to read
            bytes_out.extend([pad_byte] * word_count * reg_data_size)
        else:  # Write, use data_out to finish building
            for word in data_out:  # Map each word to byte list and add to output list
                bytes_out.extend(map_word(word, reg_data_size, self.data_byte_order))
        return bytes_out
