from cl_test_station.interfaces.ctrl_interface import CtrlInterface, ByteOrder
from cl_test_station.test_station_object import TsoField
from enum import Enum
from typing import List


class SpiApbInterface(CtrlInterface):
    """Control interface for SPI. Allows for SPI reading and writing at the component level"""

    # Pad fields
    padding: int = TsoField(ftype=int, desc="Number of pad Bytes between address and data frames")
    pad_value: int = TsoField(ftype=int, required=False, default=0, desc="Value of pad bits")
    # AINC fields
    ainc_bit_pos: int = TsoField(ftype=int, required=False, desc="Bit position in address of the auto-increment bit.")
    ainc_active_level: int = TsoField(ftype=int, required=False, default=1, desc="Active state for AINC bit")
    ainc: bool = TsoField(ftype=bool, required=False, default=False,
                          desc="Flag that indicated if AINC is being used. Will be set to True if ainc_bit_pos is defined")
    # Max transfer field
    max_transfer_size: int = TsoField(ftype=int, required=False, default=4096, desc="Max number of bytes per transfer")
    # Chip select field
    chip_select: int = TsoField(ftype=int, required=True, desc="Number corresponding to a chip select pin")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.ainc_bit_pos is not None:
            self.ainc = True

    def write_register(self, host_controller, reg_addr, write_data, **kwargs):
        """
        Creates a single register write packet and sends it to the host controller. Currently only supports FD transfers

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param reg_addr: [int] Address of the register
        :param write_data: [int] Data to write to the register
        :return: None
        """
        if type(write_data) is list:
            self.log.error("Cannot input list into write_register, use block_write")
            raise ValueError("Cannot input list into write_register, use block_write")
        self.check_args(host_controller.spi_apb_block_write, extra=['values', 'address'])
        err_code = host_controller.spi_apb_block_write(values=[write_data], address=reg_addr, **self.fields)
        self.raise_error(err_code)

    def read_register(self, host_controller, reg_addr, **kwargs):
        """
        Creates a single register read packet and sends it to the host controller. Currently only supports FD transfers

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param reg_addr: [int] Address of the register
        :return: [int] Readback value
        """
        self.check_args(host_controller.spi_apb_block_read, extra=['length', 'address'])
        data_read = host_controller.spi_apb_block_read(address=reg_addr, length=1, **self.fields)
        self.raise_error(data_read)
        return data_read[0]

    def __block_write(self, host_controller, start_addr:int, write_data:List[int], ainc:bool):
        self.configure_ctrl_reg(host_controller, ainc)
        # Max number of write bytes per transfer
        max_write_bytes = self.max_transfer_size - self.write_reg_addr_size - self.padding
        max_write_words = int(max_write_bytes / self.write_reg_data_size)
        if len(write_data) <= max_write_words:  # Can be issued in a single transfer
            self.log.debug('Block write: Writing %d words to address %s (%d)'
                           % (len(write_data), self.word_to_hex(start_addr, self.write_reg_addr_size), start_addr))
            self.check_args(host_controller.spi_apb_block_write, extra=['values', 'address'])
            host_controller.spi_apb_block_write(values=write_data, address=start_addr, **self.fields)
        else:  # Need to chunk up the data
            divisions = range(0, len(write_data), max_write_words)  # Slices of write_data to tranfer
            # Create packets for each chunk of writes
            for i, chunk in enumerate([write_data[n:n + max_write_words] for n in divisions]):
                address = start_addr + i * max_write_words * self.address_stride  # address for the current transfer
                self.log.debug('Block write: Writing %d words to address %s (%d)'
                               % (len(chunk), self.word_to_hex(address, self.write_reg_addr_size), address))
                self.check_args(host_controller.spi_apb_block_write, extra=['values', 'address'])
                host_controller.spi_apb_block_write(values=chunk, address=address, **self.fields)

    def block_write(self, host_controller, start_addr, write_data):
        """
        Writes each word from write_data starting at start_addr (incrementing)

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block write
        :param write_data: [list<int>] List of words to write
        :return: None
        """
        if self.ainc:
            self.__block_write(host_controller, start_addr, write_data, True)
        else:  # Individual transactions
            self.log.debug("Block write: Issuing %d individual transfers" % len(write_data))
            for word_num, word in enumerate(write_data):
                address = start_addr + word_num * self.address_stride
                self.log.debug("Wrote %s to address %s (%d)" % (self.word_to_hex(word, self.write_reg_data_size),
                                                                self.word_to_hex(address, self.write_reg_addr_size),
                                                                address))
                self.write_register(host_controller, reg_addr=address, write_data=word)

    def __block_read(self, host_controller, start_addr:int, word_count:int, ainc:bool) -> List[int]:
        self.configure_ctrl_reg(host_controller, ainc)
        # Max numbers of read bytes per transfer
        max_read_bytes = self.max_transfer_size - self.read_reg_addr_size - self.padding
        max_read_words = int(max_read_bytes / self.read_reg_data_size)
        if word_count <= max_read_words:  # Can be issued in a single transfer
            self.log.debug('Block read: Reading %d words from address %s (%d)'
                           % (word_count, self.word_to_hex(start_addr, self.read_reg_addr_size), start_addr))
            self.check_args(host_controller.spi_apb_block_read, extra=['length', 'address'])
            bytes_in = host_controller.spi_apb_block_read(address=start_addr, length=word_count, **self.fields)
            # read_bytes = bytes_in[self.read_reg_addr_size + self.padding:]
            return bytes_in
        else:  # Need to chunk up the data
            words_out = []
            divisions = range(0, word_count, max_read_words)  # Slices of write_data to tranfer
            # Create packets for each chunk of writes
            for i, chunk in enumerate([min(word_count - div, max_read_words) for div in divisions]):
                address = start_addr + i * max_read_words * self.address_stride  # Address for current transfer
                self.log.debug('Block read: Reading %d words from address %s (%d)'
                               % (chunk, self.word_to_hex(address, self.read_reg_addr_size), address))
                self.check_args(host_controller.spi_apb_block_read,
                                extra=['length', 'address'])
                read_bytes = host_controller.spi_apb_block_read(address=address, length=chunk, **self.fields)
                words_out.extend(read_bytes)
            return words_out

    def block_read(self, host_controller, start_addr, word_count):
        """
        Reads a block of word_count words from start_addr. Will issue multiple transfers if word_count exceeds the
        max_tranfer_size defined

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block read
        :param word_count: [int] number of words to read
        :return: [list<int>] List of length word_count containing register values
        """
        if self.ainc:
            return self.__block_read(host_controller, start_addr, word_count, True)
        else:  # individual transactions
            self.log.debug("Block read: Issuing %d individual transfers" % word_count)
            words_out = []
            for address in range(start_addr, start_addr + word_count * self.address_stride, self.address_stride):
                word = self.read_register(host_controller, reg_addr=address)
                words_out.append(word)
                self.log.debug("Read %s from address %s (%d)" % (self.word_to_hex(word, self.read_reg_data_size),
                                                                 self.word_to_hex(address, self.read_reg_addr_size),
                                                                 address))
            return words_out

    def chain_read(self, host_controller, reg_addr: int, word_count: int) -> List[int]:
        """
        Reads words from single address 'reg_addr', without incrementing. Returns list of words read.

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :return: List of words
        :rtype: list
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, data may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        return self.__block_read(host_controller, reg_addr, word_count, False)

    def chain_write(self, host_controller, reg_addr: int, write_data: List[int]):
        """
        Writes words sequentially to single address, without incrementing.

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param write_data: List of words to write
        :type write_data: list
        :return: None
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, data may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        return self.__block_write(host_controller, reg_addr, write_data, False)

    def configure_ctrl_reg(self, host_controller, ainc):
        """
        Sets ainc bit in control register.

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :type host_controller: HostController
        :param ainc: [bool] True = enable ainc bit in address, False = disable
        :type ainc: bool
        :return: None
        """
        if self.ainc_bit_pos is not None:  # Add ainc bit
            read_ctrl_reg_addr = 0x91
            write_ctrl_reg_addr = 0xA1
            self.check_args(host_controller.spi_fd, extra=['bytes_out'])
            ctrl_reg_value = host_controller.spi_fd(bytes_out=[read_ctrl_reg_addr, 0x0, 0x0], **self.fields)[2]
            ctrl_reg_value &= ~(1 << self.ainc_bit_pos)  # Mask off ainc bit from ctrl reg
            ainc_bit = self.ainc_active_level ^ int(not ainc)  # Get value of the bit
            ctrl_reg_value |= ainc_bit << self.ainc_bit_pos  # Set bit in
            self.check_args(host_controller.spi_fd, extra=['bytes_out'])
            host_controller.spi_fd(bytes_out = [write_ctrl_reg_addr, ctrl_reg_value], **self.fields)
            self.log.debug("Setting ainc bit %d of ctrl reg to %d (%sactive)" %
                           (self.ainc_bit_pos, ainc_bit, '' if ainc_bit == self.ainc_active_level else 'in'))
