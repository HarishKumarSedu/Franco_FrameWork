"""
Module for SPMI related classes. MIPI's SPMI page: https://www.mipi.org/specifications/system-power-management-interface
Author: Evan Canter <evan.canter@cirrus.com>
"""
from enum import Enum
from typing import List

from cl_test_station.interfaces.ctrl_interface import CtrlInterface, ByteOrder, CtrlInterfaceError
from cl_test_station.interfaces.ctrl_interface import map_word, build_words_from_bytes, build_word, map_words_to_bytes
from cl_test_station.test_station_object import TsoField


class SpmiParityError(CtrlInterfaceError):
    """Exception for SPMI parity error"""
    pass


class SpmiNackError(CtrlInterfaceError):
    """Exception for SPMI NACK error"""
    pass


class SpmiTimeoutError(CtrlInterfaceError):
    """Exception for SPMI timeout error"""
    pass


class CommandType(Enum):
    """Enumerations for types SPMI command to use. Auto lets the interface chose which command to use based on data and
    address size"""
    AUTO = 0
    BASE = 1
    EXTENDED = 2
    EXTENDED_LONG = 3


class SpmiInterface(CtrlInterface):
    """Interface for MIPI SPMI (System Power Management Interface)"""
    peripheral_id: int = TsoField(ftype=int, desc="Target device's SPMI peripheral ID. Can be 0 through 15")

    ERROR_CODES = {-1: SpmiParityError,
                   -2: SpmiNackError,
                   -3: SpmiTimeoutError,
                   -4: NotImplementedError}

    SPMI_FUNCTIONS = {
        CommandType.BASE: 'spmi_register_*',
        CommandType.EXTENDED: 'spmi_extended_register_*',
        CommandType.EXTENDED_LONG: 'spmi_extended_register_*_long',
    }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.addressibility = int(self.read_reg_data_size / self.address_stride)   # Bytes per memory location, usually 1
        self.fields['addressibility'] = self.addressibility

    def get_optimal_mode(self, address, write_data=None, word_count=None):
        """
        Checks address, data and addr size and finds compatible SPMI function

        :param address: [int] address of the access
        :param write_data: [list<int>] list of words to write
        :return: [CommandType] compatible function type
        """
        # Get possible modes based only on address
        if address < 32:  # Address is 5-bit, can use BASE mode
            modes = {CommandType.BASE, CommandType.EXTENDED, CommandType.EXTENDED_LONG}
        elif address < 256:  # Address is 8-bit
            modes = {CommandType.EXTENDED, CommandType.EXTENDED_LONG}
        elif address < 65536:  # 16-bit
            modes = {CommandType.EXTENDED_LONG}
        else:
            raise ValueError(f"Address given ({address}) is greater than 65536. SPMI only supports up to 16 bit "
                             f"addresses")
        # Get possible modes based only on word_count
        if word_count is not None:
            data_bytes = word_count * self.read_reg_data_size
        elif write_data is not None:
            if type(write_data) is int:
                write_data = [write_data]
            data_bytes = len(write_data) * self.write_reg_data_size
        else:
            raise ValueError("Must specify either word_count or write_data")
        if data_bytes == 1:  # Can use any mode
            data_set = {CommandType.BASE, CommandType.EXTENDED, CommandType.EXTENDED_LONG}
        elif data_bytes <= 8:  # Anything but BASE
            data_set = {CommandType.EXTENDED, CommandType.EXTENDED_LONG}
        elif data_bytes <= 16:  # Can't use LONG
            data_set = {CommandType.EXTENDED}
        else:
            raise ValueError("write_data is more than 16 bytes. SPMI can only support up to 16 bytes in one "
                             "transaction."
                             " Use block/chain functions instead")
        # Get modes that are compatible with both address and word_count
        modes = modes.intersection(data_set)
        if modes:
            return min(modes, key=lambda mode: mode.value)
        else:  # No compatible SPMI Commands for given args
            raise ValueError(f"No Compatible SPMI Commands for given byte count ({data_bytes}) and address ({address}).")

    def write_register(self, host_controller, reg_addr, write_data, priority=0, mode=CommandType.AUTO, **kwargs):
        """
        Writes a register using SPMI command specified in 'mode'.

        :param host_controller: Reference to controller to use
        :type host_controller: HostController, PyroReceiver
        :param reg_addr: Address of the register
        :type reg_addr: int
        :param write_data: Value to write to register
        :type write_data: int
        :param priority: Arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        :param mode: Type of command to use
        :type mode: CommandType
        :param kwargs: 'pointer' can be used for 24-bit access
        :return: None
        """
        kwargs.update({  # These kwarg names are standard across all SPMI funcitons in AudioHubController
            'address': reg_addr,
            'priority': priority
        })
        if mode is CommandType.AUTO:  # Pick mode based on input param sizes/values
            mode = self.get_optimal_mode(reg_addr, write_data=write_data)
        spmi_func_name = self.SPMI_FUNCTIONS[mode].replace('*', 'write')  # Get SPMI write function name
        try:
            spmi_func = getattr(host_controller, spmi_func_name)  # Pull SPMI function from controller
        except AttributeError:
            msg = "%s (%s) doesn't support SPMI" % (host_controller.ref_name, host_controller.class_type.split('.')[-1])
            self.log.error(msg)
            raise NotImplementedError(msg)
        self.log.debug("Using '%s' for register write" % spmi_func_name)
        write_bytes = map_word(write_data, self.write_reg_data_size, self.data_byte_order)
        err_code = spmi_func(write_data=write_bytes, **kwargs, **self.fields)
        self.raise_error(err_code)

    def read_register(self, host_controller, reg_addr, priority=0, mode=CommandType.AUTO, **kwargs):
        """
        Reads a register using SPMI command specified in 'mode'.

        :param host_controller: Reference to controller to use
        :type host_controller: HostController, PyroReceiver
        :param reg_addr: Address of the register
        :type reg_addr: int
        :param priority: [int] Arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        :param mode: Type of command to use
        :type mode: CommandType
        :return: Readback value
        :rtype: int
        """
        kwargs.update({  # These kwarg names are standard across all SPMI funcitons in AudioHubController
            'length': self.read_reg_data_size,
            'address': reg_addr,
            'priority': priority,
        })
        if mode is CommandType.AUTO:  # Pick mode based on input param sizes/values
            mode = self.get_optimal_mode(reg_addr, word_count=1)
        spmi_func_name = self.SPMI_FUNCTIONS[mode].replace('*', 'read')  # Get SPMI read function name
        try:
            spmi_func = getattr(host_controller, spmi_func_name)  # Pull SPMI function from controller
        except AttributeError:
            msg = "%s (%s) doesn't support SPMI" % (host_controller.ref_name, host_controller.class_type.split('.')[-1])
            self.log.error(msg)
            raise NotImplementedError(msg)
        self.log.debug("Using '%s' for register read" % spmi_func_name)
        bytes_in = spmi_func(**kwargs, **self.fields)
        self.raise_error(bytes_in)
        if type(bytes_in) is int:
            bytes_in = [bytes_in]
        return build_word(bytes_in, self.read_reg_data_size, self.data_byte_order)

    def block_read(self, host_controller, start_addr, word_count, priority=0):
        """
        Reads a block of word_count words from start_addr. Will issue multiple transfers if word_count exceeds the
        max_tranfer_size defined

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block read
        :param word_count: [int] number of words to read
        :param priority: arbitration level. **0=secondary master arb, 1=primary master arb**
        :return: [list<int>] List of length word_count containing register values
        """
        byte_count = word_count * self.read_reg_data_size
        self.check_args(host_controller.spmi_block_read, extra=['start_addr', 'byte_count', 'priority'])
        bytes_in = host_controller.spmi_block_read(start_addr=start_addr, byte_count=byte_count, priority=priority, **self.fields)
        self.raise_error(bytes_in)
        return build_words_from_bytes(bytes_in, self.read_reg_data_size, self.data_byte_order)

    def block_write(self, host_controller, start_addr, write_data, priority=0):
        """
        Writes each word from write_data starting at start_addr (incrementing)

        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :param start_addr: [int] start address of the block write
        :param write_data: [list<int>] List of words to write
        :param priority: arbitration level. **0=secondary master arb, 1=primary master arb**
        :return: None
        """
        bytes_out = map_words_to_bytes(write_data, self.write_reg_data_size, self.data_byte_order)
        self.check_args(host_controller.spmi_block_write, extra=['start_addr', 'write_data', 'priority'])
        ret = host_controller.spmi_block_write(start_addr=start_addr, write_data=bytes_out, priority=priority, **self.fields)
        self.raise_error(ret)

    def chain_read(self, host_controller: object, reg_addr: int, word_count: int, read_size: int = None,
                   priority: int = 0) -> List[int]:
        """
        Performs successive reads to a single address and returns a list of all values read.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param reg_addr: Register address
        :type reg_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :param read_size: Size in bytes of successive bytes to read. If none is given, one word will be read per SPMI
            transaction
        :type read_size: int
        :param priority: SPMI priority
        :type priority: int
        :return: List of words read
        :rtype: List[int]
        """
        if not read_size:
            read_size = self.read_reg_data_size
        words_per_read = int(read_size/self.read_reg_data_size)
        num_reads = int(word_count/words_per_read)
        self.check_args(host_controller.spmi_chain_read, extra=['address', 'num_reads', 'read_size', 'priority'])
        bytes_in = host_controller.spmi_chain_read(address=reg_addr, num_reads=num_reads, read_size=read_size, priority=priority, **self.fields)
        return build_words_from_bytes(bytes_in, self.read_reg_data_size, self.data_byte_order)

    def chain_write(self, host_controller: object, reg_addr: int, write_data: List[int], write_size: int = None,
                    priority: int = 0):
        """
        Performs successive writes to a single address.

        :param host_controller: Host controller reference to use
        :type host_controller: HostController
        :param reg_addr: Register address to write to
        :type reg_addr: int
        :param write_data: Words to write
        :type write_data: List[int]
        :param write_size: Size in bytes of successive writes. If none is given, one word will be written per SPMI
            transaction
        :type write_size: int
        :param priority: SPMI priority
        :type priority: int
        :return: None
        :rtype: None
        """
        if not write_size:
            write_size = self.write_reg_data_size
        bytes_out = map_words_to_bytes(write_data, self.write_reg_data_size, self.data_byte_order)
        self.check_args(host_controller.spmi_chain_write, extra=['address', 'write_data', 'write_size', 'priority'])
        ret = host_controller.spmi_chain_write(address=reg_addr, write_data=bytes_out, write_size=write_size, priority=priority, **self.fields)

    def enable(self, base_addr, host_controller=None):
        """
        Enables the AH spmi master core, enables interrupts

        :param base_addr: Base address of the master
        :type base_addr: int
        :return: 0
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        return host_controller.enable_spmi(base_addr)

    def set_slave_address_db(self, addr, host_controller=None):
        """
        Sets slave address on the AH built in slave. **NOT FOR USE WITH MAHONEY**

        :param addr: desired slave address
        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :return: 0
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        self.log.debug("Setting slave to address: " + str(addr))
        return host_controller.spmi_set_slave_addr(addr)

    def set_master_prescaler(self, rate, host_controller=None):
        """
        Sets prescaler. divides 100mHz clock by rate * 4. Ex: prescaler of 2 results in 12.5 mHz SCLK

        :param rate: clock divide value
        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :return: 0
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        return host_controller.spmi_set_master_req_prescaler(rate)

    def request_master_write(self):  # TODO: Once we know how to instantiate master write on mahoney, use SPI to mst_wr
        return 0
        # Send call to AH side client to write SPI to spmi slave on fpga

    # READ COMMANDS
    def spmi_register_read(self, address, priority=0, host_controller=None):
        """
        Reads 1 byte from register

        :param address: 5 bit address
        :param priority: arbitration level. **0=secondary master arb, 1=primary master arb**
        :type priority: int
        :return: result of register_read
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        if address > 0x1F or address < 0:
            raise ValueError("Address must be 5-bit: " + hex(addr))
        self.check_args(host_controller.spmi_register_read, extra=['address', 'priority'])
        result = host_controller.spmi_register_read(address=address, priority=priority, **self.fields)
        self.raise_error(result)
        return result

    def spmi_extended_register_read(self, address, word_count=1, priority=0, host_controller=None):
        """
        SPMI read with 8 bit addressing and up to 16 bytes read data

        :param address: [int] 8 bit address
        :param word_count: number of words
        :param priority: [int] arbitration level. 0=secondary master arb, 1=primary master arb
        :return: [list<int>] list of words
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        byte_count = self.read_reg_data_size * word_count
        if address > 0xFF or address < 0:
            raise ValueError("address must be 8-bit: " + hex(address))
        if byte_count > 16 or byte_count < 1:
            raise ValueError("Byte count is out of range: " + str(byte_count))
        self.check_args(host_controller.spmi_extended_register_read, extra=['address', 'length', 'priority'])
        bytes_in = host_controller.spmi_extended_register_read(address=address, length=byte_count, priority=priority, **self.fields)
        self.raise_error(bytes_in)
        return build_words_from_bytes(bytes_in, self.read_reg_data_size, self.data_byte_order)

    def spmi_extended_register_read_long(self, address, word_count=1, priority=0, host_controller=None):
        """
        SPMI read with 16 bit addressing and up to 8 bytes read data

        :param address: 16 bit address
        :param word_count: number of words
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :return: list of words
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        if address > 0xFFFF or address < 0:
            raise ValueError("address must be 16-bit: " + hex(address))
        byte_count = self.read_reg_data_size * word_count
        if byte_count > 8 or byte_count < 1:
            raise ValueError("size is out of range: " + str(byte_count))
        self.check_args(host_controller.spmi_extended_register_read_long, extra=['address', 'length', 'priority'])
        bytes_in = host_controller.spmi_extended_register_read_long(address=address, length=byte_count, priority=priority, **self.fields)
        self.raise_error(bytes_in)
        return build_words_from_bytes(bytes_in, self.read_reg_data_size, self.data_byte_order)

    # WRITE COMMANDS
    def spmi_register_write(self, address, write_data, priority=0, host_controller=None):
        """
        SPMI write 1 byte to register

        :param address: 5-bit address
        :param write_data: 1 byte to write
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :return: 0
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        if isinstance(write_data, int):
            write_data = [write_data]
        if write_data[0] > 0xFF or write_data[0] < 0:
            raise ValueError("Data must be 8-bit")
        self.check_args(host_controller.spmi_register_write, extra=['address', 'write_data', 'priority'])
        err_code = host_controller.spmi_register_write(address=address, write_data=write_data, priority=priority, **self.fields)
        self.raise_error(err_code)

    def spmi_extended_register_write(self, address, write_data, priority=0, host_controller=None):
        """
        SPMI write with 8 bit addressing and up to 16 bytes of write data

        :param address: 8-bit address
        :param write_data: list of words
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :return: 0
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        if isinstance(write_data, int):
            write_data = [write_data]
        if address > 0xFF or address < 0:
            raise ValueError("address must be 8-bit: " + self.word_to_hex(address, self.write_reg_addr_size))
        bytes_out = map_words_to_bytes(write_data, self.write_reg_data_size, self.data_byte_order)
        if len(bytes_out) < 1 or len(bytes_out) > 16:
            raise ValueError("Size of data out of bounds: " + str(len(bytes_out)))
        self.check_args(host_controller.spmi_extended_register_write, extra=['address', 'write_data', 'priority'])
        err_code = host_controller.spmi_extended_register_write(address=address, write_data=bytes_out, priority=priority, **self.fields)
        self.raise_error(err_code)

    def spmi_extended_register_write_long(self, address, write_data, priority=0, host_controller=None):
        """
        SPMI write with 16 bit addressing and up to 8 bytes of write data

        :param address: [int] 16-bit address
        :param write_data: [list<int>] List of words to write
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :param host_controller: [HostController, PyroReceiver] Reference to controller to use
        :return: 0
        """
        if host_controller is None:
            host_controller = self.component.active_controller
        if isinstance(write_data, int):
            write_data = [write_data]
        # data_list = self.spmi_config.pack_byte_array(data_list, data_size)
        if address > 0xFFFF or address < 0:
            raise ValueError("address must be 16-bit, got " + self.word_to_hex(address, self.write_reg_addr_size))
        if len(write_data)*self.write_reg_data_size > 8:
            raise ValueError("packet must be less than 8 bytes, got %d bytes" % len(write_data)*self.write_reg_data_size)

        bytes_out = map_words_to_bytes(write_data, self.write_reg_data_size, self.data_byte_order)
        self.check_args(host_controller.spmi_extended_register_write_long, extra=['address', 'write_data', 'priority'])
        err_code = host_controller.spmi_extended_register_write_long(address=address, write_data=bytes_out, priority=priority, **self.fields)
        self.raise_error(err_code)

    def poll_for_int(self):
        """
        Busy-waits for an RSC interrupt.

        :return: None
        :rtype: None
        """
        raise NotImplementedError("Interrupt polling is not currently supported")
        return self.container.poll_for_int()
