import os
import sys
import pylink
import logging
import datetime
import threading
import traceback
import xlsxwriter
from collections import namedtuple, defaultdict
from cl_test_station.interfaces.jlink_i2c_interface import JlinkI2cInterface
from unified_modules.resources.resource_itm.itm_trace_parser import ItmTraceParser
from unified_modules.resources.resource_math_lib.resource_math_lib import ResourceMathLib as Stats
from unified_modules.resources.resource_data_lib.resource_data_lib import ResourceDataLib as DataLib
from unified_modules.resources.resource_itm.resource_itm_lib import ResourceItmLib as ItmPacketFactory


class RegisterWatchError(Exception):
    """Define DominoSwdError Exception type"""
    def __init__(self, message):
        super(RegisterWatchError, self).__init__(message)


class JlinkSwdInterface(JlinkI2cInterface):
    """ Register Watchpoint class """

    SPEED = namedtuple('clock_speed', 'KHZ MHZ')(1000, 1000000)

    DWT_WP_REGISTERS = namedtuple('dwt_registers', 'DWT_COMP DWT_MASK DWT_FUNCTION')(0xe0001020, 0xe0001024, 0xE0001028)
    DWT_WP_OFFSET = 0x10

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.swo_speed = None
        self.raw_traces = []
        self.available_comparators = 4
        self.swo_capture_flag = False
        self.swo_log_name = None
        self.trace_dict = None
        self.trace_packets = None
        self.excel_manager = None
        self.swo_thread = None
        self.swo_output_dir = None
        self.itm_factory = None
        self.itm_parser = None
        self.tpiu_decoder = None
        self.local_timestamp_enabled = True
        self.global_timestamp_enabled = False
        self.event_counter_enabled = False
        self.initial_packet_ignore_count = 0
        self.delta_time_stats = Stats()
        self.max_packet_error_allowed = 0

        self.device_name = None
        self.DataLib = DataLib()

        self.mcu_freq_mhz = 48
        self.divisor = 1
        self.register_watch_list = []

        self.SWD = None  # stub for ST
        self._jlink = None
        self._log = logging.getLogger(JlinkSwdInterface.__name__)
        self.update_tpiu_clock_enable = True

    def set_active_jlink(self, jlink_object):
        self._jlink = jlink_object

    @property
    def jlink(self):
        return self._jlink

    def configure_and_start_itm(self, target_device, output_folder):
        self.configure_watchpoints(self.register_watch_list, False, output_folder)
        self.start_watchpoint_capture(target_device)
        self._log.info(f"ITM enabled. Configuring {len(self.register_watch_list)} registers watch points:\n"
                       f"{[hex(value) for value in self.register_watch_list]}")

    """
    ====================================================================================================
    Nucleo Read/Write Functions
    ====================================================================================================
    """

    # def read_reg(self, target, addr, word_count, i2c_mode=None):
    #     return super().read_reg(target, addr, word_count, i2c_mode)
    #
    # def write_reg(self, target, addr, data, i2c_mode=None):
    #     return super().write_reg(target, addr, data, i2c_mode)

    def write_register(self, host_controller, reg_addr, write_data):
        super().write_register(host_controller, reg_addr, write_data)

    def read_register(self, host_controller, reg_addr):
        return super().read_register(host_controller, reg_addr)

    def set_mcu_freq(self, freq_mhz, divisor=1):
        self.mcu_freq_mhz = freq_mhz
        self.divisor = divisor

    def set_register_watchpoint(self, register_watch_list):
        self.register_watch_list = register_watch_list
        self.configure_watchpoints(self.register_watch_list)

    @staticmethod
    def get_traceback_string(ex, ex_traceback=None):
        """
        Returns traceback string for an exception in Python 2 or Python 3
        Python 2 will need to pass ex_traceback obtained by "_, _, ex_traceback = sys.exc_info()"
        Python 3 can leave the ex_traceback argument empty
        :param ex: Exception for which traceback shall be returned
        :param ex_traceback: Traceback object required for Processing Python 2 requests
        :return: String containing traceback information
        """
        # Taken from https://realpython.com/the-most-diabolical-python-antipattern/
        if ex_traceback is None:
            ex_traceback = ex.__traceback__
        tb_lines = traceback.format_exception(ex.__class__, ex, ex_traceback)
        tb_text = ''.join(tb_lines).rstrip()
        return tb_text

    def _configure_swo(self):
        """ Set SWO pin configuration and speed """
        self._log.info("Configuring SWO...")
        # TODO: Investigate what coresight configure actually does
        # self.container.jlink.coresight_configure()
        self.jlink.set_reset_strategy(pylink.enums.JLinkResetStrategyCortexM3.RESETPIN)
        # SWO speed set at MHz
        supported_swo_speeds = self.jlink.swo_supported_speeds((self.mcu_freq_mhz // self.divisor) * self.SPEED.MHZ, 10)
        self.swo_speed = supported_swo_speeds[0]
        self._log.info('Selected SWO Speed: {0}'.format(self.swo_speed))

    def _configure_tpiu(self, ccm_mcu_clock_ctrl=0x40003C08, ctrl_mask_value=0x00200200):
        """  Values are for Toots:
            ccm_mcu_clock_ctrl= 0x40003C08
            ctrl_mask_value= 0x00200200
            The for Domino/Smokey/Fats:
            ccm_mcu_clock_ctrl= 0x40004004
            ctrl_mask_value= 0x0800000
        """
        self._log.info("Configuring TPIU...")
        if self.update_tpiu_clock_enable:
            # Unlock sequence on CCM_MCU.COMMAND
            self.jlink.memory_write32(0x40003C00, [0xAAAA])
            self.jlink.memory_write32(0x40003C00, [0xC3C3])
            # CCM_MCU.CCM_MCU_CLOCK_CTRL_2.CKEN_CLK_TPIU = 1
            set_tpiu_clk_bit = int(self.jlink.memory_read32(ccm_mcu_clock_ctrl, 1)[0] | ctrl_mask_value)
            self.jlink.memory_write32(ccm_mcu_clock_ctrl, [set_tpiu_clk_bit])
            # CCM_MCU.CCM_MCU_DIVIDE_CTRL_1.TPIU_DIVIDE = 0x1
            mcu_divide_ctrl1_addr = 0x40003C14
            mcu_divide_value = self.jlink.memory_read32(mcu_divide_ctrl1_addr, 1)[0]
            clear_tpiu_div_bits = self.DataLib.set_bits_field(mcu_divide_value, 3, 26, 0, 32)
            self.jlink.memory_write32(mcu_divide_ctrl1_addr, [clear_tpiu_div_bits])
            # Lock sequence on CCM_MCU.COMMAND
            self.jlink.memory_write32(0x40003C00, [0xAAAA])
            self.jlink.memory_write32(0x40003C00, [0x9696])
        # Set TPIU_SPPR - Selected Pin Protocol Register, TXMODE to Async SWO
        self.jlink.memory_write32(0xE00400F0, [0x00000002])
        # Set TPIU_SPPR with Manchester Encoding
        # self.container.jlink.memory_write32(0xE00400F0, [0x00000001])
        # Set TPIU_FFCR - Continuous formatting disabled
        self.jlink.memory_write32(0xE0040304, [0x100])

    def _configure_dwt_and_itm(self):
        """ Unlock access to ITM registers, and enable DWT transmission to
            TPIU
        """
        self._log.info("Configuring DWT and ITM...")
        # Unlock access to ITM registers
        self.jlink.memory_write32(0xE0000FB0, [0xC5ACCE55])
        # Enable DEMCR.TRCENA, to enable DWT and ITM blocks
        self.jlink.memory_write32(0xE000EDFC, [0x01000000])
        # ITM Trace Control Register, enable TXENA (DWT forwarding to TPIU)
        itm_tcr_value = 0x00000008
        if self.global_timestamp_enabled:
            # Set GTSFREQ (Global Timestamp generation)
            itm_tcr_value |= 0xc00
        elif self.local_timestamp_enabled:
            # Set TSENA (Local Timestamp generation)
            itm_tcr_value |= 0x2
        self.jlink.memory_write32(0xE0000E80, [itm_tcr_value])
        dwt_ctrl_value = 0x1 << 19 if self.event_counter_enabled else 0x0
        self.jlink.memory_write32(0xE0001000, [dwt_ctrl_value])

    def _configure_data_watchpoints(self, wp_list):
        """ Configure the data watchpoints (up to four) with the addresses
            provided in the wp_list. Set the DWT_COMPn, DWT_MASKn, and
            DWT_FUNCTIONn registers.

            DWT_FUNCTIONn Comparator function
                DATAVMATCH 0 and CYCMATCH 0 -> Address comparison
                DATAVMATCH 1 and CYCMATCH 0 -> Data value comparison

            FUNCTION (Action performed on a successful match):
                0010 | 0011 and EMITRANGE=0 - Generate Data trace data value
                                              packet
                0010 | 0011 and EMITRANGE=1 - Generate Data trace address
                                              offset and data value packets
        """
        self._log.info("Configuring Register Watchpoints...")
        # Data address comparison function
        dwt_addr_comp_function = 0x822
        dwt_compare_mask = 0x0

        if len(wp_list) > self.available_comparators:
            wp_list = wp_list[:self.available_comparators]
            raise RegisterWatchError("%s higher than %s" % (wp_list, self.available_comparators))

        for watchpoint_address in wp_list:
            # Reference value for comparison
            self.jlink.memory_write32(
                self.DWT_WP_REGISTERS.DWT_COMP + wp_list.index(watchpoint_address) * self.DWT_WP_OFFSET,
                [watchpoint_address])
            # Set ignore mask (all bits are compared)
            self.jlink.memory_write32(
                self.DWT_WP_REGISTERS.DWT_MASK + wp_list.index(watchpoint_address) * self.DWT_WP_OFFSET,
                [dwt_compare_mask])
            # Set word match for address comparison, and send address and
            # data to ITM
            self.jlink.memory_write32(
                self.DWT_WP_REGISTERS.DWT_FUNCTION + wp_list.index(watchpoint_address) * self.DWT_WP_OFFSET,
                [dwt_addr_comp_function])

    def _swo_start(self):
        """ Capture SWO data buffer """
        self.jlink.swo_start(self.swo_speed)
        # self.container.jlink.swo_enable(cpu_speed=self.mcu_clock, swo_speed=self.swo_speed)
        self.jlink.swo_flush()
        # Store data into hex file
        self.swo_log_name = os.path.join(
            self.swo_output_dir,
            '%s_swo_%s.hex' % (self.device_name, datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S"))
        )
        swo_log = open(self.swo_log_name, 'wb')
        self._log.info("SWO output file: %s" % self.swo_log_name)
        try:
            while self.swo_capture_flag:
                num_bytes = self.jlink.swo_num_bytes()
                if num_bytes != 0:
                    bytes_as_ints_list = self.jlink.swo_read(0x0, num_bytes, remove=True)
                    bytes_string = ''.join(chr(i) for i in bytes_as_ints_list)
                    if sys.version_info.major == 2:  # Compatibility with Python 2
                        swo_log.write(bytes_string)
                    else:
                        swo_log.write(bytes(bytes_as_ints_list))
        except Exception as error:
            # ex_traceback is necessary for the Python2 implementation of traceback printing
            _, _, ex_traceback = sys.exc_info()
            swo_start_exception = self.get_traceback_string(error, ex_traceback)
            raise RegisterWatchError("Failed to start SWO " + swo_start_exception)

        finally:
            swo_log.close()

    def _generate_itm_packets(self):
        self.itm_factory.load_hex_file(self.swo_log_name)
        try:
            self._log.info('{} Processing {} Bytes...'.format(self.device_name, len(self.itm_factory.byte_list)))
            self.itm_factory.convert_byte_list_to_itm_packets()
        except Exception as error:
            self._log.error('***** ITM Error Occurred! *****\n' + str(error) + '\n**********************************')
            self._log.info('Processed {0} bytes...'.format(self.itm_factory.byte_count))
            raise RegisterWatchError(str(error))
        finally:
            self._log.info('Generated %i ITM Packets...' % len(self.itm_factory.itm_packets))

    def _validate_packet_timing(self, initial_value, min_value, max_value, trace_packets):
        invalid_timing_count = 0
        previous_time_us = initial_value
        for trace_packet in trace_packets:
            delta_time = trace_packet.time_us - previous_time_us
            is_timing_valid = min_value <= delta_time <= max_value
            previous_time_us = trace_packet.time_us
            if not is_timing_valid:
                # self._log.warning("Trace packet timing invalid. Value: %i. Expected value: %i (+/-%i)" %
                #                  (delta_time, target_period_us, tolerance_us))
                invalid_timing_count += 1
        self._log.info("Invalid TracePacket Timing count: %i (out of %i packets)" % (invalid_timing_count,
                                                                                     len(trace_packets)))

    def configure_watchpoints(self, register_watch_list, halt_mcu=False, output_directory=""):
        """ Configure DWT trace registers with the address specified in
            register_watch_list. Maximum of four registers can be configured.

            :param: register_watch_list - List of registers to configure in
                                         watchpoints
            :returns: None
        """
        self.register_watch_list = register_watch_list
        self.swo_output_dir = output_directory
        if halt_mcu:
            self.jlink.halt()

        self._configure_swo()
        self._configure_tpiu()
        self._configure_dwt_and_itm()
        self._configure_data_watchpoints(register_watch_list)

        if halt_mcu:
            # noinspection PyProtectedMember
            self.jlink._dll.JLINKARM_Go()

    def start_watchpoint_capture(self, device_name):
        """ Start Serial Wire Output """
        self._log.info("Starting Register Watchpoint capture thread...")
        self.device_name = device_name
        self.swo_thread = threading.Thread(target=self._swo_start)
        self.swo_capture_flag = True
        self.swo_thread.start()

    def stop_watchpoint_capture(self):
        """ Stop capturing Serial Wire Output """
        self._log.info("Stopping Register Watchpoint capture thread...")
        self.swo_capture_flag = False
        # Stop logging serial wire output.
        self.jlink.swo_stop()
        self.swo_thread.join()
        self.jlink.swo_flush()

    def extract_trace_packets(self):
        """ Extract data trace packets from SWO output file.
            Use ItmPacketFactory to parse and retrieve a list containing
            the ITM packets, then consolidate ITM packets to generate a
            TracePacket list.

            :returns: List of TracePacket objects
        """
        self._log.info("Extracting Register Watchpoint trace packets...")
        # self.tpiu_decoder = TpiuDecoder()
        # tpiu_trace_stream = self.tpiu_decoder.decode_tpiu_data(self.swo_log_name)
        # self.itm_factory = ItmPacketFactory(tpiu_trace_stream[0])
        self.itm_factory = ItmPacketFactory()
        self._generate_itm_packets()
        self._log.info('Generating Trace Packet list...')
        self.itm_parser = ItmTraceParser(self.register_watch_list, mcu_freq_mhz=self.mcu_freq_mhz)
        self.itm_parser.local_timestamp_enabled = self.local_timestamp_enabled
        self.itm_parser.global_timestamp_enabled = self.global_timestamp_enabled
        self.trace_packets = self.itm_parser.parse_itm_trace_packets(self.itm_factory.itm_packets)
        self._log.info('Generated %i Trace Packets' % len(self.trace_packets))
        if self.itm_factory.packet_error_counter:
            self._log.warning(
                "PACKET ERROR COUNTER = {}".format(self.itm_factory.packet_error_counter))
            if self.itm_factory.packet_error_counter > self.max_packet_error_allowed:
                packet_error = "packet error={}".format(self.itm_factory.packet_error_counter)
                max_packet_error = "maximum packet error allowed={}".format(
                    self.max_packet_error_allowed)
                message = "The maximum of packet error was reached({}, {})".format(packet_error,
                                                                                   max_packet_error)
                self._log.warning(msg=message)
        return self.trace_packets

    def separate_trace_packets(self, packet_list=None):
        """ Return packets separated by address into a dictionary. A maximum of
            4 keys are added, one for each comparator set based on
            register_watch_list.

            :param: packet_list - List containing multiple TracePacket objects
            :returns: Dictionary with TracePacket objects separated
        """
        self.trace_dict = defaultdict(list)
        if not packet_list:
            packet_list = self.trace_packets
        for packet in packet_list:
            self.trace_dict[packet.address].append(packet)
        return self.trace_dict

    def validate_trace_packet_timing(self, target_period_us, tolerance_us, trace_packets=None):
        """ Check a TracePacket list and verify time between each packet is within the expected range

        :param target_period_us: Target period value in microseconds
        :param tolerance_us: Tolerance value in microseconds
        :param trace_packets: List containing TracePacket objects. Defaults to self.trace_packets
        """
        self._log.info("Validating TracePacket timing...")
        self._log.info("Timing expected value in us: %i (+/-%i)" % (target_period_us, tolerance_us))
        if not trace_packets:
            trace_packets = self.trace_packets
        # Take first value for reference
        if trace_packets:
            initial_time_us = trace_packets[0].time_us
            self._validate_packet_timing(initial_time_us, target_period_us - tolerance_us,
                                         target_period_us + tolerance_us, trace_packets[1:])
        else:
            # TODO: Add assertion and needed changes as part of DOM-9353
            pass

    def extract_register_values_from_trace_packets(self, trace_packets):
        """
        Iterate through a list of TracePacket objects, extract data field and add to a list
        :param trace_packets: List of TracePacket objects from which data fields will be extracted
        :type trace_packets: list[TracePacket]
        :return: list of register values extracted from input trace_packets
        """
        self._log.info("Parsing Register Watchpoint values from trace packets...")
        register_values = []
        for packet in trace_packets:
            register_values.append(packet.data)
        return register_values

    def create_trace_workbook(self, trace_packets, file_name=None, sheet_name="Summary"):
        if file_name:
            workbook_name = file_name
        else:
            workbook_name = self.swo_log_name.replace('.hex', '.xlsx')
        self.create_workbook(workbook_name, sheet_name)
        if isinstance(trace_packets, list):
            if len(trace_packets) > self.initial_packet_ignore_count:
                self.write_trace_list_to_workbook()
        elif isinstance(trace_packets, dict):
            if trace_packets:
                self.write_trace_dict_to_workbook()
        self.close_workbook()

    def create_workbook(self, file_path, sheet_name):
        self.excel_manager = self.ExcelManager(file_path, sheet_name)

    def close_workbook(self):
        self.excel_manager.close_workbook()

    def write_trace_dict_to_workbook(self, row=0, col=0):
        self._log.info("Writing Register Watchpoint dictionary to workbook...")
        for key in self.trace_dict:
            trace_packets = self.trace_dict[key]
            self.write_excel_headers_to_workbook(row=row, col=col)
            self.write_trace_packets_to_workbook(trace_packets=trace_packets, row=row, col=col)
            # col += 6 allows to write the following trace packets in the next columns
            col += 6

    def write_trace_list_to_workbook(self, row=0, col=0):
        self._log.info("Writing Register Watchpoint packet list to workbook...")
        self.write_excel_headers_to_workbook(row=row, col=col)
        self.write_trace_packets_to_workbook(trace_packets=self.trace_packets, row=row, col=col)

    def write_excel_headers_to_workbook(self, row=0, col=0):
        header_list = ["Address", "Access", "Cycle", "Time (us)", "Time Delta (us)", "Data"]
        for i in range(len(header_list)):
            self.excel_manager.worksheet.write_string(row=row, col=col + i, string=header_list[i])

    def write_trace_packets_to_workbook(self, trace_packets, row=0, col=0):
        self._log.info("Writing Register Watchpoint packets to workbook...")
        if self.initial_packet_ignore_count:
            previous_time_us = trace_packets[self.initial_packet_ignore_count - 1].time_us
        else:
            previous_time_us = 0
        # take a list of trace packets and write them row by row
        for packet in trace_packets[self.initial_packet_ignore_count:]:
            # it starts writing 1 row below the headers
            row += 1
            # If no ITM timestamps enabled, set time to zero for all packets
            if not (self.local_timestamp_enabled or self.global_timestamp_enabled):
                previous_time_us = 0
                packet.time_us = 0
            delta_time_us = packet.time_us - previous_time_us
            self.delta_time_stats.add_value(delta_time_us)
            previous_time_us = packet.time_us
            row_values = [hex(packet.address), packet.access, packet.cycle,
                          packet.time_us, delta_time_us, hex(packet.data)]
            for i, data in enumerate(row_values):
                if DataLib.is_integer(data) or isinstance(data, float):
                    self.excel_manager.worksheet.write_number(row=row, col=col + i, number=data)
                else:
                    self.excel_manager.worksheet.write_string(row=row, col=col + i, string=data)
        self.write_statistics_table()
        self.add_chart(row)
        # return the last written row in case the user needs to write more packets below
        return row

    def write_statistics_table(self):
        headers_row = ["Delta time MIN", "Delta time MAX", "Delta time AVG", "Delta time SD", "Delta time VAR"]
        data_row = [self.delta_time_stats.min, self.delta_time_stats.max, self.delta_time_stats.avg,
                    self.delta_time_stats.sd, self.delta_time_stats.var]
        self.excel_manager.worksheet.write_row(row=0, col=7, data=headers_row)
        self.excel_manager.worksheet.write_row(row=1, col=7, data=data_row)

    def add_chart(self, last_row):
        chart = self.excel_manager.workbook.add_chart({'type': 'line'})
        chart_range = '=Summary!$E$2:$E$%s' % (last_row + 1)
        chart.add_series({'values': chart_range, 'name': "Time Delta (us)"})
        chart.set_size({'height': 800, 'width': 1450})
        self.excel_manager.worksheet.insert_chart('G3', chart)

    class ExcelManager:
        def __init__(self, filename, sheet_name):
            self.workbook = xlsxwriter.Workbook(filename)
            self.worksheet = self.add_worksheet(sheet_name)

        def __del__(self):
            if self.workbook is not None:
                self.close_workbook()

        def close_workbook(self):
            if self.workbook is not None:
                self.workbook.close()
            self.workbook = None

        def add_worksheet(self, sheet_name):
            return self.workbook.add_worksheet(sheet_name)

        def write_cell(self, row, col, value):
            self.worksheet.write(row, col, value)
