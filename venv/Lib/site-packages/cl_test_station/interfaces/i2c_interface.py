"""Generic I2C Interface class"""
from typing import List, Union

from cl_test_station.interfaces.ctrl_interface import CtrlInterface, ByteOrder, CtrlInterfaceError
from cl_test_station.interfaces.ctrl_interface import map_word, build_word, build_words_from_bytes
from cl_test_station.test_station_object import TsoField


class I2cWriteError(CtrlInterfaceError):
    """Generic I2C Write error"""


class I2cReadError(CtrlInterfaceError):
    """Generic I2C Read error"""


class I2cNackError(CtrlInterfaceError):
    """Missing/incorrect I2C Acknowledgement error"""


class I2cInterface(CtrlInterface):
    """Generic I2C Interface class"""

    ainc_bit_pos: int = TsoField(ftype=int, required=False, desc="Bit position in address of the auto-increment bit.")
    ainc_active_level: int = TsoField(ftype=int, required=False, default=0, desc="Active state for AINC bit")
    ainc: bool = TsoField(ftype=bool, required=False, default=None,
                          desc="Flag that indicated if AINC is being used. Will be set to True if ainc_bit_pos is defined")

    ERROR_CODES = {
        -4: I2cWriteError,
        -5: I2cReadError,
        -6: I2cNackError
    }

    def __init__(self, *args, **kwargs):
        # ainc attributes
        super().__init__(*args, **kwargs)
        if self.ainc is None:
            if self.ainc_bit_pos is not None:  # Set ainc to True if bit_pos is set.
                self.ainc = True
            else:
                self.ainc = False
                self.ainc = False
        elif self.ainc is True and self.ainc_bit_pos is None:  # Ensure bit position is defined if ainc is set.
            self.log.debug(f'Component {self.container.ref_name} is using ainc without a bit_pos defined.')

    def scan(self, *args, host_controller=None, **kwargs) -> List[str]:
        """
        Scans the I2C bus and returns a list of any found devices (7-bit address)

        :param args: Additional positional arguments
        :type args: Any
        :param host_controller: Instance of controller to perform transaction with [Default: component.active_controller]
        :type host_controller: HostController | PyroReciever
        :param kwargs: Additional HostController specific keyword arguments
        :type kwargs: Any
        :return: list of hex addresses (7-bit) present on the I2C bus
        :rtype: list of strings
        """
        if host_controller is None:
            host_controller = self.component.active_controller

        # combine passed in keyword arguments with interface fields. Allows for a caller to override YAML definition
        new_kwargs = self.fields.copy()
        new_kwargs.update(kwargs)
        # TODO: Maybe fix issue where controller cannot be first positional argument
        device_list = host_controller.i2c_scan(*args, **new_kwargs)
        if device_list:
            self.log.info(f'Devices found: {", ".join(device_list)}')
            return device_list
        # else
        self.log.info('No devices found')
        return []

    def prepare_address(self, address: int, ainc: bool) -> int:
        """
        Adds AINC bit to address if nec.

        :param address: Raw address
        :type address: int
        :param ainc: Indicates whether to add the ainc bit or not.
        :type ainc: bool
        :return: Address with ainc bit
        :rtype: int
        """
        if self.ainc_bit_pos is not None:  # Add ainc bit
            return self.add_config_bit(address, self.ainc_bit_pos, self.ainc_active_level, ainc)
        return address

    def write_register(self, host_controller, reg_addr: int, write_data: int, ainc: bool = None, **kwargs):
        """
        Writes 'write_data' to register at address 'reg_addr'

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: HostController
        :param reg_addr: Address of the register
        :type reg_addr: int
        :param write_data: Data to write to the register
        :type write_data: int
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :return: None
        """
        if isinstance(write_data, list):
            self.log.error("Cannot input list into write_register, use block_write")
            raise ValueError("Cannot input list into write_register, use block_write")
        # Add ainc bit to address (doesnt affect address if ainc is not configured)
        if ainc is None:
            ainc = self.ainc
        reg_addr = self.prepare_address(reg_addr, ainc=ainc)
        # Need to convert write_data from list of words to list of bytes
        write_data = self.build_write_packet(write_data, self.write_reg_data_size, byte_order=self.data_byte_order)
        # Check that interface contains all arguments required for the write
        self.check_args(host_controller.write_i2c_reg, extra=['reg_addr', 'write_data'])
        # Issue write and return error code
        err_code = host_controller.write_i2c_reg(reg_addr=reg_addr, write_data=write_data, **self.fields, **kwargs)
        # Raise error if necessary
        self.raise_error(err_code)

    def read_register(self, host_controller, reg_addr: int, ainc: bool = None, **kwargs) -> int:
        """
        Reads value from register at address 'reg_addr'

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: HostController
        :param reg_addr: Address of the register
        :type reg_addr: int
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :return: Register value
        :rtype: int
        """
        # Add ainc bit to address (doesn't affect address if ainc is not configured)
        if ainc is None:
            ainc = self.ainc
        reg_addr = self.prepare_address(reg_addr, ainc=ainc)
        byte_count = self.read_reg_data_size
        # Check that interface contains all arguments required for the read
        self.check_args(host_controller.read_i2c_reg, extra=['reg_addr', 'byte_count'] + list(kwargs))
        # Issue read and get back list of bytes
        read_bytes = host_controller.read_i2c_reg(reg_addr=reg_addr, byte_count=byte_count, **self.fields, **kwargs)
        # Check for error
        self.raise_error(read_bytes)
        # Build word list from list of bytes and return word
        return build_word(read_bytes, self.read_reg_data_size, byte_order=self.data_byte_order)

    def block_read(self, host_controller, start_addr: int, word_count: int, ainc: bool = None, **kwargs) -> List[int]:
        """
        Reads a block of word_count words starting from address 'start_addr'.

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: HostController
        :param start_addr: Start address of the block read
        :type start_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :return: List of length word_count containing register values
        :rtype: List[int]
        """
        # Add ainc bit to address (doesnt affect address if ainc is not configured)
        if ainc is None:
            ainc = self.ainc
        start_addr = self.prepare_address(start_addr, ainc=ainc)
        # Perform read in 1 transaction using auto-increment
        if ainc:
            self.log.debug("Reading %d words from %s with auto-increment" %
                          (word_count, '0x'+hex(start_addr)[2:].zfill(self.read_reg_addr_size*2)))
            # Caculate byte count based on word_count and register data size
            byte_count = word_count * self.read_reg_data_size
            # Issue read and get back list of bytes
            self.check_args(host_controller.read_i2c_reg, extra=['reg_addr', 'byte_count'])
            read_bytes = host_controller.read_i2c_reg(reg_addr=start_addr, byte_count=byte_count, **self.fields)
            # Check for error
            self.raise_error(read_bytes)
            # Build list of words from the bytes read
            words_out = build_words_from_bytes(read_bytes, self.read_reg_data_size, byte_order=self.data_byte_order)
        # Issue series of individual transactions
        else:
            self.log.debug("AINC is inactive, issuing %d individual transactions" % word_count)
            # todo: Test that this works on other projects, knuckles doesnt bc its address is shifted by a byte
            # List of address are separated by the addressibility of the memory
            addr_list = [start_addr + (reg_num * self.address_stride) for reg_num in range(word_count)]
            # Populate list with read values for each address
            words_out = [self.read_register(host_controller, addr) for addr in addr_list]
            # Check for errors
            for err_code in words_out:
                self.raise_error(err_code)
        return words_out

    def block_write(self, host_controller, start_addr: int, write_data: List[int], ainc: bool = None, **kwargs):
        """
        Writes each word from write_data starting at start_addr (incrementing)

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: HostController
        :param start_addr: [int] start address of the block write
        :type start_addr: int
        :param write_data: [list<int>] List of words to write
        :type write_data: List[int]
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :return: None
        :rtype: None
        """
        # Add ainc bit to address (doesnt affect address if ainc is not configured)
        if ainc is None:
            ainc = self.ainc
        start_addr = self.prepare_address(start_addr, ainc=ainc)
        # Perform write in 1 transaction using auto-increment
        if ainc:
            self.log.debug("Writing %d words from %s with auto-increment" %
                          (len(write_data), '0x' + hex(start_addr)[2:].zfill(self.write_reg_addr_size * 2)))
            # Need to convert write_data from list of words to list of bytes
            write_data = self.build_write_packet(write_data, self.write_reg_data_size, byte_order=self.data_byte_order)
            # Issue write and return error code
            self.check_args(host_controller.write_i2c_reg, extra=['reg_addr', 'write_data'])
            err_codes = [host_controller.write_i2c_reg(reg_addr=start_addr, write_data=write_data, **self.fields)]
        # Issue series of individual transactions with manual address increment
        else:
            self.log.debug("AINC is inactive, issuing %d individual transactions" % len(write_data))
            # todo: Test that this works on other projects, knuckles doesnt bc its address is shifted by a byte
            # List of address are separated by the size of the register
            addr_list = [start_addr + (reg_num * self.address_stride) for reg_num in range(len(write_data))]
            err_codes = [self.write_register(host_controller, addr, data) for addr, data in zip(addr_list, write_data)]
        # Raise errors if necessary
        for err_code in err_codes:
            self.raise_error(err_code)

    def chain_read(self, host_controller, reg_addr: int, word_count: int, **kwargs) -> List[int]:
        """
        Reads words from single address 'reg_addr', without incrementing. Returns list of words read.

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :return: List of words
        :rtype: list
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, data may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        reg_addr = self.prepare_address(reg_addr, ainc=False)  # Turn off AINC
        # Caculate byte count based on word_count and register data size
        byte_count = word_count * self.read_reg_data_size
        # Issue read and get back list of bytes
        self.check_args(host_controller.read_i2c_reg, extra=['reg_addr', 'byte_count'])
        read_bytes = host_controller.read_i2c_reg(reg_addr=reg_addr, byte_count=byte_count, **self.fields)
        # Check for error
        self.raise_error(read_bytes)
        # Build list of words from the readback byte list
        return build_words_from_bytes(read_bytes, self.read_reg_data_size, byte_order=self.data_byte_order)

    def chain_write(self, host_controller, reg_addr:int, write_data:List[int], **kwargs):
        """
        Writes words sequentially to single address, without incrementing.

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: HostController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param write_data: List of words to write
        :type write_data: list
        :return: None
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, data may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        reg_addr = self.prepare_address(reg_addr, ainc=False)  # Turn off AINC
        # Need to convert write_data from list of words to list of bytes
        write_data = self.build_write_packet(write_data, self.write_reg_data_size, byte_order=self.data_byte_order)
        # Issue write and return error code
        self.check_args(host_controller.write_i2c_reg, extra=['reg_addr', 'write_data'])
        err_code = host_controller.write_i2c_reg(reg_addr=reg_addr, write_data=write_data, **self.fields)
        self.raise_error(err_code)

    # TODO: PLATDEV-1080 replace this with map_words_to_bytes
    @staticmethod
    def build_write_packet(word_list: Union[List[int], int], reg_data_size: int, byte_order: ByteOrder = ByteOrder.MSB_FIRST):
        """
        Builds a list of bytes from a list of words of length 'reg_data_size' using byte_order

        :param word_list: List of words
        :type word_list: List[int]
        :param reg_data_size: Register data size in bytes
        :type reg_data_size: int
        :param byte_order: Byte ordering to use. 0=LSB_FIRST, 1=MSB_FIRST [Default: ByteOrder.MSB_FIRST]
        :type byte_order: ByteOrder | int
        :return: List of bytes
        :rtype: List[int]
        """
        if isinstance(word_list, int):
            word_list = [word_list]
        byte_array = []
        for word in word_list:
            byte_array.extend(map_word(word, reg_data_size, byte_order))
        return byte_array
