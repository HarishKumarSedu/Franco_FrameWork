"""
Module for I3C interface
Author: Evan Canter <evan.canter@gmail.com>
"""
from typing import Callable, List, Optional, Tuple

from cl_test_station.host_controllers.mixins import I3cControllerMixin as I3cController
from cl_test_station.interfaces.ctrl_interface import (build_word, build_words_from_bytes, CtrlInterface,
                                                       ByteOrder, map_word, map_words_to_bytes)
from cl_test_station.test_station import TsoField


class I3cInterface(CtrlInterface):
    """Interface Class for I3C target devices."""

    # Auto-Increment fields
    ainc_bit_pos: int = TsoField(ftype=int, required=False, desc="Bit position in address of the auto-increment bit.")
    ainc_active_level: int = TsoField(ftype=int, required=False, default=0, desc="Active state for AINC bit")
    ainc: bool = TsoField(ftype=bool, required=False, desc="Flag that indicated if AINC is being used. "
                                                           "Will be set to True if ainc_bit_pos is defined")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Set ainc value based on input fields
        if self.ainc is None:
            # Use ainc if bit position is defined
            self.ainc = self.ainc_bit_pos is not None
        # Log message if ainc was set to True without an address bit position. ainc will be assumed enabled by default.
        elif self.ainc and self.ainc_bit_pos is None:
            self.log.debug(f'Component {self.container.ref_name} is using ainc without a bit_pos defined.')

    def get_kwargs(self, kwargs):
        """
        Combines kwargs and self.fields, where any key conflicts will use kwarg value over self.fields value

        :param kwargs: Extra key word arguments
        :type kwargs: dict
        :return: Combined kwargs dictionary
        :rtype: dict
        """
        combined_kwargs = self.fields.copy()
        combined_kwargs.update(kwargs)
        return combined_kwargs

    def add_ainc_bit(self, address: int, ainc: bool) -> int:
        """
        Adds AINC bit to address if nec.

        :param address: Raw address
        :type address: int
        :param ainc: Indicates whether to add the ainc bit or not.
        :type ainc: bool
        :return: Address with ainc bit
        :rtype: int
        """
        if self.ainc_bit_pos is not None:  # Add ainc bit
            address = self.add_config_bit(address, self.ainc_bit_pos, self.ainc_active_level, ainc)
        return address

    def _get_controller_func(self, host_controller: I3cController, legacy_i2c: bool = False, rnw: bool = True, 
                             reg_access: bool = False) -> Callable:
        # Build function name
        legacy = '_legacy_i2c' if legacy_i2c else ''
        access = 'read' if rnw else 'write'
        level = 'reg' if reg_access else 'device'
        func_name = f"i3c{legacy}_{access}_{level}"
        # Check availability
        if not hasattr(host_controller, func_name):
            raise AttributeError(f"Host controller {host_controller.ref_name} does not support "
                                 f"{'Legacy I2C' if legacy_i2c else 'I3C'} {level} {access}s "
                                 f"(no function 'i3c_legacy_i2c_read_reg')")
        # Return function reference
        return getattr(host_controller, func_name)
    
    def read_device(self, host_controller: I3cController, num_words: int, preamble_bytes: List[int] = None,
                    legacy_i2c: bool = False, **kwargs) -> List[int]:
        """
        Reads num_words from I3C device.

        :param host_controller: I3C capable host controller to use
        :type host_controller: I3cController
        :param num_words: Number of words to read
        :type num_words: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: List of words read
        :rtype: List[int]
        """
        if preamble_bytes is None:
            preamble_bytes = []
        read_func = self._get_controller_func(host_controller, legacy_i2c, rnw=True, reg_access=False)
        # Check field arguments
        extra_args = ['num_bytes', 'preamble_bytes'] + list(kwargs)
        self.check_args(iface_func=read_func, extra=extra_args)
        # Perform read and get back raw bytes
        bytes_in = read_func(num_bytes=num_words * self.read_reg_data_size,
                             preamble_bytes=preamble_bytes, **self.get_kwargs(kwargs))
        # Convert bytes to words
        return build_words_from_bytes(bytes_in, self.read_reg_data_size, self.data_byte_order)

    def write_device(self, host_controller: I3cController, write_data: List[int], preamble_bytes: List[int] = None,
                     legacy_i2c: bool = False, **kwargs):
        """
        Writes 'write_data' to I3C device.

        :param host_controller: I3C capable host controller to use
        :type host_controller: I3cController
        :param write_data: List of words to write
        :type write_data: List[int]
        :param preamble_bytes: List of bytes to write to the device before write_data
        :type preamble_bytes: List[int]
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: None
        :rtype: None
        """
        if preamble_bytes is None:
            preamble_bytes = []
        write_func = self._get_controller_func(host_controller, legacy_i2c, rnw=False, reg_access=False)
        # Check field arguments
        extra_args = ['write_data', 'preamble_bytes'] + list(kwargs)
        self.check_args(iface_func=write_func, extra=extra_args)
        # Convert list of words to bytes
        bytes_out = map_words_to_bytes(write_data, self.write_reg_data_size, self.data_byte_order)
        # Perform write
        return write_func(write_data=bytes_out, preamble_bytes=preamble_bytes, **self.get_kwargs(kwargs))

    def _process_ainc(self, reg_addr: int, ainc: bool) -> Tuple[int, bool]:
        """
        Adds AINC bit to register address and pulls ainc enable from self if None is given.

        :param reg_addr: Register address
        :type reg_addr: int
        :param ainc: ainc input value
        :type ainc: bool
        :return: Tuple contatining modified register address and ainc value
        :rtype: Tuple[int, bool]
        """
        if ainc is None:
            ainc = self.ainc
        # Add auto increment bit if defined
        reg_addr = self.add_ainc_bit(reg_addr, ainc)
        return reg_addr, ainc

    def read_register(self, host_controller: I3cController, reg_addr: int, preamble_bytes: List[int] = None,
                      ainc: bool = None, legacy_i2c: bool = False, **kwargs) -> int:
        """
        Reads value from register at address 'reg_addr'

        :param host_controller: I3C capable host controller to use
        :type host_controller: I3cController
        :param reg_addr: Register address
        :type reg_addr: int
        :param preamble_bytes: List of bytes to write to the device before issuing read
        :type preamble_bytes: List[int]
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: Register value
        :rtype: int
        """
        if preamble_bytes is None:
            preamble_bytes = []
        reg_addr, ainc = self._process_ainc(reg_addr, ainc)
        read_func = self._get_controller_func(host_controller, legacy_i2c, rnw=True, reg_access=True)
        # Check field arguments
        extra_args = ['reg_addr', 'num_bytes', 'preamble_bytes'] + list(kwargs)
        self.check_args(iface_func=read_func, extra=extra_args)
        # Perform read and build words
        bytes_in = read_func(num_bytes=self.read_reg_data_size, reg_addr=reg_addr,
                             preamble_bytes=preamble_bytes, **self.get_kwargs(kwargs))
        return build_word(bytes_in, self.read_reg_data_size, self.data_byte_order)

    def write_register(self, host_controller: I3cController, reg_addr: int, write_data: int,
                       preamble_bytes: List[int] = None, ainc: bool = None, legacy_i2c: bool = False, **kwargs):
        """
        Writes 'write_data' to register at address 'reg_addr'

        :param host_controller: I3C capable host controller to use
        :type host_controller: I3cController
        :param reg_addr: Register address
        :type reg_addr: int
        :param write_data: New register value
        :type write_data: int
        :param preamble_bytes: List of bytes to write to the device before write_data
        :type preamble_bytes: List[int]
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: None
        :rtype: None
        """
        if preamble_bytes is None:
            preamble_bytes = []
        reg_addr, ainc = self._process_ainc(reg_addr, ainc)
        write_func = self._get_controller_func(host_controller, legacy_i2c, rnw=False, reg_access=True)
        # Check field arguments
        extra_args = ['reg_addr', 'write_data', 'preamble_bytes'] + list(kwargs)
        self.check_args(iface_func=write_func, extra=extra_args)
        # Convert word to list of bytes
        bytes_out = map_word(write_data, self.write_reg_data_size, self.data_byte_order)
        # Perform write
        return write_func(reg_addr=reg_addr, write_data=bytes_out, preamble_bytes=preamble_bytes, **self.get_kwargs(kwargs))

    def block_read(self, host_controller: I3cController, start_addr: int, word_count: int,
                   preamble_bytes: List[int] = None, ainc: bool = None, legacy_i2c: bool = False, **kwargs) -> List[int]:
        """
        Reads sequential registers from a start address. If Auto-increment is not enabled, individual transactions will be
        issued for each word.

        :param host_controller: Host controller to use
        :type host_controller: I3cController
        :param start_addr: Address of the first word
        :type start_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :param preamble_bytes: List of bytes to write to the device before issuing read
        :type preamble_bytes: List[int]
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: List of words read
        :rtype: List[int]
        """
        if preamble_bytes is None:
            preamble_bytes = []
        reg_addr, ainc = self._process_ainc(start_addr, ainc)
        # Perform read in 1 transaction using auto-increment
        if ainc:
            self.log.debug(f"Reading {word_count} words from 0x{start_addr:0{self.read_reg_addr_size<<1}X} with auto-increment")
            read_func = self._get_controller_func(host_controller, legacy_i2c, rnw=True, reg_access=True)
            # Caculate byte count based on word_count and register data size
            num_bytes = word_count * self.read_reg_data_size
            # Issue read and get back list of bytes
            extra_args = ['reg_addr', 'num_bytes', 'preamble_bytes'] + list(kwargs)
            self.check_args(read_func, extra=extra_args)
            bytes_in = read_func(reg_addr=start_addr, num_bytes=num_bytes, preamble_bytes=preamble_bytes, **self.get_kwargs(kwargs))
            # Build list of words from the bytes read
            words_out = build_words_from_bytes(bytes_in, self.read_reg_data_size, byte_order=self.data_byte_order)
        # Issue series of individual transactions
        else:
            self.log.debug(f"AINC is inactive, issuing {word_count} individual transactions")
            # List of address are separated by the addressibility of the memory
            words_out = []
            for reg_num in range(word_count):
                addr = start_addr + reg_num * self.address_stride
                words_out.append(self.read_register(host_controller, reg_addr=addr, preamble_bytes=preamble_bytes, 
                                                    ainc=ainc, legacy_i2c=legacy_i2c))
        return words_out

    def block_write(self, host_controller: I3cController, start_addr: int, write_data: List[int],
                    preamble_bytes: List[int] = None, ainc: bool = None, legacy_i2c: bool = False, **kwargs):
        """
        Writes words to sequential registers. If Auto-increment is not enabled, individual transactions will be issued
        for each word.

        :param host_controller: Host controller to use
        :type host_controller: I3cController
        :param start_addr: Address that the first word will be written to
        :type start_addr: int
        :param write_data: List of words to write
        :type write_data: List[int]
        :param preamble_bytes: List of bytes to write to the device before write_data
        :type preamble_bytes: List[int]
        :param ainc: Override for auto-increment. If none is given, the interface's 'ainc' attribute will be used
        :type ainc: bool
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: None
        :rtype: None
        """
        if preamble_bytes is None:
            preamble_bytes = []
        reg_addr, ainc = self._process_ainc(start_addr, ainc)
        # Perform write in 1 transaction using auto-increment
        if ainc:
            self.log.debug(f"Writing {len(write_data)} words from 0x{start_addr:0{self.write_reg_addr_size<<1}X} with auto-increment")
            write_func = self._get_controller_func(host_controller, legacy_i2c, rnw=False, reg_access=True)
            # Need to convert write_data from list of words to list of bytes
            bytes_out = self.build_write_packet(write_data, self.write_reg_data_size, byte_order=self.data_byte_order)
            # Check arguments
            extra_args = ['reg_addr', 'write_data', 'preamble_bytes'] + list(kwargs)
            self.check_args(write_func, extra=extra_args)
            # Perform write
            write_func(reg_addr=start_addr, write_data=write_data, preamble_bytes=preamble_bytes, ainc=ainc, **self.get_kwargs(kwargs))
        # Issue series of individual transactions with manual address increment
        else:
            self.log.debug(f"AINC is inactive, issuing {len(write_data)} individual transactions")
            for reg_num, word in enumerate(write_data):
                addr = start_addr + reg_num * self.address_stride
                self.write_register(host_controller, reg_addr=addr, write_data=word, preamble_bytes=preamble_bytes,
                                    ainc=ainc, legacy_i2c=legacy_i2c)

    def chain_read(self, host_controller: I3cController, reg_addr: int, word_count: int,
                   preamble_bytes: List[int] = None, legacy_i2c: bool = False, **kwargs) -> List[int]:
        """
        Reads words from single address 'reg_addr', without incrementing. Returns list of words read.

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: I3cController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :param preamble_bytes: List of bytes to write to the device before write_data
        :type preamble_bytes: List[int]
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: List of words read
        :rtype: List[int]
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, data may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        if preamble_bytes is None:
            preamble_bytes = []
        reg_addr, ainc = self._process_ainc(reg_addr, False)
        read_func = self._get_controller_func(host_controller, legacy_i2c, rnw=True, reg_access=True)
        # Caculate byte count based on word_count and register data size
        num_bytes = word_count * self.read_reg_data_size
        # Check field arguments
        extra_args = ['reg_addr', 'num_bytes', 'preamble_bytes'] + list(kwargs)
        self.check_args(iface_func=read_func, extra=extra_args)
        # Issue read and get back list of bytes
        bytes_in = read_func(reg_addr=start_addr, num_bytes=num_bytes, preamble_bytes=preamble_bytes, **self.get_kwargs(kwargs))
        return build_words_from_bytes(bytes_in, self.read_reg_data_size, byte_order=self.data_byte_order)

    def chain_write(self, host_controller: I3cController, reg_addr: int, write_data: List[int],
                    preamble_bytes: List[int] = None, legacy_i2c: bool = False, **kwargs):
        """
        Writes words to single address 'reg_addr', without incrementing.

        :param host_controller: Instance of controller to perform transaction with
        :type host_controller: I3cController
        :param reg_addr: Register/Buffer address to read from
        :type reg_addr: int
        :param write_data: Words to write
        :type write_data: List[int]
        :param preamble_bytes: List of bytes to write to the device before write_data
        :type preamble_bytes: List[int]
        :param legacy_i2c: Perform transaction using I2C over I3C bus lines.
        :type legacy_i2c: bool
        :return: None
        :rtype: None
        """
        if self.ainc_bit_pos is None:
            self.log.warning("AINC bit is not configured, writes may not be valid. Add ainc_bit_pos and ainc_active_level to config")
        if preamble_bytes is None:
            preamble_bytes = []
        reg_addr, ainc = self._process_ainc(reg_addr, False)
        write_func = self._get_controller_func(host_controller, legacy_i2c, rnw=False, reg_access=True)
        # Check field arguments
        extra_args = ['reg_addr', 'write_data', 'preamble_bytes'] + list(kwargs)
        self.check_args(iface_func=write_func, extra=extra_args)
        # Need to convert write_data from list of words to list of bytes
        bytes_out = self.build_write_packet(write_data, self.write_reg_data_size, byte_order=self.data_byte_order)
        # Perform write
        return write_func(reg_addr=reg_addr, write_data=bytes_out, preamble_bytes=preamble_bytes, **self.get_kwargs(kwargs))
