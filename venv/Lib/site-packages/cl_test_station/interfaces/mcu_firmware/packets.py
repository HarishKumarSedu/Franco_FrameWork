"""
Packet class definitions for SQA firmware application.
Author: Evan Canter <evan.canter@cirrus.com>
"""
from typing import Callable, List, NamedTuple, TYPE_CHECKING
from dataclasses import dataclass, replace, field

from cl_test_station.interfaces.ctrl_interface import build_word, build_words_from_bytes, ByteOrder
from cl_test_station.interfaces.mcu_firmware.enums import *
from cl_test_station.utilities.packets.packets import packetclass, packet_frame, PacketSteps, PacketBase, PacketFrame

if TYPE_CHECKING:
    packetclass = dataclass

# ---------------------------------------------------------------------------
# Packet header definition. All fields are required besides register address,
# which is only present when performing mode 00 and mode 11 transactions.
# ---------------------------------------------------------------------------

@packetclass
class SqaPacketHeader(PacketBase):
    packet_index:       int               = packet_frame(PacketSteps.BYTE, 2, ByteOrder.LSB_FIRST)
    wait_for_tick:      int               = packet_frame(PacketSteps.BIT,  1)
    i2c_address:        int               = packet_frame(PacketSteps.BIT,  5)
    i2c_mode:           I2cModes          = packet_frame(PacketSteps.BIT,  2)
    operation_mode:     SqaOperationModes = packet_frame(PacketSteps.BIT,  2)
    operation:          SqaOperations     = packet_frame(PacketSteps.BIT,  6)
    payload_size:       int               = packet_frame(PacketSteps.BYTE, 2, ByteOrder.LSB_FIRST)  # For writes, these will be the same
    target_rw_size:     int               = packet_frame(PacketSteps.BYTE, 2, ByteOrder.LSB_FIRST)
    register_address:   list              = packet_frame(PacketSteps.BYTE, 'i2c_mode.header_addr_size', ByteOrder.LSB_FIRST, default_factory=lambda: [])


# ------------------------------------------
# Definitions for Stimulus/Response payloads
# ------------------------------------------

class PayloadBase(PacketBase):

    @property
    def raw_bytes(self) -> List[int]:
        return self.serialize()


# OPCODE 1 - I2C Read
@packetclass
class ReadResponsePayload(PayloadBase):
    read_bytes: list = packet_frame(PacketSteps.BYTE, 'size', default_factory=lambda : [])
    size: int = 1  # For deserialization

    def __post_init__(self):
        super().__post_init__()
        self._frames[0].width = len(self.read_bytes)
        self.size = len(self.read_bytes)


# OPCODE 2 - I2C write
@packetclass
class WriteStimulusPayload(PayloadBase):
    write_bytes: list = packet_frame(PacketSteps.BYTE, 1, default_factory=lambda : [])

    def __post_init__(self):
        super().__post_init__()
        self._frames[0].width = len(self.write_bytes)


# OPCODE 3 - Polling function
@packetclass
class PollStimulusPayload(PayloadBase):
    mask:     int = packet_frame(PacketSteps.BYTE, 4)
    expected: int = packet_frame(PacketSteps.BYTE, 4)


@packetclass
class PollResponsePayload(PayloadBase):
    read_value:      int = packet_frame(PacketSteps.BYTE, 'reg_size')  # Last read value
    _ignored:        int = packet_frame(PacketSteps.BYTE, 'remainder', repr=False)  # Last read value
    poll_count:      int = packet_frame(PacketSteps.BYTE, 4)  # Number of iterations
    poll_time_usec:  int = packet_frame(PacketSteps.BYTE, 4)  # Time elapsed in usec
    reg_size: int = field(default=4, repr=False)
    remainder: int = field(default=0, repr=False)

# OPCODE - Write random I2C data via mode 11
@packetclass
class RandomWriteStimulusPayload(PayloadBase):
    seed: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Random seed


# OPCODE 5 - Time delay
@packetclass
class DelayStimulusPayload(PayloadBase):
    delay_time_usec: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Delay time in microseconds


# OPCODE 7 - Read timer
@packetclass
class ReadTimerResponsePayload(PayloadBase):
    elapsed_time_usec: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.MSB_FIRST)  # Time elapsed between start and read timer (microseconds)


# OPCODEs 8-11 - Set output, clear output, wait if input is set, wait if inpus is clear
@packetclass
class InoutStimulusPayload(PayloadBase):
    value: int = packet_frame(PacketSteps.BYTE, 1, ByteOrder.LSB_FIRST)  # for Set Output, Clear Output, and Wait Input operations


# OPCODE 12 - Set I2C speed and tick period
@packetclass
class SetSpeedTickStimulusPayload(PayloadBase):
    speed_khz:        int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # I2C bus speed in in kHz
    tick_period_usec: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Tick period in microseconds


# OPCODE 14 - Set PWM output
@packetclass
class SetPwmStimulusPayload(PayloadBase):
    output_pin:        int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Output pin number
    polarity:          int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Polarity
    pwm_period:        int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # PWM period
    pwm_duty_cycle:    int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # PWM duty cycle
    pull_up_push_pull: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Open drain/push-pull or open drain/pull-up


# OPCODE 15 - Clear PWM output
@packetclass
class ClearPwmStimulusPayload(PayloadBase):
    output_pin: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Output pin number


# OPCODE 16 - Write bit field
@packetclass
class WriteBitFieldStimulusPayload(PayloadBase):
    mask:  int = packet_frame(PacketSteps.BYTE, 4)  # Field mask
    value: int = packet_frame(PacketSteps.BYTE, 4)  # Desired field value


@packetclass
class WriteBitFieldResponsePayload(PayloadBase):
    new_value:      int = packet_frame(PacketSteps.BYTE, 4)  # Updated field value
    previous_value: int = packet_frame(PacketSteps.BYTE, 4)  # Previous field value


# OPCODE 17 - Skip Nack
@packetclass
class SkipNackStimulusPayload(PayloadBase):
    enable: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # 0 = Disable, 1 = Enable


# OPCODE 18 - Read Nack
@packetclass
class ReadNackStimulusPayload(PayloadBase):
    read_bytes: list = packet_frame(PacketSteps.BYTE, 1, ByteOrder.LSB_FIRST, default_factory=lambda : [])

    def __post_init__(self):
        super().__post_init__()
        self._frames[0].width = len(self.read_bytes)


@packetclass
class ReadNackResponsePayload(PayloadBase):
    last_result: int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # 0 = ACK, 1 = NACK
    nack_count:  int = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)  # Counter for Nacks detected


@packetclass
class SelectPortModeStimulusPayload(PayloadBase):
    port_mode: SqaPortModes = packet_frame(PacketSteps.BYTE, 4, ByteOrder.LSB_FIRST)


OPERATION_PAYLOAD_MAP = {
    SqaOperations.I2C_READ: ReadResponsePayload,
    SqaOperations.I2C_POLL: PollResponsePayload,
    SqaOperations.READ_TIMER: ReadTimerResponsePayload,
    SqaOperations.WRITE_FIELD: WriteBitFieldResponsePayload,
    SqaOperations.READ_NAK: ReadNackResponsePayload

}

# -------------------------------------
# Dataclass defintions for type hints
# -------------------------------------

# Generic Types
@dataclass
class McuStimulus:
    header:  SqaPacketHeader
    payload: PayloadBase = None


@dataclass
class McuResponse:
    header:     SqaPacketHeader
    payload:    PayloadBase = None
    time_stamp: int = None

    def __repr__(self):
        if self.header is None:
            return f"{self.__class__.__name__}(pending execution)"
        else:
            return f"{self.__class__.__name__}(header={self.header.operation.name}, payload={self.payload}, time_stamp={self.time_stamp})"

    @property
    def time_stamp_usec(self) -> float:
        """
        Calculates time stamp in microseconds. Based off of the MCUs 250MHz clock.

        :return: Time stamp in usec
        :rtype: float
        """
        if self.time_stamp is not None:
            return self.time_stamp / 250  # x clks * 1usec/250 clks
        return None


# These dunders will get dynamically added to McuI2cReadResponse
_OPERATORS = ['add', 'sub', 'mul', 'truediv', 'floordiv', 'mod', 'pow', 'lshift,', 'rshift', 'and', 'xor', 'or']


# Read responses need to remember what operations were done to them for post-execution parsing
@dataclass(repr=False)
class McuI2cReadResponse(McuResponse):
    payload: ReadResponsePayload = None
    convert_to_int: bool = False
    convert_to_list: bool = False
    byte_order: ByteOrder = ByteOrder.LSB_FIRST
    word_size: int = 4
    byte_count: int = 4
    ref: 'McuI2cReadResponse' = None

    def __post_init__(self):
        """
        Adds operator functions that create a new copy of this data class, appending the operation to a queue.

        :return: None
        :rtype: None
        """
        self.operations = []
        for op in _OPERATORS:
            for prefix in ['', 'r', 'i']:
                op_func = f"__{prefix}{op}__"
                # func = lambda *a, _self=self, _func=op_func, **kw: _self.queue_op(*a, _func=_func, **kw)
                func = lambda self, *a, _func=op_func, **kw: self.queue_op(*a, _func=_func, **kw)
                setattr(self, op_func, func)
                setattr(self.__class__, op_func, func)

        # Each copy of this class will refer to the same response object that will hold read bytes
        self.response = self.ref if self.ref else self

    def __getattribute__(self, item):
        if item in ['header', 'payload', 'time_stamp'] and hasattr(self, 'response'):
            return object.__getattribute__(self.response, item)
        return object.__getattribute__(self, item)

    def __setattr__(self, key, value):
        if hasattr(self, 'response') and key in ['header', 'payload', 'time_stamp']:
            return object.__setattr__(self.response, key, value)
        return object.__setattr__(self, key, value)

    def __len__(self):
        return self.byte_count

    def queue_op(self,  *args, _func='', **kwargs):
        new = McuI2cReadResponse(None, None, None, self.convert_to_int, self.convert_to_list, self.byte_order, self.word_size,
                                 self.byte_count, ref=self.response)
        new.operations = self.operations.copy()
        new.operations.append((_func, args, kwargs))
        return new

    @property
    def value(self) -> int:
        if self.convert_to_int:
            value = build_word(self.payload.read_bytes, self.word_size, self.byte_order)
            for int_func, args, kwargs in self.operations:
                value = getattr(int, int_func)(value, *args, **kwargs)
        else:
            value = build_words_from_bytes(self.payload.read_bytes, self.word_size, self.byte_order)
        return value


@dataclass
class McuPollResponse(McuResponse):
    payload: PollResponsePayload = None


@dataclass
class McuReadTimerResponse(McuResponse):
    payload: ReadTimerResponsePayload = None


@dataclass
class McuWriteBitFieldResponse(McuResponse):
    payload: WriteBitFieldResponsePayload = None


@dataclass
class McuReadNackResponse(McuResponse):
    payload: ReadNackResponsePayload = None


# Mapping from header operation to response type
OPERATION_RESPONSE_MAP = {
    SqaOperations.I2C_READ: McuI2cReadResponse,
    SqaOperations.I2C_POLL: McuPollResponse,
    SqaOperations.READ_TIMER: McuReadTimerResponse,
    SqaOperations.WRITE_FIELD: McuWriteBitFieldResponse,
    SqaOperations.READ_NAK: McuReadNackResponse
}
