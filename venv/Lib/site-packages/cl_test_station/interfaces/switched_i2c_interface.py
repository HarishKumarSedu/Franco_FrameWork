
from functools import wraps
from typing import List
from cl_test_station.interfaces.i2c_interface import I2cInterface
from cl_test_station.components.i2c_switch.i2c_switch import I2cSwitch
from cl_test_station.test_station_object import TsoField


def switch_i2c_mux(f):
    """Indirect transaction decorator.

    Wrap transaction method in calls to enable and disable the component's
    i2c_switch channel.

    :param f: I2C transaction method to wrap.
    :returns: results of the transaction.
    """
    @wraps(f)
    def wrapper(iface, *args, **kwargs):
        iface.i2c_switch.mux_channel(iface.switch_channel)
        result = f(iface, *args, **kwargs)
        return result
    return wrapper


class SwitchedI2cInterface(I2cInterface):
    """I2C Interface class with ability to switch an I2C mux"""

    i2c_switch: str = TsoField(ftype=str, required=True, desc='Reference to I2C switch component')
    switch_channel: int = TsoField(ftype=int, required=True, desc='Channel number on corresponding I2C switch')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def post_system_initialize(self, **kwargs):
        """The i2c switch component reference will be created at post system initialize and removed from fields."""
        super().post_construct_system(**kwargs)
        if isinstance(self.i2c_switch, str):
            self._i2c_switch_str = self.i2c_switch
            self.i2c_switch = self.resolve_path(self._i2c_switch_str)
            if self.i2c_switch == None:  # If Field object cannot be found, resolve_path() returns None, not an error.
                raise AttributeError(f'{self._i2c_switch_str} i2c_switch object for {self.ref_name} interface on '
                                     f'{self.container.ref_name} cannot be found.')

            # remove i2c_switch from fields as it will not serialize to be transferred via Pyro
            self.log.info('Removing i2c_switch from fields')
            self.fields.pop('i2c_switch')

    @switch_i2c_mux
    def write_register(self, host_controller, reg_addr, write_data, **kwargs):
        super().write_register(host_controller, reg_addr, write_data, **kwargs)

    @switch_i2c_mux
    def read_register(self, host_controller, reg_addr, **kwargs):
        return super().read_register(host_controller, reg_addr, **kwargs)

    @switch_i2c_mux
    def block_read(self, host_controller, start_addr, word_count):
        return super().block_read(host_controller, start_addr, word_count)

    @switch_i2c_mux
    def block_write(self, host_controller, start_addr, write_data):
        super().block_write(host_controller, start_addr, write_data)

    @switch_i2c_mux
    def chain_read(self, host_controller, reg_addr: int, word_count: int) -> List[int]:
        return super().chain_read(host_controller, reg_addr, word_count)

    @switch_i2c_mux
    def chain_write(self, host_controller, reg_addr: int, write_data: List[int]):
        super().chain_write(host_controller, reg_addr, write_data)
