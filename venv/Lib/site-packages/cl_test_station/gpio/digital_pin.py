from typing import Optional, Union

from cl_test_station.gpio.enums import *
from cl_test_station.gpio.pin import (
    Pin,
    input_only_dir,
    input_only_kind,
    output_only_dir,
    output_only_kind,
)
from cl_test_station.multisource.multisourceabc import MultiSourceABC
from cl_test_station.multisource.tso_group import TSOGroupableMixin
from cl_test_station.test_station_object import TsoField


class DigitalPin(Pin, MultiSourceABC, TSOGroupableMixin):
    """Digital Pin abstraction."""

    default_direction: Optional[PinDirection] = TsoField(
        ftype=PinDirection,
        required=False,
        default=None,
        desc="Default direction of the DigitalPin",
    )
    default_output: Optional[int] = TsoField(
        ftype=int,
        required=False,
        default=None,
        desc="Default value to output if default_direction=OUTPUT",
    )

    def resolve_source(self, path: str) -> Optional[Pin]:
        """Resolves and returns the given source using
        TestStationObject.resolve_path. Maybe overridden by children to add
        additional checks.

        :param path: Path to the source object defined in the project configuration YAML
        :type path: str
        :return: The source object, or None if N/A or not present
        :rtype: Optional[Pin]
        """
        obj = super().resolve_source(path)
        # verify object is a Pin or None for not present
        if isinstance(obj, (Pin, type(None))):
            return obj
        # else return None and issue warning for invalid types
        self.log.warning(
            f"{path} is an invalid source for DigitalPin {self.path}. Required to be Pin, not {type(obj)}"
        )
        return None

    def post_system_initialize(self, **kwargs):
        """Sets the default direction and output, if they are defined. The default_output is only used if
        default_direction is OUTPUT.

        :param kwargs: Pass through keyword arguments
        :type kwargs: Any
        :return: None
        :rtype: None
        """
        super().post_system_initialize(**kwargs)

        if self.active_source:
            if self.default_direction:
                self.active_source.direction = self.default_direction

            if self.direction is PinDirection.OUTPUT and self.default_output:
                self.active_source.output = self.default_output
        else:
            if self.default_direction is not None:
                self.log.warning(
                    f"{self.path} could not set default_direction({self.default_direction}) because there is not an "
                    "active source for the DigitalPin."
                )
            if self.default_output is not None:
                self.log.warning(
                    f"{self.path} could not set default_output({self.default_output}) because there is not an active "
                    f"source for the DigitalPin."
                )

    @property
    def active_source(self) -> Optional[Pin]:
        """Returns the currently active Pin object.

        :return: Active Pin object
        :rtype: Optional[Pin]
        """
        return MultiSourceABC.active_source.fget(self)  # noqa

    @active_source.setter
    def active_source(self, selection: str):
        """Changes the active source to the given source name. If defined, it also calls the connect function.

        :param selection: Name of the available source to be made active
        :type selection: str
        :return: None
        :rtype: None
        """
        MultiSourceABC.active_source.fset(self, selection)  # noqa

    @property
    def kind(self) -> PinKind:
        """Returns the kind of pin. Can be INPUT_ONLY, OUTPUT_ONLY, or INOUT.

        :return: Pin kind
        :rtype: PinKind
        """
        return self.active_source.kind

    @property
    def direction(self) -> PinDirection:
        """Returns the pin's direction.

        **If current pin configuration is an output:** PinDirection.OUTPUT

        **If current pin configuration is an input:** PinDirection.INPUT

        :return: Pin direction
        :rtype: PinDirection
        """
        return self.active_source.direction

    @direction.setter
    def direction(self, value: Union[PinDirection, int]):
        """Sets the desired direction. 0 -> OUTPUT, 1 -> INPUT.

        :param value: Desired pin direction
        :type value: PinDirection | int
        :return: None
        :rtype: None
        """
        self.active_source.direction = value

    @property
    def polarity(self) -> PinPolarity:
        """Returns the pin's polarity.

        **PinPolarity.NORMAL indicates:** a value of 1 -> HIGH, 0 -> LOW.

        **PinPolarity.INVERTED indicates:** 1 -> LOW, 0 -> HIGH

        :return: Pin's polarity configuration
        :rtype: PinPolarity
        """
        return self.active_source.polarity

    @property
    def value(self) -> int:
        raise NotImplementedError(
            "Pin.value is deprecated, used input/output functions"
        )

    @property
    @output_only_dir
    @output_only_kind
    def output(self) -> int:
        """Returns the current output value.

        :return: Pin level
        :rtype: int
        """
        return self.active_source.output

    @output.setter
    @output_only_dir
    @output_only_kind
    def output(self, value: int):
        """Sets the output value of the pin.

        :param value:
        :type value: int
        :return: None
        :rtype: None
        """
        self.active_source.output = value

    @property
    @input_only_dir
    @input_only_kind
    def input(self) -> int:
        """Reads the input value of the pin.

        :return: Input value
        :rtype: int
        """
        return self.active_source.input
