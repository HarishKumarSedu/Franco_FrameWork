from abc import ABCMeta, abstractmethod
from collections.abc import Iterable
from functools import partial, wraps
from typing import Callable, Optional

from cl_test_station.gpio.enums import *


class RestrictionError(RuntimeError):
    """Raised by add_restriction decorator when function access is denied."""


def add_restriction(fn: Optional[Callable] = None, *, prop_name: str, value):
    """Decorator that can be used to restrict functions to only be called when
    prop_name value is in value, else RestrictionError is raised.

    Example usage:

    .. code-block:: python

       @property
       @add_restriction(prop_name="direction", value=PinDirection.OUTPUT)
       def foo_w_restriction(self) -> int:
           return 123

    :param fn: function to decorate. This is used in the case that you want to use a partial like @input_only.
    :param prop_name: Name of property to check
    :param value: Value(or Tuple of possble values) prop_name must be to allow function call
    """

    def _decorate(function):
        @wraps(function)
        def wrapped_function(*args, **kwargs):
            nonlocal value

            if not isinstance(value, Iterable):
                value = (value,)

            if not hasattr(type(args[0]), prop_name):
                raise AttributeError(
                    f"{type(args[0])} has no attribute `{prop_name}` - check that a `{prop_name}` "
                    "property exists"
                )

            prop = getattr(type(args[0]), prop_name)

            if not isinstance(prop, property):
                raise TypeError(
                    f"{type(args[0])} attribute `{prop_name}` is not a property, it is `{type(prop)}`."
                    " add_restriction requires that prop_name refers to a class property."
                )

            if prop.fget(args[0]) in value:
                return function(*args, **kwargs)
            else:
                raise RestrictionError(
                    f"Function {function} is restricted based on instance current configuration.\n"
                    f"{args[0]} `{prop_name}` property must be in {value}, but got `{prop.fget(args[0])}`"
                )

        return wrapped_function

    if fn:
        return _decorate(fn)

    return _decorate


#: Decorator to add requirement that kind must be in (PinKind.INOUT, PinKind.INPUT_ONLY)
input_only_kind = partial(
    add_restriction, prop_name="kind", value=(PinKind.INOUT, PinKind.INPUT_ONLY)
)

#: Decorator to add requirement that kind must be in (PinKind.INOUT, PinKind.OUTPUT_ONLY)
output_only_kind = partial(
    add_restriction, prop_name="kind", value=(PinKind.INOUT, PinKind.OUTPUT_ONLY)
)

#: Decorator to add requirement that direction must be PinDirection.INPUT
input_only_dir = partial(
    add_restriction, prop_name="direction", value=PinDirection.INPUT
)

#: Decorator to add requirement that direction must be PinDirection.OUTPUT
output_only_dir = partial(
    add_restriction, prop_name="direction", value=PinDirection.OUTPUT
)


class Pin(metaclass=ABCMeta):
    """**Abstract baseclass that outlines standard functions/properties for a GPIO pin. Getters are required, setters are
    optional depending on the pin's functionality**"""

    @property
    @abstractmethod
    def kind(self) -> PinKind:
        """Returns the kind of pin. Can be INPUT_ONLY, OUTPUT_ONLY, or INOUT.

        :return: Pin kind
        :rtype: PinKind
        """

    @property
    @abstractmethod
    def direction(self) -> PinDirection:
        """Returns the pin's direction.

        **If current pin configuration is an output:** PinDirection.OUTPUT

        **If current pin configuration is an input:** PinDirection.INPUT

        :return: Pin direction
        :rtype: PinDirection
        """

    @property
    @abstractmethod
    def polarity(self) -> PinPolarity:
        """Returns the pin's polarity.

        **PinPolarity.NORMAL indicates:** a value of 1 -> HIGH, 0 -> LOW.

        **PinPolarity.INVERTED indicates:** 1 -> LOW, 0 -> HIGH

        :return: Pin's polarity configuration
        :rtype: PinPolarity
        """

    @property
    @abstractmethod
    def value(self) -> int:
        """Returns the value of the pin, direction dependent.

        **If direction is OUTPUT:** returns drive level.

        **If direction is INPUT:** returns the measured level of the pin.

        .. warning::

           Pin.value will be deprecated in cl-test-station 2.0. Use explicit input/output methods instead

        :return: Pin level
        :rtype: int
        """

    @property
    @output_only_dir
    @output_only_kind
    def output(self) -> int:
        """Returns the current output value.

        :return: Pin level
        :rtype: int
        """

    @output.setter
    @output_only_dir
    @output_only_kind
    def output(self, value: int):
        """Sets the output value of the pin.

        :param value:
        :type value: int
        :return: None
        :rtype: None
        """

    @property
    @input_only_dir
    @input_only_kind
    def input(self) -> int:
        """Reads the input value of the pin.

        :return: Input value
        :rtype: int
        """
