"""
Base classes and decorators for building packet objects.
Author: Evan Canter <evan.canter@cirrus.com>
"""
from dataclasses import dataclass, field, _MISSING_TYPE, Field, replace
from enum import Enum, auto
from typing import List, Type, TYPE_CHECKING, Union

from bitarray import bitarray
from tabulate import tabulate
from cl_test_station.interfaces.ctrl_interface import ByteOrder, map_word, build_word
from cl_test_station.utilities.reusables import resolve_attr_path


# Special key used to find frame arguments in dataclass field's metadata
PACKET_METADATA_KEY = "__PacketFrame_args"


class PacketSteps(Enum):
    """Enumeration for a packet frame's step size. Determines whether the 'width' field measured in Bits or Bytes."""
    BIT = auto()
    BYTE = auto()


@dataclass
class PacketFrame:
    """Dataclass for a single frame of a packet. One packet class can have any number of frames defined within it."""
    name: str  # Name that maps to an attribute in the packet class
    step: PacketSteps  # Determines whether the 'width' field measured in Bits or Bytes
    width: int  # Size of the frame
    byte_order: ByteOrder = ByteOrder.MSB_FIRST  # Only gets used when step is PacketSteps.BYTE
    data_type: Type = None  # Mirrors dataclass field type from type hint in class definition

    @property
    def width_str(self) -> str:
        """
        Returns text desciption of the frame's width. For example, if width=8 and step=BIT, "8 Bits" will be returned.

        :return: Width desciprtion
        :rtype: str
        """
        s = 's' if self.width > 1 else ''
        step = 'Bit' if self.step is PacketSteps.BIT else 'Byte'
        return f"{self.width} {step}{s}"

    @property
    def width_bits(self) -> int:
        """
        Returns the frame's width in bits.

        :return: Frame bit-width
        :rtype: int
        """
        if self.step is PacketSteps.BYTE:
            return self.width << 3
        return self.width


def packetclass(_cls=None, *args, static: bool = False, deser_byteorder: ByteOrder = ByteOrder.MSB_FIRST, **kwargs):
    """
    Decorator that wraps the dataclass wrapper and adds packet frame construction. When a class uses this decorator, any
    'packet_frame' field definitions will be added to a class attribute __packet_frames__. The frames will be used to
    create a table-style visualization of the packet's format.

    Note: Wrapped class **must** inherit from the PacketBase class to enable serialization/deserialization functions

    :param cls: Class to convert to packet class.
    :type cls: Type[PacketBase]
    :param static: Flag for packets with a static length. Allows for deserialization from just an integer value
    :type static: bool
    :param deser_byteorder: Byte order of integer passed into deserialization function. Only used if static==True.
    Defaults to MSB_FIRST
    :type deser_byteorder: ByteOrder
    :param args: Positional arguments to be passed into the dataclass decorator
    :param kwargs: Key-worded arguments to be passed into the dataclass decorator
    :return: Wrapped class
    :rtype: Type[PacketBase]
    """
    def decorator(cls):
        if not issubclass(cls, PacketBase):
            raise TypeError(f"Class {cls.__name__} must be a child class of PacketBase")
        dc: Type['PacketBase'] = dataclass(cls, *args, **kwargs)


        # Parse data class fields for PacketFrames
        dc.__packet_frames__: List[PacketFrame] = []
        for field_name, field in dc.__dataclass_fields__.items():
            if PACKET_METADATA_KEY in field.metadata:
                # field.type = int
                dc.__packet_frames__.append(PacketFrame(name=field_name, data_type=field.type,
                                                        **field.metadata[PACKET_METADATA_KEY]))

        static_length = None
        # Get length in bytes using each frame
        if static:
            bit_length = 0
            for frame in dc.__packet_frames__:
                if not isinstance(frame.width, int):
                    raise ValueError(f"Static packet class with non-integer frame width: {frame.name}.width={frame.width}")
                frame_width = frame.width if frame.step is PacketSteps.BIT else frame.width << 3
                bit_length += frame_width
            static_length = bit_length >> 3

        # Set deserialization attributes
        dc._static = static
        dc._deser_byteorder = deser_byteorder
        dc._static_length = static_length

        # Build packet class's visualization function
        headers = []
        data = []

        # Find smallest frame to be the base for column width adjustment
        non_variable_frames = [f for f in dc.__packet_frames__ if type(f.width) is int]
        if non_variable_frames:
            smallest_frame = min(non_variable_frames,  key=lambda f: f.width_bits)
            min_width_bits = smallest_frame.width_bits
            min_width_repr = len(smallest_frame.width_str)
        else:
            min_width_bits = 8
            min_width_repr = 20
        # Create tabulate data and header list
        for frame in dc.__packet_frames__:
            # Add width string representation to data row
            if type(frame.width) is int:
                multiplier = frame.width_bits // min_width_bits
                text = frame.width_str
            # Width is variable, use ellipsis
            else:
                multiplier = 1
                text = '. . .'
            desired_length = min(20, min_width_repr * multiplier)
            headers.append(frame.name.center(desired_length, '?'))
            data.append(text.center(desired_length, '?'))

        # Store tabulate args
        dc.__packet_str_kwargs__ = {
            'tabular_data': [data],
            'headers': headers,
        }
        # Create method to print and remove '?' from column values (tabulate strips data so spaces could not be used)
        def visualize(cls, fmt: str = 'fancy_grid'):
            print(tabulate(**cls.__packet_str_kwargs__, tablefmt=fmt).replace('?', ' '))
        # Cast function as classmethod so cls automatically gets passed in
        setattr(dc, 'visualize', classmethod(visualize))

        # Return modified dataclass
        return dc

    # @packetclass(), return decorator function pointer
    if _cls is None:
        return decorator

    # @packetclass without parens, call decorator and return wrapped class
    return decorator(_cls)


def packet_frame(step: PacketSteps, width: int, byte_order = ByteOrder.MSB_FIRST, **kwargs) -> Field:
    """
    Function to define a frame within a packetclass. Creates a normal dataclass field with embedded frame metadata.

    :param step: Step size of frame, either bits or bytes
    :type step: PacketSteps
    :param width: Frame width
    :type width: int
    :param byte_order: If step=Byte and data type is an int, byte_order will be used to convert the field to a list of bytes
    :type byte_order: ByteOrder
    :param kwargs: Extra keyword arguments to pass into the field function
    :return: Dataclass Field with frame metadata
    :rtype: Field
    """
    return field(metadata={PACKET_METADATA_KEY: {'step': step, 'width': width, 'byte_order': byte_order}}, **kwargs)


class PacketBase:
    """Base class for all packets. Handles serialization (to bytes) and deserialization (from bytes)"""
    _frames: List[PacketFrame] = None
    _static: bool = None
    _deser_byteorder: ByteOrder = None
    _static_length: int = None

    def __post_init__(self):
        # Copy frames
        self._frames = [replace(f) for f in self.__packet_frames__]
        # Assign any frame widths that are dynamic
        for frame in self._frames:
            if type(frame.width) is str:
                referenced_value = resolve_attr_path(self, frame.width)
                frame.width = referenced_value

    def __len__(self):
        total_bits = 0
        for frame in self._frames:
            if frame.data_type is int or issubclass(frame.data_type, Enum):
                total_bits += frame.width_bits
            elif frame.data_type is list:
                total_bits += len(getattr(self, frame.name)) << 3
        return total_bits >> 3

    def __add__(self, other: 'PacketBase') -> List[int]:
        return self.serialize() + other.serialize()

    def __int__(self) -> int:
        ser = self.serialize()
        return build_word(bytes=ser, word_size=len(ser), byte_order=self._deser_byteorder)

    def _to_bitarray(self) -> bitarray:
        bits = bitarray()
        for byte in self.serialize():
            bits.extend(f"{byte:08b}")
        return bits

    def to_bin_str(self) -> str:
        return self._to_bitarray().to01()

    def to_bytes(self) -> bytes:
        return self._to_bitarray().tobytes()

    def serialize(self) -> List[int]:
        """
        Iterates through each packet frame and builds serialized list of integers using frame values.

        :return: List of bytes
        :rtype: List[int]
        """
        bits = bitarray()
        for frame in self._frames:
            # Convert Enum member/bool if necessary
            value = getattr(self, frame.name)
            if isinstance(value, Enum):
                value = value.value
            if isinstance(value, bool):
                value = int(value)
            # Case 1: frame is stepped by Byte, map to list of bytes and add to list
            if frame.step is PacketSteps.BYTE:
                if type(value) is list:
                    byte_list = value
                else:  # If value is a raw integer, map that int to bytes
                    byte_list = map_word(value, frame.width, frame.byte_order)
                # Convert each bytes to bin string and add to bitarray
                for byte in byte_list:
                    bits.extend(f"{byte:08b}")
            # Case 2: frame is stepped by Bit, need to add to current working byte
            else:
                value_bin = f"{value:0{frame.width}b}"
                bits.extend(value_bin)
        # Check length
        if len(bits) % 8:  # Not byte aligned
            raise ValueError("Frames with bit-width are not byte-aligned - some frames might be left out.")
        # Convert bits to bytes
        return list(bits.tobytes())

    # TODO: PLATDEV-1080 remove this
    @classmethod
    def get_min_req_len(cls, **variable_field_values):
        """
        Gets minimum required length of bytes necessary to deserialize the packet class. Ignores frames with default
        values and undefined variable length frames.

        :param variable_field_values:
        :type variable_field_values:
        :return:
        :rtype:
        """
        total_bits = 0
        for frame in cls.__packet_frames__:
            field: Field = cls.__dataclass_fields__[frame.name]
            if isinstance(field.default, _MISSING_TYPE) and isinstance(field.default_factory, _MISSING_TYPE):  # This is a required field
                # Add width of normal frames
                if type(frame.width) is int:
                    total_bits += frame.width_bits
                # For variable frames, check variable_field_values dict
                elif type(frame.width) is str:
                    if frame.width in variable_field_values:
                        total_bits += variable_field_values[frame.width] << (3 if frame.step is PacketSteps.BYTE else 0)
                    else:
                        raise KeyError(f"Required variable sized frame '{frame.name}' depends on {frame.width}, whose value "
                                       f"must be specified as a keyword argument, e.g. deserialize(*args, {frame.width}=n, **kwargs)")
            else:
                break
        return total_bits >> 3

    @classmethod
    def deserialize(cls, bytes_in: Union[List[int], int], **variable_field_values) -> 'PacketBase':
        packet_kwargs = {}
        # If an int was given, convert to list of bytes
        if type(bytes_in) is int:
            if cls._static:
                bytes_in = map_word(bytes_in, cls._static_length, cls._deser_byteorder)
            else:
                raise ValueError("Cannot deserialize using integer - packet class is not static. Add static=True, length=X")
        # Convert bytes to bits
        bits = bitarray()
        for byte in bytes_in:
            bits.extend(f"{byte:08b}")
        # Parse frames
        for frame in cls.__packet_frames__:
            # Skip all fields that aren't in the init
            if not cls.__dataclass_fields__[frame.name].init:
                frame_width = frame.width if frame.step is PacketSteps.BIT else frame.width << 3
                bits = bits[frame_width:]
                continue
            # Function to use to cast raw value into dataclass field type
            cast_type = int
            if issubclass(frame.data_type, Enum) or frame.data_type is bool:
                cast_type = frame.data_type
            # Replace width values if necessary
            if type(frame.width) is str:
                # Partition path
                base_attr, _, path = frame.width.partition('.')
                # First check user entered kwargs
                if base_attr in variable_field_values:
                    frame_width = variable_field_values[base_attr]
                # Check previously parsed frames
                elif base_attr in packet_kwargs:
                    if path:
                        frame_width = resolve_attr_path(packet_kwargs[base_attr], path)
                    else:
                        frame_width = packet_kwargs[base_attr]
                else:
                    raise KeyError(f"{frame.name}'s width '{frame.width}' was not found in kwargs or in previous frames")
            # Just use dataclass raw value
            else:
                frame_width = frame.width
            # Parse frame value
            if frame.step is PacketSteps.BYTE:
                frame_width_bits = frame_width << 3
                # Check remaining bytes are enough to construct this field
                if len(bits) < frame_width_bits:  # Not enough, raise error
                    raise IndexError("Insufficient number of bytes given.")
                # Slice bits
                frame_bits = bits[:frame_width_bits]
                frame_bytes = list(frame_bits.tobytes())
                if frame.data_type is list:  # Assign list to slice
                    packet_kwargs[frame.name] = frame_bytes
                else:  # Build single word from bytes and cast to dataclass type
                    word = build_word(bytes=frame_bytes, word_size=frame_width, byte_order=frame.byte_order)
                    packet_kwargs[frame.name] = cast_type(word)
                # Remove used bits from array
                bits = bits[frame_width_bits:]
            else:  # Bits
                if frame_width > len(bits):
                    raise IndexError("Insufficient number of bytes given.")
                frame_bits = bits[:frame_width]
                value = int(frame_bits.to01(), 2)
                packet_kwargs[frame.name] = cast_type(value)
                # Remove used bits from array
                bits = bits[frame_width:]
        # Use kwargs to build packet object
        return cls(**packet_kwargs)
