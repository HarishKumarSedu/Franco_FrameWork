"""
Common helper functions used within cl-test-station
Items may eventually be promoted into a reusable packages
"""
import inspect
import json
import logging
import math
import os
import re
import socket
import subprocess
import sys
import time
from copy import deepcopy
from enum import Enum, EnumMeta
from functools import lru_cache
from importlib import import_module
from pathlib import Path
from types import ModuleType
from typing import Tuple, List, Any, Callable, Union
import struct

try:
    import git
except ImportError:
    logging.warning("Failed to import 'git', try installing GitPython and try again")

from cl_test_station.utilities.cl_yaml_loader import yaml_load
from cl_test_station.utilities.varilist import enumerate


LOCALHOST = '127.0.0.1'


def read_int_value(input_value: Union[str, int]) -> int:
    """
    Converts given string to integer
    supports 0x/0X/0b/0B prefixes
    all other strings are assumed as decimal.

    :param input_value: input string
    :type input_value: str | int
    :return: Integer that the input represents
    :rtype: int
    """
    if type(input_value) is int:
        return input_value
    if input_value.startswith(('0b', '0B')):
        if re.search('[^0|1|_]', input_value[2:], re.IGNORECASE) is not None:
            raise ValueError(f'{input_value} is not a valid binary value')
        return int(input_value, 2)
    elif input_value.startswith(('0x', '0X')):
        if re.search('[^0-9|a-f|_]', input_value[2:], re.IGNORECASE) is not None:
            raise ValueError(f'{input_value} is not a valid hexadecimal value')
        return int(input_value, 16)
    else:
        if re.search('[^0-9|_]', input_value, re.IGNORECASE) is not None:
            raise ValueError(f'{input_value} is not a valid integer value')
        return int(input_value)

def read_bool_value(input_value: Union[str, bool]) -> bool:
    """
    Converts given string to boolean
    any string that starts with 1, t, or y (case insensative) is True
    all other strings are False.

    :param input_value: input string
    :type input_value: str | bool
    :return: Boolean value that the input represents
    :rtype: bool
    """
    if type(input_value) is bool:
        return input_value
    if input_value.startswith(('y', 'Y', '1', 't', 'T')):
        return True
    else:
        return False


def read_enum_value(input_value: Union[str, Enum], enum_cls: EnumMeta) -> Enum:
    """
    Takes in a string input and an EnumMeta class and returns the corresponding Enum.

    :param input_value: Enum string representation
    :type input_value: str | Enum
    :param enum_cls: EnumMeta class that contains all the Enums
    :type enum_cls: EnumMeta
    :return: Enum value
    :rtype: Enum
    """
    if isinstance(input_value, Enum):  # Pass through
        return input_value
    members = enum_cls.__members__
    if input_value in members:
        return members[input_value]
    else:
        raise KeyError(f"Invalid {enum_cls.__name__} '{input_value}', valid values are {', '.join(members.keys())}")


def reverse_byte(n: int) -> int:
    """
    Reverses bit order in byte 'n'

    :param n: Target byte
    :type n: int
    :return: Reversed Byte
    :rtype: int
    """
    n = (n & 0xF0) >> 4 | (n & 0x0F) << 4
    n = (n & 0xCC) >> 2 | (n & 0x33) << 2
    n = (n & 0xAA) >> 1 | (n & 0x55) << 1
    return n


def reverse_bytes(packet: List[int]) -> List[int]:
    """
    Reverses the bit order of each byte in the list

    :param packet: List of bytes to have bits reversed
    :type packet: List[int]
    :return: List of bytes with bits reversed
    :rtype: List[int]
    """
    reversed_bytes = []
    for byte in packet:
        reversed_bytes.append(reverse_byte(byte))
    return reversed_bytes


def get_station_ip() -> str:
    """
    Grabs the IP V4 address of your station
    based on https://stackoverflow.com/a/28950776

    :return: PC IP V4 address
    :rtype: str
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(('1.1.1.1', 1))   # using CloudFlare DNS
        ip_addr = s.getsockname()[0]
    except Exception:
        ip_addr = LOCALHOST
    finally:
        s.close()
        return ip_addr

def _get_all_int_revs(dir_path: str, base_fname: str) -> List[str]:
    """
    Scans dir_path directory and returns a list of all revision strings found in files that start with 'base_fname'

    :param dir_path: Path to search directory
    :type dir_path: str
    :param base_fname: Base name of revision files, without any revision suffix
    :type base_fname: str
    :return: List of all revision suffixes, e.g. base_fname_<revision>.ext
    :rtype: List[str]
    """
    prefix, ext = os.path.splitext(base_fname)
    suffixes = [os.path.splitext(f.replace(prefix + '_', ''))[0] for f in os.listdir(dir_path)
                if os.path.isfile(os.path.join(dir_path, f)) and prefix in f]
    revs = [s for s in suffixes if s.replace('_', '').isdigit()]  # Filter out any non digit revisions
    return revs

def get_revision_file(dir_path: str, base_fname: str, revision: str) -> str:
    """
    Gets absolute file path in folder 'dir_path' pointing to file closest to revision given. Order of searching:

    1. Exact match. If a file of the form 'dir_path/base_revision.ext' exists, this function will return immeditately
    2. If no exact match exists, the largest revision thats less than the target revision will be returned.
    3. If no smaller revisions exists, the smallest revision that is greater than the target revision will be returned.
    4. If no such files are found and the base file 'dir_path/base_fname.ext' exists, the base file will be returned
    5. None will be returned if no valid files are found

    There are two accepted string formats for revision searching: integer with underscores, and leading letters:
    - integers (e.g. '123', '123_001') will be converted to integers for comparison
    - alphanumerics (e.g. 'a0', 'c1', etc.) will use string compare, so a0 < c0 < c1 and so on.

    **NOTE: file structure is stritly: prefix_revision.extension**

    :param dir_path: Path to directory where revision files are stored
    :type dir_path: str
    :param base_fname: file base name, revision will be inserted at end with '_' separating
    :type base_fname: str
    :param revision: [str] target revision to search for
    :type revision: str
    :return: filepath
    :rtype: str
    """
    # todo: Need to add extra for replacing underscore
    # Check for exact match
    rev_suffix = "_" + revision if revision else ''
    prefix, ext = os.path.splitext(base_fname)

    # Figure out type of revision and create parsing functions
    rev_concat = revision.replace('_', '')
    if rev_concat.isdigit():  # This could be a C4 edition
        compare, filter, search = lambda _rev: int(_rev), lambda _rev: _rev.replace('_', '').isdigit(), True
    elif rev_concat and re.match('[a-zA-Z]', rev_concat[0]):  # Silicon rev, e.g. a0. Use string compare
        compare, filter, search = lambda _rev: _rev.lower(), lambda _rev: re.match('[a-zA-Z]', _rev[0]), True
    else:  # Unknown format, cannot search
        search = False

    # Check for exact revision match
    fname = os.path.join(dir_path, prefix + rev_suffix + ext)
    if os.path.isfile(fname):
        return fname

    # If revision can be compared, parse all revisions in the directory and find the closest match
    if search:  # Need to compare all other files in dir_path
        # Get all revision strings from map directory
        suffixes = re.findall(fr'{prefix}_(.*)?{ext}', '\n'.join(os.listdir(dir_path)))
        # Filter out non compatible revisions
        revs = [s for s in suffixes if filter(s)]
        # Compare all revisions to target, valid if revision <= target revision
        valid_revs = [rev for rev in revs if compare(rev) <= compare(revision)]
        # Pick revision to use
        rev_to_load = None
        if valid_revs:  # Grab largest valid revision
            rev_to_load = max(valid_revs, key=compare)
        elif revs:  # No valid revisions or base file, grab smallest revision file
            rev_to_load = min(revs, key=compare)
        if rev_to_load:  # A revision file was found, build file path from pattern prefix_rev.ext
            return os.path.join(dir_path, f"{prefix}_{rev_to_load}{ext}")
    # Base file could be used if no other file is found
    base_file = os.path.join(dir_path, base_fname)
    if os.path.isfile(base_file):
        return base_file


def get_latest_revision_file(dir_path: str, base_fname: str) -> str:
    """
    Gets file path of largest revisioned file in dir_path. If no revision files are found, returns base file (if exists)
    or None.

    :param dir_path: Path to directory where revision files are stored
    :type dir_path: str
    :param base_fname: file base name, revision will be inserted at end with '_' separating
    :type base_fname: str
    :return: Absolute path to file with largest revision
    :rtype: str
    """
    # Get all revision strings from map directory
    revs = _get_all_int_revs(dir_path, base_fname)
    if revs: # Get largest revision
        max_rev = max(revs, key=int)
        prefix, ext = os.path.splitext(base_fname)
        return os.path.join(dir_path, f"{prefix}_{max_rev}{ext}")
    # Base file could be used if no other file is found
    base_file = os.path.join(dir_path, base_fname)
    if os.path.isfile(base_file):
        return base_file

def revision_to_hex_str(revision: int, length: int = 0) -> str:
    """
    Converts a revision integer into a zero-filled hex string of length 'length'.

    :param revision: Raw revision
    :type revision: int
    :param length: Zero-fill length
    :type length: int
    :return: Zero-filled hex string
    :rtype: str
    """
    return hex(revision)[2:].zfill(length)


def expand_env_variables(config: dict):
    """
    Expands any environmental variables in dictionary 'config'.

    :param config: [dict] dictionary to expand
    :return: None
    """
    for key, value in config.items():
        if type(value) is str:  # Expand this string
            config[key] = os.path.expandvars(value)
        elif type(value) is dict:  # Recursively expand sub config
            expand_env_variables(value)


def expand_config_files(config: dict):
    """
    Finds any 'config_file' keys, loads the YAML file, updates dictionary

    :param config: config to parse
    :type config: dict
    :return: None
    """
    new_items = {}
    for key, value in config.items():
        if key == 'config_file':  # Load this file
            path = os.path.expandvars(value)
            if not os.path.isfile(path):  # File not found
                raise FileNotFoundError("Cannot expand %s's config, config_file not found: %s" % (key, path))
            elif os.path.splitext(path)[1] != '.yml':
                raise ValueError("Cannot expand %s's config, config_file is not YAML: %s" % (key, path))
            config_file_contents = yaml_load(path)
            new_items.update(yaml_load(path))
        elif type(value) is dict:  # Recursively expand sub config
            expand_config_files(value)
    config.update(new_items)


def diff_configs(d1: dict, d2: dict) -> List[Tuple]:
    """
    Performs key and value diff between d1 and d2.

    :param d1: Dictionary to diff against
    :type d1: dict
    :param d2: Dictionary to diff with
    :type d2: dict
    :return: Tuple containing a List of all Key diffs and a List of all Value diffs
        Format of diffs: (d1 content, d2 content)
    """
    s1 = set(flatten_dict(d1))
    s2 = set(flatten_dict(d2))
    return s1 - s2, s2 - s1


def flatten_dict(d: dict, path: List[str] = None) -> List[Tuple[str, str]]:
    """
    Converts a dictionary into a flattened list of tuples, where the first entry is the full path including nested
    dictionary keys and the second entry is the JSON serialized dict value that the path points to.

    :param d: Dictionary to flatten
    :type d: dict
    :param path: Current resolution
    :type path: List[str]
    :return: List of tuples containing flattened key-value pairs
    :rtype: List[Tuple[str, str]
    """
    if not path:
        path = []
    pairs = []
    for key, value in d.items():
        if type(value) is dict:
            pairs.extend(flatten_dict(value, path + [key]))
        else:  # Add the key value pair to list
            try:
                pairs.append(('.'.join(path + [key]), json.dumps(value)))
            except TypeError:
                continue
    return pairs


def format_request_url(url: str) -> str:
    """
    Removes test and release directories since both get searched through

    :param url: raw request url
    :type url: str
    :return: request url
    :rtype: str
    """
    if not url.endswith('/'):
        url += '/'
    if url.endswith('test/'):
        url = url.replace('test/', '')
    if url.endswith('release/'):
        url = url.replace('release/', '')
    return url


def get_editable_lib_info():
    """
    Finds all editable libraries in the environment and gets the commit hash for each library

    :return: dictionary of tuples where the key is the name of the library and the tuple is (remote_rul, sha)
    :rtype: dict
    """

    # output will be in columns where rows 0 and 1 are a header. Used columns since it includes the paths
    # in the output
    # The format of the row is as follows:
    # <library_name> <version> <path>
    proc = subprocess.Popen('pip list -e --format columns', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    output, err = proc.communicate()
    pip_list_output = output.decode("utf-8")

    libs = {}
    dirty_repos = {}
    # Split output by carriage return to get rows
    rows = pip_list_output.strip().split('\r')
    # Start iterating over rows from index 2 since rows 0 and 1 are the header rows
    for i in range(2, len(rows)):
        # Strip the row and split by white space
        columns = rows[i].strip().split()
        # use columns[2:] to account for paths with spaces. Any splits in the path will be recombined
        path = Path(' '.join(columns[2:]))
        # Get the commit hash
        repo = git.Repo(path)
        repo_sts = get_repo_status(repo)
        if repo_sts[0] or repo_sts[1]:
            dirty_repos[path] = repo_sts
        sha = repo.head.commit.hexsha
        # Get short version of hash, first 10 characters
        # See Git Pro Book: https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection
        # Recommends 8 - 10 characters for short hash for most projects can prevent collisions
        commit_id = repo.git.rev_parse(sha, short=10)
        # Get the remote url of origin
        url = repo.remotes.origin.url
        # Close the repo
        repo.close()
        # Create the key, value pair in the dictionary
        libs[columns[0]] = (str(url), commit_id)

    return libs, dirty_repos


def get_repo_status(repo):
    """
    Gets the status of the git repo that is passed in with parameter repo

    :param repo: git repo object that represents the git repository
    :type repo: gitpython object
    :return: Tuple that has lists of untracked and modified files (<untracked files list>, <modified files list>
    :rtype: tuple
    """
    modified_files = [item.a_path for item in repo.index.diff(None)]
    return repo.untracked_files, modified_files


def get_user_log_path(filename: str) -> str:
    """
    Generates a user accessible path for cl-test-station logs

    :param filename: filename to be used
    :type filename: str
    :return: joined filepath string
    :rtype: str
    """
    # select correct root folder based on platform
    if sys.platform == 'win32':
        prefix = os.environ['USERPROFILE']
    elif sys.platform == 'linux':
        prefix = '/home'
    else:
        prefix = os.path.expandvars('$PROJECT_ROOT')
    # build file name
    filename = os.path.join(prefix, 'python', 'cl_test_station', filename)
    return filename


def get_attr_safe(obj, attr_name) -> Any:
    """
    Gets the value of 'attr_name' without calling a property's fget()

    :param obj: Object to retrieve attribute from
    :type obj: Any
    :param attr_name: Name of attribute
    :type attr_name: str
    :return: value of attr_name
    :rtype: Any
    """
    for _obj in (obj,) + obj.__class__.__mro__:
        if attr_name in _obj.__dict__:
            return _obj.__dict__[attr_name]
    raise AttributeError(attr_name)


def time_func(func):
    def inner(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"{func.__name__} executed in {elapsed:2.5f}s")
        return result
    return inner

# POTENTIALLY NEW FUNCTIONS


def __get_alias_file(obj, target_cls, rev_formatter: Callable, component) -> str:
    """
    Gets the alias file located alongside 'target_cls'. alias file name format is base_name_revision.yml, where
    basename is either user-defined or the name of the class's python file.

    :param obj: Passed in block or component object in reference to self
    :param target_cls: Block Class to get alias file from. Can be any class reference from the Block's __mro__
    :type target_cls: class
    :param rev_formatter: function to format raw revision returned from Component class
    :param component: If passing in block enter block.container, if passing in component enter component
    :type rev_formatter: Callable
    :return: Full file path to alias YAML file
    :rtype: str
    """
    # Flags that will dictate log level in event of no alias files found
    external_alias_path = False
    external_base_name = False
    # NOTE: If we cannot use obj here we may just be able to pass alias_path into function
    if target_cls is obj.__class__:  # Check if alias_base_name is provided from YAML
        # Compute alias_path based on yaml field
        if obj.alias_path is None:
            alias_path = os.path.join(os.path.dirname(inspect.getfile(target_cls)), 'aliases')
        else:
            external_alias_path = True
            alias_path = obj.alias_path
        alias_path = os.path.expandvars(os.path.normpath(alias_path))
        # alias_path = obj.alias_path  # Use attribute for loading
        if not obj.alias_base_name:  # None provided, use default basename
            alias_base_name = os.path.splitext(os.path.basename(inspect.getfile(target_cls)))[0]
        else:
            external_base_name = True
            alias_base_name = obj.alias_base_name
        # alias_base_name = obj.alias_base_name
        if os.path.isdir(alias_path):  # Look in this directory for alias files
            # Set alias attributes on target object
            obj.alias_path = alias_path
            obj.alias_base_name = alias_base_name
            try:  # Get revision from the parent Component
                rev = getattr(component, '_Component__get_revision')()
            except Exception as e:  # Fail, try to use base file with no revision
                base_file = os.path.join(alias_path, alias_base_name + '.yml')
                if os.path.isfile(base_file):
                    obj.log.warning("Received %s when getting revision, using base alias file: %s"
                                    % (e.__class__.__name__, alias_base_name + '.yml'))
                    return base_file
                else:  # No file found, cannot create any aliases for this Block
                    obj.log.warning("Received %s when getting revision and base file '%s' not found. "
                                    "No Aliases will be created" % (
                                        e.__class__.__name__, alias_base_name + '.yml'))
                    return None
        else:
            if external_alias_path:
                obj.log.error(f"Given alias path is not a directory: {alias_path}")
            else:
                obj.log.info(f"'aliases' directory not found for {obj}")
            return None
    else:  # Just use default python file name as base name, this is an inherited block class
        alias_path = os.path.join(os.path.dirname(inspect.getfile(target_cls)), 'aliases')
        alias_base_name = os.path.splitext(os.path.basename(inspect.getfile(target_cls)))[0]
        rev = ''
    base_file = os.path.join(alias_path, alias_base_name + '.yml')  # Full file name besides the revision
    rev = rev_formatter(rev) if rev_formatter is not None else rev  # Format rev if a function was passed in
    # get_revision completed, find nearest match based on the revision
    alias_file = get_revision_file(alias_path, alias_base_name + '.yml', rev)
    if alias_file is not None:
        if alias_file == base_file:
            obj.log.info("No versioned files found, Using base alias file '%s'" % os.path.basename(base_file))
        else:
            obj.log.info("Using alias file: %s" % os.path.basename(alias_file))
        return alias_file
    else:  # No file was found
        if external_alias_path or external_base_name:  # User specified, raise error to signal bad input fields
            log_func = obj.log.error
        elif target_cls is obj.__class__:  # Auto-search failed
            log_func = obj.log.info
        else:  # Parent class, not useful most of the time
            log_func = obj.log.debug
        log_func(f"No alias files with base_name '{alias_base_name}' found in '{alias_path}'")
        return None


def alias(obj, component, rev_formatter: Callable = None):
    """
    For Block classes that inherit from Block, this function looks for an alias YAML file and creates an attribute
    mapping for its registers/fields.

    :param obj: Passed in block or component object in reference to self
    :param component: If passing in block enter block.container, if passing in component enter component
    :param rev_formatter: Optional function to format Component revision
    :type rev_formatter: Callable
    :return: None
    """
    # Parse this class's __mro__ to parse parent class aliases first
    load_order = []
    for cls in obj.__class__.__mro__:  # Order is obj.__class__, parents, Block, object
        if cls.__name__ in ['Block', 'CustomBlock', 'Component']:  # Stop here to not include Block or Component baseclass or object class
            break
        load_order.append(cls)
    if not load_order:  # This class is generic, check for external alias file fields
        if obj.alias_path and obj.alias_base_name:  # This generic class can be aliased using tso fields
            load_order.append(cls)
        elif cls.__name__ == 'CustomBlock':  # Show warning that no aliases will be created
            obj.log.warning(f"Generic CustomBlock {obj.name} does not have both 'alias_path' and 'alias_base_name' "
                            f"fields defined - this block will have no aliases")
    # Warn user if they have defined a base custom block with no alias fields (block will be useless otherwise)
    for cls in reversed(load_order):  # Need to parse parents first, so reverse the list
        obj.alias_file = __get_alias_file(obj, cls, rev_formatter, component)  # Try to find alias file
        if obj.alias_file is not None:  # Found a file
            obj._alias_yaml_dict.update(yaml_load(obj.alias_file, obj=obj))  # Update dictionary
    # Now that the _alias_yaml_dict is populated (with inheritance), parse it and create attributes
    temp = deepcopy(obj._alias_yaml_dict)
    conversion_summary = convert_alias_dict(obj, temp)  # Converts all dot paths and references into regmap objects
    for alias_name, attr in temp.items():
        setattr(obj, alias_name, attr)  # Set as attribute of the block
        obj.aliases[alias_name] = attr  # Store in dictionary as well
    # Once all valid aliases have been set, raise error if any had failed to be resolved
    if conversion_summary:
        obj.log.warning(conversion_summary, suppress_file_msg=True)


def convert_alias_dict(obj, d: dict) -> str:
    """
    Sets attributes from input dictionary, where key is name, value is current attribute name

    :param obj: Passed in block or component object in reference to self
    :param d: dictionary
    :return: Empty string if all aliases resolved correctly, summary of all broken aliases otherwise
    :rtype: str
    """
    failed_aliases = []
    for name, value in [(k, v) for k, v in d.items()]:
        if type(value) is dict:  # Recursively run through sub dictionary
            convert_alias_dict(obj, value)
        elif isinstance(value, list):  # Iterate over list
            for i, item in enumerate(value):
                if type(item) is dict:
                    convert_alias_dict(obj, item)
                elif type(item) is str:
                    try:
                        value[i] = __resolve_alias(obj, item)
                    except AttributeError as attr_err:
                        failed_aliases.append(f"Alias '{name}' - {str(attr_err)}")
                        value[i] = None
        elif type(value) is str:  # Could be dot path, need to iterate
            try:
                d[name] = __resolve_alias(obj, value)
            except AttributeError as attr_err:
                failed_aliases.append(f"Alias '{name}' - {str(attr_err)}")
                d.pop(name)  # Remove broken alias from dictionary
        else:
            obj.log.warning("Unsupported type for alias: %s" % type(value).__name__)
    conversion_summary = ''  # String that will contain error output for any broken aliases
    if failed_aliases:  # Format these into conversion_summary
        plural = 's' if len(failed_aliases) > 1 else ''
        lines = '\t' + '\n\t'.join(failed_aliases)
        conversion_summary = f'Encountered {len(failed_aliases)} error{plural} parsing ' \
                             f'{os.path.basename(obj.alias_file)}:\n(File "{os.path.abspath(obj.alias_file)}", ' \
                             f'line 0)\n{lines}\n'
    return conversion_summary


def __resolve_alias(obj, path) -> Any:
    """
    Takes in dot path either from block or component level and returns the object the path represents

    :param path: Path to object, eg BLOCK.REGISTER.FIELD
    :type path: str
    :return: Object reference
    :rtype: Any
    """
    import cl_test_station.register_map.block as block
    # Check if the path can be resolved at block level, then component level
    if isinstance(obj, block.Block):
        search_list = [obj, obj.component]
    else:
        search_list = [obj]
    for attr in search_list:
        try:
            for attr_name in path.split('.'):
                attr = getattr(attr, attr_name)
            # Fully resolved, return final object reference
            return attr
        except AttributeError:  # Not found, try next base attribute
            continue
    else:  # Attribute not found at either level, raise exception
        names = []
        for obj in search_list:
            names.append(obj.name if hasattr(obj, 'name') else obj.ref_name)
        raise AttributeError(f"Attribute {path} not found in {', '.join(names)}")


@lru_cache(maxsize=256)
def twos_comp_to_int(value, bits):
    """
    Convert 2s complement number to a signed python integer

    :param value: Integer that represents a 2s complement number
    :type value: int
    :param bits: Number of bits in the 2s complement number
    :type bits: int
    :return: Signed integer
    :rtype: int
    """
    if value > (1 << bits) - 1:  # Value too high for given bit count
        raise ValueError(f"{value} > {(1 << bits) - 1}, which is the max value for a {bits} bit 2s complement number")
    if value & (1 << (bits - 1)):  # if sign bit is set e.g., 8bit: 128-255
        value = value - (1 << bits)  # compute negative value
    return value  # return positive value as is


@lru_cache(maxsize=256)
def int_to_twos_comp(value, bits):
    """
    Converts int to 2s complement representation. eq for 5 bits, -12 (0b10100) -> 20 (0b10100)

    :param value: Integer value to convert to 2s complement
    :type value: int
    :param bits: Number of bits
    :type bits: int
    :return: Positive integer whose value equates to the 2s complement of val
    :rtype: int
    """
    max_value = (1 << bits - 1) - 1
    if value > max_value or value < -1 * max_value - 1:  # Value out of bounds
        raise ValueError(f"Value must be between {-1 * max_value - 1} and {max_value} for a {bits} bit 2s complement number")
    if value < 0:  # Flip and shift
        return (1 << bits) + value
    return value


def serializable(obj: Any, serializer: ModuleType) -> bool:
    """
    Attempts to call the serializer's dumps(obj) and returns True if no exception was raised.

    :param obj: Object to serialize
    :type obj: Any
    :param serializer: Serializer module, eg json, serpent, etc. Must have a dumps() function
    :type serializer: ModuleType
    :return: True if obj can be serialized, False is dumps() throws an error
    :rtype: bool
    """
    try:
        serializer.dumps(obj)
        return True
    except Exception:
        return False


def resolve_attr_path(obj: Any, attr_path: str) -> Any:
    attr = obj
    for attr_name in attr_path.split('.'):
        try:
            attr = getattr(attr, attr_name)
        except AttributeError as attr_err:
            partial_path = attr_path.partition(attr_name)[0].rstrip('.')
            raise AttributeError(f"Object '{partial_path}' has no attribute '{attr_name}'")
    return attr


def import_class_from_path(path: str):
    """
    Attempts to import a specified class from dot separated path.
    Will return a ModuleNotFoundError exception, if the package does not exist. An AttributeError is raised if the
    package exists but the specified class is not present.

    :param path: Python import path to class including .ClassName
    :type path: str
    :return: Imported class
    :rtype: Any
    """
    package_path, sep, class_name = path.rpartition('.')
    module = import_module(package_path)
    imported_class = getattr(module, class_name)
    return imported_class


def is_int(value: Union[int, float]) -> bool:
    """
    Returns True if value divided by 1 gives a remainder of 0. Attempts to duplicate LabView implementation.

    """

    # Note: I used math.fmod because it seemed the best match to the Quotient & Remainder Numeric VI that was used in
    # the LabView implementation of this function. That accepts floats.
    return math.fmod(value, 1) == 0


def is_even(value: Union[int, float]) -> bool:
    """Returns True if value divided by 2 gives a remainder of 0. Attempts to duplicate LabView implementation."""

    # So should these be allowed to be used on floats?

    # Note: I used math.fmod because it seemed the best match to the Quotient & Remainder Numeric VI that was used in
    # the LabView implementation of this function. In at least one corner case it produces the same unexpected result
    # as the LV code: for x = 1-1E-16 is_even(x) == is_odd(x) == False!

    return math.fmod(value, 2) == 0  # fmod returns -0.0 for value < 0, but comparing that to 0 gives True.


def is_odd(value: Union[int, float]) -> bool:
    """Returns True if value divided by 2 gives a remainder of 1. Attempts to duplicate LabView implementation."""

    # So should these be allowed to be used on floats?

    return abs(math.fmod(value, 2)) == 1


def db_to_ratio(value: Union[int, float]) -> float:
    """Returns the **voltage** ratio corresponding to the value in decibels. 10 dB corresponds to a ratio of 3.16.
    Duplicates LabView implementation.
    """

    # TODO: Should this be called db_to_voltage_ratio?

    return 10.0 ** (value / 20.0)


def ratio_to_db(value: Union[int, float]) -> float:
    """Returns decibels value corresponding to the supplied **voltage** ratio. Ratio of 10 corresponds to 20 dB.
    Duplicates LabView implementation.
    """

    return 20.0 * math.log10(value)


def db_to_power_ratio(value: Union[int, float]) -> float:
    """Returns the **power** ratio corresponding to the value in decibels. 10 dB corresponds to a ratio of 10.
    """

    return 10.0 ** (value / 10.0)


def power_ratio_to_db(value: Union[int, float]) -> float:
    """Returns decibels value corresponding to the supplied **power** ratio. Ratio of 10 corresponds to 10 dB.
    """

    return 10.0 * math.log10(value)


def fixed_format_split(fixed_format) -> Tuple[str, int, int]:
    """
    Returns the component parts of the specified fixed_format string, after checking for valid syntax and converting the
    numeric fields to ints.

    :param fixed_format: One of these forms 'QUn.m', 'Un.m', 'Qn.m', 'Q-n.m', 'Sn.m'. n is number of integer bits,
        m is number of binary fraction bits. Note that Q-n.m format denotes n<0, for a signed integer of width 1+n+m
        scaled by 2**-m.
    :type fixed_format: str
    :return: Tuple of sign_spec (str), nbits_integer (int) , nbits_fraction (int).
    :rtype: Tuple[str, int, int]
    """

    # TODO: Allow n < 0 for S format ?

    fixed_format = fixed_format.upper()  # Note: some datasheets use Qu.

    match_obj = re.match(r'(QU|U|Q|Q-|S)(\d+).(\d+)', fixed_format)

    if match_obj is None:
        raise ValueError(f"Bad fixed_format '{fixed_format}'. Should be a string of one of these forms: "
                         f"'QUn.m', 'Un.m', 'Qn.m', 'Q-n.m', 'Sn.m'. \nn is number of integer bits, m is number of "
                         f"bits in the binary fraction. Note that Q format allows n<0, for a total bit width of 1+n+m.")

    sign_spec, nbits_integer, nbits_fraction = match_obj.groups()
    sign_spec.upper()
    nbits_integer = int(nbits_integer)
    if sign_spec == 'Q-':
        sign_spec = 'Q'
        nbits_integer *= -1
    nbits_fraction = int(nbits_fraction)

    return sign_spec, nbits_integer, nbits_fraction


def fixed_lsb_size(fixed_format: str) -> float:
    """
    Returns the step size of specified fixed format. In other words the floating point value corresponding to the
    weight of the smallest fractional bit.

    :param fixed_format: One of these forms 'QUn.m', 'Un.m', 'Qn.m', 'Q-n.m', 'Sn.m'. n is number of integer bits,
        m is number of binary fraction bits. Note that Q-n.m format denotes n<0, for a signed integer of width 1+n+m
        scaled by 2**-m.
    :type fixed_format: str
    :return: Value of the LSB, the smallest fractional bit.
    :rtype: float
    """
    _, _, nbits_fraction = fixed_format_split(fixed_format)
    return 2 ** (-1 * nbits_fraction)


def fixed_to_float(fixed_value: int, fixed_format: str) -> float:
    """Returns the Python 64-bit float value that results when bits of fixed_value are interpreted using the specified
    fixed_format.

    :param fixed_value: Holds the bits of the fixed point representation, values can be 0 to 2**total_bits - 1.
        total_bits is the bit width of the format including integer bits + fractional bits + sign bit (if any).
    :type fixed_value: int
    :param fixed_format: One of these forms 'QUn.m', 'Un.m', 'Qn.m', 'Q-n.m', 'Sn.m'. n is number of integer bits,
        m is number of binary fraction bits. Note that Q format allows n<0, a signed integer of width of 1+n+m.")

        * | 'QU' indicates unsigned, total bits=n+m. Values range from 0 to 2**n - 2**-m in steps of 2**-m. Examples:
          | QU1.0 would be a single bit with the values 0 or 1;  QU8.0 would be 8 bits having values 0 to 255;
          | QU2.3 would be 5 bits corresponding to the values 0.0 to 3.875 in steps of 0.125.
        * 'U' Identical to 'QU'.
        * | 'Q' indicates signed, total bits=1+n+m, the sign bit is not counted in I. Sign bit=1 for negative values
          | which are twos-complement encoded. Values range from most positive 2**n - 2**-m, to most negative
          | -1.0*2**-n in steps of 2**-m. There is one more negative value than positive. Examples: 'S1.0' is two bits
          | with values: b01=>1.0, b00=>0.0, b11=>-1.0, b10=>-2.0. 'S2.3' would be 6 bits with the values ranging from
          | 0x1F=>3.875,...,0x20=>-4.0. Note that n may be negative but the total bit width must be positive. Negative n
          | values are interpreted as a signed integer of the total bit width scaled by 2**-m.
        * 'S' Identical to 'Q', but n<0 not permitted.
    :type fixed_format: str
    :return: The standard python float value (64-bits IEEE-754) which results from converting the fixed_value.
    :rtype: float
    """

    sign_spec, nbits_integer, nbits_fraction = fixed_format_split(fixed_format)

    total_bits = nbits_integer + nbits_fraction
    if nbits_fraction < 0 or total_bits <= 0:
        raise ValueError(f"Bad fixed_format '{fixed_format}', the sum nbits_integer + nbits_fraction must be > 0. "
                         f"Also, nbits_integer may be < 0 but nbits_fraction must always be >= 0.")

    if sign_spec in ('Q', 'S'):
        sign_mask = 2 ** total_bits
        is_neg = (fixed_value & sign_mask) >> total_bits  # Get the sign bit
        total_bits += 1  # Include the sign bit
    else:
        is_neg = 0

    max_fixed_value = (2 ** total_bits) - 1

    if not (0 <= fixed_value <= max_fixed_value):
        raise ValueError(f"Bad fixed_value {fixed_value} for '{fixed_format}', Should be 0 to 0x{max_fixed_value:0X}.")

    if is_neg:
        tmp = fixed_value - 1
        tmp = ~tmp & max_fixed_value  # mask off bits above our sign bit, those got set by taking the complement.
        return -1.0 * tmp * (2 ** (-1 * nbits_fraction))
    else:
        return fixed_value * (2 ** (-1 * nbits_fraction))


def float_to_fixed(float_value: float, fixed_format: str, overrange_handling: Union[None, str] = 'ERROR') -> int:
    """
    Returns the closest value in specified fixed_format that corresponds to the standard python 64-bit float_value.

    :param float_value: A standard python 64-bit float value to be converted to fixed point.
    :type float_value: float
    :param fixed_format: One of these forms 'QUn.m', 'Un.m', 'Qn.m', 'Q-n.m', 'Sn.m'. n is number of integer bits,
        m is number of binary fraction bits. Note that Q-n.m format denotes n<0, for a signed integer of width 1+n+m
        scaled by 2**-n. Examples:

        * 'QU' indicates unsigned, total bits=I+F. Values range from 0 to 2**I - 2**-F in steps of 2**-F. Examples:
            QU1.0 would be a single bit with the values 0 or 1;  QU8.0 would be 8 bits having values 0 to 255;
            QU2.3 would be 5 bits corresponding to the values 0.0 to 3.875 in steps of 0.125.
        * 'U' Identical to 'QU'.
        * 'Q' indicates signed, total bits=1+I+F, the sign bit is not counted in I. Sign bit=1 for negative values
            which are twos-complement encoded. Values range from most positive 2**I - 2**-F, to most negative
            -1.0*2**-I in steps of 2**-F. There is one more negative value than positive. Examples: 'S1.0' is two bits
            with values: b01=>1.0, b00=>0.0, b11=>-1.0, b10=>-2.0. 'S2.3' would be 6 bits with the values ranging from
            0x1F=>3.875,...,0x20=>-4.0.
        * 'S' Identical to 'Q'.
    :type fixed_format: str
    :param overrange_handling: Defines how out_of_range values are handled.

        * 'ERROR' - The default. Raise ValueError if float_value is outside the range representable by the fixed_format.
        * 'SATURATE' - Out of range values are silently saturated at the corresponding extreme of the fixed_format.
        * 'SATURATE_WARN' - Same as 'SATURATE' except that a warning is issued value is being saturated.
    :return: A int holding the bits of the fixed point value.
    :rtype: int
    """

    sign_spec, nbits_integer, nbits_fraction = fixed_format_split(fixed_format)

    if sign_spec in ('U', 'QU'):  # Unsigned representations.
        max_value = 2 ** nbits_integer - 2 ** (-1 * nbits_fraction)  # Max is 1 LSB less then 2**nbits_integer.
        min_value = 0.0
        tmp = _range_check_saturate(float_value, fixed_format, min_value, max_value, overrange_handling)
        tmp *= 2 ** nbits_fraction
        tmp += 0.5              # Values halfway or more positive between steps round up to next more positive step.
        return math.trunc(tmp)  # For unsigned, we're done.

    elif sign_spec in ('S', 'Q'):  # Signed representations.
        max_value = 2 ** nbits_integer - 2 ** (-1 * nbits_fraction)  # Max is 1 LSB less then 2**nbits_integer.
        min_value = -1.0 * 2 ** (1 * nbits_integer)  # It's 2s complement so negatives have one additional value.
        tmp = _range_check_saturate(float_value, fixed_format, min_value, max_value, overrange_handling)
        total_bits = 1 + nbits_integer + nbits_fraction  # Sign bit is not counted in nbits_integer
    else:
        raise NotImplementedError(f"The sign_spec '{sign_spec}' is not supported! (Also, the re in "
                                  f"fixed_format_split should have caught this!")

    # At last, the actual conversion code for signed!

    tmp *= (2 ** nbits_fraction)
    if tmp >= 0.0:
        tmp += 0.5  # Values halfway or more positive between steps round up to next more positive step
        return math.trunc(tmp)

    tmp -= 0.5  # Makes halfway or more negative between steps round to the next more negative step.
    tmp = math.trunc(tmp)  # Is already twos complement, but is sign extended, so
    tmp &= (2 ** total_bits) - 1  # clear all bits that are not part of our fixed point representation.
    return tmp


def _range_check_saturate(float_value, fixed_format, min_value, max_value, overrange_handling):
    """
    Helper function for float_to_fixed. Implements checking to see if the float value is within the range that can be
    represented by the specified fixed_format. If out-of-range, it either raises a ValueError or saturates the value,
    depending on the specified overrange_handling.

    :param float_value: Value intended to be converted to specified fixed_format.
    :type float_value: float
    :param fixed_format: The name of the fixed_format. Supplied here only for inclusion in error/warning messages.
    :type fixed_format: str
    :param min_value: The minimum float_value that can be converted using fixed_format. Minimum means most negative
        for signed formats.
    :type min_value: float
    :param max_value: The maximum float_value that can be converted using fixed_format.
    :type max_value: float
    :param overrange_handling: Defines how out_of_range values are handled.

        * 'ERROR' - The default. Raise ValueError if float_value is outside the range representable by the fixed_format.
        * 'SATURATE' - Out of range values are silently saturated at the corresponding extreme of the fixed_format.
        * 'SATURATE_WARN' - Same as 'SATURATE' except that a warning is issued when the value is being saturated.
    :type overrange_handling: str
    :return: If float_value was within range, the supplied value is returned. If float_value exceeds max_value, then
        max_value is returned. If float_value is more negative than min_value, then min _value is returned.
    :rtype:
    """

    overrange_handling_options = ('ERROR', 'SATURATE_WARN', 'SATURATE')
    if overrange_handling not in overrange_handling_options:
        msg = ', '.join(f"'{x}'" for x in overrange_handling_options)
        raise ValueError(f"Bad overrange_handling option '{overrange_handling}. Should be one of {msg}.")

    too_pos = float_value > max_value
    too_neg = float_value < min_value

    if too_pos | too_neg:
        if overrange_handling == 'ERROR':
            raise ValueError(f"Bad float_value {float_value}, out of range for '{fixed_format}', should be {min_value} "
                             f"to {max_value}.")

        if too_pos:
            if overrange_handling == 'SATURATE_WARN':
                logging.warning(f"float value {float_value} too positive for '{fixed_format}', saturating to most "
                                f"positive value {max_value}.")
            float_value = max_value
        if too_neg:
            if overrange_handling == 'SATURATE_WARN':
                logging.warning(f"float value {float_value} too negative for '{fixed_format}', saturating to most "
                                f"negative value {min_value}.")
            float_value = min_value

    return float_value


def float_to_float32_bits(value: float) -> int:
    """Returns an int containing the bits of a 32-bit floating point value obtained by converting the supplied value.

    :param value: Value to be converted, a standard Python float (64-bit IEEE-754). (C double precision).
    :type value: float
    :return: A positive integer whose bits are the 32-bits of the float32 (C single precision) representation.
    :rtype: int
    """

    byte_values = list(struct.pack('f', value))   # Bytes of corresponding single precision, from least to most signif.
    byte_weights = [v * 256 ** i for i, v in enumerate(byte_values)]
    return sum(byte_weights)


def float_to_float64_bits(value: float) -> int:
    """Returns an int containing the bits of a 64-bit floating point value obtained by converting the supplied value.

    :param value: Value to be converted, a standard Python float (64-bit IEEE-754). (C double precision).
    :type value: float
    :return: A positive integer whose bits are the 64-bits of the float64 (C double precision) representation.
    :rtype: int
    """

    byte_values = list(struct.pack('d', value))   # Bytes of corresponding single precision, from least to most signif.
    byte_weights = [v * 256 ** i for i, v in enumerate(byte_values)]
    return sum(byte_weights)

# TODO: Should float and fixed operations be funneled through a single function? We would have identify the format, F24 ?


def float_to_float24_bits(value: float) -> int:
    """Returns an int containing the bits of a 24-bit floating point value (Toots format) obtained by converting the
    supplied value.

    For details of the Toots 24-bit format, see: https://docs.cirrus.com/display/TOOT/Register+Map+Numerical+Formats,
    share link https://docs.cirrus.com/x/wxmNEg

    This code is an adaption of the Matlab code found on that page.

    :param value: Value to be converted, a standard Python float (64-bit IEEE-754). Equivalent to a C double.
    :type value: float
    :return: A positive integer whose bits are the 24-bits of the float24 representation.
    :rtype: int
    """

    # Constants
    f32_sign_mask = 0x8000_0000
    f32_exp_mask = 0x7f800000
    f32_mantissa_mask = 0x007F_FFFF
    f32_mantissa_bwidth = 23
    f32_to_f24_bias_adj = 0x40
    f24_sign_mask = 0x80_0000
    f24_exp_mask = 0x7f_0000
    f24_mantissa_mask = 0x0000_FFFF
    f24_mantissa_bwidth = 16
    f32_to_f24_mant_shift = f32_mantissa_bwidth - f24_mantissa_bwidth
    f24_mantissa_half_bit_in_f32_mantissa = 1 << (f32_to_f24_mant_shift - 1)
    f24_mant_mask_in_f32 = f24_mantissa_mask << f32_to_f24_mant_shift

    x = float_to_float32_bits(value)  # convert python 64-bit (C double) to 32-bit (C single) and get get raw bits.

    x_sign_f24 = (f32_sign_mask & x) >> 8
    x_expon_f32 = f32_exp_mask & x

    largest_mag = 1.8446603336221196e+19    # (2 - 2 ** -16) * 2 ** 63  See Docs page.
    if x_expon_f32 == f32_exp_mask or abs(value) > largest_mag:  # All expon bits 1 means =/- inf or Nan
        # Conversion to 32-bit causes magnitudes > 3.4028234664E38 to become infinities.
        # Doing the same if values exceeds float24 largest_mag.
        x_expon_f24 = f24_exp_mask
    else:
        x_expon_f24 = x_expon_f32 >> f32_mantissa_bwidth
        x_expon_f24 = x_expon_f24 - f32_to_f24_bias_adj
        x_expon_f24 = x_expon_f24 if x_expon_f24 > 0 else 0
        x_expon_f24 = x_expon_f24 << f24_mantissa_bwidth

    x_mantissa_f32 = f32_mantissa_mask & x

    # round to the nearest integer by adding 1/2 and truncating LSBs
    x_mantissa_f24_in_f32 = (x_mantissa_f32 + f24_mantissa_half_bit_in_f32_mantissa) & f24_mant_mask_in_f32
    x_mantissa_f24 = x_mantissa_f24_in_f32 >> f32_to_f24_mant_shift
    # x_f32_truncated_to_f24 = (x & ~f32_mantissa_mask) + x_mantissa_f24_in_f32

    return sum([x_sign_f24, x_expon_f24, x_mantissa_f24])


def float24_bits_to_float(float24_bits: int) -> float:
    """
    Converts the bits of a Toots float24 number into a Python float (64-bits IEEE-754) value.

    For details of the Toots 24-bit float, see: https://docs.cirrus.com/display/TOOT/Register+Map+Numerical+Formats,
    share link https://docs.cirrus.com/x/wxmNEg

    :param float24_bits: The 24-bits of a float24 number as would be found in a Toots register. Values should be limited
        to a range of a 24-bit unsigned int.
    :type float24_bits: int
    :return: Python float (64-bits IEEE-754)
    :rtype: float
    """

    if not(0 <= float24_bits <= 0xFF_FFFF):
        raise ValueError(f"Bad float24_bits {float24_bits:06X}, representation must be in the range of a 24-bit "
                         f"unsigned int: 0 to 0xFFFFFF (decimal={0xFFFFFF}).")

    sign_mask = 0x80_0000
    exponent_mask = 0x7F_0000
    mantissa_mask = 0xFFFF
    sign = (float24_bits & sign_mask) >> 23
    exp = float24_bits & exponent_mask
    if exp == exponent_mask:
        # Values with all exp bits==1 are treated as infinities in Toots 24-bit regardless of mantissa.
        # Consequently,  NaNs (mantissa != 0) are also mapped to infinities.
        if sign:
            return float('-infinity')
        else:
            return float('infinity')

    mantissa = float24_bits & mantissa_mask
    if exp == 0:
        if mantissa == 0:
            if sign:
                return -0.0
            else:
                return 0.0
        else:
            raise ValueError(f"Bad float24_bits 0x{float24_bits:X}, because this float24 representation does not "
                             f"support subnormals, i.e. expon bits==0 and mantissa bits != 0.")

    value = 1.0 + (mantissa * 2 ** -16)
    # make the exponent double
    exp = 1.0 * math.floor(exp * 2 ** -16)
    exponent = 2 ** (exp - 63)
    float_value = value * exponent
    if sign:
        float_value *= -1
    return float_value


# if __name__ == "__main__":
#     print('----- read_int_value Tests -----')
#     print(f"read_int_value('0x5') = {read_int_value('0x5')}")
#     test = read_int_value('dead')
#     print(f"read_int_value('dead') = {test} (0x{test:X})")
#     print(f"read_int_value('101') = {read_int_value('101')}")
#     print(f"read_int_value('1024') = {read_int_value('1024')}")
#     # print(f"read_int_value('0b1010') = {read_int_value('0b1010')}")
#     # test = read_int_value('0b10AF')
#     # print(f"read_int_value('0b10AF') = {test} (0x{test:X})")
#
#     print('\n----- read_bool_value Test -----')
#     print('*** True tests ***')
#     print(f"read_bool_value('yes') = {read_bool_value('yes')}")
#     print(f"read_bool_value('YesNo') = {read_bool_value('yesNo')}")
#     print(f"read_bool_value('T') = {read_bool_value('T')}")
#     print(f"read_bool_value('true') = {read_bool_value('true')}")
#     print(f"read_bool_value('1') = {read_bool_value('1')}")
#     print('*** False tests ***')
#     print(f"read_bool_value('') = {read_bool_value('')}")
#     print(f"read_bool_value('N') = {read_bool_value('N')}")
#     print(f"read_bool_value('0') = {read_bool_value('0')}")
#     print(f"read_bool_value('no') = {read_bool_value('no')}")
#     print(f"read_bool_value('false') = {read_bool_value('false')}")

