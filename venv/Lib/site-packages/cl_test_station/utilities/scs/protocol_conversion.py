"""
Contains functions that convert CL Test Station interfaces and attributes into their SoundClear Studio counterparts.
Author: Evan Canter <evan.canter@cirrus.com>
"""
from cl_test_station.interfaces.ctrl_interface import CtrlInterface, ByteOrder
from cl_test_station.interfaces.i2c_interface import I2cInterface
from cl_test_station.interfaces.spi_interface import SpiInterface
from cl_test_station.interfaces.spmi_interface import SpmiInterface
from cl_test_station.interfaces.spi_apb_interface import SpiApbInterface
from studiolink.enums.ControlInterface import ControlInterface

# TODO: This module does not account for library interface: soundwire

def is_scs_compatible(interface: CtrlInterface) -> bool:
    """
    Checks if the given interface is compatible with SCS.

    :param interface: Interface instance
    :type interface: CtrlInterface
    :return: True if interface is compatible, False otherwise
    :rtype: bool
    """
    return any([isinstance(interface, iface_cls) for iface_cls in [I2cInterface, SpiInterface, SpmiInterface, SpiApbInterface]])


def to_string(interface: CtrlInterface) -> str:
    """
    Converts a CL Test Station interface object into an SCS protocol string, e.g. I2cInterface -> 'SMbus_32inx_32dat'

    :param interface: Interface instance
    :type interface: CtrlInterface
    :return: Protocol string
    :rtype: str
    """
    inx = interface.read_reg_addr_size << 3  # Address bits
    dat = interface.read_reg_data_size << 3  # Data width
    if isinstance(interface, I2cInterface):  # SMbus_Xinx_Xdat
        return f"SMbus_{inx}inx_{dat}dat"
    # SPI protocol strings
    # ------------------------------
    # 4wireSPI_32inx_8dat -> 16 pad
    # 4wireSPI_32inx_8dat_32pad
    # 4wireSPI_16inx_16dat -> No pad
    # 4wireSPI_32inx_16dat -> 16 pad
    # 4wireSPI_32inx_32dat -> 16 pad
    # 4wireSPI_32inx_32dat_32pad
    # ------------------------------
    elif isinstance(interface, SpiInterface):
        pad = interface.padding << 3  # Pad bits
        protocol = f"4wireSPI_{inx}inx_{dat}dat"
        if pad == 32:
            protocol += "_32pad"
        elif inx == 32 and pad != 16:
            raise ValueError(f"Invalid combination: inx={inx}, dat={dat}, pad={pad}")
        # Add shift string
        if interface.address_shift > 0:
            protocol += f'_{interface.address_shift}asl'
        elif interface.address_shift < 0:
            protocol += f'_{-1 * interface.address_shift}asr'
        return protocol
    # SPMI protocol strings
    # ------------------------------
    # SPMI_16INX_8DAT
    # SPMI_16INX_32DAT
    # SPMI_16INX_32DAT_LE
    # ------------------------------
    elif isinstance(interface, SpmiInterface):
        if inx == 16 and dat == 8:
            return "SPMI_16INX_8DAT"
        elif inx == 16 and dat == 32:
            if interface.data_byte_order is ByteOrder.MSB_FIRST:
                return "SPMI_16INX_32DAT"
            else:
                return "SPMI_16INX_32DAT_LE"
        else:
            raise ValueError(f"Invalid combination: inx={inx}, dat={dat}")
    # SPI APB protocol strings
    # ------------------------------
    # APB_SPI_8BIT
    # APB_SPI_32BIT
    # ------------------------------
    elif isinstance(interface, SpiApbInterface):
        if dat not in [8, 32]:
            raise ValueError(f"Invalid data width: {dat}")
        return f"APB_SPI_{dat}BIT"
    else:
        raise ValueError(f"Unsupported interface type {type(interface)}")


def get_device_address(interface) -> int:
    """
    In SCS, DeviceAddress is a common attribute that is shared accross multiple different interfaces. For I2C, its the
    I2C device address, while for SPI it describes the chip select line number. This function takes in any interface
    instance and returns the correct value for the DeviceAddress attribute.

    :param interface: Interface instance
    :type interface: CtrlInterface
    :return: Device address
    :rtype: int
    """
    if isinstance(interface, I2cInterface):
        if hasattr(interface, "address"):
            return interface.address << 1
        else:
            raise ValueError(f"Given I2CInterface {interface.ref_name} does not have an address defined")
    elif isinstance(interface, SpiInterface):
        if hasattr(interface, "chip_select"):
            return interface.chip_select
        else:
            raise ValueError(f"Given I2CInterface {interface.ref_name} does not have a chip_select defined")
    elif isinstance(interface, SpmiInterface):
        return interface.peripheral_id
    elif isinstance(interface, SpiApbInterface):
        return interface.chip_select
    else:
        raise ValueError(f"Unsupported interface type: {type(interface)}")


def get_control_interface_value(interface) -> ControlInterface.ControlInterfaceValues:
    """
    Converts an interface instance into the matching ControlInterfaceValues Enum, e.g. I2cInterface -> CTRL_I2C

    :param interface: Interface instance
    :type interface: CtrlInterface
    :return: ControlInterfaceValues Enum
    :rtype: ControlInterface.ControlInterfaceValues
    """
    if isinstance(interface, I2cInterface):
        return ControlInterface.ControlInterfaceValues.CTRL_I2C
    elif isinstance(interface, SpiInterface):
       return ControlInterface.ControlInterfaceValues.CTRL_SPI
    elif isinstance(interface, SpmiInterface):
        return ControlInterface.ControlInterfaceValues.CTRL_SPMI
    elif isinstance(interface, SpiApbInterface):
        return ControlInterface.ControlInterfaceValues.CTRL_APB_SPI
    else:
        raise ValueError(f"Unsupported interface type: {type(interface)}")
