"""
Module that controls SoundClear Studio (SCS), python API and Java GUI.

SoundClear Studio 2.x releases page: https://docs.cirrus.com/x/EWMqDg

StudioLink releases page: https://docs.cirrus.com/x/wNJQDg

Author: Evan Canter <evan.canter@cirrus.com>
"""
import inspect
import os
import time
from typing import Dict, List

import cl_test_station.utilities.iter_priority as iter_priority
from cl_test_station.test_station_object import TestStationObject, TsoField, TestStationObjectConfigError
from cl_test_station.utilities.scs.generate_description import gen_system_description
from cl_test_station.utilities.tso_container import TsoContainer
from studiolink.device_comm.CLSystem import CLSystem
from studiolink.device_comm.Device import Device
from studiolink.exceptions.StudioLinkException import StudioLinkException
from studiolink.StudioLink import StudioLink
from tabulate import tabulate

# System name that will be displayed in the SCS systems tree view
CUSTOM_SYS_NAME = 'CL_Test_Station'


class StudioLinkAdapter(TestStationObject):
    """
    Bridge between CL Test Station and SoundClear Studio. Can connect to an existing system or create a custom system
    with 1:1 component matching from project config YAML file.
    -----------------------------------------------------------------------------------------------------------------
    How to use this class when building a custom system:

        * Fields:  build_desc_files=True [default], desc_file_location=path/to/desired/location
            * The 'system' field must **not** be defined.
        * Components will be added and linked automatically, using the component's test station path as its name.
        * If send_scs_updates=True [default], CL Test Station will update the SCS register map GUI any time a component has been accessed.

    How to use this class when linking to an existing system, e.g. a Board Support Package (BSP):

        * Fields: build_desc_files=False, system=<Name of SCS sysem currently loaded
            * If no system is given, the **default** system in SCS will be used.
        * Any devices (components) from the SCS system need to be linked by name to CL Test Station components to provide updates.
            * Each component must have the **scs_device_name** field set to the matching device name in SCS.
        * 'send_scs_updates' must be True to update the GUI after accessing components.

    **Note:** SCS updating is only available with SoundClear Studio 2.1.44.1 or greater.
    """
    _post_initialize_group: int = iter_priority.HIGH  # This should go efore most other objects since it needs to build device list

    build_desc_files: bool = TsoField(ftype=bool, required=False, default=True,
                                      desc="When True, converts active project config into system description .xml file.")
    desc_file_location: str = TsoField(ftype=str, required=False,
                                       desc="Location where generated description files will be stored. "
                                            "Subdirectories 'systems' and 'devices' will be created.")
    force_build_device_files: bool = TsoField(ftype=bool, required=False, default=False,
                                              desc="When True, bypasses revision checking when building device xml files")
    system: CLSystem = TsoField(ftype=str, required=False, desc="Name of SCS system to link to. If none is provided, "
                                                                "the default system will be used.")
    system_discovery_timeout: float = TsoField(ftype=float, required=False, default=5.0,
                                               desc="Time in seconds this class will wait for any SCS systems to "
                                                    "become available.")
    send_scs_updates: bool = TsoField(ftype=bool, required=False, default=True,
                                      desc="When True, enables transaction updates in SCS for all components.")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Check for field incompatibilities
        if self.build_desc_files and self.desc_file_location is None:
            raise TestStationObjectConfigError("Must specify field 'desc_file_location' since 'build_desc_files' is "
                                               "True. Class fields:\n\n" + self.get_class_fields_table())
        if self.build_desc_files and self.system is not None:
            raise TestStationObjectConfigError(f"Cannot connect to existing system {self.system} and build description "
                                               f"files. Either remove 'system' field or disable 'build_desc_files'. "
                                               f"Class fields:\n\n" + self.get_class_fields_table())
        # Create directories if needed
        if self.desc_file_location:
            for directory in [self.desc_file_location, self._get_systems_dir(), self._get_devices_dir()]:
                if not os.path.exists(directory):
                    os.mkdir(directory)
                elif not os.path.isdir(directory):
                    raise NotADirectoryError(directory)
        # Initialize StudioLink connection
        try:
            self.log.debug("Initializing StudioLink")
            if not StudioLink.isLinkRunning():
                self.log.info("Launching StudioLink background process")
            self.link = StudioLink(shutdownStudioLinkOnStop=True)
        except StudioLinkException as scs_err:
            raise EnvironmentError("Please make sure SCS and and StudioLink are installed.") from scs_err
        # Attempt to start link instance, will fail if SouncClear studio is not open
        try:
            self.log.debug("Starting link client")
            self.link.start()
        except StudioLinkException as scs_err:
            raise ProcessLookupError("Cannot connect to SCS, please make sure it is running") from scs_err
        # Once link is open, wait for systems to start showing up. If none are found, this adapter will not function.
        start = time.time()
        while time.time() - start < self.system_discovery_timeout:
            if len(self.link.getCLSystems()) != 0:  # Systems were found, exit loop
                break
            time.sleep(.25)
        else:  # Timeout occurred before systems were discovered, raise error
            self.log.warning(f"No systems were found after {self.system_discovery_timeout: 2.1f} seconds")

    def _get_systems_dir(self) -> str:
        """
        Gets path to 'systems' subdirectory

        :return: Systems path
        :rtype: str
        """
        return os.path.join(self.desc_file_location, 'systems')

    def _get_devices_dir(self) -> str:
        """
        Gets path to 'devices' subdirectory

        :return: Devices path
        :rtype: str
        """
        return os.path.join(self.desc_file_location, 'devices')

    def _get_clts_system(self, extra: str = '') -> CLSystem:
        """
        Gets system associated with cl-test-station.

        :param extra: Extra substring to check for
        :type extra: str:
        :return: SCS System object
        :type: CLSystem
        """
        for system in self.link.getCLSystems():
            name = system.getName().lower()
            if CUSTOM_SYS_NAME.lower() in name and extra in name:
                return system

    def post_system_initialize(self, **kwargs):
        """
        Either builds custom system or connects to existing one. Then gets all found devices and adds them to the
        'devices' TSO container

        :return: None
        :rtype: None
        """
        if self.build_desc_files:  # Build XML from constructed objects
            test_station = self.find_top_level()
            if len(self.link.getCLSystems()) > 1:  # Cannot guarantee default system will have hardware
                # Attempt to find a thrift controller that has a matching hostname
                found = False
                for controller in test_station.get_host_controllers().values():
                    if hasattr(controller, 'hostname'):  # This controller could be linked to a cirruslink system
                        hostname = controller.hostname.replace('.local', '').lower()
                        for system in self.link.getCLSystems():  # Search all available systems
                            if hostname in system.getName().lower():  # Found a match, use this system
                                self.system = system
                                found = True
                if not found:
                    raise StudioLinkException("Cannot build custom description files, SCS has more than one system "
                                              "opened and none that match with defined host controllers. "
                                              "Please close systems or relaunch SCS.")
                self.log.info(f"Found compatible system {self.system.getName()}")
            else:
                self.system = self.link.getDefaultCLSystem()  # Get system to set description
            # Generate system description file to apply to found system
            self.log.debug("Generating system desciption file")
            system_desc_file, component_paths, system_diff = gen_system_description(
                CUSTOM_SYS_NAME, self._get_systems_dir(), self._get_devices_dir(), test_station,
                force=self.force_build_device_files, logger=self.log)
            # If no new files were generated, and SCS has all devices already, leave it alone
            existing_components = [dev.getName() for dev in self.system.getDevices()]
            if system_diff or self.force_build_device_files or existing_components != component_paths:  # Update system
                self.link.setSystemDescription(self.system.getName(), system_desc_file)
                time.sleep(0.5)
            else:
                self.log.info(f"{self.system.getName()} already exists")
            # After setting system, re-grab and verify that all components got transferred correctly
            self.system = self._get_clts_system()  # Need to get system again to update the python instance
            if len(self.system.getDevices()) < len(component_paths):  # Check for components that failed to transfer
                found_devices = [d.getName() for d in self.system.getDevices()]
                missing = [p for p in component_paths if p not in found_devices]
                self.log.info("Devices not available in SCS: " + ", ".join([p for p in missing]))
        else:  # Connect to existing system
            # Attempt to resolve system
            if len(self.link.getCLSystems()) == 0 or \
                    len(self.link.getCLSystems()) == 1 and 'Unknown' in self.link.getCLSystems()[0].getName():
                # No systems, raise warning that no updates will happen
                self.log.warning("No systems were found in SoundClear Studio, register updates will be unavailable.")
                self.system = None
            elif self.system:
               self.system = self.link.getCLSystem(self.system)
            else:
                self.system = self.link.getDefaultCLSystem()
        # Get all devices from system
        self.devices = TsoContainer(ref_name='devices', container=self, resource_type=Device)  # type: Dict[str, Device]
        if self.system:
            self.log.info(f"Connected to system '{self.system.getName()}'")
            for device in self.system.getDevices():
                self.log.debug(f"Adding device: '{device.getName()}'")
                self.devices[device.getName()] = device

    def close(self):
        """
        Closes the link connection.

        :return: None
        :rtype: None
        """
        self.link.stop()

    def _check_device(self, device_name: str) -> Device:
        """
        Checks that the given device is in the instance's devices container, then returns the instance of the device.
        Raises a KeyError if the device does not exist.

        :param device_name: Name of SCS device
        :type device_name: str
        :return: SCS Device object
        :rtype: Device
        """
        if device_name not in self.devices:
            raise KeyError(f"Device '{device_name}' not found in system {self.system.getName()}, available devices "
                           f"are: {', '.join(self.devices.keys())}")
        return self.devices[device_name]

    def update_register_read(self, device_name: str, address: int, value: int):
        """
        Sends a register read update to the SCS GUI. Will log a new line in its transaction log, and update the
        displayed contents in the register map view.

        :param device_name: Name of the device to update
        :type device_name: str
        :param address: Register address
        :type address: int
        :param value: Read value
        :type value: int
        :return: None
        :rtype: None
        """
        device = self._check_device(device_name)
        if self.send_scs_updates:
            device.updateRegisterValueForRead(address, value)

    def update_register_write(self, device_name: str, address: int, value: int):
        """
        Sends a register write update to the SCS GUI. Will log a new line in its transaction log, and update the
        displayed contents in the register map view.

        :param device_name: Name of the device to update
        :type device_name: str
        :param address: Register address
        :type address: int
        :param value: Write value
        :type value: int
        :return: None
        :rtype: None
        """
        device = self._check_device(device_name)
        if self.send_scs_updates:
            device.updateRegisterValueForWrite(address, value)

    def update_register_block_read(self, device_name: str, address: int, values: List[int]):
        """
        Sends a register block read update to the SCS GUI. Will log a new line in its transaction log, and update the
        displayed contents in the register map view.

        :param device_name: Name of the device to update
        :type device_name: str
        :param address: Register address
        :type address: int
        :param value: Read values
        :type value: List[int]
        :return: None
        :rtype: None
        """
        device = self._check_device(device_name)
        if self.send_scs_updates:
            device.updateRegisterValueForBlockRead(address, values)

    def update_register_block_write(self, device_name: str, address: int, values: List[int]):
        """
        Sends a register block write update to the SCS GUI. Will log a new line in its transaction log, and update the
        displayed contents in the register map view.

        :param device_name: Name of the device to update
        :type device_name: str
        :param address: Register address
        :type address: int
        :param value: Write values
        :type value: List[int]
        :return: None
        :rtype: None
        """
        device = self._check_device(device_name)
        if self.send_scs_updates:
            device.updateRegisterValueForBlockWrite(address, values)

    def update_register_chain_read(self, device_name: str, address: int, values: List[int]):
        """
        Sends a register chain read update to the SCS GUI. Will log a new line in its transaction log, and update the
        displayed contents in the register map view.

        :param device_name: Name of the device to update
        :type device_name: str
        :param address: Register address
        :type address: int
        :param value: Read values
        :type value: List[int]
        :return: None
        :rtype: None
        """
        device = self._check_device(device_name)
        if self.send_scs_updates:
            device.updateRegisterValueForFifoRead(address, values)

    def update_register_chain_write(self, device_name: str, address: int, values: List[int]):
        """
        Sends a register chain write update to the SCS GUI. Will log a new line in its transaction log, and update the
        displayed contents in the register map view.

        :param device_name: Name of the device to update
        :type device_name: str
        :param address: Register address
        :type address: int
        :param value: Write values
        :type value: List[int]
        :return: None
        :rtype: None
        """
        device = self._check_device(device_name)
        if self.send_scs_updates:
            device.updateRegisterValueForFifoWrite(address, values)

    def dump_systems(self):
        """
        Prints all discovered systems available in SCS.

        :return: None
        :rtype: None
        """
        self.log.info("Dumping all CL Systems in SCS:")
        max_name_len = len(max([s.getName() for s in self.link.getCLSystems()], key=len))
        for system in self.link.getCLSystems():
            self.log.print(f"{system.getName().rjust(max_name_len)}: {repr(system)}")

    def dump_system_devices(self, system_name: str = None):
        """
        Prints repr's for all devices defined under a given SCS system.

        :param system_name: SCS System name. If None, the default system will be used.
        :type system_name: str
        :return: None
        :rtype: None
        """
        if system_name:
            system = self.link.getCLSystem(system_name)
        else:
            system = self.system
        self.log.info(f"Dumping all Devices in {system.getName()}:")
        max_name_len = len(max([d.getName() for d in system.getDevices()], key=len))
        for device in system.getDevices():
            self.log.print(f"{device.getName().rjust(max_name_len)}: {device}")
