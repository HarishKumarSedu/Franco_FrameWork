"""
Function definitions for converting a test station instance into a collection of SCS description files.
Author: Evan Canter <evan.canter@cirrus.com>
"""
import os
import xml.dom.minidom as minidom
import xml.etree.ElementTree as xml
from typing import List, Tuple

import cl_test_station.utilities.scs.protocol_conversion as protocol_conversions
from cl_test_station.register_map.field import ACCESS_PERMISSION
from cl_test_station.test_station_object import TestStationObject
from studiolink.enums.ControlInterface import ControlInterface


def get_access_text(access: ACCESS_PERMISSION) -> str:
    """
    Converts access permission enum into the 'Access' element test, which has a forward slash.

    :param access: Access enum from register map
    :type access: ACCESS_PERMISSION
    :return: Access text for description file <Field> elements
    :rtype: str
    """
    if access is ACCESS_PERMISSION.RO:
        return 'R/O'
    if access is ACCESS_PERMISSION.WO:
        return 'W/O'
    if access is ACCESS_PERMISSION.RW:
        return 'R/W'
    else:
        raise ValueError(f"Invalid access type: {access}")


def gen_system_description(name: str, systems_path: str, devices_path: str, test_station: TestStationObject,
                            force: bool = False, logger=None, **system_sub_elements: str) -> Tuple[str, List[int], bool]:
    """
    Generates a system desciption xml file along with all necessary device description xml files. Creates SCS system
    representation of a dynamic, fully constructed/initialized test station instance.

    :param name: Name of system that will be displayed in SCS
    :type name: str
    :param systems_path: Path to directory where system description file will be stored
    :type systems_path: str
    :param devices_path: Path to directory where device description files will be stored
    :type devices_path: str
    :param test_station: Test Station instance to process
    :type test_station: TestStation
    :param force: When True, will generate device files even if one already exists for a given component + revision
    :type force: bool
    :param logger: Logger used to relay info/debug messages while generating
    :type logger: LoggingAdapter
    :param system_sub_elements: All extra sub elements will be added to the <SCSSytem> top level element
    :type system_sub_elements: str
    :return: Tuple containing path to system desciption xml file, components transferred, and if the system changed
    :rtype: Tuple[str, int, bool]
    """
    # Create root
    scs_system = xml.Element("SCSSystem")
    # Create name/readable name sub elements
    name_element = xml.SubElement(scs_system, 'Name')
    name_element.text = name
    readable_name = xml.SubElement(scs_system, 'ReadableName')
    readable_name.text = name
    board_hw_id = xml.SubElement(scs_system, 'BoardHardwareID')
    board_hw_id.text = '0xFF'
    # Add passed in sub elements
    for sub_name, text in system_sub_elements.items():
        sub = xml.SubElement(scs_system, sub_name)
        sub.text = text
    # Create all devices
    devices = xml.Element("Devices")
    scs_system.append(devices)
    from cl_test_station.components.component.component import Component
    components = test_station.find_all(Component)
    changed_components = []
    invalid_components = []
    for _, component in components:
        component: Component
        device = xml.Element("Device")
        devices.append(device)
        # Type and Name sub elements
        device_type = xml.SubElement(device, "Type")
        device_type.text = component.__class__.__name__
        device_name = xml.SubElement(device, "Name")
        device_name.text = component.path
        # Attempt to get revision
        try:
            revision = component.get_revision()
            revision_concat = revision.replace('_', '')
        except:
            revision = ''
            revision_concat = ''
        device_revision = xml.SubElement(device, "DeviceRevision")
        if revision:
            device_revision.text = revision_concat
        # Generate device desciption xml
        device_xml_path = os.path.join(devices_path, f"{component.ref_name}{'_' if revision else ''}{revision}.xml")
        definiton_path = xml.SubElement(device, "DefinitionPath")
        definiton_path.text = device_xml_path.replace(os.sep, '/')
        compatible_interfaces = [i for i in component.interfaces.values() if protocol_conversions.is_scs_compatible(i)]
        # # ----- Component Description ----- # #
        if not os.path.exists(device_xml_path) or force:  # Generate xml
            changed_components.append(component.path)
            if logger:
                logger.info(f"Building device descriptor for {component.ref_name}")
            # Create device xml file
            device_description = xml.Element("SCSDevice")
            # # ----- Device info ----- # #
            device_info = xml.Element("DeviceInfo")
            device_description.append(device_info)
            device_type = xml.SubElement(device_info, "Type")
            device_type.text = component.__class__.__name__
            device_reported_id = xml.SubElement(device_info, "ReportedID")
            device_reported_id.text = '0'
            device_revision = xml.SubElement(device_info, "Revision")
            device_revision.text = revision_concat
            device_ds_revision = xml.SubElement(device_info, "DataSheetRevision")
            device_merge_behavior = xml.SubElement(device_info, "FieldWriteMergeBehaviour")
            device_merge_behavior.text = "Device"
            # Auto incremement. Check that all control interfaces have ainc==true
            ainc = True
            for interface in compatible_interfaces:
                if hasattr(interface, 'ainc'):
                    ainc &= interface.ainc
                else:
                    ainc = False
            if ainc:
                device_ainc = xml.SubElement(device_info, "AutoIncrement")
                device_ainc.text = '1'
            control_interfaces = xml.Element("ControlInterfaces")
            device_info.append(control_interfaces)
            for interface in component.interfaces.values():
                try:
                    protocol = protocol_conversions.to_string(interface)
                except ValueError:
                    continue
                ctrl_iface = xml.Element("ControlInterface")
                control_interfaces.append(ctrl_iface)
                iface_protocol = xml.SubElement(ctrl_iface, "InterfaceProtocol")
                iface_protocol.text = protocol
                try:
                    device_address = protocol_conversions.get_device_address(interface)
                    device_address_sub = xml.SubElement(ctrl_iface, "DeviceAddress")
                    device_address_sub.text = f"0x{device_address:02X}"
                except ValueError:
                    pass
            # # ----- Registers/Fields ----- # #
            fields = xml.Element("Fields")
            device_description.append(fields)
            # Create Sections of registers in order of occurrence, grouped by size.
            reg_sections_by_width = {}
            spanned_fields_processed = set()
            for reg in component.get_all_registers():
                if reg.length not in reg_sections_by_width:  # Create new section element
                    # Find interfaces that have width and check for ainc/stride
                    stride = set()
                    for interface in [i for i in compatible_interfaces if i.read_reg_data_size == reg.length >> 3]:
                        stride.add(interface.address_stride)
                    extra = {}
                    if ainc and len(stride) == 1:
                        extra['AddressIncrement'] = str(stride.pop())
                    registers = xml.Element("Registers", Width=str(reg.length),
                                            Name=f"Section {len(reg_sections_by_width) + 1}", **extra)
                    reg_sections_by_width[reg.length] = registers
                    device_description.append(registers)
                else:  # Use existing element
                    registers = reg_sections_by_width[reg.length]
                # # ----- Define register ----- # #
                register = xml.Element("Register")
                registers.append(register)
                # Name
                register_name = xml.SubElement(register, "Name")
                flat_register_name = reg.path.replace('.', '_')
                register_name.text = flat_register_name
                # Block Name
                block_name = xml.SubElement(register, "BlockName")
                block_name.text = reg.container.name
                # Datasheet Name
                data_sheet_name = xml.SubElement(register, "DatasheetName")
                data_sheet_name.text = reg.name  # TODO: Better value for this?
                # Address
                register_address = xml.SubElement(register, "Address")
                register_address.text = hex(reg.addr)  # TODO: How to get addr size without interfaces?
                # Default Value
                default_value = xml.SubElement(register, "DefaultValue", format="hex")
                default_value.text = f"0x{reg.reset_val:0{reg.length >> 2}X}"
                # Access
                register_access = xml.SubElement(register, "Access")
                register_access.text = get_access_text(reg.access)
                # SW Access
                register_sw_access = xml.SubElement(register, "SoftwareAccess")
                register_sw_access.text = reg.access.name
                # # ----- Fields ----- # #
                for field in reg.get_fields():
                    if field.spans_multiple_regs and field.name in spanned_fields_processed:  # Skip repeat spanned fields
                        continue
                    field_elem = xml.Element("Field")
                    fields.append(field_elem)
                    # Name
                    field_name = xml.SubElement(field_elem, "Name")
                    field_name.text = f"{reg.container.name}_{field.name}"
                    # Address
                    field_address = xml.SubElement(field_elem, "Address")
                    if not field.spans_multiple_regs:  # Regular field
                        if field.bit_width > 1:
                            location = f"{field.bit_offset + field.bit_width - 1}:{field.bit_offset}"
                        else:
                            location = str(field.bit_offset)
                        address_text = f"{flat_register_name}[{location}]"
                    else:  # Spanned fields, follows form REGn[i:j]+REGn-1[m:n]...
                        addends = []
                        span_dict = reg.container.spanned_fields[field.full_name]
                        # Arrange registers from MSB -> LSB
                        ascending_reg_list = sorted(span_dict, key=lambda reg: min(span_dict[reg].keys()))
                        for span_reg, bit_pos in {r: span_dict[r] for r in reversed(ascending_reg_list)}.items():
                            if len(bit_pos) > 1:
                                location = f"{max(bit_pos.values())}:{min(bit_pos.values())}"
                            else:
                                location = str(field.bit_offset)
                            addends.append(f"{span_reg.path.replace('.', '_')}[{location}]")
                        address_text = '+'.join(addends)
                        spanned_fields_processed.add(field.name)
                    field_address.text = address_text
                    # Description
                    field_desc = xml.SubElement(field_elem, "Description")
                    field_desc.text = field.description
                    # Datasheet Name
                    field_ds_name = xml.SubElement(field_elem, "DatasheetName")
                    field_ds_name.text = field.name
                    # Default Value
                    field_default_value = xml.SubElement(field_elem, "DefaultValue")
                    hex_str = f"{field.reset_value:0{field.bit_width >> 2}X}"[0:8]
                    field_default_value.text = f"0x{hex_str}"
                    # Access
                    field_access = xml.SubElement(field_elem, "Access")
                    field_access.text = get_access_text(field.access)
                    # SW Access
                    field_sw_access = xml.SubElement(field_elem, "SoftwareAccess")
                    field_sw_access.text = field.ipx_type
                    # Volatile
                    field_volatile = xml.SubElement(field_elem, "Volatile")
                    field_volatile.text = str(field.volatile).lower()
                    # TODO: Test?
            # Write Component xml to file
            contents = minidom.parseString(xml.tostring(device_description)).toprettyxml(indent='    ')
            with open(device_xml_path, 'w', encoding='utf-8')as f:
                f.write(contents)
        for interface in [component.active_interface] + list(component.interfaces.values()):
            try:
                iface_enum = protocol_conversions.get_control_interface_value(interface)
            except ValueError:
                continue
            # Tags will change based on the interface
            if iface_enum is ControlInterface.ControlInterfaceValues.CTRL_I2C:
                control_interface = xml.SubElement(device, "ControlInterface")
                control_interface.text = "I2C"
                if hasattr(interface, 'address'):  # Address in fields
                    dev_addr = xml.SubElement(device, "DeviceAddress")
                    dev_addr.text = f"0x{interface.address << 1:02X}"
                if hasattr(interface, "bus_num"):
                    bus_number = xml.SubElement(device, "BusNumber")
                    bus_number.text = str(interface.bus_num)
            elif iface_enum is ControlInterface.ControlInterfaceValues.CTRL_SPI:
                control_interface = xml.SubElement(device, "ControlInterface")
                control_interface.text = "SPI"
                if hasattr(interface, 'chip_select'):
                    dev_addr = xml.SubElement(device, "DeviceAddress")
                    dev_addr.text = str(interface.chip_select)
                if hasattr(interface, 'bus_num'):
                    bus_number = xml.SubElement(device, "BusNumber")
                    bus_number.text = str(interface.bus_num)
            elif iface_enum is ControlInterface.ControlInterfaceValues.CTRL_APB_SPI:
                if logger:
                    logger.info("APB SPI conversion is currently not implemented, device will not have a "
                                   "ControlInterface SubElement")
                continue
            elif iface_enum is ControlInterface.ControlInterfaceValues.CTRL_SPMI:
                control_interface = xml.SubElement(device, "ControlInterface")
                control_interface.text = "SPMI"
                if hasattr(interface, 'peripheral_id'):
                    dev_addr = xml.SubElement(device, "DeviceAddress")
                    dev_addr.text = str(interface.peripheral_id)
            break
        else:  # No interfaces found, remove device
            logger.warning(f"No SCS compatible interfaces found for {device_name.text}, removing from system")
            devices.remove(device)
            invalid_components.append(component.path)
            if component.path in changed_components:
                changed_components.remove(component.path)

    # Write system xml to file
    system_desc_file = os.path.join(systems_path, f"{test_station.ref_name}.xml")
    contents = minidom.parseString(xml.tostring(scs_system)).toprettyxml(indent='    ')
    with open(system_desc_file, 'w', encoding='utf-8')as f:
        f.write(contents)

    return system_desc_file, [path for path, _ in components if path not in invalid_components], bool(changed_components)
