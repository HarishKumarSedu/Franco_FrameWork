from cl_test_station.test_station_object import TestStationObject
from cl_test_station.pyro_support.pyro_receiver import PyroReceiver
from cl_test_station.utilities.reusables import read_int_value
from cl_test_station.register_map.block import Block
from cl_test_station.register_map.register import Register
from cl_test_station.register_map.field import Field

import re, json
BURST_ENABLED_CONTROLLERS = ['AudioHubController', 'ZdcController']


def get_indentation(s):
    """
    Gets the level (in multiples of 4 spaces) of a given line of text

    :param s: line of text to get indentation level
    :type s: str
    :rtype: int
    """
    s = s.replace('\n', '')
    return int((len(s) - len(s.strip())) / 4)


def rebase_indentation(lines):
    """
    Re indents lines based off of first line

    :param lines: The lines to be re indented
    :type lines: str
    :return: list
    """
    block = []
    base = get_indentation(lines[0])
    for line in lines:
        block.append((line.replace('    ', ''), get_indentation(line) - base))
    result = []
    for line, indent in block:
        result.append('    '*indent + line)
    return result


def parse_code_block(code_lines, start_line=0):
    """
    Parses entire block from code_lines starting from start_line. Stops when indentation returns and stores all object
    references in attributes

    :param code_lines: list of lines of code
    :type code_lines: list
    :param start_line: starting point for parsing
    :type start_line: int
    :return: tuple of (lines, attributes) where lines are stripped and indented, attributes are all attr references
    :rtype: tuple
    """
    lines = []  # Code lines to compile and execute on AH
    attributes = []  # List of attribute names used in burst that need to be transfered

    """PARSING LINES AND ATTRIBUTES IN BLOCK"""
    with_inx = get_indentation(code_lines[start_line])
    #todo: more elaborate code block to pull nested attributes
    exp_regex = re.compile(r'self\.(\w+)')  # Matches all attributes used in each line
    for i in range(start_line + 1, len(code_lines)):
        line = code_lines[i]
        if not line.strip() or line.strip().startswith('#'):
            continue  # Ignore blank lines and comments
        line_inx = get_indentation(line) - with_inx
        if line_inx > 0:  # This line is part of with block, strip and add relative indentation
            temp = exp_regex.findall(line)
            for attr in temp:
                if not attr.startswith('__') and not attr.endswith('__'):
                    attributes.append(attr)
            stripped_line = ('    ' * (line_inx - 1)) + line.strip()
            lines.append(stripped_line)
        else:  # Done with the block
            break

    return lines, attributes

def parse_station_attributes(obj, test_station, attributes):
    """
    Parses through obj attribute references and separates all aliases to TestStationObjects in test_station

    :param obj: Instance of class that code block is contained in
    :type obj: obj
    :param test_station: Test station used to search for aliases
    :param attributes: References to obj's attributes to check
    :return: tuple of (vars, station_aliases) where vars is dictionary of name:value pairs of all JSON compatible attr,
             and station_aliases is dictionary of alias: ref_name for all TestStationObjects
    """
    station_aliases = {}  # List of ref_name's of all required test station objects in burst
    # Format is {alias: ref_name}
    vars = {}  # List of variables used by burst, JSON compatible
    # Format is {name: value}

    for attr_name in attributes:
        try:
            if attr_name in ['result', 'log']:  # TEMPORARY
                continue
            attr = getattr(obj, attr_name)
            # If attr exists, need to see if its 1. part of test_station 2. variable 3. illegal type (function, cls)
            if isinstance(attr, TestStationObject):
                if attr.ref_name in test_station:  # In test station, create alias
                    station_aliases[attr_name] = attr.path  # attr.ref_name
                elif attr.ref_name != test_station.ref_name:  # Ignore top level
                    raise Exception("Unknown TestStationObject %s, not part of given TestStation" % attr.ref_name)
            elif isinstance(attr, PyroReceiver):
                if hasattr(attr, 'class_type') and attr.class_type.slpit('.')[-1] in BURST_ENABLED_CONTROLLERS:
                    station_aliases[attr_name] = attr.ref_name
            # TODO: VALTECH-591 Consolidate these conditionals with more generic path, or change aliasing relative to
            #       'self' local and not test_station
            elif isinstance(attr, (Register, Field)):
                station_aliases[attr_name] = attr.component.path + '.' + attr.path
            elif isinstance(attr, Block):
                station_aliases[attr_name] = attr.container.path + '.' + attr.name
            else:
                json.dumps(attr)
                vars[attr_name] = attr
        except AttributeError:  # Doesn't exist yet, keep as None for now
            vars[attr_name] = None
        except TypeError:  # Not JSON serializable
            raise TypeError("Cannot access %s in burst, has to be JSON compatible or part of test station." % attr_name)

    return vars, station_aliases

def parse_field_writes(lines, globals, locals):
    """
    Parses line and looks for all expressoins of form: something.value = something. Creates dictionary where the keys
    are the LHS and the values are RHS.

    :param lines: Code, list of strings
    :type lines: list
    :return: Dictionary contianing expressions
    :rtype: dict
    """
    setters = {}
    for i, line in enumerate(lines):
        if not line.strip():
            continue
        # Search for any "Something = Something_else"
        m = re.search(r'(.+?)\.value\s*=\s*(.+)', line)
        if m is None:
            msg = "[WriteFields] Invalid line format: Must be field.value = Something. Aborting\n%s" % line
            return i, msg
        field_exp, value_exp = m.groups()
        try:
            field = eval(field_exp, globals, locals)
        except Exception as e:
            return i, str(e)
        if type(field) is not Field:
            msg = "[WriteFields] %s is of type '%s', not Field. Aborting" % (field_exp, type(field).__name__)
            return i, msg
        try:
            value = eval(value_exp, globals, locals)
        except Exception as e:
            return i, str(e)
        if type(value) is not int:
            msg = "[WriteFields] %s is of type '%s', not int. Aborting" % (value_exp, type(value).__name__)
            return i, msg
        setters[field] = value
    return setters, ''

def parse_field_reads(lines, globals, locals):
    """
    Parses lines and looks for all expressions that end in '.value'. Returns a list containing all expressions in
    string form

    :param lines: list of strings, lines of code
    :type lines: list
    :return: List of strings contianing just field expressions
    :rtype: list
    """
    field_list = []
    for i, line in enumerate(lines):
        if not line.strip():
            continue
        m = re.search(r'(.+)?\.value', line)
        if m is None:
            msg = "[ReadFields] Invalid line format: Must be field.value, Aborting\n%s" % line
            return i, msg
        field_exp = m.group(1)
        try:
            field = eval(field_exp, globals, locals)
        except Exception as e:
            return i, str(e)
        if type(field) is not Field:
            msg = "[WriteFields] %s is of type '%s', not Field. Aborting" % (field_exp, type(field).__name__)
            return i, msg
        field_list.append(field)
    return field_list, ''
