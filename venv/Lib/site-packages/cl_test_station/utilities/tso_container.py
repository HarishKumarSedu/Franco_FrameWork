from typing import *

from cl_test_station.test_station_object import TestStationObject, TsoField


class TsoContainer(TestStationObject):

    def __init__(self, *args, container=None, resource_type=None, protect_resources=True, generate_stubs=True, **kwargs):
        object.__setattr__(self, 'protect_resources', protect_resources)  # Used to prevent setattr overwriting resources
        object.__setattr__(self, '_all_resources', {})  # Dictionary for tracking all resources
        super().__init__(*args, container=container, **kwargs)
        self._pyi_generated = False
        self.has_dynamic_attrs = True
        if self.container is not None:
            if self not in self.container.resources.values():
                self.container.resources[self.ref_name] = self
        self.resource_type = resource_type  # Force single type for all resources
        self.generate_stubs = generate_stubs

    # ----- Internals ----- #

    def __contains__(self, item):
        return item in self._all_resources.keys() or item in self._all_resources.values()

    def __len__(self):
        return len(self._all_resources)

    def __bool__(self):
        return bool(self._all_resources)

    def __getitem__(self, item):
        return self._all_resources[item]

    def __setitem__(self, key, value):
        self.add_resource(value, ref_name=key, force=True)

    def __repr__(self):
        rec_str = ''
        for key in self._all_resources.keys():
            if len(rec_str) + len(key) + 2 > 70:
                rec_str += ', ...'
                break
            rec_str += f', {key}'
        return f'{self.__class__.__name__}(size={len(self)}, resources=[{rec_str[2:]}])'

    def __setattr__(self, key, value):
        if self.protect_resources and key in self._all_resources:
            raise PermissionError(f"Cannot set {key}={value}, {key} is a protected resource")
        object.__setattr__(self, key, value)

    # ----- Resource management ----- #

    def add_resource(self, resource: Any, ref_name: str = None, force: bool = False):
        """
        Registers an object with this container. If resource is a TSO, it will be added to self.resources

        :param resource: Object to register
        :type resource: Any
        :return: None
        :rtype: None
        """
        # Warn user if a resource is going to be added after stub files have been generated
        if self._pyi_generated:
            self.log.warning(f"Stub files have already been generated; {resource} might not be included.")
        # Check for specific type if one was given
        if self.resource_type is not None and not isinstance(resource, self.resource_type):
            raise TypeError(f"This container can only accept resources of type {self.resource_type}, received: {type(resource)}")

        if isinstance(resource, TestStationObject):  # TSO, add to resources
            if ref_name is None:
                ref_name = resource.ref_name
            self.resources[ref_name] = resource
            resource.container = self
        elif ref_name is None:  # Normal object, add to internal dict
            ref_name = f'{resource.__class__.__name__}_{id(resource)}'
        # Check ref_name for uniqueness
        old_value = self.protect_resources
        if ref_name in self._all_resources:
            if force:
                self.log.dev(f"{ref_name} already exists in container, overwriting entry")
            else:
                raise KeyError(f"'{ref_name}' already exists in container, either choose a new the name or set force=True")
        # Register resource and setattr
        if force:
            self.protect_resources = False
        self._all_resources[ref_name] = resource
        setattr(self, ref_name, resource)
        self.protect_resources = old_value

    def dump_resources(self):
        self.log.info("Dumping all resources:")
        for ref_name, obj in self.items():
            self.log.print(f"{ref_name}: {obj}")

    def gen_pyi(self, *args, indent: int = 0, **kwargs) -> Tuple[str, Set[Tuple[str, str]]]:
        pyi_str, imports = super().gen_pyi(*args, indent=indent, **kwargs)
        tab = '    '
        pyi_contents = [pyi_str, tab*(indent+1), '# Resources (may be duplicates)', '\n']
        if self.generate_stubs:
            for ref_name, obj in self._all_resources.items():
                if isinstance(obj, TestStationObject):
                    continue
                if hasattr(obj, 'gen_pyi'):
                    pyi_contents.extend(obj.gen_pyi(indent=indent+1))
                    imports.add((obj.__class__.__name__, obj.__class__.__module__))
                elif hasattr(type(obj), '__name__'):
                    pyi_contents.extend([tab*(indent+1), ref_name, ':', type(obj).__name__, '\n'])
                    if hasattr(obj.__class__, '__name__') and hasattr(obj.__class__, '__module__'):
                        imports.add((obj.__class__.__name__, obj.__class__.__module__))
            self._pyi_generated = True
        return ''.join(pyi_contents), imports

    # ----- Dictionary-like functions ----- #

    def items(self):
        return self._all_resources.items()

    def keys(self):
        return self._all_resources.keys()

    def values(self):
        return self._all_resources.values()

    def pop(self, key: str):
        if key not in self._all_resources:
            raise KeyError(key)
        value = self._all_resources.pop(key)
        delattr(self, key)
        return value
