import csv
import datetime
import os
import re
import subprocess
import time
import traceback
from enum import Enum
import pyperclip
import wx
import wx.grid
import wx.lib.inspection
import wx.dataview as dv
from cl_test_station.components.component.component import Component, Register, Block, Field
from .data_view_model import RegMapModel


class KeyEventType(Enum):
    ctrl_c = 0          # copy item name
    ctrl_s = 1          # read item value
    ctrl_a = 2          # read all item values
    ctrl_t = 3          # collapse all items
    ctrl_e = 4          # expand all items
    ctrl_f = 5          # key focus to the search box
    ctrl_o = 13         # open component's reg map directory
    ctrl_shift_r = 6    # call current component reset method
    down_arrow = 7      # change focus to search results if searchbox has focus
    esc = 8             # hide search results and give the reg map focus
    enter = 9
    ctrl_up = 10        # decrement component selection
    ctrl_down = 11      # increment component selection
    ctrl_shift_c = 12   # copy self.comp_name.field/reg_name.value
    ctrl_shift_w = 14  # toggle minimal/full view
    ctrl_x = 15  # copy item setter


class RegMapGui(wx.Frame):
    def __init__(self, test_station, caller):
        super().__init__(parent=None, title='Python Register Map', style=wx.DEFAULT_FRAME_STYLE)  # & (~wx.MAXIMIZE_BOX))
        self.panel = wx.Panel(self)

        # wx.lib.inspection.InspectionTool().Show()  # todo for debugging event handling

        self.caller = caller

        self.search_limit = 13  # limits the search result to increase speed. Override to change
        self.is_mini_mode = False  # to keep track of window state for ctrl_shift_w
        self.print_writes = False  # determines if writes are printed to the console
        self.current_reg_obj = None  # keeps track of the current register being edited for write_optmized
        self.write_optimized = False
        # Define common colors in the colour database so the GUI and Model use the same colors
        wx.TheColourDatabase.AddColour('NON_DEFAULT', wx.Colour(0x00f5d65d))
        wx.TheColourDatabase.AddColour('INTERNAL', wx.Colour(0x008F78B3))
        wx.TheColourDatabase.AddColour('PENDING', wx.TheColourDatabase.Find('GOLDENROD'))
        wx.TheColourDatabase.AddColour('ERROR', wx.Colour(255, 255, 255, 255))

        # define a menu bar
        self.menu_bar = wx.MenuBar()
        self.status_bar = self.CreateStatusBar(1)
        self.settings_menu = wx.Menu()  # Settings menu
        self.write_optimized_menu_item = wx.MenuItem(self.settings_menu, text='Write fields optimized', kind=wx.ITEM_CHECK, id=wx.ID_ANY)
        self.settings_menu.Append(self.write_optimized_menu_item)
        self.print_writes_menu_item = wx.MenuItem(self.settings_menu, text='Print writes', kind=wx.ITEM_CHECK, id=wx.ID_ANY)
        self.settings_menu.Append(self.print_writes_menu_item)
        self.verify_writes = wx.MenuItem(self.settings_menu, text='Verify writes', kind=wx.ITEM_CHECK, id=wx.ID_ANY)
        self.settings_menu.Append(self.verify_writes)
        self.settings_menu.AppendSeparator()
        self.host_controller_menu = wx.Menu()  # menu to select the active controller
        self.settings_menu.Append(wx.ID_ANY, "Host controller", self.host_controller_menu)  # AppendMenu
        self.settings_menu.AppendSeparator()
        self.interface_menu = wx.Menu()  # menu
        self.settings_menu.Append(wx.ID_ANY, 'Interface', self.interface_menu)  # AppendMenu
        # Actions menu
        self.actions_menu = wx.Menu()
        self.export_dump = wx.MenuItem(self.actions_menu, text='Export register dump to Desktop', id=wx.ID_ANY)
        self.actions_menu.Append(self.export_dump)
        self.export_selected_dump = wx.MenuItem(self.actions_menu, text='Export register dump to Desktop - Selected Items', id=wx.ID_ANY)
        self.actions_menu.Append(self.export_selected_dump)
        # Help menu - todo - temporary
        self.help_menu = wx.Menu()
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+S - Read selected item(s)', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+A - Read all Registers', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Spacebar - Edit item value, Enter to write value, Esc to cancel write', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Right Arrow - Expand item', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Left Arrow - Collapse item', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+E - Expand all', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+T - Collapse all', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+F - Search for name or address', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+O - Open reg map directory', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+Shift+R - Reset Component', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+C - Copy item value getter', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+X - Copy item value setter', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+Shift+C - Copy item name', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+Up Arrow - Switch to previous Component', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+Down Arrow - Switch to next Component', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Ctrl+Shift+W - Toggle Mini/Normal View', id=wx.ID_ANY)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Internal or key-locked field', id=wx.ID_ANY)
        dummy.SetTextColour(wx.TheColourDatabase.Find('INTERNAL'))
        font = dummy.GetFont()
        font.MakeBold()
        font.MakeItalic()
        dummy.SetFont(font)
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Non-default value', id=wx.ID_ANY)
        dummy.SetBackgroundColour(wx.TheColourDatabase.Find('NON_DEFAULT'))
        self.help_menu.Append(dummy)
        dummy = wx.MenuItem(self.help_menu, text='Pending write value', id=wx.ID_ANY)
        dummy.SetBackgroundColour(wx.TheColourDatabase.Find('PENDING'))
        self.help_menu.Append(dummy)
        # Add the menus to the menu bar
        self.menu_bar.Append(self.settings_menu, 'Settings')
        self.menu_bar.Append(self.actions_menu, 'Actions')
        self.menu_bar.Append(self.help_menu, 'Help')
        self.SetMenuBar(self.menu_bar)
        self.menu_bar.Bind(wx.EVT_MENU, self.menu_event)

        # get all component names
        self.component_list = test_station.find_all(Component)
        self.component_dict = {}
        for item in self.component_list:  # make a list of all component names
            self.component_dict[item[0]] = item[1]

        # create a sizer to organize the gui elements
        self.panel_sizer = wx.BoxSizer(wx.VERTICAL)

        self.reg_map_dict = {}
        for comp in self.component_dict.keys():  # create a dvc for the reg map of each component
            view = dv.DataViewCtrl(self.panel, style=wx.BORDER_THEME | dv.DV_ROW_LINES | dv.DV_VERT_RULES | dv.DV_MULTIPLE)
            # bind events
            view.Bind(wx.dataview.EVT_DATAVIEW_SELECTION_CHANGED, self.change_selection)
            view.Bind(wx.dataview.EVT_DATAVIEW_ITEM_EDITING_DONE, self.edit_item)
            # create columns and append to the view
            tr = dv.DataViewTextRenderer()
            tr_edit = dv.DataViewTextRenderer(mode=wx.dataview.DATAVIEW_CELL_EDITABLE)  # value column
            c0 = dv.DataViewColumn("NAME", tr, 0, width=400)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c0)
            c1 = dv.DataViewColumn("ADDR", tr, 1, width=80)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c1)
            c2 = dv.DataViewColumn("LENGTH", tr, 2, width=80)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c2)
            c3 = dv.DataViewColumn("BITS", tr, 3, width=80)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c3)
            c4 = dv.DataViewColumn("ACCESS", tr, 4, width=80)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c4)
            c5 = dv.DataViewColumn("DEFAULT", tr, 5, width=80)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c5)
            c6 = dv.DataViewColumn("VALUE", tr_edit, 6, width=80)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c6)
            c7 = dv.DataViewColumn("VOLATILE", tr, 7, width=80)  # , flags=wx.dataview.DATAVIEW_COL_SORTABLE)
            view.AppendColumn(c7)
            model = RegMapModel(self.component_dict[comp])  # create a model for the component's reg map
            view.AssociateModel(model)
            model.DecRef()
            view.SetMinSize(wx.Size(1000, 300))  # 300
            view.Show(False)  # hide by default - we'll show it when the component selector is changed
            self.reg_map_dict[comp] = view  # add the view to the dict

        # dropdown to select component
        self.component_selector = wx.ComboBox(self.panel, choices=list(self.component_dict.keys()), style=wx.CB_READONLY)
        self.component_selector.SetSelection(0)
        self.change_component(None)  # init the reg map to the first component in the list
        self.component_selector.Bind(wx.EVT_COMBOBOX, self.change_component)

        # add a search control and listbox for register map searching
        # just using a searchbox because it looks nice - the search functionality is too basic though
        # we'll use regex to implement searching
        self.search_box = wx.SearchCtrl(self.panel)
        self.search_box.SetDescriptiveText(f'Search for a items by name or "0x..." for addresses.')
        self.search_box.Bind(wx.EVT_TEXT, self.do_search)
        self.search_box.Bind(wx.EVT_SET_FOCUS, self.show_results_window)
        self.search_box.Bind(wx.EVT_KILL_FOCUS, self.show_results_window)
        self.search_results = wx.ListBox(self.panel)
        self.search_results.Bind(wx.EVT_KILL_FOCUS, self.show_results_window)
        self.search_results.Bind(wx.EVT_LISTBOX_DCLICK, self.get_search_result)  # wx.EVT_LISTBOX originally
        self.search_results.Show(False)

        # create the field description box
        self.field_description = wx.TextCtrl(self.panel, style=wx.TE_MULTILINE | wx.TE_BESTWRAP | wx.TE_READONLY)
        self.field_description.SetMinSize(wx.Size(-1, 150))  # so it doesn't get squashed

        # bind event handlers
        self.panel.Bind(wx.EVT_CHAR_HOOK, self.get_key_press)

        # add elements to the sizer
        # proportion of 1 enables the item to fill vertically
        # wx.EXPAND flag enables the item to expand horizontally
        self.panel_sizer.Add(self.component_selector, 0, wx.EXPAND)
        self.panel_sizer.Add(self.search_box, 0, wx.EXPAND)  # | wx.RIGHT)
        self.panel_sizer.Add(self.search_results, 1, wx.EXPAND)
        for key in self.reg_map_dict.keys():  # add each map to the sizer
            self.panel_sizer.Add(self.reg_map_dict[key], 1, wx.EXPAND)
        self.panel_sizer.Add(self.field_description, 0, wx.EXPAND)  # | wx.BOTTOM)

        self.panel.SetSizer(self.panel_sizer)
        self.set_frame_size(is_mini_mode=False)
        self.Layout()
        self.Show()

    def edit_item(self, event):  # this handles writing regs and fields
        if not event.IsEditCancelled():  # user didn't cancel the edit?
            item = self.model.ItemToObject(event.Item)
            value = self.model.value_to_int(event.Value)
            if not self.write(item, value):  # did the write fail?
                event.Veto()  # cancel the updates to the GUI so we don't give a false ipression that the write was successful

    def menu_event(self, event):
        if event.GetEventObject().FindItem(event.GetId())[1] == self.host_controller_menu:  # user selected a host controller
            print(f'Host Controller: {self.menu_bar.GetLabel(event.GetId())}')
            self.current_component.active_controller = self.menu_bar.GetLabel(event.GetId())
        elif event.GetEventObject().FindItem(event.GetId())[1] == self.interface_menu:  # user selected an interface
            print(f'Interface: {self.menu_bar.GetLabel(event.GetId())}')
            self.current_component.active_interface = self.menu_bar.GetLabel(event.GetId())
        elif event.GetEventObject().FindItem(event.GetId())[0] == self.verify_writes:  # user selected verify writes
            print(f'Verify Writes: {event.GetEventObject().FindItem(event.GetId())[0].IsChecked()}')
            self.current_component.verify_writes = event.GetEventObject().FindItem(event.GetId())[0].IsChecked()
        elif event.GetEventObject().FindItem(event.GetId())[0] == self.print_writes_menu_item:
            self.print_writes = event.GetEventObject().FindItem(event.GetId())[0].IsChecked()
        elif event.GetEventObject().FindItem(event.GetId())[0] == self.write_optimized_menu_item:
            if not event.GetEventObject().FindItem(event.GetId())[0].IsChecked():  # user unchecked
                cancelled = False
                for k, v in self.model.pending_value_dict.items():
                    if isinstance(k, Register):  # prompt the user if there are pending writes
                        cancelled = self._warn_pending_writes(reg_object=k)
                        break
                if cancelled:
                    self.write_optimized_menu_item.Check(True)  # keep it enabled
                    self.write_optimized = True
                else:
                    self.model.ClearPendingValueChanges()
                    self.write_optimized = False
            else:  # user checked
                self.write_optimized = event.GetEventObject().FindItem(event.GetId())[0].IsChecked()
        elif event.GetEventObject().FindItem(event.GetId())[0] == self.export_dump:  # user selected dump
            regs = []
            for block in list(self.current_component.get_blocks()):  # todo safe to assume all comps have blocks?
                regs.extend(list(self.get_register_dict(block).keys()))  # make a list of all regs
            self.dump_regs_to_file(regs)
        elif event.GetEventObject().FindItem(event.GetId())[0] == self.export_selected_dump:  # user selected dump
            selections = self.get_selected_objects()
            regs = []
            for obj in selections:  # make a list of all selected items' registers
                regs.extend(list(self.get_register_dict(obj).keys()))
            regs = list(dict.fromkeys(regs))  # remove duplicate registers from the list
            if regs:  # list not empty
                self.dump_regs_to_file(regs)
        else:
            # print(f'Menu: {self.menu_bar.GetLabel(event.GetId())}')  # for debug
            pass

    def dump_regs_to_file(self, regs):
        # todo
        # children = []
        # self.model.GetChildren(None, children)  # all blocks
        self.set_cursor_busy(True)
        desktop = os.path.expanduser("~/Desktop")
        t = datetime.datetime.now()
        timestamp = t.strftime("%I_%M_%S_%p")
        path = desktop + '\\' + timestamp + '_' + self.current_component.ref_name + '_dump.csv'  # append the time to make the name unique
        with open(path, 'w', newline='') as report:  # create the report
            dump = csv.writer(report, delimiter=',', quotechar='\"')
            dump.writerow(['FIELD NAME', 'ACCESS', 'DEFAULT', 'VALUE', 'IS_DEFAULT'])
            for reg in regs:
                if reg.readable:
                    self.read(reg)  # read the register so the gui reflects the current state
                field_list = list(reg.get_fields())
                for field in field_list:
                    name = field.path
                    default = self.model.int_to_value(field.reset_value)
                    access = field.access.name
                    if field.readable:
                        value = self.model.int_to_value(self.model.value_to_int(self.model.GetValue(self.model.ObjectToItem(field), 6)))
                    else:
                        value = '0x0'
                    is_default = bool(value == default)
                    dump.writerow([name, access, default, value, is_default])
        self.set_cursor_busy(False)

    def change_component(self, event):
        self.current_component = self.component_dict[self.component_selector.GetValue()]
        # update the controller dropdown
        self.host_controller_dict = self.current_component.host_controllers
        self.host_controller_names = list(self.host_controller_dict.keys())

        # update the interface dropdown
        self.interface_dict = self.current_component.interfaces
        self.interface_names = list(self.interface_dict.keys())

        # update the menus
        self.refresh_controller_menu()
        self.refresh_interface_menu()
        self.verify_writes.Check(self.current_component.verify_writes)

        # update the reg map dvc and it's model
        self.model = self.reg_map_dict[self.component_list[self.component_selector.GetSelection()][0]].Model
        self.current_reg_map = self.reg_map_dict[self.component_list[self.component_selector.GetSelection()][0]]
        self.update_field_name_list()
        self.update_reg_map()

    def refresh_controller_menu(self):
        # populate the host controller menu
        for item in self.host_controller_menu.GetMenuItems():  # clear the menu
            self.host_controller_menu.DestroyItem(item)
        for name in self.host_controller_names:
            self.host_controller_menu.AppendRadioItem(wx.ID_ANY, name)
        # check the item for the current host controller
        self.host_controller_menu.Check(self.host_controller_menu.FindItem(self.current_component.active_controller.ref_name), check=True)

    def refresh_interface_menu(self):
        # populate the interface menu
        for item in self.interface_menu.GetMenuItems():  # clear the menu
            self.interface_menu.DestroyItem(item)
        for name in self.interface_names:
            self.interface_menu.AppendRadioItem(wx.ID_ANY, name)
        # check the item for the current interface
        self.interface_menu.Check(self.interface_menu.FindItem(self.current_component.active_interface.ref_name), check=True)

    def get_search_result(self, event):
        text = self.search_results.GetString(self.search_results.GetSelection())
        selection = self.current_component
        if 'show all results...' in text:  # user wants to see all results
            self.do_search(None, show_all_results=True)
        else:
            self.search_results.Show(False)
            self.search_results.GetContainingSizer().Layout()
            if 'test_station' in text:  # test station object
                self.component_selector.SetValue(text)
                self.change_component(None)
            else:
                if text[:2] == '0x':  # user searched an address
                    selection = [r for r in self.current_component.get_all_registers() if r.addr == int(text, 16)][0]  # get reg by addr
                else:  # user searched a name
                    for obj in text.split('.'):  # block, reg, or field name
                        selection = selection.__getattr__(obj)
                self.current_reg_map.UnselectAll()
                self.current_reg_map.Select(self.model.ObjectToItem(selection))
                self.current_reg_map.EnsureVisible(self.model.ObjectToItem(selection))
                self.change_selection(event)  # keep track of the newly-selected object so we can cancel any pending writes - even if write optimized is disabled
            self.current_reg_map.SetFocus()
            self.update_description(None)

    def show_results_window(self, event):
        if event.EventType == wx.EVT_SET_FOCUS.typeId:  # user is focused on search box
            self.search_results.Show(True)
            self.search_results.GetContainingSizer().Layout()
        if event.EventType == wx.EVT_KILL_FOCUS.typeId:  # user clicked away from search box
            if isinstance(event.Window, wx.ListBox):  # user clicked to search results
                self.search_results.Show(True)
                self.search_results.GetContainingSizer().Layout()
            elif isinstance(event.Window, wx.TextCtrl):  # user went from results back to search box
                self.search_results.Show(True)
                self.search_results.GetContainingSizer().Layout()
            else:  # user clicked off the search and didn't go to the results
                self.search_results.Show(False)
                self.search_results.GetContainingSizer().Layout()
                self.search_box.SetValue('')
        event.Skip()

    def do_search(self, event, show_all_results=False):
        # https://stackoverflow.com/questions/3640359/regular-expressions-search-in-list/39593126
        is_addr = False
        if event:
            is_addr = event.String[:2] == '0x'
        elif self.search_results.GetItems()[0][:2] == '0x':  # user clicked "show all results..." after searching an address
            is_addr = True
        self.set_cursor_busy(busy=True)
        if is_addr:  # user searched an address
            string = self.search_box.GetValue()[:2]+self.search_box.GetValue()[2:].upper()  # get the text entered by the user
            addr_search = re.compile(string)
            addr_results = filter(addr_search.search, self.addresses)  # get the matching addresses
            addr_results = list(addr_results)
            if len(addr_results) > self.search_limit and not show_all_results:    # limit to speed up the search
                addr_subset = addr_results[0: self.search_limit] + ['show all results...']
                self.search_results.SetItems(addr_subset)
            else:
                self.search_results.SetItems(addr_results)  # show all items
                if show_all_results:
                    self.search_results.SetSelection(self.search_limit-1)  # so the user doesn't have to scroll back down
        else:  # user searched a name
            r = re.compile(self.search_box.GetValue(), re.IGNORECASE)
            filter_results = filter(r.search, self.names + self.component_selector.GetItems())
            items = list(filter_results)
            if len(items) > self.search_limit and not show_all_results:    # limit to speed up the search
                items_subset = items[0: self.search_limit] + ['show all results...']
                self.search_results.SetItems(items_subset)
            else:
                self.search_results.SetItems(items)  # show all items
                if show_all_results:
                    self.search_results.SetSelection(self.search_limit-1)  # so the user doesn't have to scroll back down
        self.set_cursor_busy(busy=False)

    def update_field_name_list(self):
        self.search_list = []  # list of names that we'll use to auto complete
        blocks = []
        regs = []
        fields = []
        self.names = []
        self.addresses = []
        self.model.GetChildren(item=None, children=blocks)  # get parents (blocks)
        for block in blocks:  # get the item's name and add to the list
            self.model.GetChildren(item=block, children=regs)
            self.names.append(self.model.ItemToObject(block).name)
        for reg in regs:
            self.model.GetChildren(item=reg, children=fields)
            self.names.append(self.model.ItemToObject(reg).path)
            self.addresses.append(self.model.GetValue(reg, 1))
        for field in fields:
            self.names.append(self.model.ItemToObject(field).path)
        self.reg_map_children = fields+regs+blocks  # child first then up the heirarchy

    def update_reg_map(self):
        for map in self.reg_map_dict.keys():  # hide all the maps just to be sure
            self.reg_map_dict[map].Show(False)
        self.current_reg_map.Show(True)
        self.panel_sizer.Layout()

    def get_key_press(self, event):
        # print(event.GetKeyCode())  # for debug
        # print(event.ShiftDown())
        # print(event.ControlDown())
        if self.search_box.HasFocus() and event.GetKeyCode() == 317:
            self.handle_event(event, KeyEventType.down_arrow)
            event.Skip()
        elif event.ControlDown() and event.GetKeyCode() == 315:
            self.handle_event(event, KeyEventType.ctrl_up)
            event.Skip()
        elif event.ControlDown() and event.GetKeyCode() == 317:
            self.handle_event(event, KeyEventType.ctrl_down)
            event.Skip()
        elif self.search_results.HasFocus() and event.GetKeyCode() == 13:
            self.handle_event(event, KeyEventType.enter)
            event.Skip()
        elif event.GetKeyCode() == 27:
            self.handle_event(event, KeyEventType.esc)
            event.Skip()
        elif event.ControlDown() and event.GetKeyCode() == 69:
            self.handle_event(event, KeyEventType.ctrl_e)
            event.Skip()
        elif event.ControlDown() and event.GetKeyCode() == 70:
            self.handle_event(event, KeyEventType.ctrl_f)
            event.Skip()
        elif event.ControlDown() and event.GetKeyCode() == 84:
            self.handle_event(event, KeyEventType.ctrl_t)
            event.Skip()
        elif event.ControlDown() and event.GetKeyCode() == 65:
            self.handle_event(event, KeyEventType.ctrl_a)
            event.Skip()
        elif event.ControlDown() and event.GetKeyCode() == 79:
            self.handle_event(event, KeyEventType.ctrl_o)
            event.Skip()
        elif event.ControlDown() and not event.ShiftDown() and event.GetKeyCode() == 67:
            self.handle_event(event, KeyEventType.ctrl_c)
        elif event.ControlDown() and not event.ShiftDown() and event.GetKeyCode() == 88:
            self.handle_event(event, KeyEventType.ctrl_x)
        elif event.ControlDown() and event.ShiftDown() and event.GetKeyCode() == 67:
            self.handle_event(event, KeyEventType.ctrl_shift_c)
        elif event.ControlDown() and event.GetKeyCode() == 83:
            self.handle_event(event, KeyEventType.ctrl_s)
            event.Skip()
        elif event.ControlDown() and event.ShiftDown() and event.GetKeyCode() == 82:
            self.handle_event(event, KeyEventType.ctrl_shift_r)
            event.Skip()
        elif event.ControlDown() and event.ShiftDown() and event.GetKeyCode() == 87:
            self.handle_event(event, KeyEventType.ctrl_shift_w)
            event.Skip()
        else:
            event.Skip()

    def change_selection(self, event):
        selection = self.get_selected_objects()
        self.update_description(event)
        old_reg = self.current_reg_obj
        new_reg = None
        reg_changed = False
        if len(selection) == 0:  # the selection was cleared - for example, they did a "collapse all"
            pass
        elif len(selection) > 1:  # user selected multiple items
            reg = None
            items_in_same_reg = True
            for i, sel in enumerate(selection):  # check to see if all selected items belong to the same register
                if isinstance(sel, Register):
                    if i == 0:
                        reg = sel
                    elif sel != reg:  # selected items across multiple regs
                        items_in_same_reg = False
                if isinstance(sel, Field):
                    if i == 0:
                        reg = sel.container
                    elif sel.container != reg:  # selected items across multiple regs
                        items_in_same_reg = False
            if not items_in_same_reg:  # user selected items from multiple registers
                reg_changed = True
            elif items_in_same_reg and reg != self.current_reg_obj:  # user selected multiple items in a different register
                new_reg = reg
                reg_changed = True
            else:  # user selected the same reg - don't care
                reg_changed = False
        else:  # user only selected a single item
            selection = selection[0]
            if not isinstance(selection, Register) and not isinstance(selection, Field):  # user clicks something which isn't a field or reg
                new_reg = None
                reg_changed = True
            elif isinstance(selection, Register) and selection != self.current_reg_obj:  # user clicks a different register
                new_reg = selection
                reg_changed = True
            elif isinstance(selection, Field) and selection.container != self.current_reg_obj:  # user clicks a field which belongs to a different register
                new_reg = selection.container
                reg_changed = True
            else:  # user selects multiple items and they all belong to the current register - do nothing
                pass

        if reg_changed:
            canceled = False
            if old_reg is not None:  # prompt if it has pending changes
                if self.write_optimized:
                    if old_reg in self.reg_map_dict[old_reg.component.path].Model.pending_value_dict.keys():
                        canceled = self._warn_pending_writes(old_reg)
            if not canceled:
                if old_reg is not None:
                    if self.write_optimized:
                        self.reg_map_dict[old_reg.component.path].Model.ClearPendingValueChanges()
                self.current_reg_obj = new_reg  # update the selected reg

    def _warn_pending_writes(self, reg_object: Register):
        # This prompts the user to let them know they are about to leave a register with pending writes
        dialog = wx.MessageDialog(self.panel, f'{reg_object.component.ref_name} {reg_object.path} has pending writes. \n\nSelect OK to discard pending writes. \n\nSelect CANCEL if you wish to keep the pending writes and continue editing the register.', 'Warning', wx.OK | wx.CANCEL | wx.ICON_WARNING | wx.CANCEL_DEFAULT)
        result = dialog.ShowModal()
        canceled = False
        if result == wx.ID_CANCEL:
            canceled = True
        elif result == wx.ID_OK:
            canceled = False
        else:
            raise ValueError(f'Unexpected wx ID: {result}.')
        return canceled

    def update_description(self, event):
        try:  # handle the benign error that occurs when the user collapses all when a field is selected
            selection = self.get_selected_objects()[0]
            if isinstance(selection, Field):  # only update if field is selected
                self.field_description.SetValue(selection.description)
            else:
                self.field_description.SetValue('')
            if event is not None:
                event.Skip()
        except IndexError:
            self.field_description.SetValue('')
            pass

    def get_selected_objects(self):
        try:
            obj_list = []
            for obj in self.current_reg_map.GetSelections():
                obj_list.append(self.model.ItemToObject(obj))
            return obj_list
        except Exception:
            self.indicate_error()
            print(traceback.format_exc())
            return None

    @staticmethod
    def get_register_dict(obj):
        reg_dict = {}
        if isinstance(obj, Block):  # if block
            regs = obj.get_registers()  # get regs
            for reg in regs:  # get each reg's fields
                reg_dict[reg] = list(reg.get_fields())
        if isinstance(obj, Field):  # if field
            reg = obj.container  # get reg
            reg_dict[reg] = list(reg.get_fields())  # get reg's fields
        elif isinstance(obj, Register):  # if reg
            reg = obj  # get reg
            reg_dict[reg] = list(reg.get_fields())  # get reg's fields
        return reg_dict

    def get_object_values(self, obj):
        # todo - if this is type block, reg dict will have more than one key, so we cannot return inside the loop
        reg_dict = self.get_register_dict(obj)
        for reg in reg_dict.keys():
            try:  # in case we get an error
                reg_item = self.model.ObjectToItem(reg)
                field_list = []
                for field in reg_dict[reg]:
                    field_list.append(field)
                field_value_dict = reg.component.read_fields_optimized(field_list)
                reg_val = 0  # todo - it would be better if read_optimized would return the reg value so we don't have to calculate it here
                for field, value in [(field, field_value_dict[field]) for field in field_value_dict.keys()]:
                    field_item = self.model.ObjectToItem(field)
                    self.model.ChangeValue(str(value), field_item, 6)  # update the model with the field's calculated value
                    reg_val = reg_val | ((value << field.bit_offset) & field.mask)
                self.model.ChangeValue(str(reg_val), reg_item, 6)  # update the model with the reg's calculated value
                return reg_val, field_value_dict
            except Exception:
                self.indicate_error()
                print(traceback.format_exc())
                return None

    @staticmethod
    def object_to_reg_list(obj):
        if isinstance(obj, Block):
            regs = obj.get_registers()
        elif isinstance(obj, Register):
            regs = [obj]
        elif isinstance(obj, Field):
            regs = [obj.container]
        else:
            raise TypeError(f'Type {type(obj)} is not supported. Must be type Block, Register, or Field.')
        return regs

    def read(self, obj):
        regs = self.object_to_reg_list(obj)
        reg_field_dict = {}
        reg_value_dict = {}
        for reg in regs:
            try:
                fields = list(reg.get_fields())
                field_value_dict = reg.component.read_fields_optimized(fields)
                reg_field_dict[reg] = field_value_dict
                reg_value = 0
                for field in field_value_dict.keys():
                    reg_value = reg_value | ((field_value_dict[field] << field.bit_offset) & field.mask)
                    field_item = self.model.ObjectToItem(field)
                    self.model.ChangeValue(str(field_value_dict[field]), field_item, 6)  # update the field in the model
                reg_value_dict[reg] = reg_value
                reg_item = self.model.ObjectToItem(reg)
                self.model.ChangeValue(str(reg_value), reg_item, 6)  # update the reg in the model
            except Exception:
                self.indicate_error()
                print(traceback.format_exc())
        if self.write_optimized:
            self.model.ClearPendingValueChanges()
        return reg_value_dict, reg_field_dict

    def read_all(self):
        for block in list(self.current_component.get_blocks()):  # todo safe to assume all comps have blocks?
            reg_dict = self.get_register_dict(block)
            for reg in reg_dict.keys():
                if reg.readable:
                    try:
                        self.read(reg)
                    except Exception:  # prevent errors from breaking the loop - read will flash the error status
                        pass

    def write(self, obj, value):
        written = False
        if isinstance(obj, Register):
            reg = obj
            try:
                reg.value = value
                if self.print_writes:
                    if self.write_optimized:
                        # todo - get the fields that had pending values. Also get any fields that were changed as part of the final register write
                        # model - get pending dict
                        # find items of type Field
                        # for each field in the register
                        # is field in pending dict? Does original value equal set value? If not, print, else don't print
                        # if field is not in pending dict, does the original value equal set value? If not, print, else dont print
                        self.model.ChangeValue(str(value), self.model.ObjectToItem(reg), 6)
                        pending_dict = self.model.pending_value_dict
                        field_prints = {}
                        for field in list(reg.get_fields()):  # figure out which fields had value changes
                            # we have to treat pending fields and non-pending fields differently
                            # b/c the model will already be updated with new values if the field is marked pending
                            field_value = (value & field.mask) >> field.bit_offset
                            if field in pending_dict.keys():  # field had a pending value
                                if self.int_to_value(field_value) != pending_dict[field]:  # does value written not equal the original field value?
                                    field_prints[field] = field_value
                            elif field_value != int(self.model.GetValue(self.model.ObjectToItem(field), 6), 16):  # field did not have a pending value
                                # does value written not equal the value currently in the model?
                                field_prints[field] = field_value
                        component = self.get_objects_component(obj)
                        if field_prints:
                            print(f'\n# {component}.{reg.path}.value = {self.int_to_value(value)}')
                            print('write_dict = {')
                            for i, (k, v) in enumerate(field_prints.items()):
                                if i != len(field_prints.keys()) - 1:
                                    print(f'\t{component}.{k.path}: {v},')  # comma
                                else:
                                    print(f'\t{component}.{k.path}: {v}''}')  # no comma
                            print(f'{component}.write_fields_optimized(write_dict)')
                        else:  # dict is empty - this can happen if an unmapped bit is written
                            print(f'{component}.{reg.path}.value = {self.int_to_value(value)}')
                    else:  # we just care about reg values for a reg write
                        print(self.get_objects_component(obj) + f'.{reg.path}' + f'.value = {self.int_to_value(value)}')
                written = True
                # Update the GUI items
                self.model.ChangeValue(str(value), self.model.ObjectToItem(reg), 6)
                for field in list(reg.get_fields()):  # calculate the field values and update the model
                    field_value = (value & field.mask) >> field.bit_offset
                    self.model.ChangeValue(str(field_value), self.model.ObjectToItem(field), 6)
                if self.write_optimized:
                    self.model.CompletePendingValueChanges()
            except Exception:
                self.indicate_error()
                print(traceback.format_exc())
        elif isinstance(obj, Field):  # field write
            # Todo - this could be improved once this feature is added: https://tracker.cirrus.com/browse/PLATDEV-1671
            reg = obj.container
            if not obj.writeable:  # Log error and dont do transaction
                reg.container.log.error('Cannot write %d to field %s: Field not writeable' % (value, obj.path))
                self.indicate_error()
            elif value > obj.max_value:
                reg.container.log.error("Field value %d is larger than maximum value %d" % (value, obj.max_value))
                self.indicate_error()
            elif value < 0:
                reg.container.log.error("Given value %d is negative, it must be >= 0" % value)
                self.indicate_error()
            elif not self.write_optimized:
                # read, modify, write
                reg_value = 0
                if reg.readable:
                    reg_value_dict, reg_field_dict = self.read(reg)  # read
                    reg_value = reg_value_dict[reg]
                    # Force bits (For W1C, W0S, etc)
                    if reg.w1x_mask:
                        reg_value &= ~reg.w1x_mask
                    if reg.w0x_mask:
                        reg_value |= reg.w0x_mask
                    # Set bits for field write
                    masked_reg = reg_value & ~obj.mask
                    new_value = masked_reg | ((value << obj.bit_offset) & obj.mask)
                else:  # WO register, raw write
                    new_value = (value << obj.bit_offset) & obj.mask
                try:
                    reg.value = new_value
                    if self.print_writes:
                        print(self.get_objects_component(obj) + f'.{obj.path}' + f'.value = {self.int_to_value(value)}')
                    written = True
                    # Update the GUI elements
                    self.model.ChangeValue(str(new_value), self.model.ObjectToItem(reg), 6)
                    for field in list(reg.get_fields()):  # calculate the field values and update the model
                        field_value = (new_value & field.mask) >> field.bit_offset
                        self.model.ChangeValue(str(field_value), self.model.ObjectToItem(field), 6)
                except Exception:
                    self.indicate_error()
                    print(traceback.format_exc())
            elif self.write_optimized:
                # read, modify, write using reg value from model
                val = self.model.GetValue(self.model.ObjectToItem(reg), 6)
                if val == self.model.unknown_value:  # user hasn't read the register yet
                    reg_value = 0x0  # Assume reg is 0
                    reg_item = self.model.ObjectToItem(reg)
                    self.model.ChangeValue(str(reg_value), reg_item, 6)  # update the reg in the model
                    for field in reg.fields.values():
                        self.model.ChangeValue(str(0), self.model.ObjectToItem(field), 6)  # update the field in the model
                else:
                    reg_value = self.model.value_to_int(val)
                # Force bits (For W1C, W0S, etc)
                if reg.w1x_mask:
                    reg_value &= ~reg.w1x_mask
                if reg.w0x_mask:
                    reg_value |= reg.w0x_mask
                if reg not in self.model.pending_value_dict.keys():
                    reg_value &= reg.read_mask  # mask out non-readable fields
                    self.model.ChangeValue(str(reg_value), self.model.ObjectToItem(reg), 6)  # change the masked value in the model
                    for k, v in reg.fields.items():  # reset any non-readible fields to 0 so the model is accurate
                        if not v.readable:
                            self.model.ChangeValue(str(0), self.model.ObjectToItem(v), 6)  # change the value to in the model
                # Set bits for field write
                masked_reg = reg_value & ~obj.mask
                new_value = masked_reg | ((value << obj.bit_offset) & obj.mask)  # new reg value which includes the new field value

                # Update the GUI elements
                self.model.ChangePendingValue(str(new_value), self.model.ObjectToItem(reg), 6)
                for field in list(reg.get_fields()):  # calculate the field values and update the model
                    field_value = (new_value & field.mask) >> field.bit_offset
                    if field is obj:  # this is the field the user set
                        # differentiate the field with pending color
                        self.model.ChangePendingValue(str(field_value), self.model.ObjectToItem(field), 6)
                    else:  # all other fields in the register
                        self.model.ChangeValue(str(field_value), self.model.ObjectToItem(field), 6)
        else:
            self.indicate_error()
            raise TypeError(f'Type {type(obj)} is not supported. Must be type Register or Field.')
        return written

    def handle_event(self, event, evt_type: KeyEventType):
        if evt_type is KeyEventType.ctrl_shift_c:
            listing = []
            for obj in self.get_selected_objects():  # handle the multi select case
                if isinstance(obj, Block):
                    selection = obj.name     # Block does not have full_name/path attribute
                else:
                    selection = obj.path
                listing.append(selection)
            listing = "\n".join(listing)
            pyperclip.copy(listing)
        elif evt_type is KeyEventType.ctrl_up:
            if self.component_selector.GetSelection() != 0:  # so we don't go negative
                self.component_selector.SetSelection(self.component_selector.GetSelection()-1)
                self.change_component(None)
                self.current_reg_map.SetFocus()
        elif evt_type is KeyEventType.ctrl_down:
            self.component_selector.SetSelection(self.component_selector.GetSelection()+1)
            self.change_component(None)
            self.current_reg_map.SetFocus()
        elif evt_type is KeyEventType.enter:
            self.get_search_result(None)
        elif evt_type is KeyEventType.ctrl_s:  # read item
            self.set_cursor_busy(busy=True)
            for obj in self.get_selected_objects():
                self.read(obj)
            self.set_cursor_busy(busy=False)
        elif evt_type is KeyEventType.esc:
            self.current_reg_map.SetFocus()
            if self.write_optimized:
                self.model.ClearPendingValueChanges()
        elif evt_type is KeyEventType.ctrl_a:  # read all
            self.set_cursor_busy(busy=True)
            self.read_all()
            self.set_cursor_busy(busy=False)
        elif evt_type is KeyEventType.ctrl_t:  # collapse all
            for child in self.reg_map_children:
                self.current_reg_map.Collapse(child)
        elif evt_type is KeyEventType.ctrl_e:  # expand all
            for child in self.reg_map_children:
                self.current_reg_map.Expand(child)
        elif evt_type is KeyEventType.ctrl_f:
            self.search_box.SetFocus()
        elif evt_type is KeyEventType.ctrl_o:
            subprocess.run([os.path.join(os.getenv('WINDIR'), 'explorer.exe'), self.current_component.register_map_path])
        elif evt_type is KeyEventType.down_arrow:
            self.search_results.SetSelection(0)
            self.search_results.SetFocus()
        elif evt_type is KeyEventType.ctrl_c:  # copy value getter
            listing = []
            if self.field_description.HasFocus():  # user is trying to copy the description text
                pyperclip.copy(self.field_description.GetValue())
            else:
                for obj in self.get_selected_objects():  # handle the multi select case
                    # Find the object's component
                    comp_path = self.get_objects_component(obj)

                    # Build up the value getter/setter for the selected object
                    if isinstance(obj, Block):
                        selection = comp_path + '.' + obj.name
                    elif isinstance(obj, Register) or isinstance(obj, Field):
                        selection = comp_path + '.' + obj.path + f'.value'
                    listing.append(selection)
                listing = "\n".join(listing)
                pyperclip.copy(listing)
        elif evt_type is KeyEventType.ctrl_x:  # copy value setter
            listing = []
            if self.field_description.HasFocus():  # user is trying to copy the description text
                pyperclip.copy(self.field_description.GetValue())
            else:
                for obj in self.get_selected_objects():  # handle the multi select case
                    # Find the object's component
                    comp_path = self.get_objects_component(obj)

                    # Build up the value getter/setter for the selected object
                    if isinstance(obj, Block):
                        selection = comp_path + '.' + obj.name
                    elif isinstance(obj, Register) or isinstance(obj, Field):
                        val = self.model.GetValue(self.model.ObjectToItem(obj), 6)
                        selection = comp_path + '.' + obj.path + f'.value = {val}'
                    listing.append(selection)
                listing = "\n".join(listing)
                pyperclip.copy(listing)
        elif evt_type is KeyEventType.ctrl_shift_r:  # reset
            self.set_cursor_busy(busy=True)
            try:
                self.current_component.reset()
                self.model.Reset()
                for child in self.reg_map_children:
                    self.model.ValueChanged(child, 6)
            except Exception:
                self.indicate_error()
                print(traceback.format_exc())
            self.set_cursor_busy(busy=False)
        elif evt_type is KeyEventType.ctrl_shift_w:
            self.is_mini_mode = not self.is_mini_mode
            for k,v in self.reg_map_dict.items():
                for col in range(1,8):
                    col_obj = v.GetColumn(col)
                    hidden = col_obj.IsHidden()
                    if col == 6: #and not self.is_mini_mode:
                        col_obj.SetWidth(80)
                        col_obj.SetHidden(False)  # never hide the value column
                    else:
                        col_obj.SetHidden(self.is_mini_mode)
            self.set_frame_size(is_mini_mode=self.is_mini_mode)

    def get_objects_component(self, obj):
        # TODO: this code could be simpler. see PLATDEV-956
        # get the reg map object's containing component
        # check if this component is an attribute of the caller (i.e. the base test)
        # if it is, then get the attribute name (i.e. self.dut)
        # otherwise, use the full path (i.e. self.test_station.board.component...)
        # Find the object's component
        if isinstance(obj, Block):
            component = obj.container
        elif isinstance(obj, Register) or isinstance(obj, Field):
            component = obj.component
        # Find the component's attribute name within the caller or it's "path"
        if component in self.caller.__dict__.values():  # the component is an attribute of the caller
            attr_name = (list(self.caller.__dict__.keys())[list(self.caller.__dict__.values()).index(component)])
            comp_path = 'self.' + attr_name
        else:  # the component is not an attribute of the caller
            comp_path = 'self.' + component.path
        return comp_path

    @staticmethod
    def int_to_value(value):
        # converts hex value to the familiar CLIVE format where the digits are upper and the 0x is lower
        value = hex(value)
        return value[:2] + value[2:].upper()

    def set_frame_size(self, is_mini_mode=False):
        if is_mini_mode:  # size width to the miminum width that allows Name and Value columns to fit on screen
            size = self.GetSize()
            self.SetSize(size=[520, size[1]])
            self.SetMaxSize(size=[-1, -1])
            self.SetMinSize(size=[520, 1])
        else:  # reset to default size but keep resizeable
            self.SetMinSize(size=[-1, -1])
            self.SetMaxSize(size=[-1, -1])
            self.SetSize(size=[1000, 800])
            self.Centre(wx.CentreX)
            self.Centre(wx.CentreY)

    def indicate_error(self):
        self.status_bar.SetBackgroundColour('Red')
        self.status_bar.SetStatusText('*******************************ERROR******************************')
        time.sleep(0.5)
        self.status_bar.SetBackgroundColour(wx.TheColourDatabase.Find('ERROR'))
        self.status_bar.SetStatusText('')

    def set_cursor_busy(self, busy: bool):
        if busy:
            self.wait = wx.BusyCursor()  # Create a busy cursor
        else:
            del self.wait


if __name__ == '__main__':
    app = wx.App()
    frame = RegMapGui()
    app.MainLoop()
