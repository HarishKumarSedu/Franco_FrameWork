"""
Module for parsing a function and serializing it for use in the Thrift Server
Author: Evan Canter <evan.canter@cirrus.com>
"""
import inspect
import json
import re
from typing import Callable
from textwrap import dedent
from queue import Queue
import cl_test_station.utilities.parsing as parsing
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.utilities.ts_context_manager import TsContextManager


def func_dumps(func:Callable):
    """
    Creates dictionary representation of a function that contains its source code, parameters, and test station aliases.
    Returns JSON serialized dictionary

    :param func: Function to serialize
    :type func: Callable
    :return: Serialized dictionary representation of function
    :rtype: str
    """
    if func is None:
        return ''
    # Gather data
    func_source = inspect.getsource(func)
    sig = inspect.signature(func)
    # Create a context manager solely for parsing TSO attributes used in func
    t = TsContextManager(source_code=func_source, locals={'self': func.__self__})
    # Parse parameters
    parameters = {}
    for name, param in sig.parameters.items():
        if param.kind is param.POSITIONAL_OR_KEYWORD and param.default is inspect._empty:  # Can't have positional args
            raise SyntaxError("Cannot serialize function with positional parameter: %s. Add a default value." % name)
        try:
            json.dumps(param.default)  # See if default type can be serialized
            parameters[name] = param.default
        except TypeError:
            raise TypeError("%s default value %s is not json serializable" % (name, str(param.default)))

    # Format function source code
    stripped_source = '\n'.join(func_source.split('\n')[1:])  # Remove signature line
    stripped_source = dedent(stripped_source)  # Remove indentation
    ret_statements = re.findall('(return\s+(.+?))\n', stripped_source)  # Find any return statements
    ser_dict = {
        'parameters': parameters,
        'source_code': stripped_source,
        'ret_statements': ret_statements,
        'ts_aliases': t.station_aliases
    }
    return json.dumps(ser_dict)

def func_loads(ser_func: str, _locals: dict, ret_queue: Queue):
    """
    Takes in string from func_dumps and creates lambda function that is equivalent to original. All return statements are
    replaced with queue puts.

    :param ser_func: Serialized function, output of func_dumps
    :type ser_func: str
    :param _locals: locals() dictionary
    :type _locals: dict
    :param ret_queue: Queue to hold return values
    :type ret_queue: Queue
    :return: Function reference
    :rtype: Callable
    """
    ser_dict = json.loads(ser_func)
    source_code = ser_dict['source_code']  # Get raw source code
    kwargs = ser_dict['parameters']  # Instead of parameters, these will become local variables
    for statement, value in ser_dict['ret_statements']:  # Replace returns with queue puts
        source_code = source_code.replace(statement, f'ret_q.put({value})')
    _locals.update(**kwargs, ret_q=ret_queue)  # Add parameters to locals
    # todo: Upgrade this to use eval() so lamda can have user-defined parameters (not just defaulted)
    return lambda self=_locals['self'], source_code=source_code: exec(source_code, {}, _locals), ser_dict['ts_aliases']
