"""
Test Station Context Manager
Author: Evan Canter

This class provides custom Context Manager functionality for cl_test_station interfacing code.
What it looks like in code:

with TsContextManager():
    self.some_component.function()

    self.other_component.BLOCK.REGISTER.FIELD.value = 1

    ## Other python code ###

- Can be used in any class that contains a reference to a test_station

- Loads all source code contained in the 'with' block and stores in self.lines
    - self.lines would = ['self.some_component.function()', 'self.other_component.BLOCK.REGISTER.FIELD.value = 1', ...]

- Realiases all TestStationObject (TSO) types to DummyObjects, so that code executing in the block doesn't do anything

- Allows any class that inherits from this class to offload calls+command 'in' the block to 'out' of the block
    - You just have to override the __enter__ and __exit__ functions
"""
import os, sys, inspect, re
from io import StringIO
import logging
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.register_map.register import Register
from cl_test_station.utilities.parsing import parse_code_block, parse_station_attributes
from cl_test_station.utilities.ts_logging import TsLoggingAdapter, get_logger
from cl_test_station.utilities.dummy_object import DummyObject


class TsContextManager:
    def __init__(self, source_code=None, locals=None):
        """
        Grabs calling object, line number, source code from exec stack. Creates TS attributes and parses source code
        """
        # Save stack information
        stack = inspect.stack()
        self.locals = {}
        self._active = False
        self.realiased = False
        embedded = False
        # Grab source code of block
        if not source_code or not locals:
            for frame, filename, line_num, func, source_code, source_index in stack:
                if frame is not None and 'lines' in frame.f_locals:
                    self.locals['lines'] = frame.f_locals['lines']
                if filename == 'burst_block':
                    call_line = self.locals['lines'][line_num-1]
                    embedded = True
                else:
                    call_line = source_code[source_index].strip()
                if 'with' in call_line and self.__class__.__name__ in call_line:  # This is line of Burst instantiation
                    self.globals = frame.f_globals
                    self.locals = frame.f_locals
                    self.name = ''
                    if 'as' in call_line:  # This manager has a name
                        self.name = call_line[-1][:-1]  # Name of the burst object
                    self.line_num = line_num - 1  # Convert to zero-indexed position
                    if embedded:
                        self.source_code = self.locals['lines'].copy()
                    else:
                        self.source_code = []
                        with open(filename, 'r') as f:  # Get entire file source code as list of lines
                            for line in f:
                                self.source_code.append(line)
                    break
        else:  # Set source code to init param
            self.source_code = source_code.split('\n')
            self.locals = locals
            self.globals = {}
            self.line_num = 0
            call_line = ''

        # Save containing object and find test station
        self.obj = self.locals['self']
        if isinstance(self.obj, TestStationObject):  # Get test station from top level, use ref_name as alias
            self.test_station = self.obj.find_top_level()
            self.ts_alias = self.test_station.ref_name
        else:  # External object, search though __dict__ to find instance of TestStation
            self.ts_alias, self.test_station = self.find_test_station(self.obj)

        # Create Log adapter
        self.log = TsLoggingAdapter(self.test_station.log.logger, self.__class__.__name__)

        # Get lines, attributes, vars, station_aliases
        self.lines = []
        self.attributes = []
        self.vars = {}
        self.station_aliases = {}
        self.attributes.extend(self.parse_call_line(call_line)) # Grab attributes from call line (input parameters)
        self.parse_source()

    def __getattr__(self, item):
        """
        If inactive, acts like a normal object's getattr. When active, always returns a DummyObject
        """
        if item == '_active':
            return object.__getattribute__(self, item)
        elif hasattr(self, '_active') and self.__getattribute__('_active'):  # Active means that code is executing in context
            return DummyObject()
        else:  # Internal code is executing, allow attribute access
            return object.__getattribute__(self, item)

    def find_test_station(self, obj):
        """
        Looks for a reference to a TestStation in obj, returns the name and the reference

        :param obj: Object to search through
        :return: Tuple, (name, TS reference)
        """
        from cl_test_station.test_station import TestStation
        for name, attr in obj.__dict__.items():
            if isinstance(attr, TestStation):
                return name, attr
        raise AttributeError("No TestStation given and no TestStation found as caller attribute")

    def parse_call_line(self, call_line):
        attributes = []
        for match in re.findall(r'self\.(\w+)', call_line):
            if not match.startswith('__') and match != self.__class__.__name__:
                attributes.append(match)
        return attributes


    def parse_source(self):
        """
        Parses calling object's file source code. Finds lines in the 'with' block, any attributes/local varibalies used.
        Compiles a list of any TSOs used, maps their ref_name to the attr_name given to it in the containing object

        :return: None
        """
        # Get lines and attributes used inside the 'with' block
        lines, attributes = parse_code_block(self.source_code, start_line=self.line_num)
        self.lines.extend(lines)
        self.attributes.extend(attributes)
        self.attributes = list(set(self.attributes))
        # Dev logging
        self.log.dev('lines:')
        self.log.draw_line('=', 'DEV')
        for line in self.lines:
            self.log.dev(line)
        self.log.draw_line('=', 'DEV')
        self.log.dev('attributes: ' + str(self.attributes))
        # Use attributes to parse aliases of test_station
        vars, station_aliases = parse_station_attributes(self.obj, self.test_station, self.attributes)
        self.vars.update(vars)
        self.station_aliases.update(station_aliases)
        # Dev logging
        self.log.dev('vars: ' + str(self.vars))
        self.log.dev('station_aliases: ' + str(self.station_aliases))
        self.log.dev('locals: ' + str(self.locals))
        self.log.dev('global keys: ' + str(self.globals.keys()))

    def realias(self):
        """
        Uses setattr to convert any TSO used to a DummyObject. Makes sure nothing happens in the 'with' block

        :return: None
        """
        # Re-alias attributes
        for alias, path in self.station_aliases.items():
            self.station_aliases[alias] = self.test_station.resolve_path(path)
            self.log.dev('Realiasing %s [%s] to DummyObject'%(alias, path))
            self.obj.__dict__[alias] = DummyObject()

        # Re-Alias test station itself
        if self.ts_alias in self.obj.__dict__:
            self.log.dev("Realiasing '%s' to DummyObject"%self.ts_alias)
            self.obj.__dict__[self.ts_alias] = DummyObject()

        # Realias logger
        if hasattr(self.obj, 'log'):
            self.log_save = self.obj.log
            logger = get_logger()
            self.log_buffer = StringIO()
            shandler = logging.StreamHandler(self.log_buffer)
            shandler.setLevel(logging.DEBUG)
            shandler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)-8s - %(message)s'))
            logger.addHandler(shandler)
            self.log_router = TsLoggingAdapter(logger, self.__class__.__name__)
            self.log.dev("Realiasing logger")
            self.obj.__dict__['log'] = self.log_router
        self.realiased = True

    def restore_aliases(self):
        """
        Uses setattr to restore any objects converted into a DummyObject

        :return: None
        """
        # Restore test station and object aliases
        if self.ts_alias in self.obj.__dict__:
            self.log.dev("Restoring %s" % self.ts_alias)
            self.obj.__dict__[self.ts_alias] = self.test_station
        for alias, tso  in self.station_aliases.items():
            self.log.dev("Restoring link: %s = %s" % (alias, tso))
            self.obj.__dict__[alias] = tso
        if hasattr(self, 'log_save'):
            self.log.dev("Restoring logger")
            self.obj.__setattr__('log', self.log_save)
        self.realiased = False

    def activate(self):
        """
        Should get called at the end of __enter__. Puts Context Manager in the active state, redirects stdout, and
        realiases any TSO references

        :return:
        """
        # Realias
        self.realias()
        # Remove stdout stream
        self.stdout_save = sys.stdout
        sys.stdout = None
        self._active = True

    def __enter__(self):
        """
        __enter__ gets automatically called right after the 'with" statement, and after the ContectManaging object is
        instantiated. Base functionality activates itself (protects attributes from outside code) and returns a
        reference to itself

        :return: self
        """
        self.activate()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        __exit__ gets called after the last line in the 'with' block executes. For classes inheriting from this class,
        This would be where most of the implementation will be. The parameteres are required, but aren't used

        :return: None
        """
        self._active = False
        self.restore_aliases()
        sys.stdout = self.stdout_save

    def raise_exc(self, exc, msg, line_no):
        """
        Creates a custom traceback message that allows PyCharm to make clickable link to line that errored out.

        :param exc: Exception class to raise
        :param msg: message to include in the traceback
        :param line_no: Line number relative to the lines in the 'with' block. Will automatically convert to absolute
                        line in source code to create link
        :return: None
        """
        # line in 'with' block where the error happened
        error_source = self.lines[line_no - 1]
        # Get source line number
        source_line_no = self.line_num + line_no + 2
        # Get file name of obj
        fname = inspect.getfile(self.obj.__class__)
        # Build traceback string
        out = '\tFile "%s", line %d, in %s\n\t\traise %s()\n%s'\
                       % (fname, source_line_no, self.__class__.__name__, exc.__name__, msg)
        self.log.error(msg)
        if self.realiased:
            self.restore_aliases()
        raise exc(out)
