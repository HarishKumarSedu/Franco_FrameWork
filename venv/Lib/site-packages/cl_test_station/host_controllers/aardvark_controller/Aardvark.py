# Note: i2c_bus is only for interfaces with multiple i2c buses, i.e. CirrusLink and AudioHub
from typing import List, Tuple
from array import array

from .Aardvark_ import aardvark_wrap as wrap
from .common import intList_to_byteArray, byteArray_to_intList
from cl_test_station.host_controllers.aardvark_controller.enums import AaOperatingModes, AaGpios


DEFAULT_I2C_SPEED = 100      # 100 kHz
DEFAULT_SPI_SPEED = 1000     # 1 MHz
MAX_NUM_AARDVARKS = 10
QUERY = 0x80


class Aardvark:
    """Abstracts low level .dll python driver."""

    def __init__(self, i2c_speed=DEFAULT_I2C_SPEED, spi_speed=DEFAULT_SPI_SPEED, serial_num=None):
        self.handle = -1234
        # The line below allows tests direct access to the wrapper api e.g. ...
        # devid = aardvark.wrap.aae_i2c_read(aardvark.handle, 0x90>>1, 0, 4, 4)
        # OR
        # devid = aardvark.wrap.aa_i2c_write_read(...)
        self.wrap = wrap

        # Interface speed
        self.i2c_speed = i2c_speed
        self.spi_speed = spi_speed

        # Maximum bytes Aardvark can support per single block I2C transaction
        self.i2c_byte_limit = 0xFFFF
        # Maximum bytes Aardvark can support per single block SPI transaction
        self.spi_byte_limit = 0x8000

        # Aardvark serial number; Useful if multiple Aardvarks are used
        self.serial_num = serial_num

        # GPIO masks
        self.gpio_dir_mask = 0
        self.gpio_out_mask = 0
        self.gpio_pullup_mask = 0

    def open(self):
        """
        Opens connection to the Aardvark. If no serial_num was given in the __init__, will pick the Aardark with the
        highest serial number available.

        :return: None
        :rtype: None
        """
        [num_devices, device_ports, device_serial_nums] = wrap.aa_find_devices_ext(MAX_NUM_AARDVARKS, MAX_NUM_AARDVARKS)
        if num_devices == 0:
            raise Exception("No Aardvark devices found!")

        # Either pick the first available Aardvark or an Aardvark with a specific serial number
        if self.serial_num is not None:
            specific_aard_found = False
            for i in range(num_devices):
                if device_serial_nums[i] == self.serial_num:
                    specific_aard_found = True
                    port = device_ports[i]
            if not specific_aard_found:
                raise Exception("Cannot connect to Aardvark device with serial number %d" % self.serial_num)

            self.handle = wrap.aa_open(port)
            if self.handle < 0:
                raise Exception("Cannot connect to Aardvark device. Make sure it is not used in another software, "
                                "e.g. WISCE.")
        else:
            # Calculate number of available Aardvarks
            num_available_aards = 0
            highest_serial_num = 0
            for i in range(num_devices):
                if not (0x8000 & device_ports[i]):
                    num_available_aards += 1
                    if device_serial_nums[i] > highest_serial_num:
                        highest_serial_num = device_serial_nums[i]
                        port = device_ports[i]

            if num_available_aards == 0:
                raise Exception("No free aardvarks available to connect to. Make sure Aardvarks aren't currently being "
                                "used by other software such as WISCE")
            if num_available_aards > 1:
                print("Warning: Multiple Aardvarks available, picking the available Aardvark with the highest serial " +
                      f"number ({highest_serial_num})")
                # raise Exception("Multiple Aardvarks available. Disconnect extra Aardvarks or specify a particular "
                #                 "Aardvark using serial_num argument e.g. aardvark = Aardvark(serial_num=2238289415)")

            self.handle = wrap.aa_open(port)
            if self.handle < 0:
                raise Exception("Cannot connect to Aardvark device")

        # Init GPIOS
        wrap.aa_gpio_direction(self.handle, self.gpio_dir_mask)
        wrap.aa_gpio_set(self.handle, self.gpio_out_mask)
        wrap.aa_gpio_pullup(self.handle, self.gpio_pullup_mask)

        wrap.aa_configure(self.handle, wrap.AA_CONFIG_SPI_I2C)
        wrap.aa_target_power(self.handle, wrap.AA_TARGET_POWER_BOTH)

        self.set_i2c_speed(self.i2c_speed)
        wrap.aa_i2c_pullup(self.handle, wrap.AA_I2C_PULLUP_BOTH)

        self.set_spi_speed(self.spi_speed)
        wrap.aa_spi_configure(self.handle, wrap.AA_SPI_POL_RISING_FALLING, wrap.AA_SPI_PHASE_SAMPLE_SETUP,
                              wrap.AA_SPI_BITORDER_MSB)

    def __del__(self):
        self.close()

    def close(self):
        """
        Closes connection to the Aardvark.

        :return: None
        :rtype: None
        """
        wrap.aa_close(self.handle)

    def is_connected(self) -> bool:
        """
        Returns host port connection status. aa_port will return -9 ('invalid device handle') if not connected, so any
        non-negative port number means the controller is connected.

        :return: Connection status
        :rtype: bool
        """
        return wrap.aa_port(self.handle) >= 0

    def set_operating_mode(self, mode: int):
        """
        Sets operating mode (configure):

        AA_CONFIG_GPIO_ONLY = 0x00
        AA_CONFIG_SPI_GPIO = 0x01
        AA_CONFIG_GPIO_I2C = 0x02
        AA_CONFIG_SPI_I2C = 0x03

        :param mode: Ooperating mode
        :type mode: int
        :return: None
        :rtype: None
        """
        wrap.aa_configure(self.handle, mode)

    def get_operating_mode(self) -> int:
        """
        Gets current operating mode:

        AA_CONFIG_GPIO_ONLY = 0x00
        AA_CONFIG_SPI_GPIO = 0x01
        AA_CONFIG_GPIO_I2C = 0x02
        AA_CONFIG_SPI_I2C = 0x03

        :return: Operating mode
        :rtype: int
        """
        return wrap.aa_configure(self.handle, QUERY)

    # # GPIO FUNCTIONS
    # For these functions, the 'bit' parameter corrosponds to the bit position of 8bit mask used to configure the pins.
    # Bit positions:
    # I2C_SCL  = 0
    # I2C_SDA  = 1
    # SPI_MISO = 2
    # SPI_SCK  = 3
    # SPI_MOSI = 4
    # SPI_SS   = 5

    def set_gpio_direction(self, bit: int, direction: int):
        """
        Sets GPIO direction for a given bit position. 0 = INPUT, 1 = OUTPUT.

        :param bit: Mask bit position
        :type bit: int
        :param direction: Direction. 0 = INPUT, 1 = OUTPUT
        :type direction: int
        :return: None
        :rtype: None
        """
        mask = 1 << bit
        self.gpio_dir_mask &= ~mask
        self.gpio_dir_mask |= direction << bit
        wrap.aa_gpio_direction(self.handle, self.gpio_dir_mask)

    def get_gpio_direction(self, bit: int) -> int:
        """
        Returns GPIO direction for a given bit position.

        NOTE: Direction values are cached in software, as the Aardvark does not allow querying the direction.

        :param bit: Mask bit position
        :type bit: int
        :return: Direction. 0 = INPUT, 1 = OUTPUT
        :rtype: int
        """
        return self.gpio_dir_mask >> bit & 1

    def set_gpio_pullup(self, bit: int, enable: int):
        """
        Sets GPIO pullup enable for a given bit position. 0 = OFF, 1 = ON. If the pin is configured as an output,
        this enable will be ignored until the pin is switched to an input.

        :param bit: Mask bit position
        :type bit: int
        :param enable: 0 = OFF, 1 = ON
        :type enable: int
        :return: None
        :rtype: None
        """
        mask = 1 << bit
        self.gpio_pullup_mask &= ~mask
        self.gpio_pullup_mask |= enable << bit
        wrap.aa_gpio_pullup(self.handle, self.gpio_pullup_mask)

    def get_gpio_pullup(self, bit: int) -> int:
        """
        Returns GPIO pullup enable for a given bit position.

        NOTE: Pullup values are cached in software, as the Aardvark does not allow querying the pullup mask.

        :param bit: Mask bit position
        :type bit: int
        :return: Pullup enable. 0 = OFF, 1 = ON
        :rtype: int
        """
        return self.gpio_pullup_mask >> bit & 1

    def set_gpio_output(self, bit: int, value: int):
        """
        Sets GPIO output value for a given mask bit position.

        :param bit: Mask bit position
        :type bit: int
        :param value: Output level
        :type value: int
        :return: None
        :rtype: None
        """
        mask = 1 << bit
        self.gpio_out_mask &= ~mask
        self.gpio_out_mask |= value << bit
        wrap.aa_gpio_set(self.handle, self.gpio_out_mask)

    def get_gpio_output(self, bit: int) -> int:
        """
        Returns GPIO output level for a given bit position. If pin is configured as an input, this value will be stored
        and applied when the pin becomes an output.

        NOTE: Output values are cached in software, as the Aardvark does not allow querying the gpio mask.

        :param bit:
        :type bit:
        :return:
        :rtype:
        """
        return self.gpio_out_mask >> bit & 1

    def get_gpio_input(self, bit: int) -> int:
        """
        Gets GPIO input level for a given mask bit position.

        :param bit: Mask bit position
        :type bit: int
        :return: Input level
        :rtype: int
        """
        input_mask = wrap.aa_gpio_get(self.handle)
        return input_mask >> bit & 1

    def set_i2c_speed(self, i2c_speed):
        """**i2c_speed: bitrate_khz**"""
        speed = wrap.aa_i2c_bitrate(self.handle, i2c_speed)

    def set_spi_speed(self, spi_speed):
        """**spi_speed: bitrate_khz**"""
        speed = wrap.aa_spi_bitrate(self.handle, spi_speed)

    def get_i2c_byte_limit(self):
        """**Returns the i2c_byte_limit**"""
        return self.i2c_byte_limit

    def get_spi_byte_limit(self):
        """**Returns the spi_byte_limit**"""
        return self.spi_byte_limit

    def set_i2c_pullup(self, pullup_mask=True):
        """**PLACE HOLDER**"""
        if pullup_mask:
            wrap.aa_i2c_pullup(self.handle, wrap.AA_I2C_PULLUP_BOTH)
        else:
            wrap.aa_i2c_pullup(self.handle, wrap.AA_I2C_PULLUP_NONE)

    def get_i2c_pullup(self):
        """**PLACE HOLDER**"""
        return wrap.aa_i2c_pullup(self.handle, wrap.AA_I2C_PULLUP_QUERY)

    def i2c_write(self, i2c_addr, waddr, wdata):
        """**PLACE HOLDER**"""
        self.i2c_block_write(i2c_addr, waddr, wdata)

    def i2c_read(self, i2c_addr, raddr, read_reg_data_size):
        """**PLACE HOLDER**"""
        return self.i2c_block_read(i2c_addr, raddr, read_reg_data_size)

    def i2c_block_write(self, i2c_addr, waddr: list, wdata: list):
        """**PLACE HOLDER**"""
        # todo: the i2c_addr below used to be left shifted, but I removed it since we now use 7-bit i2c addresses
        waddr =  array('B', waddr)
        wdata = array('B', wdata)
        ret_code, num_written = wrap.aa_i2c_write_ext(self.handle, i2c_addr, wrap.AA_I2C_NO_FLAGS, waddr + wdata)
        if ret_code != 0:
            raise IOError("I2C Write Error", (ret_code, num_written))

    def i2c_block_read(self, i2c_addr, raddr: list, byte_count: int):
        """**PLACE HOLDER**"""
        raddr = array('B', raddr)
        data_in = array('B', [0] * byte_count)                 # Blank array to be filled with bytes read
        # todo: the i2c_addr below used to be left shifted, but I removed it since we now use 7-bit i2c addresses
        (ret_code, num_written, in_data, num_read) = wrap.aa_i2c_write_read(self.handle, i2c_addr, wrap.AA_I2C_NO_FLAGS,
                                                                      raddr, data_in)
        # Note: in_data and data_in have exactly the same values
        # print("ret_code=%d, num_written=%d, in_data=%s, num_read=%d" % (ret_code, num_written, in_data, num_read) )
        if ret_code != 0:
            raise IOError("I2C Read Error", (ret_code, num_written, in_data, num_read))

        return list(in_data) # Array of bytes?

    def spi_fd(self, bytes_out):
        """**PLACE HOLDER**"""
        data_out = array('B', bytes_out)
        data_in = array('B', [0] * len(bytes_out))
        ret_code, bytes_in = wrap.aa_spi_write(self.handle, data_out, data_in)
        if ret_code != len(bytes_out):
            raise IOError("SPI Write Error", ret_code)
        return bytes_in

    def spi_write(self, cs, reg_addr, wdata, addr_width, data_width, spi_padding):
        """**PLACE HOLDER**"""
        self.spi_block_write(cs, reg_addr, [wdata], addr_width, data_width, spi_padding)

    def spi_read(self, cs, reg_addr, addr_width, data_width, spi_padding):
        """**PLACE HOLDER**"""
        return self.spi_block_read(cs, reg_addr, 1, addr_width, data_width, spi_padding)[0]

    def spi_block_write(self, cs, first_reg_addr, wdata_array, addr_width, data_width, spi_padding):
        """**PLACE HOLDER**"""
        num_data_bytes = len(wdata_array) * data_width
        size_bytes = addr_width + spi_padding + num_data_bytes
        data_out = array('B', [0] * size_bytes)
        data_in = array('B', [0] * size_bytes)

        data_out[0:addr_width] = array('B', intList_to_byteArray([first_reg_addr], addr_width))
        data_out[spi_padding + data_width:] = array('B', intList_to_byteArray(wdata_array, data_width))

        (ret_code, in_data) = wrap.aa_spi_write(self.handle, data_out, data_in)
        # Note: in_data and data_in have exactly the same values
        if ret_code != size_bytes:
            raise IOError("SPI Write Error", ret_code)

    def spi_block_read(self, cs, first_reg_addr, num_regs, addr_width, data_width, spi_padding):
        """**PLACE HOLDER**"""
        num_data_bytes = num_regs * data_width
        size_bytes = addr_width + spi_padding + num_data_bytes
        data_out = array('B', [0] * size_bytes)
        data_in = array('B', [0] * size_bytes)

        data_out[0:addr_width] = array('B', intList_to_byteArray([first_reg_addr], addr_width))

        data_out[0] |= 0x80     # Set MSB to 1 to indicate a read transaction

        (ret_code, in_data) = wrap.aa_spi_write(self.handle, data_out, data_in)
        # Note: in_data and data_in have exactly the same values
        if ret_code != size_bytes:
            raise IOError("SPI Read Error", (ret_code, in_data))
        values_returned = byteArray_to_intList(in_data[(addr_width + spi_padding):], data_width)

        return values_returned

    @classmethod
    def find_devices(cls, num_devices: int = 10) -> List[Tuple[int, int]]:
        """
        Returns zipped list of tuples, where the first int is the port the aardvark is connected to, and the second int
        is the aardvark's unique ID

        :param num_devices: Number of devices, will determine the length of the return list
        :type num_devices: int
        :return: List of length 'num_devices', containing Port and ID data
        :rtype: list
        """
        ret, devices, ids = wrap.aa_find_devices_ext(num_devices, num_devices)
        return list(zip(devices, ids))
