import os
import sys
from array import array

from cl_test_station.host_controllers.aardvark_controller.aa_pin import AardvarkPin
from cl_test_station.host_controllers.aardvark_controller.Aardvark import Aardvark
from cl_test_station.host_controllers.aardvark_controller.enums import AaOperatingModes, AaGpios
from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.interfaces.ctrl_interface import map_word, ByteOrder
from cl_test_station.pyro_support.pyro_transmitter import internal_transmitter
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.tso_container import TsoContainer


@internal_transmitter('host')
class AardvarkController(HostController):
    """**Place holder**"""
    __default_i2c_speed = 100  # 100 kHz
    __default_spi_speed = 1000  # 1 MHz
    force_speed: bool = TsoField(ftype=bool, required=False, default=False,
                                 desc='When True, sets the i2c/spi speed before each transaction. Adds ~600us '
                                      'of latency per transaction.')
    serial_num: int = TsoField(ftype=int, required=False,
                               desc='Target device serial number. If None is given, the available '
                                    'device with the highest serial num will be used.')
    default_operating_mode: AaOperatingModes = TsoField(ftype=str, required=False,
                                                        default=AaOperatingModes.SPI_AND_I2C, cast_type=AaOperatingModes,
                                                        desc=f"Default operating mode. Can be one of: "
                                                             f"{', '.join([mode.name for mode in AaOperatingModes])}")

    def __init__(self, *args, host = None, **kwargs):
        super().__init__(*args, **kwargs)

        if type(self.serial_num) is str:  # Serial num came in as a string (ENV variable)
            self.serial_num = int(self.serial_num)

        self.host: Aardvark = host
        if self.host is None:
            self.host = Aardvark(i2c_speed=self.__default_i2c_speed,
                                 spi_speed=self.__default_spi_speed,
                                 serial_num=self.serial_num)

        # Cache the most recent i2c/spi speed changes from python.
        self.__current_i2c_speed = None
        self.__current_spi_speed = None

        # Pins container. Will dynamically update based on operating mode
        self.pins = TsoContainer(ref_name='pins', container=self, generate_stubs=False)

    def connect(self):
        if not self.is_connected():
            self.host.open()
            self.set_operating_mode(self.default_operating_mode)
        else:  # Create pins based on current mode
            self._create_pins(self.get_operating_mode())

    def disconnect(self):
        self.host.close()

    def is_connected(self) -> bool:
        return self.host.is_connected()

    # TODO: PLATDEV-1080 remove this
    def isConnected(self):
        return self.is_connected()

    def enable_force_speed(self):
        """Sets the objects force_speed to True."""
        self.force_speed = True

    def diable_force_speed(self):
        """Sets the objects force_sped to False."""
        self.force_speed = False

    def get_devices_idn(self):
        """
        Gets up to 10 devices Serial numbers

        return (_rtn_, [devices], [unique_ids])
        """
        return self.host.wrap.aa_find_devices_ext(devices=10, unique_ids=10)

    def set_operating_mode(self, mode: AaOperatingModes):
        """
        Sets the Aardvark's operating mode:
        GPIO_ONLY    - All pins are gpios: I2C_SCL, I2C_SDA, SPI_MISO, SPI_SCK, SPI_MOSI, SPI_SS
        SPI_AND_GPIO - SPI lines are normal, I2C are GPIO: I2C_SCL, I2C_SDA
        GPIO_AND_I2C - I2C lines are normal, SPI are GPIO: SPI_MISO, SPI_SCK, SPI_MOSI, SPI_SS
        SPI_AND_I2C  - All lines normal, no GPIOs available

        :param mode: Desired operating mode
        :type mode: AaOperatingModes
        :return: None
        :rtype: None
        """
        # Set mode
        self.host.set_operating_mode(mode.value)
        # Create pins
        self._create_pins(mode)

    def get_operating_mode(self) -> AaOperatingModes:
        """
        Gets current operating mode.

        :return: Operating mode
        :rtype: AaOperatingModes
        """
        mode = self.host.get_operating_mode()
        return AaOperatingModes(mode)

    def _create_pins(self, mode: AaOperatingModes):
        # Clear pins
        for pin in list(self.pins.keys()):
            self.pins.pop(pin)
        # Create new pins based on mode
        for gpio in mode.gpios:
            self.pins[gpio.name.lower()] = AardvarkPin(_host=self.host, _gpio=gpio)

    def gen_pyi(self, *args, **kwargs):
        old_pins = {}
        # Clear and store real pins
        for pin in list(self.pins.keys()):
            old_pins[pin] = self.pins.pop(pin)
        # Create all pins for PYI file
        self._create_pins(AaOperatingModes.GPIO_ONLY)
        # Generate normal PYI content with pins included
        result = super().gen_pyi(*args, **kwargs)
        # Clear temp pins and restore current configuration pins
        for pin in list(self.pins.keys()):
          self.pins.pop(pin)
        for pin_name, pin in old_pins.items():
            self.pins[pin_name] = pin
        # Return pyi result
        return result

    def set_i2c_pullup(self, pullup=True):
        """
        Configure I2C Pull up resistors. This is only supported on hardware versions >= 2.00

        :param pullup: I2C Pull up mask
        :type pullup: bool
        :return: None
        """
        self.host.set_i2c_pullup(pullup)

    def get_i2c_pullup(self):
        """
        Gets I2C Pullup status. 0 = NONE, 3 = BOTH

        :return: I2C Pullup status
        :rtype: int
        """
        return self.host.get_i2c_pullup()

    def get_i2c_byte_limit(self):
        """
        Return i2c_byte_limit

        :return: i2c_byte_limit
        :rtype: int
        """
        return self.host.get_i2c_byte_limit()

    def get_spi_byte_limit(self):
        """
        Return i2c_byte_limit

        :return: i2c_byte_limit
        :rtype: int
        """
        return self.host.get_spi_byte_limit()

    def write_i2c_reg(self, speed, address, reg_addr, write_reg_addr_size, addr_byte_order, write_data, **kwargs):
        # Speed comes in as Hz, need to use KHz
        speed_KHz = int(speed/1000)
        if speed % 1000:
            self.log.warning("Ardvark only supports speeds in KHz, using %dHz" % speed_KHz*1000)
        if speed_KHz != self.__current_i2c_speed or self.force_speed:  # Need to set i2c speed
            self.host.set_i2c_speed(speed_KHz)
            self.__current_i2c_speed = speed_KHz  # Save speed_KHz for future transactions
        addr_byte_order = ByteOrder(addr_byte_order)
        waddr = map_word(reg_addr, write_reg_addr_size, addr_byte_order)
        # local_reg, local_data = self.check_iface_arguments(reg_addr, write_data)
        self.host.i2c_block_write(i2c_addr=address, waddr=waddr, wdata=write_data)

    def read_i2c_reg(self, speed, address, reg_addr, read_reg_addr_size, addr_byte_order, byte_count, **kwargs):
        # Speed comes in as Hz, need to use KHz
        speed_KHz = int(speed / 1000)
        if speed % 1000:
            self.log.warning("Ardvark only supports speeds in KHz, using %dHz" % speed_KHz * 1000)
        if speed_KHz != self.__current_i2c_speed or self.force_speed:  # Need to set i2c speed
            self.host.set_i2c_speed(speed_KHz)
            self.__current_i2c_speed = speed_KHz  # Save speed_KHz for future transactions
        addr_byte_order = ByteOrder(addr_byte_order)
        raddr = map_word(reg_addr, read_reg_addr_size, addr_byte_order)
        return self.host.i2c_block_read(address, raddr, byte_count)

    def spi_fd(self, bytes_out, speed, **kwargs):
        """Place Holder"""
        speed_KHz = int(speed / 1000)
        if speed % 1000:
            self.log.warning("Ardvark only supports speeds in KHz, using %dHz" % speed_KHz * 1000)
        if speed_KHz != self.__current_spi_speed or self.force_speed:  # Need to set spi speed
            self.host.set_spi_speed(speed_KHz)
            self.__current_spi_speed = speed_KHz  # Save speed_KHz for future transactions
        return self.host.spi_fd(bytes_out)

    def spi_fd_write(self, spi_fd_config, data_list, ainc, addr, **kwargs):
        """
        Sends command for full duplex spi to libcomms controller

        :param spi_fd_config: config object from test_controller_resource_config.yml under 'resource_spi_iface_mahoney'
        :param data: spi packet. includes r/w, ainc, padding, and write data/read padding
        :return: miso packet
        """
        self.log.warning("spi_fd_write is deprecated. Use spi_fd() instead.")
        # self.host.set_spi_speed(spi_fd_config.speed)
        #
        # local_reg, local_data = self.check_iface_arguments(addr, data_list)
        #
        # if len(local_data) == 1:
        #     self.host.spi_write(spi_fd_config.cSelect, local_reg, local_data[0], spi_fd_config.reg_size, spi_fd_config.data_size, spi_fd_config.padding)
        # else:
        #     self.host.spi_block_write(spi_fd_config.cSelect, local_reg, local_data, spi_fd_config.reg_size, spi_fd_config.data_size, spi_fd_config.padding)

    def spi_fd_read(self, spi_fd_config, word_count, ainc, addr, **kwargs):
        """
        Sends command for full duplex spi to libcomms controller

        :param spi_fd_config: config object from test_controller_resource_config.yml under 'resource_spi_iface_mahoney'
        :param data: spi packet. includes r/w, ainc, padding, and write data/read padding
        :return: miso packet
        """
        self.log.warning("spi_fd_read is deprecated. Use spi_fd() instead.")
        #
        # self.host.set_spi_speed(spi_fd_config.speed)
        #
        # if word_count == 1:
        #     readback = self.host.spi_read(spi_fd_config.cSelect, addr, spi_fd_config.reg_size, spi_fd_config.data_size,
        #                                   spi_fd_config.padding)
        #     return [readback]
        # else:
        #     return self.host.spi_block_read(spi_fd_config.cSelect, addr, word_count, spi_fd_config.reg_size, spi_fd_config.data_size,
        #                                     spi_fd_config.padding)

    @classmethod
    def find_devices(cls, num_devices=10):
        """
        Returns zipped list of tuples, where the first int is the port the aardvark is connected to, and the second int
          is the aardvark's unique ID

        :param num_devices: Number of devices, will determine the length of the return list
        :type num_devices: int
        :return: List of length 'num_devices', containing Port and ID data
        :rtype: list
        """
        return Aardvark.find_devices(num_devices=num_devices)
