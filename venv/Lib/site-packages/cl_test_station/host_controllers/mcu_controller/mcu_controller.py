import inspect
import os
import time
from typing import Dict, List, Optional, Tuple, Type, Union

from cl_test_station.host_controllers.jlink_controller.jlink_controller import JLinkController
from cl_test_station.host_controllers.mcu_controller.sqa_machine.sqa_machine import SqaMachine
from cl_test_station.host_controllers.mcu_controller.mcu_packet_list import McuPacketList
from cl_test_station.host_controllers.mixins import ExtendedConfigMixin
from cl_test_station.interfaces.ctrl_interface import build_word, ByteOrder, map_word
from cl_test_station.interfaces.mcu_firmware.enums import *
from cl_test_station.interfaces.mcu_firmware.packets import *
from cl_test_station.register_map.field import Field
from cl_test_station.register_map.register import Register
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.reusables import get_revision_file, get_latest_revision_file, _get_all_int_revs
from cl_test_station.utilities.ts_context_manager import TsContextManager
from packaging.version import parse as parse_version


# Ranges for value checking
VALID_BUS_SPEEDS_KHZ = [100, 250, 400, 500, 666, 750, 1000]
VALID_TICK_PERIODS_USEC = [100, 5000]
DEFAULT_BUS_SPEED_KHZ = 250
DEFAULT_TICK_PERIOD_USEC = 100


# Creates error message based on what error code was returned by the Mcu
class McuError(Exception):
    def __init__(self, error_code: SqaErrorCodes, *args, **kwargs):
        super().__init__(error_code.description, *args, **kwargs)
        self.error_code = error_code


class McuController(JLinkController, ExtendedConfigMixin):

    # Class attributes
    packet_queue: McuPacketList
    max_tx_size_bytes = 0x35000  # TODO Find out the real value for this

    # Class Fields
    # Override parent TSO with known core name
    target_name: str = TsoField(ftype=str, required=False, default='CORTEX-M33',
                                desc="Chip name to connect to. Defaults to CORTEX-M33")
    test_time_out: float =  TsoField(ftype=float, required=False, default=10.0,
                                     desc="Timeout in seconds to wait for test sequence to finish executing")
    time_stamp_enable: bool = TsoField(ftype=bool, required=False, default=False,
                                       desc="When True, each response will have a time stamp attached to it.")
    # Fields for auto-flashing firmware
    flash_target_name: str = TsoField(ftype=str, required=False, default='', desc="Name of target device for flashing")
    flash_file_path: str = TsoField(ftype=str, required=False, desc="Path to .hex files for flashing")
    flash_file_name: str = TsoField(ftype=str, required=False, default='mcu_firmware.hex',
                                    desc="Name of hex file to flash (non-revisioned)")
    firmware_version_override: str = TsoField(ftype=str, required=False, desc='Desired firmware version to flash. If None '
                                                                              'is specified, the latest will be used. '
                                                                              'e.g. "4.0.2"')
    firmware_version_addr: int = TsoField(ftype=int, required=False, default=0x2007d02c,
                                          desc="Address of firmware version register")

    def __init__(self, *args, **kwargs):
        self.extended_config = {}
        self.sqa_machine: SqaMachine = None
        super().__init__(*args, **kwargs)
        # Populate replacement dictionary for mixin class
        self._extended_config_replacements = {
            "REF_NAME": self.ref_name,
            "FW_VER_ADDR": self.firmware_version_addr
        }
        # Queue attributes
        self.packet_queue = McuPacketList()
        self.__response_map: Dict[int, McuResponse] = {}
        self.force_queue_all_packets = False
        self.wait_for_tick = False
        # Set defaults for bus speed and tick period
        self._most_recent_speed = DEFAULT_BUS_SPEED_KHZ
        self._most_recent_tick_period = DEFAULT_TICK_PERIOD_USEC
        # Auto-flash field defaults
        if not self.flash_file_path:  # Default to path_to_class_module/firmware
            self.flash_file_path = os.path.join(os.path.dirname(inspect.getfile(self.__class__)), 'firmware')

    @property
    def firmware_version(self) -> int:
        """
        Returns version of firmware currently flashed on the MCU
        :return: Firmware version
        :rtype: int
        """
        return self.sqa_machine.get_revision().replace('_', '.')

    def flash_firmware(self, firmware_version: str):
        """
        Connects to flash target device flashes firmware file that corrosponds to the desired version.

        :param firmware_version: Desired firmware version, e.g. 4.0.2
        :type firmware_version: str
        :return: None
        :rtype: None
        """

        # Convert to revision string format
        firmware_revision = firmware_version.replace('.', '_')
        # Connect to flash target
        self.connect_to_target(self.flash_target_name, self.default_target_interface)
        # Get hex file
        if firmware_version:  # User specified specific version
            flash_hex_file = get_revision_file(self.flash_file_path, self.flash_file_name, firmware_revision)
        else:  # Grab latest version locally available
            flash_hex_file = get_latest_revision_file(self.flash_file_path, self.flash_file_name)
        # Flash
        self.handle.flash_file(flash_hex_file, None)
        time.sleep(0.5)

    def connect(self):
        """
        Connects to MCU to read revision, then flashes/reconnects if a new revision is requested.

        :return: None
        :rtype: None
        """
        super().connect()
        if self.__class__ is not McuController:  # Can only auto-flash specific controllers (NXP, Nucleo, etc.)
            # Get current revision
            current_fw_rev = self.firmware_version
            if os.path.isdir(self.flash_file_path):
                # Get desired revision
                available_fw_revs = [s.replace('_', '.') for s in _get_all_int_revs(self.flash_file_path, self.flash_file_name)]
                self.log.debug(f"Current version: {current_fw_rev}, available firmware versions: {', '.join(available_fw_revs)}")
                # Use latest if not specified
                if not self.firmware_version_override:
                    target_fw_version = max(available_fw_revs, key=parse_version)
                # Make sure desired version exists
                elif self.firmware_version_override not in available_fw_revs:
                    raise ValueError(f"Desired firmware version {self.firmware_version_override} does not exists. Available "
                                     f"versions: {', '.join(available_fw_revs)}")
                else:
                    target_fw_version = self.firmware_version_override
                # Flash if current != desired
                if parse_version(current_fw_rev) != parse_version(target_fw_version):
                    self.log.info(f"Flashing target ({target_fw_version})..")
                    result = self.flash_firmware(target_fw_version)
                    self.log.info(f"Flash completed with result code {result}")
                    # Connect again
                    super().connect()
                    # Start state machine
                    self.reset_mcu()
            else:
                self.log.warning(f"Firmware path '{self.flash_file_path}' does not exist, cannot search for firmware.")

    @property
    def wait_for_tick(self) -> bool:
        """
        When True, sets the 'wait_for_tick' bit in all future McuStimulus headers.

        :return: Flag value. True=set bit, False=clear bit
        :rtype: None
        """
        return bool(self.__wait_for_tick)

    @wait_for_tick.setter
    def wait_for_tick(self, value: bool):
        self.__wait_for_tick = int(value)

    @property
    def _most_recent_speed_and_tick(self) -> Tuple[int, int]:
        """
        Finds the last SET_I2C_SPEED_AND_TICK stimulus and returns tuple of speed and tick values.
        If no packets are found, returns default speed (250kHz) and tick period (100usec).

        :return: Tuple containing most recent speed (kHz) and tick period (usec)
        :rtype: Tuple[int, int]
        """
        set_speed_packets = self.packet_queue[SqaOperations.SET_I2C_SPEED_AND_TICK]
        if set_speed_packets:
            payload: SetSpeedTickStimulusPayload = set_speed_packets[-1].payload
            return payload.speed_khz, payload.tick_period_usec
        return DEFAULT_BUS_SPEED_KHZ, DEFAULT_TICK_PERIOD_USEC

    def reset_mcu(self):
        """
        Resets core and cached speed/tick period.

        :return: None
        :rtype: None
        """
        self.handle.reset(halt=False)
        self._most_recent_speed = DEFAULT_BUS_SPEED_KHZ
        self._most_recent_tick_period = DEFAULT_TICK_PERIOD_USEC

    def write_stimulus_packets(self, stimulus_packets: List[McuStimulus] = None):
        """
        Writes stimulus packets to the firmware's TX_START buffer:

            1. Serializes and concatenates all stimulus objects to a single list of integers (bytes)
            2. Block writes bytes to tx_buffer_start (JLink memory_write, nbits=8)
            3. Write length of byte list to tx_buffer_size (JLink memory_write, nbits=32)

        :param stimulus_packets: External stimulus list. If none is given, internal list will be used and then cleared
        :type stimulus_packets: List[McuStimulus]
        :return: None
        :rtype: None
        """
        # Use internal packet queue if no list is given
        if stimulus_packets is None:
            stimulus_packets: List[McuStimulus] = self.packet_queue
            self.packet_queue = McuPacketList()
            self._most_recent_speed = DEFAULT_BUS_SPEED_KHZ
            self._most_recent_tick_period = DEFAULT_TICK_PERIOD_USEC
        # Serialize all headers and payloads
        tx_bytes_out = []
        for stimulus in stimulus_packets:
            if stimulus.payload:
                tx_bytes_out += (stimulus.header + stimulus.payload)
                # self.log.debug(f"Appending {header+payload}")
            else:
                tx_bytes_out += stimulus.header.serialize()
        # Check size of tx buffer
        if len(tx_bytes_out) > self.max_tx_size_bytes:
            raise ValueError(f"Packets given ({len(stimulus_packets)} packets, {len(tx_bytes_out)} bytes) is larger "
                             f"than max transfer size ({self.max_tx_size_bytes} Bytes)")
        self.log.debug(f"Writing {len(stimulus_packets)} packets ({len(tx_bytes_out)} Bytes) "
                       f"to tx buffer at 0x{self.sqa_machine.tx_buffer_start.addr:08x}")
        self.log.debug(tx_bytes_out)
        # Write bytes to start address
        self.sqa_machine.block_write(self.sqa_machine.tx_buffer_start.addr, tx_bytes_out, interface=self.sqa_machine.swd_8bit)
        # Small delay required before writing the buffer size
        time.sleep(0.005)
        # Write tx size to register
        self.sqa_machine.tx_buffer_size.value = len(tx_bytes_out)

    def execute_test_sequence(self, stimulus_packets: List[McuStimulus] = None, iteration_count: int = 0,
                              iteration_delay_usec: int = 0) -> McuPacketList:
        """
        Executes Test and parses responses:

            1. Write to time stamp enable register
            2. Clear test_start register
            3. Write stimulus packets and tx_buffer_size
            4. Set test_start
            5. Poll test_done - if timeout (in seconds) is reached, a TimeoutError will be raised and the test will abort
            6. Check test_error and raises McuError for all non-zero error codes
            7. Read rx_buffer_size
            8. Read response bytes from rx_buffer_start
            9. Parses response packets

        :param stimulus_packets: External stimulus list. If none is given, internal list will be used and then cleared
        :type stimulus_packets: List[McuStimulus]
        :param iteration_count: Number of times to loop the test sequence. Only the last iteration's  results will be
        stored in RX BUFFER.
        :type iteration_count: int
        :param iteration_delay_usec: Delay in microseconds between iterations.
        :type iteration_delay_usec: int
        :return: List of parsed McuResponse objects. Each McuResponse element will have a header, payload (optional),
        and time_stamp (optional)
        :rtype: McuPacketList
        """
        # Clear test start, write time stamp enable bit
        self.sqa_machine.time_stamp_en.value = int(self.time_stamp_enable)
        self.sqa_machine.test_start.value = 0
        # Write stimulus packets
        self.write_stimulus_packets(stimulus_packets)
        # Set up iterations if specified
        if iteration_count:
            self.sqa_machine.sequence_iteration_count.value = iteration_count
            self.sqa_machine.sequence_delay_usec.value = iteration_delay_usec
        # Start test
        start = time.time()
        self.sqa_machine.test_start.value = 1
        # Poll test done until 1
        while self.sqa_machine.test_done.value == 0:
            if time.time() - start > self.test_time_out:
                raise TimeoutError(f"Test execution timed out after {self.test_time_out:2.2f} seconds")
        self.log.debug(f"Test sequence finished executing in {time.time() - start: 3.2f} seconds ")
        # Reset iteration
        self.sequence_iteration_count = 0
        # Before getting responses, check for errors
        try:
            test_error = SqaErrorCodes(self.sqa_machine.test_error.value)
        except ValueError:
            raise McuError(SqaErrorCodes.UNKNOWN_ERROR)
        if test_error is not SqaErrorCodes.NO_ERROR:
            raise McuError(test_error)
        # After test done, get rx size and read in response bytes
        rx_size = self.sqa_machine.rx_buffer_size.value
        self.log.debug(f"reading {rx_size} bytes from rx_buffer at 0x{self.sqa_machine.rx_buffer_start.addr:08x}")
        bytes_in = self.sqa_machine.block_read(self.sqa_machine.rx_buffer_start.addr, rx_size, interface=self.sqa_machine.swd_8bit)
        # self.sqa_machine.test_start.value = 0
        self.log.debug(f"Received bytes: {bytes_in}")
        responses = self._process_response_bytes(bytes_in, self.time_stamp_enable)
        self.__response_map = {}
        return responses

    def queue_packet(self, stimulus: McuStimulus) -> McuResponse:
        """
        Adds McuStimulus object to the internal packet queue and returns a placeholder response object. After execution,
        the response object will be updated to contain the actual response information (header, payload, time stamp)

        :param stimulus: McuStimulus object to queue
        :type stimulus: McuStimulus
        :return: Empty McuResponse object
        :rtype: McuResponse
        """
        # Create empty response to return as a stand-in
        response_cls = self.__get_response_cls(stimulus.header.operation)
        empty_response = response_cls(None, None, None)
        # Add stimulus to the queue
        self.packet_queue.append(stimulus)
        # Register empty response using packet index so that it can be updated after execution
        self.__response_map[stimulus.header.packet_index] = empty_response
        return empty_response

    # -------------------------------------
    #           Internal functions
    # -------------------------------------

    def __get_response_cls(self, op: SqaOperations) -> Type[McuResponse]:
        """
        Performs lookup to get response dataclass based on operation. Defaults to generic McuResponse.

        :param op: Operation
        :type op: SqaOperations
        :return: McuResponse class
        :rtype: McuResponse
        """
        return OPERATION_RESPONSE_MAP.get(op, McuResponse)

    def _process_response_bytes(self, bytes_in: List[int], time_stamp_enable) -> McuPacketList:
        """
        Iterates over received bytes and creates McuResponse dataclass objects.

        :param bytes_in: Bytes read from tx_buffer_start
        :type bytes_in: List[int]
        :param time_stamp_enable: If True, interprets 4 bytes after header as time stamp.
        :type time_stamp_enable: bool
        :return: List of McuResponse objects.
        :rtype: McuPacketList
        """
        response_packets = McuPacketList()
        processed_bytes = 0
        while processed_bytes < len(bytes_in):
            # Parse header
            header = SqaPacketHeader.deserialize(bytes_in[processed_bytes:])
            processed_bytes += len(header)
            # Timestamp, if enabled
            if time_stamp_enable:
                time_stamp = build_word(bytes_in[processed_bytes:processed_bytes+4], word_size=4, byte_order=ByteOrder.MSB_FIRST)
                processed_bytes += 4
            else:
                time_stamp = None
            # Payload
            if header.payload_size and header.operation in OPERATION_PAYLOAD_MAP:
                packet_cls = OPERATION_PAYLOAD_MAP[header.operation]
                payload = packet_cls.deserialize(bytes_in[processed_bytes:processed_bytes+header.payload_size],
                                                 size=header.payload_size, reg_size=header.i2c_mode.reg_size,
                                                 remainder=4-header.i2c_mode.reg_size)
            else:
                payload = None
            # Move pointer and append data
            processed_bytes += header.payload_size
            # Parse response dataclass
            if header.packet_index in self.__response_map:  # Update stored response's attributes
                response = self.__response_map[header.packet_index]
                response.header = header
                response.payload = payload
                response.time_stamp = time_stamp
            else:  # Create new response
                response_cls = self.__get_response_cls(header.operation)
                response = response_cls(header=header, payload=payload, time_stamp=time_stamp)
            response_packets.append(response)
        return response_packets

    def _execute_single_packet(self, stimulus: McuStimulus) -> McuResponse:
        stimulus.header.packet_index = 0
        result = self.execute_test_sequence([stimulus])
        return result[0]

    def __handle_packet_request(self, header: SqaPacketHeader, payload: PayloadBase = None, queue: bool = False):
        stimulus = McuStimulus(header, payload)
        if queue:  # TODO: Add force_queue here or rename attribute to be more i2c centric
            return self.queue_packet(stimulus)
        else:
            return self._execute_single_packet(stimulus)

    def _create_header(self, wait_for_tick: int = None, op: SqaOperations = SqaOperations.I2C_READ, payload_size: int = 0,
                       target_rw_size: int = 4, i2c_address: int = 0, i2c_mode: I2cModes = I2cModes.MODE_11,
                       op_mode: SqaOperationModes = SqaOperationModes.NOT_STD, register_address: int = None
                       ) -> SqaPacketHeader:
        if wait_for_tick is None:
            wait_for_tick = self.__wait_for_tick
        # These interface fields are constant
        address_size = 4 if i2c_mode.addressable else 0
        addr_byte_order = ByteOrder.LSB_FIRST
        # Map address
        if register_address is not None:
            register_address = map_word(register_address, address_size, addr_byte_order)
        # Z-fill address portion if needed
        else:
            register_address = [0] * address_size
        return SqaPacketHeader(packet_index=len(self.packet_queue), wait_for_tick=wait_for_tick,
                               i2c_address=i2c_address, i2c_mode=i2c_mode, operation_mode=op_mode, operation=op,
                               payload_size=payload_size, target_rw_size=target_rw_size, register_address=register_address)

    # -------------------------------------
    #           Opcode functions
    # -------------------------------------

    def i2c_read(self, i2c_address: int, i2c_mode: I2cModes, reg_address: int, num_bytes: int, queue: bool = True) -> McuI2cReadResponse:
        """
        Either queues or executes an I2C_READ operation. If queueing, an empty McuI2cReadResponse object will be
        returned. After execution, this object will be updated.

        Contents of McuI2cReadResponse:
            * header - SqaPacketHeader dataclass
            * payload - ReadResponsePayload dataclass, which has read_bytes and size attributes
            * time_stamp (if enabled)

        Example access:
            * response.header.target_rw_size
            * response.payload.read_bytes

        :param i2c_address: I2C device address
        :type i2c_address: int
        :param i2c_mode: I2C mode to use - 00, 01, 10, 11
        :type i2c_mode: I2cModes
        :param reg_address: Register address
        :type reg_address: int
        :param num_bytes: Number of bytes to read
        :type num_bytes: int
        :param queue: When True, adds stimulus to queue. When False, executes read and immediately returns response
        :type queue: bool
        :return: Read response dataclass. If queueing, the response's attributes will be None
        :rtype: McuI2cReadResponse
        """
        header = self._create_header(i2c_address=i2c_address, i2c_mode=i2c_mode, op=SqaOperations.I2C_READ,
                                     payload_size=0, target_rw_size=num_bytes, register_address=reg_address)
        return self.__handle_packet_request(header, queue=queue)

    def i2c_write(self, i2c_address: int, i2c_mode: I2cModes, reg_address: int, bytes_out: List[int], queue: bool = True) -> McuResponse:
        """
        Either queues or executes an I2C_WRITE operation. If queueing, an empty McuResponse object will be
        returned. After execution, this object will be updated.

        :param i2c_address: I2C device address
        :type i2c_address: int
        :param i2c_mode: I2C mode to use - 00, 01, 10, 11
        :type i2c_mode: I2cModes
        :param reg_address: Register address
        :type reg_address: int
        :param bytes_out: Bytes to write
        :type bytes_out: List[int]
        :param queue: When True, adds stimulus to queue. When False, executes read and immediately returns response
        :type queue: bool
        :return: MCU response dataclass. If queueing, the response's attributes will be None
        :rtype: McuResponse
        """
        header = self._create_header(i2c_address=i2c_address, i2c_mode=i2c_mode, op=SqaOperations.I2C_WRITE,
                                     payload_size=len(bytes_out), target_rw_size=len(bytes_out), register_address=reg_address)
        payload = WriteStimulusPayload(bytes_out)
        return self.__handle_packet_request(header, payload, queue)

    def i2c_poll(self, i2c_address: int, i2c_mode: I2cModes, register_address: int, mask: int,
                 expected_value: int, read_reg_data_size: int, queue: bool = True) -> McuPollResponse:
        if i2c_mode not in [I2cModes.MODE_00, I2cModes.MODE_11]:
            raise ValueError(f"Can only poll using MODE_00 or MODE_11, not {i2c_mode.name}")
        header = self._create_header(i2c_address=i2c_address, i2c_mode=i2c_mode, op=SqaOperations.I2C_POLL,
                                     payload_size=8, target_rw_size=read_reg_data_size, register_address=register_address)
        payload = PollStimulusPayload(mask, expected_value)
        return self.__handle_packet_request(header, payload, queue)

    def toggle_tick_timer_check(self, queue: bool = True) -> McuResponse:
        header = self._create_header(op=SqaOperations.TOGGLE_TIMING_CHECK, payload_size=0)
        return self.__handle_packet_request(header, queue)

    def i2c_mode11_random_write(self, i2c_address: int, register_address: int, seed: int, queue: bool = True) -> McuResponse:
        header = self._create_header(i2c_address=i2c_address, i2c_mode=I2cModes.MODE_11, payload_size=4,
                                     op=SqaOperations.I2C_RANDOM_WRITE, register_address=register_address)
        payload = RandomWriteStimulusPayload(seed)
        return self.__handle_packet_request(header, payload, queue=queue)

    def insert_time_delay(self, delay_usec: int, queue: bool = True) -> McuResponse:  # todo: remove queue
        header = self._create_header(op=SqaOperations.INSERT_PACKET_DELAY, payload_size=4)
        payload = DelayStimulusPayload(delay_time_usec=delay_usec)
        return self.__handle_packet_request(header, payload, queue)

    def start_timer(self, queue: bool = True) -> McuResponse:
        header = self._create_header(op=SqaOperations.START_TIMER, payload_size=0)
        return self.__handle_packet_request(header, queue=queue)

    def read_timer(self, queue: bool = True) -> McuReadTimerResponse:
        header = self._create_header(op=SqaOperations.READ_TIMER, payload_size=0)
        return self.__handle_packet_request(header, queue=queue)

    def set_output(self, value) -> McuResponse:
        header = self._create_header(op=SqaOperations.SET_OUTPUT, payload_size=1)
        payload = InoutStimulusPayload(value)
        return self.__handle_packet_request(header, payload, queue)

    def clear_output(self, value) -> McuResponse:
        header = self._create_header(op=SqaOperations.CLEAR_OUTPUT, payload_size=1)
        payload = InoutStimulusPayload(value)
        return self.__handle_packet_request(header, payload, queue)

    def wait_if_input_is_set(self, value) -> McuResponse:
        header = self._create_header(op=SqaOperations.WAIT_IF_INPUT_IS_SET, payload_size=1)
        payload = InoutStimulusPayload(value)
        return self.__handle_packet_request(header, payload, queue)

    def wait_if_input_is_clear(self, value) -> McuResponse:
        header = self._create_header(op=SqaOperations.WAIT_IF_INPUT_IS_CLEAR, payload_size=1)
        payload = InoutStimulusPayload(value)
        return self.__handle_packet_request(header, payload, queue)

    def set_speed_and_tick_period(self, bus_speed_hkz: int, tick_period_usec: int, queue: bool = True) -> McuResponse:
        # Check arguments
        if bus_speed_hkz not in VALID_BUS_SPEEDS_KHZ:
            raise ValueError(f"Bus speed given ({bus_speed_hkz}kHz) is not supported, can be {', '.join(VALID_BUS_SPEEDS_KHZ)}kHz")
        if tick_period_usec not in VALID_TICK_PERIODS_USEC:
            raise ValueError(f"Tick period given ({bus_speed_hkz}usec) is not supported, can be {', '.join(VALID_TICK_PERIODS_USEC)}usec")
        # Create packet
        header = self._create_header(op=SqaOperations.SET_I2C_SPEED_AND_TICK, payload_size=8)
        payload = SetSpeedTickStimulusPayload(speed_khz=bus_speed_hkz, tick_period_usec=tick_period_usec)
        if queue:
            self._most_recent_speed = bus_speed_hkz
            self._most_recent_tick_period = tick_period_usec
        return self.__handle_packet_request(header, payload, queue)

    def enable_pwm_output(self, output_pin: int, polarity: int, period: int, duty_cycle: int, push_pull_en: int,
                          queue: bool = True) -> McuResponse:
        header = self._create_header(op=SqaOperations.SET_PWM_OUTPUT, payload_size=20)
        payload = SetPwmStimulusPayload(output_pin=output_pin, polarity=polarity, pwm_period=period,
                                        pwm_duty_cycle=duty_cycle, pull_up_push_pull=push_pull_en)
        return self.__handle_packet_request(header, payload, queue)

    def disable_pwm_output(self, output_pin: int, queue: bool = True) -> McuResponse:
        header = self._create_header(op=SqaOperations.CLEAR_PWM_OUTPUT, payload_size=4)
        payload = ClearPwmStimulusPayload(output_pin=output_pin)
        return self.__handle_packet_request(header, payload, queue)

    def write_bit_field(self, i2c_address: int, i2c_mode: I2cModes, register_address: int, mask: int, field_value: int,
                        write_reg_data_size: int, queue: bool = True) -> McuWriteBitFieldResponse:
        if not i2c_mode.addressable:  # Mode 01 or 10, raise error
            raise ValueError(f"Mode given ({i2c_mode.name}) is not supported, must be MODE00 or MODE11.")
        header = self._create_header(i2c_address=i2c_address, i2c_mode=i2c_mode, op=SqaOperations.WRITE_FIELD,
                                     payload_size=8, target_rw_size=write_reg_data_size, register_address=register_address)
        payload = WriteBitFieldStimulusPayload(mask=mask, value=field_value)
        return self.__handle_packet_request(header, payload, queue)

    # -------------------------------------
    #        HostController Functions
    # -------------------------------------

    def __get_speed_khz(self, speed_hz: int) -> int:
        speed_khz = int(speed_hz // 1000)
        if speed_khz not in VALID_BUS_SPEEDS_KHZ:
            raise ValueError(
                f"Speed given ({speed_khz}kHz) is not supported. Must be {', '.join(VALID_BUS_SPEEDS_KHZ)}kHz")
        return speed_khz

    def _ixc_read(self, reg_addr: int, byte_count: int, i2c_mode: I2cModes, address_5bit: int,
                         read_reg_data_size: int, speed_khz: int) -> List[int]:
        # Queue packets and return None
        if self.force_queue_all_packets:
            most_recent_speed, most_recent_tick = self._most_recent_speed_and_tick
            if most_recent_speed != speed_khz:  # Need to update speed
                self.set_speed_and_tick_period(speed_khz, most_recent_tick, queue=True)
            response = self.i2c_read(address_5bit, i2c_mode, reg_addr, byte_count, queue=True)
            response.convert_to_int = True
            response.byte_order = ByteOrder.MSB_FIRST  # Based on firmware
            response.word_size = read_reg_data_size
            return response
        # Create sequence just for setting speed and i2c read
        else:
            save = self.packet_queue
            self.packet_queue = []
            self.set_speed_and_tick_period(speed_khz, 100, queue=True)  # TODO: Find way to not touch the tick rate
            self.i2c_read(address_5bit, i2c_mode, reg_addr, byte_count, queue=True)
            try:
                responses = self.execute_test_sequence()
                self.packet_queue = save
                return responses[1].payload.read_bytes
            except McuError as err:
                self.packet_queue = save
                if err.error_code is SqaErrorCodes.NACK_TIMEOUT:
                    return -6
                else:
                    raise

    def _ixc_write(self, reg_addr: int, write_data: List[int], i2c_mode: I2cModes, address_5bit: int,
                   speed_khz: int) -> Optional[McuResponse]:
        # Queue packets and return None
        if self.force_queue_all_packets:
            most_recent_speed, most_recent_tick = self._most_recent_speed_and_tick
            if most_recent_speed != speed_khz:  # Need to update speed
                self.set_speed_and_tick_period(speed_khz, most_recent_tick, queue=True)
            return self.i2c_write(address_5bit, i2c_mode, reg_addr, bytes_out=write_data, queue=True)
        # Create sequence just for setting speed and i2c write
        else:
            save = self.packet_queue
            self.packet_queue = []
            self.set_speed_and_tick_period(speed_khz, DEFAULT_TICK_PERIOD_USEC,
                                           queue=True)  # TODO: Find way to not touch the tick rate
            self.i2c_write(address_5bit, i2c_mode, reg_addr, bytes_out=write_data, queue=True)
            try:
                responses = self.execute_test_sequence()
                self.packet_queue = save
                return 0
            except McuError as err:
                self.packet_queue = save
                if err.error_code is SqaErrorCodes.NACK_TIMEOUT:
                    return -6
                else:
                    raise

    def read_i2c_reg(self, reg_addr: int, byte_count: int, address: int, read_reg_data_size: int,
                     speed: int = 100_000, **kwargs) -> List[int]:
        """
        Performs an I2C register read. The Stucture of the bus traffic is:

        1. START
        2. Device address (Write), ACK
        3. Register address, ACK
        4. REPEAT START
        5. Device address (Read), ACK
        6. Read data from device/ACK repeated byte_count-1 times
        7. Last read byte from device/NACK from controller
        8. STOP

        :param reg_addr: Register address of read
        :type reg_addr: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param address: 7-bit device address
        :type address: int
        :param read_reg_data_size: Size of register in Bytes, only used for queued transactions
        :type read_reg_data_size: int
        :return:
            * Successful read: List of bytes read from device
            * Failed read: Integer, error code: -6 -> I2C NAK error
        :rtype: list | int
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address
        i2c_mode = I2cModes(address & 0x3)
        # For I2C, device address is just upper 5 bits
        i2c_address = address >> 2 & 0x1F
        # Perform read
        return self._ixc_read(reg_addr, byte_count, i2c_mode, i2c_address, read_reg_data_size, speed_khz)

    def read_i3c_reg(self, reg_addr: int, byte_count: int, address: int, read_reg_data_size: int,
                     speed: int = 100_000, **kwargs) -> List[int]:
        """
        Performs an I3C register read.

        :param reg_addr: Register address of read
        :type reg_addr: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param address: 7-bit device address
        :type address: int
        :param read_reg_data_size: Size of register in Bytes, only used for queued transactions
        :type read_reg_data_size: int
        :return:
           * Successful read: List of bytes read from device
           * Failed read: Integer, error code: -6 -> I2C NAK error
        :rtype: list | int
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address TODO: Figure out how mode is defined in I3C
        i2c_mode = I2cModes(address & 0x3)
        # For I3C_DM and I3C, device address b6, b5, b4, b1, b0
        i2c_address = (address >> 2 & 0x1C) + (address & 0x3)
        # Perform read
        return self._ixc_read(reg_addr, byte_count, i2c_mode, i2c_address, read_reg_data_size, speed_khz)

    def write_i2c_reg(self, reg_addr: int, write_data: List[int], address: int, speed: int = 100_000,
                      **kwargs) -> Union[int, McuResponse]:
        """
        Performs an I2C register write. The Stucture of the bus traffic is:

        1. START
        2. Device address (Write), ACK
        3. Register address, ACK
        4. Data byte/ACK repeated len(write_data) times
        5. STOP

        :param reg_addr: Register address of write
        :type reg_addr: int
        :param write_data: List of bytes to write
        :type write_data: list
        :param address: 7-bit device address
        :type address: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :return: Either empty McuReponse if queueing or error code if atomic. Error code. 0 -> Successful write,
        -6 -> I2C NAK error
        :rtype: int | McuResponse
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address
        i2c_mode = I2cModes(address & 0x3)
        # For I2C, device address is just upper 5 bits
        i2c_address = address >> 2 & 0x1F
        return self._ixc_write(reg_addr, write_data, i2c_mode, i2c_address, speed_khz)

    def write_i3c_reg(self, reg_addr: int, write_data: List[int], address: int, speed: int = 100_000, **kwargs):
        """
        Performs an I3C register write.

        :param reg_addr: Register address of write
        :type reg_addr: int
        :param write_data: List of bytes to write
        :type write_data: list
        :param address: 7-bit device address
        :type address: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :return: Error code. 0 -> Successful write, -6 -> I3C NAK error
        :rtype: int
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address TODO: Figure out how mode is defined in I3C
        i2c_mode = I2cModes(address & 0x3)
        # For I3C_DM and I3C, device address b6, b5, b4, b1, b0
        i2c_address = (address >> 2 & 0x1C) + (address & 0x3)
        return self._ixc_write(reg_addr, write_data, i2c_mode, i2c_address, speed_khz)

    def write_i2c_field(self, reg_addr: int, field_value: int, field_mask: int, field_offset: int, address: int,
                        write_reg_data_size: int, speed: int = 100_000, **kwargs) -> Union[int, McuWriteBitFieldResponse]:
        """
        Issues a write bitfield operation to modify a field's value. The Stucture of the bus traffic is:

        1. START
        2. Device address (Write), ACK
        3. Register address, ACK
        4. REPEAT START
        5. Device address (Read), ACK
        6. Read data from device/ACK repeated byte_count-1 times
        7. Last read byte from device/NACK from controller
        8. STOP
        9. START
        10. Device address (Write), ACK
        11. Register address, ACK
        12. Data byte/ACK repeated len(write_data) times
        13. STOP

        :param reg_addr: Register address of write
        :type reg_addr: int
        :param field_value: Desired field value
        :type field_value: int
        :param field_mask: Field mask. e.g for a 3 bit field with offet=0, mask=0x7
        :type field_mask: int
        :param field_offset: Field's offset. Bit location of the LSB
        :type field_offset: int
        :param address: 7-bit device address
        :type address: int
        :param write_reg_data_size: Size of register in bytes
        :type write_reg_data_size: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :return: Either empty McuWriteBitFieldResponse if queueing or error code if atomic. Error code.
        0 -> Successful write, -6 -> I2C NAK error
        :rtype: int | McuWriteBitFieldResponse
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address
        i2c_mode = I2cModes(address & 0x3)
        # For I2C, device address is just upper 5 bits
        i2c_address = address >> 2 & 0x1F
        # Adjust field value
        field_value <<= field_offset
        # Adjust payload data if size is < 4
        if write_reg_data_size < 4:
            shift = 8 * (4 - write_reg_data_size)  # Need to right shift into MSByte of the 32 bit payload word
            field_value <<= shift
            field_mask <<= shift
        # Queue packets and return None
        if self.force_queue_all_packets:
            most_recent_speed, most_recent_tick = self._most_recent_speed_and_tick
            if most_recent_speed != speed_khz:  # Need to update speed
                self.set_speed_and_tick_period(speed_khz, most_recent_tick, queue=True)
            return self.write_bit_field(i2c_address, i2c_mode, reg_addr, field_mask, field_value, write_reg_data_size, queue=True)
        # Create sequence just for setting speed and i2c write
        else:
            save = self.packet_queue
            self.packet_queue = []
            self.set_speed_and_tick_period(speed_khz, DEFAULT_TICK_PERIOD_USEC, queue=True)  # TODO: Find way to not touch the tick rate
            self.write_bit_field(i2c_address, i2c_mode, reg_addr, field_mask, field_value, write_reg_data_size, queue=True)
            try:
                responses = self.execute_test_sequence()
                self.packet_queue = save
                return 0
            except McuError as err:
                self.packet_queue = save
                if err.error_code is SqaErrorCodes.NACK_TIMEOUT:
                    return -6
                else:
                    raise

    def i2c_device_read(self, address: int, byte_count: int, speed: int = 100_000, **kwargs) -> Union[List[int], int]:
        """
        Performs simple I2C read to device with i2c address 'address'. The Stucture of the bus traffic is:

        1. START
        2. Device address with R/W bit = 0
        3. Read in 'byte_count' bytes from device
        4. STOP

        :param address: 7-bit device address
        :type address: int
        :param byte_count: Number of bytes to read immediately following the address byte
        :type byte_count: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :return:
            * Successful read: List of bytes read from device
            * Failed read: Integer, error code: -6 -> I2C NAK error
        :rtype: List[int] | int
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address
        i2c_mode = I2cModes(address & 0x3)
        if i2c_mode.addressable:
            raise ValueError(f"I2C mode {i2c_mode.name} does not support device reads, use read_i2c_reg instead.")
        # For I2C, device address is just upper 5 bits
        i2c_address = address >> 2 & 0x1F
        # Perform read
        response = self._ixc_read(None, byte_count, i2c_mode, i2c_address, 1, speed_khz)
        if self.force_queue_all_packets:  # Response is a McuResponse class, convert to a list instead of int
            response.convert_to_int = False
            response.convert_to_list = True
        return response

    def i2c_device_write(self, address: int, write_data: List[int], speed: int = 100_000, **kwargs) -> int:
        """
        Performs simple I2C write to device with i2c address 'address'. The Structure of the bus traffic is:

        1. START
        2. Device address with R/W bit = 1
        3. Data bytes, write_data[0] will be the first byte sent out
        4. STOP

        :param address: 7-bit device address
        :type address: int
        :param write_data: List of data bytes to write immediately following the address byte
        :type write_data: list
        :param speed: Transfer speed in Hz
        :type speed: int
        :return: Error code. 0 -> Successful write, -6 -> I2C NAK error
        :rtype: int
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address
        i2c_mode = I2cModes(address & 0x3)
        if i2c_mode.addressable:
            raise ValueError(f"I2C mode {i2c_mode.name} does not support device reads, use read_i2c_reg instead.")
        # For I2C, device address is just upper 5 bits
        i2c_address = address >> 2 & 0x1F
        # Perform read
        return self._ixc_write(None, write_data, i2c_mode, i2c_address, speed_khz)

    # TODO: Improve read_value in payload for field polls, or remove polling fields as a feature
    def poll_reg_or_field(self, regmap_obj: Union[Field, Register], expected_value: int, address: int,
                          read_reg_data_size: int,
                          speed: int = 100_000, queue: bool = True, **kwargs) -> McuPollResponse:
        """
        Polls a given Register or Field's value until expected value is reached. If value never reaches expected, an
        McuError (timeout) exception will be raised.

        :param regmap_obj: Register or Field reference
        :type regmap_obj: Register | Field
        :param expected_value: Value to check
        :type expected_value: int
        :param address: 7-bit device address
        :type address: int
        :param read_reg_data_size: Size of register in bytes
        :type read_reg_data_size: int
        :param speed: Bus speed in Hz
        :type speed: int
         :param queue: When True, adds stimulus to queue. When False, executes read and immediately returns response
        :type queue: bool
        :return: McuPollResponse dataclass. If queueing, the response's attributes will be None
        :rtype: McuI2cReadResponse
        """
        speed_khz = self.__get_speed_khz(speed)
        # Get mode from address
        i2c_mode = I2cModes(address & 0x3)
        # For I2C, device address is just upper 5 bits
        i2c_address = address >> 2 & 0x1F
        # Get register object
        if isinstance(regmap_obj, Field):
            reg = regmap_obj.container
            # Compliment field mask
            mask = regmap_obj.mask
            # Shift expected value
            expected_value = expected_value << regmap_obj.bit_offset
        else:
            reg = regmap_obj
            mask = 2 ** (read_reg_data_size << 3) - 1
        # shift payloads if data size is less than 4 bytes
        if read_reg_data_size < 4:
            shift = 8 * (4 - read_reg_data_size)
            mask <<= shift
            expected_value <<= shift
        return self.i2c_poll(i2c_address=i2c_address, i2c_mode=i2c_mode, register_address=reg.addr, mask=mask,
                             expected_value=expected_value, read_reg_data_size=read_reg_data_size, queue=queue)

    def McuStimulusExecutor(self, *args, wait_for_tick: bool = False, add_time_stamps: bool = False,
                            iteration_count: int = 0, iteration_delay_usec: int = 0, **kwargs) -> 'McuStimulusExecutor':
        """
        Creates an McuStimulusExecutor context manager for use in a 'with' statement.

        e.g.
        ```
            with self.test_station.nxp_rt600.McuStimulusExecutor() as results:
                # Set bus speed and tick period to 250kHz, 100usec resp.
                self.test_station.nxp_rt600.set_speed_and_tick_period(250, 100)
                # Store read values in the results object. These attributes will be converted to integers after execution
                results.field1_value = self.dut.BLOCK.REG1.FIELD1.value
                results.reg1_value = self.dut.BLOCK.REG1.value
                # Field writes will use the write bitfield operation instead of the usual read-modify-write flow
                self.dut.BLOCK.REG2.FIELD2.value = 0xE

            # Access read values as integers
            print(results.field1_value)
            print(results.reg1_value)
            # Access read responses as dataclasses (header, payload, time_stamp)
            print(results[0].header)
            print(results[0].payload)
            print(results[0].time_stamp)
        ```

        :param wait_for_tick: Denotes value of 'wait_for_tick' bit in all packets in the 'with' block
        :type wait_for_tick: bool
        :param add_time_stamps: When True, each response packet will contain a timestamp
        :type add_time_stamps: bool
        :param iteration_count: Number of times to loop the test sequence. Only the last iteration's  results will be
        stored in RX BUFFER.
        :type iteration_count: int
        :param iteration_delay_usec: Delay in microseconds between iterations.
        :type iteration_delay_usec: int
        :return: Mcu stimulus executor context manager, whose __enter__ returns an McuResponseResults instance
        :rtype: McuStimulusExecutor
        """
        return McuStimulusExecutor(self, *args, wait_for_tick=wait_for_tick, add_time_stamps=add_time_stamps,
                                   iteration_count=iteration_count, iteration_delay_usec=iteration_delay_usec, **kwargs)


class McuResponseResults:
    """Class returned by McuStimulusExecutor's __enter__ method. Handles storing McuResponse objects. Converts any
    McuI2cReadResponse's into integers"""

    responses: McuPacketList
    __read_response_attrs: Dict[str, McuI2cReadResponse]

    def __init__(self):
        self.responses = None
        self.__read_response_attrs = {}

    def __getitem__(self, item) -> McuResponse:
        return self.responses[item]

    def __setattr__(self, key, value):
        if isinstance(value, McuI2cReadResponse) and (value.convert_to_int or value.convert_to_list):
            self.__read_response_attrs[key] = value
        if isinstance(value, list):
            self.__read_response_attrs[key] = value
        object.__setattr__(self, key, value)

    def convert_read_responses(self):
        """
        Any attribute or list element that is an McuI2cReadResponse instance will be converted to an interger.

        :return: None
        :rtype: None
        """
        for key, value in self.__read_response_attrs.items():
            # Convert all values in lists
            if isinstance(value, list):
                for i, sub_elem in enumerate(value):
                    if isinstance(sub_elem, McuI2cReadResponse):
                        value[i] = sub_elem.value
            # Convert basic response attribute
            else:
                setattr(self, key, value.value)


class McuStimulusExecutor(TsContextManager):
    """Context Manager that uses an McuController to queue, execute and parse any requests inside of a with statement."""

    def __init__(self, controller: 'McuController', *args, wait_for_tick: bool = False, add_time_stamps: bool = False,
                 iteration_count: int = 0, iteration_delay_usec: int = 0, **kwargs):
        super().__init__(*args, **kwargs)
        self.controller = controller
        self.old_wait_for_tick = self.controller.wait_for_tick
        self.old_time_stamp_en = self.controller.time_stamp_enable
        self.wait_for_tick = wait_for_tick
        self.time_stamp_en = add_time_stamps
        self.iteration_count = iteration_count
        self.iteration_delay_usec = iteration_delay_usec

    def __enter__(self):
        self.controller.force_queue_all_packets = True
        self.controller.wait_for_tick = self.wait_for_tick
        self.results = McuResponseResults()
        return self.results

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.controller.force_queue_all_packets = False
        self.controller.time_stamp_enable = self.time_stamp_en
        responses = self.controller.execute_test_sequence(iteration_count=self.iteration_count,
                                                          iteration_delay_usec=self.iteration_delay_usec)
        self.controller.wait_for_tick = self.old_wait_for_tick
        self.controller.time_stamp_enable = self.old_time_stamp_en
        self.results.responses = responses
        self.results.convert_read_responses()
