"""Abstract Host Controller Class"""
import inspect
from typing import List, Tuple
from abc import abstractmethod
from cl_test_station.test_station_object import TestStationObject


def connection_required(func):
    """
    Wrapper that checks if the HostController's isConnected() returns True, then calls wrapped function. If isConnected
    returns False, an error is raised and the function is not called.
    """
    def inner(self, *args, **kwargs):
        if self.isConnected():  # TODO: PLATDEV-1080 change to is_connected()
            return func(self, *args, **kwargs)
        raise ConnectionError(f"{self.ref_name} is not connected. Use connect() first.")
    inner.__signature__ = inspect.signature(func)
    return inner


def skip_if_connected(func):
    """
    Wrapper that checks if the HostController's isConnected() returns False, then calls wrapped function. If isConnected
    returns True, The function will not be run.
    """
    def inner(self, *args, **kwargs):
        if not self.isConnected():
            return func(self, *args, **kwargs)
        else:
            self.log.debug(f"Already connected, skipping execution of {func}")
    inner.__signature__ = inspect.signature(func)
    return inner


class HostController(TestStationObject):
    """Abstract Host Controller Class"""

    @abstractmethod
    def isConnected(self) -> bool:  # ToDo: correct name to confirm to standards: is_connected
        """
        Returns status of connection. True should mean the controller is able to send out transactions

        :return: Connection status
        :rtype: bool
        """

    @abstractmethod
    def connect(self):
        """
        Connects driver to controller. isConnected() should return True after this function runs.

        :return: None
        :rtype: None
        """

    @abstractmethod
    def disconnect(self):
        """
        Disconnects driver from controller. isConnected() should return False after this function runs.

        :return: None
        :rtype: None
        """

    @abstractmethod
    def write_i2c_reg(self, reg_addr: int, write_data: List[int], address: int, *args, **kwargs):
        """
        Writes write_data bytes to the specified I2C register

        :param reg_addr: Register Address to write to
        :type reg_addr: int
        :param write_data: Bytes to write to register
        :type write_data: List[int]
        :param address: Device I2C address to be written to
        :type address: int
        :param args: Additional positional arguments
        :type args: Any
        :param kwargs: Additional HostController specific keyword arguments
        :type kwargs: Any
        :return: None
        :rtype: None
        """

    @abstractmethod
    def read_i2c_reg(self, reg_addr: int, byte_count: int, address: int, *args, **kwargs) -> List[int]:
        """
        Reads specified number of bytes from the given I2C register

        :param reg_addr: Register Address to read from
        :type reg_addr: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param address: Device I2C address to be read from
        :type address: int
        :param args: Additional positional arguments
        :type args: Any
        :param kwargs: Additional HostController specific keyword arguments
        :type kwargs: Any
        :return: Bytes readback
        :rtype: List[int]
        """

    def i2c_scan(self, *args, **kwargs) -> List[str]:
        """
        Checks the I2C bus and returns a list present device addresses

        :param args: Additional positional arguments
        :type args: Any
        :param kwargs: Additional HostController specific keyword arguments
        :type kwargs: Any
        :return: List of hexadecimal I2C addresses on the bus (i.e. ['0x70', '0x82'])
        :rtype: List[str]
        """
        raise NotImplementedError(f'I2C Scan is not supported by {self.ref_name}')

    @abstractmethod
    def spi_fd(self, bytes_out: List[int], *args, **kwargs) -> List[int]:
        """
        Issues a dull-duplex transfer, sending bytes in 'data_bytes' out to SDI/MOSI and returning bytes read from SDO/MISO.

        :param bytes_out: Bytes to be transferred on SDI/MOSI
        :type bytes_out: List[int]
        :param args: Additional positional arguments
        :type args: Any
        :param kwargs: Additional HostController specific keyword arguments
        :type kwargs: Any
        :return: Bytes from SDO/MISO
        :rtype: List[int]
        """

    @staticmethod
    def check_iface_arguments(reg_addr, write_data) -> Tuple[int, List[int]]:
        """
        Checks arguments for interface methods

        :param reg_addr: Register address to write to/read from
        :type reg_addr: int
        :param write_data: Data to be written
        :type write_data: int | List[int]
        :return: Tuple of Register address and list of data
        :rtype: Tuple[int, List[int]]
        """
        # Check the type of the write_data argument
        local_data = []
        if isinstance(write_data, int):
            local_data.append(write_data)
        elif isinstance(write_data, list):
            local_data = write_data
        else:
            raise TypeError('The type for the write_data argument is expected to be int or list')

        # Check the type of the reg_addr argument
        if not isinstance(reg_addr, int):
            raise TypeError('The type for the reg_addr argument is expected to be int')

        return reg_addr, local_data

    def generate_id(self, *args, **kwargs):     # pylint: disable=unused-argument
        return 0
