"""Host Controller for PyFlexPatGen"""
from cl_test_station.host_controllers.host_controller.host_controller import HostController


class PatternController(HostController):
    """Host Controller for PyFlexPatGen"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.reg_dict = {}
        self.last_addr = 0
        self.pat = None

    def configure(self, pat_object, *args, **kwargs):  # pylint: disable=arguments-differ
        self.pat = pat_object

    # Required Abstract Methods
    def connect(self):
        """
        Connects driver to controller. isConnected() should return True after this function runs.

        :return: None
        :rtype: None
        """

    def disconnect(self):
        """
        Disconnects driver from controller. isConnected() should return False after this function runs.

        :return: None
        :rtype: None
        """

    def isConnected(self):
        """
        Returns status of connection. True should mean the controller is able to send out transactions

        :return: Connection status
        :rtype: bool
        """
        return True

    # Pattern generation functions
    def write_i2c_reg(self, reg_addr, write_data, port_name, *args, **kwargs):  # pylint: disable=arguments-differ
        self.reg_dict[reg_addr] = write_data

        hex_string = '0x'
        for value in write_data:
            hex_string = hex_string + '%02x' % value

        int_value = int(hex_string, 16)

        self.pat.Append.controlWrite(port_name, reg_addr, int_value)
        self.last_addr = reg_addr

    def read_i2c_reg(self, reg_addr, byte_count, read_reg_data_size, default_value, *args,
                     **kwargs):  # pylint: disable=arguments-differ
        self.last_addr = reg_addr

        if reg_addr in self.reg_dict:
            return self.reg_dict[reg_addr]
        else:
            default_value_list = []
            for i in range(0, read_reg_data_size):
                default_value_list.append((default_value >> (read_reg_data_size - i - 1) * 8) & 0xff)
            print(default_value_list)
            return default_value_list

    def spi_fd(self, bytes_out, access_mode, port_name, read_reg_addr_size, read_reg_data_size, padding, *args, **kwargs):  # pylint: disable=arguments-differ
        """
        Place holder

        :param bytes_out:
        :type bytes_out:
        :param access_mode:
        :type access_mode:
        :param port_name:
        :type port_name:
        :param read_reg_addr_size:
        :type read_reg_addr_size:
        :param read_reg_data_size:
        :type read_reg_data_size:
        :param padding:
        :type padding:
        :param args:
        :type args:
        :param kwargs:
        :type kwargs:
        :return:
        """

        reg_addr_list = bytes_out[:read_reg_addr_size]
        # remove r/w and autoinc bits
        reg_addr_list[0] = reg_addr_list[0] & 0x3f
        reg_addr = 0
        for i, byte in enumerate(reg_addr_list):
            reg_addr = reg_addr + byte * 256 ** (read_reg_addr_size - i - 1)

        self.last_addr = reg_addr

        if access_mode is False:
            default_value = kwargs['default_value']
            default_value_list = []
            for i in range(0, read_reg_data_size):
                default_value_list.append((default_value >> (read_reg_addr_size - i - 1) * 8) & 0xff)

            if reg_addr in self.reg_dict:
                return [0] * (read_reg_addr_size + padding) + self.reg_dict[reg_addr]

            return [0] * (read_reg_addr_size + padding) + default_value_list

        else:
            write_data = bytes_out[(read_reg_addr_size + padding):(read_reg_addr_size + padding) + read_reg_data_size]
            self.reg_dict[reg_addr] = write_data

            hex_string = '0x'
            for value in write_data:
                hex_string = hex_string + '%02x' % value

            int_value = int(hex_string, 16)
            self.pat.Append.controlWrite(port_name, reg_addr, int_value)

    def spmi_extended_register_write_long(self, slave_id, address, write_data, port_name, **kwargs):
        """
        Sends extended register write long command to AudioHub API

        :param slave_id: Slave ID
        :type slave_id: int
        :param address: Write address, 16 bit
        :type address: int
        :param port_name: the
        :param write_data: [list<int>] List of bytes to write, up to 8 bytes

        :return:
        """

        self.last_addr = address

        self.reg_dict[address] = write_data

        hex_string = '0x'
        reversed_write_data = write_data[::-1]

        for value in reversed_write_data:
            hex_string = hex_string + '%02x' % value

        int_value = int(hex_string, 16)
        self.pat.Append.controlWrite(port_name, address, int_value)

    def spmi_extended_register_read_long(self, slave_id, address, default_value, length, **kwargs):
        """
        Sends extended register read long command to AudioHub API

        :param slave_id: Slave ID
        :param address: Read address, 16 bit
        :param default_value:
        :type default_value:
        :param length: length of read, up to 8 bytes
        :return: list of read bytes
        """

        self.last_addr = address

        if address in self.reg_dict:
            return self.reg_dict[address]
        else:
            default_value_list = []
            for i in range(0, length):
                default_value_list.append((default_value >> (length - i - 1) * 8) & 0xff)
            reversed_default_value_list = default_value_list[::-1]
            return reversed_default_value_list

    # Dummy Implementations
    def set_gpio(self, *args, **kwargs):
        pass

    def hcc_queue_packets(self, packets, cs_delays, **kwargs):
        """
        Sends packets to Audiohub and queues them using the HCC Driver. len(packets) needs to equal len(cs_delays)

        :param packets: List of lists of bytes. Each list of bytes is a separate HCC Packet
        :type packets: list
        :param cs_delays: List of ints. Contains CS delay for packet at matching index.
        :type cs_delays: list
        :return: None
        """

    def hcc_send_packet(self, packet, cs_delay, **kwargs):
        """
        Sends packet onto the physical bus, returns bytes received from HCC Device.

        :param packet: List of bytes to send onto the bus.
        :type packet: list
        :param cs_delay: Time in usec the CS line is deasserted after the packet is finished transmitting
        :type cs_delay: int
        :return: List of ints representing bytes received from the HCC Device
        :rtype: list
        """

    def hcc_execute_packet_queue(self, **kwargs):
        """
        Issues all queued packets and returns list of lists of ints (list of return packets from HCC Device)

        :return: List of list of integers (Bytes), packets received from HCC Device
        :rtype: list
        """

    def enable_hcc(self, bus_num, chip_select, **kwargs):
        """
        Allows HCC Driver to access SPI Controller

        :param bus_num: SPI Bus number
        :type bus_num: int
        :param chip_select: Chip Select line
        :type chip_select: int
        :return: None
        """

    def disable_hcc(self, **kwargs):
        """
        Disconnects HCC Driver from SPI Controller

        :return: None
        """

    def hcc_set_speed(self, speed, **kwargs):
        """
        Sets bus speed of HCC Driver. Supported speeds are 24MHz, 12MHz, 6MHz, 3MHz. Can also use Porter.

        :param speed: Bus rate in Hz
        :type speed: int
        :return: None
        """

    def hcc_driver_register(self, handler=''):
        """
        Regsiters HINT Signal, builds serialized handler if specified

        :param handler: Result from calling ts_function_serializer func_dumps
        :type handler: str
        :return: None
        """

    def hcc_driver_unregister(self):
        """
        Removes HINT Signal from python process

        :return: None
        """

    def hcc_hint_queue_get(self, timeout=0):
        """
        Grabs interrupt response from server queue. Returns '__empty' if empty

        :param timeout: If no response is found in queue after timeout seconds, returns '__empty'
        :type timeout: float
        :return: Interrupt response
        :rtype: Any
        """
