"""
Simulation Host Controller that supports reading and writing through internal runtime memory.

Author: Evan Canter <evan.canter@cirrus.com>
"""
import math
from typing import Dict, List

from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.interfaces.ctrl_interface import map_word, ByteOrder, build_word
from cl_test_station.pyro_support.pyro_transmitter import internal_transmitter
from cl_test_station.utilities.dummy_object import DummyObject


class AccessTypes:
    """Access types for dictating behavior of spi_fd"""
    R = 1
    W = 2
    RW = 3


class TransactionCache:
    """Pyro-friendly dictionary implmentation for managing controller transaction data."""

    def __init__(self):
        self.cache = {}

    def get_cache(self) -> Dict[str, Dict[int, List[int]]]:
        """
        Returns entire cache dictionary

        :return: Cache dictionary that stores transaction data for all components/protocols
        :rtype: dict
        """
        return self.cache

    def contains(self, item):
        return item in self.cache

    def update(self, **kwargs):
        self.cache.update(**kwargs)

    def clear(self):
        self.cache = {}

    def __getitem__(self, item):
        return self.cache[item]

    def __setitem__(self, key, value):
        self.cache[key] = value


@internal_transmitter('cache')
class SimHostController(HostController):
    """Controller class that can simulate transactions for I2C, SPI, and SPMI protocols"""

    # List that specifies all resources the real controller has. A DummyObject will be created for each.
    __resource_names__ = []

    def __init__(self, *args, cache: TransactionCache = None, **kwargs):
        super().__init__(*args, **kwargs)
        # Internal transmitter logic. Pass dict transmitter through if provided
        if cache is None:
            self.cache = TransactionCache()
        else:
            self.cache = cache
        # Create dummy objects for all resource names
        for resource in self.__resource_names__:
            setattr(self, resource, DummyObject())

    # # ----- Helper Functions ----- # #

    def reset_cache(self, comp_path: str = None):
        """
        If comp_path is supplied, will only clear cache for that specific component. Otherwise, will clear entire cache

        :param comp_path: test_station path to the component, eg. test_station.eeb.dc.proj_name
        :type comp_path: str
        :return: None
        """
        if comp_path is not None:
            if self.cache.contains(comp_path):
                self.log.debug(f"Clearing cache for {comp_path}")
                self.cache[comp_path] = {}
        else:
            self.log.debug("Clearing entire cache")
            self.cache.clear()

    def _get_cache(self, comp_path:str) -> Dict[int, List[int]]:
        """
        Gets dictionary reference for a specific component's cache. Cache format is {address: list of bytes}

        :param comp_path: test_station path to the component, eg. test_station.eeb.dc.proj_name
        :type comp_path: str
        :return:
        :rtype:
        """
        if not self.cache.contains(comp_path):  # Create new component cache entry
            self.cache[comp_path] = {}
        return self.cache[comp_path]

    def _sim_read(self, comp_path, address, byte_count, address_stride, read_reg_data_size, default_value,
                  data_byte_order, ainc) -> List[int]:
        """
        Simulated read that either 1. Grabs from cache 2. returns default value given 3. returns 0's

        :return: List of integers representing bytes read
        :rtype: list
        """
        cache = self._get_cache(comp_path)
        bytes_in = []
        step = address_stride if ainc else 0
        num_words = math.ceil(byte_count / read_reg_data_size)
        for i in range(num_words):
            addr = address + i * step
            if addr in cache:
                bytes_in += cache[addr]
            elif default_value is not None:
                bytes_in += map_word(default_value, read_reg_data_size, data_byte_order)
            else:
                bytes_in += [0] * read_reg_data_size
        bytes_in = bytes_in[:byte_count]
        self.log.debug(f"Simulating read from address {address:x}: {bytes_in}")
        return bytes_in

    def _sim_write(self, comp_path, address, write_data, write_reg_data_size, address_stride, ainc):
        """
        Simulated write that stores given write_data in the cache

        :return: None
        """
        cache = self._get_cache(comp_path)
        self.log.debug(f"Simulating write to address {address:x}: {write_data}")
        step = address_stride if ainc else 0
        for i, chunk in enumerate([write_data[i:i+write_reg_data_size] for i in range(0, len(write_data), write_reg_data_size)]):
            chunk += [0] * (write_reg_data_size - len(chunk))  # Pad 0's for incomplete
            cache[address + i * step] = chunk.copy()
        self.cache[comp_path] = cache

    # # ----- HostController Functions ----- # #
    def connect(self, *args, **kwargs):
        self.log.debug(f"SimHostController.connect(), args: {args}, kwargs: ({', '.join(kwargs.keys())})")

    def disconnect(self, *args, **kwargs):
        self.log.debug(f"SimHostController.disconnect(), args: {args}, kwargs: ({', '.join(kwargs.keys())})")

    def isConnected(self, *args, **kwargs):
        return True

    def i2c_scan(self, *args, **kwargs) -> List[str]:
        return ['']

    # # ----- Protocol Functions ----- # #

    def write_i2c_reg(self, reg_addr, write_data, write_reg_data_size, address_stride, _comp_path, ainc_bit_pos, ainc_active_level, *args, **kwargs):
        """
        Simulates an I2C register write transaction
        """

        # Get Auto-Increment flag from address
        if ainc_bit_pos is not None:
            ainc = (reg_addr >> ainc_bit_pos & 0x1) == ainc_active_level
            reg_addr &= ~(0x1 << ainc_bit_pos)
        else:
            ainc = False
        self._sim_write(_comp_path, reg_addr, write_data, write_reg_data_size, address_stride, ainc)

    def read_i2c_reg(self, reg_addr, byte_count, read_reg_data_size, address_stride,
                     data_byte_order, _comp_path, ainc_bit_pos, ainc_active_level, default_value=None, **kwargs):
        """
        Simulates an I2C register read transaction
        """
        if data_byte_order not in ByteOrder:  # Reconstruct enum if serialized
            data_byte_order = ByteOrder(data_byte_order)

        # Get Auto-Increment flag from address
        if ainc_bit_pos is not None:
            ainc = (reg_addr >> ainc_bit_pos & 0x1) == ainc_active_level
            reg_addr &= ~(0x1 << ainc_bit_pos)
        else:
            ainc = False
        return self._sim_read(_comp_path, reg_addr, byte_count, address_stride, read_reg_data_size, default_value, data_byte_order, ainc)

    def spi_fd(self, bytes_out, read_reg_addr_size, write_reg_addr_size, read_reg_data_size, write_reg_data_size,
               padding, pad_value, rw_bit_pos, write_active_level, ainc_bit_pos, ainc_active_level, _comp_path,
               addr_byte_order, data_byte_order, address_stride, default_value=None, **kwargs):
        """
        Simulates a SPI Full Duplex transaction
        """
        # Reconstruct ByteOrder Enums
        if data_byte_order not in ByteOrder:
            data_byte_order = ByteOrder(data_byte_order)
        if addr_byte_order not in ByteOrder:
            addr_byte_order = ByteOrder(addr_byte_order)

        # Retrieve address from bytes_out
        raw_address = build_word(bytes_out[:read_reg_addr_size], read_reg_addr_size, addr_byte_order)

        # Process access and trim register address
        address = raw_address
        if rw_bit_pos is not None:  # Mask off rw bit
            address &= ~(0x1 << rw_bit_pos)
            write_bool = (raw_address >> rw_bit_pos & 0x1) == write_active_level  # Write -> True, Read -> False
            access = 1 << write_bool  # Write -> 2 -> AccessTypes.W, Read -> 1 -> AccessTypes.R
        else:  # No RW bit given, just perform both todo: Is this a good assumption?
            access = AccessTypes.RW
        # Process AINC bit and tim register address
        if ainc_bit_pos is not None:  # Mask off ainc bit
            address &= ~(0x1 << ainc_bit_pos)
            ainc = (raw_address >> ainc_bit_pos & 0x1) == ainc_active_level
        else:
            ainc = False

        # Perform full duplex transaction
        bytes_in = [pad_value] * (read_reg_addr_size + padding)
        byte_count = len(bytes_out) - len(bytes_in)
        if access & AccessTypes.R:  # Perform read
            bytes_in += self._sim_read(_comp_path, address, byte_count, address_stride, read_reg_data_size, default_value,
                                       data_byte_order, ainc)
        if access & AccessTypes.W:  # Perform write
            write_data = bytes_out[write_reg_addr_size+padding:]  # Bytes to be written
            self._sim_write(_comp_path, address, write_data, write_reg_data_size, address_stride, ainc)
        # Trim bytes_in if extra bytes were read
        bytes_in = bytes_in[:len(bytes_out)]
        return bytes_in

    # TODO: Implement rest of SPMI functions

    def spmi_extended_register_read(self, address, length, address_stride, read_reg_data_size,
                                    data_byte_order, _comp_path, default_value=None, **kwargs):
        """
        Simulates an SPMI Extended Register Read command
        """
        return self._sim_read(_comp_path, address, length, address_stride, read_reg_data_size, default_value, data_byte_order, ainc=True)

    def spmi_extended_register_read_long(self, *args, **kwargs):
        """
        Simulates an SPMI Extended Register Read Long command
        """
        return self.spmi_extended_register_read(*args, **kwargs)

    def spmi_extended_register_write(self, address, write_data, write_reg_data_size, address_stride, _comp_path, **kwargs):
        """
        Simulates an SPMI Extended Register Write command
        """
        self._sim_write(_comp_path, address, write_data, write_reg_data_size, address_stride, ainc=True)

    def spmi_extended_register_write_long(self, *args, **kwargs):
        """
        Simulates an SPMI Extended Register Write Long command
        """
        self.spmi_extended_register_write(*args, **kwargs)

    def spmi_block_read(self, start_addr, byte_count, address_stride, read_reg_data_size, data_byte_order, _comp_path,
                        default_value=None, **kwargs):
        """
        Simulates an SPMI Extended Register Read command
        """
        return self._sim_read(_comp_path, start_addr, byte_count, address_stride, read_reg_data_size, default_value, data_byte_order, ainc=True)

    def spmi_block_write(self, start_addr, write_data, write_reg_data_size, address_stride, _comp_path, **kwargs):
        """
        Simulates an SPMI Extended Register Write command
        """
        self._sim_write(_comp_path, start_addr, write_data, write_reg_data_size, address_stride, ainc=True)

    def spmi_chain_read(self, address, num_reads, read_size, address_stride, read_reg_data_size, data_byte_order, _comp_path,
                        default_value=None, **kwargs):
        """
        Simulates an SPMI Extended Register Read command
        """
        return self._sim_read(_comp_path, address, num_reads * read_size, address_stride, read_reg_data_size, default_value, data_byte_order, ainc=False)

    def spmi_chain_write(self, address, write_data, write_reg_data_size, address_stride, _comp_path, **kwargs):
        """
        Simulates an SPMI Extended Register Write command
        """
        self._sim_write(_comp_path, address, write_data, write_reg_data_size, address_stride, ainc=False)

    def set_gpio(self, *args, **kwargs):
        """Simulated function. Prints attempted call to the console."""
        self.log.debug(f"SimHostController.set_gpio(), args: {args}, kwargs: ({', '.join(kwargs.keys())})")

    def enable_hcc(self, *args, **kwargs):
        """Simulated function. Prints attempted call to the console."""
        self.log.debug(f"SimHostController.enable_hcc(), args: {args}, kwargs: ({', '.join(kwargs.keys())})")

    def disable_hcc(self, *args, **kwargs):
        """Simulated function. Prints attempted call to the console."""
        self.log.debug(f"SimHostController.disable_hcc(), args: {args}, kwargs: ({', '.join(kwargs.keys())})")
