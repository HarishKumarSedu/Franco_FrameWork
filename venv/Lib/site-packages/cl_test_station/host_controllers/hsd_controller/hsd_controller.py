"""
This file requires BETA-SYS inst_mgr 0.2.1 or above to be installed, but is not a requirement of cl_test_station
ToDo: PLATDEV-931 move to a library package
"""

# Import error raising Warning
from typing import List
import numpy as np
from inst_mgr.drivers.nidigpat.nidigpat import NiDigPat
from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.interfaces.i2c_interface import I2cInterface
from cl_test_station.interfaces.spi_interface import SpiInterface
from cl_test_station.interfaces.spmi_interface import SpmiInterface
from cl_test_station.interfaces.hcc_interface import HccInterface


class HsdController(HostController):
    """Host Controller class for NI Digital cards"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.nidigpat = NiDigPat

    def isConnected(self) -> bool:
        """
        Returns status of connection. True should mean the controller is able to send out transactions over i2c/spi

        :return: Connection status
        :rtype: bool
        """
        return True

    def connect(self):
        """
        Connects driver to controller. isConnected() should return True after this function runs.

        :return: None
        :rtype: None
        """
        pass    # pylint: disable=unnecessary-pass

    def disconnect(self):
        """
        Disconnects driver from controller. isConnected() should return False after this function runs.

        :return: None
        :rtype: None
        """
        pass    # pylint: disable=unnecessary-pass

    def assign_instrument(self, nidigpat: NiDigPat):
        """
        Connects driver to ni digital instrument.

        :param nidigpat: Instrument to connect to driver
        :type nidigpat: NiDigPat
        :return: None
        :rtype: None
        """
        self.nidigpat = nidigpat

    def configure_i2c_waveforms(self, i2c_data_pin: str, i2c: I2cInterface):
        """
        Configures the required I2C source and capture waveforms. Set to use 8-bit MSB broadcasted serial samples.

        :param i2c_data_pin: DUT I2C SDA pin name
        :type i2c_data_pin: str
        :param i2c: I2C interface for the pin to get the source and capture waveform names used
        :type i2c: I2cInterface
        :return: None
        :rtype: None
        """
        # Fill missing fields with defaults
        read_cap_wfm_name = getattr(i2c, 'read_cap_wfm_name', 'i2c_cap')
        read_src_wfm_name = getattr(i2c, 'read_src_wfm_name', 'i2c_src_read')
        write_src_wfm_name = getattr(i2c, 'write_src_wfm_name', 'i2c_src_write')
        # Configure waveforms
        self.nidigpat.create_capture_waveform_serial(i2c_data_pin, read_cap_wfm_name, 8, self.nidigpat.enums.BitOrder.MSB)
        self.nidigpat.create_source_waveform_serial(i2c_data_pin, read_src_wfm_name, self.nidigpat.enums.SourceDataMapping.BROADCAST,   # pylint: disable=line-too-long
                                                    8, self.nidigpat.enums.BitOrder.MSB)
        self.nidigpat.create_source_waveform_serial(i2c_data_pin, write_src_wfm_name, self.nidigpat.enums.SourceDataMapping.BROADCAST,  # pylint: disable=line-too-long
                                                    8, self.nidigpat.enums.BitOrder.MSB)

    def write_i2c_reg(self, reg_addr: int, write_data: List[int], address: int, write_reg_addr_size: int, *args, # pylint: disable=arguments-differ
                      write_src_wfm_name: str='i2c_src_write', write_src_wfm_size: int = 1024,
                      write_pattern: str='i2c_write', check_ack: bool=True, **kwargs):
        """
        Writes write_data bytes to the specified I2C register

        :param reg_addr: Register Address to write to
        :type reg_addr: int
        :param write_data: Bytes to write to register
        :type write_data: List[int]
        :param address: Device I2C address to be written to
        :type address: int
        :param write_reg_addr_size: Register address size in bytes
        :type write_reg_addr_size: int
        :param args: Additional positional arguments
        :type args: Any
        :param write_src_wfm_name: SDA source waveform name [Default: i2c_src_write]
        :type write_src_wfm_name: str
        :param write_src_wfm_size: SDA source waveform memory size in bytes [Default: 1024]
        :type write_src_wfm_size: int
        :param write_pattern: Name of pattern to burst [Default: i2c_write]
        :type write_pattern: str
        :param check_ack: Check for I2C Acknowledgements? [Default: True]
        :type check_ack: bool
        :param kwargs: Additional keyword arguments
        :type kwargs: Any
        :return: Error Code from transaction [Default: None]
        :rtype: int | None
        """
        # Create data to send to pattern
        source_data = [address << 1]
        for byte_number in range(write_reg_addr_size - 1, -1, -1):
            next_byte = reg_addr & 255 << (byte_number * 8)
            source_data.append(next_byte >> (byte_number * 8))  # MSB 8 bits
        source_data.extend(write_data)  # Data MSB 8 bits
        self.__pad_source(source_data, write_src_wfm_size)

        self.nidigpat.write_sequencer_register(self.nidigpat.enums.SequencerRegister.REGISTER0, write_reg_addr_size)
        self.nidigpat.write_sequencer_register(self.nidigpat.enums.SequencerRegister.REGISTER1, len(write_data))
        self.nidigpat.write_source_waveform_broadcast(write_src_wfm_name, source_data)
        self.nidigpat.burst_pattern(write_pattern)

        if check_ack and not self.check_i2c_ack(address):
            return -6

    def read_i2c_reg(self, reg_addr: int, byte_count: int, address: int, read_reg_addr_size: int, *args,    # pylint: disable=arguments-differ
                     read_cap_wfm_name: str='i2c_cap', read_src_wfm_name: str='i2c_src_read', read_src_wfm_size: int=6,
                     read_pattern: str='i2c_read', check_ack: bool=True, **kwargs) -> List[int]:
        """
        Reads specified number of bytes from the given I2C register

        :param reg_addr: Register Address to read from
        :type reg_addr: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param address: Device I2C address to be read from
        :type address: int
        :param read_reg_addr_size: Register address size in bytes
        :type read_reg_addr_size: int
        :param args: Additional positional arguments
        :type args: Any
        :param read_cap_wfm_name: SDA capture waveform name [Default: i2c_cap]
        :type read_cap_wfm_name: str
        :param read_src_wfm_name: SDA source waveform name [Default: i2c_src_read]
        :type read_src_wfm_name: str
        :param read_src_wfm_size: SDA source waveform memory size in bytes [Default: 6]
        :type read_src_wfm_size: str
        :param read_pattern: Name of the pattern to burst [Default: i2c_read]
        :type read_pattern: str
        :param check_ack: Check for I2C Acknowledgements? [Default: True]
        :type check_ack: bool
        :param kwargs: Additional keyword arguments
        :type kwargs: Any
        :return: List of bytes read or transaction error code
        :rtype: List[int] | int
        """
        # Create data for pattern
        source_data = [address << 1]
        for byte_number in range(read_reg_addr_size-1, -1, -1):
            next_byte = reg_addr & 255 << (byte_number*8)
            source_data.append(next_byte >> (byte_number*8))  # MSB 8 bits
        source_data.append((address << 1) + 1)  # dev_id + rw bit: 1 (Read)
        self.__pad_source(source_data, read_src_wfm_size)

        self.nidigpat.write_sequencer_register(self.nidigpat.enums.SequencerRegister.REGISTER0, read_reg_addr_size)

        # Set flag if byte_count is 1
        if byte_count == 1:
            self.nidigpat.write_sequencer_flag(seq_flag=self.nidigpat.enums.SequencerFlag.FLAG0, value=True)
        else:
            self.nidigpat.write_sequencer_flag(seq_flag=self.nidigpat.enums.SequencerFlag.FLAG0, value=False)
            self.nidigpat.write_sequencer_register(self.nidigpat.enums.SequencerRegister.REGISTER1, byte_count-1)
        self.nidigpat.write_source_waveform_broadcast(read_src_wfm_name, source_data)
        self.nidigpat.burst_pattern(read_pattern)
        capture_data = self.nidigpat.fetch_per_site_wfm(read_cap_wfm_name, byte_count)
        if check_ack and not self.check_i2c_ack(address):
            return -6

        return np.asarray(capture_data[0]).tolist()

    def i2c_scan(self, read_src_wfm_name: str='i2c_src_read', read_src_wfm_size: int=6, scan_pattern: str='i2c_scan',   # pylint: disable=arguments-differ
                 **kwargs) -> List[str]:
        """
        Checks the I2C bus and returns a list present device addresses. Assumes pattern only checks for single address
         and reuses the read source waveform for the address.

        :param read_src_wfm_name: SDA source waveform name [Default: i2c_src_read]
        :type read_src_wfm_name: str
        :param read_src_wfm_size: SDA source waveform memory size in bytes [Default: 6]
        :type read_src_wfm_size: int
        :param scan_pattern: Name of pattern to burst
        :type scan_pattern: str
        :param kwargs: Additional keyword arguments
        :type kwargs: Any
        :return: List of hexadecimal I2C addresses on the bus (i.e. ['0x70', '0x82'])
        :rtype: List[str]
        """
        devices = []
        for address in range(128):
            source_data = [(address << 1) + 1]
            self.__pad_source(source_data, read_src_wfm_size)
            self.nidigpat.write_source_waveform_broadcast(read_src_wfm_name, source_data)
            self.nidigpat.burst_pattern(scan_pattern)
            if self.check_i2c_ack(address, log_error=False):
                devices.append(hex(address))
        return devices

    def check_i2c_ack(self, address, log_error=True):
        """
        Check HSD pass/fail to check that acknowledgements have occurred properly in the pattern

        :param address: I2C address written to, only used in error message
        :type address: int
        :param log_error: log an error if the device NACKs [Default: True]
        :type log_error: bool
        :return: Pattern Pass/Fail
        :rtype: bool
        """
        ack = self.nidigpat.get_pass_fail()
        if not ack and log_error:
            self.log.error(f'The device at address: {hex(address)} did not ack')
        return ack

    def configure_spi_waveforms(self, sdi_pin: str, sdo_pin: str, spi: SpiInterface):
        """
        Configures required SPI source and capture waveforms. Set to use 8 bit MSB broadcasted serial samples.

        :param sdi_pin: DUT SPI SDI pin name
        :type sdi_pin: str
        :param sdo_pin: DUT SPI SDO pin name
        :type sdo_pin: str
        :param spi: SPI interface for the pins to get the source and capture waveform names used
        :type spi: SpiInterface
        :return: None
        :rtype: None
        """
        # Fill missing fields with defaults
        cap_wfm_name = getattr(spi, 'cap_wfm_name', 'spi_read')
        src_wfm_name = getattr(spi, 'src_wfm_name', 'spi_write')
        # Configure waveforms
        self.nidigpat.create_capture_waveform_serial(sdo_pin, cap_wfm_name, 8, self.nidigpat.enums.BitOrder.MSB)
        self.nidigpat.create_source_waveform_serial(sdi_pin, src_wfm_name, self.nidigpat.enums.SourceDataMapping.BROADCAST,
                                                    8, self.nidigpat.enums.BitOrder.MSB)

    def spi_fd(self, bytes_out: List[int], *args, cap_wfm_name: str='spi_read', src_wfm_name: str='spi_write',  # pylint: disable=arguments-differ
               src_wfm_size: int=12, pattern: str='spi_fd', **kwargs) -> List[int]:
        """
        Issues a dull-duplex transfer, sending bytes in 'bytes_out' out to SDI/MOSI and returning bytes read from SDO/MISO.
        Uses HSD Reg0 to set number of bits in SPI frame. Expects every frame bit to be captured.


        :param bytes_out: Bytes to be transferred over SDI/MOSI
        :type bytes_out: List[int]
        :param args: Additional positional arguments
        :type args: Any
        :param cap_wfm_name: SDO capture waveform name [Default: spi_read]
        :type cap_wfm_name: str
        :param src_wfm_name: SDI source waveform name [Default: spi_write]
        :type src_wfm_name: str
        :param src_wfm_size: SDI source waveform memory size in bytes [Default: 12]
        :type src_wfm_size: int
        :param pattern: Name of pattern to burst [Default: spi_fd]
        :type pattern: str
        :param kwargs: Additional keyword arguments
        :type kwargs: Any
        :return: Bytes captured from SDO/MISO during transaction
        :rtype: List[int]
        """
        # Set length of pattern
        num_bytes = len(bytes_out)
        self.nidigpat.write_sequencer_register(self.nidigpat.enums.SequencerRegister.REGISTER0, num_bytes * 8)

        # Run pattern
        self.__pad_source(bytes_out, src_wfm_size)
        self.nidigpat.write_source_waveform_broadcast(src_wfm_name, bytes_out)
        self.nidigpat.burst_pattern(pattern)

        # Get captured data and return
        capture_data = self.nidigpat.fetch_per_site_wfm(cap_wfm_name, num_bytes)
        return np.asarray(capture_data[0]).tolist()

    def configure_hcc_waveforms(self, sdi_pin: str, sdo_pin: str, hcc: HccInterface):
        """
        Configures required HCC source and capture waveforms. Set to use 8 bit LSB broadcasted serial samples.

        :param sdi_pin: DUT SPI SDI pin name
        :type sdi_pin: str
        :param sdo_pin: DUT SPI SDO pin name
        :type sdo_pin: str
        :param spi: HCC interface for the pins to get the source and capture waveform names used
        :type spi: HccInterface
        :return: None
        :rtype: None
        """
        # Fill missing fields with defaults
        cap_wfm_name = getattr(hcc, 'cap_wfm_name', 'hcc_read')
        src_wfm_name = getattr(hcc, 'src_wfm_name', 'hcc_write')
        # Configure waveforms
        self.nidigpat.create_capture_waveform_serial(sdo_pin, cap_wfm_name, 8, self.nidigpat.enums.BitOrder.LSB)
        self.nidigpat.create_source_waveform_serial(sdi_pin, src_wfm_name, self.nidigpat.enums.SourceDataMapping.BROADCAST,
                                                    8, self.nidigpat.enums.BitOrder.LSB)

    def hcc_send_packet(self, packet: List[int], cap_wfm_name: str='hcc_read', src_wfm_name: str='hcc_write',
                        src_wfm_size: int=24, pattern: str='hcc_spi', **kwargs) -> List[int]:
        """
        Send out the HCC packet using the SPI Full-duplex call

        :param packet: Bytes to be transferred over SDI/MOSI
        :type packet: List[int]
        :param cap_wfm_name: SDO capture waveform name [Default: hcc_read]
        :type cap_wfm_name: str
        :param src_wfm_name: SDI source waveform name [Default: hcc_write]
        :type src_wfm_name: str
        :param src_wfm_size: SDI source waveform memory size in bytes [Default: 24]
        :type src_wfm_size: int
        :param pattern: Name of pattern to burst [Default: hcc_spi]
        :type pattern: str
        :param kwargs: Additional keyword arguments
        :type kwargs: Any
        :return: Bytes captured from SDO/MISO during transaction
        :rtype: List[int]
        """
        return self.spi_fd(packet, cap_wfm_name=cap_wfm_name, src_wfm_name=src_wfm_name, src_wfm_size=src_wfm_size,
                           pattern=pattern, **kwargs)

    def configure_spmi_waveforms(self, pin: str, spmi: SpmiInterface):
        """
        Configures the required SPMI source and capture wavforms. Source set to use 9-bit MSB broadcasted serial samples.
        Capture configured to 8-bit MSB samples.

        :param pin: DUT pin name
        :type pin: str
        :param spmi: SPMI Interface for the pin to get the source and capture waveform names used
        :type spmi: SpmiInterface
        :return: None
        :rtype: None
        """
        # Fill missing fields with defaults
        cap_wfm_name = getattr(spmi, 'cap_wfm_name', 'spmi_cap')
        src_wfm_name = getattr(spmi, 'src_wfm_name', 'spmi_src')
        # Configure waveforms
        self.nidigpat.create_capture_waveform_serial(pin, cap_wfm_name, 8, self.nidigpat.enums.BitOrder.MSB)
        self.nidigpat.create_source_waveform_serial(pin, src_wfm_name, self.nidigpat.enums.SourceDataMapping.BROADCAST,
                                                    9, self.nidigpat.enums.BitOrder.MSB)

    def spmi_extended_register_write_long(self, address: int, write_data: List[int], write_pattern: str ='spmi_singleWrite',
                                          src_wfm_name: str='spmi_src', src_wfm_size: int=6, **kwargs):
        """
        Sends extended register write long (ERWL) SPMI command

        :param address: 16-bit register address to write
        :type address: int
        :param write_data: List of bytes to write up to 8 bytes
        :type write_data: List[int]
        :param write_pattern: Name of pattern to burst [Default: spmi_singleWrite]
        :type write_pattern: str
        :param src_wfm_name: Source waveform name [Default: spmi_src]
        :type src_wfm_name: str
        :param src_wfm_size: Size of the source waveform in bytes [Default: 6]
        :type src_wfm_size: int
        :param kwargs: Keyword arguments
        :type kwargs: Any
        :return: None
        :rtype: None
        """
        # Add parity and pad to size
        source_data = self.__address_to_list(address, 2)
        source_data.extend(write_data)
        source_data = self.__add_parity(source_data)
        source_data = self.__pad_source(source_data, src_wfm_size)
        # Burst pattern
        self.nidigpat.write_source_waveform_broadcast(src_wfm_name, source_data)
        self.nidigpat.burst_pattern(write_pattern)

    def spmi_extended_register_read_long(self, address: int, length: int, read_pattern: str='spmi_singleRead',
                                         cap_wfm_name: str='spmi_cap', src_wfm_name: str='spmi_src',
                                         src_wfm_size: int=6, **kwargs):
        """
        Sends extended register read long (ERRL) command

        :param address: 16-bit register address to read
        :type address: int
        :param length: Bytes to read up to 8 bytes
        :type length: int
        :param read_pattern: Name of pattern to burst [Default: spmi_singleRead]
        :type read_pattern: str
        :param cap_wfm_name: Capture waveform name [Default: spmi_cap]
        :type cap_wfm_name: str
        :param src_wfm_name: Source waveform name [Default: spmi_src]
        :type src_wfm_name: str
        :param src_wfm_size: Size of the source waveform in bytes [Default: 6]
        :type src_wfm_size: str
        :param kwargs: Keyword arguments
        :type kwargs: Any
        :return: List of read bytes
        :rtype: List[int]
        """
        # Add parity and pad to size
        source_data = self.__address_to_list(address, 2)
        source_data = self.__add_parity(source_data)
        source_data = self.__pad_source(source_data, src_wfm_size)
        # Burst pattern
        self.nidigpat.write_source_waveform_broadcast(src_wfm_name, source_data)
        self.nidigpat.burst_pattern(read_pattern)
        # Retrieve data to return
        capture_data = self.nidigpat.fetch_per_site_wfm(cap_wfm_name, length)
        return np.asarray(capture_data[0]).tolist()

    @staticmethod
    def __add_parity(data: List[int]):
        """
        Calculates and appends parity bit for each byte

        :param data: List of bytes
        :type data: List[int]
        :return: Parityed bytes
        :rtype: List[int]
        """
        for _index, _value in enumerate(data):
            binary = bin(_value)[2:]
            count = 0
            for i in binary:
                if i == '1':
                    count = count + 1

            if count % 2 == 0:
                data[_index] = _value * 2 + 1
            else:
                data[_index] = _value * 2

        return data

    @staticmethod
    def __address_to_list(value: int, byte_length: int) -> List[int]:
        """
        Converts address to list bytes

        :param value: Address to split into bytes
        :type value: int
        :param byte_length: Number of bytes in address
        :type byte_length: int
        :return: List of address bytes
        :rtype: List[int]
        """
        hex_string = hex(value)[2:].zfill(byte_length*2)
        output = []
        while len(hex_string) > 0:
            output.append(int(hex_string[:2], 16))
            hex_string = hex_string[2:]
        return output

    @staticmethod
    def __pad_source(data: list, length: int):
        """
        Pads end of given list to maintain a constant source waveform size that the HSD requires. Also verifies data is
        not over sized for the defined source waveform memory.

        :param data: Source data to pad
        :type data: List[int]
        :param length: Source waveform length
        :type length: int
        :return: Padded list of source data
        :rtype: List[int]
        """
        # Verify data size
        data_size = len(data)
        if data_size > length:
            raise ValueError(f'Attempting to write {data_size} bytes is longer than the defined source memory of '
                             f'{length} bytes')
        # Pad data as needed
        data.extend([0] * (length - data_size))
        return data
