"""
Module for JLink controller class.
Author: Evan Canter <evan.canter@cirrus.com>
"""
import logging
import math
from typing import Union, List

from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.interfaces.ctrl_interface import ByteOrder, CtrlInterfaceError
from cl_test_station.interfaces.ctrl_interface import map_words_to_bytes, build_words_from_bytes
from cl_test_station.pyro_support.pyro_transmitter import internal_transmitter
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.reusables import read_enum_value
from enum import Enum
from pylink import JLink
from pylink.enums import JLinkInterfaces as PyLinkInterfaces
try:
    from unified_modules.resources.resource_data_lib.resource_data_lib import ResourceDataLib as DataLib
    DATALIB_PRESENT = True
except ImportError:
    logging.warning("Failed to import DataLib from Unified Modules - Legacy ST code will be unavailable")
    DATALIB_PRESENT = False


class JLinkInterfaces(Enum):
    """Enum that converts pylink.enums into an Enum class"""
    JTAG = PyLinkInterfaces.JTAG
    SWD = PyLinkInterfaces.SWD
    FINE = PyLinkInterfaces.FINE
    ICSP = PyLinkInterfaces.ICSP
    SPI = PyLinkInterfaces.SPI
    C2 = PyLinkInterfaces.C2


@internal_transmitter('handle')
class JLinkController(HostController):
    """
    Controller for Segger JLink.

    **NOTE:** JLink Software and Documentation Pack is required to control the JLink with python. This class was tested
    with V7.66g. Download from the segger website: https://www.segger.com/downloads/jlink/
    """
    handle: JLink = None
    serial_number: int = TsoField(ftype=int, desc="Serial number of JLink")
    target_name: str = TsoField(ftype=str, desc="Chip name to connect to.")
    target_auto_connect: bool = TsoField(ftype=bool, required=False, default=True,
                                         desc="In connect(), will open the JLink and then attempt to connect"
                                              "to target specified in 'target_name'")
    default_target_interface: JLinkInterfaces = TsoField(ftype=str, required=False, default=JLinkInterfaces.SWD,
                                                         desc="JLink target interface to use upon connection. Can be "
                                                              "JTAG, SWD, FINE, ICSP, SPI, or C2. Defaults to SWD.",
                                                         cast_type=JLinkInterfaces)
    suppress_console_prints: bool = TsoField(ftype=bool, required=False, default=False,
                                             desc="Moves JLink commander console output to DEBUG level")

    def __init__(self, *args, handle=None, **kwargs):
        super().__init__(*args, **kwargs)
        # Local controller, create JLink connection
        if handle is None:
            self.init_jlink()
        else:  # Handle was passed in (Pyro)
            self.handle = handle
        if DATALIB_PRESENT:
            self.data_lib = DataLib()

    def init_jlink(self):
        # Attempt to launch JLink commander
        try:
            self.handle = JLink()
        except TypeError as type_err:
            err_msg = "JLink Software and Documentation Pack is required to control the JLink with python: " \
                      "https://www.segger.com/downloads/jlink/"
            raise SystemError(err_msg) from type_err
        # Logging for the connection process happens at INFO by default, need to condition based on TSO Field
        log_func = self.log.dev if self.suppress_console_prints else self.log.info
        # Redirect logging functions to use TS Logger
        self.handle.error_handler        = lambda msg: self.log.error(msg.decode('UTF-8'))
        self.handle.warning_handler      = lambda msg: self.log.warning(msg.decode('UTF-8'))
        self.handle.log_handler          = lambda msg: log_func(msg.decode('UTF-8'))
        self.handle.detailed_log_handler = lambda msg: msg

    def isConnected(self) -> bool:
        # TODO: PLATDEV-1080 Remove in 2.0.0 since isConnected is deprecated
        return self.is_connected()

    def is_connected(self) -> bool:
        return all([self.handle is not None,
                   self.handle.connected(),
                   self.handle.target_connected()])

    def connect_to_target(self, chip_name: str = None, tif: Union[JLinkInterfaces, str] = None, **kwargs):
        """
        Calls the 'connect' JLink command to connect to device 'chip_name'. Before connecting, sets the target interface
        to 'tif' (if specified) or the default target interface.

        :param chip_name: Name of target, e.g. CORTEX-M4
        :type chip_name: str
        :param tif: Target interface, e.g. JLinkInterfaces.SWD or 'JTAG'
        :type tif: JLinkInterfaces | str
        :param kwargs: Arguments that can be passed into the pylink call:
            * speed (int | str) : Connection speed, one of {5-12000, 'auto', 'adaptive'}
            * verbose (bool): Boolean indicating if connection should be verbose in logging
        :return: None
        :rtype: None
        """
        if not self.handle.connected():  # USB Connection required to connect to target
            raise ConnectionError("JLink needs to be connected to PC first before connecting to target. Use connect()")
        # If parameters aren't given, use defaults from TSO Fields
        if chip_name is None:
            chip_name = self.target_name
        if tif is None:
            tif = self.default_target_interface
        # Need to set interface before connecting to target
        self.log.debug(f"Setting TIF to {tif}")
        self.target_interface = tif
        # Launches an active connection with the core
        self.handle.connect(chip_name, **kwargs)

    def connect(self):
        if self.serial_number:
            if not self.handle.connected():
                self.handle.open(self.serial_number)  # Connects to JLink via USB
                if not self.handle.connected():
                    self.init_jlink()
                    self.handle.open(self.serial_number)  # Connects to JLink via USB
            if self.target_auto_connect and not self.handle.target_connected():  # Connect to target immediately
                self.connect_to_target()  # Connects using chip name from target_name TSO field
        else:
            self.log.warning("No serial number was given, cannot connect. "
                             "All functions that require a connection will be unavailable.")

    def disconnect(self):
        self.handle.close()

    # # ----- JLink configuration ----- # #

    @property
    def target_interface(self) -> JLinkInterfaces:
        """
        Returns the configured JLink target interface for current and future target connections.

        :return: Jlink interface
        :rtype: JLinkInterfaces
        """
        return JLinkInterfaces(self.handle.tif)

    @target_interface.setter
    def target_interface(self, target_iface: Union[JLinkInterfaces, str]):
        """
        Sets the JLink's target interface. If the interface is changed while a connection is active, the connection
        will be closed. If the desired target interface is already the configured interface, no action will be done.

        :param target_iface: Target interface to use, e.g. JLinkInterfaces.SWD, or 'JTAG'
        :type target_iface: JLinkInterfaces | str
        :return: None
        :rtype: None
        """
        if type(target_iface) is str:
            target_iface = read_enum_value(target_iface, JLinkInterfaces)
        if target_iface.value != self.handle.tif:  # Need to change TIF
            if self.is_connected():  # Changing TIF will close the connection, warn user
                self.log.warning(f"Changing target interface from {JLinkInterfaces(self.handle.tif).name} to"
                                 f" {target_iface.name}, target will be disconnected.")
            self.handle.set_tif(target_iface.value)
        else:
            self.log.debug(f"Target interface already set to {target_iface.name}")

    @property
    def speed(self) -> int:
        """
        Returns JTAG speed currently configured. If the desired speed is already the configured speed, no action will
        be done.

        :return: JTAG speed in Hz
        :rtype: int
        """
        return self.handle.speed * 1000

    @speed.setter
    def speed(self, speed: int):
        """
        Sets the JLink's JTAG speed. Given speed can only be in kHz denominations. Any value that isn't will be rounded.

        :param speed: JTAG speed in Hz
        :type speed: int
        :return: None
        :type: None
        """
        speed_khz = speed // 1000  # JLink takes values in kHz
        if speed_khz * 1000 != speed:  # Requested speed, won't be accurate, warn user
            self.log.warning(f"JLink only supports speeds in kHz denominations. Rounding {speed}Hz to {speed_khz}kHz")
        if self.handle.speed != speed_khz:  # Only set speed if it needs to be changed
            self.handle.set_speed(speed_khz)
        else:
            self.log.dev(f"JTAG speed already set to {speed_khz}kHz")

    # # ----- Interface functions ----- # #

    def swd_read(self, address: int, byte_count: int, read_reg_data_size: int,
                 data_byte_order: Union[ByteOrder, int], speed: int, **kwargs) -> List[int]:
        """
        Performs SWD memory access through the memory_read JLink commander function. Returns list of bytes read from
        the device.

        :param address: Register address
        :type address: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param read_reg_data_size: Size of register in bytes
        :type read_reg_data_size: int
        :param data_byte_order: Word byte order
        :type data_byte_order: ByteOrder | int
        :param speed: Speed in Hz of transfer
        :type speed: int
        :return: List of bytes read
        :rtype: List[int]
        """
        # Check JLink TIF is set to SWD
        if self.target_interface is not JLinkInterfaces.SWD:
            raise CtrlInterfaceError(f"Connection to {self.handle.core_name()} is through {self.target_interface.name},"
                                     f" set target_interface to SWD and reconnect before attempting swd_read()")
        if byte_count % read_reg_data_size:  # Can only read word-aligned blocks
            raise ValueError(f"byte_count ({byte_count}) must be divisible by read_reg_data_size ({read_reg_data_size})")
        # Make sure byte order is the Enum type
        if type(data_byte_order) is int:
            data_byte_order = ByteOrder(data_byte_order)
        elif type(data_byte_order) is not ByteOrder:
            raise TypeError(f"data_byte_order can be of type int or ByteOrder, not {type(data_byte_order)}")
        # Set speed using interface field
        self.speed = speed
        words_in = self.handle.memory_read(address, num_units=byte_count // read_reg_data_size, nbits=read_reg_data_size<<3)
        return map_words_to_bytes(words_in, read_reg_data_size, data_byte_order)

    def swd_write(self, address: int, bytes_out: List[int], write_reg_data_size: int,
                  data_byte_order: Union[ByteOrder, int], speed: int, **kwargs):
        """
        Performs SWD memory access through the memory_write JLink commander function.

        :param address: Register address
        :type address: int
        :param bytes_out: Bytes to write
        :type bytes_out: list
        :param write_reg_data_size: Size of register in bytes
        :type write_reg_data_size: int
        :param data_byte_order: Word byte order
        :type data_byte_order: ByteOrder | int
        :param speed: Speed in Hz of transfer
        :type speed: int
        :return: None
        :rtype: None
        """
        # Check JLink TIF is set to SWD
        if self.target_interface is not JLinkInterfaces.SWD:
            raise CtrlInterfaceError(f"Connection to {self.handle.core_name()} is through {self.target_interface.name},"
                                     f" set target_interface to SWD and reconnect before attempting swd_write()")
        # Check size of byte list
        if len(bytes_out) % write_reg_data_size:
            raise ValueError(f"Length of bytes_out ({len(bytes_out)}) must be divisible by write_reg_data_size ({write_reg_data_size})")
        # Make sure byte order is the Enum type
        if type(data_byte_order) is int:
            data_byte_order = ByteOrder(data_byte_order)
        elif type(data_byte_order) is not ByteOrder:
            raise TypeError(f"data_byte_order can be of type int or ByteOrder, not {type(data_byte_order)}")
        # Build words for armdbg expression; memory_set can only take words
        words_out = build_words_from_bytes(bytes_out, write_reg_data_size, data_byte_order)
        # Set speed using interface field
        self.speed = speed
        self.handle.memory_write(address, data=words_out, nbits=write_reg_data_size<<3)

    # # ----- HostController abstract functions ----- # #

    # TODO: PLATDEV-1079 Remove these once HostController base classes are restructured
    def read_i2c_reg(self, *args, **kwargs):
        raise NotImplementedError("I2C is not supported on DStream")

    def write_i2c_reg(self, *args, **kwargs):
        raise NotImplementedError("I2C is not supported on DStream")

    def spi_fd(self, *args, **kwargs):
        raise NotImplementedError("SPI is not supported on DStream")

    #  -----------------------------
    # TODO: Project specific ST code
    #  -----------------------------

    def write_to_memory(self, address, data, word_length=8):
        """
        Write to memory at the specified address
        :param address: Register or memory address
        :param data: Value or list of values to be written in memory
        :param word_length: number of bits per word for write operation: 8, 16 or 32
        :return None
        """
        if not isinstance(data, list):
            data = [data]
        # Call the respective memory_write_X based on the input word length
        getattr(self.handle, f'memory_write{word_length}')(address, data)

    def read_from_memory(self, address, words_to_read=1, word_length=8):
        """
        Write to memory at specified address
        :param address: Register or memory address
        :param words_to_read: Number of words to read
        :param word_length: number of bits per word for write operation: 8, 16 or 32
        :return Returns a array of words read
        """
        if word_length == 8:
            words_to_read_32 = int(math.ceil(words_to_read / 4.0))
            extra_bytes = (words_to_read % 4)
            word_list = self.handle.memory_read32(address, words_to_read_32)
            word_list = self.data_lib.convert_words_to_bytes(word_list, 4)
            if extra_bytes:
                del word_list[-(4 - extra_bytes):]
        elif word_length == 16:
            word_list = self.handle.memory_read16(address, words_to_read)
        elif word_length == 32:
            word_list = self.handle.memory_read32(address, words_to_read)
        else:
            raise NotImplementedError(f'SWD only supports 8, 16 or 32-bit words. Provided {word_length} word length')

        if len(word_list) == 1:
            return word_list[0]
        else:
            return word_list

    def reset(self):
        """
        Make a Physical reset of the MCU using SWD instruction
        """
        import time
        self.handle.reset(halt=False)
        time.sleep(0.1)

    #  -----------------------------
