# Note: i2c_bus is only for interfaces with multiple i2c buses, i.e. CirrusLink and AudioHub

from array import array

from .Promira_ import promira_wrap as wrap
from .Promira_ import promira_app as app
from .common import intList_to_byteArray, byteArray_to_intList
from typing import List, Tuple

# TODO review
DEFAULT_I2C_SPEED = 100      # 100 kHz
DEFAULT_SPI_SPEED = 1000     # 1 MHz
DEFAULT_LOGIC_LEVEL = 3.3    # 3.3 V
MAX_NUM_PROMIRAS = 10
DEFAULT_SPI_MODE = app.PS_SPI_IO_STANDARD  # Standard, full-duplex SPI


class Promira:
    """Python driver for the Promira controller"""
    def __init__(self, i2c_speed=DEFAULT_I2C_SPEED, spi_speed=DEFAULT_SPI_SPEED, logic_level=DEFAULT_LOGIC_LEVEL, serial_num=None, **kwargs):  # TODO review
        self.handle = None
        self.conn = None
        self.channel = None
        self.net_addr = None
        self.i2c_queue = None
        self.spi_queue = None
        self.logic_level = logic_level
        # The line below allows tests direct access to the api's e.g. ...
        # devid = promira.wrap.pm_find_devices(num_devices)
        # OR
        # devid = promira.app.ps_i2c_write_read(channel, ...)
        self.wrap = wrap
        self.app = app
        self.open(i2c_speed, spi_speed, serial_num)
        # Maximum bytes Promira can support per single block I2C transaction (64 KiB)
        self.i2c_byte_limit = 0xFFFF
        # Maximum bytes Promira can support per single block SPI transaction (1 MB)
        self.spi_byte_limit = 0xFFFFF

    def open(self, i2c_speed=DEFAULT_I2C_SPEED, spi_speed=DEFAULT_SPI_SPEED, serial_num=None): # TODO review
        [num_devices, device_ports, device_serial_nums, device_statuses] = wrap.pm_find_devices_ext(MAX_NUM_PROMIRAS, MAX_NUM_PROMIRAS, MAX_NUM_PROMIRAS)
        if num_devices == 0:
            raise Exception("No Promira devices found!")

        # Either pick the first available Promira or an Promira with a specific serial number
        if serial_num is not None:
            specific_promira_found = False
            for i in range(num_devices):
                if device_serial_nums[i] == serial_num:
                    specific_promira_found = True
                    port = device_ports[i]
            if not specific_promira_found:
                raise Exception("Cannot connect to Promira device with serial number %d" % serial_num)

            self.net_addr = "{3}.{2}.{1}.{0}".format(*(byte for byte in intList_to_byteArray([port], 4)))
            self.handle = wrap.pm_open(self.net_addr)
            if self.handle < 0:
                raise Exception("Cannot connect to Promira device. Make sure it is not used in another software, "
                                "e.g. WISCE.")
        else:
            # TODO what is this for?
            # Calculate number of available Promiras
            #num_available_promiras = 0
            #for port in device_ports:
            #    if not (0x8000 & port):
            #        num_available_promiras += 1
            #        available_port = port

            if num_devices == 0:
                raise Exception("No free promiras available to connect to. Make sure Promiras aren't currently being "
                                "used by other software such as WISCE")
            if num_devices > 1:
                raise Exception("Multiple Promiras available. Disconnect extra Promiras or specify a particular "
                                "Promira using serial_num argument e.g. promira = Promira(serial_num=2238289415)")

            port = device_ports[0]
            self.net_addr = "{3}.{2}.{1}.{0}".format(*(byte for byte in intList_to_byteArray([port], 4)))
            self.handle = wrap.pm_open(self.net_addr)
            if self.handle < 0:
                raise Exception("Cannot connect to Promira device")

        self.app_connect(i2c_speed, spi_speed)

    def app_connect(self, i2c_speed, spi_speed):
        # Load I2C/SPI application
        app_name = 'com.totalphase.promact_is'
        if wrap.pm_load(self.handle, app_name) < 0:
            raise Exception("Error loading {} application for Promira. Installed apps are: {}".format(app_name, self.get_licensed_apps()))

        self.conn = app.ps_app_connect(self.net_addr)
        if self.conn < 0:
            raise Exception("Cannot establish connection to I2C/SPI application for Promira")

        # Open channel
        self.channel = app.ps_channel_open(self.conn)
        if self.channel < 0:
            raise Exception("Cannot open a Promira channel for I2C/SPI")

        app.ps_app_configure(self.channel, app.PS_APP_CONFIG_I2C | app.PS_APP_CONFIG_SPI)  # Enable both I2C and SPI
        app.ps_phy_level_shift(self.channel, self.logic_level)  # Set logic level
        app.ps_phy_target_power(self.channel, app.PS_PHY_TARGET_POWER_BOTH)  # Set target power

        app.ps_i2c_bitrate(self.channel, i2c_speed)
        app.ps_i2c_pullup(self.channel, app.PS_I2C_PULLUP_BOTH)

        app.ps_spi_bitrate(self.channel, spi_speed)
        ss_polarity = 0  # active low
        app.ps_spi_configure(self.channel, app.PS_SPI_MODE_0, app.PS_SPI_BITORDER_MSB, ss_polarity)

    def set_i2c_speed(self, i2c_speed):
        """
            i2c_speed: bitrate_khz
        """
        self.i2c_speed = i2c_speed
        app.ps_i2c_bitrate(self.channel, i2c_speed)

    def set_spi_speed(self, spi_speed):
        """
            spi_speed: bitrate_khz
        """
        self.spi_speed = spi_speed
        app.ps_spi_bitrate(self.channel, spi_speed)

    def get_i2c_speed(self):
        """
            i2c_speed: bitrate_khz
        """
        return app.ps_i2c_bitrate(self.channel, 0)

    def get_spi_speed(self):
        """
            spi_speed: bitrate_khz
        """
        return app.ps_spi_bitrate(self.channel, 0)

    def set_logic_level(self, logic_lvl: float = DEFAULT_LOGIC_LEVEL) -> float:
        """
        Sets logic high level.

        :param logic_lvl: Desired logic level
        :type logic_lvl: float
        :return: Value
        :rtype: float
        """
        self.logic_level = logic_lvl
        return app.ps_phy_level_shift(self.channel, logic_lvl)

    def __del__(self):
        self.close()

    def close(self):
        """
        Closes Promira app

        :return: None
        :rtype: None
        """
        app.ps_channel_close(self.channel) if self.channel else None  # TODO added
        app.ps_app_disconnect(self.conn) if self.conn else None  # TODO added
        wrap.pm_close(self.handle)

    def get_licensed_apps(self):
        """Get licensed Apps"""
        num_apps, apps = wrap.pm_licensed_apps(self.handle, 200)  # Number 200 must be larger than char length of apps
        apps_list = ""
        for char in apps:
            apps_list += "%c" % char
        return apps_list.split(sep=":")

    def set_i2c_pullup(self, pullup_mask: bool = True):
        """
        Sets Promira's I2C pullup value Enum.

        :param pullup_mask: Flag that indicates whether to use Pullups or not. When True, uses both. When False, uses none
        :type pullup_mask: bool
        :return: None
        :rtype: None
        """
        if pullup_mask:
            app.ps_i2c_pullup(self.handle, app.PS_I2C_PULLUP_BOTH)
        else:
            app.ps_i2c_pullup(self.handle, app.PS_I2C_PULLUP_NONE)

    def get_i2c_pullup(self) -> int:
        """
        Queries the Promira and returns the currently configured value of the pullup Enum
        :return: Integer
        :rtype: int
        """
        return app.ps_i2c_pullup(self.handle, app.PS_I2C_PULLUP_QUERY)

    # TODO: PLATDEV-1161 fix headers
    def i2c_write(self, i2c_addr, reg_addr, wdata, addr_width, data_width, i2c_bus=0):
        """
        Performs I2C block write.

        :param i2c_addr: Device address
        :type i2c_addr: int
        :param reg_addr: register address
        :type reg_addr: int
        :param wdata: write data
        :type wdata: int
        :return: None
        :rtype: None
        """
        self.i2c_block_write(i2c_addr, reg_addr, [wdata], addr_width, data_width, i2c_bus)

    def i2c_read(self, i2c_addr, reg_addr, addr_width, data_width, i2c_bus=0):
        """
        Performs I2C block read.

        :param i2c_addr: Device address
        :type i2c_addr: int
        :param reg_addr: register address
        :type reg_addr: int
        :return: List of bytes read
        :rtype: List[int]
        """
        return self.i2c_block_read(i2c_addr, reg_addr, 1, addr_width, data_width, i2c_bus)[0]

    def i2c_block_write(self, i2c_addr, waddr, wdata):
        """
        Performs I2C block write.

        :param i2c_addr: Device address
        :type i2c_addr: int
        :param reg_addr: register address
        :type reg_addr: int
        :param wdata: write data
        :type wdata: int
        :return: None
        :rtype: None
        """
        (ret_code, num_written) = app.ps_i2c_write(self.channel, i2c_addr, app.PS_I2C_NO_FLAGS, waddr + wdata)
        if ret_code != 0:
            raise IOError("I2C Write Error", (ret_code, num_written))

    # def i2c_block_read(self, i2c_addr, first_reg_addr, num_regs, addr_width, data_width, i2c_bus=0):
    def i2c_block_read(self, i2c_addr, raddr, byte_count):
        """
        Performs I2C block read.

        :param i2c_addr: Device address
        :type i2c_addr: int
        :param reg_addr: register address
        :type reg_addr: int
        :return: List of bytes read
        :rtype: List[int]
        """
        # data_out = intList_to_byteArray([first_reg_addr], addr_width)     # Bytes to be written
        # size_bytes = num_regs * data_width
        in_data = self.i2c_queue_transaction(i2c_addr, byte_count, raddr)
        # values_returned = byteArray_to_intList(in_data, data_width)

        return list(in_data)

    # I2C read transfer with Promira queue mechanism
    # This is to add both the write & read in the same queue and submit these at the same time to reduce this latency
    def i2c_queue_transaction(self, i2c_addr, size_bytes, data_out):
        """Place Holder"""
        in_data = array('B', [0] * size_bytes)
        data_in = array('B', [0] * size_bytes)

        # Create and clear queue for SPI transactions #TODO review
        if not self.i2c_queue:
            self.i2c_queue = app.ps_queue_create(self.conn, app.PS_MODULE_ID_I2C_ACTIVE)
        app.ps_queue_clear(self.i2c_queue)
        app.ps_queue_i2c_write(self.i2c_queue, i2c_addr, app.PS_I2C_NO_STOP, data_out)
        app.ps_queue_i2c_read(self.i2c_queue, i2c_addr, app.PS_I2C_NO_FLAGS, size_bytes)
        app.ps_queue_sync(self.i2c_queue)
        collect, _ = app.ps_queue_submit(self.i2c_queue, self.channel, 0)
        if collect == app.PS_APP_CONNECTION_LOST:
            print("RECONNECTING APP *********************")
            self.app_connect(0, 0)
            collect, _ = app.ps_queue_submit(self.i2c_queue, self.channel, 0)
        elif collect < 0:
            raise IOError("Error submitting I2C write command queue (Error Code %d)" % collect)
        ret_val = None
        timeout = 999
        while ret_val != app.PS_APP_NO_MORE_CMDS_TO_COLLECT:
            if timeout < 0:
                raise IOError("Error: Timeout reached in collecting SPI response")
            timeout -= 1
            ret_val, _, _ = app.ps_collect_resp(collect, timeout=20)
            if ret_val == app.PS_I2C_CMD_READ:
                ret_code, _, in_data = app.ps_collect_i2c_read(collect, data_in)
                # Note: in_data and data_in have exactly the same values
                if ret_code != 0:
                    raise IOError("I2C Read Error", (ret_code, in_data))
        # app.ps_queue_destroy(self.i2c_queue)  # not using this since it causes invalid handle issue
        return data_in

    def spi_write(self, cs, reg_addr, wdata, addr_width, data_width, spi_padding):
        """Place Holder"""
        self.spi_block_write(cs, reg_addr, [wdata], addr_width, data_width, spi_padding)

    def spi_read(self, cs, reg_addr, addr_width, data_width, spi_padding):
        """Place Holder"""
        return self.spi_block_read(cs, reg_addr, 1, addr_width, data_width, spi_padding)[0]

    def spi_block_write(self, cs, first_reg_addr, wdata_array, addr_width, data_width, spi_padding):
        """Place Holder"""
        num_data_bytes = len(wdata_array) * data_width
        size_bytes = addr_width + spi_padding + num_data_bytes
        data_out = array('B', [0] * size_bytes)

        data_out[0:addr_width] = array('B', intList_to_byteArray([first_reg_addr], addr_width))
        data_out[spi_padding + data_width:] = array('B', intList_to_byteArray(wdata_array, data_width))

        self.spi_queue_transaction(size_bytes, data_out)

        ##TODO remove (ret_code, in_data) = app.ps_queue_spi_write(self.handle, data_out, data_in)
        # Note: in_data and data_in have exactly the same values
        #if ret_code != size_bytes:
        #    raise IOError("SPI Write Error", ret_code)

    def spi_block_read(self, cs, first_reg_addr, num_regs, addr_width, data_width, spi_padding):
        """Place Holder"""
        num_data_bytes = num_regs * data_width
        size_bytes = addr_width + spi_padding + num_data_bytes
        data_out = array('B', [0] * size_bytes)

        data_out[0:addr_width] = array('B', intList_to_byteArray([first_reg_addr], addr_width))
        data_out[0] |= 0x80     # Set MSB to 1 to indicate a read transaction

        in_data = self.spi_queue_transaction(size_bytes, data_out)
        values_returned = byteArray_to_intList(in_data[(addr_width + spi_padding):], data_width)

        return values_returned

    # SPI read transfer with Promira queue mechanism
    def spi_queue_transaction(self, size_bytes, data_out):
        """Place Holder"""
        word_size = 8
        in_data = array('B', [0] * size_bytes)
        data_in = array('B', [0] * size_bytes)

        # Create and clear queue for SPI transactions
        if not self.spi_queue:
            self.spi_queue = app.ps_queue_create(self.conn, app.PS_MODULE_ID_SPI_ACTIVE)
        app.ps_queue_clear(self.spi_queue)
        app.ps_queue_spi_oe(self.spi_queue, 1)  # Enable SPI outputs
        app.ps_queue_spi_ss(self.spi_queue, 1)  # Assert SPI SS line
        app.ps_queue_spi_write(self.spi_queue, DEFAULT_SPI_MODE, word_size, size_bytes, data_out)
        app.ps_queue_spi_ss(self.spi_queue, 0)  # De-assert SPI SS line
        app.ps_queue_spi_oe(self.spi_queue, 0)  # Disable SPI outputs
        app.ps_queue_sync(self.spi_queue)
        collect, _ = app.ps_queue_submit(self.spi_queue, self.channel, 0)
        if collect == app.PS_APP_CONNECTION_LOST:
            print("RECONNECTING APP *********************")
            self.app_connect(0, 0)
            collect, _ = app.ps_queue_submit(self.spi_queue, self.channel, 0)
        elif collect < 0:
            raise IOError("Error submitting SPI write command queue (Error Code %d)" % collect)
        ret_val = None
        timeout = 999
        while ret_val != app.PS_APP_NO_MORE_CMDS_TO_COLLECT:
            if timeout < 0:
                raise IOError("Error: Timeout reached in collecting SPI response")
            timeout -= 1
            ret_val, _, _ = app.ps_collect_resp(collect, timeout=10)
            if ret_val == app.PS_SPI_CMD_READ:
                ret_code, _, in_data = app.ps_collect_spi_read(collect, data_in)
                # Note: in_data and data_in have exactly the same values
                if ret_code != size_bytes:
                    raise IOError("SPI Read Error", (ret_code, in_data))
        # app.ps_queue_destroy(self.spi_queue)  # not using this since it causes invalid handle issue
        return in_data

    @classmethod
    def find_devices(cls, num_devices: int = MAX_NUM_PROMIRAS) -> List[Tuple[int, int]]:
        """
        Returns zipped list of tuples, where the first int is the port the aardvark is connected to, and the second int
          is the aardvark's unique ID

        :param num_devices: Number of devices, will determine the length of the return list
        :type num_devices: int
        :return: List of length 'num_devices', containing Port and ID data
        :rtype: list
        """
        ret, devices, ids, stats = wrap.pm_find_devices_ext(num_devices, num_devices, num_devices)
        return list(zip(devices, ids, stats))
