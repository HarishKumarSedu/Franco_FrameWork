import os
import sys
from cl_test_station.host_controllers.host_controller.host_controller import HostController, skip_if_connected
from cl_test_station.host_controllers.promira_controller.Promira import Promira
from cl_test_station.interfaces.ctrl_interface import map_word, ByteOrder
from array import array


class PromiraController(HostController):
    __default_i2c_speed = 100  # 100 kHz
    __default_spi_speed = 1000  # 1 MHz
    # todo: VALTECH-601 add serial_num optional field

    def __init__(self, *args, **kwargs):
        # promira serial. If None, host will scan for all available aarvarks and pick the one with the highest serial
        self.serial_num = None
        super().__init__(*args, **kwargs)
        self.host:Promira = None

    @skip_if_connected
    def connect(self):
        self.host = Promira(serial_num=self.serial_num)

    def disconnect(self):
        self.host.close()
        self.host = None

    def is_connected(self) -> bool:
        return self.host is not None

    # TODO: PLATDEV-1080 remove
    def isConnected(self) -> bool:
        return self.is_connected()

    def set_i2c_pullup(self, pullup=True):
        self.host.set_i2c_pullup(pullup)

    def get_i2c_pullup(self):
        """Returns i2c_pullup"""
        return self.host.get_i2c_pullup()

    def write_i2c_reg(self, speed, address, reg_addr, write_reg_addr_size, addr_byte_order, write_data, **kwargs):
        # Speed comes in as Hz, need to use KHz
        speed_KHz = int(speed/1000)
        if speed % 1000:
            self.log.warning("Ardvark only supports speeds in KHz, using %dHz" % speed_KHz*1000)
        self.host.set_i2c_speed(speed_KHz)
        addr_byte_order = ByteOrder(addr_byte_order)
        waddr = array('B', map_word(reg_addr, write_reg_addr_size, addr_byte_order))
        write_data = array('B', write_data)
        # local_reg, local_data = self.check_iface_arguments(reg_addr, write_data)
        self.host.i2c_block_write(i2c_addr=address, waddr=waddr, wdata=write_data)

    def read_i2c_reg(self, speed, address, reg_addr, read_reg_addr_size, addr_byte_order, byte_count, **kwargs):
        # Speed comes in as Hz, need to use KHz
        speed_KHz = int(speed / 1000)
        if speed % 1000:
            self.log.warning("Ardvark only supports speeds in KHz, using %dHz" % speed_KHz * 1000)
        self.host.set_i2c_speed(speed_KHz)
        addr_byte_order = ByteOrder(addr_byte_order)
        raddr = array('B', map_word(reg_addr, read_reg_addr_size, addr_byte_order))
        return self.host.i2c_block_read(address, raddr, byte_count)

    def spi_fd(self, bytes_out, **kwargs):
        bytes_out = array('B', bytes_out)
        return self.host.spi_queue_transaction(len(bytes_out), bytes_out)

    def spi_fd_write(self, spi_fd_config, data_list, ainc, addr, **kwargs):
        """
        Sends command for full duplex spi to libcomms controller

        :param spi_fd_config: config object from test_controller_resource_config.yml under 'resource_spi_iface_mahoney'
        :param data: spi packet. includes r/w, ainc, padding, and write data/read padding
        :return: miso packet
        """
        self.log.warning("spi_fd_write is deprecated. Use spi_fd() instead.")

    def spi_fd_read(self, spi_fd_config, word_count, ainc, addr, **kwargs):
        """
        Sends command for full duplex spi to libcomms controller

        :param spi_fd_config: config object from test_controller_resource_config.yml under 'resource_spi_iface_mahoney'
        :param data: spi packet. includes r/w, ainc, padding, and write data/read padding
        :return: miso packet
        """
        self.log.warning("spi_fd_read is deprecated. Use spi_fd() instead.")

    @classmethod
    def find_devices(cls, num_devices):
        """
        Returns zipped list of tuples, where the first int is the port the aardvark is connected to, and the second int
          is the aardvark's unique ID

        :param num_devices: Number of devices, will determine the length of the return list
        :type num_devices: int
        :return: List of length 'num_devices', containing Port and ID data
        :rtype: list
        """
        return Promira.find_devices(num_devices)

    def get_licensed_apps(self):
        return self.host.get_licensed_apps()

    def set_logic_level(self, level):
        return self.host.set_logic_level(level)
