#!/usr/bin/python
## ============================================================================
## Python Wrapper for libCLcomms
##
## This python file can be used to interface libCLcomms from other python
## scripts.  All libCLcomms functionality might not be available. Feel free to
## add anything that has not been implemented.
##
## Tested originally with python 2.6
##
## Note:  You must have an up to date version of WISCE installed (which
## includes libCLcomms) to run this
## ============================================================================
from __future__ import print_function
import imp
import os
import sys
import string
import inspect
import platform
import struct
from ctypes import *

#Protocol mask values
PROT_I2C = 0x01
PROT_SPI = 0x02
PROT_JTAG = 0x04
DEV_RPI = 0x10
DEV_FTDI = 0x20
DEV_XMOS = 0x40
PROT_BLANK_FTDI = 0x80
PROT_ALL = 0xFF

#Logging levels
MSG_OFF = 0x00
MSG_ERR = 0x01
MSG_WARN = 0x02
MSG_INFO = 0x03
MSG_FILE = 0x1000
MSG_SCREEN = 0x2000

#DeviceType_t enum
TYPE_UNKNOWN = 0
TYPE_BRUICHLADDICH = 1
TYPE_FUSBBOX1 = 2
TYPE_FUSBBOX2 = 3
TYPE_LOCHNAGAR2_FTDI = 4
TYPE_CL_VCOM = 5
TYPE_BLANK = 6
TYPE_GENERIC_JTAG = 7
TYPE_GENERIC_VCP = 8
TYPE_RPI_LN2 = 9
TYPE_MAX = 10


class DeviceNode(Structure):
     _fields_ = [("dtype", c_uint32),
                ("flags", c_uint32),
                ("VidPid", c_uint32),
                ("channel", c_uint32),
                ("serialNumber", c_byte*16),
                ("description", c_byte*64)]


platform = platform.system()
print('Platform: ' + platform)
architecture = 32
if sys.maxsize == pow(2,63)-1:
    architecture = 64
print('Python architecture: ' + str(architecture) + "-bit")

lib_path = None

# Define which directories to check for DLL, use list to set priority order
cmdline_dir = os.getcwd()
main_script_dir = sys.path[0]
lib_wrapper_dir = os.path.dirname(__file__)
dirs_to_check = [cmdline_dir, main_script_dir, lib_wrapper_dir]

# Search for appropriate DLL in each directory
# Break loop when it finds something
for dir in dirs_to_check:
    # First checks local directory for libCLcomms files.
    local_dll_path = os.path.join(dir, 'libCLcomms.dll')
    local_dll_path_64 = os.path.join(dir, 'libCLcomms_64.dll')

    # If 64-bit Python and libCLcomms_64.dll in same folder, use it
    if architecture == 64 and os.path.isfile(local_dll_path_64):
        lib_path = local_dll_path_64
        break
    # Otherwise, if libCLcomms.dll in same folder, use it regardless of architecture (file could be either - check later)
    elif os.path.isfile(local_dll_path):
        lib_path = local_dll_path
        break

# If local copy of library is not found, look in platform specific locations

if lib_path == None or lib_path == "":

    # On Linux, look in /usr/local/lib
    if platform == "Linux":
        lib_path = "/usr/local/lib/libCLcomms.so"

    # On Mac OS, look in /usr/local/lib
    elif platform == "Darwin": # Darwin = Mac OS
        lib_path = "/usr/local/lib/libCLcomms.dylib"

    # On Windows, check WISCE installation directory
    elif platform == "Windows":

        if sys.version_info[0] < 3:
            import _winreg as winreg
        else:
            import winreg

        # Find out where WISCE is installed.
        wisce_path = ""
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,"SOFTWARE\\Wolfson Microelectronics\\WISCE", 0,
                                    winreg.KEY_READ | winreg.KEY_WOW64_32KEY) as key:
                i = 0
                while True:
                    (keyName,keyData,keyType)  = winreg.EnumValue(key, i)
                    if (keyName == 'Installation directory'):
                        wisce_path = keyData
                    i+=1
        except WindowsError:
            pass

        if wisce_path == "":
            print("ERROR: No local libCLcomms.dll and WISCE installation not found!")
            sys.exit(1)

        if architecture == 64:
            if os.path.isfile(os.path.join(wisce_path, "bin", "libCLcomms_64.dll")):
                lib_path = os.path.join(wisce_path, "bin", "libCLcomms_64.dll")
            else:
                print("ERROR: No local libCLcomms.dll and 64-bit version not found in WISCE installation")
                sys.exit(1)

        elif architecture == 32 and os.path.isfile(os.path.join(wisce_path, "bin", "libCLcomms.dll")):
            lib_path = os.path.join(wisce_path, "bin", "libCLcomms.dll")

        else:
            print("ERROR: No local libCLcomms.dll and appropriate DLL not found in WISCE installation")
            sys.exit(1)

        # Finally, double-check that DLL architecture is compatible with Python architecture by parsing DLL to check if 32/64-bit
        lib_arch = None
        with open(lib_path, 'rb') as f:
            f.seek(60)
            offset = struct.unpack('i', f.read(4))[0]
            f.seek(offset + 4, os.SEEK_SET)
            dll_arch = struct.unpack('H', f.read(2))[0]
            if dll_arch == 0x014C:
                lib_arch = 32
            elif dll_arch == 0x8664:
                lib_arch = 64
            else:
                print("Error parsing DLL architecture")
                sys.exit(1)

        if lib_arch != architecture:
            print("Error: {:d}-bit DLL not compatible with {:d}-bit Python installation".format(lib_arch, architecture))
            sys.exit(1)

    # Else if platform is not linux, MacOS or Windows
    else:
        print("Error: Unknown operating system")
        sys.exit(1)

# globals
c_ulonglong_p = c_void_p
c_uint32_p = c_void_p
c_uint8_p = c_void_p

# FT Handle is a pointer value which will be either 32- or 64-bit depending on DLL version
if architecture == 32:
    c_ft_handle = c_uint32
elif architecture == 64:
    c_ft_handle = c_uint64

# Final double-check that library file exists in the path specified before attempting to load
if not os.path.isfile(lib_path):
    print("Error: Library {} not at specified path".format(lib_path))
    sys.exit(1)

print("Library Path: {}".format(lib_path))
imp_dll = CDLL(str(lib_path))  # handles dll functions

verbosityLevel = 1


# function definitions
def printDebug(text):
    """
    Place Holder

    :param text:
    :return:
    """
    if verbosityLevel > 0:
        print(text)


def CLCOMMS_SetVerbosity(level):
    """
    Place Holder

    :param level:
    :return:
    """
    global verbosityLevel
    verbosityLevel = level


def CLCOMMS_SetDebugLevel(level):
    """
    Place Holder

    :param level:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32] # list parameters
    result = func(c_uint32(level)) # API function call
    if result == 0:
        return
    else:
    # May be old lib version which does not accept  MSG_SCREEN and MSG_FILE
        printDebug( "SetDebugLevel call failed. Checking if pre-version 3.1.xx DLL")
        if result == 6:
            result = func(c_uint(level & 3))
            if result == 0:
                return

        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_GetDebugLevel():
    """
    Place Holder

    :return:
    """
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32_p] # list parameters
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(readBuffer) # API function call
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SetLogFile(logname):
    """
    Place Holder

    :param logname:
    :return:
    """
    printDebug( "Error:  Function deprecated. Please use CLCOMMS_SetLogDir.")
    raise IOError("Error code")


def CLCOMMS_SetLogDir(dirname):
    """
    Place Holder

    :param dirname:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_char_p] # list parameters
    result = func(c_char_p(dirname)) # API function call
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_GetLibraryVersion():
    """
    Place Holder

    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32_p] # list parameters
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(readBuffer) # API function call
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SetPortCloseTimer(handle, timeout):
    """
    Place Holder

    :param handle:
    :param timeout:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint32] # list parameters
    result = func(c_ft_handle(handle), c_uint32(timeout)) # API function call
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_ListChannels(dev_mask):
    """
    Place Holder

    :param dev_mask:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32] # list parameters
    result = func(c_uint32(dev_mask)) # API function call
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_GetNumberOfDevices(protoMask, devtype):
    """
    Place Holder

    :param protoMask:
    :param devtype:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32_p, c_uint32, c_uint32] # list parameters
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(readBuffer, c_uint32(protoMask), c_uint32(devtype)) # API function call
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_GetNumberOfChannels(protoMask):
    """
    Place Holder

    :param protoMask:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32_p, c_uint32] # list parameters
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(readBuffer, c_uint32(protoMask)) # API function call
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_GetChannelInfo(index, protoMask):
    """
    Place Holder

    :param index:
    :param protoMask:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32, POINTER(DeviceNode)] # list parameters
    readValue = DeviceNode()
    readBuffer = pointer(readValue) # create pointer
    result = func(c_uint32(index), readBuffer, c_uint32(protoMask)) # API function call
    if result == 0:
        return readValue
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))
    return


def CLCOMMS_GetDeviceInfo(index, protoMask, devtype):
    """
    Place Holder

    :param index:
    :param protoMask:
    :param devtype:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32, POINTER(DeviceNode), c_uint32] # list parameters
    readValue = DeviceNode()
    readBuffer = pointer(readValue) # create pointer
    result = func(c_uint32(index), readBuffer, c_uint32(protoMask), c_uint32(devtype)) # API function call
    if result == 0:
        return readValue
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))
    return


def CLCOMMS_HideLN2FTDI(hide):
    """
    Place Holder

    :param hide:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_bool] # list parameters
    result = func(c_bool(hide)) # API function call
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_OpenChannel(chan):
    """
    Place Holder

    :param chan:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_void_p, c_uint32] # list parameters
    readValue = c_ft_handle()
    readBuffer = pointer(readValue) # create pointer
    result = func(readBuffer, c_uint32(chan)) # API function call
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SPISelectCS(handle, cs):
    """
    Place Holder

    :param handle:
    :param cs:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8] # list parameters
    result = func(c_ft_handle(handle), c_uint8(cs)) # API function call
    if result == 0:
        return 0
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SPIEnableCS(handle, enableCS):
    """
    Place Holder

    :param handle:
    :param enableCS:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_bool] # list parameters
    result = func(c_ft_handle(handle), c_bool(enableCS)) # API function call
    if result == 0:
        return 0
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_InitChannel(handle, chanType, ena3Phase, speed=100000):
    """
    Place Holder

    :param handle:
    :param chanType:
    :param ena3Phase:
    :param speed:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint32, c_void_p, c_bool] # list parameters
    speedValue = c_uint32(speed)#default to 100K
    speedBuffer = pointer(speedValue) # create pointer
    result = func(c_ft_handle(handle), c_uint32(chanType), speedBuffer, c_bool(ena3Phase)) # API function call
    if result == 0:
        return int(speedValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_ReInitChannel(handle, chanType, ena3Phase, speed=100000):
    """
    Place Holder

    :param handle:
    :param chanType:
    :param ena3Phase:
    :param speed:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint32, c_uint32_p, c_bool] # list parameters
    speedValue = c_uint32(speed)#default to 100K
    speedBuffer = pointer(speedValue) # create pointer
    result = func(c_ft_handle(handle), c_uint32(chanType), speedBuffer, c_bool(ena3Phase)) # API function call
    if result == 0:
        return int(speedValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_CloseChannel(handle):
    """
    Place Holder

    :param handle:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle] # list parameters
    result = func(c_ft_handle(handle)) # API function call
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_I2CBlockRead(handle, i2cAddress, regAddress, numAddrBytes, length):
    """
    Place Holder

    :param handle:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param length:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint32, c_uint8, c_uint8_p, c_uint32_p] # list parameters
    readValue = (c_uint8 * length)()
    readBuffer = pointer(readValue) # create pointer
    lengthValue = c_uint32(length)
    lengthBuffer = pointer(lengthValue)
    result = func(c_ft_handle(handle), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), readBuffer, lengthBuffer) # API function call
    if result == 0:
        return readValue
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_I2CBlockReadWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, length):
    """
    Place Holder

    :param handle:
    :param i2cBus:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param length:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint8, c_uint32, c_uint8, c_uint8_p, c_uint32_p] # list parameters
    readValue = (c_uint8 * length)()
    readBuffer = pointer(readValue) # create pointer
    lengthValue = c_uint32(length)
    lengthBuffer = pointer(lengthValue)
    result = func(c_ft_handle(handle), c_uint8(i2cBus), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), readBuffer, lengthBuffer) # API function call
    if result == 0:
        return readValue
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_I2CBlockWrite(handle, i2cAddress, regAddress, numAddrBytes, writeArray, length):
    """
    Place Holder

    :param handle:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param writeArray:
    :param length:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint32, c_uint8, c_uint8_p, c_uint32] # list parameters
    writeBuffer = (c_uint8 * len(writeArray))(*writeArray)
    result = func(c_ft_handle(handle), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), writeBuffer, c_uint32(length)) # API function call
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_I2CBlockWriteWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, writeArray, length):
    """
    Place Holder

    :param handle:
    :param i2cBus:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param writeArray:
    :param length:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint8, c_uint32, c_uint8, c_uint8_p, c_uint32] # list parameters
    writeBuffer = (c_uint8 * len(writeArray))(*writeArray)
    result = func(c_ft_handle(handle), c_uint8(i2cBus), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), writeBuffer, c_uint32(length)) # API function call
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SPIReadWrite(handle, writeArray, length):
    """
    Place Holder

    :param handle:
    :param writeArray:
    :param length:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8_p, c_uint8_p, c_uint32, c_uint32_p, c_bool] # list parameters
    readValue = (c_uint8 * length)()
    readBuffer = pointer(readValue) # create pointer
    writeBuffer = (c_uint8 * len(writeArray))(*writeArray)
    xferValue = c_uint32(0)
    xferBuffer = pointer(xferValue)
    result = func(c_ft_handle(handle), writeBuffer, readBuffer, c_uint32(length), xferBuffer, c_bool(True)) # API function call
    if result == 0:
        return readValue
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SPIReadWriteWithCS(handle, writeArray, length, csIndex):
    """
    Place Holder

    :param handle:
    :param writeArray:
    :param length:
    :param csIndex:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8_p, c_uint8_p, c_uint32, c_uint32_p, c_uint8] # list parameters
    readValue = (c_uint8 * length)()
    readBuffer = pointer(readValue) # create pointer
    writeBuffer = (c_uint8 * len(writeArray))(*writeArray)
    xferValue = c_uint32(0)
    xferBuffer = pointer(xferValue)
    result = func(c_ft_handle(handle), writeBuffer, readBuffer, c_uint32(length), xferBuffer, c_uint8(csIndex)) # API function call
    if result == 0:
        return readValue
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SPIBlockRead(handle, regAddr, regAddressSize, dataSize, paddingSize=2):
    """
    Place Holder

    :param handle:
    :param regAddr:
    :param regAddressSize:
    :param dataSize:
    :param paddingSize:
    :return:
    """

    spiRegAddressSize = regAddressSize
    spiDataSize = dataSize
    spiZeroPaddingSize = paddingSize

    spiPacketSize = spiRegAddressSize + spiZeroPaddingSize + spiDataSize

    txBytes = [0]*spiPacketSize
    readArray = [0]*dataSize

    for i in range(0, spiRegAddressSize):
        txBytes[i] = (regAddr >> (spiRegAddressSize-i-1) * 8 & 0xFF)

    txBytes[0] = txBytes[0] | 0x80

    #zero padding
    for i in range(0, spiZeroPaddingSize + spiDataSize):
        txBytes[i+spiRegAddressSize] = 0

    rxBytes = CLCOMMS_SPIReadWrite(handle, txBytes, spiPacketSize)

    for i in range(0, spiDataSize):
        readArray[i] = rxBytes[i+spiRegAddressSize+spiZeroPaddingSize]

    return readArray


def CLCOMMS_SPIBlockReadWithCS(handle, regAddr, regAddressSize, dataSize, csIndex, paddingSize=2):
    """
    Place Holder

    :param handle:
    :param regAddr:
    :param regAddressSize:
    :param dataSize:
    :param csIndex:
    :param paddingSize:
    :return:
    """

    spiRegAddressSize = regAddressSize
    spiDataSize = dataSize
    spiZeroPaddingSize = paddingSize

    spiPacketSize = spiRegAddressSize + spiZeroPaddingSize + spiDataSize

    txBytes = [0]*spiPacketSize
    readArray = [0]*dataSize

    for i in range(0, spiRegAddressSize):
        txBytes[i] = (regAddr >> (spiRegAddressSize-i-1) * 8 & 0xFF)

    txBytes[0] = txBytes[0] | 0x80

    #zero padding
    for i in range(0, spiZeroPaddingSize + spiDataSize):
        txBytes[i+spiRegAddressSize] = 0

    rxBytes = CLCOMMS_SPIReadWriteWithCS(handle, txBytes, spiPacketSize, csIndex)

    for i in range(0, spiDataSize):
        readArray[i] = rxBytes[i+spiRegAddressSize+spiZeroPaddingSize]

    return readArray


def CLCOMMS_SPIBlockWrite(handle, regAddr, regAddressSize, dataSize, data, paddingSize=2):
    """
    Place Holder

    :param handle:
    :param regAddr:
    :param regAddressSize:
    :param dataSize:
    :param data:
    :param paddingSize:
    :return:
    """

    spiRegAddressSize = regAddressSize
    spiDataSize = dataSize
    spiZeroPaddingSize = paddingSize

    spiPacketSize = spiRegAddressSize + spiZeroPaddingSize + spiDataSize

    txBytes = [0]*spiPacketSize
    readArray = [0]*dataSize

    for i in range(0, spiRegAddressSize):
        txBytes[i] = (regAddr >> (spiRegAddressSize-i-1) * 8 & 0xFF)

    txBytes[0] = txBytes[0] | 0x0

    #zero padding
    for i in range(0, spiZeroPaddingSize):
        txBytes[i+spiRegAddressSize] = 0

    for i in range(0, spiDataSize):
        txBytes[i+spiRegAddressSize+spiZeroPaddingSize] = data[i]

    rxBytes = CLCOMMS_SPIReadWrite(handle, txBytes, spiPacketSize)

    return readArray


def CLCOMMS_SPIBlockWriteWithCS(handle, regAddr, regAddressSize, dataSize, data, csIndex, paddingSize=2):
    """
    Place Holder

    :param handle:
    :param regAddr:
    :param regAddressSize:
    :param dataSize:
    :param data:
    :param csIndex:
    :param paddingSize:
    :return:
    """
    spiRegAddressSize = regAddressSize
    spiDataSize = dataSize
    spiZeroPaddingSize = paddingSize

    spiPacketSize = spiRegAddressSize + spiZeroPaddingSize + spiDataSize

    txBytes = [0]*spiPacketSize
    readArray = [0]*dataSize

    for i in range(0, spiRegAddressSize):
        txBytes[i] = (regAddr >> (spiRegAddressSize-i-1) * 8 & 0xFF)

    txBytes[0] = txBytes[0] | 0x0

    #zero padding
    for i in range(0, spiZeroPaddingSize):
        txBytes[i+spiRegAddressSize] = 0

    for i in range(0, spiDataSize):
        txBytes[i+spiRegAddressSize+spiZeroPaddingSize] = data[i]

    rxBytes = CLCOMMS_SPIReadWriteWithCS(handle, txBytes, spiPacketSize, csIndex)

    return readArray


def CLCOMMS_I2CRegRead(handle, i2cAddress, regAddress, numAddrBytes, length):
    """
    Place Holder

    :param handle:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param length:
    :return:
    """
    readArray = CLCOMMS_I2CBlockRead(handle, i2cAddress, regAddress, numAddrBytes, length)
    i = length - 1
    result = 0
    for byte in readArray:
        result += byte << (8 * i)
        i = i - 1
    return result


def CLCOMMS_I2CRegWrite(handle, i2cAddress, regAddress, numAddrBytes, writeVal, length):
    """
    Place Holder

    :param handle:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param writeVal:
    :param length:
    :return:
    """
    writeArray = [0]*length
    for i in range(0,length):
        writeArray[i] = (writeVal >> (8 * (length-1-i))) & 0xFF
    CLCOMMS_I2CBlockWrite(handle, i2cAddress, regAddress, numAddrBytes, writeArray, length)


def CLCOMMS_I2CReadRegister(handle, i2cAddress, regAddress, numAddrBytes, numDataBytes, swap):
    """
    Place Holder

    :param handle:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param numDataBytes:
    :param swap:
    :return:
    """
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint32, c_uint8, c_uint8, c_uint8, c_uint32_p] # list parameters
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(c_ft_handle(handle), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), c_uint8(numDataBytes), c_uint8(swap), readBuffer) # API function call
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_I2CReadRegisterWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, numDataBytes, swap):
    """
    Place Holder

    :param handle:
    :param i2cBus:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param numDataBytes:
    :param swap:
    :return:
    """
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint8, c_uint32, c_uint8, c_uint8, c_uint8, c_uint32_p] # list parameters
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(c_ft_handle(handle), c_uint8(i2cBus), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), c_uint8(numDataBytes), c_uint8(swap), readBuffer) # API function call
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_I2CWriteRegister(handle, i2cAddress, regAddress, numAddrBytes, numDataBytes, swap, value):
    """
    Place Holder

    :param handle:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param numDataBytes:
    :param swap:
    :param value:
    :return:
    """
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint32, c_uint8, c_uint8, c_uint8, c_uint32]
    result = func(c_ft_handle(handle), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), c_uint8(numDataBytes), c_uint8(swap), c_uint32(value))
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_I2CWriteRegisterWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, numDataBytes, swap, value):
    """
    Place Holder

    :param handle:
    :param i2cBus:
    :param i2cAddress:
    :param regAddress:
    :param numAddrBytes:
    :param numDataBytes:
    :param swap:
    :param value:
    :return:
    """
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint8, c_uint32, c_uint8, c_uint8, c_uint8, c_uint32]
    result = func(c_ft_handle(handle), c_uint8(i2cBus), c_uint8(i2cAddress), c_uint32(regAddress), c_uint8(numAddrBytes), c_uint8(numDataBytes), c_uint8(swap), c_uint32(value))
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SPIReadRegister(handle, cs, regAddress, numAddrBytes, numDataBytes, swap, pad):
    """
    Place Holder

    :param handle:
    :param cs:
    :param regAddress:
    :param numAddrBytes:
    :param numDataBytes:
    :param swap:
    :param pad:
    :return:
    """
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint32, c_uint8, c_uint8, c_uint8, c_uint8, c_uint32_p]
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(c_ft_handle(handle), c_uint8(cs), c_uint32(regAddress), c_uint8(numAddrBytes), c_uint8(numDataBytes), c_uint8(swap), c_uint8(pad), readBuffer)
    if result == 0:
        return int(readValue.value)
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_SPIWriteRegister(handle, cs, regAddress, numAddrBytes, numDataBytes, swap, pad, value):
    """
    Place Holder

    :param handle:
    :param cs:
    :param regAddress:
    :param numAddrBytes:
    :param numDataBytes:
    :param swap:
    :param pad:
    :param value:
    :return:
    """
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint8, c_uint32, c_uint8, c_uint8, c_uint8, c_uint8, c_uint32]
    readValue = c_uint32()
    readBuffer = pointer(readValue) # create pointer
    result = func(c_ft_handle(handle), c_uint8(cs), c_uint32(regAddress), c_uint8(numAddrBytes), c_uint8(numDataBytes), c_uint8(swap), c_uint8(pad), c_uint32(value))
    if result == 0:
        return
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))


def CLCOMMS_GetPairedChannel(handle, jtag):
    """
    Place Holder

    :param handle:
    :param jtag:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_ft_handle, c_uint32_p, c_bool] # list parameters
    channelValue = c_uint32()
    channelBuffer = pointer(channelValue) # create pointer
    result = func(c_ft_handle(handle), channelBuffer, c_bool(jtag)) # API function call
    if result == 0:
        return channelValue.value
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))
    return


def CLCOMMS_GetPairedFTDIChannel(channel):
    """
    Place Holder

    :param channel:
    :return:
    """
    # note: "inspect.stack()[0][3]" returns the function name as a string, eg."WMGetDeviceName"
    func = imp_dll[inspect.stack()[0][3]] # create temporary instance of function
    func.argtypes = [c_uint32, c_uint32_p, c_void_p] # list parameters
    pairedChannelValue = c_uint32()
    pairedChannelBuffer = pointer(pairedChannelValue) # create pointer
    jtagValue = c_bool()
    jtagBuffer = pointer(jtagValue) # create pointer
    result = func(c_uint32(channel), pairedChannelBuffer, jtagBuffer) # API function call
    if result == 0:
        return pairedChannelValue.value, jtagValue.value
    else:
        printDebug( "Error " + str(result) + " returned from " + inspect.stack()[0][3])
        raise IOError("Error code: " + str(result))
    return


# not run when importing code as a library
if __name__ == '__main__':

    try:    # setup default config
        print("libCLComms Version:" + hex(CLCOMMS_GetLibraryVersion()))
        CLCOMMS_ListChannels(DEV_XMOS)
        #chan = input("Enter device channel number:")
        chan = 99
        handle = CLCOMMS_OpenChannel(chan)
        speed = CLCOMMS_InitChannel(handle, PROT_I2C, True)

        # test data to be used with Lochnagar 2

        i2cBus = 0x0
        i2cAddress = 0x22
        regAddress = 0x0
        numAddrBytes = 0x2
        length= 0x2
        temp = 0x00

        # readback device id from reg 0
        readBuffer = CLCOMMS_I2CBlockReadWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, length)
        print(("Block read 2 bytes from address 0: "+hex(readBuffer[0]) + " " + hex(readBuffer[1])))

        # readback device id from reg 0 using register rea call
        temp = CLCOMMS_I2CReadRegisterWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, length, 0)
        print(("Register read from FPGA address 0: "+hex(temp)))

        # write data to scratch reg
        regAddress = 0xF9
        writeData = [0xAB, 0xCD]

        CLCOMMS_I2CBlockWriteWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, writeData, length)

        # readback written data
        readBuffer = CLCOMMS_I2CBlockReadWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, length)
        print(("Block read from scratch register (expect 0xABCD): "+hex(readBuffer[0]) + " " + hex(readBuffer[1])))

        # write new data to scratch register
        CLCOMMS_I2CWriteRegisterWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, length, 0, 0xF00B)

        temp = CLCOMMS_I2CReadRegisterWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, length, 0)
        print(("Scratch register read from FPGA (expect 0xF00B): "+hex(temp)))

        # do write/readback via reg functions
        CLCOMMS_I2CRegWriteWithBus(handle, i2cBus, i2cAddress, regAddress, numAddrBytes, 0xef01, length)
        print(("Read rgister 0: "+hex(CLCOMMS_I2CRegRead(handle, i2cAddress, regAddress, numAddrBytes, length))))

        speed = CLCOMMS_ReInitChannel(handle, PROT_SPI, False)

        temp = CLCOMMS_SPIReadRegister(handle, 0, 0, 4, 2, 0, 2)
        print(("SPI read codec register 0: "+hex(temp)))
        CLCOMMS_SPIWriteRegister(handle, 0, 0x21, 4, 2, 0, 2, 0x1234)
        temp = CLCOMMS_SPIReadRegister(handle, 0, 0x21, 4, 2, 0, 2)
        print(("SPI read codec register 0x21: "+hex(temp)))

        CLCOMMS_CloseChannel(handle)

    except IOError:
        print(IOError)
