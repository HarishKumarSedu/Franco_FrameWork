# Note: i2c_bus is only for interfaces with multiple i2c buses, i.e. CirrusLink and AudioHub

from .LibCLcomms_ import LibCLcomms_wrap as wrap
from .common import intList_to_byteArray, byteArray_to_intList

DEFAULT_I2C_SPEED = 100  # 100 kHz
DEFAULT_SPI_SPEED = 1000  # 1 MHz

# doc strings not appearing
class LibCLcomms():

    def __init__(self, i2c_speed=DEFAULT_I2C_SPEED, spi_speed=DEFAULT_SPI_SPEED):
        self.handle_i2c = -1234
        self.handle_spi = -1234

        # The line below allows tests direct access to the wrapper api
        # e.g. devid = libclcomms.wrap.CLCOMMS_I2CReadRegister(libclcomms.handle_spi, 0x90>>1, 0x0, 4, 4, 0)
        self.wrap = wrap
        self.open(i2c_speed, spi_speed)
        # Maximum bytes LibCLcomms can support per single block I2C transaction
        self.i2c_byte_limit = None  # Not known
        # Maximum bytes LibCLcomms can support per single block SPI transaction
        self.spi_byte_limit = 0xFFF0

    def open(self, i2c_speed=DEFAULT_I2C_SPEED, spi_speed=DEFAULT_SPI_SPEED):
        """
        Place Holder

        :param i2c_speed:
        :param spi_speed:
        :return:
        """
        num_devices = wrap.CLCOMMS_GetNumberOfDevices(wrap.PROT_SPI | wrap.PROT_I2C, wrap.TYPE_CL_VCOM)
        if num_devices == 0:
            raise Exception("ERROR: No Lochnagar type devices found")
        elif num_devices > 1:
            raise Exception("ERROR: More than 1 Lochnagar type device found (%d devices found)" % num_devices)

        device_info = wrap.CLCOMMS_GetDeviceInfo(0, wrap.PROT_SPI | wrap.PROT_I2C, wrap.TYPE_CL_VCOM)

        self.handle_i2c = wrap.CLCOMMS_OpenChannel(device_info.channel)

        # Stops the Port closing and re-opening between successive reads and writes
        wrap.CLCOMMS_SetPortCloseTimer(self.handle_i2c, 10)

        ena3phase = False
        speed = wrap.CLCOMMS_ReInitChannel(self.handle_i2c, wrap.PROT_I2C, ena3phase, speed=i2c_speed * 1000)

        self.handle_spi = wrap.CLCOMMS_OpenChannel(device_info.channel)
        speed = wrap.CLCOMMS_ReInitChannel(self.handle_spi, wrap.PROT_SPI, ena3phase, speed=spi_speed * 1000)

    def set_i2c_speed(self, speed, ena3phase=False):
        """
        Place Holder

        :param speed:
        :param ena3phase:
        :return:
        """
        speed = wrap.CLCOMMS_ReInitChannel(self.handle_i2c, wrap.PROT_I2C, ena3phase, speed=speed * 1000)

    def set_spi_speed(self, speed, ena3phase=False):
        """
        Place Holder

        :param speed:
        :param ena3phase:
        :return:
        """
        speed = wrap.CLCOMMS_ReInitChannel(self.handle_spi, wrap.PROT_SPI, ena3phase, speed=speed * 1000)

    def __del__(self):
        self.close()

    def close(self):
        """
        Place Holder

        :return:
        """
        wrap.CLCOMMS_CloseChannel(self.handle_i2c)

    def i2c_write(self, i2c_addr, reg_addr, write_data, write_reg_addr_size, write_reg_data_size, i2c_bus=0):
        """
        Place Holder

        :param i2c_addr:
        :param reg_addr:
        :param write_data:
        :param write_reg_addr_size:
        :param write_reg_data_size:
        :param i2c_bus:
        :return:
        """
        wrap.CLCOMMS_I2CWriteRegister(self.handle_i2c, i2c_addr, reg_addr, write_reg_addr_size,
                                      write_reg_data_size, 0, write_data)

    def i2c_read(self, i2c_addr, reg_addr, read_reg_addr_size, read_reg_data_size, i2c_bus=0):
        """
        Place Holder

        :param i2c_addr:
        :param reg_addr:
        :param read_reg_addr_size:
        :param read_reg_data_size:
        :param i2c_bus:
        :return:
        """
        return wrap.CLCOMMS_I2CReadRegister(self.handle_i2c, i2c_addr, reg_addr, read_reg_addr_size, read_reg_data_size,
                                            0)

    def i2c_block_write(self, i2c_addr, start_addr, write_data, write_reg_addr_size, i2c_bus=None):
        """
        Place Holder

        :param i2c_addr:
        :param start_addr:
        :param write_data:
        :param write_reg_addr_size:
        :param i2c_bus:
        :return:
        """
        # bytes_to_write = intList_to_byteArray(wdata_array, data_width)
        if i2c_bus is None:
            # todo: the i2c_addr below used to be left shifted, but I removed it since we now use 7-bit i2c addresses
            wrap.CLCOMMS_I2CBlockWrite(self.handle_i2c, i2c_addr, start_addr, write_reg_addr_size,
                                       write_data, len(write_data))
        else:
            wrap.CLCOMMS_I2CBlockWriteWithBus(self.handle_i2c, i2c_bus, i2c_addr, start_addr, write_reg_addr_size,
                                              write_data, len(write_data))

    def i2c_block_read(self, i2c_addr, start_addr, read_reg_addr_size, byte_count, i2c_bus=None):
        """
        Place Holder

        :param i2c_addr:
        :param start_addr:
        :param read_reg_addr_size:
        :param byte_count:
        :param i2c_bus:
        :return:
        """
        if i2c_bus is None:
            return wrap.CLCOMMS_I2CBlockRead(self.handle_i2c, i2c_addr, start_addr, read_reg_addr_size, byte_count)
        else:
            return wrap.CLCOMMS_I2CBlockReadWithBus(self.handle_i2c, i2c_bus, i2c_addr, start_addr, read_reg_addr_size,
                                                    byte_count)

    def spi_write(self, cs, reg_addr, wdata, addr_width, data_width, spi_padding):
        """
        Place Holder

        :param cs:
        :param reg_addr:
        :param wdata:
        :param addr_width:
        :param data_width:
        :param spi_padding:
        :return:
        """
        wrap.CLCOMMS_SPIWriteRegister(self.handle_spi, cs, reg_addr, addr_width, data_width, 0, spi_padding, wdata)

    def spi_read(self, cs, reg_addr, addr_width, data_width, spi_padding):
        """
        Place Holder

        :param cs:
        :param reg_addr:
        :param addr_width:
        :param data_width:
        :param spi_padding:
        :return:
        """
        return wrap.CLCOMMS_SPIReadRegister(self.handle_spi, cs, reg_addr, addr_width, data_width, 0, spi_padding)

    def spi_fd(self, bytes_out, chip_select=None):
        """
        Place Holder

        :param bytes_out:
        :param chip_select:
        :return:
        """
        if chip_select is None:
            return wrap.CLCOMMS_SPIReadWrite(self.handle_spi, bytes_out, len(bytes_out))
        else:
            return wrap.CLCOMMS_SPIReadWriteWithCS(self.handle_spi, bytes_out, len(bytes_out), chip_select)

    def spi_block_write(self, cs, first_reg_addr, wdata_array, addr_width, data_width, spi_padding):
        """
        Place Holder

        :param cs:
        :param first_reg_addr:
        :param wdata_array:
        :param addr_width:
        :param data_width:
        :param spi_padding:
        :return:
        """
        bytes_to_write = intList_to_byteArray(wdata_array, data_width)
        wrap.CLCOMMS_SPIBlockWriteWithCS(self.handle_spi, first_reg_addr, addr_width,
                                         len(bytes_to_write), bytes_to_write, cs, spi_padding)

    def spi_block_read(self, cs, first_reg_addr, num_regs, addr_width, data_width, spi_padding):
        """
        Place Holder

        :param cs:
        :param first_reg_addr:
        :param num_regs:
        :param addr_width:
        :param data_width:
        :param spi_padding:
        :return:
        """
        bytes_read = wrap.CLCOMMS_SPIBlockReadWithCS(self.handle_spi, first_reg_addr, addr_width,
                                                     num_regs * data_width, cs, spi_padding)
        values_read = byteArray_to_intList(bytes_read, data_width)
        return values_read
