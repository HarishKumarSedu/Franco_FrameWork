import os
import sys
from cl_test_station.host_controllers.host_controller.host_controller import HostController, skip_if_connected
from cl_test_station.host_controllers.libclcomms_controller.LibCLcomms import LibCLcomms
#TODO Issue with importing CL comms


class LibCLcommsController(HostController):
    __default_i2c_speed = 100  # 100 kHz
    __default_spi_speed = 1000  # 1 MHz

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @skip_if_connected
    def connect(self):
        self.host = LibCLcomms(i2c_speed=100, spi_speed=1000)

    def disconnect(self):
        self.host.close()
        self.host = None

    def is_connected(self) -> bool:
        return self.host is not None

    # TODO PLATDEV-1080 remove
    def isConnected(self) -> bool:
        return self.is_connected()

    def write_i2c_reg(self, address, speed, write_reg_addr_size, reg_addr, write_data, bus_num=None, **kwargs):
        """
        Sends command for I2C write down to the AudioHub.

        :param address: [int] 7-bit device address
        :param speed: [int] Transfer speed in Hz
        :param reg_addr: [int] register address of write
        :param write_reg_addr_size: [int] size of register address in Bytes
        :param write_data: [List<int>] list of bytes to write
        :param bus_num: [int] I2C Bus to use, if not specified, will use LibCLComms function without bus
        :return: None
        """
        i2c_addr, reg_addr, write_data, write_reg_addr_size, i2c_bus = None
        speed_KHz = int(speed / 1000)
        if speed % 1000:
            self.log.warning("LibCLComms only supports speeds in KHz, using %dHz" % speed_KHz * 1000)
        self.host.set_i2c_speed(speed_KHz)
        self.host.i2c_block_write(address, reg_addr, write_data, write_reg_addr_size, i2c_bus=bus_num)

    def read_i2c_reg(self, address, speed, reg_addr, read_reg_addr_size, byte_count, bus_num=None, **kwargs):
        """
        Reads i2c at reg_addr

        :param address: [int] 7-bit device address
        :param speed: [int] Transfer speed in Hz
        :param reg_addr: [int] register address of write
        :param read_reg_addr_size: [int] size of register address in Bytes
        :param byte_count: [int] Number of bytes to read
        :param bus_num: [int] I2C Bus to use, if not specified, will use LibCLComms function without bus
        :return: [List<int>] List of bytes read
        """
        speed_KHz = int(speed / 1000)
        if speed % 1000:
            self.log.warning("LibCLComms only supports speeds in KHz, using %dHz" % speed_KHz * 1000)
        self.host.set_i2c_speed(speed_KHz)
        return self.host.i2c_block_read(address, reg_addr, read_reg_addr_size, byte_count, i2c_bus=bus_num)

    def spi_fd(self, bytes_out, *args, chip_select=None, **kwargs):
        return self.host.spi_fd(bytes_out, chip_select=chip_select)

    def spi_fd_write(self, spi_fd_config, data_list, ainc, addr):
        """
        Sends command for full duplex spi to libcomms controller

        :param spi_fd_config: config object from test_controller_resource_config.yml under 'resource_spi_iface_mahoney'
        :param data: spi packet. includes r/w, ainc, padding, and write data/read padding
        :return: miso packet
        """
        self.host.set_spi_speed(spi_fd_config.speed)

        local_reg, local_data = self.check_iface_arguments(addr, data_list)

        if len(local_data) == 1:
            self.host.spi_write(spi_fd_config.cSelect, local_reg, local_data[0], spi_fd_config.reg_size, spi_fd_config.data_size, spi_fd_config.padding)
        else:
            self.host.spi_block_write(spi_fd_config.cSelect, local_reg, local_data, spi_fd_config.reg_size, spi_fd_config.data_size, spi_fd_config.padding)

    def spi_fd_read(self, spi_fd_config, word_count, ainc, addr):
        """
        Sends command for full duplex spi to libcomms controller

        :param spi_fd_config: config object from test_controller_resource_config.yml under 'resource_spi_iface_mahoney'
        :param data: spi packet. includes r/w, ainc, padding, and write data/read padding
        :return: miso packet
        """
        self.host.set_spi_speed(spi_fd_config.speed)

        if word_count == 1:
            readback = self.host.spi_read(spi_fd_config.cSelect, addr, spi_fd_config.reg_size, spi_fd_config.data_size,
                                  spi_fd_config.padding)
            return [readback]
        else:
            return self.host.spi_block_read(spi_fd_config.cSelect, addr, word_count, spi_fd_config.reg_size, spi_fd_config.data_size,
                                  spi_fd_config.padding)


class SomeConfig():
    pass

# Execute run_test() if this file is run as a script
if __name__ == "__main__":
    # # SAVING, BUT deprecated # #
    """
    # I2C Test - Read from Lochnagar
    from cl_test_station.host_controllers.libclcomms_controller.libclcomms_controller import LibCLcommsController
    from cl_test_station.interfaces.i2c_interface.libclcomms_i2c_config import LibCLcommsI2cConfig
    #
    config_dict = {
        'bus_num': 0,
        'speed': 100,
        'dev_addr': 0x44,
        'reg_size': 2,
        'data_size': 2
    }
    # config = SomeConfig()
    # setattr(config, "bus_num", 0)
    # setattr(config, "speed", 100)
    # setattr(config, "dev_addr", 0x44)
    # setattr(config, "reg_size", 4)
    # setattr(config, "data_size", 2)

    config = LibCLcommsI2cConfig()
    config.configure(config_dict)
    # iface = LibCLcommsController(config)
    iface = LibCLcommsController()
    iface.connect()
    iface.write_i2c_reg(config, 0x0D, 0xAA55)
    readback = iface.read_i2c_reg(config, 0x0D)
    print(hex(readback[0]))
    readback = iface.read_i2c_reg(config, 0)
    print(hex(readback[0]))
    readback = iface.read_i2c_reg(config, 0x0D, 2)
    print(readback)

    # SPI test - Read from shelley
    config = SomeConfig()
    setattr(config, "speed", 1000)
    setattr(config, "cSelect", 0)
    setattr(config, "reg_size", 4)
    setattr(config, "data_size", 4)
    setattr(config, "padding", 4)

    # config = I2cConfig(config_dict)
    # iface = LibCLcommsController(config)
    # iface = LibCLcommsController(config)
    # iface.connect()
    iface.spi_fd_write(config, [0xAAAA5555],False, 0xA8)
    readback = iface.spi_fd_read(config, 1, False, 0xA8)
    print(hex(readback[0]))
    readback = iface.spi_fd_read(config, 1, False, 0)
    print(hex(readback[0]))
    readback = [hex(x) for x in iface.spi_fd_read(config, 2, False, 0)]
    print(readback)
    """
