import time
from dataclasses import dataclass, field
from typing import *

from cl_test_station.gpio.enums import *
from cl_test_station.gpio.pin import (
    Pin,
    input_only_dir,
    input_only_kind,
    output_only_dir,
    output_only_kind,
)
from cl_test_station.register_map.field import Field


@dataclass
class RegmapPin(Pin):
    """Dataclass that represents an input/output pin on the Audiohub."""

    _pin_name: str
    _select: Field = field(repr=False)
    _direction: Field = field(repr=False, default=None)
    _kind: PinKind = PinKind.INOUT
    _visibility: Field = None
    _default_direction: PinDirection = None
    _default_value: int = None

    def __post_init__(self):
        if self._default_direction is not None:
            self.direction = self._default_direction
            if self._default_direction == PinDirection.OUTPUT:
                if self._default_value is not None:
                    self.value = self._default_value

    @property
    def kind(self) -> PinKind:
        """Audiohub regmap controlled pins are either in/out pins controlled
        through a direction field or are input_only or output_only.

        :return: PinKind
        :rtype: PinKind
        """
        kind_value = self._kind
        return PinKind(kind_value)

    @kind.setter
    def kind(self, value: Union[PinKind, int]):
        """This property defines what type of pin this is. PinKind:
        OUTPUT_ONLY=1, INPUT_ONLY=2, INOUT=3.

        :param value: PinKind: OUTPUT_ONLY=1, INPUT_ONLY=2, INOUT=3
        :type value: PinKind | int
        :return: None
        :rtype: None
        """
        if type(value) is PinKind:
            value = value.value
        self._kind.value = value

    @property
    def direction(self) -> PinDirection:
        """Reads the value of the configuration register to get the pin's
        direction.

        :return: Currently configured direction, either INPUT or OUTPUT
        :rtype: PinDirection
        """
        if self.kind is PinKind.INOUT:
            dir_value = self._direction.value
            return PinDirection(dir_value)
        elif self.kind is PinKind.INPUT_ONLY:
            return PinDirection.INPUT
        elif self.kind is PinKind.OUTPUT_ONLY:
            return PinDirection.OUTPUT

    @direction.setter
    def direction(self, value: Union[PinDirection, int]):
        """Writes bit to the direction field to set desired direction. 0 ->
        OUTPUT, 1 -> INPUT.

        :param value: Desired pin direction
        :type value: PinDirection | int
        :return: None
        :rtype: None
        """
        if self.kind is PinKind.INOUT:
            if type(value) is PinDirection:
                value = value.value
            self._direction.value = value
        else:
            raise TypeError(
                f"This pin is configured as {self.kind.name}, therefore direction may not be configured."
            )

    @property
    def value(self) -> int:
        """If input: reads the visibility field.

        If output: reads the currently selected output value.
        :return: value read
        :rtype: int
        """
        if self.direction == PinDirection.INPUT:
            if self._visibility is None:
                raise AttributeError(
                    f"Pin {self._pin_name} is configured to {PinDirection.INPUT.name} and has no visibilty pin."
                )
            else:
                if self._visibility.component.block_apis.FAKE_CS.global_hi_z.value != 0:
                    raise Warning("Global hi z is enabled and may affect values read.")
                value = self._visibility.value
        else:
            value = self._select.value
        return value

    @value.setter
    def value(self, value: int):
        """Value can only be set when the pin direction is set to output. Value
        can be set to 0 or 1. It sets the select field under the hood.

        :param value: Value to output
        :type value: int
        :return: None
        :rtype: None
        """
        if self.direction == PinDirection.INPUT:
            raise AttributeError(
                f"Error setting value for gpio pin {self._pin_name}, because pin direction is set to input."
            )
        else:
            self._select.value = value

    @property
    @output_only_dir
    @output_only_kind
    def output(self) -> int:
        """Returns the current output value.

        :return: Pin level
        :rtype: int
        """
        return self._select.value

    @output.setter
    @output_only_dir
    @output_only_kind
    def output(self, value: int):
        """Sets the output value of the pin.

        :param value:
        :type value: int
        :return: None
        :rtype: None
        """
        self._select.value = value

    @property
    @input_only_dir
    @input_only_kind
    def input(self) -> int:
        """Reads the input value of the pin.

        :return: Input value
        :rtype: int
        """
        if self._visibility is None:
            raise AttributeError(
                f"Pin {self._pin_name} is configured to {PinDirection.INPUT.name} and has no visibilty pin."
            )
        else:
            if self._visibility.component.block_apis.FAKE_CS.global_hi_z.value != 0:
                raise Warning("Global HI-Z is enabled and may affect values read.")
            return self._visibility.value

    @property
    def polarity(self) -> PinPolarity:
        """Not configureable."""
        return PinPolarity.NORMAL

    @output_only_dir
    def toggle(self, active_edge=0, delay=0.2, pulse_width=0.2):
        """Toggles the gpio pin high or low. Active edge 0= -_-  1= _-_

        :param active_edge: 0 - active low; 1 - active high
        :type active_edge: int
        :return:
        :rtype:
        """
        active_low = not active_edge
        if self.direction == PinDirection.INPUT:
            raise Exception(
                f"GPIO pin {self._consumer_name} is configured as input. You must change the direction in order to toggle the output."
            )
        else:
            # Toggle for pulse_width seconds
            self.value = int(active_low)
            time.sleep(delay)
            self.value = int(not active_low)
            time.sleep(pulse_width)
            self.value = int(active_low)
            time.sleep(delay)

    def show_output_select_options(self):
        print(self._select.description)
