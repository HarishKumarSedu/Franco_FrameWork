from embedded_thrift_server.ah_thrift.ttypes import (
    I2c_error,
    Spmi_timeout,
    Spmi_arb_failure,
    GpioAccessError,
    HccDriverError,
    JSONSerializeError,
    ServerError,
    VariantError,
    I3cError,
    I3cDriverError
)
from thrift.Thrift import TApplicationException
from thrift.transport.TTransport import TTransportException
from Pyro5.api import config, register_dict_to_class


_exc_dict = {
    f"{I2c_error.__module__}.{I2c_error.__name__}": I2c_error,
    f"{Spmi_timeout.__module__}.{Spmi_timeout.__name__}": Spmi_timeout,
    f"{Spmi_arb_failure.__module__}.{Spmi_arb_failure.__name__}": Spmi_arb_failure,
    f"{GpioAccessError.__module__}.{GpioAccessError.__name__}": GpioAccessError,
    f"{HccDriverError.__module__}.{HccDriverError.__name__}": HccDriverError,
    f"{JSONSerializeError.__module__}.{JSONSerializeError.__name__}": JSONSerializeError,
    f"{ServerError.__module__}.{ServerError.__name__}": ServerError,
    f"{VariantError.__module__}.{VariantError.__name__}": VariantError,
    f"{I3cError.__module__}.{I3cError.__name__}": I3cError,
    f"{I3cDriverError.__module__}.{I3cDriverError.__name__}": I3cDriverError,
    f"{TApplicationException.__module__}.{TApplicationException.__name__}": TApplicationException,
    f"{TTransportException.__module__}.{TTransportException.__name__}": TTransportException,

}


# Make these exceptions mutable (Thrift generates a custom __setattr__ that breaks Pyro)
for exc in _exc_dict.values():
    exc.__setattr__ = object.__setattr__


def _deserialize_thrift_error(classname: str, obj_dict: dict):  # pragma: no cover
    """
    Custom deserializer for all thrift service exceptions.

    Converts serpent dictionary into the exception. This function does check and only deserialized if Pyro is using
     serpent as the serializer.
    :param classname: Full path class name
    :type classname: str
    :param obj_dict: Serpent object dictionary
    :type obj_dict: dict
    :return: Deserialized thrift exception
    :rtype: Exception
    """
    if config.SERIALIZER == 'serpent':
        exc = _exc_dict[classname](*obj_dict['args'])
        # exc._pyroTraceback = obj_dict['attributes']['_pyroTraceback']
        for attr_name, attr_value in obj_dict['attributes'].items():
            setattr(exc, attr_name, attr_value)
        return exc
    else:
        print('Unable to deserialize as not using serpent serializer for Pyro')

for name in _exc_dict.keys():
    register_dict_to_class(name, _deserialize_thrift_error)
