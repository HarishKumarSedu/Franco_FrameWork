"""
Class definition for AudioHub (AH2/AH3) host controller.

*Author:* Evan Canter <evan.canter@cirus.com>
"""
import inspect
import json
import logging
import os
import posixpath
import shutil
import sys
import time
from importlib import import_module
from queue import Queue
from typing import *
import yaml

from cl_test_station.components.component.component import Component
from cl_test_station.gpio.enums import *
from cl_test_station.gpio.pin import Pin
from cl_test_station.host_controllers.audiohub_controller.enums import XmosConfigs
from cl_test_station.host_controllers.audiohub_controller.master_control import SpmiMasterCtrl
from cl_test_station.host_controllers.audiohub_controller.regmap_pin import RegmapPin
from cl_test_station.host_controllers.audiohub_controller.linux_pin import LinuxPin
from cl_test_station.host_controllers.audiohub_controller.interrupt_pin import InterruptPin
from cl_test_station.host_controllers.host_controller.host_controller import connection_required, skip_if_connected
from cl_test_station.host_controllers.mixins import I3cControllerMixin, ExtendedConfigMixin
from cl_test_station.host_controllers.thrift_controller.thrift_controller import ThriftController
from cl_test_station.interfaces.i3c import I3C_BROADCAST
from cl_test_station.interfaces.i3c.enums import I3cEvents
from cl_test_station.interfaces.i3c.exceptions import I3cError, I3cNackError, I3cParityError
from cl_test_station.interfaces.ctrl_interface import ByteOrder, map_word
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.reusables import reverse_byte
from cl_test_station.utilities.tso_container import TsoContainer
from component_ah3_fpga.ah3_fpga import Ah3Fpga
from component_sdv_spmi_manager.sdv_spmi_manager import SdvSpmiManager
from embedded_thrift_server.ah_thrift.ttypes import Spmi_timeout, Spmi_arb_failure, HccDriverError, I3cError, I3cDriverError
from packaging.version import parse as parse_version


HCC_SPEEDS = {
    24_000_000: 0,
    12_000_000: 1,
    6_000_000:  2,
    3_000_000:  3
}


I3C_ERROR_CODES = {
    'Address NACK': I3cNackError,
    'Parity Error': I3cParityError,
    'I3C Broadcast Address NACK': I3cNackError
}


class ImageVersionError(Exception):
    """Exception reserved for when the user's AH image is incompatible with a feature"""


class AudioHubController(ThriftController, I3cControllerMixin, ExtendedConfigMixin):
    """Driver for AudioHub3 controllers"""
    
    _exteneded_config_name = 'ah_ext_cfg.yml'
    
    # # ----- Variant fields ----- # #
    default_variant: str = TsoField(ftype=str, required=False, desc="Name of variant to check for. Will set variant "
                                                                    "upon connect() if current variant is not the "
                                                                    "one given.")
    spmi_base_addr: int = TsoField(ftype=int, required=False, default=0x43C0_0000,
                              desc="Base address of the SPMI manager's memory space in the Audiohub's FPGA")
    i3c_auto_add_devices: bool = TsoField(ftype=bool, required=False, default=False,
                                          desc="When True, will automatically register I3C devices "
                                               "to the driver if address is not found.")
    # # ------- Fpga fields -------- # #
    fpga_block_config_name: str = TsoField(ftype=str, required=False, default='block_config.yml',
                                           desc='Name of block config yaml for AH3')
    fpga_block_config_path: str = TsoField(ftype=str, required=False, default=None,
                                           desc='Path to block config yaml for AH3')
    fpga_class_type: str = TsoField(ftype=str, required=False, default='component_ah3_fpga.ah3_fpga.Ah3Fpga',
                                    desc='Class type of  AH3 fpga component')
    fpga_register_map_name: str = TsoField(ftype=str, required=False, default='ah3_regs_val.csv',
                                           desc='Name of AH FPGA register map found on the image.')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.fpga: Ah3Fpga = None
        self.spmi_manager: SdvSpmiManager = None
        self.spmi_master = SpmiMasterCtrl(self)  # Legacy SPMI controller
        self.interrupt_queue = Queue()        

    def set_rail_voltage(self, voltage:float):
        """
        Uses level shifter to configure pin levels.

        :param voltage: Desired rail voltage. Can be either 1.2 or 1.8
        :type voltage: float
        :return: None
        """
        if voltage not in [1.2, 1.8]:
            raise ValueError("Please use valid voltages 1.2 or 1.8")
        if self.hostname.lower().startswith('ah2'):
            raise Exception("Rail updates not supported on the AudioHub2")
        self.client.set_rail_voltage(voltage)

    def connect(self, modules: List[str] = None, check_variant: bool = True):
        """
        Updates the code on controller and then attempts to open thrift transport. Will only attempt if there is not an
        existing connection open. Resets the SPMI master and creates spmi control in server

        :param modules: List of names for all modules loaded in python session. Tells the Audiohib what needs to be
            installed on its OS
        :type modules: list
        :param check_variant: After initial conncetion, if the 'default_variant' field was given and the current variant
        is not the desired one, this function will apply the new variant and reconnect
        type check_variant: bool
        :return: None
        :rtype: None
        """
        super().connect(modules)  # Connect to thrift server
        # Set variant
        if self.default_variant and check_variant:
            current_variant = self.get_current_variant()
            if current_variant != self.default_variant:
                self.log.info(
                    f"Current variant is {current_variant}, switching to {self.default_variant} then rebooting")
                self.set_variant(self.default_variant, reboot=True, reconnect=True)
                if self.get_current_variant() == self.default_variant:
                    self.log.debug(f"Successfully set variant to {self.default_variant}")
                else:
                    self.log.error(f"Could set variant to {self.default_variant}, unknown error")
        # Run sequence of initialization functions
        self._run_connect_sequence(
            self.copy_image_register_map,
            self.create_variant_container,
            self._initialize_internal_resources,
            self.create_pins,
            self.enable_spmi
        )

    def copy_image_register_map(self):
        """
        Copies image-specific register map from the AudioHub, located in '/home/regmap'

        :return: None
        """
        # Grab the regmap from the remote OS
        local_file = os.path.join(self.fpga.register_map_path, self.fpga_register_map_name)
        remote_file = posixpath.join('/home', 'regmap', self.fpga_register_map_name)
        try:
            self.ssh.communicate(f'ls {remote_file}')
            self.ssh.scp(local_file, remote_file, put=False)  # scp get
        except (TimeoutError, OSError):
            files = self.ssh.communicate(f'ls {posixpath.dirname(remote_file)}').split('\n')
            self.log.error(f"Could not find {posixpath.basename(remote_file)}, on remote, found:\n\t{', '.join(files)}")

    def toggle_pin(self, pin, mode, invert=False):
        """
        Toggles either a field or register that drives the value of an AH pin

        :func: `my text <mymodule.MyClass.foo>`

        :param pin: pin to toggle
        :type pin: <cl_test_station.host_controllers.audiohub_controller.master_control.Register> or Field
        :param mode: 0 to set pin low; 1 to set pin high; 2 to toggle pin
        :type mode: int
        :param invert: When True, assumes pin is high when value written is 0
        :type invert: bool
        :return: None
        """
        high = int(not invert)
        low = int(invert)
        if mode == 0:  # Set pin low
            pin.value = low
        elif mode == 1:  # Set pin high
            pin.value = high
        elif mode == 2:  # Toggle pin
            # invert = False -> 0 1 0, True --> 1 0 1
            pin.value = low
            pin.value = high
            pin.value = low

    @connection_required
    def reset_dut(self, mode=2, active_low=True):
        """
        Resets the DUT

        :param mode: 0 to set pin low; 1 to set pin high; 2 to toggle pin
        :type mode: int
        :param active_low: active low flag
        :type active_low: bool
        :return: None
        """
        if mode < 0 or mode > 2:
            raise ValueError("Mode must be one of: 0 to set pin low; 1 to set pin high; 2 to toggle pin")
        if self.hostname.startswith('ah2'):  # Use old sysfs function
            self.client.reset_dut(mode, active_low)
        else:  # Use AH3 registers
            # active_low = True --> High Low High --> 0 1 0 (pin is inverted), invert=False
            self.toggle_pin(self.fpga.FAKE_CS.SYSTEM_CONTROL.FORCE_DUT_RESETN, mode=mode, invert=not active_low)

    @connection_required
    def reset_sys(self, mode=2, active_low=True):
        """
        Sets the reset_sys pin

        :param mode: 0 to set pin low; 1 to set pin high; 2 to toggle pin
        :type mode: int
        :param active_low: active low flag
        :type active_low: bool
        :return: None
        """
        if mode < 0 or mode > 2:
            raise ValueError("Mode must be one of: 0 to set pin low; 1 to set pin high; 2 to toggle pin")
        if self.hostname.startswith('ah2'):
            SYS_RESET_NUM = 55
            if mode < 2:
                self.client.set_gpio(1,SYS_RESET_NUM, mode)
            else:
                self.client.toggle_gpio(1, SYS_RESET_NUM, active_low, 0.1, 0.1)  # Default delay and width to 100ms
        else:
            # active_low = True --> High Low High --> 0 1 0 (pin is inverted), invert=False
            self.toggle_pin(self.fpga.FAKE_CS.SYSTEM_CONTROL.FORCE_SYS_RESETN, mode=mode, invert=not active_low)

    def reset_fpga(self):
        """
        Toggles sysfs GPIO to reset Zynq FPGA.
        
        :return: None 
        :rtype: None
        """
        self.ssh_sendcommand('echo 1 > /sys/class/gpio/gpio61/value;'
                             'echo 0 > /sys/class/gpio/gpio61/value;'
                             'echo 1 > /sys/class/gpio/gpio61/value;')

    def program_xmos_image(self, image: Union[XmosConfigs, str]) -> str:
        """
        Programs XMOS image given.

        :param image: Either XmosConfigs enum or string. eg. XmosConfigs.UAC2_16IN_16_OUT_TDM8 or
            "xmos_uac2_16in_16out_tdm8.bin"
        :type image: str
        :return: "Programming complete." if image was successfully programmed
        :rtype: str
        """
        if type(image) is XmosConfigs:
            image = image.value
        return self.client.program_xmos_image(image)

    # # ----- SPMI Functions ----- # #

    def enable_spmi(self):
        """
        Sends enable_spmi command to AudioHub. Uses I2C to set mst_en bit and muxes spmi_mst_irq out to
        interposer pin PDM2_DATA

        :return: None
        """
        # Enable SPMI manager in ah fpga
        self.fpga.enable_spmi()
        # Create SPMI manager memory map and interrupt queue
        self.client.enable_spmi(self.spmi_base_addr)
        return self.spmi_manager.SPMI.CONTROL.value == 3

    def reset_spmi_master(self):
        """
        Resets the spmi master on the audiohup. enable_spmi issues the i2c commands necessary to reset the Spmi master,
        so this function just wraps it using the base address attribute.
        """
        self.enable_spmi(self.spmi_base_addr)

    def spmi_device_initialize(self, device_type, device_id, f_tclk, ddba_addr, inten, enr):
        """Initializes Spmi master"""
        return self.client.spmi_device_initialize(device_type, device_id, f_tclk, ddba_addr, inten, enr)

    def spmi_device_disable(self):
        """Disables spmi master"""
        return self.client.spmi_device_disable()

    def spmi_dump_registers(self):
        """Prints block of master control registers

        :return: list of strings containing reg contents
        """
        return self.client.spmi_dump_registers()

    def spmi_poll_command_sent_flag(self, clear_all_flags=True):
        """Check periodically if CSF flag is set.

        :param clear_all_flags: True or False Value
        :type clear_all_flags: bool
        :return: Return True or False
        """
        return self.client.spmi_poll_command_sent_flag(clear_all_flags)

    def spmi_master_write(self, master_id, address, write_data, use_a_bit=False, use_sr_bit=False, **kwargs):
        """
        Sends master **write** command to internal slave. **NOT FOR USE WITH MAHONEY.**

        :param master_id: Master ID
        :type master_id: int
        :param address: Write address
        :type address: int
        :param write_data: List of bytes to write, up to 16 bytes
        :type write_data: [list<int>]
        :param use_a_bit: Request bus access with a bit
        :type use_a_bit: bool
        :param use_sr_bit: Request bus access with sr bit
        :type use_sr_bit: bool
        :return: Write command to internal slave.
        """
        return self.client.spmi_master_write(master_id, address, write_data, use_a_bit, use_sr_bit)

    def spmi_master_read(self, master_id, address, length=1, use_a_bit=False, use_sr_bit=False, **kwargs):
        """
        Send master **read** command to internal slave. **NOT FOR USE WITH MAHONEY**

        :param master_id: Master ID
        :type master_id: int
        :param address: Write address
        :type address: int
        :param length: Length of read in bytes
        :type length: int
        :param use_a_bit: Request bus access with a bit
        :type use_a_bit: bool
        :param use_sr_bit: Request bus access with sr bit
        :type use_sr_bit: bool
        :return: Read data
        :rtype: int
        """
        if length > 1:
            raise NotImplementedError("Only 1 byte master reads are currently supported")
        return self.client.spmi_master_read(master_id, address, length, use_a_bit, use_sr_bit)

    def spmi_extended_register_write(self, peripheral_id, address, write_data, priority=0, **kwargs):
        """
        Sends extended register **write** command to AudioHub API

        :param peripheral_id: peripheral ID
        :type peripheral_id: int
        :param address: Write address, 8 bit
        :type address: int
        :param write_data: List of bytes to write, up to 16 bytes
        :type write_data: [list<int>]
        :param priority: Arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        """
        # todo: make these return values useful
        # data = spmi_config.pack_byte_array(data, data_size)
        try:
            return self.client.spmi_extended_register_write(peripheral_id, address, write_data, priority)
        except Exception as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_set_master_req_prescaler(self, rate):
        """
        Sends command to AudioHub API to set prescaler value

        :param rate: prescaler value. SCLK freq = 100mHz/4/rate
        """
        return self.client.spmi_set_master_req_prescalemr(rate)

    def spmi_extended_register_read(self, peripheral_id, address, length, priority=0, **kwargs):
        """
        Sends extended register **read** command to AudioHub API

        :param peripheral_id: peripheral ID
        :type peripheral_id: int
        :param address: Read address, 8 bit
        :type address: int
        :param length: Length of read, up to 16 bytes
        :type length: int
        :param priority: Arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        :return: List of read bytes
        :rtype: [list<int>]
        """
        try:
            bytes_in = self.client.spmi_extended_register_read(peripheral_id, address, length, priority)
            return bytes_in
        except Exception as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_extended_register_write_long(self, peripheral_id, address, write_data, priority=0, **kwargs):
        """
        Sends extended register **write long** command to AudioHub API

        :param peripheral_id: peripheral ID
        :type peripheral_id: int
        :param address: Write address, 8 bit
        :type address: int
        :param write_data: List of bytes to write, up to 16 bytes
        :type write_data: [list<int>]
        :param priority: Arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        """
        try:
            return self.client.spmi_extended_register_write_long(peripheral_id, address, write_data, priority)
        except Exception as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_extended_register_read_long(self, peripheral_id, address, length, priority=0, **kwargs):
        """
        Sends extended register **read long** command to AudioHub API

        :param peripheral_id: peripheral ID
        :type peripheral_id: int
        :param address: Write address, 8 bit
        :type address: int
        :param length: Length of read, up to 16 bytes
        :type length: int
        :param priority: Arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        """
        try:
            byte_array = self.client.spmi_extended_register_read_long(peripheral_id, address, length, priority)
            return byte_array
        except Exception as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_set_slave_addr(self, addr):
        """
        Sets internal peripheral ID. **NOT FOR USE WITH MAHONEY**

        :param addr: New peripheral ID
        """
        return self.client.spmi_set_slave_addr(addr)

    def spmi_set_master_addr(self, addr):
        """
        Sets master ID of AudioHub Spmi master

        :param addr: Master ID
        """
        return self.client.spmi_set_master_addr(addr)

    def spmi_set_ip_version(self, version):
        """
        Sets verison of SPMI

        :param version: 0 = Spmi1.0, 1 = Spmi2.0
        """
        return self.client.spmi_set_ip_version(version)

    def spmi_register_write(self, peripheral_id, address, write_data, priority=0, **kwargs):
        """
        Sends register **write** command to AudioHub API

        :param peripheral_id: peripheral ID
        :type peripheral_id: int
        :param address: Write address, 5 bit
        :type address: int
        :param write_data: Write data, 1 byte
        :type write_data: int
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        """
        try:
            return self.client.spmi_register_write(peripheral_id, address, write_data, priority)
        except Exception as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_register_read(self, peripheral_id, address, priority=0, **kwargs):
        """
        Sends register **read** command to AudioHub API

        :param peripheral_id: peripheral ID
        :param address: Read address, 5 bit
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :return: [int] read byte
        """
        try:
            return self.client.spmi_register_read(peripheral_id, address, priority)
        except Exception as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_24bit_read(self, slave_id, address, word_count, priority=0, pointer=0, **kwargs):
        """
        Uses 24 bit pointers in master to access full mahoney register space

        :param slave_id: Slave ID
        :param address: 24-bit address
        :param word_count: number of words to read (Auto increment)
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :param pointer: pointer index, indicates which 24-bit pointer to use
        :return: list of words
        """
        try:
            return self.client.spmi_24bit_read(slave_id, address, word_count, priority, pointer)
        except Exception as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_24bit_write(self, slave_id, address, write_data, priority=0, pointer=0, **kwargs):
        """
        Uses 24 bit pointers in master to access full mahoney register space

        :param slave_id: Slave ID
        :param address: 24-bit address
        :param write_data: List of bytes to write, up to 16 bytes
        :type write_data: [list<int>]
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        :type priority: int
        :param pointer: pointer index, indicates which 24-bit pointer to use
        :type pointer: int
        :return: list of words
        """
        try:
            return self.client.spmi_24bit_write(slave_id, address, write_data, priority, pointer)
        except Exception as arb_err:  # Spmi_arb_failure as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def attempt_spmi_func(self, func, args):
        """**Place Holder**"""
        try:
            return func(*args)
        except Spmi_arb_failure as arb_err:
            self.client.release_lock()
            self.log.info(arb_err.error_output)
            if 'NACK' in arb_err.error_output:
                return -2  # code for NACK on write
            else:
                return -1  # code for parity on write
        except Spmi_timeout as timeout_err:
            self.client.release_lock()
            self.log.info(timeout_err.error_output)
            return -3  # code for timeout error

    def spmi_block_read(self, peripheral_id, start_addr, byte_count, addressibility, priority=0, **kwargs):
        """
        Performs multiple SPMI transactions to read bytes from successive addresses.

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param start_addr: Start address if block read
        :type start_addr: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: List of Bytes rec'd from SDATA
        :rtype: list
        """
        return self.attempt_spmi_func(self.client.spmi_block_read, args=(peripheral_id, start_addr, byte_count, addressibility, priority))

    def spmi_block_write(self, peripheral_id, start_addr, write_data, addressibility, priority=0, **kwargs):
        """
        Performs multiple SPMI transactions to write bytes from successive addresses.

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param start_addr: Start address if block read
        :type start_addr: int
        :param write_data: List of bytes to write
        :type write_data: list
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: None
        """
        return self.attempt_spmi_func(self.client.spmi_block_write, args=(peripheral_id, start_addr, write_data, addressibility, priority))

    def spmi_chain_read(self, peripheral_id, address, num_reads, read_size, addressibility, priority=0, **kwargs):
        """
        Performs successive reads on the same address and returns concatenated list of bytes

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param address: Address of chain read
        :type address: int
        :param num_reads: Number of separate SPMI transactions to perform
        :type num_reads: int
        :param read_size: Number of bytes to read per SPMI transaction
        :type read_size: int
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: List of bytes
        :rtype: list
        """
        cutoff = 0x100 - int(read_size / addressibility)
        if read_size > 8 and address > cutoff:
            raise ValueError("Cannot read more than 8 bytes at a time with a 16 bit address")
        if read_size > 16:
            raise ValueError("Cannot read more than 16 bytes at a time with SPMI")
        if address > 0xFFFF:
            raise ValueError(f"Address can not be more than 16 bit: {address}")

        return self.attempt_spmi_func(self.client.spmi_chain_read, args=(peripheral_id, address, num_reads, read_size, addressibility, priority))

    def spmi_chain_write(self, peripheral_id, address, write_data, write_size, addressibility, priority=0, **kwargs):
        """
        Performs successive writes to the same address

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param address: Address of chain read
        :type address: int
        :param write_data: List of bytes to write
        :type write_data: list
        :param write_size: Number of bytes to read per SPMI transaction
        :type write_size: int
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: None
        """
        cutoff = 0x100 - int(write_size / addressibility)
        if write_size > 8 and address > cutoff:
            raise ValueError("Cannot write more than 8 bytes at a time with a 16 bit address")
        if write_size > 16:
            raise ValueError("Cannot write more than 16 bytes at a time with SPMI")
        if address > 0xFFFF:
            raise ValueError(f"Address can not be more than 16 bit: {address}")

        return self.attempt_spmi_func(self.client.spmi_chain_write, args=(peripheral_id, address, write_data, write_size
                                                                          , addressibility, priority))

    # # ----- SPMI Interrupt Functions ----- # #

    def poll_for_int(self, int_id=-1):
        """
        Manually polls for interrupt, returns master write data

        :param int_id: ID of interrupt to poll for. Default of -1 means return the next interrupt for any ID. If
            specified, all interrupts not = int_id will be ignored
        :type int_id: int
        :return: int
        """
        # Get json dictionary string
        json_string = self.client.handle_interrupt(int_id)
        json_dict = json.loads(json_string)
        return json_dict['ID']

    def empty_server_queue(self, timeout=0):
        """
        Internal method for pulling queued interrupt data up from the Audiohub

        :return: none
        """
        if timeout <= 0:
            strings = self.client.empty_server_queue()
        else:
            start = time.time()
            strings = []
            while time.time() - start < (timeout + 0.01):
                strings = self.client.empty_server_queue()
                if len(strings) > 0:
                    break
        for s in strings:
            self.interrupt_queue.put(s)

    def clear_queue(self):
        """
        Clears both the server and client interrupt queue; erases all previous interrupt data

        :return: None
        """
        self.empty_server_queue()
        self.interrupt_queue = Queue()

    def pop_interrupt_queue(self, timeout=0):
        """
        Gets interrupt data from the queue in the form of a dictionary.
        The first two Key-value pairs are 'ID' : int, 'result': bool
        Queue is FIFO

        :return: dictionary
        """
        if self.interrupt_queue.empty():
            self.empty_server_queue(timeout)
        try:
            return json.loads(self.interrupt_queue.get(block=False))
        except:
            return 'EMPTY'

    def interrupt_queue_empty(self):
        """
        Method to check if there are any pending interrupt results in the queue

        :return: True if empty, False otherwise
        """
        if self.interrupt_queue.empty():
            self.empty_server_queue()
        return self.interrupt_queue.empty()

    def start_embedded_interrupt_handling(self, int_map, verbose=False, functions=''):
        """
        Starts the background interrupt handling thread on the AH

        :return: True if successful
        """
        self.clear_queue()

        if self.client.start_embedded_interrupt_handling(int_map, verbose, functions) and not functions == 'legacy':
            functions_list = json.loads(functions).keys()
            self.log.info('Interrupt handling thread active with service%s: ' % ('s' if len(functions_list) > 1 else '')
                          + ', '.join(functions_list))

    def print_from_buffer(self):
        """Returns the self.client.print_from_buffer."""
        return self.client.print_from_buffer()

    def stop_embedded_interrupt_handling(self):
        """
        Stops the background interrupt handling thread on the AH

        :return: True if successful
        """
        self.clear_queue()
        result = self.client.stop_embedded_interrupt_handling()
        if result:
            self.lof.info('Halted interrupt handling thread')

    def clear_interrupt_handler(self):
        """
        Injects the basic interrupt handler class into the AH, removing any custom services
        """
        lp = os.path.expandvars(
            "$PROJECT_ROOT") + r'\mahoney_fw_test\framework\host_controller\audiohub_controller\embedded_tests'
        with open(lp + r'\template_handler.py', 'r') as f:
            content = f.read()
        with open(lp + r'\interrupt_handler_embedded.py', 'w') as f:
            f.write(content)
        rp = '/home/Projects/Mahoney/mahoney_fw_test/framework/host_controller/' \
             'audiohub_controller/embedded_tests/interrupt_handler_embedded.py'
        self.download(lp + r'\interrupt_handler_embedded.py', rp)

    def inject_input_files(self):
        """
        **Place holder!**

        :return:
        """
        import yaml
        import json
        yaml.warnings({'YAMLLoadWarning': False})

        # Convert interrupt yaml into json
        mapping_file = self.input_data['int_mapping']
        with open(os.path.expandvars(mapping_file), 'r') as yml_file:
            map_string = yml_file.read()
        temp_dict = yaml.load(map_string, Loader=yaml.SafeLoader)
        json_string = json.dumps(temp_dict)
        json_file = os.path.expandvars(self.input_data['int_json'])
        with open(json_file, 'w') as f:
            f.write(json_string)

        resource_file = self.input_data['resource_config_yml']
        with open(os.path.expandvars(resource_file), 'r') as yml_file:
            map_string = yml_file.read()
        temp_dict = yaml.load(map_string, Loader=yaml.SafeLoader)
        json_string = json.dumps(temp_dict)
        json_file = os.path.expandvars(self.input_data['resource_config_json'])
        with open(json_file, 'w') as f:
            f.write(json_string)

        for input_file in self.input_data.keys():
            if not self.input_data[input_file].endswith(".yml"):
                self.download(os.path.expandvars(self.input_data[input_file]),
                              '/home/Projects/Mahoney/mahoney_fw_test/input_data/')

    # # ----- HCC Functions ----- # #

    def hcc_queue_packets(self, packets, cs_delays, **kwargs):
        """
        Sends packets to Audiohub and queues them using the HCC Driver. len(packets) needs to equal len(cs_delays)

        :param packets: List of lists of bytes. Each list of bytes is a separate HCC Packet
        :type packets: list
        :param cs_delays: List of ints. Contains CS delay for packet at matching index.
        :type cs_delays: list
        :return: None
        """
        lsb_packets = [[reverse_byte(b) for b in packet] for packet in packets]
        self.client.hcc_queue_packets(lsb_packets, cs_delays)

    def hcc_send_packet(self, packet, cs_delay, **kwargs):
        """
        Sends packet onto the physical bus, returns bytes received from HCC Device.

        :param packet: List of bytes to send onto the bus.
        :type packet: list
        :param cs_delay: Time in usec the CS line is deasserted after the packet is finished transmitting
        :type cs_delay: int
        :return: List of ints representing bytes received from the HCC Device
        :rtype: list
        """
        lsb_packet_out = [reverse_byte(b) for b in packet]  # Convert MSBit bytes to LSBit
        # print("LSB packet out:", lsb_packet_out)
        packet_in = self.client.hcc_send_packet(lsb_packet_out, cs_delay)
        # print('LSB packet in: ', [reverse_byte(b) for b in packet_in])
        return [reverse_byte(b) for b in packet_in]  # Convert LSBit bytes to LSBit

    def hcc_execute_packet_queue(self, **kwargs):
        """
        Issues all queued packets and returns list of lists of ints (list of return packets from HCC Device)

        :return: List of list of integers (Bytes), packets received from HCC Device
        :rtype: list
        """
        packets_in = self.client.hcc_execute_packet_queue()
        return [[reverse_byte(b) for b in packet] for packet in packets_in]

    @connection_required
    def enable_hcc(self, bus_num, chip_select, **kwargs):
        """
        Allows HCC Driver to access SPI Controller

        :param bus_num: SPI Bus number
        :type bus_num: int
        :param chip_select: Chip Select line
        :type chip_select: int
        :return: None
        """
        self.client.enable_hcc(bus_num, chip_select)

    @connection_required
    def disable_hcc(self, **kwargs):
        """
        Disconnects HCC Driver from SPI Controller

        :return: None
        """
        self.client.disable_hcc()

    @connection_required
    def hcc_set_speed(self, speed, **kwargs):
        """
        Sets bus speed of HCC Driver. Supported speeds are 24MHz, 12MHz, 6MHz, 3MHz. Can also use Porter.

        :param speed: Bus rate in Hz
        :type speed: int
        :return: None
        """
        # TODO: Figure out porter to offer more rates
        if speed in HCC_SPEEDS:
            speed = HCC_SPEEDS[speed]
        else:
            raise ValueError(f"Invalid speed given: %d - speed value must be "
                             f"{', '.join(HCC_SPEEDS.keys()[:-1])}, or {HCC_SPEEDS.keys()[-1]} Hz")
        self.client.hcc_set_speed(speed)

    def _check_image_version(self, version: str):
        curr_image = self.get_image_version()
        if parse_version(version) < parse_version(curr_image):
            raise ImageVersionError(f"Current AH image {str(curr_image)} < {version}")

    @connection_required
    def hcc_set_setup_delay(self, delay: int):
        """
        Configures the controller setup delay for transactions.

        :param delay: Setup delay in usec
        :type delay: int
        :return: None
        :rtype: None
        """
        self._check_image_version('2.5.0')
        self.client.hcc_set_setup_delay(delay)

    @connection_required
    def hcc_set_bit_order(self, order: int):
        """
        Sets bit order of Bytes sent out over MOSI

        :param order: Bit order, 0 = MSB first, 1 = LSB first
        :type order: int
        :return: None
        :rtype: None
        """
        self._check_image_version('2.5.0')
        if order not in [0, 1]:
            raise ValueError(f"Invalid order given ({order}), can either be 0 (MSB first) or 1 (LSB first)")
        self.client.hcc_set_bit_order(order)

    @connection_required
    def hcc_set_clk_mode(self, mode: int):
        """
        Sets hcc-spi clock mode.

        :param mode: SPI mode. Can be 0, 1, 2, 3. Denotes value of CPOL and CPHA:

        ======== ==== ==== ========== ======================
        clk_mode CPOL CPHA Idle Clock Sample edge/Shift edge
        -------- ---- ---- ---------- ----------------------
        0        0    0    logic low  rising/falling
        1        0    1    logic low  falling/rising
        2        1    0    logic high rising/falling
        3        1    1    logic high falling/rising
        ======== ==== ==== ========== ======================

        :type mode: int
        :return: None
        :rtype: None
        """
        self._check_image_version('2.5.0')
        if mode not in range(0, 4):
            raise ValueError(f"Invalid clock mode given ({mode}), can be 0, 1, 2, 3")
        self.client.hcc_set_clk_mode(mode)

    @connection_required
    def hcc_driver_register(self, handler=''):
        """
        Regsiters HINT Signal, builds serialized handler if specified

        :param handler: Result from calling ts_function_serializer func_dumps
        :type handler: str
        :return: None
        """
        self.client.hcc_register(handler)

    @connection_required
    def hcc_driver_unregister(self):
        """
        Removes HINT Signal from python process

        :return: None
        """
        self.client.hcc_unregister()

    def hcc_hint_queue_get(self, timeout=0):
        """
        Grabs interrupt response from server queue. Returns '__empty' if empty

        :param timeout: If no response is found in queue after timeout seconds, returns '__empty'
        :type timeout: float
        :return: Interrupt response
        :rtype: Any
        """
        return json.loads(self.client.hcc_hint_queue_get(timeout))

    # # ----- I3C Functions ----- # #

    def enable_i3c(self, bus_num: int) -> bool:
        return self.client.enable_i3c(bus_num)

    def disable_i3c(self, bus_num: int):
        return self.client.disable_i3c(bus_num)

    def i3c_controller_rstdaa(self, bus_num: int, address: int = 0x7E, detach_devs: bool = False, **kwargs):
        """
        Uses I3C Controller to issue the RSTDAA CCC (Reset dynamic address assignments) to 'address'

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: I3C address. Defaults to broadcast address = 0x7E
        :type address: int
        :param detach_devs: After issuing the CCC, remove all devices from the driver's interal device list
        :type detach_devs: bool
        :return: None
        :rtype: None
        """
        try:
            return self.client.i3c_controller_rstdaa(bus_num, address, detach_devs)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None
        except Exception as other:
            print(other)

    def i3c_controller_setaasa(self, bus_num: int, **kwargs):
        """
        Uses I3C Controller to issue the SETAASA Broadcast CCC (Set static address as dynamic address)

        :param bus_num: I3C bus number
        :type bus_num: int
        :return: None
        :rtype: None
        """
        return self.client.i3c_controller_setaasa(bus_num)

    def i3c_controller_setdasa(self, bus_num: int, static_addr: int, dyn_addr: int, **kwargs):
        """
        Uses I3C Controller to issue the SETDASA CCC (Set dynamic address from static address)

        :param bus_num: I3C bus number
        :type bus_num: int
        :param static_addr: I3C static device address
        :type static_addr: int
        :param dyn_addr: Desired I3C dynamic device address
        :type dyn_addr: int
        :return: None
        :rtype: None
        """
        return self.client.i3c_controller_setdasa(bus_num, static_addr, dyn_addr)

    def i3c_controller_setnewda(self, bus_num: int, old_addr: int, new_addr: int, **kwargs):
        """
        Uses I3C Controller to issue the SETDASA CCC (Set dynamic address from static address)

        :param bus_num: I3C bus number
        :type bus_num: int
        :param old_addr: Device address to change
        :type old_addr: int
        :param new_addr: New device address
        :type new_addr: int
        :return: None
        :rtype: None
        """
        self.client.i3c_controller_setnewda(bus_num, old_addr, new_addr)

    def i3c_controller_dodaa(self, bus_num: int, reset_addr_assignments: bool = True, **kwargs) -> Dict[int, int]:
        """
        Performs a DAA (dynamic address assignment) using CCC ENTDAA and returns a dictionary where the keys are device
        PIDs and values are the assigned dynamic addresses.

        :param bus_num: I3C bus number
        :type bus_num: int
        :return: Dynamic address assignments
        :rtype: Dict[int, int]
        """
        return self.client.i3c_controller_dodaa(bus_num, reset_addr_assignments)

    def i3c_controller_enec(self, bus_num: int, events: int = 0, address: Union[int, I3cEvents] = I3C_BROADCAST, **kwargs):
        """
        Uses I3C Controller to issue the ENEC CCC (Enable Events Command). Payload contains which events will be
        enabled.

        Payload format (1 Byte):

        ========================  ============  =============  ============  ============
                reserved           hot_join       reserved     mastership     int_req
        ========================  ============  =============  ============  ============
                 4 Bits             1 Bit        1 Bit         1 Bit          1 Bit
        ========================  ============  =============  ============  ============

        Example:

        # Enable Target interrupt requests and hot join events for **all** devices, leave mastership requests untouched
        i3c_controller_enec(bus_num=0, events=I3cEvents.TARGET_INT_REQ | I3cEvents.HOT_JOIN_EVENT)

        :param bus_num: I3C bus number
        :type bus_num: int
        :param events: Events to enable. OR of cl_test_station.interfaces.i3c.enums.I3cEvents members.
        :type events: int | I3cEvents
        :param address: Target device, or all devices if address==BROADCAST
        :type address: int
        :return: None
        :rtype: None
        """
        if isinstance(events, I3cEvents):
            events = events.mask
        return self.client.i3c_controller_enec(bus_num, address, payload=events)

    def i3c_controller_disec(self, bus_num: int, events: Union[int, I3cEvents] = 0, address: int = I3C_BROADCAST, **kwargs):
        """
        Uses I3C Controller to issue the DISEC CCC (Disable Events Command). Paylod contains which events will be
        disabled.

        Payload format (1 Byte):

        ========================  ============  =============  ============  ============
                reserved           hot_join       reserved     mastership     int_req
        ========================  ============  =============  ============  ============
                 4 Bits             1 Bit        1 Bit         1 Bit          1 Bit
        ========================  ============  =============  ============  ============

        Example:

        # Disable Target interrupt requests and hot join events for **all** devices, leave mastership requests untouched
        i3c_controller_disec(bus_num=0, events=I3cEvents.TARGET_INT_REQ | I3cEvents.HOT_JOIN_EVENT)

        :param bus_num: I3C bus number
        :type bus_num: int
        :param events: Events to disable. OR of cl_test_station.interfaces.i3c.enums.I3cEvents members.
        :type events: int | I3cEvents
        :param address: Target device, or all devices if address==BROADCAST
        :type address: int
        :return: None
        :rtype: None
        """
        if isinstance(events, I3cEvents):
            events = events.mask
        return self.client.i3c_controller_disec(bus_num, address, payload=events)

    def i3c_controller_getpid(self, bus_num: int, address: int, **kwargs) -> int:
        """
        Uses I3C Controller to issue the GETPID CCC (Get Provisional ID). The driver's device info will be updated with
        the PID response, and this function will also return the PID in the form of an integer.

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :return: Provisional ID
        :rtype: int
        """
        return self.client.i3c_controller_getpid(bus_num, address, self.i3c_auto_add_devices)

    def i3c_controller_getbcr(self, bus_num: int, address: int, **kwargs) -> int:
        """
        Uses I3C Controller to issue the GETBCR CCC (Get Bus Characteristics Register). The driver's device info will
        be updated with the BCR value, and this function will also return the BCR in the form of an integer.

        BCR Format:

        =============  ==========  ===========  =================  =============  =================  ========================
        device_role    reserved    is_bridge    offline_capable    ibi_payload    ibi_req_capable    max_data_speed_limited
        =============  ==========  ===========  =================  =============  =================  ========================
          2 Bits       1 Bit       1 Bit        1 Bit              1 Bit          1 Bit              1 Bit
        =============  ==========  ===========  =================  =============  =================  ========================

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :return: BCR value
        :rtype: int
        """
        return self.client.i3c_controller_getbcr(bus_num, address, self.i3c_auto_add_devices)

    def i3c_controller_getdcr(self, bus_num: int, address: int, **kwargs) -> int:
        """
        Uses I3C Controller to issue the GETDCR CCC (Get Device Characteristics Register). The driver's device info will
        be updated with the DCR value, and this function will also return the DCR in the form of an integer.

        The DCR is a 1 Byte code the describes the type of device. Default value is 0x00 for a generic device

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :return: DCR value
        :rtype: int
        """
        return self.client.i3c_controller_getdcr(bus_num, address, self.i3c_auto_add_devices)

    def i3c_controller_getstatus(self, bus_num: int, address: int, **kwargs) -> int:
        """
        Uses I3C Controller to issue the GETSTATUS CCC (Get Device Status). The driver's device info will
        be updated with the device's status value, and this function will also return the DCR in the form of an integer.

        Status format:

        ======================  ===============  ================  ==========  ======================
          vendor_reserved       activity_mode    protocol_error    reserved     pending_interrupt
        ======================  ===============  ================  ==========  ======================
               8 Bits             2 Bits         1 Bit             1 Bit              4 Bits
        ======================  ===============  ================  ==========  ======================

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :return: DCR value
        :rtype: int
        """
        return self.client.i3c_controller_getstatus(bus_num, address, self.i3c_auto_add_devices)

    def i3c_controller_add_device(self, bus_num: int, static_addr: int = None, dyn_addr: int = None, **kwargs):
        """
        Attaches a new I3C device to the driver.

        1. If only a static address is given (dyn_addr==0), the SETAASA CCC is assumed to have been broadcasted already.
        2. If only a dynamic address is given (static_addr==0), a device will be added using 'dyn_addr'
        3. If a static and dynamic address is given, this function will issue a SETDASA.

        :param bus_num: I3C bus number
        :type bus_num: int
        :param static_addr: I3C static device address
        :type static_addr: int
        :param dyn_addr: Desired I3C dynamic device address
        :type dyn_addr: int
        :return: None
        :rtype: None
        """
        if static_addr is None:
            static_addr = 0
        if dyn_addr is None:
            dyn_addr = 0
        if not static_addr and not dyn_addr:
            raise ValueError("At least one address (static or dynamic) is required.")
        return self.client.i3c_controller_add_device(bus_num, static_addr, dyn_addr)
    
    def i3c_controller_add_i2c_device(self, bus_num: int, address: int, replace: bool = True):
        """
        Adds legacy I2C device to the DWC I3C driver. If replace is True, exitsting devices at 'address' will be
        removed. If replace is False and a device already exists (Either I3C or legacy I2C), an I3cDriverError is raised.

        :param bus_num: Bus number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param replace: Replace existing device with new I2C device
        :type replace: bool
        :return: None
        :rtype: None
        """
        self.client.i3c_controller_add_i2c_device(bus_num, address, replace)
        
    def i3c_controller_get_devices(self, bus_num: int) -> List[str]:
        """
        Returns list of __str__ strings for all i3c devices attached to the driver.

        :return: List of I3cDeviceInfo __str__ results
        :rtype: List[str]
        """
        return self.client.i3c_controller_get_devices(bus_num) + self.client.i3c_controller_get_i2c_devices(bus_num)

    def i3c_controller_dump_devices(self, bus_num: int, log_level='INFO'):
        """
        Logs all i3c devices attached to the driver.

        :return: List of I3cDeviceInfo __str__ results
        :rtype: List[str]
        """
        msg = '\n'.join(self.i3c_controller_get_devices(bus_num))
        self.log.log(logging._nameToLevel.get(log_level), f"Devices currently added to I3C Driver:\n{msg}")

    def i3c_controller_remove_device(self, bus_num: int, address: int):
        """
        Removes device from I3C driver. Can be I3C or legacy I2C device.

        :param bus_num: Bus number
        :type bus_num: int
        :param address: Either I3C dynamic address or I2C address
        :type address: int
        :return: None
        :rtype: None
        """
        self.client.i3c_controller_remove_device(bus_num, address)

    def _i3c_get_exc(self, error_code: str, msg: str) -> I3cError:
        """
        Parses error code returned from server and returns corrosponding exception.

        :param error_code: Error code receviced from I3C driver
        :type error_code: int
        :param msg: Error message
        :type msg: str
        :return: I3C Exception object
        :rtype: I3cError
        """
        if error_code in I3C_ERROR_CODES:
            return I3C_ERROR_CODES[error_code](msg)
        return I3cError(f"Unknown I3C Error: {msg}")

    def i3c_read_device(self, bus_num: int, address: int, num_bytes: int,
                        preamble_bytes: List[int] = None, **kwargs) -> List[int]:
        """
        Reads 'num_bytes' from an I3C device at 'address'. If preamble_bytes is populated, those bytes will be written
        to the device before the read operation. Otherwise, only a read transfer will be executed.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :return: List of bytes read from the device, or an error code if one occurred
        :rtype: List[int]
        """
        if preamble_bytes is None:
            preamble_bytes = []
        try:
            return self.client.i3c_read_device(bus_num, address, num_bytes, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    def i3c_read_reg(self, bus_num: int, address: int, reg_addr: int, num_bytes: int = 4,
                     preamble_bytes: List[int] = None, read_reg_addr_size: int = 4,
                     addr_byte_order: ByteOrder = ByteOrder.MSB_FIRST, **kwargs) -> List[int]:
        """
        Reads 'num_bytes' from register address 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before the register address.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :type reg_addr: Register address
        :param reg_addr: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :param read_reg_addr_size: Size of register address
        :type read_reg_addr_size: int
        :param addr_byte_order: Byte order of register addr
        :type addr_byte_order: ByteOrder
        :return: List of bytes read starting from register at address 'reg_addr'
        :rtype: List[int]
        """
        if preamble_bytes is None:
            preamble_bytes = []
        # Convert register address to bytes
        reg_addr_list = map_word(word=reg_addr, word_size=read_reg_addr_size, byte_order=addr_byte_order)
        try:
            return self.client.i3c_read_reg(bus_num, address, reg_addr_list, num_bytes, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    def i3c_write_device(self, bus_num: int, address: int, write_data: List[int], preamble_bytes: List[int] = None, **kwargs):
        """
        Writes 'write_data' to I3C device at 'address'. If preamble_bytes is populated,those bytes will be written
        to the device before write_data.

        If an error code is returned from the write transfer, this function will raise an I3cError

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :return: None
        :rtype: None
        """
        if preamble_bytes is None:
            preamble_bytes = []
        try:
            return self.client.i3c_write_device(bus_num, address, write_data, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    def i3c_write_reg(self, bus_num: int, address: int, reg_addr: int, write_data: List[int],
                      preamble_bytes: List[int] = None, write_reg_addr_size: int = 4,
                      addr_byte_order: ByteOrder = ByteOrder.MSB_FIRST, **kwargs):
        """
        Writes 'write_data' to I3C register at 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before register address.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :param reg_addr: Register address
        :type reg_addr: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :param write_reg_addr_size: Size of register address
        :type write_reg_addr_size: int
        :param addr_byte_order: Byte order of register addr
        :type addr_byte_order: ByteOrder
        :return: None
        :rtype: None
        """
        if preamble_bytes is None:
            preamble_bytes = []
        # Convert register address to bytes
        reg_addr_list = map_word(word=reg_addr, word_size=write_reg_addr_size, byte_order=addr_byte_order)
        try:
            return self.client.i3c_write_reg(bus_num, address, reg_addr_list, write_data, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    # I3C Legacy I2C functions

    def i3c_legacy_i2c_read_device(self, bus_num: int, address: int, num_bytes: int,
                                   preamble_bytes: List[int] = None, **kwargs) -> List[int]:
        """
        Reads 'num_bytes' from a legacy I2C device at 'address'. If preamble_bytes is populated, those bytes will be written
        to the device before the read operation. Otherwise, only a read transfer will be executed.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :return: List of bytes read from the device, or an error code if one occurred
        :rtype: List[int]
        """
        if preamble_bytes is None:
            preamble_bytes = []
        try:
            return self.client.i3c_legacy_i2c_read_device(bus_num, address, num_bytes, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    def i3c_legacy_i2c_read_reg(self, bus_num: int, address: int, reg_addr: int, num_bytes: int = 4,
                                preamble_bytes: List[int] = None, read_reg_addr_size: int = 4,
                                addr_byte_order: ByteOrder = ByteOrder.MSB_FIRST, **kwargs) -> List[int]:
        """
        Reads 'num_bytes' from register address 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before the register address.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :type reg_addr: Register address
        :param reg_addr: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :param read_reg_addr_size: Size of register address
        :type read_reg_addr_size: int
        :param addr_byte_order: Byte order of register addr
        :type addr_byte_order: ByteOrder
        :return: List of bytes read starting from register at address 'reg_addr'
        :rtype: List[int]
        """
        if preamble_bytes is None:
            preamble_bytes = []
        # Convert register address to bytes
        reg_addr_list = map_word(word=reg_addr, word_size=read_reg_addr_size, byte_order=addr_byte_order)
        try:
            return self.client.i3c_legacy_i2c_read_reg(bus_num, address, reg_addr_list, num_bytes, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    def i3c_legacy_i2c_write_device(self, bus_num: int, address: int, write_data: List[int], preamble_bytes: List[int] = None, **kwargs):
        """
        Writes 'write_data' to a legacy I2C device at 'address'. If preamble_bytes is populated,those bytes will be
        written to the device before write_data.

        If an error code is returned from the write transfer, this function will raise an I3cError

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :return: None
        :rtype: None
        """
        if preamble_bytes is None:
            preamble_bytes = []
        try:
            return self.client.i3c_legacy_i2c_write_device(bus_num, address, write_data, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    def i3c_legacy_i2c_write_reg(self, bus_num: int, address: int, reg_addr: int, write_data: List[int],
                      preamble_bytes: List[int] = None, write_reg_addr_size: int = 4,
                      addr_byte_order: ByteOrder = ByteOrder.MSB_FIRST, **kwargs):
        """
        Writes 'write_data' to a legacy I2C device register at 'reg_addr'. If preamble_bytes is populated, those bytes
        will be written to the device before register address.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param reg_addr: Register address
        :type reg_addr: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :param write_reg_addr_size: Size of register address
        :type write_reg_addr_size: int
        :param addr_byte_order: Byte order of register addr
        :type addr_byte_order: ByteOrder
        :return: None
        :rtype: None
        """
        if preamble_bytes is None:
            preamble_bytes = []
        # Convert register address to bytes
        reg_addr_list = map_word(word=reg_addr, word_size=write_reg_addr_size, byte_order=addr_byte_order)
        try:
            return self.client.i3c_legacy_i2c_write_reg(bus_num, address, reg_addr_list, write_data, preamble_bytes, self.i3c_auto_add_devices)
        except I3cError as i3c_err:
            raise self._i3c_get_exc(i3c_err.error_code, i3c_err.msg) from None

    def i3c_controller_reset_driver(self, bus_num: int):
        """
        Resets the DWC I3C device, and removes/readds crus-i3c module

        :param bus_num: Bus Number
        :type bus_num: int
        :return: None
        :rtype: None
        """
        # create i3c driver in software (if needed)
        self.enable_i3c(bus_num)
        # Reset and disable i3c from the server
        self.client.server_eval(f"self.dwc_i3c[{bus_num}].write_reg(0x34, 0xFF)")
        # Disable i3c, close fd
        self.disable_i3c(bus_num)
        # remove module, then add it again
        self.ssh_sendcommand('rmmod crus-i3c')
        self.ssh_sendcommand('modprobe crus-i3c')
        # Reenable driver
        self.enable_i3c(bus_num)

    def create_pins(self):
        #Create pin attributes for regmap style pins
        for pdm_num, element in enumerate(self.fpga.block_apis.FAKE_CS.pdm_controls): # asp/pdm num loop
            for key, value in element.items(): #group A loop
                    pin_name = value['sel'].name.rstrip('_SEL').lower()
                    vis = self.fpga.block_apis.FAKE_CS.pdm_visibilities[pdm_num+1][key]
                    self.pins[pin_name] = RegmapPin(pin_name, value['sel'],value['dir'], _visibility=vis)

        vis_keys = ['sclk', 'lrck', 'sdata1', 'sdata2']
        for asp_num, element in enumerate(self.fpga.block_apis.FAKE_CS.asp_controls): # asp/pdm num loop
            for index, key_val_pair in enumerate(element.items()): #group A loop
                    key, value = key_val_pair
                    pin_name = value['sel'].name.rstrip('_SEL').lower()
                    asp_vis = self.fpga.block_apis.FAKE_CS.asp_visibilities[asp_num+1]
                    self.pins[pin_name] = RegmapPin(pin_name, value['sel'],value['dir'], _visibility=asp_vis[vis_keys[index]])

        for element in self.fpga.block_apis.FAKE_CS.sai_controls.values():
            pin_name = element['sel'].name.rstrip('_SEL',).lower()
            self.pins[pin_name] = RegmapPin(pin_name, element['sel'], element['dir'])

        for element in self.fpga.block_apis.FAKE_CS.sao_clk_controls.values():
            pin_name = element['sel'].name.rstrip('_SEL').lower()
            self.pins[pin_name] = RegmapPin(pin_name, element['sel'], element['dir'])

        self.pins['sao_sdo1'] = RegmapPin('sao_sdo1', _select=self.fpga.block_apis.FAKE_CS.sao_sdo1_sel,
                                            _kind=PinKind.OUTPUT_ONLY)

        for element in self.fpga.block_apis.FAKE_CS.mclk_controls:
            pin_name = element['sel'].name.rstrip('_SEL').lower()
            self.pins[pin_name] = RegmapPin(pin_name, element['sel'], element['dir'])

        self.pins['pll_clk_in'] = RegmapPin('pll_clk_in', _select = self.fpga.block_apis.FAKE_CS.pll_clk_in, _kind = PinKind.INPUT_ONLY)
        self.pins['usb_audio_sdin1'] = RegmapPin('usb_audio_sdin1', _select=self.fpga.block_apis.FAKE_CS.usb_audio_sdin_sel[1],
                                            _kind=PinKind.OUTPUT_ONLY)

        #Create pin attributes for linux style pins
        self.pins['dev_gpio0'] = LinuxPin('DEV_GPIO0', self)
        self.pins['dev_gpio1'] = LinuxPin('DEV_GPIO1', self)
        self.pins['dev_gpio2'] = LinuxPin('DEV_GPIO2', self)
        self.pins['dev_gpio3'] = LinuxPin('DEV_GPIO3', self)
        self.pins['dev_dut_reset_n'] = LinuxPin('DEV_DUT_RESET_N', self, PinDirection.OUTPUT, 1)
        self.pins['dev_sys_reset_n'] = LinuxPin('DEV_SYS_RESET_N', self, PinDirection.OUTPUT, 1)

        self.mmap_add(0xE000A068, 4, 4)
        self.pins['dev_int0_n'] = InterruptPin(self, 0)
        self.pins['dev_int1_n'] = InterruptPin(self, 1)
        self.pins['dev_int2_n'] = InterruptPin(self, 2)
        self.pins['dev_int3_n'] = InterruptPin(self, 3)

    @connection_required
    def get_variants(self) -> List[str]:
        """
        Lists all variant names available.

        :return: List of variant names
        :rtype: List[str]
        """
        return self.client.get_variants()

    @connection_required
    def get_current_variant(self) -> str:
        """
        Reads boot.bin and returns currently configured variant name.

        :return: Variant name
        :rtype: str
        """
        return self.client.get_current_variant()

    @connection_required
    def set_variant(self, variant: str, reboot: bool = False, reconnect: bool = False):
        """
        Sets the variant on the AudioHub. Copies new boot.bin into /mnt/boot and creates new symlink to register map.

        :param variant: Variant name. Use self.variants to view what's available
        :type variant: str
        :param reboot: After syncing, sends reboot command
        :type reboot: bool
        :param reconnect: After rebooting, reestablishes ssh sesson and reconnects to the thrift server
        :type reconnect: bool
        :return: None
        :rtype: None
        """
        if variant not in self.get_variants():
            raise ValueError(f"Unknown variant '{variant}', must be one of: {', '.join(self.get_variants())}")
        self.client.set_variant(variant, False)
        if reboot:
            self.reboot(bypass_reconnect=not reconnect, connect_kwargs={'check_variant': False})  # TODO: PLATDEV-1080 invert reconnnect param

    @connection_required
    def create_variant_container(self):
        """
        Gets variants and creates TsoContainer to enumerate names.

        :return: None
        :rtype: None
        """
        self.variants = TsoContainer(ref_name='variants', container=self, resource_type=str, generate_stubs=True)
        for variant_name in self.get_variants():
            self.variants[variant_name] = variant_name


class EmbeddedAudioHubController(AudioHubController):
    """**Reduced wrapper class for ah_ctrl_server use only**"""

    def configure(self, config, *args, **kwargs):
        """
        Configures the AH Controller to connect to user specific audiohub

        :param config: Controller subconfig dictionary
        :type config: dict
        :return: None
        """
        HostController.configure(self, config, *args, **kwargs)
        # TODO check if this breaks anything
        # self.HostController.configure(self, config, *args, **kwargs)

        self.spmi_master = SpmiMasterCtrl(self)
        self.interrupt_queue = Queue()
        # self.client = config['handler']
        # inside config dict client will be the passed in handler, construct_objects does the rest
