"""
Bursts are used to execute python code remotely on a host controller for faster execution.
See documentation for usage at: https://docs.cirrus.com/pages/viewpage.action?pageId=257226170

*Author:* Evan Canter
"""
import sys, time, re, inspect
import json, types
from cl_test_station.utilities.ts_json import ts_dumps, ts_loads
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.pyro_support.pyro_receiver import PyroReceiver
from cl_test_station.test_station import TestStation
from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.utilities.ts_logging import TsLoggingAdapter
from logging import FileHandler
from cl_test_station.utilities.parsing import parse_code_block, parse_station_attributes
from cl_test_station.utilities.pkg_paths import get_pkg_rel_path
from cl_test_station.utilities.dummy_object import DummyObject



# This list defines all internal attributes that need to be accessed, otherwise DummyObjects will be returned
INTERNALS = ['_Burst__obj', '_Burst__lines', '_Burst__line_num', '_Burst__source_code', '_Burst__name',
             '_Burst__attributes', 'self', '__class__', '__bases__', '__name__',
             '_Burst__find_test_station', '_Burst__test_station', '_Burst__ts_alias', '_Burst__vars',
             '_Burst__station_aliases', '_Burst__host_controller', '_Burst__log', 'log']


class Burst(object):
    def __init__(self, obj: object, host_controller: HostController, test_station=None):
        """
        Reads text of file that instantiated the Burst and grabs the starting line number of the block.
        :param obj: The calling class of the burst block
        :param host_controller: reference to host controller that the burst is being executed on
        :param test_station: TestStation being used. If None, will search for one in attributes
        """
        for frame, filename, line_num, func, source_code, source_index in inspect.stack():
            if 'with Burst(self' in source_code[source_index].strip():  # This is line of Burst instantiation
                self.__name = source_code[source_index].split()[-1][:-1]  # Name of the burst object
                self.__line_num = line_num - 1  # Convert to zero-indexed position
                self.__source_code = []
                with open(filename, 'r') as f:  # Get entire file source code as list of lines
                    for line in f:
                        self.__source_code.append(line)
        self.__obj = obj
        self.__host_controller = host_controller
        if test_station is not None:
            self.__test_station = test_station
        else:
            self.__ts_alias, self.__test_station = self.__find_test_station(obj)
        self.log = self.__test_station.log


    def __enter__(self):
        """
        Parses through each line of the test and extracts all required variables and executable lines of code

        :return: Burst object
        """
        sys.stdout = None
        self.__lines, self.__attributes = parse_code_block(self.__source_code, start_line=self.__line_num)
        self.__vars, self.__station_aliases = parse_station_attributes(self.__obj, self.__test_station,
                                                                       self.__attributes)
        # Re-alias test station objects to DummyObjects for now
        for alias in self.__station_aliases.keys():
            self.__obj.__setattr__(alias, DummyObject())

        # Re-Alias test station itself
        self.__obj.__setattr__(self.__ts_alias, DummyObject())

        # Same with log
        if hasattr(self.__obj, 'log'):
            self.__log = self.__obj.log
            self.__obj.__setattr__('log', DummyObject())

        return self

    def __find_test_station(self, obj):
        for name, attr in obj.__dict__.items():
            if isinstance(attr, TestStation):
                return name, attr
        raise AttributeError("No TestStation given and no TestStation found as caller attribute")

    def __getattribute__(self, item):
        if str(item) in INTERNALS:
            temp = object.__getattribute__(self, item)
            return temp
        else:
            return DummyObject()  # Anything else is called in the 'with' block by the user

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        Pings test station in host controller, embeds test station if necessary
        Calls Burst thrift function in given Host Controller, gets updates vars
        Updates vars in __obj
        Restores test station object aliases
        """
        sys.stdout = sys.__stdout__
        error = False
        # Embed test station if not already
        self.__test_station.embed_in_controller(self.__host_controller)

        # Serialize dictionaries and call burst thrift function
        vars_json_in = ts_dumps(self.__vars)
        aliases_json_in = ts_dumps(self.__station_aliases)
        burst_json_out = self.__host_controller.burst(self.__lines, vars_json_in, aliases_json_in)
        burst_result_dict = ts_loads(burst_json_out, self.__test_station)

        # Print all remote print statements to the console
        console_log = burst_result_dict.pop('CONSOLE_LOG')
        if console_log.endswith('\n'):
            console_log = console_log[:-1]
        if console_log:
            for line in console_log.split('\n'):
                if '- WARNING' in line:
                    color = "\033[93m"
                elif '- ERROR' in line:
                    color = "\033[31m"
                elif '- CRITICAL' in line:
                    color = "\033[31;1m"
                elif '- DEBUG' in line:
                    color = '\033[92m'
                elif '- DEV' in line:
                    color = "\033[1;36m"
                else:
                    color = "\033[0;0m"                                #cl_test_station
                self.log.print(color + line.replace('cl_test_station', 'cl_test_station - [EMBEDDED]') + "\033[0;0m")

        # Write console output to any log files
        for handler in self.__test_station.log.handlers:
            if isinstance(handler, FileHandler):
                if handler.stream.writable():
                    handler.stream.writelines([line.replace('cl_test_station', 'cl_test_station - [EMBEDDED]')
                                               +'\n' for line in console_log.split('\n')])

        # Check for exceptions
        if 'EXCEPTION' in burst_result_dict.keys():
            c = "\033[91m"
            self.log.error('BURST EXCEPTION')
            trace = burst_result_dict["EXCEPTION"].replace("Traceback", "Remote traceback")  # type: str
            # Get line of exception on local file
            try:
                # Find the line in the burst exec block from ah_ctrl_server
                line_no = int(re.findall('"burst_block", line (\d+)', trace)[-1])
                # line in burst 'with' block where the error happened
                error_source = self.__lines[line_no-1]
                # Find line number in source code
                for i, line in enumerate(self.__source_code):
                    if error_source in line:
                        source_line_no = i + 1
                # Get error message line from traceback (Last line in traceback that contains text)
                err_line = ''
                for line in reversed(trace.split('\n')):
                    if line.strip():  # Contains text
                        err_line = line
                        break
                custom_trace = '\tFile "%s", line %d, in Burst block\n\t\t%s\n%s' \
                               % (inspect.getfile(self.__obj.__class__), source_line_no, error_source.strip(), err_line)
                self.log.print(c + 'Local traceback (most recent call last):\n' + custom_trace + '\n \033[0m')
            except:
                pass
            # Print remote traceback for Error type and message
            self.log.print(c + trace + '\033[0m')
            raise Exception("Burst exception: See traceback")

        # Update test attributes
        self.log.dev('Updating %s with new attribute values: %s' % (self.__obj.__class__.__name__, str(burst_result_dict)))
        self.__obj.__dict__.update(burst_result_dict)

        # Restore test station and object aliases
        if hasattr(self, '__log'):
            self.__obj.__setattr__('log', self.__log)
        self.__obj.__setattr__(self.__ts_alias, self.__test_station)
        for alias, path in self.__station_aliases.items():
            self.__obj.__setattr__(alias, self.__test_station.resolve_path(path))
        return
