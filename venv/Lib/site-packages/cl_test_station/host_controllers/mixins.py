"""
Mixin class definitions for use with host controller child classes.

*Author:* Evan Canter <evan.canter@cirus.com>
"""
import inspect
import json
import os
from abc import abstractmethod
from typing import Dict, List, Set, Tuple, Union

import yaml
from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.utilities.cl_yaml_loader import yaml_load


class PyiMixin(HostController):

    def gen_pyi(self, indent=0, top=False, **kwargs) -> Tuple[str, Set[Tuple[str, str]]]:
        pyi_str, imports = super().gen_pyi(indent=0, top=True, **kwargs)
        self._write_pyi_file(pyi_str, imports)
        return self._get_pyi_reference()


def _find_mixin_child(target_cls, mixin_cls) -> list:
    for base in target_cls.__bases__:
        # Found class, exit recursion
        if base is mixin_cls:
            return target_cls
        # Look inward
        found = _find_mixin_child(base, mixin_cls)
        if found:
            return found


class ExtendedConfigMixin(HostController):

    _exteneded_config_name: str = 'ext_cfg.yml'
    _extended_config_replacements: Dict[str, str] = {}

    def construct_objects(self, *args, **kwargs):
        # Extend config to include internal components
        this_dir = os.path.dirname(inspect.getfile(_find_mixin_child(self.__class__, ExtendedConfigMixin)))
        extended_config_path = os.path.join(this_dir, self._exteneded_config_name)
        # with open(extended_config_path, 'r') as f:
        #     extended_config = yaml.load(f, Loader=yaml.FullLoader)
        extended_config = yaml_load(extended_config_path, self)
        # Serialize with JSON to perform string replacements
        extended_config_str = json.dumps(extended_config)
        for key, value in self._extended_config_replacements.items():
            extended_config_str = extended_config_str.replace(key, str(value))
        self.extended_config = json.loads(extended_config_str)
        self.config.update(self.extended_config)  # Tack on nested components
        super().construct_objects(*args, **kwargs)
        for key in self.extended_config:
            self.config.pop(key)


class I3cControllerMixin(HostController):

    @abstractmethod
    def i3c_read_device(self, address: int, num_bytes: int, *args, preamble_bytes: List[int] = None, **kwargs) -> List[int]:
        """
        Reads 'num_bytes' from an I3C device at 'address'. If preamble_bytes is populated, those bytes will be written
        to the device before the read operation. Otherwise, only a read transfer will be executed.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError

        :param address: I3C device address
        :type address: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :return: List of bytes read from the device, or an error code if one occurred
        :rtype: List[int]
        """

    @abstractmethod
    def i3c_read_reg(self, address: int, reg_addr: int, *args, num_bytes: int = 4,
                     preamble_bytes: List[int] = None, **kwargs) -> List[int]:
        """
        Reads 'num_bytes' from register address 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before the register address.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError

        :param address: I3C device address
        :type address: int
        :type reg_addr: Register address
        :param reg_addr: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :return: List of bytes read starting from register at address 'reg_addr'
        :rtype: List[int]
        """

    @abstractmethod
    def i3c_write_device(self, address: int, write_data: List[int], *args, preamble_bytes: List[int] = None, **kwargs):
        """
        Writes 'write_data' to I3C device at 'address'. If preamble_bytes is populated,those bytes will be written
        to the device before write_data.

        If an error code is returned from the write transfer, this function will raise an I3cError

        :param address: I3C device address
        :type address: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :return: None
        :rtype: None
        """

    @abstractmethod
    def i3c_write_reg(self, address: int, reg_addr: int, write_data: List[int], *args, preamble_bytes: List[int] = None, **kwargs):
        """
        Writes 'write_data' to I3C register at 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before register address.

        :param address: I3C device address
        :type address: int
        :param reg_addr: Register address
        :type reg_addr: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :return: None
        :rtype: None
        """
