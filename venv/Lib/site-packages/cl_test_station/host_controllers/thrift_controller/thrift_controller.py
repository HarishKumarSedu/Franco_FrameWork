import glob
import json
import logging
import os
import re
import socket
import sys
import time
from importlib import import_module
from typing import *
from abc import abstractmethod

from cl_test_station.components.component.component import Component
from cl_test_station.host_controllers.host_controller.host_controller import HostController, connection_required
from cl_test_station.pyro_support.pyro_transmitter import internal_transmitter
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.tso_container import TsoContainer
from embedded_thrift_server.tclient import TClient
from embedded_thrift_server.utilities.local_ssh import LocalSSH
from embedded_thrift_server.ah_thrift.ttypes import I2c_error, ServerError, JSONSerializeError, GpioAccessError
from thrift.transport.TTransport import TTransportException


def skip_system_initialize(func: Callable):
    """Decorator that will skip system initialize functions if the Thrift Controller has already called them. This is 
    solely for internal components that are considered resources of the controller."""
    def inner(self, *args, **kwargs):
        controller = self.find_container(ThriftController)
        if not hasattr(controller, '_thrift_initialized') or not controller._thrift_initialized:
            return func(self, *args, **kwargs)
        self.log.debug(f"{self.path}.{func.__name__} has already been called, skipping")
    return inner


@internal_transmitter('client', 'ssh')
class ThriftController(HostController):
    """Parent class for all controllers using embedded_thrift_server."""
    # enable PYI generation
    has_dynamic_attrs = True
    # Class fields
    hostname: str = TsoField(ftype=str, desc="Host name, eg 'ah3-0d5c84.local'")
    socket: int = TsoField(ftype=int, desc="Socket that the Thrift server will use, eg 1025")
    thrift_file: str = TsoField(ftype=str, required=False, default='',
                                desc="Path to the .thrift file to load a service from. If none given, "
                                     "embedded_thrift_server/ah_thrift.thrift will be used.")
    thrift_service: str = TsoField(ftype=str, required=False, default='',
                                   desc="Name of the thrift service defined in the .thrift file. If none given, "
                                        "the servie 'ah_thrift' will be used")
    FORCE_UPDATE: bool = TsoField(ftype=bool, required=False, default=False,
                                  desc="When True, Reinstalls every required package and reconfigures thrift server")
    auto_update: bool = TsoField(ftype=bool, required=False, default=True,
                                 desc="When True, Checks remote package versions and updates any that are out of date")
    # Misc class attributes
    I2C_SPEEDS = {100e3: 0, 400e3: 1, 1e6: 2, 20e3: 3}
    SPI_ROOT_CLK = 166_666_666

    def __init__(self, *args, client: TClient = None, ssh = None, **kwargs):
        self._num_i2c_retries = 0
        super().__init__(*args, **kwargs)
        self.client: TClient = client
        self.ssh = ssh
        self.pins = TsoContainer(ref_name='pins', container=self, generate_stubs=False)
        self.py_version = ''  # Will get updated by update_ah_thrift()
        self.format_hostname()  # Add .local at end of hostname if missing
        self._thrift_initialized = False

        # Create Thrift client if None was passed in
        if self.client is None:
            self.client = TClient(self.thrift_file, self.thrift_service, self.log)
            self.client.open(self.hostname, self.socket)
        # Create SSH session if None was passed in
        if self.ssh is None:
            try:  # This will fail during embedded construction
                from embedded_thrift_server.utilities.update_ah_thrift import SSH
                self.ssh = SSH(self.hostname, 'root', 'crus')  # Open SSH Connection to controller
            except ImportError:
                self.ssh = LocalSSH()

    def _initialize_internal_resources(self):
        """
        Runs system_initialize() sequence on nested resources and then prevents those functions from being called
        a second time when the test station actually initializes. Allows these internal TSOs to remain part of resource
        linkage while having their attributes like Registers available earlier.

        :return: None
        :rtype: None
        """
        from cl_test_station.interfaces.mmap_interface import MmapInterface
        # Reassign log level temporarily so that log is not flooded with internal initialization
        old_info = logging.INFO
        logging.INFO = logging.DEBUG
        # Initialize all mmap interfaces so that controller will have access to FPGA's in initialize()
        interfaces = [iface for _, iface in self.find_all(MmapInterface)]
        for iface in interfaces:
            iface.initialize(standalone=True)
        # Initialize everything besides mmap interfaces
        for _, resource in self:
            if resource in interfaces:
                continue
            resource.initialize(standalone=True)
        # Post system initialize and wrap resource functions
        for _, resource in self:
            resource.post_system_initialize()
            # resource._thrift_initialized = True
            # Wrap initialize and post_system_initialize so that they are skipped when system calls
            resource.__class__.initialize = skip_system_initialize(resource.__class__.initialize)
            resource.__class__.post_system_initialize = skip_system_initialize(resource.__class__.post_system_initialize)
        self._thrift_initialized = True
        # Restore log level
        logging.INFO = old_info

    def _run_connect_sequence(self, *funcs: Callable):
        """
        Exectues sequence of bringup functions, logging exceptions as they occur. No function returns will be captured.

        :param funcs: Functions to run in order they are input
        :type funcs: Callable
        :return: None
        :rtype: None
        """
        for func in funcs:
            try:
                self.log.debug(f"Executing {func.__name__}()")
                func()
            except Exception as err:
                self.log.exception(f"Received {type(err)} in {func.__name__}()")

    @property
    def num_i2c_retries(self) -> int:
        """Returns the num_i2c_retries."""
        return self._num_i2c_retries

    @num_i2c_retries.setter
    def num_i2c_retries(self, num_retries: int):
        """Sets num_i2c_retries"""
        self._num_i2c_retries = num_retries

    # # ----- Attribute Functions ----- # #

    def format_hostname(self):
        """
        If the user gave a host name (not IP) that does not contain '.local', it will be added.

        :return: None
        :rtype: None
        """
        is_ip = True
        numbers = self.hostname.split('.')
        if len(numbers) != 4:
            is_ip = False
        for n in numbers:
            if not (n.isdigit() and int(n) in range(0, 256)):
                is_ip = False

        if not is_ip and '.local' not in self.hostname:
            self.log.warning("Hostname env variable does not contain '.local', appending before connection")
            self.hostname += '.local'

    def get_hostname(self) -> str:
        """
        Returns the non-ip address hostname

        :return: Device hostname
        :rtype: str
        """
        return self.hostname

    def get_py_version(self) -> str:
        """
        Returns python version used to run the remote thrift server, eg. '3.7'

        :return: String representing python version
        :rtype: str
        """
        return self.py_version

    # # ----- SSH Functions ----- # #

    def ssh_sendcommand(self, cmd):
        """
        Uses ssh connection to execute 'cmd'

        :param cmd: Command to execute through ssh, eg 'rm /home/some/file.txt'
        :type cmd: str
        :return: None
        """
        self.ssh.sendcommand(cmd)

    def ssh_communicate(self, cmd, print_result=False) -> str:
        """
        Uses ssh connection to execute 'cmd' and return the result as a string

        :param cmd: Command to execute through ssh, eg 'cat /home/some/file.txt'
        :type cmd: str
        :param print_result: When true, prints the command result to stdout instead of returning it
        :type print_result: bool
        :return: Command result as a string
        :rtype: str
        """
        result = self.ssh.communicate(cmd)
        if print_result:
            print(result)
        else:
            return result

    # # ----- Connection Functions ----- # #

    def connect(self, modules=None):
        """
        Updates the code on controller and then attempts to open thrift transport. Will only attempt if there is not an
        existing connection open.

        :param modules: List of names for all modules loaded in python session. Tells the Audiohub what needs to be
            installed on its OS
        :type modules: list
        :return: None
        """
        self.log.print(f'Connecting to {self.__class__.__name__}...\r', end='')
        if not self.ssh.is_open():
            self.ssh.open()
        if self.auto_update and not self.client.connected:  # Update server code
            self.update(modules=modules)
        if not self.client.connected:
            raise_error = False  # Flag to grab traceback and raise TimeOutError
            timeout_error = None
            for attempt in range(3):  # If connect fails, first try restarting server, then try repairing cache
                try:  # Try to connect. If server can't be connected to, attempt to repair
                    self.client.connect()
                    break  # No need for rety, connection went through
                except TimeoutError as err:  # ah_ctrl_server.py is not running correctly
                    timeout_error = err
                    if attempt == 0:
                        self.log.warning("Server connection timed out, restarting server and trying again...")
                        self.restart_thrift_server(reconnect=False)
                    elif attempt == 1:  # Only try to repair after the first fail
                        self.log.error("Could not connect to server, validating version cache...")
                        from embedded_thrift_server.utilities.update_ah_thrift import validate_version_cache
                        missing_modules = validate_version_cache(self.ssh, self.hostname)
                        if missing_modules:  # Force update to reinstall missing modules
                            self.log.info(f"Found missing modules [{', '.join(missing_modules)}], repairing..,")
                            self.update(force=True, modules=missing_modules)
                            self.log.info("Attempting to reconnect...")
                        else:  # Cache is fine, unknown issue is breaking the server
                            self.log.info("Version cache validated")
                            raise_error = True
                            break
                    else:
                        raise_error = True
            else:  # Second attempt failed
                raise_error = True
            if raise_error and timeout_error:  # Raise error and grab server traceback
                try:
                    trace = self.ssh.communicate('cat /home/ah_ctrl_server_log.log')
                except TimeoutError:  # Log empty, no trace to report
                    trace = ''
                self.log.error(f"Could not connect to thrift server ({self.hostname}, {self.socket})")
                if trace:
                    self.log.error(f"Server traceback:\n{trace}")
                raise timeout_error
            received = self.client.ping()  # Attempt to ping to verify connection
            if received != 'Received':
                raise ConnectionError('Did not receive a reply message from Thrift server')
            self.log.info(f'Connected to {self.ref_name} ({self.__class__.__name__})    ')

    def disconnect(self):
        """
        Disconnects the TClient (Closes the thrift transport) and closes the ssh connection if one exists

        :return:
        """
        self.client.close()
        if self.ssh is not None:
            self.ssh.client.close()
        self.log.info(f"Disconnected from {self.hostname}")

    def has_open_ssh(self) -> bool:
        """
        Checks if there is an open ssh connection

        :return: True if ssh connection exists, False otherwise
        """
        return self.ssh is not None and self.ssh.is_open()

    def is_connected(self) -> bool:
        """
        Pings the thrift server to test if client is connected

        :return: True if able to ping server, False otherwise
        """
        return self.client.connected and self.has_open_ssh()

    def isConnected(self) -> bool:
        """
        Pings the thrift server to test if client is connected

        :return: True if able to ping server, False otherwise
        """
        return self.is_connected()

    def ping(self, tries=3) -> str:
        """
        Attempts to ping the thrift server 'tries' amount of times

        :param tries: Number of ping attempts
        :return: 'Received' if ping was successful, 'Unable to ping {hostname}' if ping failed for all attempts
        """
        for i in range(tries):
            try:
                return self.client.ping()
            except:
                pass
        else:
            return "Unable to ping %s" % self.hostname

    def ping_test_station(self):
        """
        Checks to see if there is already a test station embedded on the AudioHub

        :return: 'success' if there is a station, 'failure' otherwise
        """
        return self.client.ping_test_station()

    # # ----- Reset Functions ----- # #

    @connection_required
    def reset_dut(self, mode=2, active_low=True):
        """
        Resets the DUT

        :param mode: 0 to set pin low; 1 to set pin high; 2 to toggle pin
        :type mode: int
        :param active_low: active low flag
        :type active_low: bool
        :return: Resets dut, otherwise if mode invalid value raises value error
        """
        if mode < 0 or mode > 2:
            raise ValueError("Mode must be one of: 0 to set pin low; 1 to set pin high; 2 to toggle pin")
        self.client.reset_dut(mode, active_low)

    # TODO: VALTECH-796 see if ZDC has this pin
    # @connection_required
    # def reset_sys(self, mode=2, active_low=True):
    #     """
    #     Sets the reset_sys pin
    #
    #     :param mode: 0 to set pin low; 1 to set pin high; 2 to toggle pin
    #     :param active_low: [Bool] active low flag
    #     :return:
    #     """
    #     if mode < 0 or mode > 2:
    #         raise ValueError("Mode must be one of: 0 to set pin low; 1 to set pin high; 2 to toggle pin")
    #     if self.hostname.startswith('ah2'):
    #         SYS_RESET_NUM = 55
    #         if mode < 2:
    #             self.client.set_gpio(SYS_RESET_NUM, mode)
    #         else:
    #             self.client.toggle_gpio(SYS_RESET_NUM, active_low, 0.1, 0.1)  # Default delay and width to 100ms
    #     else:
    #         # active_low = True --> High Low High --> 0 1 0 (pin is inverted), invert=False
    #         self.toggle_pin(self.fpga.FAKE_CS.SYSTEM_CONTROL.FORCE_SYS_RESETN, mode=mode, invert=not active_low)

    @connection_required
    def reset_wrapper(self, mode=2, active_low=True):
        """
        Resets the Wrapper

        :param mode: 0 to set pin low; 1 to set pin high; 2 to toggle pin
        :type mode: int
        :param active_low: active low flag
        :type active_low: bool
        :return: Resets the wrapper, if mode invalid value raises value error
        """
        if mode < 0 or mode > 2:
            raise ValueError("Mode must be one of: 0 to set pin low; 1 to set pin high; 2 to toggle pin")
        self.client.reset_wrapper(mode, active_low)

    # # ----- Protocol Functions ----- # #

    def __get_i2c_speed(self, speed_Hz: int) -> int:
        """
        Converts bus speed in Hertz to xi2c speed code. Valid codes are (return code -> bus speed):
            * 0 -> 100kHz
            * 1 -> 400kHz
            * 2 -> 1MHz
            * 3 -> 20kHz

        The returned code will be the closest speed to what was given as an input, e.g. 22e3 will map to 3.

        :param speed_Hz: Desired I2C bus speed in Hertz
        :type speed_Hz: int
        :return: Speed code used by xi2c CLI
        :rtype: int
        """
        if speed_Hz in self.I2C_SPEEDS:
            speed_code = self.I2C_SPEEDS[speed_Hz]
        else:
            speed_code = int(min(self.I2C_SPEEDS.keys(), key=lambda k: abs(k-speed_Hz)))
            self.log.warning("I2C does not support speed of %dHz, using %dHz" % (speed_Hz, speed_code))
            speed_code = self.I2C_SPEEDS[speed_code]
        return speed_code

    def i2c_device_write(self, bus_num: int, speed: int, address: int, write_data: List[int], **kwargs) -> int:
        """
        Performs simple I2C write to device with i2c address 'address'. The Structure of the bus traffic is:

        1. START
        2. Device address with R/W bit = 1
        3. Data bytes, write_data[0] will be the first byte sent out
        4. STOP

        :param bus_num: I2C bus to use
        :type bus_num: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :param address: 7-bit device address
        :type address: int
        :param write_data: List of data bytes to write immediately following the address byte
        :type write_data: list
        :return: Error code. 0 -> Successful write, -4 -> I2C write error
        :rtype: int
        """
        _speed = self.__get_i2c_speed(speed)
        try:
            return self.client.i2c_device_write(bus_num, _speed, address, write_data)
        except I2c_error as i2c_error:
            self.log.error("Failed to run: " + i2c_error.command)
            self.log.error("Received " + i2c_error.error_output)
            return -4

    def i2c_device_read(self, bus_num: int, speed: int, address: int, byte_count: int, **kwargs) -> Union[List[int], int]:
        """
        Performs simple I2C read to device with i2c address 'address'. The Stucture of the bus traffic is:

        1. START
        2. Device address with R/W bit = 0
        3. Read in 'byte_count' bytes from device
        4. STOP

        :param bus_num: I2C bus to use
        :type bus_num: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :param address: 7-bit device address
        :type address: int
        :param byte_count: Number of bytes to read immediately following the address byte
        :type byte_count: int
        :return:
            * Successful read: List of bytes read from device
            * Failed read: Integer, error code: -5 -> I2C read error
        :rtype: list | int
        """
        _speed = self.__get_i2c_speed(speed)
        try:
            return self.client.i2c_device_read(bus_num, _speed, address, byte_count)
        except I2c_error as i2c_error:
            self.log.error("Failed to run: " + i2c_error.command)
            self.log.error("Received " + i2c_error.error_output)
            return -5

    def write_i2c_reg(self, reg_addr: int, write_data: List[int], address: int, bus_num: int, speed: int = 1e6,
                      repeat_start: bool = True, write_reg_addr_size: int = 4, ainc: bool = True,
                      address_stride: int = 4, write_reg_data_size: int = 4, **kwargs) -> int:
        """
        Performs an I2C register write. The Stucture of the bus traffic is:

        1. START
        2. Device address (Write), ACK
        3. Register address, ACK
        4. Data byte/ACK repeated len(write_data) times
        5. STOP

        :param reg_addr: Register address of write
        :type reg_addr: int
        :param write_data: List of bytes to write
        :type write_data: list
        :param address: 7-bit device address
        :type address: int
        :param bus_num: I2C bus to use
        :type bus_num: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :param repeat_start: When True, uses repeated start
        :type repeat_start: bool
        :param write_reg_addr_size: Size of register address in Bytes
        :type write_reg_addr_size: int
        :param ainc: Auto-increment, only used for large block transactions
        :type ainc: bool
        :param address_stride: Address increment per word, only used for large block transactions
        :type address_stride: int
        :param write_reg_data_size: Size of register in bytes, only used for large block transactions
        :type write_reg_data_size: int
        :return: Error code. 0 -> Successful write, -4 -> I2C write error
        :rtype: int
        """
        global I2c_error
        _speed = self.__get_i2c_speed(speed)
        for attempt in range(self.num_i2c_retries+1):
            try:
                if write_reg_addr_size:
                    return self.client.write_i2c_reg(reg_addr, write_data, address, bus_num,
                                                     _speed, repeat_start, write_reg_addr_size,
                                                     ainc, address_stride, write_reg_data_size)
                else:  # Address size of 0, call non-address function instead
                    return self.client.i2c_device_write(bus_num, _speed, address, write_data)
            except I2c_error as err:
                command = err.command
                error_output = err.error_output
            except TTransportException:
                self.log.warning("I2C write received Transport exception, make sure '%s' is connected to thrift server"
                                 % self.ref_name)
                self.log.exception("Unable to write $s from address %s" % (str(write_data), hex(reg_addr)))
                return -4
        else:
            self.log.error("Failed to run: " + command)
            self.log.error("Received " + error_output)
            return -4

    def read_i2c_reg(self, reg_addr: int, byte_count: int, address: int, bus_num: int, speed: int = 1e6,
                     repeat_start: bool = True, read_reg_addr_size: int = 4,  ainc: bool = True, address_stride: int = 4,
                     read_reg_data_size: int = 4, **kwargs) -> Union[List[int], int]:
        """
        Performs an I2C register read. The Stucture of the bus traffic is:

        1. START
        2. Device address (Write), ACK
        3. Register address, ACK
        4. REPEAT START
        5. Device address (Read), ACK
        6. Read data from device/ACK repeated byte_count-1 times
        7. Last read byte from device/NACK from controller
        8. STOP

        :param reg_addr: Register address of read
        :type reg_addr: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param address: 7-bit device address
        :type address: int
        :param bus_num: I2C bus to use
        :type bus_num: int
        :param speed: Transfer speed in Hz
        :type speed: int
        :param repeat_start: When True, uses repeated start
        :type repeat_start: bool
        :param read_reg_addr_size: Size of register address in Bytes
        :type read_reg_addr_size: int
        :param ainc: Auto-increment, only used for large block transactions
        :type ainc: bool
        :param address_stride: Address increment per word, only used for large block transactions
        :type address_stride: int
        :param read_reg_data_size: Size of register in bytes, only used for large block transactions
        :type read_reg_data_size: int
        :return:
            * Successful read: List of bytes read from device
            * Failed read: Integer, error code: -5 -> I2C read error
        :rtype: list | int
        """
        global I2c_error
        _speed = self.__get_i2c_speed(speed)
        for attempt in range(self.num_i2c_retries+1):
            try:
                if read_reg_addr_size:
                    return self.client.read_i2c_reg(reg_addr, byte_count, address, bus_num,
                                                    _speed, repeat_start, read_reg_addr_size,
                                                    ainc, address_stride, read_reg_data_size)
                else:  # Address size of 0, call non-address function instead
                    return self.client.i2c_device_read(bus_num, _speed, address, byte_count)
            except I2c_error as err:
                command = err.command
                error_output = err.error_output
            except TTransportException:
                self.log.warning("I2C read received Transport exception, make sure '%s' is connected to thrift server"
                                 % self.ref_name)
                self.log.exception("Unable to perform I2C read from address %s" % hex(reg_addr))
                return -5
        else:
            self.log.error("Failed to run: " + command)
            self.log.error("Received " + error_output)
            return -5

    @connection_required
    def i2c_scan(self, bus_num: int, speed: int = None, **kwargs) -> List[str]:
        """
        Scans I2C bus 'bus_num' for devices. Returns a list of hex addresses (7bit) found.

        :param bus_num: Bus number for I2C Bus to scan
        :type bus_num: int
        :param speed: SCLK rate used to scan the bus in Hz (Default: 20kHz)
        :type speed: int
        :return: List of found addresses as hex strings
        :rtype: List[str]
        """
        if speed is None:
            speed = 20000   # default to slowest speed
        self.set_i2c_bus_speed(bus_num, speed)
        self.log.debug(f"Scanning I2C bus {bus_num} for devices at {speed / 1000}kHz")
        result = self.client.i2c_scan(bus_num)
        if 'This I2C bus is not present' in result:
            raise ValueError(f"This I2C bus ({bus_num}) is not present.")
        result = result.replace('[', '').replace(']', '').split()
        result = ['0x' + i for i in result]
        valid = []
        for addr in result:
            try:
                int(addr, 16)  # Check if result is valid hex number
                valid.append(addr)
            except ValueError:
                continue
        return valid

    @connection_required
    def set_i2c_bus_speed(self, bus_num, speed):
        """
        Sets the default clock rate of bus 'bus_num' to 'speed'

        :param bus_num: Bus number
        :type bus_num: int
        :param speed: Clock rate to set bus to in Hz
        :type speed: int
        :return: None
        """
        self.log.debug(f"Setting I2C bus {bus_num} speed to {speed}Hz")
        self.client.set_i2c_bus_speed(bus_num, speed)

    def __get_spi_speed(self, speed_hz: int) -> int:
        """
        Gets Valid SPI speed from user-input speed. Only denominations of root 166.66MHz clock are supported. Input
        speed is floored to closest divided clock, e.g. 6_000_000 will be floored to 5_208_333

        :param speed_hz: Input speed in Hz
        :type speed_hz: int
        :return: Supported speed in Hz
        :rtype: int
        """
        supported_speed = self.SPI_ROOT_CLK >> 3  # 20.83MHz fastest speed, gated by 25MHz EMIO cap
        while speed_hz < supported_speed:
            supported_speed >>= 1  # Div by 2 until available is less than requested
        supported_speed = max(supported_speed, self.SPI_ROOT_CLK >> 8)  # Can't go lower than 651KHz
        return supported_speed

    def __get_supported_spi_speeds(self) -> List[int]:
        return [self.SPI_ROOT_CLK >> i for i in range(3, 9)]

    def spi_fd(self, bytes_out: List[int], bus_num: int, chip_select: int, speed: int, keep_cs: bool, clk_mode: int = 0, **kwargs) -> List[int]:
        """
        Performs a SPI full-duplex transfer. Outputs bytes_out to MOSI, returns received bytes from MISO.

        Device used is /dev/crus_spi{bus_num}.{chip_select}

        :param bytes_out: List of bytes to send over MOSI
        :type bytes_out: list
        :param bus_num: Bus number
        :type bus_num: int
        :param speed: Speed in Hz of the transfer. Only divisions of root clock of 166.66MHz are supported:
        * 41_666_666
        * 20_833_333
        * 10_416_666
        * 5_208_333
        * 1_302_083
        * 651_041
        :type speed: int
        :param chip_select: Specify which chip select pin to assert
        :type chip_select: int
        :param keep_cs: When False, de-asserts cs after transfer. When True, cs is kept low (FD only)
        :type keep_cs: bool
        :param clk_mode: SPI mode. Can be 0, 1, 2, 3. Denotes value of CPOL and CPHA:

        ======== ==== ==== ========== ======================
        clk_mode CPOL CPHA Idle Clock Sample edge/Shift edge
        -------- ---- ---- ---------- ----------------------
        0        0    0    logic low  rising/falling
        1        0    1    logic low  falling/rising
        2        1    0    logic high rising/falling
        3        1    1    logic high falling/rising
        ======== ==== ==== ========== ======================

        :return: Return bytes from MISO
        :rtype: list
        """
        supported_speed = self.__get_spi_speed(speed)
        if speed != supported_speed:  # AH only supports multiples of root clock
            self.log.warning(f"SPI controller supports divisions of 166.66MHz. Requested {speed}Hz, using {supported_speed}Hz."
                             f" Available speeds (Hz): {self.__get_supported_spi_speeds()}")
        if clk_mode not in range(4):
            raise ValueError("Invalid clock mode. Can be 0, 1, 2, or 3.")
        return self.client.spi_fd(bytes_out, bus_num, chip_select, supported_speed, keep_cs, clk_mode)

    def spi_apb_block_read(self, bus_num, chip_select, speed, address, read_reg_addr_size=4, read_reg_data_size=4,
                           length=1, **kwargs):
        """
        Checks the arguments for SPI methods. Device used is /dev/crus_spi{bus_num}.{chip_select}

        :param bus_num: Bus number
        :param chip_select: Chip select
        :type chip_select: int
        :param speed: Speed in Hz of the transfer
        :type speed: int
        :param address: start address to read from
        :type address: int
        :param read_reg_addr_size: size of address
        :type read_reg_addr_size: int
        :param read_reg_data_size: size of data to read
        :type read_reg_data_size: int
        :param length: length (in units determined by data_size), ex: if 4 then length is number of words
        :type length: int
        :return: Return bytes or words (depending on data_size)
        :rtype: [list<int>]
        """
        speed_Mhz = int(speed / 1e6)
        if speed % 1e6:  # AH only supports MHz denominations
            self.log.warning('%s only supports SPI speeds in MHz denominations. Using %dMHz'
                             % (self.hostname.split('-')[0].upper(), speed))
        return self.client.spi_apb_block_read(bus_num, chip_select, speed_Mhz, address, read_reg_addr_size,
                                              read_reg_data_size, length)

    def spi_apb_block_write(self, bus_num, chip_select, speed, address, values, write_reg_addr_size=4,
                            write_reg_data_size=4, **kwargs):
        """
        Checks the arguments for SPI or I2C interface methods. Device used is /dev/crus_spi{bus_num}.{chip_select}

        :param bus_num: Bus number
        :param chip_select: Chip select
        :type chip_select: int
        :param speed: Speed in Hz of the transfer
        :type speed: int
        :param address: start address to read from
        :type address: int
        :param values: Data to write (size of each element should match data_size
        :type values: [list<int>]
        :param write_reg_addr_size: size of address
        :type write_reg_addr_size: int
        :param write_reg_data_size: size of data to read
        :type write_reg_data_size: int
        :return: None
        """
        speed_Mhz = int(speed / 1e6)
        if speed % 1e6:  # AH only supports MHz denominations
            self.log.warning('%s only supports SPI speeds in MHz denominations. Using %dMHz'
                             % (self.hostname.split('-')[0].upper(), speed))
        return self.client.spi_apb_block_write(bus_num, chip_select, speed_Mhz, address, values, write_reg_addr_size,
                                               write_reg_data_size)

    def mmap_add(self, base_addr: int, size: int, word_size: int, **kwargs):
        """
        Creates a memory map at base_addr with end address base_addr + size. Once an mmmap is added, mmap_read() and
        mmap_write() can be used for that base_addr.

        :param base_addr: Base address of the memory map
        :type base_addr: int
        :param size: Number of addresses in the memory map
        :type size: int
        :param word_size: Size in bytes of each word
        :type word_size: int
        :return: None
        """
        self.client.mmap_add(base_addr, size, word_size)

    def mmap_read(self, base_addr: int, offset: int, num_bytes: int, **kwargs) -> List[int]:
        """
        Read 'num_bytes' bytes from base_addr + offset. mmap_add() needs to have been called for base_addr before being
        able to perform mmap_read

        :param base_addr: Base address of the memory map
        :type base_addr: int
        :param offset: Address offset, ie reg_address - base_addr
        :type offset: int
        :param num_bytes: Number of bytes to read
        :type num_bytes: int
        :return: List of bytes read
        :rtype: List[int]
        """
        return self.client.mmap_read(base_addr, offset, num_bytes)

    def mmap_write(self, base_addr: int, offset: int, bytes_out: List[int], **kwargs):
        """
        Write 'bytes_out' to base_addr + offset. mmap_add() needs to have been called for base_addr before being
        able to perform mmap_write

        :param base_addr: Base address of the memory map
        :type base_addr: int
        :param offset: Address offset, ie reg_address - base_addr
        :type offset: int
        :param bytes_out: List of bytes to write
        :type bytes_out: List[int]
        :return: None
        """
        self.client.mmap_write(base_addr, offset, bytes_out)

    def memio_write(self, addr, data):
        """
        Sends data to AudioHub for memio CLine

        :param addr: Write address, 32 bit
        :param data: write data, 32 bit
        """
        return self.client.memio_write(addr, data)

    def memio_read(self, addr):
        """
        Sends data to AudioHub for memio Cline

        :param addr: Read address, 32 bit
        :return: Read data
        :rtype: int
        """
        return self.client.memio_read(addr)

    # # ----- GPIO Functions ----- # #

    @connection_required
    def set_gpio(self, chip_num, line_num, value):
        """
        Sets GPIO to 0 or 1
        :param chip_num: chip number
        :type chip_num: int
        :param line_num: line number
        :type line_num: int
        :param value: value to set. 0=Low, 1=High
        :type value: int
        :return: None
        :rtype: None
        """
        if line_num < 0:
            raise ValueError('Invalid value of set_gpio function argument "line_num". Must be greater than 0')
        if value != 0 and value != 1:
            raise ValueError('Invalid value of set_gpio function argument "value". Must be 0 or 1')
        try:
            self.client.set_gpio(chip_num, line_num, value)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("set_gpio received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err

    @connection_required
    def get_gpio(self, chip_num, line_num) -> int:
        """
        Reads the gpio on the spcified chip and line, return the value as an integer.
        When the pin direction is set to output, it reads the set output value.

        :param chip_num: chip number
        :type chip_num: int
        :param line_num: gpio line number
        :type line_num: int
        :return: value read or current value set if output.
        :rtype: int
        """
        if line_num < 0:
            raise ValueError('Invalid value of set_gpio function argument "line_num". Must be greater than 0')
        try:
            value = self.client.get_gpio(chip_num, line_num)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("get_gpio received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err
        return value

    @connection_required
    def set_gpio_by_name(self, name:str, value:int):
        """
        Set using the active gpio name. to get a list of active gpios, call print(self.get_active_gpios())
        :param name: pin name
        :type name: str
        :param value: value to set
        :type value: int
        :return: None
        :rtype: None
        """
        if value != 0 and value != 1:
            raise ValueError('Invalid value of set_gpio function argument "value". Must be 0 or 1')
        try:
            self.client.set_gpio_by_name(name, value)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("set_gpio received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err

    @connection_required
    def get_gpio_by_name(self, name:str):
        """
        Get value using the active gpio name. To get a list of active gpios, call print(self.get_active_gpios())
        :param name: pin name
        :type name: str
        :return: value of the gpio
        :rtype: int
        """
        try:
            value_read = self.client.get_gpio_by_name(name)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("set_gpio received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err
        return value_read

    @connection_required
    def set_gpio_direction(self, chip_num, line_num, direction):
        """
        Set the gpio pin direction. 0=output, 1=input.
        :param chip_num: chip number
        :type chip_num: int
        :param line_num: line number
        :type line_num: int
        :param direction: direction, corresponding to cl_test_station.gpio.enums.PinDirection. 0=output, 1=input
        :type direction: int
        :return: None
        :rtype: None
        """
        if line_num < 0:
            raise ValueError('Invalid value of set_gpio function argument "line_num". Must be greater than 0')
        if direction != 0 and direction != 1:
            raise ValueError('Invalid value of set_gpio function argument "value". Must be 0 or 1')
        try:
            self.client.set_gpio_direction(chip_num, line_num, direction)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("set_gpio_direction received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err

    @connection_required
    def set_gpio_direction_by_name(self, name, direction):
        """
        Set the gpio pin direction. 0=output, 1=input.
        :param chip_num: chip number
        :type chip_num: int
        :param line_num: line number
        :type line_num: int
        :param direction: pin direction 0=output, 1=input
        :type direction: int
        :return: None
        :rtype: None
        """
        if direction != 0 and direction != 1:
            raise ValueError('Invalid value of set_gpio function argument "direction". Must be 0 or 1')
        try:
            self.client.set_gpio_direction_by_name(name, direction)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("set_gpio_direction received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err

    @connection_required
    def get_gpio_direction(self, chip_num, line_num):
        """
        Gets the gpio pin direction.
        :param chip_num: gpio chip number
        :type chip_num: int
        :param line_num: gpio line number
        :type line_num: int
        :return: 0=output, 1=input
        :rtype: int
        """
        if line_num < 0:
            raise ValueError('Invalid value of set_gpio function argument "line_num". Must be greater than 0')
        try:
            direction = self.client.get_gpio_direction(chip_num, line_num)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("set_gpio_direction received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err
        return direction

    @connection_required
    def get_gpio_direction_by_name(self, name):
        """
        Gets the gpio pin direction using the active gpio name. To get a list of active gpios, call print(self.get_active_gpios())
        :param name: Pin name.
        :type name: str
        :return: direction. 0=output, 1=input
        :rtype: int
        """
        try:
            direction = self.client.get_gpio_direction_by_name(name)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("set_gpio_direction received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err
        return direction

    @connection_required
    def get_active_gpio_info(self):
        """
        Gets info on the active gpios. Returns: pin name, controller_name, direction, and current value - for each active gpio line.
        :return: above info
        :rtype: str
        """
        return self.client.get_active_gpio_info()

    @connection_required
    def get_active_gpios_list(self):
        """
        Returns all active gpio names.
        :return: a list of active gpio pin names
        :rtype: [str]
        """
        return self.client.get_active_gpios_list()

    @connection_required
    def gpioinfo(self):
        """
        Gets info on the active gpios. Returns: pin name, controller_name, direction, and current value - for each active gpio line.
        :return: above info
        :rtype: str
        """
        return self.client.gpioinfo()

    @connection_required
    def toggle_gpio(self, chip_num, line_num, active_edge=0, delay=0.1, pulse_width=0.1):
        """
        Toggles GPIO based on active_edge
        :param chip_num: [int] GPIO chip number
        :type chip_num: int
        :param line_num: gpio line number
        :type line_num: int
        :param active_edge: [int] 0 - active low; 1 - active high
        :type active_edge: int
        :param delay: Time before active edge and after active edge
        :type delay: float
        :param pulse_width: Time held low or high in seconds based on active edge
        :type pulse_width: float
        :return: None
        :rtype: None
        """
        if chip_num < 0:
            raise ValueError('Invalid value of set_gpio function argument "chip_num". Must be greater than 0')
        if line_num < 0:
            raise ValueError('Invalid value of set_gpio function argument "line_num". Must be greater than 0')
        if active_edge != 0 and active_edge != 1:
            raise ValueError('Invalid value of set_gpio function argument "active_edge". Must be 0 or 1')
        try:
            self.client.toggle_gpio(chip_num, line_num, active_low=not active_edge, delay=delay, pulse_width=pulse_width)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("toggle_gpio received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err

    @connection_required
    def toggle_gpio_by_name(self, name, active_edge=0, delay=0.1, pulse_width=0.1):
        """
        Toggles GPIO based on active_edge
        :param name: gpio pin name. To get a list of active gpios, call print(self.get_active_gpios())
        :type name: str
        :param active_edge: [int] 0 - active low; 1 - active high
        :type active_edge: int
        :param delay: Time before active edge and after active edge
        :type delay: float
        :param pulse_width: Time held low or high in seconds based on active edge
        :type pulse_width: float
        :return: None
        :rtype: None
        """
        if active_edge != 0 and active_edge != 1:
            raise ValueError('Invalid value of set_gpio function argument "active_edge". Must be 0 or 1')
        try:
            self.client.toggle_gpio_by_name(name, active_low=not active_edge, delay=delay, pulse_width=pulse_width)
        except GpioAccessError as err:
            raise Exception(err.message)
        except TTransportException as err:
            self.log.warning("toggle_gpio received Transport exception, make sure '%s' is connected to thrift server"
                             % self.ref_name)
            raise err
    # # ----- Linux Functions ----- # #

    def get_image_version(self):
        """
        Returns Controller image version as a string, eg '1.1'

        :return: Version string
        :rtype: str
        """
        try:
            return self.ssh.communicate('cat /mnt/boot/version.txt')
        except TimeoutError:
            pass
        try:
            datecode = self.ssh.communicate('cat /mnt/boot/DATECODE.txt')
            self.log.warning("Image does not have a version file, grabbing datecode instead")
            return datecode
        except TimeoutError:
            self.log.error("Could not find version or datecode file.")
        return 'version unknown'

    def download(self, localpath, remotepath):
        """
        Downloads contents from local path onto audiohub at remotepath

        :param localpath: local path to download contents
        :type localpath: str
        :param remotepath: remote path where files will be downloaded
        :type remotepath: str
        :return: None
        """
        if not self.has_open_ssh():
            raise ConnectionError("%s has no open ssh connection, call connect() to open one" % self.hostname)

        # Convert remote path to linux compatible
        remotepath = remotepath.replace('\\', '/')
        self.log.info("Downloading %s to root@%s" % (localpath[len(os.path.expandvars("$ROOT")):], self.hostname))
        # Create directory if one does not exist
        self.ssh.sendcommand(f'mkdir -p {remotepath}')
        self.ssh.scp(localpath, remotepath)

    @connection_required
    def reboot(self, bypass_reconnect: bool = False, auto_update: bool = False, connect_kwargs: bool = None):  # TODO PLATDEV-1080 invert reconnect param
        """
        Sends the 'reboot' command to the Thrift controller through SSH. If bypass_reconnect is False, the SSH session
        and thrift connections are reestablished.

        :param bypass_reconnect: Reconnects to the audiohub
        :type bypass_reconnect: bool
        :param auto_update: Temporary auto_connect field override when reconnecting
        :type auto_update: bool
        :param connect_kwargs: Keyword arguments to be passed in to the connect function
        :type connect_kwargs: bool
        :return: None
        :rtype: None
        """
        if not connect_kwargs:
            connect_kwargs = {}
        from embedded_thrift_server.utilities.update_ah_thrift import sync_and_reboot
        sync_and_reboot(self.hostname, self.ssh, reconnect_ssh=not bypass_reconnect)
        self.restart_thrift_server(reconnect=False)
        if not bypass_reconnect:
            save = self.auto_update
            self.auto_update = auto_update
            # self._thrift_initialized = False
            self.connect(**connect_kwargs)
            self.auto_update = save

    def install_numpy(self):
        from embedded_thrift_server.utilities.scripts.install_numpy import install_numpy
        install_numpy(self.ssh, self.log)

    # # ----- Server Functions ----- # #

    def update(self, force: bool = False, modules: List[str] = None):
        """
        Runs script that checks version data on the Audiohub against versions in the local virtual environment

        :param force: When true, will download packages regardless of version
        :type force: bool
        :param modules: List of module names in use that should be installed onto the Thrift controller's OS
        :type modules: List[str]
        :return: None
        :rtype: None
        """
        # Windows only configuration
        if sys.platform == 'win32':
            from embedded_thrift_server.utilities.update_ah_thrift import update_ah
            # Combine YAML force flag with function param
            force |= self.FORCE_UPDATE
            # Get modules
            if not modules:
                modules = list(sys.modules.keys())
            # Run update utility
            update_ah(self, self.hostname, self.log, force=force, modules=modules)

    def restart_thrift_server(self, reconnect: bool = True):
        """
        Stops and starts the ah_ctrl_server service, which restarts the AudioHub thrift server

        :return: None
        :rtype: None
        """
        self.log.info("Restarting the thrift service.")
        self.ssh.sendcommand("systemctl stop ah_ctrl_server")
        self.ssh.sendcommand("systemctl start ah_ctrl_server")
        time.sleep(1)
        self.client.open(self.hostname, self.socket)
        if reconnect:
            self.connect()

    @staticmethod
    def env_to_dict(env_path):
        """
        Converts an env file to a dictionary where the keys are the environmental variable names, values are
        not expanded

        :param env_path: path to .env file
        :return: dictionary
        """
        env_vars = {}
        with open(env_path, 'r') as f:
            for line in f:
                if line.strip() == '' or line.startswith('#'):
                    continue
                name, value = line.strip().split('=')
                value = value.replace(os.sep, '/') # Convert to '/'
                env_vars[name] = re.sub('\s*#.*', '', value)  # Remove comments

        return env_vars

    @connection_required
    def embed_test_station(self, station_dict, station_id):
        """
        Takes in serialized test station dictionary and embeds it on the AudioHub. Also grabs env variables from /env/
        project path and sends those down as well.

        :param station_dict: dictionary returned by TestStation's serialize() function
        :return: None, prints exception in server log if one occurred
        """
        from embedded_thrift_server.utilities.update_ah_thrift import read_version_cache
        # Get python version and linux path to dist-packages
        try:
            py_version = read_version_cache(self.ssh, self.hostname)['py_version']
        except Exception as err:
            self.log.warning(f"Received error reading python version from cache. Using '3.7': {repr(err)}")
            py_version = '3.7'

        # Path where all packages are installed on the controller
        dist_pkg_path = f'/usr/local/lib/python{py_version}/dist-packages/'

        env_vars = {}
        if 'PROJECT_ROOT' in os.environ:  # VALIDATION-SPECIFIC: Grab .env files
            env_vars['PROJECT_ROOT'] = os.environ['PROJECT_ROOT']  # Add first as others might be based off PROJECT_ROOT
            station = socket.gethostname()
            env_path = os.path.expandvars('$PROJECT_ROOT') + '/env'
            generic_env = glob.glob(env_path + "/*.env")
            station_env = glob.glob(env_path + '/station/*%s.env' % station)
            # Update dictionary with contents of .env files
            if generic_env:
                env_vars.update(self.env_to_dict(generic_env[0]))
            if station_env:
                env_vars.update(self.env_to_dict(station_env[0]))

        # Make client key, default to None
        station_dict[self.ref_name]['client'] = None
        # Create json string
        serialized_station = json.dumps(station_dict)
        # Make all paths unix compatible
        serialized_station = serialized_station.replace(os.sep, '/')

        # Revert all expanded references of ENV variables
        for name, value in env_vars.items():
            true_value = os.path.expandvars(value).replace(os.sep, '/')
            if '/' in true_value:  # Paths only
                serialized_station = serialized_station.replace(true_value, '$' + name)
            # VALIDATION-SPECIFIC: Replace any venv package paths with the matching linux path
            value = re.sub('.*?\/Lib\/site-packages\/', dist_pkg_path, value)
            env_vars[name] = re.sub('.*?\/src\/', dist_pkg_path, value)

        # Package env data into json string
        env_vars = json.dumps(env_vars)
        # On server side: Load json str, construct test station
        return self.client.embed_test_station(serialized_station, env_vars)

    def burst(self, lines, vars, aliases):
        """
        Sends burst to AudioHub. Takes in list of lines, compiles and executes them as python code.

        :param lines: List of strings representing lines of python code. Uses 4 spaces for indentation
        :type lines: list[str]
        :param vars: dictionary containing variable information that the lines of code needs to execute.
          Updates the server with the values in this dictionary.

          **Format: {attribute_name: value}**
        :type vars: dict
        :param aliases: dictionary of TestStationObject references used by lines. updates server with these aliases by
         finding them in its embedded test_station. Format: {attribute_name: test_station ref_name}
        :type aliases: dict
        :return: Dictionary containing updated variables if changed, exception traceback and console log if applicable
        :rtype: dict
        """
        return self.client.burst(lines, vars, aliases)

    def server_eval(self, expression):
        """
        Runs eval() on ah_ctrl_server and returns JSON string of result.

        :param expression: String that will get called in eval()
        :type expression: str
        :return: JSON String
        :rtype: str
        """
        try:
            return json.loads(self.client.server_eval(expression))
        except JSONSerializeError as e:
            raise ValueError(f'Expression value is not json serializable. Traceback:\n{e.error_output}')
        except ServerError as e:
            raise Exception(f'encountered error while evaluating {expression}:\n{e.error_output}')

    # TODO: PLATDEV-1080 Remove this?
    def reload_modules(self, modules):
        """
        Reloads imported python modules while thrift server is running, in case any were updated.

        :param modules: List of modules to reload
        :type modules: List[str]
        :return: None
        :rtype: None
        """
        self.client.reload_modules(modules)

    # # ----- Logging Functions ----- # #

    def enable_transaction_logging(self, log_file=None, call_stack=True, append=False):
        """
        Starts logging all register and field transactions from the AH's internal components into csv file.

        :param log_file: path to csv file. If None, logger will track this component under all log files currently open
        :type log_file: str
        :param call_stack: Indicate whether to inspect the call stack to find calling function or not. May reduce
            performance
        :type call_stack: bool
        :param append: append parameter
        :type append: bool
        :return: None
        """
        for _, component in self.find_all(Component):
            component.enable_transaction_logging(log_file=log_file, call_stack=call_stack, append=append)

    def disable_transaction_logging(self, log_file=None):
        """
        Starts logging all register and field transactions from the AH's internal components into csv file.

        :param log_file: path to csv file. If None, logger will track this component under all log files currently open
        :type log_file: str
        :return: None
        """
        for _, component in self.find_all(Component):
            component.disable_transaction_logging(log_file=log_file)

    @abstractmethod
    def create_pins(self):
        pass

    def gen_pyi(self, indent=0, top=False, **kwargs) -> Tuple[str, Set[Tuple[str, str]]]:
        pyi_str, imports = super().gen_pyi(indent=0, top=True, **kwargs)
        self._write_pyi_file(pyi_str, imports)
        return self._get_pyi_reference()
