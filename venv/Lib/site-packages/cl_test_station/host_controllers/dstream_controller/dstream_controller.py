"""
Module for Arm DStream controller class.

*Author:* Evan Canter <evan.canter@cirrus.com>
"""
import os
import subprocess
from subprocess import Popen
from time import sleep, time
from typing import List, Union

from cl_test_station.host_controllers.dstream_controller.armdbg_session import ArmDbgSession, XSizes, XFormats
from cl_test_station.host_controllers.host_controller.host_controller import HostController, connection_required, skip_if_connected
from cl_test_station.interfaces.ctrl_interface import build_words_from_bytes, map_words_to_bytes, ByteOrder
from cl_test_station.test_station_object import TsoField


class DStreamController(HostController):
    """
    HostController for Arm DStream. Interfaces with armdbg interactive console.

    **NOTES:**
        * armdbg.exe must be added to system path. If added, pycharm will need to be closed and reopened
        * .launch files must be created beforehand in Arm's IDE
        * Connection through armdbg is generally slower than the IDE. Connection time may range from 15s-1min
        * This controller and Arm's IDE *cannot* be active at the same time. One needs to be disconnected before the other can connect
    """

    launch_file_path: str = TsoField(ftype=str, required=True,  desc="Path to the .launch file created in ArmDs workspace")
    config_db_path: str =   TsoField(ftype=str, required=False, desc='Path to external configuration database folder')
    suppress_console_prints: bool = TsoField(ftype=bool, required=False, default=False,
                                             desc="Disables relaying armdbg console output to the python console")
    connection_timeout: float = TsoField(ftype=float, required=False, default=60.0, desc="Time in seconds before armdbg"
                                                                                         " connection will time out.")
    session: ArmDbgSession = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Check paths
        if not os.path.isfile(self.launch_file_path):
            raise FileNotFoundError(self.launch_file_path)
        if self.config_db_path and not os.path.isdir(self.config_db_path):
            raise NotADirectoryError(self.config_db_path)
        # Build launch command
        cdb_root = f'--cdb-root "{self.config_db_path}"' if self.config_db_path else ''
        self._launch_command = f'armdbg --launch-config "{self.launch_file_path}" --launch-config-connect-only true ' \
                               f'--disable-analytics --stop-on-connect false {cdb_root}'

    def isConnected(self) -> bool:
        # TODO: Remove in 2.0.0 since isConnected is deprecated
        return self.is_connected()

    def is_connected(self) -> bool:
        if self.session:
            return self.session.is_connected
        else:
            return False

    @skip_if_connected
    def connect(self):
        """
        Launches armdbg session in shell and creates wrapper class around the subprocess

        :return: None
        :rtype: None
        """
        # Launch subprocess
        self.log.info("Launching armdbg session...")
        process = Popen(self._launch_command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT)
        self.session = ArmDbgSession(process)
        start = time()
        while not self.session.is_connected:
            sleep(0.005)
            if time() - start > self.connection_timeout:  # Timed out, print console and raise error
                self.log.error(f"Could not connect to DStream:\n{self.session.read()}")
                raise TimeoutError(f"Dstream connection timed out after {self.connection_timeout:2.2f} seconds")
        self.dump_console_output()

    def disconnect(self):
        if self.session:
            self.session.exit()
            self.session = None

    @connection_required
    def dump_console_output(self):
        """
        Reads the session's output stream and prints the result to the python console. Gated by suppress_console_prints

        :return: None
        :rtype: None
        """
        if not self.suppress_console_prints:
            self.log.print(self.session.read())

    def swd_read(self, address: int, byte_count: int, read_reg_data_size: int,
                 data_byte_order: Union[ByteOrder, int], **kwargs) -> List[int]:
        """
        Performs SWD memory access through the "x" command in armdbg. Returns list of bytes read from device.

        :param address: Register address
        :type address: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param read_reg_data_size: Size of register in bytes
        :type read_reg_data_size: int
        :param data_byte_order: Word byte order
        :type data_byte_order: ByteOrder | int
        :return: List of bytes read
        :rtype: List[int]
        """
        if byte_count % read_reg_data_size:
            raise ValueError(f"byte_count ({byte_count}) must be divisible by read_reg_data_size ({read_reg_data_size})")
        if type(data_byte_order) is int:
            data_byte_order = ByteOrder(data_byte_order)
        elif type(data_byte_order) is not ByteOrder:
            raise TypeError(f"data_byte_order can be of type int or ByteOrder, not {type(data_byte_order)}")
        size = XSizes(read_reg_data_size)
        words_in = self.session.x(address=address, count=byte_count//read_reg_data_size, size=size, fmt=XFormats.UINT)
        return map_words_to_bytes(list(map(int, words_in)), read_reg_data_size, data_byte_order)

    def swd_write(self, address: int, bytes_out: List[int], write_reg_data_size: int,
                  data_byte_order: Union[ByteOrder, int], verify: bool = False, **kwargs):
        """
        Performs SWD memory access through the "memory set" command in armdbg.

        :param address: Register address
        :type address: int
        :param bytes_out: Bytes to write
        :type bytes_out: list
        :param write_reg_data_size: Size of register in bytes
        :type write_reg_data_size: int
        :param data_byte_order: Word byte order
        :type data_byte_order: ByteOrder | int
        :param verify: Verifies write with an immediate read. NOT related to write verification for components
        :type verify: bool
        :return: None
        :rtype: None
        """
        # Check size of byte list
        if len(bytes_out) % write_reg_data_size:
            raise ValueError(f"Length of bytes_out ({len(bytes_out)}) must be divisible by write_reg_data_size ({write_reg_data_size})")
        # Check width parameter (bits) derived from data size (bytes)
        width = write_reg_data_size << 3
        if width not in [0, 8, 16, 32, 64]:
            raise ValueError(f"Invalid write_reg_data_size, expected: 0, 1, 2, 4, 8, got: {write_reg_data_size}")
        if type(data_byte_order) is int:
            data_byte_order = ByteOrder(data_byte_order)
        elif type(data_byte_order) is not ByteOrder:
            raise TypeError(f"data_byte_order can be of type int or ByteOrder, not {type(data_byte_order)}")
        # Build words for armdbg expression; memory_set can only take words
        words_out = build_words_from_bytes(bytes_out, write_reg_data_size, data_byte_order)
        self.session.memory_set(address=address, width=width, data=words_out, verify=verify)

    def interrupt(self) -> str:
        """
        Issues the 'interrupt' command in armdbg and returns the response as a string.

        :return: Console output after issuing the 'interrupt' command
        :rtype: str
        """
        return self.session.communicate('interrupt')

    def send_command(self, cmd: str):
        """
        Sends a command to the armdbg session and waits for completion.

        :param cmd: armdbg command
        :type cmd: str
        :return: None
        :rtype: None
        """
        self.session.send_command(cmd)

    def communicate(self, cmd: str) -> str:
        """
        Sends a command to the armdbg session and returns the resulting console output as a string.

        :param cmd: armdbg command
        :type cmd: str
        :return: Command result
        :rtype: str
        """
        return self.session.communicate(cmd)

    # TODO: PLATDEV-1079 Remove these once HostController base classes are restructured
    def read_i2c_reg(self, *args, **kwargs):
        raise NotImplementedError("I2C is not supported on DStream")

    def write_i2c_reg(self, *args, **kwargs):
        raise NotImplementedError("I2C is not supported on DStream")

    def spi_fd(self, *args, **kwargs):
        raise NotImplementedError("SPI is not supported on DStream")
