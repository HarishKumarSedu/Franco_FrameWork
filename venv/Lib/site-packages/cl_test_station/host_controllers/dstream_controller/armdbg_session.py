"""
Module for armdbg session wrapper.

*Author:* Evan Canter <evan.canter@cirrus.com>
"""
import re
import subprocess
from enum import Enum
from queue import Queue
from subprocess import Popen
from threading import Event, Thread
from time import sleep, time
from typing import List, Union


class XSizes(Enum):
    """**Enum for converting word size (Bytes) to armdbg "x" size flag**"""
    BYTE = 1
    HALF_WORD = 2
    WORD = 4
    DOUBLE_WORD = 8

    @property
    def flag(self) -> str:
        return {
            XSizes.BYTE:        'b',
            XSizes.HALF_WORD:   'h',
            XSizes.WORD:        'w',
            XSizes.DOUBLE_WORD: 'g'
        }[self]


class XFormats(Enum):
    """**Enum for all possible return formats for armdbg's "x" command**"""
    HEX = 'x'
    OCTAL = 'o'
    INT = 'd'
    UINT = 'u'
    BINARY = 't'
    CHAR = 'c'
    FLOATING_POINT = 'f'
    ASM = 'i'
    ABS_HEX = 'a'


class ArmDbgSession:
    """
    **Class that interfaces with a subprocess shell running an armdbg interactive session.
    Responsible for emulating input and processing output.**
    """
    def __init__(self, armbdg_process: Popen, encoding: str = 'UTF-8', command_timeout: float = 5.0):
        self.armdbg = armbdg_process
        self.encoding = encoding
        self.command_timeout = command_timeout
        self._stop_event = Event()
        self._connected_event = Event()
        self._command_done = Event()
        self._error_event = Event()
        self.console_output = Queue()
        self._start()

    @property
    def is_connected(self) -> bool:
        """Property which returns True or False value based on if is_connected."""
        return self._connected_event.is_set()

    @property
    def is_running(self) -> bool:
        """Property which returns True or False value based on if the stop_event.is_set()."""
        return not self._stop_event.is_set()

    def output_stream_worker(self):
        """
        Target for worker thread that continuously reads the shell's stdout. Will read until a '>' is read (new command
        ready to be input into session) and then wait for new data. Read data is then put into a Queue for the main
        thread to access.

        :return: None
        :rtype: None
        """
        while self.is_running:
            char = ''
            line = []
            while not char == '>':
                char = self.armdbg.stdout.read(1).decode(self.encoding)
                line.append(char)
                if self._command_done.is_set():
                    self._command_done.clear()
                if char == '\r':  # Carriage return, Dump do queue
                    line_str = ''.join(line)
                    if 'Connected' in line_str:
                        self._connected_event.set()
                    elif 'Disconnected' in line_str:
                        self._connected_event.clear()
                    elif 'ERROR' in line_str:
                        self._error_event.set()
                    self.console_output.put(line_str)
                    line = []
            self._command_done.set()

    def _start(self):
        self.output_thread = Thread(target=self.output_stream_worker, args=())
        self.output_thread.start()

    def _wait(self):
        start = time()
        while not self._command_done.is_set() and time() - start < self.command_timeout:
            pass

    def _raise_error(self):
        if self._error_event.is_set():
            error_msg = self.read()
            self._error_event.clear()
            raise Exception(error_msg)

    def _clear_output_queue(self):
        while not self.console_output.empty():
            self.console_output.get()

    def read(self):
        output = ''
        while not self.console_output.empty():
            output += self.console_output.get()
        return output

    def x(self, address: int, count: int, size: XSizes = XSizes.WORD, fmt: XFormats = XFormats.HEX) -> List[str]:
        """
        Wrapper function for armdbg's "x" command. Documentation for the command:

        https://developer.arm.com/documentation/dui0452/z/ds-5-debugger-commands/ds-5-debugger-commands-listed-in-alphabetical-order/x
        """
        command = f"x/{count}{size.flag}{fmt.value} 0x{address:x}"
        output = self.communicate(command)
        values = []
        for row in re.findall(r':\s*(.+?)\r', output):
            values.extend(row.split('\t'))
        return values

    def memory_set(self, address: int, width: int, data: Union[int, List[int]], verify: bool = False):
        """
        Wrapper function for armdbg's "memory set" command. Documentation for the command:

        https://developer.arm.com/documentation/dui0452/z/ds-5-debugger-commands/ds-5-debugger-commands-listed-in-alphabetical-order/memory-set
        """
        if type(data) is int:
            data_expression = hex(data)
        elif type(data) is list:
            data_expression = f"{{{', '.join(map(hex, data))}}}"
        else:
            raise TypeError(f"data must be of type list or int, not {type(data)}")
        command = f"memory set <verify={int(verify)}>:0x{address:x} {width} {data_expression}"
        self.send_command(command)

    def send_command(self, command: str):
        """Signals and executes command.
        :param command: the command
        :type command: str
        :return: Completes command, otherwise raises error."""
        command += '\r'
        self._command_done.clear()  # Signal Command is being executed
        self.armdbg.stdin.write(command.encode(self.encoding))  # Simulate typing command in shell
        self.armdbg.stdin.flush()  # Enter
        self._wait()  # Wait for command to finish
        self._raise_error()  # Check if console detected an error, raise Exception if one occurred

    def communicate(self, command: str) -> str:
        """
        Completes send_command, and then returns the read of command.

        :param command: the command
        :type command: str
        :return: self.read()
        """
        self._clear_output_queue()
        self.send_command(command)
        return self.read()

    def exit(self):
        """
        Exits, and terminates the command.
        """
        self.send_command('exit')
        while self.is_connected:
            sleep(0.005)
        self._stop_event.set()
        self.output_thread.join()


if __name__ == '__main__':
    launch_path = '"C:/Users/ecanter/Development Studio Workspace/Syd Main/Syd Main.launch"'
    cdb_path = '"C:/Users/ecanter/Development Studio Workspace/ExtensionDB"'
    armdbg_launch = f"armdbg --launch-config {launch_path} --launch-config-connect-only true --disable-analytics" \
                    f" --stop-on-connect false --cdb-root {cdb_path}"
    p = Popen(armdbg_launch, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    session = ArmDbgSession(p)
    print("Connecting...")
    while not session.is_connected:
        sleep(0.05)
    print(session.read())
    print("hi")
