import re
from typing import Dict, List, Tuple, Union

from cl_test_station.host_controllers.host_controller.host_controller import HostController, skip_if_connected
from cl_test_station.interfaces.ctrl_interface import map_word, ByteOrder
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.scs.studiolink_adapter import StudioLinkAdapter
from studiolink.enums.ControlInterface import ControlInterface
from studiolink.device_comm.Device import Device

ControlInterfaceValues = ControlInterface.ControlInterfaceValues
ControlInterfaceParameters = ControlInterface.ControlInterfaceParameters


class ScsController(HostController):

    scs_adapter: StudioLinkAdapter = None
    spi_protocols: Dict[int, Tuple[str, Device]] = {}  # chip select: (protocol name, Device object)
    i2c_protocols: Dict[int, Dict[int, Tuple[str, Device]]] = {}  # bus number: {device address: (protocol name, Device object)}
    system: str = TsoField(ftype=str, required=False, desc='Name of SCS system to link to. If none is providedm the '
                                                           'default system will be used.')

    def __init__(self, *args, **kwargs):
        super.__init__(*args, **kwargs)

    @skip_if_connected
    def connect(self):
        self.scs_adapter = StudioLinkAdapter(ref_name='scs_adapter', container=self, system=self.system,
                                             send_scs_updates=False)
        self.build_interface_maps()

    def disconnect(self):
        del self.scs_adapter
        self.scs_adapter = None

    def is_connected(self) -> bool:
        return self.scs_adapter and self.scs_adapter.link.isLinkRunning()

    def isConnected(self) -> bool:
        # TODO: Remove in 2.0.0 since isConnected is deprecated
        return self.is_connected()

    def build_interface_maps(self):
        for device in self.scs_adapter.system.getDevices():
            for interface in device.getAvailableControlInterfaces():
                if interface.getControlInterfaceType() is ControlInterfaceValues.CTRL_SPI:
                    self.spi_protocols[interface.getDeviceAddress()] = (interface.getProtocolName(), device)
                elif interface.getControlInterfaceType() is ControlInterfaceValues.CTRL_I2C:
                    bus_num = interface.getBusNumber()
                    if bus_num not in self.i2c_protocols:
                        self.i2c_protocols[bus_num] = {}
                    self.i2c_protocols[bus_num][interface.getDeviceAddress()] = (interface.getProtocolName(), device)

    # TODO: PLATDEV-1111 and PLATDEV-1112 will change how this works
    def read_i2c_reg(self, reg_addr: int, byte_count: int, address: int, bus_num: int, read_reg_data_size: int,
                     read_reg_addr_size: int, data_byte_order: Union[ByteOrder, int], **kwargs) -> List[int]:
        address_8bit = address << 1
        if bus_num not in self.i2c_protocols:
            raise ValueError(f"No devices found using I2C bus {bus_num}. Busses with devices are: "
                             f"{', '.join(self.i2c_protocols.keys())}")
        if address_8bit not in self.i2c_protocols[bus_num]:
            raise ValueError(f"No device with address {address:2x} found on bus {bus_num}. Devices on bus {bus_num} are"
                             f": {', '.join([hex(a>>1) for a in self.i2c_protocols[bus_num].keys()])}")
        protocol_name, device = self.i2c_protocols[bus_num][address]
        requested_protocol_name = f"SMbus_{read_reg_addr_size<<3}inx_{read_reg_data_size<<3}dat"
        if requested_protocol_name != protocol_name:
            inx, dat = map(lambda x: int(x)>>3, re.match(r"SMbus_(\d+)inx_(\d+)dat").groups())
            raise ValueError(f"SCS protocol requires read_reg_addr_size={inx} (received {read_reg_addr_size}), "
                             f"read_reg_data_size={dat} (received {read_reg_data_size})")
        if type(data_byte_order) is int:
            data_byte_order = ByteOrder(data_byte_order)
        word = device.readRegisterByAddressWithProtocol(reg_addr, protocol_name, address_8bit)
        return map_word(word, read_reg_data_size, data_byte_order)
