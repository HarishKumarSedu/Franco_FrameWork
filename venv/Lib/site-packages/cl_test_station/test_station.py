"""TestStationObject class that represents a whole test system/station"""
import os
import json
import inspect
import logging
import traceback
import socket
import time
import sys
from importlib import import_module
from pathlib import Path
from typing import Dict, List, Tuple, Iterator

import yaml
import Pyro5
import Pyro5.api
import Pyro5.client
import Pyro5.errors
from cl_test_station.test_station_object import TestStationObject, TsoField
from cl_test_station.test_station_server import TestStationServer, ServerInfo
from cl_test_station.host_controllers.host_controller.host_controller import HostController
from cl_test_station.host_controllers.audiohub_controller.audiohub_controller import AudioHubController
from cl_test_station.host_controllers.zdc_controller.zdc_controller import ZdcController
from cl_test_station.host_controllers.thrift_controller.thrift_controller import ThriftController
from cl_test_station.host_controllers.sim_host_controller.sim_host_controller import SimHostController
from cl_test_station.pyro_support.pyro_receiver import PyroReceiver
from cl_test_station.instrumentation.instrument_adapter import InstrumentAdapter
from cl_test_station.gpio.pin import Pin
# - - - - - deprecated - - - - -
from cl_test_station.instrumentation.instrument_server import InstrumentBuilder
# - - - - - - - - - - - - - - - -
from cl_test_station.utilities.cl_yaml_loader import load_and_expand_yaml
from cl_test_station.utilities.reusables import (
    expand_config_files, expand_env_variables, diff_configs, read_bool_value, LOCALHOST
)
from cl_test_station.test_utils.val_database import ValDatabase


class TestStationServerError(Exception):
    """Custom Exception for TestStationServer issues"""


class TestStation(TestStationObject):
    """Class to represent a whole test system"""
    database_component_name: str = TsoField(ftype=str, required=False, default='val_db', desc='Validation database '
                                                                                              'class component name')
    tcorner_instrument_name: str = TsoField(ftype=str, required=False, default='temperature_controller',
                                            desc='Name of instrumet used to set tcorner')

    def __init__(self, config, *args, log_level=None, **kwargs):
        # Set defaults TODO: Convert to TsoFields
        self.ns_port = 1025  # adding default Pyro Name Server port
        self.config = {}
        self.class_type = self.__class__.__module__ + '.' + self.__class__.__name__
        # Preloaded config dictionary was passed in
        if type(config) is dict:
            self.config = config
        # Path to config YAML file was given
        elif type(config) is str and Path(config).suffix == '.yml':
            self.config = load_and_expand_yaml(config)

        # Get log level to use. Order of precedent: log_level kwarg -> log_level from config -> INFO
        if 'log_level' in self.config:
            if not log_level:  # Log level specified in the YAML but not kwargs
                log_level = self.config['log_level']
            self.config.pop('log_level')
        elif not log_level:  # Default to INFO
            log_level = 'INFO'

        super().__init__(*args, excluded_classes=[TestStationObject], ref_name='test_station',
                         log_level=log_level, **self.config, **kwargs)
        self.configure(config)
        # Clear excluded classes so that TestStationServer types can be created
        self.excluded_classes = None

    def __iter__(self) -> Iterator[Tuple[str, TestStationObject]]:
        # Yield all tso's from resources
        yield from super().__iter__()
        # yield any nested resources from pyro host controllers
        for hc_name, controller in self.get_host_controllers().items():
            if hasattr(controller, 'resources') and hc_name not in self.resources:  # This Controller is untracked
                for ref_name, tso in controller.resources.items():
                    yield ref_name, tso

    def construct_test_server(self) -> Dict[str, TestStationObject]:
        """
        Constructs specifically TestStationServer objects defined in the configuration

        :return: Resources dictionary
        :rtype: dict
        """
        resources = self.construct_objects(specific_class=TestStationServer)
        for _, tso in self:
            tso.post_construct_system()
        if not self.uses_ts_server:  # No server was constructed, throw exception
            msg = "No server was found in config, try changing project configs to one with a server defined"
            raise TestStationServerError(msg)
        elif len(self.find_all(TestStationServer)) > 1:  # Can only have 1 server defined
            msg = "More than one TestStationServer defined in the project config, please remove all but one server" \
                  " definiton"
            raise TestStationServerError(msg)

        return resources

    def cleanup_system(self):
        """
        Closes all Pyro connections in the TestStation object

        :return: None
        """
        for key, obj in self.__dict__.items():
            if type(obj) is PyroReceiver:
                obj.proxy._pyroRelease()

    @property
    def uses_ts_server(self) -> bool:
        """
        Checks if test station config uses a TestStationServer

        :return: True if there is a TestStationServer definition in the config yml, False otherwise
        """
        return bool(self.get_server_ref_name())

    def get_server_ref_name(self):
        """
        Returns name of the TestStationServer defined in this station's config.

        :return: server name. None if no server is found
        :rtype: str
        """
        for key, value in self.config.items():
            if type(value) is dict:
                if 'class_type' in value and 'TestStationServer' in value['class_type']:
                    return key
        return None

    def __get_server_info_from_pyro(self, name_server) -> ServerInfo:
        # TODO: Have error handling id this key does not exist
        try:
            server_info_proxy = Pyro5.client.Proxy(name_server.lookup('_server_info'))
            try:
                server_info_proxy._pyroBind()
            except Pyro5.errors.CommunicationError:
                server_info_proxy._pyroReconnect(2)
        except:
            self.log.exception("Failed to grab _server_info from Pyro server.")
        server_info = PyroReceiver('_server_info', server_info_proxy, -1)
        return server_info


    def construct_system(self, gen_pyi=False) -> Tuple[int, int]:
        """
        Constructs the client side system. This will construct anything that is not a TestStationServer. It will attempt
        check if a TestStationServer is running and get resources from the server.

        :return: Tuple containing number of errors and warnings encountered during construction: (err_cnt, warn_cnt)
        :rtype: tuple
        """
        self.log.info("Constructing TestStation", border='=')
        self.log.pop_counts()
        # Since the host controller is needed for a lot of the component auto-downloading features, building it first
        # guarantee that it will be available when the components construct
        self.construct_objects(specific_class=HostController)
        self.construct_objects(specific_class=InstrumentAdapter)

        # Grab resources from pyro server if necessary
        if self.uses_ts_server:
            self.log.info('Connecting to Pyro server and grabbing remote objects', border='=')
            abort_msg = ''
            Pyro5.config.SERPENT_BYTES_REPR = True  # Allow raw bytes to be sent over serpent without encoding
            # Check to see if the resource is in the Pyro TestStationServer
            try:
                ip_addr = LOCALHOST
                self.log.info("HOST NAME: %s" % socket.gethostname())
                self.log.info("IP ADDR: %s" % ip_addr)
                ns = Pyro5.api.locate_ns(host=ip_addr, port=self.ns_port)
                # resource_list = list(ns.list().keys())
                self.log.info("Grabbing objects from Pyro server")
                # Get server info first
                self._server_info = self.__get_server_info_from_pyro(ns)

                # Create all basic pyro receivers
                for resource_name in self._server_info.transmitters:
                    start_time = time.time()
                    try:
                        proxy = Pyro5.client.Proxy(ns.lookup(resource_name))
                        try:
                            proxy._pyroBind()
                        except Pyro5.errors.CommunicationError:
                            proxy._pyroReconnect(2)
                        if resource_name == '_server_instruments':  # This is the instrument adapter
                            receiver = PyroReceiver(resource_name, proxy, debugprintlevel=-1)
                            ref_name = receiver.get_ref_name()  # Get actual ref_name from server
                            adapter = InstrumentAdapter(ref_name=ref_name, container=self, logger=self.log,
                                                        log_level=self.log.getEffectiveLevel(), pyro_handle=receiver)
                            adapter.config.update(receiver.config)
                            adapter.configure(None)
                            self.__setattr__(ref_name, adapter)
                            self.resources[ref_name] = adapter
                        else:  # Normal PyroReceiver
                            receiver = PyroReceiver(resource_name, proxy, debugprintlevel=-1)
                            self.__setattr__(resource_name, receiver)
                    except AttributeError as attr_err:
                        if '__get_register_list__' not in str(attr_err):
                            self.log.exception("Failed to grab %s from Pyro server." % resource_name)
                    except:
                        self.log.exception("Failed to grab %s from Pyro server." % resource_name)
                    end_time = time.time()
                    self.log.debug(f'  ({end_time-start_time:2.5f}s) {resource_name}')

                # Create classes with internal transmitters
                for resource_name, config in self._server_info.transmitter_wrappers.items():
                    # Import class
                    module_name, _, class_name = config['class_type'].rpartition('.')
                    module = import_module(module_name)
                    cls = getattr(module, class_name)
                    # Get __init__ arguments
                    sub_config = config['init_kwargs']
                    if issubclass(cls, TestStationObject):  # Need to add container
                        sub_config['container'] = self
                    # Get all pyro receivers
                    pyro_kwargs = {}
                    start_time = time.time()
                    for attr_name in config['attr_names']:
                        full_name = f"{resource_name}_{attr_name}"
                        try:
                            proxy = Pyro5.client.Proxy(ns.lookup(full_name))
                            try:
                                proxy._pyroBind()
                            except Pyro5.errors.CommunicationError:
                                proxy._pyroReconnect(2)
                            receiver = PyroReceiver(full_name, proxy, debugprintlevel=-1)
                            pyro_kwargs[attr_name] = receiver
                        except:
                            self.log.exception("Failed to grab %s from Pyro server." % resource_name)
                    sub_config.update(pyro_kwargs)
                    # Instantiate class
                    resource = cls(**sub_config)
                    setattr(self, resource_name, resource)
                    if isinstance(resource, TestStationObject):
                        self.resources[resource.ref_name] = resource
                        resource.check_fields(sub_config)
                        resource.configure(sub_config)
                    end_time = time.time()
                    self.log.debug(f'  ({end_time - start_time:2.5f}s) {resource_name}')

                # Check that the server config matches the local server config
                if hasattr(self, '_server_info'):
                    server_config = self._server_info.get_config()
                    # ToDo: CL Test Station 2.0 fix diffing mechanism to align with new construction
                    expand_config_files(server_config)
                    # todo: Fix this workaround (instmngr1 Builder has objects in the config dict)
                    if server_config:
                        expand_env_variables(server_config)
                        local_config = self.config[self.get_server_ref_name()]
                        expand_env_variables(local_config)
                        expand_config_files(local_config)
                        diff_f, diff_b = diff_configs(local_config, server_config)
                        if diff_f or diff_b:  # Wrong server running
                            self.log.warning("Config for '%s' does not match with the TestStationServer found, might "
                                             "result in Errors"
                                             % self.get_server_ref_name())
                            self.log.warning("Try relaunching the server (eg run launch_server.py) to correct the "
                                             "mismatch")
                            self.log.draw_line('-', 'DEBUG')
                            self.log.debug("What the server has:")
                            for path, value in diff_b:
                                self.log.debug('\t' + path + ': ' + str(value))
                            self.log.debug("What you have:")
                            for path, value in diff_f:
                                self.log.debug('\t' + path + ':' + str(value))
                            self.log.draw_line('-', 'DEBUG')

            # If an error comes up, this means there are no Pyro resources and we do nothing
            # todo: Look into this whole section -> Hook up AP
            except Pyro5.errors.NamingError as e:  #pylint: disable=invalid-name
                if 'nameserver' in str(e):  # Test station uses a server but the server is not running
                    abort_msg = "Test Station Server not found. Make sure server is running (eg run launch_server.py)"
                    self.log.critical(abort_msg)
            except Pyro5.errors.SerializeError:
                pass
            except socket.gaierror as e:  #pylint: disable=invalid-name
                if sys.platform == 'win32':
                    raise e
                else:
                    pass
            finally:
                if abort_msg:  # Halts further construction
                    raise TestStationServerError(abort_msg)

        # Since we don't want to construct the TestStationServer when we construct the client system, we exclude it
        # Since the host_controller was specifically targeted to construct at the beginning of the function, we exclude
        # it here also
        for _, adapter in self.find_all(InstrumentAdapter):
            for inst_name, inst in adapter.instruments.items():
                setattr(self, inst_name, inst)
        self.excluded_classes = [TestStationServer, HostController, InstrumentAdapter]

        self.construct_objects()
        self.post_construct_system()
        for tso in self.__iterate_with_groups('_post_construct_group'):
            tso.post_construct_system()
        err_cnt, warn_cnt = self.log.pop_and_display_counts('Construction complete')
        if gen_pyi:
            self.gen_pyi(top=True)
        return err_cnt, warn_cnt

    def get_host_controllers(self) -> Dict[str, HostController]:
        """
        Finds all HostControllers in Test Station.

        :return: Dictionary of ref_name keys with reference values
        :rtype: Dict[str, HostController]
        """
        host_controllers = {}
        if hasattr(self, '_server_info'):
            for ref_name in self._server_info.host_controllers:
                if hasattr(self, ref_name):
                    host_controllers[ref_name] = getattr(self, ref_name)
        host_controllers.update(self.__find_local_host_controllers(self))
        return host_controllers

    def get_instruments(self) -> Dict[str, object]:
        """
        Finds all instrument handles in Test Station

        :return: Dict[str, Driver] ref_name: driver reference
        """
        instruments = {}
        if hasattr(self, '_server_info'):
            for ref_name in self._server_info.instruments:
                instruments[ref_name] = self.find_resource(ref_name)[0][1]
        instruments.update(self.__find_local_instruments())
        return instruments

    def __find_local_host_controllers(self, obj):
        host_controllers = {}
        for ref_name, ts_obj in obj.resources.items():
            if isinstance(ts_obj, HostController):
                host_controllers[ref_name] = ts_obj
            elif isinstance(ts_obj, TestStationObject):
                host_controllers.update(self.__find_local_host_controllers(ts_obj))
        return host_controllers

    def __find_local_instruments(self):
        instruments = {}
        for ref_name, ts_obj in self.resources.items():
            # - - - - - deprecated - - - - -
            if isinstance(ts_obj, InstrumentBuilder):
                for ins_name, ins_cls in ts_obj.resources.items():
                    instruments[ins_name] = ins_cls.config['instance']
            # - - - - - - - - - - - - - - - -
            if isinstance(ts_obj, InstrumentAdapter):
                instruments.update(ts_obj.instruments)
        return instruments

    def system_initialize(self, log_level=None, stop_at_level=False, abort_on_error=False, **kwargs) -> Tuple[int, int]:
        """
        Calls initialize() for all objects in the TestStation, top down. Ex: it will initialize all boards before trying
        to initialize any components. For TestStationObjects at the same level, the order of initialization will be
        the order that they are defined in the project configuration YAML file.

        :param log_level: Sets cl_test_station logging level to log_level. Will restore the existing level at end
        :type log_level: str | None
        :param stop_at_level: If this function encounters an error initializing a part, initialization will not go deeper
        :type stop_at_level: bool
        :param abort_on_error: Any error encountered will halt all initialization and the function will return
        :type abort_on_error: bool
        :param kwargs: keyword arguments will get passed to all initialize functions equally, use unique names for
            Component/Board initialize functions if you want to use kwargs
        :type kwargs: Any
        :return: Tuple containing number of errors and warnings encountered during Initialization: (err_cnt, warn_cnt)
        :rtype: Tuple[int, int]
        """
        self.log.info('Starting initialization sequence', border='=')
        err, warn = self.log.pop_counts()
        if log_level is not None:
            # Save logging level and set new one
            old_level = self.log.getEffectiveLevel()
            self.log.setLevel(log_level)
        # Initialize TestStation first
        try:
            self.initialize(standalone=True, **kwargs)
        except Exception as sys_init_err:
            self.log.error("Failed to initialize %s" % self.ref_name)
            raise sys_init_err
        # Now initialize all resources of test station recursively
        try:
            self.__system_initialize_helper(self, stop_at_level, abort_on_error, **kwargs)
            # Post system initialize all TSOs
            for tso in self.__iterate_with_groups('_post_initialize_group'):
                tso.post_system_initialize()
            # Post system initialize test station
            self.post_system_initialize()
        except:
            sys.exc_info()
            self.log.exception('Error that caused abort:')
        self.gen_pyi(top=True)  # generate stubs for autocomplete
        if log_level is not None:
            # Restore logging level
            self.log.setLevel(old_level)
        return self.log.pop_and_display_counts('Initialization complete')

    def __iterate_with_groups(self, group_attr_name: str) -> Iterator[TestStationObject]:
        """
        Generator that provides resources in groups, denoted by the group_attr_name attribute. This attribute will be
        an integer, and will be grouped by increasing value.

        :param group_attr_name: Name of group attribute (integer)
        :type group_attr_name: str
        :return: Resources in this test station instance in groups
        :rtype: Iterator
        """
        groups = {}
        for _, tso in self:  # Loop through all nested TSO's
            group = getattr(tso, group_attr_name)
            # Add TSO to its group list
            if group not in groups:
                groups[group] = []
            groups[group].append(tso)
        for group in sorted(list(groups.keys())):  # Iterate groups in increasing order
            tso_list = groups[group]
            if tso_list:
                self.log.debug(
                    f"Iterating group {group_attr_name}={group}: {', '.join([t.ref_name for t in tso_list])}"
                )
            for tso in tso_list:  # Yield each TSO in order of appearance
                yield tso

    def __system_initialize_helper(self, ts_obj, stop_at_level, abort_on_error, **kwargs):
        """
        Recursive helper function for system_initialize that controls the iteration through the test system

        :param ts_obj: current TestStationObject
        :type ts_obj: TestStationObject
        :param stop_at_level: If this function encounters an error initializing a part, initialization will not go
            deeper
        :type stop_at_level: bool
        :param abort_on_error: Any error encountered will halt all initialization and the function will return
        :type abort_on_error: bool
        :param kwargs: keyword arguments will get passed to all initialize functions equally, use unique names for
            Component/Board initialize functions if you want to use kwargs
        :type kwargs: Any
        :return: None
        :rtype: None
        """
        # Init all resources
        init_error_list = []
        for ref_name, resource in ts_obj.resources.items():
            if isinstance(resource, TestStationObject):
                try:
                    resource.initialize(standalone=True, **kwargs)
                except Exception as e:  # pylint: disable=invalid-name
                    if abort_on_error:  # Raising an error travels up recursive loop, stopping all initialization
                        self.log.critical("Aborting system initialize")
                        raise e
                    self.log.exception("Failed to initialize %s" % resource.ref_name)
                    if stop_at_level:  # Record failure so that no children of this TSO will be initialized
                        init_error_list.append(resource.ref_name)
        # go through and recursively init
        for ref_name, resource in ts_obj.resources.items():
            if ref_name in init_error_list:
                for child in resource.resources.keys():
                    self.log.warning('Stopped at level: Skipping %s since %s failed to initialize' % (child, ref_name))
                continue
            self.__system_initialize_helper(resource, stop_at_level, abort_on_error, **kwargs)

    def prepare_host_controllers(self, **kwargs):
        """
        Holds code called to prepare the TestStation so that all HostControllers can be connected after its completion

        :param kwargs: pass through keyword arguments
        :type kwargs: Any
        :return: None
        :rtype: None
        """
        pass

    def initialize(self, **kwargs):
        """
        Initializes the test system by calling prepare_host_controllers, connect_all_controllers, and program_all_fpga.
        The rest of the system will be initialized as part of the system_initialize that calls this function.

        :param kwargs: pass through keyword arguments
        :type kwargs: Any
        :return: None
        :rtype: None
        """
        super().initialize(**kwargs)   # reuse to get consistence log message

        self.prepare_host_controllers(**kwargs)  # prepare system so all HostControllers can be connected
        self.connect_all_controllers()           # connect all HostControllers (HCs)
        self.program_all_fpgas()                 # program auto-program set FPGAs, needs HCs to read version

    def shutdown(self, log_level=logging.INFO, **kwargs):
        """
        Disconnects all host_controllers

        :return: None
        """
        # Save logging level and set new one
        old_level = self.log.getEffectiveLevel()
        self.log.setLevel(log_level)
        super().shutdown(**kwargs)
        for name, controller in self.get_host_controllers().items():
            try:
                controller.disconnect()
            except Exception as e:  # pylint: disable=invalid-name
                self.log.exception("Failed to disconnect %s" % name)
        self.log.setLevel(old_level)

    def construct_component_registers(self, obj=None, gen_pyi=False):
        """
        Recursively searches through test_station (top=obj) and calls construct_registers() on any Component that
        implements it.

        :param obj: Object to search through for components. If None, self is used (Default: None)
        :type obj: TestStationObject
        :param gen_pyi: When True, will generate stub files after registers for all components have been constructed
            (Default: False)
        :type gen_pyi: bool
        :return: None
        """
        obj = obj if obj else self
        for ref_name, ts_obj in obj:
            if hasattr(ts_obj, 'construct_registers'):
                try:
                    ts_obj.construct_registers()
                except:
                    self.log.exception(f"Failed to constuct {ts_obj.ref_name} registers")
        if gen_pyi:
            self.gen_pyi(top=True)

    def connect_all_controllers(self):
        """
        Attempts to connect all HostControllers in the test station, including one located in a TestStationServer

        :return: None
        :rtype: None
        """
        self.log.info("Connecting to all host controllers")
        for name, controller in self.get_host_controllers().items():
            try:
                start = time.time()
                self.log.info(f"Connecting to {name}")
                # TODO: Remove args once embedded support for thrift controllers is dropped
                args = [list(sys.modules.keys())] if isinstance(controller, ThriftController) else []
                controller.connect(*args)
                self.log.info(f"Connected to {name}, time to connect = {time.time()-start:3.4f}s")
            except Exception as err:  # pylint: disable=invalid-name
                self.log.exception(
                    f"Could not connect to {name}, check that the controller is powered and the server is running"
                )

    def program_all_fpgas(self):
        """
        Attempts to program all FPGAs in the test system set to auto program with its specified FPGA Version. Basically
        calling self.program_fpga(self.fpga_version) on all TestStationObjects with self.fpga_auto_program = True.

        :return: None
        :rtype: None
        """
        for ref_name, ts_obj in self:
            if hasattr(ts_obj, 'fpga_auto_program'):
                ts_obj.fpga_auto_program = read_bool_value(ts_obj.fpga_auto_program)
                if ts_obj.fpga_auto_program:
                    self.log.info("%s fpga_auto_program enabled" % ts_obj.ref_name)
                    self.log.info("Programming %s FPGA with %s version" % (ts_obj.ref_name, ts_obj.fpga_version))
                    ts_obj.program_fpga(ts_obj.fpga_version)

    @property
    def station_id(self):
        """
        Returns the test systems ID value

        :return: ID value
        :rtype: int
        """
        return self.generate_id()

    def generate_id(self, level=1, recursive=True, dbg_dict=None):
        """
        When using TestStationServer, adds host controller data to ID value

        :param level: recursion level
        :param recursive: When True, will add IDs of resources to its personal ID
        :return: int, ID value
        """
        self.log.dev("GENERATING STATION ID")
        if dbg_dict is not None:
            dbg_dict[self.ref_name] = {}
            d = dbg_dict[self.ref_name]
        else:
            d = None
        id = super().generate_id(level, recursive, dbg_dict=d)
        host_controllers = {}
        if hasattr(self, '_server_info'):
            for ref_name in self._server_info.host_controllers:
                hc_id = self.find_resource(ref_name)[0][1].generate_id()
                id += hc_id
                self.log.dev(f"{ref_name}: {hc_id}")
                if dbg_dict is not None:
                    dbg_dict[ref_name] = hc_id
            self.log.dev(("  RUNNING TOTAL: %d  " % id).center(80, '-'))
        return id

    def serialize(self, top=True, exclude_classes=None, file_path=None, compress=True, include_cl_server=False):
        """
        Extends TestStationObject serialize by adding option do add TestStationServer info in serialization

        :param top: bool, indicates if self is top level of test station
        :param exclude_classes: List of strings containing class names that won't be serialized
        :param file_path: Optional path of file to dump serialized json data
        :param include_cl_server: flag, when true, will serialize all host controllers in server
        :return: dictionary representing serialized test station
        """
        if exclude_classes is None:
            exclude_classes = ['ValDatabaseTool', 'ValDatabases', 'ValDatabase']
        base_dict = super().serialize(top=top, exclude_classes=exclude_classes, file_path=file_path, compress=compress)
        # Get entry for the test station since they don't use class_type
        station_dict = base_dict.pop(self.ref_name)
        # Need to get rid of unwanted entries in the config (like ns_port and the server definition)
        for unwanted in [key for key in station_dict.keys() if key not in self.resources]:
            station_dict.pop(unwanted)
        if include_cl_server:
            if hasattr(self, '_server_info'):
                for ref_name in self._server_info.host_controllers:
                    station_dict[ref_name] = self.resolve_path(ref_name).serialize()
        station_dict['id'] = self.station_id
        station_dict['test_station'] = self.class_type
        if top:
            json_string = json.dumps(station_dict, indent=4)
            if file_path is not None:
                with open(os.path.expandvars(file_path), "w") as json_file:
                    json_file.write(json_string)
        return station_dict

    def __id_dict_diff(self, local_d, remote_d, indent=0, name='remote'):
        tab = ' '*4*indent
        for name, sum in local_d.items():
            name = os.path.normpath(name)
            if type(sum) is int:
                if name in remote_d:
                    if local_d[name] != remote_d[name]:
                        self.log.debug(f'{tab}{name}: {local_d[name]} (local) != {remote_d[name]} (remote)')
                else:
                    self.log.debug(f'{tab}{name} not found in {name}')
            elif type(sum) is dict:
                if name not in remote_d:
                    self.log.debug(f'{tab}{name} not found in {name}')
                    continue
                else:
                    self.log.debug(f'{tab}{name}:')
                    self.__id_dict_diff(local_d[name], remote_d[name], indent+1)

    def embed_in_controller(self, host_controller=None, force=False):
        """
        Embeds self (TestStation) in host_controller. If no host_controller handle is provided, this function grab the
        first available handle and use it. Will download necessary external files and create a copy of the test
        station in the host controller thrift server (python instance)

        :param host_controller: handle to the host controller to embed the test station in
        :param force: when true, will always attempt to embed, even if remote station ID matches the local ID
        :return:
        """
        # Get station id
        id_dict = {}
        ts_id = self.generate_id(dbg_dict=id_dict)
        # Get a host controller if none is provided
        if host_controller is None:
            host_controller = list(self.get_host_controllers().values())[0]
        # Ping test station and embed if no response or the embedded station differs from self
        if not host_controller.ping_test_station() == str(ts_id) or force:
            result = json.loads(host_controller.embed_test_station(self.serialize(top=True, include_cl_server=self.uses_ts_server), ts_id))
            if type(result) is int:
                if result == ts_id:
                    self.log.info(f'Successfully embedded test station (id={ts_id})')
                else:
                    self.log.error("Unknown error")
            elif type(result) is dict:  # Difference in ID, diff debug dict
                self.log.warning("Embedded station's ID differs from Local station. Behavior may be unexpected", suppress_file_msg=True)
                self.log.debug("Differences:")
                self.__id_dict_diff(local_d=id_dict, remote_d=result, indent=0)
                self.__id_dict_diff(local_d=result, remote_d=id_dict, indent=0, name='host')
            elif type(result) is str:  # Error loc, paste to console
                self.log.error("Encountered Errors while embedding station. See log below")
                c = "\033[91m"
                self.log.print(c + ' EMBEDDED OUTPUT '.center(150, '='))
                for line in result.split('\n'):
                    line = line.split('-')
                    if len(line) >= 6:
                        level = line[3].strip().lower()
                        msg = line[5].strip()
                        self.log.__getattribute__(level)(msg)
                    else:
                        self.log.print('-'.join(line))
                self.log.print(c + ' EMBEDDED OUTPUT '.center(150, '='))
        else:
            self.log.info("%s (id=%s) already embedded in %s" % (self.ref_name, ts_id, host_controller.ref_name))

    def gen_pyi(self, indent=0, top=False):
        """
        Generates and writes to TestStation.pyi. Contains all dynamic attributes, PyroReceivers, component information.
        Only overwrites if generated code is different from current; take more computation but saves pycharm from
        reindexing at every test run

        :param indent: current nest level
        :param top: flag indicating top caller
        :return: None
        """
        start = time.time()
        # Use inspect to find the file path for the calling class
        # inspect returns the full path of the py file, add an i to make it a pyi
        pyi_path = inspect.getfile(type(self)) + 'i'
        pyi_str, imports = super().gen_pyi(indent=indent, top=top)
        pyi_file_str = ''
        for module, cls in sorted(imports):
            pyi_file_str += 'from %s import %s\n' % (module, cls)
        pyi_file_str += pyi_str
        self.update_pyi_file(pyi_file_str)
        self.log.info("Generated stubs in %2.6fs" % (time.time() - start), border='=')

    def enable_transaction_logging(self, log_file=None, call_stack=True, append=False):
        """
        Enables transaction logging for all components under self. if 'log_file' is specified, all components will be
        tracked using only that file

        :param log_file: Path to csv log file
        :type log_file: str
        :param call_stack: When true, logs the function call stack for each transaction. Slightly increases time
            between transactions.
        :type call_stack: bool
        :param append: When False, deletes log_file if it exists and creates an empty log file. When True and log_file
            already exists, the logger will append to the end of the file, keeping previous log entries.
        :type append: bool
        :return: None
        """
        for ref_name, tso in self:
            if hasattr(tso, 'enable_transaction_logging') and type(tso) is not TestStation:  # This is a component
                tso.enable_transaction_logging(log_file=log_file, call_stack=call_stack, append=append)
        # Transfer log information over to the Audiohub's components
        for host_controller in self.get_host_controllers().values():
            # Enable logging for server side components
            if hasattr(host_controller, 'enable_transaction_logging'):
                host_controller.enable_transaction_logging(log_file=log_file, call_stack=call_stack, append=True)
            if hasattr(host_controller, 'resources') and  type(host_controller.resources) is dict:  # Log components
                for resource in host_controller.resources.values():  # Enable logging for components attached to PyroReceiver
                    if hasattr(resource, 'enable_transaction_logging'):
                        resource.enable_transaction_logging(log_file=log_file, call_stack=call_stack, append=append)

    def disable_transaction_logging(self, log_file=None):
        """
        Disables transaction logging for all components under self. if 'log_file' is specified, all components will be
        untracked using only that file

        :param log_file: Path to csv log file
        :type log_file: str
        :return: None
        """
        for ref_name, tso in self:
            if hasattr(tso, 'disable_transaction_logging') and type(tso) is not TestStation:  # This is a component
                tso.disable_transaction_logging(log_file=log_file)
        # Transfer log information over to any HostController attached components
        for host_controller in self.get_host_controllers().values():
            if hasattr(host_controller, 'disable_transaction_logging'):
                host_controller.disable_transaction_logging(log_file=log_file)  # Disables logging for server side components
            if hasattr(host_controller, 'resources') and  type(host_controller.resources) is dict:
                for resource in host_controller.resources.values():  # Disables logging for components attached to PyroReceiver
                    if hasattr(resource, 'disable_transaction_logging'):
                        resource.disable_transaction_logging(log_file=log_file)

    def apply_voltage_corner(self, vcorner: str = 'TYP'):
        """
        Configures DUT to the specified voltage corner

        :param vcorner: Voltage Corner to apply (Default: TYP)
        :type vcorner: str
        :return: None
        :rtype: None
        """
        # retrieve voltage corner
        settings = getattr(self, self.database_component_name).get_voltage_corner(vcorner)
        self.log.debug(f'Vcorner {vcorner}: {settings}')
        if settings:
            # set supplies to voltage corner
            self.log.info(f'Applying {vcorner} voltage corner')
            self._set_vcorner_supplies(**settings)

    def _set_vcorner_supplies(self, *args, **kwargs):
        self.log.warning("This function 'set_vcorner_supplies' is intended to be overriden in project specific test station class.")

    def apply_temperature_corner(self, tcorner: str = 'ROOM', soak_time: float = 60):
        """
        Configures DUT to the specified temperature corner

        :param tcorner: Temperature Corner to apply (Default: ROOM)
        :type tcorner: str
        :return: None
        :rtype: None
        """
        # retrieve temperature corner
        settings = getattr(self, self.database_component_name).get_temperature_corner(tcorner)
        self.log.debug(f'Tcorner {tcorner}: {settings}')
        if settings:
            # set supplies to temperature corner
            self.log.info(f'Applying {tcorner} temperature corner')
            self._set_tcorner_instrument(soak_time=soak_time, **settings)

    def _set_tcorner_instrument(self, temperature: float, soak_time: float, *args, **kwargs):
        """
        Applies the TCorner temperature to the temperature instrument.
        :param temperature:Temperature in degrees C
        :type temperature: float
        :param soak_time: Time in seconds to sit and soak after temperature is reached
        :type soak_time:float
        :param args:
        :type args:
        :param kwargs:
        :type kwargs:
        :return: Returns the post soak time measured temperature in degrees C.
        :rtype: float
        """
        self.log.info(f'Setting temperature controller to {temperature} degrees, soaking for {soak_time} sec')
        post_temp_soak = getattr(self.instruments, self.tcorner_instrument_name).set_temp_and_soak(temperature, soak_time)
        return post_temp_soak

    def get_val_db_attr(self):
        """
        Returns the ValDatabase attribute of Test Station, can be used in other classes to find the attribute by
        type.
        :return: database_component_name
        :rtype: TestStationObject
        """
        if hasattr(self, 'database_component_name'):
            return self.resolve_path(self.database_component_name)
        val_db_attrs = self.find_all(ValDatabase, start_from_top=True)
        val_db_attr = val_db_attrs[0][1]
        return val_db_attr


if __name__ == "__main__":
    os.environ['PACKAGE_ROOT'] = r'C:\validation\Projects\Mahoney\python\mahoney_venv\src\cl-test-station'
    this_path = Path(__file__).resolve().parent
    test_yaml = this_path/'example_yaml'/'system_config_example.yml'
    extra_paths = [os.path.expandvars(r'$PACKAGE_ROOT\cl_test_station\board\test_input\test_peripherals')]
    # extra_paths.append(r'C:\validation\Projects\Mahoney\mahoney_test_env\src\cl-test-station\cl_test_station\board\ctrl_interface')

    with open(test_yaml, 'r') as yml_file:
        sys_config = yaml.load(yml_file, Loader=yaml.FullLoader)

    test_station = TestStation(sys_config)
    # test_server = test_station.construct_test_server()['cl_test_station_server']
    test_station.construct_system()
    dut = test_station.hank_revB_single.dut
    emu_wrapper = test_station.hank_revB_single.emu_wrapper
    control_fpga = test_station.hank_revB_single.control_fpga
    print(test_station)
