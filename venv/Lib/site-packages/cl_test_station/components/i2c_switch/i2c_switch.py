from abc import abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Union

from cl_test_station.components.component.component import Component, static_component
from cl_test_station.register_map.field import Field
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.tso_container import TsoContainer


@dataclass
class I2CSwitchChannel:
    """**Dataclass that models a single channel in a switch. Specific implementations can have different fields, but
        should have the same functions.**"""
    ch_num: int  # Channel number used for integer conversion
    """Channel number used for integer conversion"""
    _enable_field: Field = field(repr=False)
    enable_level: int = field(repr=False, default=1)  # Field value that enables channel
    """Field value that enables channel"""

    def __int__(self):
        return self.ch_num

    def enable(self):
        """
        Sets field value to self.enable_level.

        :return: None
        """
        self._enable_field.value = self.enable_level

    def disable(self):
        """
        Sets field value to disabled.

        :return: None
        """
        self._enable_field.value = 1 - self.enable_level

    def is_enabled(self) -> bool:
        """
        Checks if channel switch is enabled.

        :return:

           **If enabled: Returns True**

           **If disabled: Returns False**

        """
        return not self._enable_field.value ^ self.enable_level  # en field XNOR enable level


@static_component
class I2cSwitch(Component):
    """
    Baseclass for all I2C switch components. All child classes must:
        * Specify num_channels class attribute

        * Implement all abstract functions

            * construct_channels must create dataclasses and add them to the container

        * Create child channel dataclass if necessary

            * If Using base dataclass, component must have a register map with enable fields for each channel
    """

    num_channels: int = 0  # Total number of channels that this switch has
    """Total number of channels that this switch has"""
    valid_channel_map: Dict[int, I2CSwitchChannel] = {}  # Maps valid channel numbers to their resp. dataclasses
    """Maps valid channel numbers to their resp. dataclasses"""
    valid_channels: List[int] = TsoField(ftype=list, required=False, desc='List of all channels that are being used in '
                                                                          'the System. If no list is given, all '
                                                                          'channels will be considered valid')
    """List of all channels that are being used in the System. If no list is given, all channels will be considered
    valid'"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Init valid channels
        if self.valid_channels is None:
            self.valid_channels = list(range(self.num_channels))
        self.channels = TsoContainer(ref_name="channels", container=self, resource_type=I2CSwitchChannel)

    @abstractmethod
    def construct_channels(self):
        """
        Builds I2CSwitchChannel attributes and adds them to the TsoContainer 'channels'. For example:

        **self.channels['CH1']** = I2CSwitchChannel(ch_num=1, _enable_field=self.CONTROL.CONTROL.CH1_EN)

        **self.channels['CH2']** = I2CSwitchChannel(ch_num=2, _enable_field=self.CONTROL.CONTROL.CH2_EN)

        :return: None
        :rtype: None
        """

    def post_construction(self):
        """
        Builds the channel map if channel.ch_num in valid_channel values.

        :return: Builds channel map.
        """
        self.construct_channels()
        # Build valid channel map
        for channel in self.channels.values():
            if channel.ch_num in self.valid_channels:  # Add this channel to the map
                self.valid_channel_map[channel.ch_num] = channel
        super().post_construction()

    def _check_channel_valid(self, channel: Union[I2CSwitchChannel, int]):
        """
        Checks if the specified channel is a valid I2C Switch channel value and type.

        :param channel: Specified channel.
        :return: If valid return None, if not valid returns ValueError.
        """
        if type(channel) is int:
            if channel not in self.valid_channels:
                raise ValueError(f"Channel num '{channel}' is not valid. "
                                 f"Valid channels are {self.valid_channels}")

        elif isinstance(channel, I2CSwitchChannel):
            if channel.ch_num not in self.valid_channel_map.keys():
                raise ValueError(f"Channel '{channel}' is not valid. "
                                 f"Valid channels are {list(self.valid_channel_map.values())}")

    @abstractmethod
    def enable_channels(self, *channels: Union[I2CSwitchChannel, int]):
        """
        Enables all channels given as arguments. Will not affect unspecified channels. Raises ValueError if
        any given channel is not valid.

        :param channels: Channels to enable
        :type channels: I2CSwitchChannel | int
        :return: None
        :rtype: None
        """

    @abstractmethod
    def disable_channels(self, *channels: Union[I2CSwitchChannel, int]):
        """
        Disables all channels given as arguments. Will not affect unspecified channels. Raises ValueError if
        any given channel is not valid.

        :param channels: Channels to disable
        :type channels: I2CSwitchChannel | int
        :return: None
        :rtype: None
        """

    @abstractmethod
    def get_enabled_channels(self) -> List[I2CSwitchChannel]:
        """
        Reads device and returns a list of all channel objects that are currently enabled.

        :return: List of I2CSwitchChannel objects
        :rtype: list
        """

    @abstractmethod
    def get_disabled_channels(self) -> List[I2CSwitchChannel]:
        """
        Reads device and returns a list of all channel objects that are currently disabled.

        :return: List of I2CSwitchChannel objects
        :rtype: list
        """

    @abstractmethod
    def enable_all_channels(self):
        """
        Writes to device and sets all valid channels to the enabled state

        :return: None
        :rtype: None
        """

    @abstractmethod
    def disable_all_channels(self):
        """
        Writes to device and sets all valid channels to the disabled state

        :return: None
        :rtype: None
        """

    @abstractmethod
    def mux_channel(self, channel: Union[I2CSwitchChannel, int]):
        """
        Enables specified channel and that channel only. All other channels will be disabled.

        :param channel: Channel to select
        :type channel: I2CSwitchChannel | int
        :return: None
        :rtype: None
        """
