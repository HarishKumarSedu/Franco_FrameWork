from abc import abstractmethod
from cl_test_station.test_station_object import TestStationObject, TsoField
from cl_test_station.register_map.block import Block


class AdcChannelBase(TestStationObject):
    """Base class for ADC channels"""

    block: Block = TsoField(ftype=str, required=True, desc='Block containing registers that control the ADC channel.')

    _on_values = ('ON', 'on', True, 1, '1')
    _off_values = ('OFF', 'off', False, 0, '0')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.ch_block = None

    def initialize(self, **kwargs):
        super().initialize(**kwargs)
        if self.ref_name == self.block:
            raise ReferenceError('Channel cannot have the same name as its block.')
        self.ch_block = getattr(self.container, self.block)

    @abstractmethod
    def get_adc_values(self) -> dict:
        """
        Triggers a conversion on the ADC channel, returning the digital value and calculated voltage.

        :return: Hex Value from ADC and converted voltage value
        :rtype: dict
        """
        pass

    @abstractmethod
    def read_adc_code(self) -> float:
        """
        Triggers a conversion on the ADC channel, returning the digital value.

        :return: ADC code
        :rtype: float
        """
        pass

    @abstractmethod
    def read_voltage(self) -> float:
        """
        Triggers a conversion on the ADC channel, returning the calculated voltage.

        :return: Voltage value calculated from the ADC code
        :rtype: float
        """
        pass

    def _calc_voltage(self, code: int, gain: int = 1, div: int = 1) -> float:
        """
        Calculate voltage value interpreted from ADC channel code

        :param code: Code on ADC channel output
        :type code: int
        :return: Voltage value
        :rtype: float
        """
        # Vin / Vref =  code / max_code
        return self.container.ref_voltage * (code/self.container.max_code) * (gain / div)
