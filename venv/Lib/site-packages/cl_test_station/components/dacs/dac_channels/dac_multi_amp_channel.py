from typing import Union
from cl_test_station.components.dacs.dac_channels.dac_channel_base import DacChannelBase
from cl_test_station.test_station_object import TsoField
from typing import Union


class MultiAmpChannel(DacChannelBase):
    """**Class for dac channel with multiple op amps attached**"""

    enable_fields: list = TsoField(ftype=list, required=True, desc='List containing op amps\'s enable/disable fields')

    def post_construct_system(self, **kwargs):
        super().post_construct_system(**kwargs)

    def initialize(self, **kwargs):
        """
        PLACE HOLDER

        :param kwargs:
        :return:
        """
        super().initialize(**kwargs)
        field_obj_str = self.enable_fields  # Put string into temp variable
        enable_fields = []  # Point enable_fields to blank list to "refresh" it
        for field in field_obj_str:
            if isinstance(field, str):  # Resolve on only first initialization
                enable_fields.append(self.resolve_path(field))
        # Verify every field is from the same component
        components = []
        if not all(field.container.container.container == self.enable_fields[0].container.container.container
                   for field in self.enable_fields):
            raise Warning(f'{self} in {self.container}, '
                          f'signals to power on/off op amps do not come from same component. Will cause delay '
                          f'between powering on/off op amps.')
        # Verify every field is from the same register
        regs = []
        if not all(field.container == self.enable_fields[0].container for field in self.enable_fields):
            raise Warning(f'{self} in {self.container},'
                          f' signals to power on/off op amps do not come from same register. Will cause delay '
                          f'between powering on/off op amps.')
        self.fpga = self.enable_fields[0].container.container.container  # Find FPGA fields belong to

    def output_state(self, on_off: Union[str, int, bool] = None, zero_volt_out: bool = False, *args, **kwargs):
        """
        Set the output state of the dac channel to 'ON' or 'OFF'.

        Call with no parameters to return state of dac channel

        Ouput voltage is volatile (will not retain previous voltage if turned off)

        :param on_off: Turn dac channel on or off
        :type on_off: str, int, bool
        :param zero_volt_out: Set dac to zero volts but do not disable op amp. Default = False
        :type zero_volt_out: bool
        :return: Current output state
        :rtype: str
        """

        if on_off is None:
            if self.is_enabled():
                return 'ON'
            else:
                return 'OFF'
        elif on_off in ['ON', 'on', True, 1, '1']:
            field_dict = {}
            for field in self.enable_fields:
                field_dict[field] = self.enable_value
            self.fpga.write_fields_optimized(field_dict)
        elif on_off in ['OFF', 'off', False, 0, '0']:
            field_dict = {}
            for field in self.enable_fields:
                field_dict[field] = self.disable_value
            self.source_voltage(0)
            self.fpga.write_fields_optimized(field_dict)

    def is_enabled(self) -> bool:
        """
        Check to see if Dac channel's op amps are enabled/disabled

        :return: None
        :rtype: None
        """
        # Verify all channels are the same value
        if not all(field.value == self.enable_fields[0].value for field in self.enable_fields):
            raise Warning(f'{self} in {self.container} does not have the same output state for every op amp.')
        # Return state of op amps
        return self.enable_fields[0].value == self.enable_value
