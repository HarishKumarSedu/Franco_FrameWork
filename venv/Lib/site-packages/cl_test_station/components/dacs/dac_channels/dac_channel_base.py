from abc import abstractmethod
from typing import Union
from cl_test_station.test_station_object import TestStationObject, TsoField
from cl_test_station.register_map.block import Block


class DacChannelBase(TestStationObject):
    """**Abstract class for DAC channels**"""

    block: Block = TsoField(ftype=str, required=True, desc='Block containing registers that control DAC channel.')
    disable_wait: float = TsoField(ftype=float, required=False, default=0,
                                   desc='Wait time between between setting zero volts and disabling OP AMP output')
    enable_value: int = TsoField(ftype=int, required=False, default=1,
                                 desc='Value written to enable OP AMP output of the DAC channel.')
    amp_gain: float = TsoField(ftype=float, required=False, default=1, desc='Gain from the op amp attached to DAC channel.'
                                                                        'Defaults to 1 if not defined.')
    amp_offset: float = TsoField(ftype=float, required=False, default=0, desc='Offset from the op amp attached to DAC channel.'
                                                                        'Defaults to 0 if not defined.')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.disable_value = 1 - self.enable_value
        self.ch_block = None

    def initialize(self, **kwargs):
        """
        Initialize Dac Channel Base class.

        :return: None
        :rtype: None
        """
        super().initialize(**kwargs)
        if self.ref_name == self.block:
            raise ReferenceError('Channel cannot have the same name as its block.')
        self.ch_block = getattr(self.container, str(self.block))

    @abstractmethod
    def source_voltage(self, voltage: Union[int, float] = None, *args, **kwargs):
        """
        Write and update DAC channel with voltage parameter

        :param voltage: voltage to set DAC channel
        :type voltage: float
        :return: voltage and code in dictionary
        :rtype: dict[code, voltage]
        """

    @abstractmethod
    def set_next_voltage(self, voltage: Union[int, float] = None, *args, **kwargs):
        """
        Write but not update DAC channel with voltage parameter

        :param voltage: voltage to write to DAC channel
        :type voltage: float
        :return: code and voltage in dict that DAC channel is currently set to
        :rtype: dict[code, voltage]
        """

    @abstractmethod
    def set_code(self, code: int = None) -> int:
        """
        Directly set code of DAC channel output. Will automatically update channel with code.

        :param code: Code to set output of DAC channel to.
        :type code: int
        :return: Current code on DAC's output.
        :rtype: int
        """

    @abstractmethod
    def output_state(self, on_off: Union[str, int, bool] = None, zero_volt_out: bool = False, *args, **kwargs):
        """
        Set the output state of the DAC channel to 'ON' or 'OFF'.

        Call with no parameters to return state of DAC channel.

        Output voltage is volatile (will not retain previous voltage if turned of)f.

        :param on_off: Turn DAC channel on or off.
        :type on_off: str, int, bool
        :param zero_volt_out: Set DAC to zero volts but do not disable op amp. Default = False
        :type zero_volt_out: bool
        :return: Current output state.
        :rtype: str
        """

    def _calc_code(self, voltage: float, dac_gain: int = 1, div: int = 1) -> int:
        """
        Calculate code from desired output voltage on DAC channel.

        :param voltage: Voltage to be turned into code
        :type voltage: float
        :param dac_gain: Gain of the DAC channel's internal op-amp. Not available on every DAC device. (Default: 1)
        :type dac_gain: int
        :param div: Divide voltage reference by this number (Default: 1)
        :type div: int
        :return: Code value for DAC channel
        :rtype: int
        """
        target_dac_voltage = voltage - self.amp_offset
        if target_dac_voltage < 0:
            self.log.warning(f'Channel {self.ref_name} of {self.container.ref_name} cannot be set to {voltage}V\n'
                             f'since the offset voltage is {self.amp_offset}V, the DAC output target is '
                             f'{target_dac_voltage}, which is outside the valid range of the DAC.\n'
                             f'Setting DAC target voltage to 0V\n')
            target_dac_voltage = 0
        code = round(target_dac_voltage / self.container.ref_voltage * self.container._codes / (dac_gain * self.amp_gain * div))
        if code > self.container.max_code:
            self.log.warning(f'Channel {self.ref_name} of {self.container.ref_name} cannot be set to {voltage}V\n'
                             f'since the ref voltage is {self.container.ref_voltage}V. '
                             f'Setting to maximum voltage {self._calc_voltage(self.container.max_code)}V.')
            code = self.container.max_code
        return code

    def _calc_voltage(self, code: int, dac_gain: int = 1, div: int = 1) -> float:
        """
        Calculate voltage value interpreted from DAC channel code

        :param code: Code on DAC channel output
        :type code: int
        :param dac_gain: Gain of the DAC channel's internal op-amp. Not available on every DAC device. (Default: 1)
        :type dac_gain: int
        :param div: Divide voltage reference by this number. (Default: 1)
        :type div: int
        :return: Voltage value
        :rtype: float
        """
        return code / self.container._codes * self.container.ref_voltage * dac_gain * self.amp_gain / div + self.amp_offset

    def get_mro(self):
        """
        Match power supply channel get_mro function.

        :return: List[str] List containing its class name and the class names of all of its parent classes
        """
        return [c.__name__ for c in self.__class__.__mro__ if c is not object]
