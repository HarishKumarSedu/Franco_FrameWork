"""
Module for SPMI Dut baseclass.
Author: Evan Canter <evan.canter@cirrus.com>
"""
import inspect
import json
import re
from functools import wraps
from typing import Any, Callable, List

import cl_test_station.utilities.parsing as parsing
from cl_test_station.components.dut.dut import Dut
from cl_test_station.components.dut.spmi_peripheral_dut.blocks.spmi_peripheral.spmi_peripheral import SpmiPeripheral
from cl_test_station.interfaces.spmi_interface import SpmiInterface
from cl_test_station.test_station_object import TsoField


def bypass_write_verification(func: Callable) -> Callable:
    """
    Function wrapper that disables write verification, runs wrapped function, then restores original verification state.
    This wrapper is only intended for use on component class methods, and will not work for any other TestStationObject.

    :param func: Function to wrap
    :type func: Callable
    :return: Wrapped function
    :rtype: Callable
    """
    @wraps(func)
    def inner(self, *args, **kwargs) -> Any:
        """
        Wrap function. Disables verification, calls original function (passing in all parameters), then restores state.

        :param self: Component reference
        :type self: Component
        :return: Result of original function
        :rtype: Any
        """
        save = self.verify_writes  # Save prev value
        self.verify_writes = False  # Don't verify any writes
        result = func(self, *args, **kwargs)  # Call original function
        self.verify_writes = save  # Restore value
        return result
    return inner


class SpmiPeripheralDut(Dut):
    """Baseclass for all Duts with SPMI functionality. Handles RCS interrupts and 24 bit pointer access."""

    interrupt_group_map: dict = TsoField(ftype=dict, required=True,
                                         desc='Dictionary where the keys are the SPMI interrupt code, and the values '
                                              'are the SPMI interrupt group names. eg. {0x00: "SYSCTL_GROUP", ...})')

    spmi_interface: SpmiInterface = TsoField(ftype=str, required=False,
                                             desc='ref_name of the spmi interface under this component. If None is '
                                                  'specified, it will find the first instance of an SpmiInterface '
                                                  'and use that')

    spmi_block: SpmiPeripheral = TsoField(ftype=str, required=False,
                                          desc='Name of SPMI block as it is defined in the block_config. If None is '
                                               'specified, it will find an instance of SpmiPeripheral in self.blocks')

    def __init__(self, *args, **kwargs):
        self.handling_active = False
        super().__init__(*args, **kwargs)

    def post_construct_system(self, *args, **kwargs):
        """
        Links SPMI interface if one was given or looks for an instance of one within its resources. Checks to make sure
        linked host controller is an Audiohub, since many features are only available using an AH.

        :return: None
        :rtype: None
        """
        super().post_construct_system(*args, **kwargs)
        if not self.spmi_interface:  # Need to find one in resources
            for resource in self.resources.values():
                if isinstance(resource, SpmiInterface):
                    self.spmi_interface = resource
                    break
            else:
                self.log.warning(f"No SPMI interface is defined under {self.ref_name}, all SPMI functionality will be unavailable")

        if 'AudioHubController' not in self.active_controller.class_type:
            cls_name = self.active_controller.class_type.rpartition('.')[2]
            self.log.warning(f"Active controller is type {cls_name}. AudioHub is required for embedded interrupt handling")

    def construct_registers(self):
        """
        Constructs registers, then links SPMI peripheral block if one was given or searches for an instance of
        SpmiPeripheral.

        :return: None
        :rtype: None
        """
        super().construct_registers()  # Create all blocks
        if not self.spmi_block:
            for block in self.blocks.values():
                if isinstance(block, SpmiPeripheral):
                    self.spmi_block = block
                    break
            else:
                self.log.warning("No block of type SpmiPeripheral found - SPMI 24 bit access will be unavailable")
        elif type(self.spmi_block) is str:  # Grab this block
            try:
                self.spmi_block = self.__getattribute__(self.spmi_block)
            except AttributeError:
                self.log.warning(f"{self.ref_name} has no block '{self.spmi_block}'. Verify spmi_block value matches name in block_config.")

    @bypass_write_verification
    def spmi_24_bit_read(self, address: int, word_count: int, pointer: int = 0) -> List[int]:
        """
        Performs read using pointers

        :param address: Register address to be written to the pointer base address
        :type address: int
        :param word_count: Number of words to read from the data buffer
        :type word_count: int
        :param pointer: Pointer to use
        :type pointer: int
        :return: Words read from data buffer
        :rtype: List[int]
        """
        # Write address to BASE
        self.spmi_block.pointers[pointer]['base_addr'].value = address
        # Reset pointer
        self.spmi_block.pointers[pointer]['reset'].value = 1
        ptr_data0 = self.spmi_block.pointers[pointer]['data'][0].addr
        num_16byte_words = word_count & ~0x3  # Get number of words to read with 16byte chunks
        remaining_words = word_count & 0x3  # Number of remaining words after 16 byte chunks
        words_in = self.spmi_interface.chain_read(self.active_controller, reg_addr=ptr_data0, word_count=num_16byte_words, read_size=16)
        if remaining_words:
            words_in.extend(self.spmi_interface.spmi_extended_register_read(address=ptr_data0, word_count=remaining_words))
        return words_in

    @bypass_write_verification
    def spmi_24_bit_write(self, address:int, write_data: List[int], pointer: int = 0):
        """
        Performs write using pointers

        :param address: Register address to be written to the pointer base address
        :type address: int
        :param write_data: Words to write to the data buffer
        :type write_data: List[int]
        :param pointer: Pointer to use
        :type pointer: int
        :return: None
        :rtype: None
        """
        # Write address to BASE
        self.spmi_block.pointers[pointer]['base_addr'].value = address
        # Reset pointer
        self.spmi_block.pointers[pointer]['reset'].value = 1
        ptr_data0 = self.spmi_block.pointers[pointer]['data'][0].addr
        cutoff_16byte = (len(write_data) & ~0x3)  # Get index of 16byte aligned chunks of data list
        n = self.spmi_interface.write_reg_data_size
        # for chunk in [write_data[i:i+n] for i in range(0, cutoff_16byte, n)]:
        #     self.spmi_interface.spmi_extended_register_write(address=ptr_data0, write_data=chunk)
        self.spmi_interface.chain_write(self.active_controller, reg_addr=ptr_data0, write_data=write_data[:cutoff_16byte], write_size=16)
        if len(write_data) & 0x3:  # Need to write remaining words
            self.spmi_interface.spmi_extended_register_write(address=ptr_data0, write_data=write_data[cutoff_16byte:])

    def start_embedded_interrupt_handling(self, handler, verbose=True, um_results=None):
        """
        Starts interrupt thread and parses functions in handler. Any that match the rcs group mapping get
        added to the control server.

        :param handler: Object that contains interrupt handlers that adhere to the group map
        :param verbose: Flag indicating whether console prints from the host get relayed back to the client
        :return: None
        """
        self.stop_embedded_interrupt_handling()
        if not self.host_controller.ping_test_station() == 'success':  # Need to embed station
            self.embed_test_station()

        self.int_handlers = {}
        for name, value in inspect.getmembers(handler):  # Looking for defined handlers for interrupts
            if inspect.ismethod(value) and name.replace('_handler', '').upper() in self.rcs_group_map.values():
                func_name = name.replace('_handler', '').lower() + '_handler'

                if not str(inspect.signature(value)) == '()':
                    raise Exception("In line handlers cannot have any parameters")

                # This is an interrupt handler we want, get source code and aliases
                lines, attributes = parsing.parse_code_block(inspect.getsourcelines(value)[0])
                variables, aliases = parsing.parse_station_attributes(handler, self.find_top_level(), attributes)
                func_config = {'code': '\n'.join(lines), 'aliases': aliases, 'static_variables': variables}
                self.int_handlers[func_name] = func_config
        functions_str = json.dumps(self.int_handlers)
        self.host_controller.start_embedded_interrupt_handling(self.rcs_group_map, verbose=verbose, functions=functions_str)
        self.handling_active = True
        self.result = um_results

    def pop_interrupt_queue(self, timeout=0, um_results_class=None):
        """
        Attempts to pop a single result dictionary from the host interrupt queue. Raises exceptions and prints console
        output if necessary. Option to pass in TestResults instance to add handler side result assertions

        :param timeout: max wait time for polling queue, default is no wait (throw exception is data not immediately
            ready)
        :param um_results_class: reference to instance of TestResults class. Necessary if there are any result calls in
            handler.
        :return: Reduced dictionary containing ID, GROUP_NAME, and any custom Data
        """
        result_dict = self.host_controller.pop_interrupt_queue(timeout)

        if result_dict == 'EMPTY':
            raise Exception("Interrupt queue is empty")

        # Handle exceptions, try to create more detailed traceback if possible
        if 'EXCEPTION' in result_dict.keys():
            trace = result_dict["EXCEPTION"]
            try:
                method_name = result_dict['GROUP_NAME'].lower()+'_handler'
                groups = re.search(r'\n\s*(File "%s", line (\d+).*\n.*)' % method_name, trace).groups()
                block = groups[0]
                line_num = int(groups[1])
                new_block = 'Function "%s", line %d, in %s\n    %s' % (method_name, line_num, 'Interrupt Handler',
                                                    self.int_handlers[method_name]['code'].split('\n')[line_num-1])
                trace = trace.replace(block, new_block)
            except: pass
            c = "\033[91m"
            self.log.print(c +' EMBEDDED EXCEPTION '.center(150, '='))
            self.log.print(c + trace)
            self.log.print(c + ' EMBEDDED EXCEPTION '.center(150, '=') + "\033[0m")
            raise Exception("Server side exception: See traceback")

        # Print console output (enabled with verbose flag)
        handler = result_dict['GROUP_NAME'].lower()+'_handler'
        if result_dict['CONSOLE_LOG'].strip():
            self.log.print("\033[94m[%s]" % handler)
            for line in result_dict['CONSOLE_LOG'].split('\n'):
                if line.strip():
                    self.log.print("\033[94m> " + line + '\033[0m')

        # Transfer TestResult Calls
        if self.result is not None and len(result_dict['result_calls']) > 0:
            for call in result_dict.pop('result_calls'):
                self.result.__getattribute__(call['method'])(*call['args'])

        data = result_dict.pop('DATA')
        result_dict.update(data)
        return result_dict

    def interrupt_queue_empty(self) -> bool:
        """
        Checks if host interrupt queue is empty

        :return: True if empty, False otherwise
        """
        return self.host_controller.interrupt_queue_empty()

    def stop_embedded_interrupt_handling(self):
        """
        Empties interrupt queue and halts handling thread on the control server

        :return: None
        :rtype: None
        """
        self.result = None
        self.host_controller.empty_server_queue()
        self.host_controller.stop_embedded_interrupt_handling()


# unit test
if __name__ == "__main__":
    pass
