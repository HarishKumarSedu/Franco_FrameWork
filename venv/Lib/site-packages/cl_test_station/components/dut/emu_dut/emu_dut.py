import os, sys, re, inspect
from cl_test_station.components.dut.dut import Dut
from cl_test_station.components.fpga.fpga import Fpga
from cl_test_station.components.component.component import full_attribute_access, GetRevisionError
from cl_test_station.components.fpga.emu_wrapper.emu_wrapper import EmuWrapper
from cl_test_station.utilities.reusables import get_revision_file, revision_to_hex_str
from cl_test_station.test_station_object import TsoField


class LinkedWrapperError(Exception):
    pass


class EmuDut(Dut, Fpga):
    """PLACE HOLDER"""
    linked_wrapper: EmuWrapper = TsoField(ftype=str, desc='TestStation path to the EmuWrapper, eg. '
                                                          'eeb.dut_dc.emu_wrapper')
    """TestStation path to the EmuWrapper, eg. eeb.dut_dc.emu_wrapper"""

    def __init__(self, *args, **kwargs):
        self.__wrap_revision_override = None
        super().__init__(*args, **kwargs)
        if self.revision_override:  # Full revision 'eXXXX_XXXX' was given in YAML
            self.__wrap_revision_override = self.revision_override  # Wrapper revision is full one
            self.revision_override = self.__format_revision(self.revision_override)  # Revision is just C4 edition

    def get_revision(self) -> str:
        """
        Returns the C4 edition read from the emu wrapper

        :return: C4 edition, zero filled to length 4. Returns empty string if ohst controller not connected
        :rtype: str
        """
        if self.active_controller.isConnected():
            return revision_to_hex_str(self.linked_wrapper.get_c4_edition(), length=4)
        else:
            self.log.warning("%s is not connected, cannot read revision registers" % self.active_controller.ref_name)
            return ''

    def configure(self, config, *args, **kwargs):
        super().configure(config)
        # Resolve linked wrapper, replace name with reference
        if type(self.linked_wrapper) is str:
            wrapper_path = self.linked_wrapper
            self.linked_wrapper = self.resolve_path(wrapper_path)
            if self.linked_wrapper is None:
                wrappers = self.container.find_all(EmuWrapper)
                if not wrappers:
                    raise LinkedWrapperError("No EmuWrappers found under %s, cannot create link to %s"
                                             % (self.container.ref_name, wrapper_path))
                wrappers = ['.'.join(w.split('.')[1:]) for (w, _) in wrappers]  # Get just ts_path, not reference Tuple
                raise LinkedWrapperError("Could not find EmuWrapper %s. Did you mean %s?"
                                         % (wrapper_path, ', '.join(wrappers)))

    def __format_revision(self, revision:str) -> str:
        """
        Grabs c4 edition from linked wrapper's revision
        eg. revision = '1234_0001' will return '1234'

        :param revision: raw revision string
        :type revision: str
        :return: formatted revision string containing C4 edition
        :rtype: str
        """
        return re.search(r'[0-9]+', revision).group(0)

    @full_attribute_access
    def construct_registers(self):
        """
        Uses revision from linked wrapper to download register map file. Then calls component construct_objects to
        build block/register/field objects

        :return: None
        :rtype: None
        """
        request_url = self.linked_wrapper.request_url  # Grabbing request url here assumes wrapper already formatted it
        if self.__wrap_revision_override:
            revision = self.__wrap_revision_override
        else:
            try:
                revision = self.linked_wrapper.get_revision()  # This is full revision e{C4}_{BuildCnt}
            except Exception as revision_err:
                raise GetRevisionError("Could not grab revision") from revision_err
        super().construct_registers(request_url=request_url, revision=revision, rev_formatter=self.__format_revision)

    def initialize(self, **kwargs):
        super().initialize(**kwargs)

    def shutdown(self, **kwargs):
        super().shutdown(**kwargs)
