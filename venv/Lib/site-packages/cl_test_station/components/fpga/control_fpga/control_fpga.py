from cl_test_station.components.fpga.fpga import Fpga
from cl_test_station.test_station_object import TsoField
from cl_test_station.components.component.component import full_attribute_access
from cl_test_station.utilities.reusables import revision_to_hex_str, format_request_url


class ControlFpga(Fpga):
    """**Place holder**"""

    c4_reg_addr: int = TsoField(ftype=int, default=0, desc="Address of register containing C4 edition.")

    build_cnt_addr: int = TsoField(ftype=int, default=0, desc="Address of register containing build count.")

    c4_edition_offset: int = TsoField(ftype=int, required=False, default=0, desc="Bit offset of the C4 edition field")

    c4_edition_bitwidth: int = TsoField(ftype=int, required=False, default=16, desc="Bit width of the C4 edition field")

    build_count_offset: int = TsoField(ftype=int, required=False, default=0, desc="Bit offset of the build count field")

    build_count_bitwidth: int = TsoField(ftype=int, required=False, default=16, desc="Bit width of the build count "
                                                                                     "field")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def initialize(self, **kwargs):
        super().initialize(**kwargs)

    def shutdown(self, **kwargs):
        super().shutdown(**kwargs)

    def get_revision(self) -> str:
        """
        Returns revision in form: {major rev}_{minor_rev}, where both the major and minor revisions are hex,
        zero-filled to length 4

        :return: Revision
        :rtype: str
        """
        if self.active_controller.isConnected():  # Can read the registers
            c4_edition = revision_to_hex_str(self.get_c4_edition(), length=4)
            build_count = revision_to_hex_str(self.get_build_count(), length=4)
            return '%s_%s' % (c4_edition, build_count)
        else:  # Return empty string since the registers can't be read
            self.log.warning('Cannot get revision, %s is not connected' % self.active_controller.ref_name)
            return ''

    def get_c4_edition(self):
        """
        Reads register at address 'c4_reg_addr' and returns value of the C4 Edition field

        :return: C4 edition field value
        :rtype: int
        """
        c4_reg_value = self.read_register(self.c4_reg_addr)             # Get raw register value
        mask = 2 ** self.c4_edition_bitwidth - 1                        # Create mask
        c4_edition = (c4_reg_value >> self.c4_edition_offset) & mask    # Shift and mask c4 edition field
        return c4_edition

    def get_build_count(self):
        """
        Reads register at address 'build_cnt_addr' and returns value of the C4 Edition field

        :return: C4 edition field value
        :rtype: int
        """
        build_count_reg_value = self.read_register(self.build_cnt_addr)             # Get raw register value
        mask = 2 ** self.build_count_bitwidth - 1                                   # Create mask
        build_count = (build_count_reg_value >> self.build_count_offset) & mask     # Shift and mask c4 edition field
        return build_count

    @full_attribute_access
    def construct_registers(self):
        """
        Uses revision from c4 and build_cnt registers to download register map file. Then calls component
        construct_objects to build block/register/field objects

        :return: None
        :rtype: None
        """
        if self.request_url is not None:
            self.request_url = format_request_url(self.request_url)  # Remove test or release from path
        super().construct_registers(request_url=self.request_url)

    def _get_image_name(self, *args):
        """
        Based on programming_method, provide the image file name

        :return: file_name
        :rtype: str
        """
        if self.programming_method == 'cldbprog':
            file_name = self.image_file_name + '.mcs'
        else:
            file_name = self.image_file_name + '.bit'
        return file_name
