import os
import re
import sys
import inspect
import zipfile
import glob
import stat
import shutil
from enum import Enum
from typing import Callable
from cl_test_station.components.component.component import Component, FileDownloadError, GetRevisionError
from cl_test_station.test_station_object import TsoField
from cl_test_station.interfaces.ctrl_interface import CtrlInterfaceError
from cl_test_station.utilities.reusables import get_revision_file, format_request_url
from program_fpga.FpgaProgrammer import FpgaProgrammer, FpgaProgramError


class FpgaProgramModes(Enum):
    HARDWARE = 'HW'
    FIRMWARE = 'FW'


class Fpga(Component):
    request_url: str = TsoField(ftype=str, required=False,
                                desc="Crystal URL to directory containing 'release' or 'test' sub-directories, eg. "
                                     "http://crystal.cirrus.com/~<project>/trunk/emulation/")
    """Crystal URL to directory containing 'release' or 'test' sub-directories,
    eg. http://crystal.cirrus.com/~<project>/trunk/emulation/"""

    regmap_auto_select: bool = TsoField(ftype=bool, required=False, default=True,
                                        desc="Flag for selecting regmap file based on revision.")
    """Flag for selecting regmap file based on revision."""

    programming_method: str = TsoField(ftype=str, required=False,
                                       desc="Required when fpga_auto_program is True. Selects which tool to use to "
                                            "program FPGA. Currently supported options are: 'jtag', 'cldbprog'")

    """Required when fpga_auto_program is True. Selects which tool to use to program FPGA.
    Currently supported options are: 'jtag', 'cldbprog'"""

    fpga_program_mode: FpgaProgramModes = TsoField(ftype=str, required=False, default=FpgaProgramModes.HARDWARE,
                                                   cast_type=FpgaProgramModes,
                                                   desc="Required when programming the FPGA with FW images. HW=program "
                                                        "the FPGA with DUT images, FW=program the FPGA with FW images")

    """Required when programming the FPGA with FW images. HW=program the FPGA with DUT images,
    FW=program the FPGA with FW images"""

    fw_image_url: str = TsoField(ftype=str, required=False,
                                 desc="Required when fpga_program_mode is FW. Artifactory URL eg. "
                                      "https://aus-art-prod-01.ad.cirrus.com/artifactory/<project>_Local/a0/nightly")
    """Required when fpga_program_mode is FW. Artifactory URL
    eg. https://aus-art-prod-01.ad.cirrus.com/artifactory/<project>_Local/a0/nightly"""

    art_user_name: str = TsoField(ftype=str, required=False,
                                  desc="Required when fpga_program_mode is FW. "
                                       "Artifactory user name for authentication.")
    """Required when fpga_program_mode is FW. Artifactory user name for authentication."""

    art_user_key: str = TsoField(ftype=str, required=False,
                                 desc="Required when fpga_program_mode is FW. Artifactory user key for authentication.")
    """Required when fpga_program_mode is FW. Artifactory user key for authentication."""

    fw_image_suffix: str = TsoField(ftype=str, required=False,
                                    desc="Required when fpga_program_mode is FW. Image file name suffix.")
    """Required when fpga_program_mode is FW. Image file name suffix."""

    def __init__(self, *args, **kwargs):
        # Init attributes
        self.reg_url = []
        # Pull in attributes from YAML
        super().__init__(*args, **kwargs)

    def configure(self, config, *args, **kwargs):
        super().configure(config, *args, **kwargs)

    def initialize(self, **kwargs):
        super().initialize(**kwargs)

    def shutdown(self, **kwargs):
        super().shutdown(**kwargs)

    def construct_registers(self, request_url: str = '', revision: str = '', rev_formatter: Callable = None):
        """
        Builds registers either from local file or downloaded regamp based on revision.

        :param request_url: Base url where the regmap file is located

            **NOTE:** Do not include 'test' or 'release' directories in crystal URLs
        :type request_url: str
        :param revision: revision of component, dictates file name of regmap
        :type revision: str
        :param rev_formatter: Function that formats the revision to form only containing digits and '_'

            **Example:** A formatter would take in 'e1234_0001' and return '1234_0001'
        :type rev_formatter: Callable
        :return: None
        """
        if not request_url:  # None supplied, use attribute
            request_url = self.request_url
        regmap_base_path = os.path.join(self.register_map_path, self.register_map_name)  # Base register filename
        # No auto select - Search for exact file from YAML fields - no revision appended
        if not self.regmap_auto_select:
            if not os.path.isfile(regmap_base_path):
                raise FileNotFoundError(
                    "No register map found, either manually download %s or enable regmap_auto_select: %s"
                    % (os.path.basename(regmap_base_path), regmap_base_path))
            self.log.info("Using explicit register map %s" % self.register_map_name)
            self.__construct_regmap(regmap_base_path)
        # # Auto select - use regmap based on revision # #
        else:
            # Get the revision of the part
            if not revision:  # No rev specified, need to grab from the component
                # Check host controller connection
                if not self.active_controller.isConnected() and not self.revision_override:
                    raise ConnectionError("Could not update %s registers, %s not connected" %
                                          (self.ref_name, self.active_controller.ref_name))
                # Try to read revision off of the component
                try:
                    revision = getattr(self, '_Component__get_revision')()
                    self.log.debug("get_revision returned '%s'" % revision)
                except Exception as revision_err:
                    raise GetRevisionError("Could not grab revision") from revision_err
            else:
                self.log.debug("Using revision '%s'" % revision)
            # # Format revision for comparison # #
            f_revision = rev_formatter(revision) if rev_formatter else revision
            # # Use revision to find or download correct register map # #
            basename = os.path.splitext(self.register_map_name)[0]  # File name no extension
            regmap_file_versioned = regmap_base_path.replace(basename, basename + '_' + f_revision)  # New filename
            # 1. Check if version file already exists locally
            if os.path.isfile(regmap_file_versioned):
                self.log.info("Loading local register map: %s" % os.path.basename(regmap_file_versioned))
                self.__construct_regmap(regmap_file_versioned)
            else:
                # 2. If it doesn't exist, try to download it
                if request_url:
                    if self.__download_regmap(request_url, self.register_map_name, revision, regmap_file_versioned):
                        self.log.info(
                            "Downloaded %s as %s" % (self.register_map_name, os.path.basename(regmap_file_versioned)))
                        self.__construct_regmap(regmap_file_versioned)
                        return
                    # 3. Download failed, look for close match
                    else:
                        raise FileDownloadError("Download of %s failed." % self.register_map_name)
                else:
                    raise AttributeError(
                        f"No request url was specified and {regmap_file_versioned} does not exist locally.")

    def download_artifact(self, dload_path: str = None, dir: str = None, request_url: str = None):
        """
        Download fpga artifact from given directory.

            If no request_url is given, it will default to request_url (defined in the yaml file) + revision
            (read off from the hardware), otherwise will throw error.

        :param dload_path: Local path to save artifact to.
        :type dload_path: str
        :param dir: Directory to store downloaded artifact. If not specified, this method will create
            a directory called 'full_artifact' and store it there.
        :type dir: str
        :param request_url: Base url to search through. eg crystal.cirrus.com/~project/trunk/emulation
        :type request_url: str
        :return: dload_path
        :rtype: str
        """
        import requests
        from bs4 import BeautifulSoup
        if dload_path is None:  # Get dload path
            dload_path = os.path.join(os.path.dirname(inspect.getfile(self.__class__)), 'fpga_images')
        if dir is None:  # Get dir
            dir = 'full_artifact'
            if not os.path.isdir(os.path.join(dload_path, dir)):
                os.mkdir(os.path.join(dload_path, dir))
            else:
                self._clear_dir(os.path.join(dload_path, dir))  # Clear directory
        dload_path = os.path.join(dload_path, dir)
        if request_url is None:  # Get request url
            revision = 'e'
            try:
                revision += self.get_revision()
            except CtrlInterfaceError:
                self.log.info("%s has no image loaded yet" % self.ref_name)
            req_url = format_request_url(self.request_url)
            search_dir = ['test', 'release']
            for dir in search_dir:
                req_url_temp = f"{req_url}{dir}/{revision}/"
                if requests.get(req_url_temp).status_code == 200:
                    request_url = req_url_temp
                else:
                    self.log.error("%s url doesn't exist" % req_url_temp)
        if requests.get(request_url).status_code != 200:  # Make sure directory is good
            raise ConnectionError(f'Bad request to url {request_url}')
        r = requests.get(request_url)
        soup = BeautifulSoup(r.text, 'html.parser')
        for link in soup.find_all('a'):  # Find all links on HTML page
            link = link.get('href')  # Get link name
            r_temp = requests.get(request_url + link)
            if r_temp.status_code == 200 and not link.startswith('?'):
                if link.endswith('/'):  # Subdirectory
                    os.mkdir(os.path.join(dload_path, link))
                    self.download_artifact(dload_path, link, os.path.join(request_url, link))
                else:  # File
                    os.chmod(dload_path, stat.S_IWOTH)
                    with open(os.path.join(dload_path, link), 'wb') as f:
                        f.write(r_temp.content)
        return dload_path

    def _clear_dir(self, path: str):
        """
        Clear directory of all contents

        :param path: Path to directory
        :type path: str
        :return: None
        :type return: None
        """

        for f in os.listdir(path):
            if os.path.isdir(os.path.join(path, f)):
                self._clear_dir(os.path.join(path, f))
                os.chmod(os.path.join(path, f), 0o777)
                os.rmdir(os.path.join(path, f))
            else:
                os.remove(os.path.join(path, f))

    def __download_regmap(self, request_url: str, remote_name: str, revision: str, dload_path: str) -> bool:
        """
        Tries to find register map 'remote_name' in the test and release directories for the given revison. Stores
        downloaded map to 'dload_path'

        :param request_url: Base url to serach through. eg crystal.cirrus.com/~project/trunk/emulation
        :type request_url: str
        :param remote_name: Name of the register map
        :type remote_name: str
        :param revision: raw revision of part. eg. e1234_0001
        :type revision: str
        :param dload_path: path to save the file locally
        :type dload_path: str
        :return: True if download was successful, False if not
        :rtype: bool
        """
        #  These imports can't go at top of file until the requests pacakge can be installed on host controllers
        import requests
        search_dir = ['test', 'release']
        for dir in search_dir:
            root_url = request_url + dir + '/e' + revision + '/'
            if self.get_link(root_url, remote_name, self.reg_url):
                r = requests.get(self.reg_url[0])
                if r.status_code == 200:
                    # Verify that directory exists
                    if not os.path.exists(os.path.dirname(dload_path)):
                        # Create all missing directories
                        self.log.info(f"Creating regmap directory: {os.path.dirname(dload_path)}")
                        os.makedirs(os.path.dirname(dload_path))
                    with open(dload_path, 'wb') as f:
                        f.write(r.content)
                    return True
        return False

    def __construct_regmap(self, regmap_path: str):
        """
        Helper function that sets component attributes and constructs objects

        :param regmap_path: Absolute path of register map file
        :type regmap_path: str
        :return: None
        """
        # Re-assign register map attributes to new file
        save1, save2 = self.register_map_path, self.register_map_name
        self.register_map_path = os.path.dirname(regmap_path)
        self.register_map_name = os.path.basename(regmap_path)
        super().construct_registers()
        self.register_map_path, self.register_map_name = save1, save2

    def program_fpga(self, request_version: str, force:bool = False):
        """
        Programs the FPGA based on image version requested and its mode (HW or FW).
        In HW mode (default), before attempting to program the FPGA, checks if the FPGA is already at the requested
        version (read off from the hardware). In both modes checks if the requested version exists in request_url
        (crystal URL for HW) or fw_image_url (artifactory URL for FW).
        If any check fails, skips programming. The requested image version gets downloaded and saved in fpga_images_path
        , which finally be used to program the FPGA.

        :param request_version: requested image version

            **NOTE:** This is the expected request_version format 'eXXXX_XXXX' for HW images
        :type request_version: str
        :param force: forces downloading the image into the fpga
        :type force: bool
        """
        if self.fpga_program_mode is FpgaProgramModes.FIRMWARE:
            self.fpga_images_path = os.path.join(os.path.dirname(inspect.getfile(self.__class__)), 'fpga_fw_images')
        else:
            self.fpga_images_path = os.path.join(os.path.dirname(inspect.getfile(self.__class__)), 'fpga_images')

        # 1. Try Checking if the FPGA is already at the requested version
        try:
            if not force and f"e{self.get_revision()}" == request_version:
                # We are done if it already is (as long as we don't force the image)
                self.log.info(f"{self.ref_name} is already at {request_version}")
                return
        except CtrlInterfaceError:
            self.log.info(f"{self.ref_name} has no image loaded yet")

        # If we make it here, we have to program the FPGA
        # ToDo: format_request_url at init instead
        if self.fpga_program_mode is FpgaProgramModes.FIRMWARE:
            fpga_image_url = format_request_url(self.fw_image_url)  # Append '/' at the end of the url if needed
        else:
            fpga_image_url = format_request_url(self.request_url)  # Remove test or release from url
        # 2. Check if the requested version exists
        version_url = self._get_version_url(fpga_image_url, request_version)  # fpga_image_url/request_version
        if version_url is not None:
            # 3. Download the requested image version and save it in fpga_images_path
            if self.fpga_program_mode is FpgaProgramModes.FIRMWARE:
                image_path = self._download_fw_image(version_url, request_version)  # Image path in system
            else:
                image_path = self._download_image(version_url, request_version)  # Image path in system
            # 4. Program the FPGA with the downloaded image
            self._load_image(image_path)
        else:
            self.log.error(f"{request_version} version doesn't exist")
            raise FpgaProgramError(self.ref_name + ' programming failed')

    def _get_version_url(self, request_url: str, request_version: str):
        """
        Based on the mode, request_url and request_version, provide the
        requested image version url (request_url/request_version)

        :param request_url: formatted request_url or fw_image_url (needs artifactory authentication)
        :type request_url: str
        :param request_version: requested image version
        :type request_version: str
        :return: version_url
        :rtype: str
        """
        #  These imports can't go at top of file until the requests pacakge can be installed on host controllers
        import requests
        version_url = None
        if self.fpga_program_mode is FpgaProgramModes.FIRMWARE:
            root_url = request_url + request_version + '/'
            r = requests.get(root_url, auth=(self.art_user_name, self.art_user_key))
            if r.status_code == 200:
                version_url = root_url
        else:
            # ToDo: make this a reusable search function
            search_dir = ['test', 'release']
            for dir in search_dir:
                root_url = request_url + dir + '/' + request_version + '/'
                r = requests.get(root_url)
                if r.status_code == 200:
                    version_url = root_url
        return version_url

    def _download_image(self, version_url: str, request_version: str):
        """
        Downloads from request_url (HW mode only) the requested image version and saves the file into fpga_images_path

        :param version_url: request_url/
        :type version_url: str
        :param request_version: requested image version
        :type request_version: str
        :return: image_path in system
        :rtype: str
        """

        #  These imports can't go at top of file until the requests pacakge can be installed on host controllers
        import requests
        image_name = self._get_image_name(request_version)  # Image file name in version_url
        if not os.path.exists(self.fpga_images_path):
            os.makedirs(self.fpga_images_path)
        if any(char.isdigit() for char in image_name):
            image_path = os.path.join(self.fpga_images_path, image_name)
        else:
            new_image_name = self.image_file_name + '_' + request_version + image_name[-4:]
            image_path = os.path.join(self.fpga_images_path, new_image_name)
        image_url = version_url + image_name
        info_url = version_url + 'build_info/info.json'
        info_path = os.path.join(self.fpga_images_path, 'info.json')
        download_urls = [image_url, info_url]
        download_paths = [image_path, info_path]
        for index, url in enumerate(download_urls):
            r = requests.get(url)
            if r.status_code == 200:
                try:
                    with open(download_paths[index], 'wb') as f:
                        f.write(r.content)
                except IOError:
                    self.log.error("Could not open %s file is locked or in use" % download_paths[index])
            else:
                self.log.error("%s not found" % url)
        return image_path

    def _download_fw_image(self, version_url: str, request_version: str):
        """
        Downloads from fw_image_url (FW mode only) the requested image version and saves the file into fpga_images_path

        :param version_url: fw_image_url/request_version
        :type version_url: str
        :param request_version: requested image version
        :type request_version: str
        :return: image_path in system
        :rtype: str
        """
        #  These imports can't go at top of file until the requests pacakge can be installed on host controllers
        import requests
        from bs4 import BeautifulSoup
        if not os.path.exists(self.fpga_images_path):
            os.makedirs(self.fpga_images_path)
        image_path = None
        image_name = '.zip'
        # Get zip file name
        r1 = requests.get(version_url, auth=(self.art_user_name, self.art_user_key))
        soup = BeautifulSoup(r1.text, 'html.parser')
        files = soup.find_all('a')
        for file in files:
            if file.string.endswith('.zip'):
                image_name = file.string
        # Download zip file
        image_url = version_url + image_name
        image_zip_path = os.path.join(self.fpga_images_path, image_name)
        image_dir_path = os.path.join(self.fpga_images_path, image_name[0:-4])
        r2 = requests.get(image_url, auth=(self.art_user_name, self.art_user_key))
        if r2.status_code == 200:
            with open(image_zip_path, 'wb') as f:
                f.write(r2.content)
            # Unzip downloaded file
            with zipfile.ZipFile(image_zip_path, 'r') as zip_ref:
                r = re.compile('.*ROM_Plugs.*')
                dirs = [d for d in zip_ref.namelist() if r.match(d)]
                zip_ref.extractall(path=image_dir_path, members=dirs)
            os.remove(image_zip_path)
            # Search in ROM_Plugs folder the file with the fw_image_suffix
            image_pattern = f"{image_dir_path}\\ROM_Plugs\\{self.fw_image_suffix}"
            for image in glob.glob(image_pattern):
                image_path = image
            if image_path is not None:
                shutil.copy(image_path, self.fpga_images_path)
                image_found = image_path.split("\\")
                image_path = f"{self.fpga_images_path}\\{image_found[-1]}"
            else:
                self.log.error("%s not found" % image_pattern)
            try:
                for root, dirs, files in os.walk(image_dir_path):
                    for dir in dirs:
                        os.chmod(os.path.join(root, dir), stat.S_IRWXU)
                    for file in files:
                        os.chmod(os.path.join(root, file), stat.S_IRWXU)
                shutil.rmtree(image_dir_path)
            except OSError:
                self.log.info("Failed to delete %s local folder" % image_dir_path)
        else:
            self.log.error("%s not found" % image_url)
        return image_path

    def _load_image(self, image_path: str):
        """
        Instantiation of FpgaProgrammer and execution of its program methods

        :param image_path: image path in system
        :type image_path: str
        """
        if self.programming_method == 'cldbprog':
            fp = FpgaProgrammer(mcs_file=image_path)
            fp_res = fp.cldbprog_program()
        else:
            target_id = self.jtag_target_id if self.jtag_target_id is not None else 'auto'
            fp = FpgaProgrammer(hw_device=self.fpga_device_id,
                                bit_file=image_path,
                                hw_target=target_id)
            fp_res = fp.jtag_program()

        if fp_res:
            self.log.info(self.ref_name + ' programmed successfully')
        else:
            self.log.error(self.ref_name + ' programming failed')
            raise FpgaProgramError(self.ref_name + ' programming failed')

    def _get_diff_url_suffix(self):
        return f"e{self.linked_wrapper.get_revision()}/register_map/diff/"
