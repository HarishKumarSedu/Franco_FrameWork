import os, sys, warnings, logging
from cl_test_station.components.fpga.fpga import Fpga
from cl_test_station.test_station_object import TsoField
from cl_test_station.utilities.reusables import get_revision_file, revision_to_hex_str, format_request_url
from cl_test_station.components.component.component import full_attribute_access


class EmuWrapper(Fpga):
    """PLACE HOLDER"""
    c4_reg_addr: int = TsoField(ftype=int, default=0, desc="Address of register containing C4 edition.")
    """Address of register containing C4 edition."""

    build_cnt_addr: int = TsoField(ftype=int, default=0, desc="Address of register containing build count.")
    """Address of register containing build count."""

    c4_edition_offset: int = TsoField(ftype=int, required=False, default=0, desc="Bit offset of the C4 edition field")
    """Bit offset of the C4 edition field"""

    c4_edition_bitwidth: int = TsoField(ftype=int, required=False, default=16, desc="Bit width of the C4 edition field")
    """Bit width of the C4 edition field"""

    build_count_offset: int = TsoField(ftype=int, required=False, default=0, desc="Bit offset of the build count field")
    """Bit offset of the build count field"""

    build_count_bitwidth: int = TsoField(ftype=int, required=False, default=16,
                                         desc="Bit width of the build count field")
    """Bit width of the build count field"""

    def __init__(self, *args, **kwargs):
        # Pull in attributes from YAML
        super().__init__(*args, **kwargs)

    def configure(self, config, *args, **kwargs):
        super().configure(config, *args, **kwargs)

    def initialize(self, **kwargs):
        super().initialize(**kwargs)

    def shutdown(self, **kwargs):
        super().shutdown(**kwargs)

    def get_revision(self):
        """
        Reads the C4 and build count registers (at address c4_reg_addr and build_cnt_addr resp.) and returns a
        formatted string in the form: '{C4 edition}_{Build count}'

        :return: revision string
        :rtype: str
        """
        # raise Exception("Test")
        if self.active_controller.isConnected():  # Can read the registers
            c4_edition = revision_to_hex_str(self.get_c4_edition(), length=4)
            build_count = revision_to_hex_str(self.get_build_count(), length=4)
            return '%s_%s' % (c4_edition, build_count)
        else:  # Return empty string since the registers can't be read
            self.log.warning('Cannot get revision, %s is not connected' % self.active_controller.ref_name)
            return ''

    def get_c4_edition(self):
        """
        Reads register at address 'c4_reg_addr' and returns value of the C4 Edition field

        :return: C4 edition field value
        :rtype: int
        """
        # todo: rename c4_reg_addr and build_cnt required fields to match accompanying attributes
        c4_reg_value = self.read_register(self.c4_reg_addr)             # Get raw register value
        mask = 2 ** self.c4_edition_bitwidth - 1                        # Create mask
        c4_edition = (c4_reg_value >> self.c4_edition_offset) & mask    # Shift and mask c4 edition field
        return c4_edition

    def get_build_count(self):
        """
        Reads register at address 'build_cnt_addr' and returns value of the C4 Edition field

        :return: C4 edition field value
        :rtype: int
        """
        build_count_reg_value = self.read_register(self.build_cnt_addr)             # Get raw register value
        mask = 2 ** self.build_count_bitwidth - 1                                   # Create mask
        build_count = (build_count_reg_value >> self.build_count_offset) & mask     # Shift and mask c4 edition field
        return build_count

    @full_attribute_access
    def construct_registers(self):
        """
        Uses revision from c4 and build_cnt registers to download register map file. Then calls component
        construct_objects to build block/register/field objects

        :return: None
        """
        if self.request_url:
            self.request_url = format_request_url(self.request_url)  # Remove test or release from path
        super().construct_registers(request_url=self.request_url)

    def _get_image_name(self, request_version:str):
        """
        Based on requested image version and image_file_suffix, provide the image file name

        :param request_version: requested image version
        :type request_version: str
        :return: file_name
        :rtype: str
        """
        req_c4_edition = request_version[1:5]
        req_build_count = int(request_version[-4:])
        if req_build_count < 10:
            req_build_count = request_version[-2:]
        else:
            req_build_count = str(req_build_count)
        file_name = "e%s_%s%s" % (req_c4_edition, req_build_count,self.image_file_suffix)
        return file_name
