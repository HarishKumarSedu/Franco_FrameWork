import os
import sys
import csv
import re
import inspect
import json
import logging
import pickle
import time
import xml.etree.ElementTree as ET
import html.parser
import ntpath
from inspect import isclass
from pkgutil import iter_modules
from importlib import import_module
from pathlib import Path
from typing import List, Dict, Tuple, Any, Callable, Union

import yaml
import cl_test_station.register_map.block as block
import cl_test_station.interfaces.ctrl_interface as ctrl_interface
import cl_test_station.host_controllers.host_controller.host_controller as host_controller
from cl_test_station.components.tags import ComponentTags
from cl_test_station.pyro_support.pyro_receiver import PyroReceiver
from cl_test_station.register_map.block import Block
from cl_test_station.register_map.field import Field, InternalAccessModes
from cl_test_station.register_map.custom_block import CustomBlock
from cl_test_station.register_map.register import Register
from cl_test_station.test_station_object import TestStationObject, TsoField, pyi_safe
from cl_test_station.utilities.cl_yaml_loader import yaml_load
from cl_test_station.utilities.parsing import parse_field_writes, parse_field_reads
from cl_test_station.utilities.reusables import get_revision_file, alias, read_bool_value
from cl_test_station.utilities.tso_container import TsoContainer
from cl_test_station.utilities.ts_context_manager import TsContextManager
from cl_test_station.utilities.ts_logging import TransactionLogger
from cl_test_station.utilities.varilist import VariList
try:
    from cl_test_station.utilities.scs.studiolink_adapter import StudioLinkAdapter
    SCS_PRESENT = True
except (ModuleNotFoundError, ImportError) as scs_err:
    SCS_PRESENT = False
    logging.getLogger('cl_test_station').warning(f"WARNING: Could not import StudioLinkAdapter, received {repr(scs_err)}")



def static_component(cls: TestStationObject):
    """Shortcut decorator for removing dynamic regmap related fields"""
    cls.remove_tags(ComponentTags.REGMAP, ComponentTags.REPAIR)
    return cls


# Wrapper that allows a function to access protected attributes of the Component (Blocks, flattened Fields)
def full_attribute_access(func):
    """
    Allows a function to access protected attributes of the Component (Blocks, flattened Fields).

    :param func: The function call.
    :return: None
    """

    def inner(self, *args, **kwargs):
        # Unlock block attributes
        setattr(self, '_Component__constructed', False)
        # Call function
        func(self, *args, **kwargs)
        # Lock attributes
        setattr(self, '_Component__constructed', True)

    return inner


class FileDownloadError(Exception):
    """**Class for raising necessary File download errors.**"""
    pass


class GetRevisionError(Exception):
    """**Class for raising necessary Revision errors.**"""
    pass


class WriteVerificationError(Exception):
    pass


class Component(TestStationObject):
    """**The component for test station object.**"""

    has_dynamic_attrs = True
    _gen_separate_pyi_file = False
    host_controllers: Dict[str, Any] = TsoField(ftype=list, desc="List of host controller ref_names that can talk to "
                                                                 "this component")

    # - - - - Reg Repair - - - - #
    reg_match_enable_flag: bool = TsoField(ftype=bool, required=False, default=False, tag=ComponentTags.REPAIR,
                                           desc='Enables reg map name repair')
    diff_file_path: str = TsoField(ftype=str, required=False, tag=ComponentTags.REPAIR,
                                   desc='Directory to Diff file folder')
    diff_file_name: str = TsoField(ftype=str, required=False, tag=ComponentTags.REPAIR,
                                   desc='Name of diff file to use for reg repair')
    diff_file_auto_download: bool = TsoField(ftype=bool, required=False, default=False, tag=ComponentTags.REPAIR,
                                             desc="Flag for selecting latest diff file based on revision.")
    diff_file_request_url: str = TsoField(ftype=str, required=False, default='', tag=ComponentTags.REPAIR,
                                          desc="Crystal URL to directory containing containing versioned subfolders"
                                               "http://crystal.cirrus.com/~<project>/trunk/emulation/test")
    repair_check: bool = TsoField(ftype=bool, required=False, default=False, tag=ComponentTags.REPAIR, desc='')
    repair_record: list = TsoField(ftype=list, required=False, default_factory=lambda: [], tag=ComponentTags.REPAIR,
                                   desc='Record of reg name repairs')

    # - - -  Register map  - - - #
    register_map_name: str = TsoField(ftype=str, required=False, tag=ComponentTags.REGMAP,
                                      desc='Name of register map file to load')
    register_map_path: str = TsoField(ftype=str, required=False, tag=ComponentTags.REGMAP,
                                      desc='Path to register map file(s)')
    revision_override: str = TsoField(ftype=str, required=False, tag=ComponentTags.REGMAP,
                                      desc='Force a certain revision regardless of image. eg "1234_0001"')
    block_config_name: str = TsoField(ftype=str, required=False, default='block_config.yml', tag=ComponentTags.REGMAP,
                                      desc='Path to explicit block config file. If none given, will use revisioned '
                                           'config file')

    block_config_path: str = TsoField(ftype=str, required=False, tag=ComponentTags.REGMAP,
                                      desc='Path to block config file(s)')
    # - Transaction Attributes - #
    transaction_logging_enable: bool = TsoField(ftype=bool, required=False, default=False, tag=ComponentTags.TRANS_LOG,
                                                desc='Enables transaction logging after construction. '
                                                     'If set to True, transaction_log_path must be specified.')
    transaction_log_path: str = TsoField(ftype=str, required=False, tag=ComponentTags.TRANS_LOG,
                                         desc="Desired path for transaction log .csv file")

    verify_writes: bool = TsoField(ftype=bool, required=False, default=True,
                                   desc='When True, each write will be followed by a read to verify')
    # - - - - Aliasing - - - - - #
    alias_base_name: str = TsoField(ftype=str, required=False, default=None, tag=ComponentTags.ALIAS,
                                    desc='Alias base name')
    alias_path: str = TsoField(ftype=str, required=False, default=None, tag=ComponentTags.ALIAS,
                               desc='Alias path')
    create_rtl_aliases: bool = TsoField(ftype=bool, required=False, default=False,
                                        desc="Uses RTL field names to create component level aliases")
    # - - - - -  Misc  - - - - - #
    reset_time: float = TsoField(ftype=float, required=False, default=0.0,
                                 desc='Time in seconds between enter_reset() and exit_reset() when reset() is called.')
    full_clive_history: bool = TsoField(ftype=bool, required=False, default=False,
                                        desc='Enable flag for full CLIVE history of registers portions of '
                                             'Field transactions')
    scs_device_name: str = TsoField(ftype=str, required=False,
                                    desc="Name of matching component in SoundClearStudio under 'Register Maps'")
    internal_field_access: InternalAccessModes = TsoField(ftype=str, required=False, default=InternalAccessModes.IGNORE,
                                                          cast_type=InternalAccessModes,
                                                          desc="When True, displays a warning when an internal "
                                                               "field is accessed")

    def __init__(self, *args, **kwargs):
        self.__constructed = False
        # - - - 1.2 deprecated  - - #
        self.control_interfaces = {}
        self.default_iface = ''
        # - - - 1.3 attributes - - - #
        self._active_interface = None  # type: ctrl_interface.CtrlInterface
        self._active_controller = None  # type: host_controller.HostController
        self.interfaces = {}
        # - - -  Register map  - - - #
        self.blocks = {}
        self.registers = {}
        self.field_regs_bitpos_dict = {}
        self.reg_addr_map: Dict[int, Register] = {}  # Maps register address to the instance
        # -  Block map attributes  - #
        self.block_config_file: str = None  # block_config_path + block_config_name
        self.block_config: dict = None  # Raw block config YAML contents
        self.block_map = {}  # Keys are regmap names, value is tuple (ref name, class reference)
        self.custom_blocks = {}  # All block mappings that aren't part of the regmap
        # - - - - - - -- - - - - - - #
        self.loaded_register_map_path = None  # The raw file path of the regmap that gets loaded
        # - - - - Aliasing - - - - - #
        self.aliases = {}  # Aliases and their attributes
        self._alias_yaml_dict = {}  # Aliases imported from found yaml file
        super().__init__(*args, **kwargs)
        # - - - - - - SCS  - - - - - #
        self.__linked_scs_devices = []
        # - - - - - - -- - - - - - - #

        # Store if test station server is present
        test_station = self.find_top_level()
        self.server_present = hasattr(test_station, 'clive_tcp_client')

        if self.register_map_path is None:  # Auto-populate with standard location
            self.register_map_path = os.path.join(os.path.dirname(inspect.getfile(self.__class__)), 'register_maps')

        if self.block_config_path is None:  # Auto-populate with standard location
            self.block_config_path = os.path.join(os.path.dirname(inspect.getfile(self.__class__)), 'block_configs')

        if self.revision_override:
            self.log.debug("Revision overridden to '%s'" % self.revision_override)

        # User enabled transaction logging from YAML
        if self.transaction_logging_enable:
            if not self.transaction_log_path:
                self.log.warning("Cannot enable transaction logging: No path specified", suppress_file_msg=True)
                self.log.warning("Add field 'transaction_log_path: <path to csv log file> to config",
                                 suppress_file_msg=True)
            else:
                self.enable_transaction_logging(self.transaction_log_path)
        # Once resources and container have been created, instantiate containers for custom blocks and flattened fields
        self.block_apis = TsoContainer(ref_name='block_apis', container=self, resource_type=CustomBlock)
        self.flattened_fields = TsoContainer(ref_name='flattened_fields', container=self, generate_stubs=False,
                                             resource_type=Field)

    def __getattribute__(self, item):
        """
        Gets attributes for the specified item.

        :param item: The item to get attribute.
        :return: Empty strings for old_reg_name, old_block_name, new_reg_name, and new_block_name if item is upper case.
        Otherwise gets attribute for item.
        """
        if item.isupper():
            self.old_reg_name = ''
            self.old_block_name = ''
            self.new_reg_name = ''
            self.new_block_name = ''
        return super().__getattribute__(item)

    def __getattr__(self, item):
        if (item not in self.__dict__) and self.__getattribute__('reg_match_enable_flag') and item.isupper():
            # The requested block name is not in the new reg map. Try to repair it...
            # Find the index of broken block name in the old column of the diff file
            # Then grab that same index from block name in the new column
            # Return as the new block name
            repaired_name = self.new_blocks[self.old_blocks.index(item)]
            self.log.warning('BLOCK: %s does not exist. Using %s instead.' % (item, repaired_name))  # warn the user
            new_block = self.__getattribute__(repaired_name)
            self.old_block_name = item  # store this for use in block and register auto repair
            self.new_block_name = repaired_name  # store this for use in block and register auto repair
            return new_block
        return self.__getattribute__(item)

    def __setattr__(self, key, value):
        if hasattr(self, '_Component__constructed') and self.__constructed and hasattr(self, key):
            obj = getattr(self, key)
            if isinstance(obj, (Block, Register, Field)):
                self.log.error(f"Cannot set protected {obj.__class__.__name__} {key} to {value}")
                return None
        return object.__setattr__(self, key, value)

    def initialize(self, **kwargs):
        """
        Constructs registers for object.

        :return: Downloads diff file if auto download is True. Constructs the registers for the object.
        """
        super().initialize(**kwargs)
        # Clear
        if self.diff_file_auto_download:
            self.__download_diff_file()
        self.construct_registers()

    def shutdown(self, **kwargs):
        """
        Gives access to shutdown the object.
        """
        super().shutdown(**kwargs)

    def enter_reset(self, *args, **kwargs):
        """Place Holder"""
        pass

    def exit_reset(self, *args, **kwargs):
        """Place Holder"""
        pass

    def configure(self, config, *args, **kwargs):
        """
        Configures the object by building host_controlers, and initializing active_controller. Also building interface
        dict, and adding host controller to dictionary.

        :return: None
        """
        super().configure(config, *args, **kwargs)
        # # Build host_controllers dictionary and set initial active_controller # #
        top = self.find_top_level()
        # Copy YAML field into temp list
        controller_list = self.host_controllers.copy()
        self.host_controllers = {}
        for controller_name in controller_list:
            if type(controller_name) is not str:
                self.log.warning("host_controller '%' is not a string, cannot create link" % controller_name)
                continue
            # Get reference to host controller
            match = top.find_resource(controller_name)
            if not match:  # No resource was found
                if top.uses_ts_server:  # Server may not be running
                    self.log.warning("Test Station server may not be running")
                else:
                    self.log.warning("Check host_controller link in config: '%s' not found" % controller_name)
                raise EnvironmentError("Unable to link host controller: '%s'" % controller_name)
            _, host_controller = match[0]
            if self.host_controllers == {}:  # First host controller, set as active
                self.active_controller = host_controller
            # Add host controller to dictionary
            self.host_controllers[controller_name] = host_controller
        if self.active_controller is None:
            self.log.warning("No host controllers were found, will be unable to communicate with this component")

        # # Build interface dictionary and set initial active_interface # #
        for ref_name, tso in self.resources.items():
            if isinstance(tso, ctrl_interface.CtrlInterface):  # Add this to dictionary
                if self.interfaces == {}:  # First interface becomes active
                    self.active_interface = tso
                self.interfaces[ref_name] = tso
        if len(self.interfaces) > 1:  # Set first interface as active, inform user
            self.active_interface.log.info(f"Using '{self.active_interface.ref_name}' as active interface.")
        if self.active_interface is None:
            self.log.warning("No interfaces are defined in this component, will be unable to communicate with it.")

    def construct_objects(self, *args, **kwargs):
        """
        Builds register map using file given by config

        :return: None
        """
        super().construct_objects(*args, **kwargs)

        # Initialize some attributes which will be used for register auto repair (if enabled)
        self.old_block_name = ''
        self.new_block_name = ''
        self.old_reg_name = ''
        self.new_reg_name = ''

        # # Generate block map if map was serialized # #
        if self.block_config:
            self.block_map = self.__parse_block_map(self.block_config)  # Creates block map dictionary

        # # Build serialized blocks # #
        if self.blocks:
            self.__parse_block_dict(self.blocks)

        # # Build serialized registers # #
        if self.registers:
            self.__parse_register_dict(self.registers)

        # # Custom blocks from serialized dict # #
        if self.custom_blocks:
            self.__parse_block_dict(self.custom_blocks)

        # # If any blocks were defined in config, they need to be aliased # #
        if self.blocks:  # Alias everything
            for block in self.get_blocks():
                block.post_construction()
                block.set_all_constructed(True)
            self.post_construction()

        # # # Request capable slave group mapping # # #
        # todo: Move this to RCS specific class
        self.rcs_group_map = None
        if 'rcs_group_mapping' in self.config:
            file_type = os.path.splitext(self.rcs_group_mapping)[1]
            if file_type == '.json':
                with open(self.rcs_group_mapping, 'r') as f:
                    int_file_dict = json.load(f)
            elif file_type == '.yml':
                with open(self.rcs_group_mapping, 'r') as f:
                    int_file_dict = yaml.load(f, Loader=yaml.FullLoader)
            self.rcs_group_map = int_file_dict

    def build_registers_from_regmap(self, regmap_file: str):
        """
        Takes in register map file path and runs the parsing function based on the file type.

        :param regmap_file: file path to register map
        :type regmap_file: str
        :return: None
        """
        # Parse the register map file based on the register map file format
        if regmap_file.lower().endswith("_wisce.xml"):
            self.__parse_wisce_xml(regmap_file)
        elif regmap_file.lower().endswith('.svd'):
            self.__parse_svd_xml(regmap_file)
        elif regmap_file.lower().endswith('.csv'):
            self.__parse_val_csv(regmap_file)
        elif regmap_file.lower().endswith('.json'):
            with open(regmap_file, 'r') as f:
                json_dict = json.load(f)
            if 'blocks' in json_dict:
                self.__parse_block_dict(json_dict['blocks'])
            if 'registers' in json_dict:
                self.__parse_register_dict(json_dict['registers'])

    @full_attribute_access
    def construct_registers(self):
        """
        Generates and applies block config mapping -> builds blocks, registers and fields from regmap file -> runs
        post_construction for all blocks and initializes block attribute protection -> Runs self.post_construction()
        -> enables attribute protection for self.

        :return: None
        """
        # # Generate block map and custom block dictionaries if specified by user # #
        self.block_config_file = self.__get_block_cfg_file()  # Get block_config file based on name and path
        if self.block_config_file:  # Either found a mapping file or one was specified
            if os.path.isfile(self.block_config_file):  # Check if user-specified file exists
                # Load yaml file into python dictionary
                self.block_config = yaml_load(self.block_config_file, obj=self)
                if self.block_config:  # YAML file has content
                    self.block_map = self.__parse_block_map(self.block_config)  # Creates block map dictionary
            else:
                self.log.warning("Block mapping file does not exist: %s" % self.block_config)

        # # Register repair: Parse diff file if one was specified # #
        if self.diff_file_path is not None and self.diff_file_name is not None and self.reg_match_enable_flag:
            # Load up the diff file and create the lists that will be used for repairing register map changes
            import csv
            self.old_blocks = []
            self.old_regs = []
            self.old_fields = []
            self.new_blocks = []
            self.new_regs = []
            self.new_fields = []
            old_names = []
            new_names = []
            if self.diff_file_auto_download:
                diff_file_path = self.local_diff_file_path
            else:
                diff_file_path = str(Path(os.path.expandvars(self.diff_file_path)) / self.diff_file_name)
            with open(diff_file_path, 'r', newline='') as diff_file:
                diff_file = csv.reader(diff_file, delimiter=',', quotechar='\"')
                # skip the 1st row since it's the header
                next(diff_file)
                for row in diff_file:
                    if row[4] != '' and row[5] != '':  # make sure the columns aren't empty
                        old = row[4].split('.')  # break out block.reg.field components
                        new = row[5].split('.')  # break out block.reg.field components
                        self.old_blocks.append(old[0])
                        self.old_regs.append(old[1])
                        self.old_fields.append(old[2])
                        self.new_blocks.append(new[0])
                        self.new_regs.append(new[1])
                        self.new_fields.append(new[2])

        # # Build objects from register map # #
        if self.register_map_name and self.register_map_path:
            regmap_file = os.path.join(self.register_map_path, self.register_map_name)
            if (os.path.isfile(regmap_file)):
                self.loaded_register_map_path = regmap_file
                self.build_registers_from_regmap(regmap_file)
            else:
                self.log.warning("Register map file not found, no objects constructed: %s" % regmap_file)

        # # Build custom blocks # #
        self.__parse_block_dict(self.custom_blocks)
        for block in self.block_apis.values():
            block.post_construction()
            block.set_all_constructed(True)

        # # Check if any attributes were made # #
        if self.get_blocks():
            # Flatten the field names to make searching easier
            self.__flatten_fields()
            # Set all constructed on all blocks, registers, fields
            self.log.debug("Aliasing blocks and setting state to constructed")
            for block in self.get_blocks():
                block.post_construction()
                block.set_all_constructed(True)
        else:
            self.log.warning('No blocks created for %s' % self.ref_name)

        # # Build regsiter address map # #
        for reg in self.get_all_registers():
            self.reg_addr_map[reg.addr] = reg

        self.post_construction()
        # # Set component state to constructed, protecting attributes in __setattr__ # #
        self.__constructed = True

    # todo: put alias wrapper function here
    def post_construction(self):
        """
        Perform any operations that requires all registers within the component to be constructed

        :return: None
        """
        try:
            self.alias()  # Create alises
        except AttributeError:
            self.log.exception(f"Failed to create aliases for {self.ref_name}")

    def __find_scs_devices(self) -> List[Tuple[str, TestStationObject]]:
        found_devices = []
        if SCS_PRESENT:  # Studiolink pacakge was successfully imported
            scs_adapter: StudioLinkAdapter
            found_scs_device_name = False
            for _, scs_adapter in self.find_all(StudioLinkAdapter, start_from_top=True):

                # Search for SCS device from TSO Field (Device from BSP)
                if self.scs_device_name in scs_adapter.devices:  # Add this adapter to internal list attribute
                    found_devices.append((self.scs_device_name, scs_adapter))
                    self.log.debug(f"Found external SCS device: {scs_adapter.devices[self.scs_device_name]}")
                    found_scs_device_name = True
                # Search for SCS device with ref_name (Adapter built description file from YAML)
                if self.path in scs_adapter.devices:
                    found_devices.append((self.path, scs_adapter))
                    self.log.debug(f"Found SCS device from ref_name: {scs_adapter.devices[self.path]}")

            if self.scs_device_name and not found_scs_device_name:  # No adapters have devices for this component
                self.log.warning(f"No SCS device found with name: '{self.scs_device_name}'")

        return found_devices

    def post_system_initialize(self, **kwargs):
        """
        TODO: Need to move this to guarantee linking regardless of YAML position
        Component post initialization:

            * Searches test station to find any StudioLinkAdapters that have devices for this component

        :return: None
        :rtype: None
        """
        super().post_system_initialize(**kwargs)
        self.__linked_scs_devices = self.__find_scs_devices()

    @property
    @pyi_safe
    def active_controller(self):
        """
        Getter for active_controller

        :return: [host_controller.HostController] reference to the component's active host controller
        """
        return self._active_controller

    @active_controller.setter
    def active_controller(self, controller):
        """
        Sets the active controller for the component. Can set it to either reference to controller or name

        :param controller: Controller reference/name
        :type controller: [Union[str, host_controller.HostController]
        :return: None

            Example usage (Both are equivalent):

            self.active_controller = self.host_controllers['audiohub']  # Set by reference

            self.active_controller = 'audiohub'  # Set by name
        """
        if type(controller) is str:
            if controller in self.host_controllers:
                controller = self.host_controllers[controller]
            else:
                self.log.error("Controller '%s' not found. %s's host controllers are: %s"
                               % (controller, self.ref_name, ', '.join(self.host_controllers.keys())))
        self._active_controller = controller

    @property
    @pyi_safe
    def active_interface(self):
        """
        Getter for active_interface

        :return: [ctrl_interface.CtrlInterface] reference to the component's active interface
        """
        return self._active_interface

    @active_interface.setter
    def active_interface(self, iface):
        """
        Sets the active interface for the component. Can set it to either reference to interface or name

        :param iface: Interface reference/name
        :type iface: [Union[str, ctrl_interface.CtrlInterface]
        :return: None
        Example usage (Both are equivalent):

        self.active_interface = self.interfaces['i2c']  # Set by reference

        self.active_interface = 'i2c'  # Set by name
        """
        if type(iface) is str:
            # Check given interface name exists
            if iface not in self.interfaces:
                raise AttributeError(f"Interface '{iface}' not found. "
                                     f"Valid interfaces for {self.ref_name}: {', '.join(self.interfaces.keys())}")
            iface = self.interfaces[iface]
        # Set property attribute
        self._active_interface = iface

    def set_default_iface(self, key):
        """
        Sets the default interface to use if not specified in r/w call

        :param key: Name of interface. Ex 'SPI'
        :type key: str
        :return: Warning
        """
        self.log.warning("set_default_iface() is deprecated. set the 'active_interface' attribute with")
        self.log.warning("one of the objects in the 'self.interfaces' dictionary")
        return

    def download_regmap(self, url, path):
        """
        Retrieves the url and writes the content to the specified path.

        :param url: Url for the regmap object.
        :type url: str
        :param path: The path where the url should be placed.
        :type path: str
        :return: The url is placed in the path.
        """
        import requests
        if os.path.exists(path):
            os.remove(path)
        r = requests.get(url)
        with open(path, 'wb') as f:
            f.write(r.content)

    def get_revision(self) -> str:
        """
        Returns the component's revision as a string. To be implemented by Child classes

        :return: revision
        :rtype: str
        """
        return ''

    def __get_revision(self) -> str:
        if self.revision_override:
            return str(self.revision_override)
        else:
            return self.get_revision()

    def get_link(self, url, target, save_url):
        """
        Gets the link, and ensures link format is correct.

        :param url: Specified url.
        :type url: str
        :param target: The target link format.
        :type target: str
        :return: Returns True if url follows target format.
        """

        import requests
        from bs4 import BeautifulSoup
        page = requests.get(url)
        soup = BeautifulSoup(page.text, 'html.parser')
        links = soup.find_all('a')
        exclude_list = ['Name', 'Last modified', 'Size', 'Description', 'Parent Directory']
        for link in links:
            if link.string not in exclude_list:
                child_link = url + link.get('href')
                # print(child_link)
                if link.string == target:
                    save_url.append(child_link)
                    return True
                elif child_link.endswith('/'):
                    if self.get_link(child_link, target, save_url):
                        return True
        return False

    def get_blocks(self) -> List[Block]:
        """
        Returns a list of all block objects in this instance

        :return: List of block objects
        :rtype: list
        """
        return list(self.blocks.values())

    def get_block_apis(self) -> List[Block]:
        """
        Returns a list of all onjects in self.block_apis

        :return: List of block objects
        :rtype: list
        """
        return list(self.block_apis.values())

    def get_block(self, name: str) -> Block:
        """
        Returns the block object that has name 'name'

        :param name: Block name
        :type name: str
        :return: Block reference
        :rtype: Block
        """
        if name in self.blocks:
            return self.blocks[name]
        return None

    def get_registers(self) -> List[Register]:
        """
        Returns a list of all register objects in this instance

        :return: list of register objects
        :rtype: list
        """
        registers = []
        for key in self.__dict__:
            if type(getattr(self, key)) == Register:
                registers.append(getattr(self, key))
        return registers

    def get_all_registers(self) -> List[Register]:
        """
        Returns a list of all register objects of the component

        :return: list of register objects
        :rtype: list
        """
        temp_regs = []
        for block in self.get_blocks():
            temp_regs.append(list(block.get_registers()))
        regs = []
        regs = [val for sublist in temp_regs for val in sublist]

        return regs

    def get_register_by_address(self, address: int) -> Register:
        """
        Gets reference to register from address. Raises AttributeError if no register exists at a given address.

        :param address: Register address
        :type address: int
        :return: Register reference
        :rtype: Register
        """
        address_size = self.active_interface.read_reg_addr_size << 1
        if address not in self.reg_addr_map:
            raise AttributeError(f"No register with address 0x{address:0{address_size}X} found in {self.ref_name}.")
        reg = self.reg_addr_map[address]
        self.log.debug(f"Register at address 0x{address:0{address_size}X}: {reg.path}")
        return reg

    def dump_block_names(self):
        """
        Prints out all block names to the console/log files. Does not perform any hw transactions.

        :return: None
        """
        self.log.info('Dumping %s block names' % self.ref_name)
        for block in self.get_blocks():
            self.log.print(block.name)

    def dump_block_api_names(self):
        """
        Prints out all block api names to the console/log files. Does not perform any hw transactions.

        :return: None
        """
        self.log.info('Dumping %s block names' % self.ref_name)
        for block in self.get_block_apis():
            self.log.print(block.name)

    def dump_registers(self):
        """
        Prints out all Register names and values from component and all blocks within the component. Performs a read
        for each register printed.

        :return: None
        """
        self.log.info('Dumping %s registers' % self.ref_name)
        for reg in self.get_registers():
            self.log.print('%s: %s' % (reg.name, hex(reg.value)))
        for block in self.get_blocks():
            block.dump_registers()

    def _update_scs(self, update_func: str, address: int, data: Union[int, List[int]]):
        """
        Sends a transaction update to SoundClear Studio for any linked devices.

        :param update_func: Name of StudioLinkAdapter update function to use, e.g. "update_register_write"
        :type update_func: str
        :param address: Register address
        :type address: int
        :param data: Read/Write data, could be single integer or list of integers
        :type data: int | List[int]
        :return: None
        :rtype: None
        """
        for device_name, scs_adapter in self.__linked_scs_devices:
            getattr(scs_adapter, update_func)(device_name, address, data)

    def check_rw_arguments(self, interface, controller):
        """
        Makes sure that interface and controller are valid, or default them to active references

        :param interface: input kwarg 'interface'
        :type interface: str
        :param controller: input kwarg 'controller'
        :type controller: str
        :return: (interface, controller) references
        :rtype: tuple
        """
        if interface == '':  # deprecated iface_name was passed in positionally
            self.log.warning("Empty string was passed as second arguement (deprecated iface_name)."
                             "Using active interface '%s'" % self.active_interface.ref_name)
            interface = self.active_interface
        if interface is not None:
            if not isinstance(interface, ctrl_interface.CtrlInterface):
                raise ValueError("interface '%s' is not a Control Interface object" % interface)
        else:  # use active interface
            interface = self.active_interface  # type: ctrl_interface.CtrlInterface
        if controller is not None:
            if not isinstance(controller, (host_controller.HostController, PyroReceiver)):
                raise ValueError("controller '%s' is not a HostController or PyroReceiver" % controller)
        else:  # use active controller
            controller = self.active_controller  # type: host_controller.HostController
        return interface, controller

    # TODO: PLATDEV-1482 simplify these functions
    def write_register(self, addr: int, data: int, interface=None, controller=None, update_clive: bool = True,
                       reg_name: str = None, field_name: Union[str, List[str]] = None, desc='WRITE (Register)',
                       field_value: Union[int, List[int]] = None, field_mask: int = None, field_offset: int = None,
                       field_fmt: Callable = None, notes: str = None, verify_mask: int = None,
                       verify_desc: str = 'READ (Verify)', skip_verify: bool = False, **kwargs):
        """
        Writes 'data' to register at address 'addr'. If no interface or controller is specified, active_interface
        and active_controller will be used.

        :param addr: Register address
        :type addr: int
        :param data: Data to write
        :type data: int
        :param interface: Optional interface to use for transaction instead of active_interface
        :type interface: CtrlInterface
        :param controller: Optional host controller to use for transaction of active_controller
        :type controller: HostController | PyroReceiver
        :param update_clive: Send CLIVE transaction information? (Default: True)
        :type update_clive: bool
        :param reg_name: [**For logging use only**] Name of register to appear in log file, eg. BLOCK.REGISTER
        :type reg_name: str
        :param field_name: [**For logging use only**] Name of field(s) to appear in log file, eg. BLOCK.REGISTER.FIELD
        :type field_name: str
        :param desc: [**For logging use only**] Transaction log description. (Default: WRITE (Register))
        :type desc: str
        :param field_value: [**For logging use only**] Field value(s) being written. Used only for writing to log file
        :type field_value: list
        :param field_mask: [**For logging use only**] Used to mask off current field bits in register
        :type field_mask: int
        :param field_offset: [**For logging use only**] Field bit offset
        :type field_offset: int
        :param field_fmt: [**For logging use only**] Function that formats field into a hex string
        :type field_fmt: Callable
        :param notes: [**For logging use only**] Extra notes for log entry
        :type notes: str
        :param verify_mask: Used to mask off undefined/volatile bits during verification
        :type verify_mask: int
        :param verify_desc: [**For logging use only**] Value of the 'description' column for the second register read
        :type verify_desc: str
        :param skip_verify: When True, will skip the verify step regardless of 'verify_writes' value
        :type skip_verify: bool
        :param kwargs: Any additional keyword arguments will be passed into the interface's write_register() function
        :return: None
        """
        transaction_exc = None  # Store potential exceptions to enable logging
        try:
            if not isinstance(data, int):
                raise ValueError("Parameter 'data' must be of type: int")
            # Check kwargs for interface and controller
            interface, controller = self.check_rw_arguments(interface, controller)
            # Issue write
            interface.write_register(controller, reg_addr=addr, write_data=data, **kwargs)
            # Update CLIVE
            if update_clive and self.server_present:
                test_station_obj = self.find_top_level()
                test_station_obj.clive_tcp_client.update_register_write(self.ref_name, addr, data)
            # Update SCS
            self._update_scs("update_register_write", addr, data)

        except Exception as e:  # Save exception to be re-raised after logging
            transaction_exc = e
        # Log transaction
        if self.transaction_logging_enable:  # This flag mirrors TransactionLogger's is_enabled()
            # Parameters incase interface/controller failed to resolve
            addr_size, data_size, interface_name, controller_name = self.__get_log_args(interface, controller, 'write')
            if type(field_value) is list and type(field_fmt) is list:
                field_values = [fmt(val) for val, fmt in zip(field_value, field_fmt)]
            elif type(field_value) is int and field_fmt is not None:
                field_values = [field_fmt(field_value)]
            else:
                field_values = None
            # Write new entry to log file(s)
            self.__transaction_logger.log(self.path, addr, addr_size, reg_name, field_name, desc, data, data_size,
                                          interface_name, controller_name, field_values, transaction_exc, notes=notes)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc
        # Verify write
        if self.verify_writes and not skip_verify:
            readback = self.read_register(addr, interface=interface, controller=controller, update_clive=update_clive,
                                          reg_name=reg_name, field_name=field_name, desc=verify_desc,
                                          field_offset=field_offset, field_fmt=field_fmt, field_mask=field_mask, **kwargs)
            masked_data = data
            if verify_mask is not None:
                readback &= verify_mask  # Only care about non-volatile, readable, and defined bits
                masked_data &= verify_mask
            if readback == masked_data:
                self.log.debug(f"[PASS] Write 0x{data:x} to {self.path}: Got expected value 0x{readback:x}")
            else:
                self.log.error(f"[FAIL] Write 0x{data:x} to {self.path}: Expected 0x{masked_data:x}, got 0x{readback:x}")
                raise WriteVerificationError(f"[{self.path}] Expected 0x{masked_data:x}, got 0x{readback:x}")

    def write_field(self, addr: int, field_value: int, field_mask: int, reg_readable: bool = True, w1x_mask: int = None,
                    w0x_mask: int = None, interface=None, controller=None, reg_name: str = None,
                    field_name: Union[str, List[str]] = None, field_offset: int = None, field_fmt: Callable = None,
                    desc='WRITE (Field)', modify_desc:str='READ (Modify)', verify_mask: int = None,
                    verify_desc: str = 'READ (Verify)', skip_verify: bool = False, notes: str = None, **kwargs):
        """
        Performs a field write. If specified, reads current reg value and modifies it, then verifies after writing.

        :param addr: Register address
        :type addr: int
        :param field_value: Desired field value
        :type field_value: int
        :param field_mask: Used to mask off current field bits in register
        :type field_mask: int
        :param reg_readable: If True, will read-modify-write. If False, assumes value of 0 for all other bits
        :type reg_readable: bool
        :param w1x_mask: Mask for all write-one bits in register. Value written for these bits (outside field) will be 0
        :type w1x_mask: int
        :param w0x_mask: Mask for all write-zero bits in register. Value written for these bits (outside field) will be 1
        :type w0x_mask: int
        :param interface: Interface to use. If None is given, 'active_interface' will be used
        :type interface: CtrlInterface
        :param controller: Controller to use. If None is given, 'active_controller' will be used
        :type controller: HostController
        :param reg_name: [**For logging use only**] Register path
        :type reg_name: str
        :param field_name: [**For logging use only**] Field path
        :type field_name: str
        :param field_offset: [**For logging use only**] Field bit offset
        :type field_offset: int
        :param field_fmt: [**For logging use only**] Function that formats field into a hex string
        :type field_fmt: Callable
        :param desc: [**For logging use only**] Value of the 'description' column for the register write
        :type desc: str
        :param modify_desc: [**For logging use only**] Value of the 'description' column for the first register read
        :type modify_desc: str
        :param verify_mask: Used to mask off undefined/volatile bits during verification
        :type verify_mask: int
        :param verify_desc: [**For logging use only**] Value of the 'description' column for the second register read
        :type verify_desc: str
        :param skip_verify: When True, skips the verification read
        :type skip_verify: bool
        :param notes: [**For logging use only**] Miscellaneous notes for log entry
        :type notes: str
        :param kwargs: Any additional keyword arguments will be passed into the interface's read/write functions
        :return: None
        :rtype: None
        """
        # Caclulate offset if necessary
        if field_offset is None:
            field_offset = 0
            if field_mask:
                while not (field_mask & 1 << field_offset):
                    field_offset += 1
        # Get initial register value
        if reg_readable:
            register_value = self.read_register(addr, controller=controller, interface=interface,
                                                update_clive=self.full_clive_history, desc=modify_desc,
                                                reg_name=reg_name, field_name=field_name, field_offset=field_offset,
                                                field_mask=field_mask, field_value=field_value, field_fmt=field_fmt,
                                                notes=notes, **kwargs)
        else:
            register_value = 0
        # Force bits (For W1C, W0S, etc)
        if w1x_mask:
            self.log.debug("Applying mask for W1X Fields: %s" % bin(w1x_mask))
            register_value &= ~w1x_mask
        if w0x_mask:
            self.log.debug("Applying mask for W0X Fields: %s" % bin(w0x_mask))
            register_value |= w0x_mask
        # Clear bits for field write
        register_value &= ~field_mask
        # Set value
        register_value = register_value | ((field_value << field_offset) & field_mask)
        # Write register
        skip_verify |= not reg_readable  # If register is not readble, skip verification step
        self.write_register(addr, register_value, interface=interface, controller=controller,
                            update_clive=self.full_clive_history, reg_name=reg_name, field_name=field_name, desc=desc,
                            field_value=field_value, field_mask=field_mask, field_offset=field_offset,
                            field_fmt=field_fmt, verify_mask=verify_mask, verify_desc=verify_desc,
                            skip_verify=skip_verify, notes=notes, **kwargs)

    def read_register(self, addr: int, interface=None, controller=None, update_clive: bool = True, reg_name: str = None,
                      field_name: Union[str, List[str]] = None, desc='READ (Register)',
                      field_offset: Union[int, List[int]] = None, field_mask: Union[int, List[int]] = None,
                      field_fmt: Union[Callable, List[Callable]] = None, notes: str = None, **kwargs) -> int:
        """
        Reads from register at address 'addr'. If no interface or controller is specified, active_interface
        and active_controller will be used.

        :param addr: Register address to read
        :type addr: int
        :param interface: Optional interface to use for transaction instead of active_interface
        :type interface: CtrlInterface
        :param controller: Optional host controller to use for transaction of active_controller
        :type controller: Union[HostController, PyroReceiver]
        :param update_clive: Send CLIVE tranaction infromation? (Default: True)
        :type update_clive: bool
        :param reg_name: Name of register to appear in log file, eg. BLOCK.REGISTER
        :type reg_name: str
        :param field_name: Name of field(s) to appear in log file, eg. BLOCK.REGISTER.FIELD
        :type field_name: Union[str, List[str]]
        :param desc: Transaction log description. (Default: READ (Register))
        :type desc: str
        :param field_offset: Field's bit_offset value. Used only for writing field value to log file
        :type field_offset: Union[int, List[int]]
        :param field_mask: Field's mask value. Used only for writing field value to log file
        :type field_mask: Union[int, List[int]]
        :param field_fmt: Field's __value_to_hex funciton pointer. Used only for writing field value to log file
        :type field_fmt: Union[Callable, List[Callable]]
        :param notes: [**For logging use only**] Miscellaneous notes for log entry
        :type notes: str
        :param kwargs: Any additional keyword arguments will be passed into the interface's read_register() function
        :return: Read value
        :rtype: int
        """
        transaction_exc = None  # Store potential exceptions to enable logging
        readback = None  # Readback data
        try:
            # Check kwargs for interface and controller
            interface, controller = self.check_rw_arguments(interface, controller)
            # Issue read
            readback = interface.read_register(controller, reg_addr=addr, **kwargs)
            # Update CLIVE
            if update_clive and self.server_present:
                test_station_obj = self.find_top_level()
                test_station_obj.clive_tcp_client.update_register_read(self.ref_name, addr, readback)
            # Update SCS
            self._update_scs("update_register_read", addr, readback)

        except Exception as e:
            transaction_exc = e
        # Log transaction
        if self.transaction_logging_enable:  # This flag mirrors TransactionLogger's is_enabled()
            if field_offset is not None and field_mask is not None and readback is not None:  # Need to get field value
                # from reg value
                if all(type(kw) is list for kw in
                       [field_offset, field_mask, field_fmt]):  # Add all field values to list
                    field_values = []
                    for offset, mask, fmt in zip(field_offset, field_mask, field_fmt):
                        field_values.append(fmt((readback & mask) >> offset))
                else:
                    field_values = [
                        field_fmt((readback & field_mask) >> field_offset)]  # Format value with corrent zfill
            else:
                field_values = None  # Just a reg read/write
            # Parameters incase interface/controller failed to resolve
            addr_size, data_size, interface_name, controller_name = self.__get_log_args(interface, controller, 'read')
            # Write new entry to log file(s)
            self.__transaction_logger.log(self.path, addr, addr_size, reg_name, field_name, desc, readback, data_size,
                                          interface_name,
                                          controller_name, field_values, transaction_exc, notes=notes)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc
        return readback

    def __log_poll_transaction(self, addr: int, interface=None, controller=None, update_clive: bool = True,
                               reg_name: str = None,
                               field_name: Union[str, List[str]] = None, desc='POLL (Register)',
                               field_fmt: Union[Callable, List[Callable]] = None, field_value: int = None,
                               reg_value: int = None, notes: str = None, transaction_exc=None, **kwargs):
        interface, controller = self.check_rw_arguments(interface, controller)
        if self.transaction_logging_enable:
            if field_value is not None:
                field_value = field_fmt(field_value)
            addr_size, data_size, interface_name, controller_name = self.__get_log_args(interface, controller, 'read')
            # Write new entry to log file(s)
            self.__transaction_logger.log(self.path, addr, addr_size, reg_name, field_name, desc, reg_value, data_size,
                                          interface_name, controller_name, field_value, transaction_exc, notes)

    def block_write(self, start_addr: int, data: List[int], interface=None, controller=None, **kwargs):
        """
        Writes each value from data to start_addr, incrementing the address with each write.

        :param start_addr: Start address of the block write
        :type start_addr: int
        :param data: List of words to write
        :type data: [List[int]]
        :param interface: Reference to the interface the write will use [OPTIONAL]
        :type interface: [CtrlInterface]
        :param controller: Reference to the controller [**OPTIONAL**]
        :type controller: [HostController, PyroReceiver]
        :return: None
        """
        transaction_exc = None  # Store potential exceptions to enable logging
        try:
            # Check arguments
            if not isinstance(data, list):
                raise TypeError(
                    'Input argument "data" for function block_write expected be type list, received type {type}'.format(
                        type=type(data)))
            if not isinstance(start_addr, int):
                raise TypeError(
                    'Input argument "start_addr" for function block_write expected be type int, '
                    'received type {type}'.format(type=type(start_addr)))
            # Check kwargs for interface and controller
            interface, controller = self.check_rw_arguments(interface, controller)
            # Issue block write
            interface.block_write(host_controller=controller, start_addr=start_addr, write_data=data, **kwargs)
            # Update SCS
            self._update_scs("update_register_block_write", start_addr, data)

        except Exception as e:
            transaction_exc = e
        if self.transaction_logging_enable:
            # Parameters incase interface/controller failed to resolve
            addr_size, data_size, interface_name, controller_name = self.__get_log_args(interface, controller, 'write')
            desc = f"WRITE (Block of {len(data)} word{'s' if len(data) > 1 else ''})"
            self.__transaction_logger.log(self.path, start_addr, addr_size, None, None, desc, str(data),
                                          data_size, interface_name, controller_name, None, transaction_exc)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc

    def block_read(self, start_addr: int, word_count: int, interface=None, controller=None, **kwargs) -> List[int]:
        """
        Reads a block of word_count words starting at start_addr.

        :param start_addr: Start address of the read
        :type start_addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :param interface: Reference to the interface the write will use [OPTIONAL]
        :type interface: [CtrlInterface]
        :param controller: Reference to the controller [OPTIONAL]
        :type controller: [HostController, PyroReceiver]
        :return: List of words read
        :rtype: List[int]
        """
        transaction_exc = None  # Store potential exceptions to enable logging
        result = None  # Readback data
        try:
            if not isinstance(word_count, int):
                raise TypeError(
                    'Input argument "word_count" for function block_read expected to be int'
                    ', received type {type}'.format(type=type(word_count)))
            if not isinstance(start_addr, int):
                raise TypeError(
                    'Input argument "start_addr" for function block_read expected to be int'
                    ', received type {type}'.format(type=type(start_addr)))
            # Check kwargs for interface and controller
            interface, controller = self.check_rw_arguments(interface, controller)
            # Issue block read
            result = interface.block_read(host_controller=controller, start_addr=start_addr, word_count=word_count, **kwargs)
            # Update SCS
            self._update_scs("update_register_block_read", start_addr, result)
        except Exception as e:
            transaction_exc = e
        if self.transaction_logging_enable:
            # Parameters incase interface/controller failed to resolve
            addr_size, data_size, interface_name, controller_name = self.__get_log_args(interface, controller, 'read')
            desc = f"READ (Block of {word_count} word{'s' if word_count > 1 else ''})"
            self.__transaction_logger.log(self.path, start_addr, addr_size, None, None, desc, str(result),
                                          data_size, interface_name, controller_name, None, transaction_exc)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc
        return result

    def chain_write(self, addr: int, data: List[int], interface=None, controller=None, **kwargs):
        """
        Writes each value from data sequentially to single address 'addr'

        :param addr: Address of the chain write
        :type addr: int
        :param data: List of words to write sequentially to addr
        :type data: list
        :param interface: Reference to the interface the write will use [OPTIONAL]
        :type interface: ctrl_interface.CtrlInterface
        :param controller: Reference to the controller [OPTIONAL]
        :type controller: host_controller.HostController
        :return: None
        """
        transaction_exc = None  # Store potential exceptions to enable logging
        try:
            # Check arguments
            if not isinstance(data, list):
                data = [data]
            if not isinstance(addr, int):
                raise TypeError(
                    'Input argument "addr" for function block_write expected be type int, received type {type}'.format(
                        type=type(addr)))
            # Check kwargs for interface and controller
            interface, controller = self.check_rw_arguments(interface, controller)
            # Issue block write
            interface.chain_write(host_controller=controller, reg_addr=addr, write_data=data, **kwargs)
            # Update SCS
            self._update_scs("update_register_chain_write", addr, data)
        except Exception as e:
            transaction_exc = e
        # Log transaction
        if self.transaction_logging_enable:  # This flag mirrors TransactionLogger's is_enabled()
            # Parameters incase interface/controller failed to resolve
            addr_size, data_size, interface_name, controller_name = self.__get_log_args(interface, controller, 'write')
            # Write new entry to log file(s)
            desc = f"WRITE (Chain of {len(data)} word{'s' if len(data) > 1 else ''})"
            self.__transaction_logger.log(self.path, addr, addr_size, None, None, desc, str(data), data_size,
                                          interface_name,
                                          controller_name, None, transaction_exc)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc

    def chain_read(self, addr: int, word_count: int, interface=None, controller=None, **kwargs) -> List[int]:
        """
        Reads a block of word_count words starting at start_addr.

        :param addr: Start address of the read
        :type addr: int
        :param word_count: Number of words to read
        :type word_count: int
        :param interface: Reference to the interface the write will use [OPTIONAL]
        :type interface: ctrl_interface.CtrlInterface
        :param controller: Reference to the controller [OPTIONAL]
        :type controller: host_controller.HostController
        :return: List of words read
        :rtype: list
        """
        transaction_exc = None  # Store potential exceptions to enable logging
        result = None  # Readback data
        try:
            if not isinstance(word_count, int):
                raise TypeError(
                    'Input argument "word_count" for function block_read expected to be int'
                    ', received type {type}'.format(type=type(word_count)))
            if not isinstance(addr, int):
                raise TypeError(
                    'Input argument "addr" for function block_read expected to be int, received type {type}'.format(
                        type=type(addr)))
            # Check kwargs for interface and controller
            interface, controller = self.check_rw_arguments(interface, controller)
            # Issue block read
            result = interface.chain_read(host_controller=controller, reg_addr=addr, word_count=word_count, **kwargs)
            # Update SCS
            self._update_scs("update_register_chain_read", addr, result)
        except Exception as e:
            transaction_exc = e
        # Log transaction
        if self.transaction_logging_enable:  # This flag mirrors TransactionLogger's is_enabled()
            # Parameters incase interface/controller failed to resolve
            addr_size, data_size, interface_name, controller_name = self.__get_log_args(interface, controller, 'read')
            # Write new entry to log file(s)
            desc = f"READ (Chain of {word_count} word{'s' if word_count > 1 else ''})"
            self.__transaction_logger.log(self.path, addr, addr_size, None, None, desc, str(result), data_size,
                                          interface_name, controller_name, None, transaction_exc)
        if transaction_exc:  # Need to raise caught exception
            raise transaction_exc
        return result

    def __get_log_args(self, interface, controller, mode):
        if interface:
            addr_size = getattr(interface, f'{mode}_reg_addr_size')
            data_size = getattr(interface, f'{mode}_reg_data_size')
            interface_name = interface.ref_name
        else:
            addr_size, data_size, interface_name = None, None, None
        controller_name = controller.ref_name if controller else None
        return addr_size, data_size, interface_name, controller_name

    def write_fields_optimized(self, fields: Dict[Field, int]) -> Dict[Register, int]:
        """
        Takes in dictionary of field values and writes those values in the minimum number of register writes

        :param fields: Dictionary containing desired Field values. eg {<Field1 reference>: 3, <Field2 reference>: 1, ..}
        :type fields: Dict[Field, int]
        :return: Dictionary containing the minimal Register writes performed. eg {<Register1 reference>: 1234,
            <Register2 reference>: 6789, ..}

        :rtype: Dict[Register, int]
        """
        # Loop through dictionary and sort fields by register
        regs: Dict[Register, Dict[Field, int]] = {}
        for field, new_value, register in [(field, fields[field], field.container) for field in fields.keys()]:
            if register not in regs:
                regs[register] = {}
            regs[register].update({field: new_value})
        # Loop by register and create new_value and mask for read-modify-write
        for reg, field_dict in regs.items():
            # Aggregate value and mask
            new_value = 0
            mask = 0
            field_values = []
            # Get mask and new field values concatenated
            # Track field properties
            offsets = []
            masks = []
            fmts = []
            field_names = []
            for field, field_value in field_dict.items():
                if field_value > field.max_value:
                    raise ValueError('Value %d too large, can\'t write to %s' % (field_value, field.name))
                new_value |= field_value << field.bit_offset
                mask |= field.mask
                field_values.append(field_value)
                # Add field properties to their resp. lists
                offsets.append(field.bit_offset)
                masks.append(field.mask)
                fmts.append(getattr(field, '_Field__value_to_hex'))
                field_names.append(field.path)

            # Read, mask, or, write
            self.log.debug('Writing %s to register %s' % (hex(new_value), reg.name))
            # Get current reg value (if possible)
            if reg.readable:
                read_value = getattr(reg, '_Register__read_value')
                old_value = read_value(desc='READ (Optimized Modify)', field_name=field_names, field_offset=offsets,
                                       field_mask=masks, field_fmt=fmts)
            else:
                old_value = 0
            # Force bits (CLEAN UP AFTER MERGE)
            if hasattr(register, 'w1x_mask') and register.w1x_mask:
                old_value &= ~register.w1x_mask
            if hasattr(register, 'w0x_mask') and register.w0x_mask:
                old_value |= register.w0x_mask
            old_value &= ~mask  # Clear field values
            new_value |= old_value  # Pull in untouched
            # reg.value = new_value   # Write new value
            # write_value = getattr(reg, '_Register__write_value')
            # write_value(new_value, field_name=field_names, field_value=field_values, desc='WRITE (Optimized)',
            #             skip_verify=True)
            # if self.verify_writes:
            #     reg._verify_reg_write(new_value, desc='READ (Optimized Verify)', field_name=field_names,
            #                           field_offset=offsets, field_mask=masks, field_fmt=fmts)
            self.write_register(reg.addr, new_value, field_name=field_names, field_offset=offsets,
                                field_value=field_values, field_mask=masks, field_fmt=fmts,
                                desc='WRITE (Optimized)', verify_desc='READ (Optimized Verify)',
                                verify_mask=reg.read_mask)
            regs[reg] = new_value  # Replace field dict with register write value for return dictionary
        self.log.debug("Wrote %d fields in %d transactions" % (len(fields), len(regs)))

        return regs  # Return register reference: value dictionary

    def read_fields_optimized(self, fields: List[Field], reg_dict: dict = None) -> Dict[Field, int]:
        """
        Takes in a list of field objects and returns their values using the minimum number of hardware transactions.

        :param fields: list of field references
        :type fields: List[Field]
        :param reg_dict: When an empty dictionary is passed in, this function will populate the dict with the register
            values it read. The keys will be the register objects, and the values will be the register values read.
        :type reg_dict: dict
        :return: Dictionary containing field read data, where the keys are the field objects and the values are the
            field values. eg {<Field1 reference>: 3, <Field2 reference>: 1, ...}
        :rtype: Dict[Field, int]
        """
        return_dict = {}
        # Loop through List and sort fields by register
        regs = {}
        for field, register in [(field, field.container) for field in fields]:
            if register not in regs:
                regs[register] = []
            regs[register].append(field)
        # Loop by register and read + distribute field values
        for reg, field_list in regs.items():
            # Track field properties
            offsets = []
            masks = []
            fmts = []
            field_names = []
            for field in field_list:
                # Add field properties to their resp. lists
                offsets.append(field.bit_offset)
                masks.append(field.mask)
                fmts.append(getattr(field, '_Field__value_to_hex'))
                field_names.append(field.path)

            self.log.debug("Reading %s" % reg.name)
            read_value = getattr(reg, '_Register__read_value')
            reg_value = read_value(field_name=field_names, desc='READ (Optimized)', field_offset=offsets,
                                   field_mask=masks, field_fmt=fmts)
            if isinstance(reg_dict, dict):  # Store register value in debug dictionary
                reg_dict[reg] = reg_value
            for field in field_list:  # Build field value from register value
                return_dict[field] = (reg_value & field.mask) >> field.bit_offset
        self.log.debug('Read %d fields in %d transactions' % (len(fields), len(regs)))
        return return_dict

    def enable_transaction_logging(self, log_file=None, call_stack=True, append=False):
        """
        Starts logging all register and field transactions into csv file.

        :param log_file: path to csv file. If None, logger will track this component under all log files currently open
        :type log_file: str
        :param call_stack: Indicate whether to inspect the call stack to find calling function or not.
            May reduce performance
        :type call_stack: bool
        :param append: **When False:** deletes log_file if it exists and creates an empty log file.

                       **When True and log_file already exists:** the logger will append to the end of the file,
                       keeping previous log entries.
        :type append: bool
        :return: None
        """
        top = self.find_top_level()  # Top level holds attributes for transaction logging
        if not hasattr(top, '_transaction_logger'):  # Create Logger
            top._transaction_logger = TransactionLogger()
        # Track this component
        result = top._transaction_logger.track(self.path, log_file, call_stack, append)
        # Pointer to logger
        self.__transaction_logger = top._transaction_logger
        self.transaction_logging_enable = result

    def disable_transaction_logging(self, log_file=None):
        """
        Stop logging transactions into csv file.

        :param log_file: path to csv file. If None, logger will disable logging for this component under all log files
            currently open
        :type log_file: str
        :return: None
        """
        top = self.find_top_level()  # Top level holds attributes for transaction logging
        logging_enabled = False
        if hasattr(top, '_transaction_logger'):
            # Untrack this component
            logging_enabled = top._transaction_logger.untrack(self.path, log_file)
        self.transaction_logging_enable = logging_enabled

    def reg_match_enable(self, encoder_module_path=None):
        """
        Enables reg map name repair

        :param encoder_module_path: Set to none
        :return: Sets reg_match_enable_flag to True, which enables reg map name repair.
        """
        if encoder_module_path:
            self.encoder_module_path = encoder_module_path
            self.reg_match_enable_flag = True

    def get_required_packages(self):
        """
        PLACE HOLDER

        :return:
        """
        tso_packages = super().get_required_packages()
        tso_packages.update([import_module(block.__class__.__module__) for block in self.blocks.values() if
                             block.__class__.__name__ is not 'Block'])
        return tso_packages

    def generate_id(self, level=1, recursive=True, dbg_dict=None):
        """
        PLACE HOLDER

        :param level:
        :param recursive:
        :param dbg_dict:
        :return:
        """
        base_id = super().generate_id(level, recursive, dbg_dict)
        for fname, block in [(inspect.getfile(block.__class__), block) for block in self.blocks.values() if
                             block.__class__ not in [Block, dict]]:
            module = block.__class__.__module__.partition('.')[0]
            left, sep, right = fname.partition(module)
            with open(fname, 'r', encoding='utf-8') as f:
                fname = ntpath.normpath(sep + right)
                block_sum = sum(bytearray(f.read(), 'utf-8'))
                self.log.dev("Sum of %s: %d" % (fname, block_sum))
                if type(dbg_dict) is dict:
                    block_total = dbg_dict.get(fname, 0)
                    dbg_dict[fname] = block_total + block_sum
                base_id += block_sum
        return base_id

    def embed_test_station(self):
        """
        PLACE HOLDER

        :return:
        """
        self.log.warning("embed_test_station is deprecated: Use test_station.embed_in_controller instead")
        return

    def find(self, substring: str):
        """
        Finds and prints all fields whose names contain 'substring'

        :param substring: [str] substring in field names to search for
        :return: None
        """
        substring = substring.upper()
        field_list = []
        for reg_obj in self.get_all_registers():
            for field in reg_obj.get_fields():
                full_name = field.full_name
                string_position = full_name.find(substring)
                if string_position > -1:
                    field_list.append(field)
        if len(field_list) == 0:
            self.log.info("No matches found for substring: '%s'" % substring)
        else:
            self.log.info("Fields containing '%s':" % substring)
            for field in field_list:
                self.log.print(field.path)

    def poll_bit(self, bit: Field, expected_bit_value: int, timeout_seconds: int) -> Tuple[float, int]:
        """
        Polls field 'bit' for value 'expected_bit_value'. Times out after 'timeout_seconds' seconds

        :param bit: [Field] Field to poll
        :param expected_bit_value: [int] value to wait for
        :param timeout_seconds: [int] wait time
        :return: [Tuple[float, int]] (time elapsed, success) Success = 1 for value hit, 0 for timeout
        """
        self.log.info("Polling %s for value %d" % (bit.path, expected_bit_value))
        time_elapsed = 0
        success = 0
        start_poll_time = time.perf_counter()
        while time_elapsed < timeout_seconds and not success:
            success = int(bit.value == expected_bit_value)
            time_elapsed = time.perf_counter() - start_poll_time
        if success:
            self.log.info('time_elapsed = %.9f seconds' % time_elapsed)
        else:
            self.log.info("Poll timed out after %5f seconds" % time_elapsed)
        return time_elapsed, success

    def reset(self, wait: float = None):
        """
        Performs a reset on the Component

        :param wait: Time in seconds between enter and exit reset. If not specified, uses reset_hold
        :type wait: float
        """
        # perform hardware reset
        self.enter_reset()
        if wait is not None:
            time.sleep(wait)
        else:
            time.sleep(self.reset_time)
        self.exit_reset()

        # notify CLIVE to reset register map
        if self.server_present:
            test_station_obj = self.find_top_level()
            test_station_obj.clive_tcp_client.reset_component(self.ref_name)

    def gen_pyi(self, indent=0, top=False):
        """
        Generates pyi stub information for component. Includes all blocks.

        :param indent: Current nest level
        :type indent: int
        :param top: flag indicating top caller
        :type top: bool
        :return: string containing all members including Blocks
        :rtype: str
        """
        tab = ' ' * 4
        needs_own_file = 'cl_test_station' not in self.__module__ or self._gen_separate_pyi_file
        comp_indent = 0 if needs_own_file else indent
        temp_controller = self.active_controller
        self.active_controller = 1

        pyi_str, imports = super().gen_pyi(indent=comp_indent, top=needs_own_file)
        self.active_controller = temp_controller
        line = re.search('active_controller.*?\n', pyi_str).group(0)
        module, _, cls_name = self.active_controller.class_type.rpartition('.')
        pyi_str = pyi_str.replace(line, 'active_controller:' + cls_name + '\n')
        imports.add((module, cls_name))
        comp_pyi = [pyi_str]
        for block in self.get_blocks():
            comp_pyi.append(block.gen_pyi(indent=comp_indent + 1))
            # Add api imports
            if block.__class__ is not Block:
                imports.add((block.__class__.__module__, block.__class__.__name__))
        # parse aliases after registers so that we can subclass to get field auto-complete
        for key, value in self.aliases.items():
            if isinstance(value, list):  # list or VariList
                start_index = value.start_index if type(value) is VariList else 0
                imports.add(('typing', 'List'))
                ltype = type(value[start_index]).__name__  # Type of value in list
                if ltype == 'dict':
                    imports.add(('typing', 'Dict'))
                    key_type = type(list(value[start_index].keys())[0]).__name__  # Type of key
                    val_type = type(
                        value[start_index][list(value[start_index].keys())[0]]).__name__  # Type of value
                    ltype = 'Dict[' + key_type + ',' + val_type + ']'
                line = [tab, key, ':List[', ltype, ']']
            elif type(value) is dict:
                imports.add(('typing', 'Dict'))
                key_type = type(list(value.keys())[0]).__name__  # Type of key
                val_type = type(value[list(value.keys())[0]]).__name__  # Type of value
                line = [tab, key, ':Dict[', key_type, ',', val_type, ']']
            elif type(value) is Register:
                line = [tab, key, '=', value.path]
            elif type(value) is Field:
                line = [tab, key, '=', value.path]
            else:
                imports.add((value.__class__.__module__, value.__class__.__name__))
                line = [tab, key, ':', value.__class__.__name__]
            comp_pyi.extend(line)
            comp_pyi.append('\n')

        pyi_str = ''.join(comp_pyi)
        # Basic imports required
        imports.update({('cl_test_station.register_map.field', 'Field'),
                        ('cl_test_station.register_map.register', 'Register'),
                        ('cl_test_station.register_map.block', 'Block')})
        if not needs_own_file:
            return pyi_str, imports
        else:  # Write to new file, reference in main pyi string
            self._write_pyi_file(pyi_str, imports)
            return self._get_pyi_reference()

    def serialize(self, top=False, exclude_classes=None, file_path=None, compress=True):
        if exclude_classes is None:
            exclude_classes = ['ValDatabaseTool']
        else:
            exclude_classes.append('ValDatabaseTool')
        base_dict = super().serialize(top=top, exclude_classes=exclude_classes, file_path=None, compress=compress)
        # Serialize all blocks
        blocks = {}
        for block in [block for block in self.get_blocks() if block.name not in self.custom_blocks]:
            blocks[block.name] = block.serialize(compress=compress)
        registers = {}
        # All registers todo: See if this is nec. since all registers will be in a block (NO_BLOCK)
        # for reg in self.get_registers():
        #     registers[reg.name] = reg.serialize(compress=compress)
        base_dict['blocks'] = blocks
        base_dict['registers'] = registers
        base_dict['block_config'] = self.block_config
        base_dict['revision_override'] = self.__get_revision()
        if self._alias_yaml_dict is not None:
            base_dict['_alias_yaml_dict'] = self._alias_yaml_dict
        # Don't need these because regmap data is serialized in dict form
        for key in ['register_map_path', 'register_map_name']:
            try:
                base_dict.pop(key)
            except KeyError:
                pass
        if top:
            base_dict = {self.ref_name: base_dict}
            if file_path is not None:
                if compress:
                    json_string = json.dumps(base_dict)
                else:
                    json_string = json.dumps(base_dict, indent=4)
                with open(os.path.expandvars(file_path), "w") as json_file:
                    json_file.write(json_string)
        return base_dict

    def deserialize(self, block_bin_path, register_bin_path, field_bin_path):
        """
        PLACE HOLDER

        :param block_bin_path:
        :param register_bin_path:
        :param field_bin_path:
        :return:
        """
        f = open(block_bin_path, "rb")
        block_dic = pickle.load(f)
        f.close()
        f = open(register_bin_path, "rb")
        register_dic = pickle.load(f)
        f.close()
        f = open(field_bin_path, "rb")
        field_dic = pickle.load(f)
        f.close()

        for block in self.get_blocks():
            block.encoded_vec = block_dic[block.name]
            for register in block.get_registers():
                register.encoded_vec = register_dic[register.name]
                for field in register.get_fields():
                    field.encoded_vec = field_dic[field.name]

    def alias(self, rev_formatter: Callable = None):
        """
        PLACE HOLDER

        :param rev_formatter: Optional function to format Component revision
        :return: None
        """
        # Can only alias custom blocks
        if self.__class__ is not Component:
            alias(self, self, rev_formatter)  # Now located in reusable

    def _get_diff_url_suffix(self):
        return f"e{self.get_revision()}/register_map/diff/"

    def __download_diff_file(self) -> bool:
        import requests
        from bs4 import BeautifulSoup
        self.diff_url = []
        diff_folder_path = self.diff_file_request_url + self._get_diff_url_suffix()
        page = requests.get(diff_folder_path)
        if page.status_code != 200:
            raise FileDownloadError(f'Diff folder url "{diff_folder_path}" does not exist.')
        soup = BeautifulSoup(page.text, 'html.parser')
        links = soup.find_all('a')
        exclude_list = ['Name', 'Last modified', 'Size', 'Description', 'Parent Directory']

        # Loop through all links on page and create a 2D array.
        # index0= revision numbers (<c4><build_count> ex 37710001), index1=corresponding full link
        revs = [[int(''.join(re.findall(r'\d+', str(link.get('href'))))), link] for link in links if link.string not in
                exclude_list]

        # Find max of revision numbers and find corresponding full link from index 1
        target_rev = str(max(revs)[1].get('href'))
        full_path = ''.join([diff_folder_path, target_rev])  # full url to download diff file from
        if self.get_link(full_path, self.diff_file_name, self.diff_url):
            old_c4 = self.diff_url[0].split("/")[-2][6:10]
            new_c4 = self.get_revision()[0:4]
            local_diff_file_name = f"diff_{old_c4}_{new_c4}.csv"
            self.local_diff_file_path = str(Path(os.path.expandvars(self.diff_file_path)) / local_diff_file_name)
            r = requests.get(self.diff_url[0])
            if r.status_code == 200:
                if os.path.exists(self.local_diff_file_path):
                    os.remove(self.local_diff_file_path)
                with open(self.local_diff_file_path, 'wb') as f:
                    f.write(r.content)
                return True
            else:
                raise FileDownloadError(f"Diff file {full_path}{self.diff_file_name} download failed.")
        else:
            raise FileDownloadError(f"{full_path}{self.diff_file_name} does not exist.")
        return False

    def __get_block_cfg_file(self):
        """
        Attempts to use component's revision to grab block config file. Defaults to grabbing file with base name
        self.block_config_name (defaulted to block_config.yml) if revision does not exist/cannot be obtained.

        :return: Full file path to the found block config file
        :rtype: str
        """
        if os.path.isdir(self.block_config_path):  # Look through this directory
            try:  # Try to get revision
                my_rev = self.__get_revision()
            except Exception as e:  # Failed, ignore revison and look for base file
                self.log.debug("get_revision Exception: %s" % e)
                my_rev = ''
            cfg_fname = get_revision_file(self.block_config_path, self.block_config_name, my_rev)
            if cfg_fname is not None:  # A file was found
                self.log.info("Using block config from '%s'" % os.path.basename(cfg_fname))
                return cfg_fname
            else:  # Could not find file
                self.log.info("No block config specified or found, all blocks will be generic")
                return None
        else:
            if not self.block_config_path == os.path.join(os.path.dirname(inspect.getfile(Component)), 'block_configs'):
                self.log.info(f"Block config path not found: {self.block_config_path}")
            return None

    def __parse_block_map(self, block_config):
        block_map = {}
        # Populate block map dictionary with tuple containing ref name and the dotpath to the class
        for ref_name, value in block_config.items():
            config = value.copy()
            if 'regmap_name' in config:  # This block is mapped
                class_type = config.pop('class_type')
                regmap_name = config.pop("regmap_name")
                block_map[regmap_name] = (ref_name, class_type, config)
            else:  # This block is custom
                if 'base_addr' not in config:
                    config['base_addr'] = None
                self.custom_blocks[ref_name] = config
        return block_map

    def __parse_val_csv(self, regmap_file):
        with open(regmap_file, 'r', encoding='utf-8', errors='ignore') as csvfile:
            csv_reader = csv.DictReader(csvfile, delimiter=',')
            # Each row in the CSV is a register field, so we will need to iterate through each row and create the
            # block, register, field if they do not already exist in the object
            for row in csv_reader:
                # The block name is in the register name separated by a '.'. Example: <block name>.<reg name>
                reg_name = row['REG NAME']
                # Check if a block actually exists in the name
                if '.' not in reg_name:
                    reg_name = 'NO_BLOCK.' + reg_name.upper()
                    row['REG NAME'] = reg_name
                block_name = reg_name.split('.')[0].upper()
                per_exists = False
                this_block = None
                for block in self.get_blocks():
                    if block_name == block.name:
                        per_exists = True
                        this_block = block
                        break
                if not per_exists:
                    if block_name in self.block_map:  # This block is mapped
                        ref_name, class_type, kwargs = self.block_map[block_name]
                        module_name, _, class_name = class_type.rpartition('.')
                        block_module = import_module(module_name)
                        block_cls = getattr(block_module, class_name)
                        # Instantiate specific class
                        this_block = block_cls(block_name, None, self, self.log, **kwargs)
                    else:
                        # Instantiate generic block class
                        ref_name = block_name
                        this_block = Block(block_name, None, self, self.log)
                    self.blocks[block_name] = this_block
                    setattr(self, ref_name, this_block)
                this_block.parse_val_csv(row)
                # Create Field alias if necessary
                if self.create_rtl_aliases:
                    # Get Field RTL name
                    field_rtl_name = row.get('FIELD RTL NAME', '').replace('.', '_')
                    field_path = row.get('FIELD NAME', '').replace('[', '').replace(']', '').upper()
                    field = self.resolve_path(field_path, start_from_top=False)
                    reg_rtl_name = row.get('REG RTL NAME', '').replace('.', '_')
                    reg_path = row.get('REG NAME', '').replace('[', '').replace(']', '').upper()
                    reg = self.resolve_path(reg_path, start_from_top=False)
                    if field_rtl_name and field:  # Create alias
                        self.aliases[field_rtl_name] = field
                        setattr(self, field_rtl_name, field)
                    if reg_rtl_name and reg and reg not in self.aliases:
                        self.aliases[reg_rtl_name] = reg

    def __parse_wisce_xml(self, regmap_file):
        """
        Parses the contents inside the XML file passed in to extract the registers. Since
        the WISCE format does not have the concept of blocks, block objects will not be created.

        :return:
        """
        parser = ET.XMLParser(encoding="utf-8")
        with open(regmap_file, 'r', encoding='utf-8') as regfile:
            xmlstring = regfile.read()
            xmlstring = xmlstring.replace(' & ', ' and ')
            root = ET.fromstring(xmlstring, parser=parser)

        # Create dummy block since the WISCE file does not support blocks
        dummy_block = Block('NO_BLOCK', 0, self, self.log)
        self.blocks['NO_BLOCK'] = dummy_block
        setattr(self, 'NO_BLOCK', dummy_block)
        register_nodes = root.find('Registers').findall('Register')
        for register in register_nodes:
            # Create register objects here
            reg_name = register.find('Name').text.upper()
            reg_addr = int(register.find('Address').text, 16)  # Hex format
            reg_rst_val = 0  # WISCE file doesnt seem to have reset values
            new_reg = Register(reg_name, reg_addr, reg_rst_val, dummy_block)
            new_reg.parse_wisce_xml(register)
            setattr(dummy_block, new_reg.name.upper(), new_reg)
            dummy_block.registers[new_reg.name.upper()] = new_reg
            for field in new_reg.get_fields():
                # Flatten the field name
                flat_field_name = '%s__%s__%s' % (field.name, field.container.container.name, field.container.name)
                setattr(self, flat_field_name, field)

    def __parse_svd_xml(self, regmap_file):
        """
        Parses the contents inside the XML node passed in to extract the blocks.
        It is assumed that the XML node is from the SVD format of the register map XML file

        :return:
        """
        # This is temporary because there is an odd escape character that the xml parser doesn't know how to handle
        with open(regmap_file, 'r') as svd_file:
            svd_text = svd_file.read()
            svd_text = svd_text.replace('&lt;', '')
            svd_text = svd_text.replace('&gt;', '')
            svd_text = svd_text.replace('&amp;', '')
        svd_text = html.parser.unescape(svd_text)
        root = ET.fromstring(svd_text)
        ip_blocks_node = root.find('peripherals')
        ip_blocks = ip_blocks_node.findall('peripheral')

        for ip_block in ip_blocks:
            # Extract the relevant information from the block
            ip_name = ip_block.find('name').text.upper()
            ip_base_addr = int(ip_block.find('baseAddress').text, 16)
            # Check to see if block has a dedicated class
            if ip_name in self.block_map:
                # Instantiate specific class
                ref_name, class_type, kwargs = self.block_map[ip_name]
                module_name, _, class_name = class_type.rpartition('.')
                block_module = import_module(module_name)
                block_cls = getattr(block_module, class_name)
                new_ip = block_cls(ip_name, ip_base_addr, self, self.log, **kwargs)
            else:
                # Instantiate generic block class
                ref_name = ip_name
                new_ip = Block(ip_name, ip_base_addr, self, self.log)
            new_ip.parse_svd_xml(ip_block.find('registers'))
            self.blocks[ip_name] = new_ip
            setattr(self, ref_name, new_ip)

    def __parse_block_dict(self, block_dict):
        for block_name, config in block_dict.items():
            kwargs = {}
            base_addr = None
            custom_block = False
            if block_name in self.block_map:
                ref_name, class_type, block_config = self.block_map[block_name]
                kwargs = block_config.copy()
                container = self
                if 'base_addr' in kwargs:
                    base_addr = kwargs.pop('base_addr')
                module_name, _, class_name = class_type.rpartition('.')
                block_module = import_module(module_name)
                block_cls = getattr(block_module, class_name)
            elif block_name in self.custom_blocks:
                custom_block = True
                ref_name = block_name
                kwargs = config.copy()
                container = self.block_apis
                class_type = kwargs.pop('class_type')
                module_name, _, class_name = class_type.rpartition('.')
                block_module = import_module(module_name)
                if 'base_addr' in kwargs:
                    base_addr = kwargs.pop('base_addr')
                block_cls = getattr(block_module, class_name)
            else:
                ref_name = block_name
                container = self
                block_cls = Block
                base_addr = config['base_addr']
            if '_alias_yaml_dict' in config:
                kwargs['_alias_yaml_dict'] = config['_alias_yaml_dict']
            block = block_cls(block_name, base_addr, container, self.log, component=self, **kwargs)
            if custom_block:
                self.block_apis[block_name] = block
            else:
                self.blocks[block_name] = block
                setattr(self, ref_name, block)
            if 'registers' in config:
                block.parse_register_dict(config['registers'])

    def __parse_register_dict(self, reg_dict):
        Block.parse_register_dict(self, reg_dict)

    def __flatten_fields(self):
        """
        Creates attributes in the class that reference all of the fields with a flattened name. This is to make
        searching using auto-complete easier. The format is <field_name>__<block_name>__<register_name>

        :return:
        """
        for block in self.get_blocks():
            for register in block.get_registers():
                for field in register.get_fields():
                    # Flatten the field name
                    flat_field_name = '%s__%s__%s' % (block.name, register.name, field.name)
                    self.flattened_fields[flat_field_name] = field

    class WriteFieldsOptimizer(TsContextManager):
        """**For 'with' block optimized field writes.**

         Usage: https://docs.cirrus.com/display/VT/Register+and+Field+Access"""

        def __enter__(self):
            self.field_writes, err = parse_field_writes(self.lines, self.globals, self.locals)
            if type(self.field_writes) is int and err != '':
                self.raise_exc(Exception, err, self.field_writes)
            self.log.debug(self.field_writes)
            self.activate()
            return self

        def __exit__(self, exc_type, exc_val, exc_tb):
            self._active = False
            sys.stdout = self.stdout_save
            self.restore_aliases()
            # Check every write has same component
            component = None
            for field in self.field_writes.keys():
                if component is None:
                    component = field.container.container.container
                elif component is not field.container.container.container:  # Diff component, error
                    raise TypeError("Field list has Fields from multiple components (%s, %s)" %
                                    (component.ref_name, field.container.container.container.ref_name))
            # Write fields
            # todo: change name to path when merged
            self.log.debug(
                "Writing Fields: %s" % ', '.join([f.name + ' = ' + hex(v) for f, v in self.field_writes.items()]))
            component.write_fields_optimized(self.field_writes)

    class ReadFieldsOptimizer(TsContextManager):
        """**For 'with' block optimized field reads.**

            Usage: https://docs.cirrus.com/display/VT/Register+and+Field+Access"""

        def __init__(self, read_dict):
            super().__init__()
            self.read_dict = read_dict

        def __enter__(self):
            self.field_reads, err = parse_field_reads(self.lines, self.globals, self.locals)
            if type(self.field_reads) is int and err != '':
                self.raise_exc(Exception, err, self.field_reads)
            self.log.debug(self.field_reads)
            self.activate()
            return self

        def __exit__(self, exc_type, exc_val, exc_tb):
            self._active = False
            # sys.stdout = sys.__stdout__
            sys.stdout = self.stdout_save
            self.restore_aliases()
            # Check every write has same component
            component = None
            for field in self.field_reads:
                if component is None:
                    component = field.container.container.container
                elif component is not field.container.container.container:  # Diff component, error
                    raise TypeError("Field list has Fields from multiple components (%s, %s)" %
                                    (component.ref_name, field.container.container.container.ref_name))
            # Read fields
            self.log.debug("Reading Fields: %s" % ', '.join([f.path for f in self.field_reads]))
            self.read_dict.update(component.read_fields_optimized(self.field_reads))
