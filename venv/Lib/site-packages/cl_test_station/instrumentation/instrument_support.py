import time
import Pyro5
import Pyro5.api
import Pyro5.client
import sys
import socket
from multiprocessing import Pipe, Lock, Process
from cl_test_station.pyro_support.pyro_receiver import PyroReceiver
from cl_test_station.utilities.reusables import get_station_ip, LOCALHOST

try:
    import unified_modules.test_support.testlogger as logging
except ImportError:
    import logging


class bcolors:
    """**PLACE HOLDER!**"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


@Pyro5.api.expose
class InstrumentServerControl:
    """**Constructs the Instrument list, and shutdown function list.**"""

    def __init__(self, instrument_list, daemon=None):
        self.shutdown_function_list = {}
        for key in instrument_list:
            instrument = instrument_list[key]
            self.shutdown_function_list.update(instrument.shutdown_function_list)

        if type(instrument_list) is dict:
            self.instrument_list = []
            for instrument in instrument_list:
                if 'State' in instrument_list[instrument].config:
                    if instrument_list[instrument].config['State'].upper() == "NOT FOUND":
                        continue
                self.instrument_list.append(instrument)
        else:
            self.instrument_list = list(instrument_list)
        self.daemon = daemon

    def get_instrument_list(self):
        """**Returns the instrument list.**"""
        return self.instrument_list

    @Pyro5.api.oneway
    def shut_me_down(self):
        """
        This function can be called through Pyro to request a remote shutdown.
        The self.daemon needs to point to the Pyro daemon so we can tell it to shut down.
        This function is a Pyro "one way" function meaning the server tells the client
        not to wait for a response, because the server will shut down immediately.

        :return: None
        """
        print(' ** InstrumentServerControl :: SHUTTING DOWN **')
        for shutdown_function_name in self.shutdown_function_list:
            print(' -> {}'.format(shutdown_function_name))
            shutdown_function_pointer, args, kwargs = self.shutdown_function_list[shutdown_function_name]
            shutdown_function_pointer(*args, **kwargs)
        if self.daemon is not None:
            print(" -> Pyro daemon")
            # aa_close(self.aard.aardvark_handle)  # I don't quite remember now why I commented this,
            # I think because __del__ function already calls it as well.
            self.daemon.shutdown()
            self.daemon.close()
        else:
            print(' -> Unable to shut down Pyro, daemon handle is not set')


def ap_worker_thread(child_conn):
    """
    This function needs to be kicked off in its own dedicated thread.
    This will be the singular thread that communicates to the AP.
    The function will instantiate an instance of the AP_WORKER_CLASS and wait for commands
    to be received through the child_conn.
    This function will wait for commands indefinitely.
    It only exits when it receives the '__shut__me__down__' command.

    :param AP_WORKER_CLASS: Pointer to AP_WORKER class
    :param child_conn: child_conn from multiprocessing Pipe library
    :return: Instantiates an instance of the AP_WORKER_CLASS
    """
    # ap = AP_WORKER()
    from ap2700 import ap
    keep_going = True
    while keep_going:
        if child_conn.poll(None):
            do_this = child_conn.recv()
            if do_this[0] == '__shut__me__down__':
                keep_going = False
            else:
                result = ap.run_function(do_this[0], *do_this[1], **do_this[2])
                child_conn.send(result)


@Pyro5.api.expose
class AP_INTERFACE:
    """
    This is the class that can be exposed to the outside world through Pyro.
    Unlike the AP_WORKER class you can safely run this in a multi threaded environment.
    This class doesn't do any real work, it just passes requests from Pyro clients to
    the worker through the multiprocessing pipe and it asserts thread safety.
    """

    def __get_register_list__(self):
        """
        This function returns the list of functions that's available

        :param args: Can be left blank
        :param kwargs: Can be left blank
        :return: Dictionary with all available functions.
        """
        if not hasattr(self, 'register_list'):
            self.read_register_list()
        return self.register_list

    def __get_atttribute_set__(self):
        return set()

    def read_register_list(self):
        """
        Reads the list of functions that are available acquired from __get_register_list__.

        :return: Register_list gets all available functions.
        """
        args = []
        kwargs = {}
        self.lock.acquire()  # Acquire lock for thread safety
        self.parent_conn.send(["__get_register_list__", args, kwargs])  # Call get register list
        self.parent_conn.poll(None)  # Wait for response

        return_value = self.parent_conn.recv()  # Receive response
        self.lock.release()  # Release lock
        self.register_list = return_value
        # self.register_list={}
        # for registername in return_value:
        #     self.register_list.update({
        #         registername : '*args, **kwargs'
        #     })
        return return_value

    def shut_me_down(self):
        """**Terminates the process.**"""
        self.parent_conn.send(['__shut__me__down__', [], {}])
        time.sleep(2)
        self.ap_process.join(2)  # Give the process 2 more seconds to shut down
        self.ap_process.terminate()  # Then terminate

    def __init__(self, pipe, lock):
        """
        Class constructor. Does not do anything other than receive pipe and lock

        :param pipe: Multiprocessing Pipe received from parent connection.
        :param lock: Multiprocessing lock , to ensure thread safety.
        """
        self.parent_conn, self.child_conn = pipe
        self.ap_process = Process(target=ap_worker_thread, args=(self.child_conn,))
        self.ap_process.start()
        self.lock = lock
        time.sleep(2)
        self.read_register_list()

    def run_function(self, function_to_run, *args, **kwargs):
        """
        Run named function. The list of available functions can be obtained through the
        __get_register_list__ function

        :param function_to_run: String with function name
        :type function_to_run: str
        :param args: Tuple with arguments
        :type args: tuple
        :param kwargs: Dictionary with keyword arguments.
        :type kwargs: dict
        :return: Returns whatever the function returned.
        """
        if function_to_run[0:4] == 'map.':
            function_to_run = function_to_run[4:]
        self.lock.acquire()
        self.parent_conn.send([function_to_run, args, kwargs])
        self.parent_conn.poll(None)

        return_value = self.parent_conn.recv()
        self.lock.release()
        return return_value

    def check_alive(self, running, hung):
        """
         Check_alive is called by the launcher GUI.
         You pass two parameters, "running" and "hung". These values can be anything you like.
         Depending on the state it will return one or the other value , so it confirms two-way communication.
         The function will try to get a lock with a 1 second timeout. If it fails, the "hung" value will be
         returned. If it passes, the "running" value will be returned.
         Since Pyro is multi threaded, this function will still work even if another thread is hung.

         :param running: Value to return when running
         :param hung: Value to return when hung.
         :return: Returns "running" or "hung" value.
         """
        success = self.lock.acquire(timeout=1)
        if success:
            self.lock.release()
            return running
        else:
            return hung

    def getattributes(self):
        """Place Holder"""
        pass

    def setattribute(self, key, value):
        """Place Holder"""
        pass


def ap2700_initialize():
    """**Returns call to the AP_INTERFACE: the class constructor.**"""
    if len(sys.argv) == 0:
        sys.argv = ['']  # somehow the Process library crashes when sys.argv is empty
    return AP_INTERFACE(Pipe(), Lock())


def get_instruments_from_pyro(ns_port):
    """**Returns the instruments in dictionary format.**"""
    inst_dict = {}
    ip_addr = LOCALHOST  # get_station_ip()
    ns = Pyro5.api.locate_ns(host=ip_addr, port=ns_port)
    instrument_server = Pyro5.client.Proxy(ns.lookup('instrument_server'))
    instrument_server._pyroReconnect()
    instrument_list = instrument_server.get_instrument_list()
    instrument_handles = {}
    for instrument in instrument_list:
        instrument_handles[instrument] = {'tcp_interface': Pyro5.client.Proxy(ns.lookup(instrument))}
        instrument_handles[instrument]['tcp_interface']._pyroReconnect()
        new_client = PyroReceiver(
            instrument,
            instrument_handles[instrument]['tcp_interface'],
            debugprintlevel=0
        )
        instrument_handles[instrument]['reg_interface'] = new_client
        inst_dict[instrument] = new_client
    return inst_dict
