import os
from multiprocessing import Lock
from cl_test_station.test_station_object import TestStationObject
from cl_test_station.instrumentation.instrument_support import bcolors
from cl_test_station.instrumentation.instrument_support import InstrumentServerControl
from cl_test_station.pyro_support.pyro_transmitter import PyroTransmitter


class Instrument(TestStationObject):
    """**PLACE HOLDER**"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.shutdown_function_list = {}
        self.idn = ''

    def construct_objects(self, *args, specific_class=None, **kwargs):
        self.__construct_instrument()

    def __construct_instrument(self, shutdown_function_list={}):
        import instmngr
        self.shutdown_function_list = shutdown_function_list
        if 'COM' in self.config['Interface']:
            # instmngr_instance = instmngr.InstMgr(resource_driver_dict={self.config['Interface']: 'supply_PSI9040'})

            # Note this a work around to the fact that for COM instruments we must supply the full module name
            # of the driver to the InstMngr __init__, therefore the yml file must supply the full name. But that causes
            # a problem later with the matching process that uses just the suffix.

            if self.config['Type'] == 'PSI9040':   # Existing Mahoney yml files are just supplying the suffix for this.
                self.config['Type'] = 'supply_PSI9040'

            instmngr_instance = instmngr.InstMgr(resource_driver_dict={self.config['Interface']: self.config['Type']})

            self.config['Address'] = None   # Matches PyVISA instmngr_instance is None for COM, so ignore yml value.
        else:
            instmngr_instance = instmngr.instMgr

        # Makes matching work regardless of yml file providing full driver module name or just the suffix.
        self.config['Type'] = self.config['Type'].split('_')[-1]  # Matching below requires the suffix.

        self.config['State'] = 'NOT FOUND'
        if 'Required' not in self.config:
            self.config['Required'] = 'No'
        for instmgr_instrument_data in instmngr_instance.instrument_list:
            address_match = False
            update_address = False
            if self.config['Address'] == '*':
                address_match = True
                update_address = True
            if self.config['Address'] == instmgr_instrument_data['addr']:
                address_match = True

            bus_match = False
            update_bus = False
            if self.config['Interface'] == '*':
                bus_match = True
                update_bus = True
            if self.config['Interface'] in instmgr_instrument_data['bus']:
                bus_match = True

            if self.config['Type'] == instmgr_instrument_data['moduleSuffix'] and \
                    address_match and \
                    bus_match:
                if instmgr_instrument_data['in_use'] == '':
                    instmgr_instrument_data['in_use'] = 'yes'
                    if update_address:
                        self.config['Address'] = instmgr_instrument_data['addr']
                    if update_bus:
                        self.config['Interface'] = instmgr_instrument_data['bus']
                else:
                    print('Duplicate instrument match!')

                self.config['State'] = 'FOUND'

        # Now that we cross checked the lists, we go initialize all the instruments and build the interfaces
        # If the instrument does not connect to a VISA-supported port, it will not show up in the
        # instrument manager. In that case we will need to have some library that we can

        if self.config['Interface'].upper() == 'API':  # Instruments with API are accessed through some Python library
            if self.config['Type'].upper() == 'AP2700':
                from .instrument_support import ap2700_initialize
                instrument_instance = ap2700_initialize()
                self.shutdown_function_list.update({
                    'ap2700': [instrument_instance.shut_me_down, [], {}]  # function, args, kwargs
                })
                self.config['State'] = 'FOUND'
                self.config.update({
                    'instance': instrument_instance,
                    'host_if': instrument_instance
                })
            else:
                print(bcolors.WARNING + 'API for instrument {} not found!'.format(self.config['Type']))
        else:  # All other instruments are accessed through the instrument manager
            if 'Required' in self.config and 'State' in self.config:
                if self.config['Required'].upper() == 'YES' and \
                        self.config['State'] == 'NOT FOUND':
                    raise RuntimeError('Required instrument {} not found!'.format(self.ref_name))
            for instmgr_instrument_data in instmngr_instance.instrument_list:
                if self.config['Type'] == instmgr_instrument_data['moduleSuffix'] and \
                        self.config['Address'] == instmgr_instrument_data['addr'] and \
                        self.config['Interface'] in instmgr_instrument_data['bus']:
                    instmgr_instrument_data['in_use'] = 'yes'
            if self.config['Interface'] == '*' or self.config['Address'] == '*':
                print(bcolors.WARNING + 'Warning: Instrument {} with wildcard interface/address was not found!'.format(
                    self.config['Type']) + bcolors.ENDC)
            elif self.config['State'] == 'NOT FOUND':
                print(bcolors.WARNING + 'Warning: Instrument {} was not found!'.format(self.ref_name) + bcolors.ENDC)
            else:
                instrument_instance = instmngr_instance.checkout(
                    interface=self.config['Interface'],
                    addr=self.config['Address'],
                    moduleSuffix=self.config['Type'],
                    objName=self.ref_name
                )
                self.config.update({'instance': instrument_instance})

                self.config.update(
                    {
                        'host_if': PyroTransmitter
                            (
                            self.config['instance'],
                            Lock(),
                            '',
                            0,  # debug print level
                            2,  # max_depth
                            self.ref_name,
                            'map.'
                        )
                    }
                )
        # if(self.config['State'] == 'FOUND'):
        #     self.config['host_uri'] = daemon.register(self.config['host_if'])
        #     ns.register(self.ref_name, self.config['host_uri'])
        #     print(': {}  = instrument type {} at address {}:{}'.format(
        #         self.ref_name,
        #         self.config['Type'],
        #         self.config['Interface'],
        #         self.config['Address']
        #     ))

    def serialize(self, top=False, exclude_classes=None, file_path = None):
        return {}

    def generate_id(self, *args, **kwargs):
        return 0


if __name__ == "__main__":
    from pathlib import Path
    import yaml

    os.environ['PACKAGE_ROOT'] = r'C:\validation\Projects\Mahoney\python\mahoney_venv\src\cl-test-station'
    this_path = Path(__file__).resolve().parent
    test_yaml = this_path / 'example_yaml' / 'system_config_example.yml'
    extra_paths = [os.path.expandvars(r'$PACKAGE_ROOT\cl_test_station\board\test_input\test_peripherals')]
    # extra_paths.append(r'C:\validation\Projects\Mahoney\mahoney_test_env\src\cl-test-station\cl_test_station\board\ctrl_interface')
