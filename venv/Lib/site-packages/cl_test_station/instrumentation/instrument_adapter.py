"""
Module for cl_instr_lib -> cl_test_station adapter.

Author: Evan Canter <evan.canter@cirrus.com>
"""
import os
import shutil
import traceback
from pathlib import Path
from typing import List, Dict

from cl_instr_lib.base_classes.instrument import Instrument
from cl_instr_lib.base_classes.pyro_isinstance import InstrumentType

from cl_test_station.test_station_object import TestStationObject, InvalidTsobject, TsoField
from cl_test_station.utilities.reusables import import_class_from_path


class InstrumentAdapter(TestStationObject):
    """Adapter class that handles construction of instrument drivers and integrates them into the TestStation"""

    template: str = TsoField(ftype=str, required=False, default='', desc='Template file to copy if "config_file" '
                                                                         'field does not exist.')

    def __init__(self, *args, pyro_handle=None, **kwargs):
        self.instruments = {}  # Internal list to store instrument instances. {name: instance}
        self._pyro_handle = pyro_handle  # This will indicate whether the adapter is local or part of server

        copied_template = False
        # Need to remove instrument definitions since those already got instantiated in the server
        if self.uses_pyro:
            if 'config_file' in kwargs:
                kwargs.pop('config_file')
            if 'config_files' in kwargs:
                kwargs.pop('config_files')
        # Copy template file if config file does not exist
        elif 'config_file' in kwargs and not os.path.isfile(os.path.expandvars(kwargs['config_file'])):
            if 'template' not in kwargs:  # Need template to copy, so raise error
                raise KeyError("'template' field not specified in YAML, cannot create config file")
            config_file = Path(os.path.expandvars(kwargs['config_file']))
            template_file = Path(os.path.expandvars(kwargs['template']))
            if not template_file.is_file():
                raise FileNotFoundError(f"Cannot find template file '{template_file}'")
            # Create subdirectories if necessary
            if not config_file.parent.is_dir():
                os.makedirs(config_file.parent)
            # Copy template to config_file
            shutil.copy(template_file, config_file)
            copied_template = True

        # TestStationObject __init__ expands config_files automatically
        super().__init__(*args, **kwargs)

        # Now that log is available, notify that template was copied
        if copied_template:
            self.log.warning(f"Copied template '{template_file.name}' to config file: '{config_file.name}'")

        # Get all driver classes from CL Instrument Library
        self._inst_classes = {}
        try:
            import cl_instr_lib.drivers as drivers
            path = os.path.dirname(drivers.__file__)
            self._inst_classes.update(self.load_classes_from_path(path, drivers.__package__, base_cls=Instrument))
        except (ImportError, ModuleNotFoundError):
            self.log.exception("Unable to import cl_instr_lib, all drivers from this package will be unavailable.")

    @property
    def uses_pyro(self) -> bool:
        """
        Returns whether the adapter is local or part of the clts server

        :returns: self._pyro_handle is not None
        :rtype: bool
        """
        return self._pyro_handle is not None

    def check_config(self, inst_cfg: Dict):
        """
        Checks each instrument config and makes sure the driver_class and address fields are present and valid.

        :param inst_cfg: instrument adapter configuration dictionary (self.config)
        :type inst_cfg: dict
        :return: None
        :rtype: None
        """
        for inst_name, config in inst_cfg.items():
            if not isinstance(config, dict):
                continue
            if 'driver_class' not in config:  # verify driver_class is present
                message = f"'driver_class' not found in {inst_name} configuration. Please check the instrument " \
                          f"configuration YAML file."
                self.log.error(message)
                raise KeyError(message)
            else:
                # verify driver_class is valid type
                # ToDo: PLATDEV-1494: Update to only support package path definition
                class_name = config['driver_class']
                dotted = '.' in class_name
                if not dotted and class_name not in self._inst_classes:
                    # not present in cl-instr-lib and no periods for importing,
                    message = f"driver_class={class_name} is not a supported instrument."
                    self.log.error(message)
                    raise KeyError(f"{message} Supported Instruments: {', '.join(self.get_driver_names())}")
                elif dotted:
                    # attempt to import instrument
                    try:
                        instr_class = import_class_from_path(class_name)
                    except (ModuleNotFoundError, AttributeError):
                        message = f"Unable to import instrument {class_name}. Please check spelling or that package is installed."
                        self.log.error(message)
                        raise ImportError(message)
                    # verify that class is an Instrument
                    if not isinstance(instr_class, InstrumentType):
                        message = f"{class_name} is not an Instrument."
                        self.log.error(message)
                        raise ImportError(message)
                    # insert imported class into look-up
                    package_path, sep, class_name = class_name.rpartition('.')
                    self._inst_classes[class_name] = instr_class

            # verify address is present
            if config['driver_class'].rpartition('.')[2] not in ['Apx', 'Ap2700'] and 'address' not in config:
                message = f"'address' not found in {inst_name} configuration. Please check the instrument configuration" \
                          f" YAML file."
                self.log.error(message)
                raise KeyError(message)

    def configure(self, config, *args, **kwargs):
        """
        Configures the instrument adapter.

        :param config: Configuration dictionary
        :type config: dict
        :return: None
        :rtype: None
        """
        if self.uses_pyro:  # Need to remove instrument definitions since those already got instantiated in the server
            for key, value in self.config.items():
                if type(value) is dict:
                    self.config[key] = None   # Need to remove these so that instruments don't get constructed
            if 'config_file' in self.config:  # ^ Same for config file drop-in
                self.config.pop('config_file')
            if 'config_files' in self.config:
                self.config.pop('config_files')
        super().configure(self.config, *args, **kwargs)  # Will only set fields (like raise_handles)

    def construct_objects(self, *args, **kwargs):
        """
        Loops through dictionary entries from YAML config and attempts to construct instruments.

        :return: None
        :rtype: None
        """
        import visa
        super().construct_objects()  # instrument attributes will temporarily be their config dictionaries
        self.check_config(self.config)  # Check config

        # Go though config dictionary, grab all handles and create drivers
        for inst_name, config in self.config.items():
            if type(config) is not dict:  # Skip normal fields
                continue
            # ToDo: PLATDEV-1494: Update to only use package path definition and import_class_from_path
            driver_class = config['driver_class']
            if '.' in driver_class:
                package_path, sep, driver_class = driver_class.rpartition('.')
            inst_cls = self._inst_classes[driver_class]
            trace = ''
            try:
                # TODO: Make this better
                if inst_cls.__name__ in ['Apx', 'Ap2700']:
                    inst = inst_cls(**config)
                else:
                    address = config['address']
                    inst = inst_cls(address)
            except visa.VisaIOError:
                self.log.exception(f"{inst_name}: failed to open resource {address}. Please check that the instrument "
                                   f"is present in system")
                trace = traceback.format_exc()
            except Exception:
                self.log.exception("Failed to instantiate instrument %s (%s)" % (inst_name, config['driver_class']))
                trace = traceback.format_exc()
            if trace:  # There was an error, create InvalidTsobject with traceback
                self.__setattr__(inst_name, InvalidTsobject(inst_name, trace, self.log))
            else:  # No errors, setattr normally
                self.__setattr__(inst_name, inst)
                self.instruments[inst_name] = inst

        if self.uses_pyro:  # Grab all instrument PyroReceivers from 'instruments' and use setattr to 'construct' them
            self.get_instruments_from_pyro(self._pyro_handle)
        else:
            # Print out driver names to the server
            if self.instruments:
                self.log.info("Instrument drivers:")
                name_just = len(max(self.instruments.keys(), key=len))
                driver_just = len(max([d.__class__.__name__ for d in self.instruments.values()], key=len))
                for name, inst in self.instruments.items():
                    self.log.info("   %s: %s at address %s" % (name.rjust(name_just),
                                                               inst.__class__.__name__.ljust(driver_just),
                                                               inst.resource_name))
            else:
                self.log.info('No instruments currently defined')

    def get_instruments_from_pyro(self, pyro_handle):
        """
        Grabs visa resource pyro objects from server and creates local driver instances

        :param pyro_handle: Reference to the PyroReceiver for the server-side adapter class
        :return: None
        """
        for inst_name in pyro_handle.get_instrument_names():
            try:
                # Grab the rm_handle PyroReceiver object from the test_station level
                rm_handle = getattr(self.find_top_level(), f'_server_instruments_{inst_name}')
            except AttributeError:  # This instrument must be in simulation mode
                rm_handle = None
            # Use the instance name to get the name of the Driver class
            driver_name = self.get_class_by_name(inst_name)
            # Instantiate local driver and pass in PyroReceiver rm_handle
            if driver_name in self._inst_classes:
                driver_cls = self._inst_classes[driver_name]
            else:
                # TODO: Unsure if it's possible to hit this line.
                driver_cls = import_class_from_path(self.get_driver_path_by_name(inst_name))
            driver = driver_cls(rm_handle=rm_handle)
            self.__setattr__(inst_name, driver)
            self.instruments[inst_name] = driver

    def get_driver_names(self) -> List[str]:
        """
        Gets list of driver names available from instrument package.

        :return: List of strings corresponding to driver class names.
        """
        drivers = list(self._inst_classes.keys())
        drivers.sort()  # Alphabetize
        return drivers

    def dump_driver_names(self):
        """
        Prints all loaded classes from instrument package to the screen

        :return: None
        """
        self.log.info("Dumping instrument driver names")
        self.log.info_line('=')
        m_len = len(max(self._inst_classes.keys(), key=len))  # Length of longest driver name for justification
        for inst_name, inst_cls in sorted(self._inst_classes.items()):
            extra = ''
            if inst_cls.__doc__ is not None:  # Docstring right below the class definition
                extra = inst_cls.__doc__.split('\n')[0]
                extra = ' - ' + extra
            self.log.info(inst_name.rjust(m_len) + extra)
        self.log.info_line('=')

    def dump_visa_resources(self, idn=False, idn_ifaces=None):  # could not use default list value as it caused issues with Pyro
        """
        Display all available VISA resources by interface and logs them as INFO. Optionally, you can attempt to send a
        **IDN?** query to get additional information of the instruments for they interfaces types listed in idn_ifaces

        :param idn: send *IDN*? queries to the instruments. **Default false**
        :type idn: Boolean
        :param idn_ifaces: List of interfaces preform *IDN*? query on.

            **- Default ['GPIB', 'USB'].**

            **- Options are GPIB, USB, COM, & TCPIP**

        :type idn_ifaces: List**[str]**
        :return: None
        :rtype: None
        """
        import visa
        manager = visa.ResourceManager()
        # make idn_ifaces all upper case
        if idn_ifaces:
            idn_ifaces = [i.upper() for i in idn_ifaces]
        else:   # Populate default interfaces
            idn_ifaces = ['GPIB', 'USB']
        # create corresponding header string
        header = 'Dumping VISA resources'
        if idn:
            header += ' with *IDN? on ['
            for i in idn_ifaces:
                header += i + ', '
            header = header[:-2] + ']'
        self.log.info(header)
        self.log.info_line('=')
        # swap COM for ASRL
        if 'COM' in idn_ifaces:
            idn_ifaces.remove('COM')
            idn_ifaces.append('ASRL')
        # build current instruments lookup, if doing *IDN?
        if idn:
            cur_instr = {}
            for i in self.instruments.values():
                visa = i.visa_resource_name.strip()  # adding strip to prevent getting list of PyroReceivers randomly
                if visa.endswith('::INSTR'):  # Remove suffix if in yml file.
                    visa = visa[:-7]
                if visa.startswith('COM'):  # Rename COM# to ASRL#
                    visa = 'ASRL{}'.format(visa[3:])
                cur_instr[visa] = i
        # iterate resources for all interfaces
        for iface in ['GPIB', 'ASRL', 'USB', 'TCPIP']:
            self.log.info("%s:" % ('COM' if iface == 'ASRL' else iface))  # print COM instead of ASRL
            res_list = manager.list_resources(query='%s?*::INSTR' % iface)  # Get list of resources for current protocol
            if not res_list:  # No resources for this interface, skip to the next one
                continue
            m_len = len(max(res_list, key=len))-7  # Length of longest resource string without ::INSTR suffix
            for resource in res_list:
                resource = resource[:-7]    # Removes '::INSTR' suffix, might not be in yml file.
                if not idn or iface not in idn_ifaces:  # just print source name
                    self.log.info('  ' + resource)
                else:   # attempt to do *IDN? query
                    # check if resource is current instrument
                    if resource in cur_instr:
                        self.log.info('  ' + resource.ljust(m_len) + ' - ' + cur_instr[resource].get_idn())  # use open connection
                    else:
                        # attempt to open connection and do query
                        try:
                            instr = manager.open_resource(resource)
                        except Exception:
                            self.log.info('  ' + resource.ljust(m_len) + ' - ' + 'unable to connect to instrument')
                        else:
                            instr.timeout = 100  # Set timeout to 100ms to make fails faster
                            try:
                                idn = instr.query('*IDN?')
                                self.log.info('  ' + resource.ljust(m_len) + ' - ' + idn.strip())
                            except Exception:
                                self.log.info('  ' + resource.ljust(m_len) + ' - ' + 'failed to query *IDN?')
        self.log.info_line('=')

    def initialize(self, *args, **kwargs):
        pass

    def shutdown(self, *args, **kwargs):
        pass

    def serialize(self, *args, **kwargs):
        return {}

    def generate_id(self, *args, **kwargs):
        return 0

    def gen_pyi(self, indent=0, top=False):
        if self.uses_pyro:
            return self._pyro_handle.gen_pyi(indent=indent, top=top)
        else:
            return super().gen_pyi(indent=indent, top=top)

    # - - Pryo helper functions - - #

    def get_instrument_names(self):
        """Returns list of instrument keys."""
        return list(self.instruments.keys())

    def get_ref_name(self):
        """Returns the reference instrument."""
        return self.ref_name

    def get_class_by_name(self, inst_name: str):
        """
        Returns the class name of the specified instrument.

        :param inst_name: Instrument's name
        :type inst_name: str
        :return: Instrument's class name
        :rtype: str
        """
        if self.uses_pyro:
            return self._pyro_handle.get_class_by_name(inst_name)
        else:
            return self.instruments[inst_name].__class__.__name__

    def get_driver_path_by_name(self, inst_name: str):
        """
        Returns the import package path for the specified instrument.

        :param inst_name: Instrument's name
        :type inst_name: str
        :return: Instrument's package path eg. module.ClassName
        :rtype: str
        """
        if self.uses_pyro:
            return self._pyro_handle.get_driver_path_by_name(inst_name)
        else:
            cls = self.instruments[inst_name].__class__
            return f"{cls.__module__}.{cls.__name__}"
