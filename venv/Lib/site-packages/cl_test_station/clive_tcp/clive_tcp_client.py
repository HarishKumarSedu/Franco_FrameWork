import socket
import json
from time import perf_counter
import warnings

HDRLEN = 16
CHUNKSIZE = 65536


class CliveTcpClient:
    """
    **Python side TCP client that sends commands to Cliver Server - purpose is to update Clive GUI to reflect Python
    operations.**

    Implements methods that correspond to some of the TCP handlers built into Clive.
    """

    def __init__(self):
        self.sock = None

    def is_connected(self):
        """Returns True if the socket is currently connected to CLive."""

        return self.sock is not None

    def connect(self, hostname='localhost', port=5020):
        """Creates socket and attempts to connect to Clive."""

        self.disconnect()

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        t1_start = perf_counter()
        try:
            self.sock.connect((hostname, port))   # For AF_INET, the address is a tuple: (host, port)
        except Exception as e:
            t1_stop = perf_counter()
            self.disconnect()
            # return f"Failed attempt to connect with Clive at ['{hostname}', {port}],
            # after {1000*(t1_stop - t1_start):4.0f} msec."
            return "Failed attempt to connect with Clive at ['{}', {}], " \
                   "after {:4.0f} msec.".format(hostname, port, 1000*(t1_stop - t1_start))
        else:
            t1_stop = perf_counter()
            # return f"Established connection with Clive at ['{hostname}', {port}] in {1000*(t1_stop - t1_start):4.2f}
            # msec."
            return "Established connection with Clive at ['{}', {}] in {:4.2f} msec.".format(hostname, port,
                                                                                             1000*(t1_stop - t1_start))

    def disconnect(self):
        """Closes any existing sock connection and destroys the socket. Sets sock attribute to None so handler methods
            know there is no Clive to talk to."""
        if self.sock is not None:
            self.sock.close()
            self.sock = None

    def cmd_to_clive(self, tcp_handler_name, parameters=None):
        """
        For the specified tcp_handler_name and parameters dict, sends TCP header and payload to Clive server and
        obtains and returns response.

           **See** https://docs.cirrus.com/display/G3/TCP+Interface+API.

        :param tcp_handler_name: String name of TCP handler implemented in Clive.
        :type tcp_handler_name: str
        :param parameters: dict of name-value pairs that correspond to the input parameter cluster expected by the
            handler in Clive. The values can be of any types that can be Jason encoded.
        :type parameters: dict

        :returns:
                **element 0 :** a dict having 2 keys:

                    **iserror:** 0 if no error, 1 if Lab View Error Cluster from TCP handler reports an error.

                    **msglen:**  int, the number of bytes in the response. Note, if iserror == 1, the response is the
                    error message from the LV error cluster.

                **element 1 :** The response data.

                    **If iserror == 0:** data type depends on the particular handler.

                    **If iserror == 1:** this is a string containing the text of the error message generated by the LV
                    error cluster.

        :rtype: A tuple of 2 elements
        """

        if parameters is None:
            parameters = ''

        # t1_start = perf_counter()

        param_json_str = json.dumps(parameters).encode('UTF-8')
        # print( 'param_json_str=', param_json_str)
        num_bytes_payload = len(param_json_str)
        self._send_header(tcp_handler_name, num_bytes_payload)
        self._send_payload(param_json_str)
        response = self._get_response()

        # t1_stop = perf_counter()
        # print( 'response_len =', len( response ) )
        # print( 'transfer time =', t1_stop - t1_start )

        return response

    def _send_header(self, tcp_handler_name, num_bytes_payload):
        """Constructs the header for the Clive TCP server protocol and sends it to the server."""

        totalsent = 0
        header = "%s:%08X" % (tcp_handler_name, num_bytes_payload)
        header_enc = header.encode('UTF-8') + b'\r\n'
        # print(header_enc)
        while totalsent < len(header_enc):
            sent = self.sock.send(header_enc[totalsent:])
            if sent == 0:
                raise RuntimeError("socket connection broken")
            totalsent = totalsent + sent

    def _send_payload(self, payload):
        """Sends the payload portion of the protocol to the CLive server."""

        totalsent = 0
        while totalsent < len(payload):
            sent = self.sock.send(payload[totalsent:])
            if sent == 0:
                raise RuntimeError("socket connection broken")
            totalsent = totalsent + sent

    def _get_response(self):
        """Used to read back the response sent back from the Clive server."""

        header = self._get_header()
        chunks = []
        bytes_recd = 0
        while bytes_recd < header['msglen']:
            chunk = self.sock.recv(min(header['msglen'] - bytes_recd, CHUNKSIZE))
            if chunk == b'':
                raise RuntimeError("socket connection broken")
            chunks.append(chunk)
            bytes_recd = bytes_recd + len(chunk)

        json_str = b''.join(chunks).decode('UTF-8')
        # print('Response Length =', len(json_str))
        # Return tuple consisting of header and response data.
        return header, json.loads(json_str)

    def _get_header(self):
        """Reads the header portion of the response from the Clive TCP server. Header contains error flag and payload
           length."""
        chunks = []
        bytes_recd = 0

        while bytes_recd < HDRLEN:
            chunk = self.sock.recv(min(HDRLEN - bytes_recd, CHUNKSIZE))
            if chunk == b'':
                raise RuntimeError("socket connection broken")
            chunks.append(chunk)
            bytes_recd = bytes_recd + len(chunk)

        header_str = b''.join(chunks)
        header = {'iserror': int(header_str[:8], 16), 'msglen': int(header_str[8:], 16)}
        # print('Response Header=', header)
        return header         # return header as dict

    # ------------------------------------------------------------------------------------------------------------------
    # Methods corresponding to some of the TCP handlers implemented in the Clive TCP Server.
    # See https://docs.cirrus.com/display/G3/TCP+Interface+API (https://docs.cirrus.com/x/IrZkDQ)

    def id(self):
        """Returns dict containing info about Clive. """

        if self.sock is None:
            return None

        result = self.cmd_to_clive('id')

        if result[0]['iserror']:
            raise RuntimeError(result[1])
        return result[1]

    def reset_component(self, component):
        """Resets the named component in Clive. Does nothing if connection to Clive doesn't exist.

        :param component: String name of component object in Clive, e.g 'sim_chilton'.
        :type component: str
        """

        if self.sock is None:
            return None

        param_dict = {'Component': component}
        result = self.cmd_to_clive('update_register_map', param_dict)

        if result[0]['iserror']:
            raise RuntimeError(result[1])

    def update_register_read(self, component, name_or_address, value):
        """
        Sends message to update_register_read TCP handler in Clive to update the GUI to correspond to value Python
        has read from the hardware. Does nothing if connection to Clive doesn't exist.

        :param component: String name of component object in Clive, e.g 'sim_chilton'.
        :type component: str
        :param name_or_address: If string, the qualified name of the register; e.g. <blockname>.<regname>
                             If int, should be the address of the register
        :type name_or_address: str | int
        :param value:  the value to display
        :type value: int
        """

        if self.sock is None:
            return None

        param_dict = {'Component': component}
        if isinstance(name_or_address, str):
            param_dict['Name'] = name_or_address
        elif isinstance(name_or_address, int):
            param_dict['Address'] = name_or_address
        else:
            # raise ValueError(f"Bad name_or_address {name_or_address}, should be str or int.")
            raise ValueError("Bad name_or_address {}, should be str or int.".format(name_or_address))

        param_dict['Value'] = value

        result = self.cmd_to_clive('update_register_read', param_dict)

        if result[0]['iserror']:
            raise RuntimeError(result[1])

    def update_register_write(self, component, name_or_address, value):
        """Sends message to update_register_write TCP handler in Clive to update the GUI to correspond to value Python
        has written to the hardware. Does nothing if connection to Clive doesn't exist.

        :param component: String name of component object in Clive, e.g 'sim_chilton'.
        :type component: str
        :param name_or_address: If string, the qualified name of the register; e.g. <blockname>.<regname>
                             If int, should be the address of the register
        :type name_or_address: str | int
        :param value: the value to display
        :type value: int
        """

        if self.sock is None:
            return None

        param_dict = {'Component': component}
        if isinstance(name_or_address, str):
            param_dict['Name'] = name_or_address
        elif isinstance(name_or_address, int):
            param_dict['Address'] = name_or_address
        else:
            # raise ValueError(f"Bad name_or_address {name_or_address}, should be str or int.")
            raise ValueError("Bad name_or_address {}, should be str or int.".format(name_or_address))

        param_dict['Value'] = value

        result = self.cmd_to_clive('update_register_write', param_dict)

        if result[0]['iserror']:
            raise RuntimeError(result[1])

    def update_field_read(self, component, field_name, value):
        """
        Sends message to update_field_read TCP handler in Clive to update the GUI to correspond to value Python has read
        from the hardware. Does nothing if connection to Clive doesn't exist.

        :param component: String name of component object in Clive, e.g 'sim_chilton'.
        :type component: str
        :param field_name: string, the qualified name of the field; e.g. <blockname>.<regname>.<field_name>.
        :type field_name: str
        :param value: the value to display
        :type value: int
        """

        if self.sock is None:
            return None

        param_dict = {'Component': component, 'Name': field_name, 'Value': value}

        result = self.cmd_to_clive('update_field_read', param_dict)

        if result[0]['iserror']:
            raise RuntimeError(result[1])

    def update_field_write(self, component, field_name, value):
        """
        Sends message to update_field_write TCP handler in Clive to update the GUI to correspond to value Python has
        written to the hardware. Does nothing if connection to Clive doesn't exist.

        :param component: String name of component object in Clive, e.g 'sim_chilton'.
        :type component: str
        :param field_name: If string, the qualified name of the register; e.g. <blockname>.<regname>.<fieldname>.
        :type field_name: str
        :param value: the value to display
        :type value: int
        """

        if self.sock is None:
            return None

        param_dict = {'Component': component, 'Name': field_name, 'Value': value}

        result = self.cmd_to_clive('update_field_write', param_dict)

        if result[0]['iserror']:
            raise RuntimeError(result[1])

    def update_register_map(self, component, version):
        """
        Sends message to load the specified register map version.
        Does nothing if connection to Clive does not exist.

        :param component: String name of component object in Clive, e.g 'sim_chilton'.
        :type component: str
        :param version: String of register map version to load, e.g 'A0'
        :type version: str
        """
        if self.sock is None:
            return None
        param_dict = {'Component': component, 'Version': version}
        result = self.cmd_to_clive('update_register_map', param_dict)

        if result[0]['iserror']:
            raise RuntimeError(result[1])
        else:
            return result[1]


if __name__ == '__main__':
    tcp_client_obj = CliveTcpClient()
    tcp_client_obj.connect('localhost', 5020)
