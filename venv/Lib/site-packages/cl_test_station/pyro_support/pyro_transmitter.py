import inspect
import re
import sys
import traceback  # noqa
from threading import Lock
from enum import Enum
from typing import *

import Pyro5.api
import Pyro5.errors
import Pyro5.server
import serpent
from cl_test_station.pyro_support.shared_logic import *
from cl_test_station.utilities.reusables import serializable, LOCALHOST
from cl_test_station.utilities.ts_logging import TsLoggingAdapter, get_logger
from cl_test_station.utilities.reusables import serializable
from Pyro5.serializers import SerpentSerializer

sys.excepthook = Pyro5.errors.excepthook
SELF_REFERENCE = '_pyro_transmitter'


class ResultsContainer:
    pass


@Pyro5.api.expose
class PyroTransmitter:
    """Class that exposes nested objects, functions, and attributes to Pyro. Requires a PyroReceiver client side."""
    def __init__(self, regobj: Any, lock: Lock, preamble_to_user: str, debugprintlevel: int, max_depth: int,
                 my_name: str, internal_preamble: str = '', logger: TsLoggingAdapter = None,
                 allow_attr_setting: bool = False, result_transmitter_depth: int = 3,
                 cache_result_transmitters: bool = True):
        # Create TS logging adapter
        if not logger:
            logger = get_logger()
        self.log = TsLoggingAdapter(logger, f'{my_name} (PyroTransmitter)')
        # init internal maps/sets
        self.__register_list__ = {}
        self.__property_map = {}
        self.__attribute_set = set()
        self.map = regobj
        # Build function register_list and attribute_set by scanning regobj
        self.regobj = regobj
        self.internal_preamble = internal_preamble
        self.scan_for_methods(self.map, preamble_to_user, depth=0, debugprintlevel=debugprintlevel, max_depth=max_depth)
        self.__build_attr_set(regobj, self.internal_preamble.rstrip('.'), max_depth=max_depth)
        # Misc init
        self.lock = lock
        self.debugprintlevel = debugprintlevel
        self.my_name = my_name
        self.allow_attr_setting = allow_attr_setting
        self.result_transmitters = ResultsContainer()
        self.result_transmitter_depth = result_transmitter_depth
        self.cache_result_transmitters = cache_result_transmitters

    def __attempt_function(self, func: Callable, *args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as func_err:
            self.log.debug(traceback.format_exc())
            raise func_err

    def check_alive(self, running: Any, hung: Any) -> Any:
        """
        check_alive is called by the launcher GUI.
        You pass two parameters, "running" and "hung". These values can be anything you like.
        Depending on the state it will return one or the other value , so it confirms two-way communication.
        The function will try to get a lock with a 1 second timeout. If it fails, the "hung" value will be
        returned. If it passes, the "running" value will be returned.
        Since Pyro is multi threaded, this function will still work even if another thread is hung.

        :param running: Value to return when running
        :param hung: Value to return when hung.
        :return: Returns "running" or "hung" value.
        """
        success = self.lock.acquire(timeout=0.2)
        if success:
            self.lock.release()
            return running
        else:
            return hung

    @Pyro5.api.oneway
    def shut_me_down(self):
        """
        This function can be called through Pyro to request a remote shutdown.
        The self.daemon needs to point to the Pyro daemon so we can tell it to shut down.
        This function is a Pyro "one way" function meaning the server tells the client
        not to wait for a response, because the server will shut down immediately.

        :return: None
        """
        self.log.info("Shutting down")
        self.daemon.shutdown()
        self.daemon.close()

    def __build_attr_set(self, obj: Any, path: str, max_depth: int = 1, depth: int = 0):
        """
        Recursively traverses obj's dir() and finds all serpent-serializable attributes. The paths relative to 'obj'
        will be added to self.__attribute_set. Any attributes that raise an exception when being grabbed or serialized
        are skipped.
        """
        dot = '.' if path else ''  # No leading '.' for base obj.attr
        for name in dir(obj):  # Loop through avery attribute name in obj
            #  Skip internals
            if name.startswith('_') or name in self.__register_list__:
                continue
            # If an attr is a property this may raise an Exception
            try:
                attr = getattr(obj, name)
            except Exception as err:
                self.log.dev(f"Failed to grab {path}{dot}{name}: {repr(err)}")
                continue
            # Skip all functions/methods
            if callable(attr):
                continue
            # Attempt to serialize with serpent, Pyro's default serializer
            if serializable(attr, serpent):
                self.__attribute_set.add(f'{path}{dot}{name}')  # Serialization passed, add path to set
            else:
                if depth < max_depth and not name == 'container':  # Recursively search through nested obj
                    self.__build_attr_set(attr, f'{path}{dot}{name}', max_depth, depth+1)

    def __get_attribute_set__(self) -> Set[str]:
        """
        Pyro exposed method for getting the Transmitter's attribute set.

        :return: Set of full paths to serpent-serializable attributes
        :rtype: set
        """
        return self.__attribute_set

    def __get_transmitter_attribute__(self, path: str) -> Any:
        """
        Takes in a dot-path and resolves the reference to that attribute.

        :param path: Path to attribute, eg obj.sub_obj.some_number
        :type path: str
        :return: Attribute specified by the path
        :rtype: Any
        """
        attr = self.__attempt_function(self.__resolve_function, path)  # attr = self.__resolve_function(path)
        return self.__serialize_result(attr, path)

    def __set_transmitter_attribute__(self, path: str, value: Any):
        """
        Takes in a dot-path and sets the corresponding attribute to 'value'. Will raise an PermissionError if this
        instance does not have self.allow_attr_setting = True

        :param path: Path to attribute, eg obj.sub_obj.some_number
        :type path: str
        :param value: Value to set the attribute to
        :type value: Any
        :return: None
        :rtype: None
        """
        # Only allow setattr if allow_attr_setting was True in __init__
        if self.allow_attr_setting:
            # Resolve containing object and get attribute name
            obj_path, _, attr_name = path.rpartition('.')
            obj = self.__resolve_function(obj_path) if obj_path else self.regobj
            value = self.__parse_parameter(value)
            self.__attempt_function(setattr, obj, attr_name, value)  # setattr(obj, attr_name, value)
        else:
            raise PermissionError(f"allow_attr_setting=False, cannot set {path} to {value}")

    def __resolve_function(self, func_path: str, transmitter_chain: list = None) -> Callable:
        """
        Takes in a period-separated path and resolves attributes starting at self.map. Returns final attribute

        :param func_path: dot path to function, eg fpga.some_string.strip
        :type func_path: str
        :return: Function pointer
        :rtype: Callable
        """
        # Define object pointers
        prev = self
        attr = self.regobj
        # Resolve dot path to get final attribute
        for name in func_path.split('.'):
            # Key word that can override start point from actual object to self
            if name == SELF_REFERENCE and prev:
                attr = prev  # Go back one attribute and continue
                prev = None
            # Proceed with getatttr normally
            else:
                prev = attr
                attr = getattr(attr, name)
                # If caller provides a transmitter_chain list, add all transmitters within
                if transmitter_chain is not None and isinstance(attr, PyroTransmitter):
                    transmitter_chain.append(attr)
        return attr

    @staticmethod
    def __parse_parameter(param_value) -> Any:
        """
        Takes in a run_function parameter value and deserializes it if needed.

        :param param_value: Parameter value
        :type param_value: Any
        :return: Deserialized parameter
        :rtype: Any
        """
        if is_pyro_clts_custom_type(param_value):
            param_type = get_pyro_clts_custom_type(param_value)
            if param_type is CustomResultTypes.ENUM:
                param_value = deserialize_enum(param_value)
        return param_value

    def __resolve_params(self, *args, **kwargs) -> Tuple[tuple, dict]:
        """
        Deserializes all args and kwargs.

        :return: Deserialized args and kwargs
        :rtype: Tuple[tuple, dict]
        """
        new_args = [self.__parse_parameter(arg) for arg in args]
        for key, value in kwargs.items():
            kwargs[key] = self.__parse_parameter(value)
        return new_args, kwargs  # noqa

    def __serialize_result(self, result: Any, function_path: str, *args, **kwargs) -> Union[Dict[str, str], Any]:
        """
        Takes result of any run_function, proper, or attribute call and serializes is if needed.

        :param result: Function return
        :type result: Any
        :param function_path: Path to transmitter attribute/function that was accessed
        :type function_path: str
        :return: Serialized result
        :rtype: Union[Dict[str, str], Any]
        """
        # Use custom enum serializer
        if isinstance(result, Enum):
            return serialize_enum(result)
        # Attempt to serialize with serpent
        try:
            serializer = SerpentSerializer()
            s = serializer.dumps(result)
            serializer.loads(s)
            return result
        # Result will not serialize over pyro server, need to it convert into a transmitter
        except Exception:
            self.log.debug(f"{function_path}() result '{result}' is not serializable. Creating new transmitter")
        # Hash combination of function path and all arguments passed in
        call_str = f"{function_path}{''.join(str(a) for a in args)}{''.join(str(k) + str(v) for k,v in kwargs.items())}"
        call_hash = f"_{hash(call_str)}"
        # To improve speed when dealing with large objects, the transmitters can be cached and used repeatedly
        if self.cache_result_transmitters and hasattr(self.result_transmitters, call_hash):
            return serialize_trasnmitter(getattr(self.result_transmitters, call_hash), call_hash)
        # Either caching is disabled or a transmitter doesn't exist for this function-argument combination
        else:
            result_transmitter = PyroTransmitter(result, self.lock, "", -1, self.result_transmitter_depth,
                                                 f"{function_path}_result", logger=self.log, allow_attr_setting=self.allow_attr_setting,
                                                 internal_preamble=f"{self.internal_preamble}_pyro_transmitter.result_transmitters.{call_hash}.map.")
            setattr(self.result_transmitters, call_hash, result_transmitter)
            self.__property_map.update(result_transmitter.__property_map)
            return serialize_trasnmitter(result_transmitter, call_hash)

    def run_function(self, function: str, *args, **kwargs) -> Any:
        """
        Takes function path and arguments from Receiver and then runs function on registered object, returning the result.

        :param function: Period-separated path to the function to run
        :type function: str
        :param args: Function's positional arguments
        :param kwargs: Function's keyword arguments
        :return: Result of function. Must be Pyro-serializable
        :rtype: Any
        """
        self.lock.acquire()  # Acquire lock so that no other function can be run until this one completes
        result = None
        try:
            if self.debugprintlevel > 3:
                p_a = ', '.join([str(a) for a in args]) if args else ''  # Arg values
                p_kw = ', ' + ', '.join([f'{k}={v}' for k, v in kwargs.items()]) if kwargs else ''  # kwargs=values
                self.log.debug(f'Running self.{self.internal_preamble}{function}({p_a}{p_kw})')
            # Get function to run
            transmitter_chain = []
            func = self.__resolve_function(func_path=function, transmitter_chain=transmitter_chain)
            # closest_transmitter, rel_func_path = self.__find_closest_transmitter(func_path=function)
            if not transmitter_chain:  # No nested transmitters were found, do not call function from this scope
                # Resolve parameters to account for non-serializable types
                p_args, p_kwargs = self.__resolve_params(*args, **kwargs)
                # Call function and get result
                result = func(*p_args, **p_kwargs)
        except Exception as exception_obj:
            if result is None:
                result = traceback.format_exc()
            self.log.debug(f'Error accessing {function}: {repr(exception_obj)}')
            self.log.debug(result)
            raise exception_obj
        finally:
            self.lock.release()  # Done using registered object, can release lock now
        # Once lock is released, the nested transmitter can be called if one exists
        if transmitter_chain:
            closest_transmitter = transmitter_chain[-1]
            relative_function_path = function.replace(closest_transmitter.internal_preamble, '', 1).lstrip('.')
            return closest_transmitter.run_function(relative_function_path, *args, **kwargs)
        return self.__serialize_result(result, function, *p_args, **p_kwargs)  # noqa

    def __get_register_list__(self) -> Dict[str, str]:
        if self.debugprintlevel > 0:
            print('__get_register_list__ : returned {} items'.format(len(self.__register_list__)))
        return self.__register_list__

    @staticmethod
    def get_members(obj: Any) -> ItemsView[str, Any]:
        """
        Property-safe implementation of inspect.get_members. Grabs all attribute name-value pairs in the obj, its class,
        and its MRO classes.

        :param obj: Object to get members from
        :type obj: Any
        :return: dict_items holding member name and values
        :rtype: ItemsView[str, Any]
        """
        members = {}
        for cls in reversed(obj.__class__.__mro__[:-1]):
            members.update(cls.__dict__)
        if hasattr(obj, '__dict__'):
            members.update(obj.__dict__)
        return members.items()

    def scan_for_methods(self, obj_to_scan, preamble='', depth=0, debugprintlevel=4, max_depth=5):
        """
        Recursive function that scans an object for all callable methods/functions, including those within nested objects.
        builds a dictionary (self.__register_list__) where the key is the attribute path of the function, and the value
        is the function signature. This dictionary will be serialized and sent to the PyroReceiver, which parses the
        dictionary and builds lambda functions representing each server-side function.

        :param obj_to_scan: Object to be searched through. Nested objects up to max_depth will also be searched
        :type obj_to_scan: Any
        :param preamble: Current attribute path from starting object.
        :type preamble: str
        :param depth: Current search depth. This function will return once depth == max_depth
        :type depth: int
        :param debugprintlevel: Dictates what and how much debug information gets printed. Needs to be > 3 for any info
            in this function to be printed.
        :type debugprintlevel: int
        :param max_depth: Maximum recursive search depth. eg if max_depth=5, this function will iterate into 5 potential
            nested objects of obj_to_scan before returning
        :type max_depth: int
        :return: None
        """
        self.debugprintlevel = debugprintlevel
        if preamble:
            preamble += '.'
        functions_added = 0
        internal_func_list = ['__call__', '__getitem__', '__setitem__']
        # Iterate through all functions and nested objects
        for func_name, func in self.get_members(obj_to_scan):
            try:
                if func_name.startswith('_') and func_name not in internal_func_list:  # Skip internal functions
                    continue
                if type(func) is property:  # Register as special property entry and add to property map
                    func_path = f'{self.internal_preamble}{preamble}{func_name}'
                    self.__register_list__[func_path] = '__CLASS_PROPERTY__'  # Keyword that the receiver will recognize
                    self.__property_map[func_path] = (func, obj_to_scan)  # Need to save the object for fget/fset param
                    if self.debugprintlevel > 3:
                        print(f'Processed property {func_name}, {func_path}')
                # Get function signature and add to register_list
                elif inspect.isfunction(func) or inspect.ismethod(func):
                    sig = inspect.signature(func)
                    # Build string from parameters
                    param_list = []  # List of parameter strings
                    for param in sig.parameters.values():
                        # Only include '=default' if a default value exists and is serpent-serializable
                        if param.default is not inspect._empty:
                            default_exists = True
                            if not serpent_serializable(param.default):  # Skip any kwargs that cant be sent over Pyro
                                self.log.dev(f"Removing keyword parameter {param} for unserializable default: {param.default}")
                                continue
                        else:
                            default_exists = False
                        # ToDo: PLATDEV-1501: change in PLATDEV-1490 to test
                        # default = f"'{param.default}'" if type(param.default) is str else param.default
                        # Add in asterisks for variable arguments
                        ast_cnt = 0
                        if param.kind is inspect.Parameter.VAR_POSITIONAL:
                            ast_cnt = 1
                        elif param.kind is inspect.Parameter.VAR_KEYWORD:
                            ast_cnt = 2
                        # Ignore annotations as they are illegal in lambda functions
                        # ToDo: PLATDEV-1501: change in PLATDEV-1490 to test
                        # original code: param_list.append(f'{"*" * ast_cnt}{param.name}{f"={default}" if default_exists else ""}')
                        if isinstance(param.default, Enum):
                            default_value = param.default.value
                        else:
                            default_value = param.default
                        default = f"={repr(default_value)}" if default_exists else ""
                        param_list.append(f'{"*" * ast_cnt}{param.name}{default}')
                    # Create signature string
                    signature = f'({", ".join(param_list)})'
                    # Replace <class 'cls'> pattern with regular syntax. Eg param1=<class 'list'> -> param1: list
                    for bad_default, cls_name in re.findall(r'(<class\s*[\'|\"](\w+)\'>)', signature):
                        signature = signature.replace(bad_default, cls_name)
                        self.log.dev(f"Replaced {bad_default} with {cls_name}: {signature}")

                    # Register function and signature to the transmitter's internal dictionary
                    func_path = f'{preamble}{func_name}'  # Full attribute path to the target function
                    self.__register_list__[func_path] = signature[1:-1]
                    functions_added += 1
                # Not a function, traverse through object and recursively look for functions
                elif depth < max_depth and not func_name.startswith('_'):
                    self.scan_for_methods(func, preamble + func_name, depth + 1, self.debugprintlevel, max_depth)
            except Exception as err:
                self.log.debug(f"Received error while processing {preamble}{func_name}: {repr(err)}")
                self.log.dev(traceback.format_exc())

    def get_property(self, attr_path: str) -> Any:
        """
        Queries the property map and calls its 'fget' function (getter). Returns the result

        :param attr_path: full path to the property, ie map.OBJ.some_property
        :type attr_path: str
        :return: Result of the requested property's getter
        :rtype: Any
        """
        prop, obj = self.__property_map[attr_path]
        result = self.__attempt_function(prop.fget, obj)  # prop.fget(obj)
        return self.__serialize_result(result, attr_path)

    def set_property(self, attr_path: str, value: Any):
        """
        Queries the property map and calls its 'fset' function (setter). Equivalent to self.some_property = value

        :param attr_path: full path to the property, ie map.OBJ.some_property
        :type attr_path: str
        :param value: New value to pass into the property's setter
        :return: None
        """
        value = self.__parse_parameter(value)
        prop, obj = self.__property_map[attr_path]
        self.__attempt_function(prop.fset, obj, value)  # prop.fset(obj, value)


def serpent_serializable(obj: Any) -> bool:
    """
    Checks if a given object will be able to serialize across the pyro server. Performs Pyro5 serialization and
    deserialization process. Returns True if successful, False if any Exception was raised.

    :param obj: Object to test. i.e. a function parameter or a return
    :type obj: Any
    :return: True if object will serialize, False otherwise
    :rtype: bool
    """
    try:
        serializer = SerpentSerializer()
        ser = serializer.dumps(obj)
        serializer.loads(ser)
        return True
    except:
        return False


def _init_wrapper(init: Callable):
    """Internal decorator that wraps the __init__ function of an internal transmitter class. Saves __init__ args and
    kwargs to the class instance under the attribute '_pyro_init_kwargs'. """
    def inner(self, *args, **kwargs):
        # Convert all args to kwargs
        new_kwargs = {}
        sig = inspect.signature(init)
        params = list(sig.parameters.keys())
        for i, arg in enumerate(args):
            if serpent_serializable(arg):
                new_kwargs[params[i]] = arg
        # Check for serialization, remove if argument can't be
        for key, value in kwargs.items():
            if serpent_serializable(value):
                new_kwargs[key] = value
        self._pyro_init_kwargs = new_kwargs
        init(self, *args, **kwargs)
    return inner


def internal_transmitter(*attr_names: str):
    """
    Decorator used to indicate that a class should use  internal pyro transmitter(s) instead of itself. The class should
    only interact with RPCs from these internal attributes to ensure compatibility across the pyro server. The attribute
    names will be stored in a class attribute '_pyro_attr_names'.

    For example, The JLink controller uses this decorator, indicating that its 'handle' attribute should be an internal
    transmitter. When using cl_test_station in a server configuration, the JLink controller will appear local, but
    its handle attribute will be a PyroReceiver.

    :param attr_names: Any attributes within the class that should be transmitters. These attributes *must* be arguments
        in the class's __init__(). See JLink controller for an example.
    :type attr_names: str
    :return: Wrapped class
    :rtype: Type
    """
    def wrapper(cls: Type[object]):
        if not inspect.isclass(cls):
            raise ValueError("Decorator can only be used on classes")
        cls._pyro_attr_names = attr_names
        init_sig = inspect.signature(cls.__init__)
        missing_params = []
        for attr_name in attr_names:
            if attr_name not in init_sig.parameters:
                missing_params.append(f"'{attr_name}'")
        if missing_params:
            s = 's' if len(missing_params) > 1 else ''
            raise NameError(f"Given attribute name{s} {', '.join(missing_params)} not found in {cls.__name__}.__init__")
        cls.__init__ = _init_wrapper(cls.__init__)
        return cls
    return wrapper
