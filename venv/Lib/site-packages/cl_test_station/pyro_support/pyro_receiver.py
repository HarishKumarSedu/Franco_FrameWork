import importlib
import inspect
import os
import re
import traceback  # noqa
import types
from enum import Enum  # noqa
from types import ModuleType
from typing import *

import hightime  # noqa: needed to support nidigital functions
import Pyro5.api
import Pyro5.client
import Pyro5.errors
from cl_test_station.pyro_support.shared_logic import *
from cl_test_station.utilities.reusables import LOCALHOST
from cl_test_station.utilities.ts_logging import TsLoggingAdapter, get_logger


def module_from_file(module_name: str, file_path: str) -> ModuleType:
    """
    Imports a module from a file

    :param module_name: Module name string
    :param file_path: File name string
    :return: Returns module
    :rtype: ModuleType
    """
    if os.path.isfile(file_path):
        try:
            spec = importlib.util.spec_from_file_location(module_name, file_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            return module
        except ImportError:
            print("Error while importing {}".format(file_path))
            raise Exception("Error while importing {}".format(file_path))
    else:
        try:
            module = __import__(file_path)
            return eval('module.' + file_path[file_path.rfind('.')+1:])
        except (ImportError, IndexError):
            raise Exception('File {} is not accessible'.format(file_path))


class PyroReceiver:
    """Class that connects to a PyroTransmitter and allows user to access nested objects, functions, and attributes."""

    def __new__(cls, my_name, *args, **kwargs):
        # Before creating a new instance, create new subclass to allow class assignment for properties
        new_cls = type(f'{my_name}Receiver', (cls,), {})
        return object.__new__(new_cls)

    def __init__(self, my_name: str, proxy: Pyro5.client.Proxy = None, debugprintlevel: int = 4, logger=None,
                 internal_preamble: str = "", register_list: Dict[str, str] = None, attribute_set: Set[str] = None):
        object.__setattr__(self, 'attributes', {})
        # Create TSLoggingAdapter
        if not logger:
            logger = get_logger()
        self.log = TsLoggingAdapter(logger, f'{my_name} (PyroReceiver)')
        # Receiver attributes
        self.internal_preamble = internal_preamble
        self.debugprintlevel = debugprintlevel
        self.my_name = my_name
        self.register_info = {}  # Contains function paths and argument information for lambda construction
        self.attribute_set = set()  # Contains paths to all transmitter attributes for dynamic property construction
        if register_list:
            self.register_info.update(register_list)
        if attribute_set:
            self.attribute_set.update(attribute_set)
        # Passed in proxy means this is the top level PyroReceiver
        self.__properties = set()
        if proxy is not None:
            self.proxy: Pyro5.client.Proxy = proxy
            # Get transmitter information
            self.register_info.update(self.proxy.__get_register_list__())
            self.attribute_set.update(self.proxy.__get_attribute_set__())
            # Build lambda functions (proxy.run_function()) and properties (proxy.get(set)_property())
            self.__add_members()
            # Build dynamic attribute properties that call proxy.__get(set)_transmitter_attribute__()
            self.__build_attr_properties()

    def __call__(self, *args, **kwargs):
        return self._call(*args, **kwargs)

    def __parse_result(self, result: Any):
        """
        Takes in return of transmitter function and parses the result if necessary. If the transmitter returns a
        dictionary with a predefined key, the dictionary needs to be converted into another object.

        If the dictionary represents an Enum member, that Enum will have to be dynamically imported and returned
        If the dictionary represents a nested PyroReceiver, that receiver will be constructed and returned

        :param result: Raw return from transmitter
        :return: parsed result
        """
        if is_pyro_clts_custom_type(result):  # This is a custom result, need to parse it
            result_type = get_pyro_clts_custom_type(result)
            # The result is an importable enum
            if result_type is CustomResultTypes.ENUM:
                return deserialize_enum(result, logger=self.log)
            # This result is a complex object (non-serializable) represented by a new PyroReceiver
            elif result_type is CustomResultTypes.RECEIVER:
                # Create new receiver using result's register list and attribute set
                result_receiver = PyroReceiver(result['my_name'], logger=self.log,
                                               internal_preamble=result['internal_preamble'],
                                               register_list=result['register_list'],
                                               attribute_set=result['attribute_set'],
                                               debugprintlevel=self.debugprintlevel)
                # Transfer attributes to new receiver and build dynamic callables
                result_receiver.proxy = self.proxy
                result_receiver.__add_members()
                result_receiver.__build_attr_properties()
                result = result_receiver
        return result

    def _run_proxy_function(self, *args, **kwargs) -> Any:
        """
        Wrapper function that keeps the Receiver thread-safe. Calls the proxy's run_function and returns the result.

        :return: Function result
        :rtype: Any
        """
        self.proxy._pyroClaimOwnership()  # Pyro5+ no longer allows multiple threads to own a single proxy
        s_args, s_kwargs = self.__serialize_params(*args, **kwargs)
        result = self.proxy.run_function(*s_args, **s_kwargs)
        return self.__parse_result(result)

    def __add_members(self):
        """
        Uses register_info to build all lambda/property objects.

        :return: None
        :rtype: None
        """
        # Build lambda functions (proxy.run_function()) and properties (proxy.get(set)_property())
        for member_str in self.register_info:
            self.add_member(member_str, member_str, self.register_info[member_str], self.proxy, self.debugprintlevel)

    def __build_attr_properties(self):
        """
        Grabs attribute set from Transmitter and builds get/set properties for each entry. Only executes at the top
        level receiver and traverses through nested receivers to assign properties.

        :return: None
        :rtype: None
        """
        # # Grab valid attributes from the PyroTransmitter
        # if not attr_set:
        #     attr_set = self.proxy.__get_atttribute_set__()  # type: Set[str]
        # Loop through set and create dynamic properties
        for path in self.attribute_set:
            rel_path = path.replace(self.internal_preamble, '')
            recv_path, _, prop_name = rel_path.rpartition('.')
            receiver = self
            create_props = True
            if recv_path:  # This is a nested property, traverse path to get the relevant PyroReceiver instance
                for attr_name in recv_path.split('.'):
                    if attr_name in receiver.__properties:  # Prevent overlap with actual properties
                        create_props = False
                        break
                    # TODO: Make this better
                    try:
                        receiver = getattr(receiver, attr_name)
                    except AttributeError:
                        self.log.dev(f"Nested receiver '{attr_name}' not found when parsing attribute path '{path}'")
                        continue
                    if not isinstance(receiver, PyroReceiver):  # Only set properties on PyroReceivers
                        create_props = False
                        break

            if not create_props:
                continue

            # # Dynamic property definitions. args have defaults to freeze values since loop overwrites them # #
            @property
            def prop(self, log=self.log, proxy=self.proxy, path=path):
                log.dev(f"Getter for {path}")
                proxy._pyroClaimOwnership()  # Claim ownership to keep Receiver thread-safe
                result = proxy.__get_transmitter_attribute__(path)  # This tells transmitter to get the requested attr
                return self.__parse_result(result)

            @prop.setter
            def prop(self, value, log=self.log, proxy=self.proxy, path=path):
                proxy._pyroClaimOwnership()  # Claim ownership to keep Receiver thread-safe
                log.dev(f"Setter for {path}")
                value = self.__serialize_parameter(value)
                proxy.__set_transmitter_attribute__(path, value)  # This tells the transmitter to set the attr to value

            # Assign property to name given from register list. Properties must be assigned to the class, not instance
            setattr(receiver.__class__, prop_name, prop)

    # TODO: PLATDEV-1080 Remove
    def add_block_from_class(self, blockname, CLASS, *params, **kwargs):
        """
        Add a block to the component with a class.
        i.e. dut.add_block_from_class('testblock',MY_TESTBLOCK,(param1,param2),{'param3':param3})

        :param blockname: String with the name of the block.
        :param CLASS: Class to instantiate
        :param params: Tuple with the parameters
        :param kwargs: Dictionary with keyword arguments
        :return: 0 for success, -1 for failure
        """
        if 'class' in str(type(CLASS)):
            try:
                if type(blockname) is str:
                    setattr(self, blockname, CLASS(self.map, *params, **kwargs))
                    return 0
                else:
                    print('**ERROR1: Parameter blockname should be of type string!')
                    return -1
            except:
                traceback.print_exc()
                return -1
        else:
            print('ERROR: Second argument should be a class!')
            return -1

    # TODO: PLATDEV-1080 Remove
    def add_block_from_module(self, modulename: str):
        """
        This function can add one or more blocks from a module.
        The parameter is a string with the module name, i.e. "myblocks" or "blocks.myblocks"
        The module has to contain a variable "blocks" which contains all the blocks information.
        You can find more information in the example "testblock.py"

        :param modulename: String that refers to the module to load
        :return: 0 = success, -1 is error
        """
        module = module_from_file('block', modulename)
        try:
            blocks_in_file = module.blocks
        except:
            print('Error: blocks variable is not in module file!')
            return -1
        if type(blocks_in_file) is not dict:
            print('module.blocks is not of type dict!')
            return -1
        for block in blocks_in_file:
            block_data_type = str(type(blocks_in_file[block]))
            if 'tuple' in block_data_type or 'list' in block_data_type:
                block_class = None
                block_params = ()
                block_kwargs = {}
                for item in range(len(blocks_in_file[block])):
                    item_data_type = str(type(blocks_in_file[block][item]))
                    if "'type'" in item_data_type:
                        block_class = blocks_in_file[block][item]
                    if "'tuple'" in item_data_type:
                        block_params = blocks_in_file[block][item]
                    if 'list' in item_data_type:
                        block_params = tuple(blocks_in_file[block][item])
                    if "'dict'" in item_data_type:
                        block_kwargs = blocks_in_file[block][item]
                if block_class is not None:
                    return self.add_block_from_class(block, block_class, *block_params, **block_kwargs)
                else:
                    print('Issue with module.blocks[{}] , no class specified!'.format(block))
                    return -1
            elif 'class' in block_data_type and "'type'" in block_data_type:
                try:
                    self.add_block_from_class(block, blocks_in_file[block])
                except:
                    traceback.print_exc()
                    print('Unable to import library {}'.format(modulename))
                    return -1
            else:
                print('module.blocks.{} is of type {} and not class, list or tuple!'.format(block, block_data_type))
                return -1

    def __serialize_parameter(self, param_value) -> Any:
        """
       Takes in a lambda parameter value and serializes it if needed.

       :param param_value: Parameter value
       :type param_value: Any
       :return: Serialized parameter
       :rtype: Any
       """
        # Use custom enum serializer
        if isinstance(param_value, Enum):
            return serialize_enum(param_value)
        # Attempt to serialize with serpent, otherwise make a new transmitter
        return param_value

    def __serialize_params(self, *args, **kwargs):
        """
        Deserializes all args and kwargs.

        :return: Deserialized args and kwargs
        :rtype: Tuple[tuple, dict]
        """
        new_args = [self.__serialize_parameter(arg) for arg in args]
        for key, value in kwargs.items():
            kwargs[key] = self.__serialize_parameter(value)
        return new_args, kwargs

    def add_member(self, member_str, fullname, parameters, master, debugprintlevel=4):
        """
        This function is used by __init__ to build up the class structure.

        :param member_str: Member string, i.e. "map.GLOBAL_AMPTOP.AMPTOP_BLOCK_ENABLES1"
            The function will recurse, so the above will make a class member map, then
            call itself with the member_str "GLOBAL_AMPTOP.AMPTOP_BLOCK_ENABLES1",
            then make a member GLOBAL_AMPTOP, call itself again, etc until it gets
            to the last section which then is a method. This method calls the
            run_function with fullname
        :param fullname: Member string, i.e. "map.GLOBAL_AMPTOP.AMPTOP_BLOCK_ENABLES1"
            This is passed on as-is so the final method knows what equivalent function
            to call on the IO server side.
        :param parameters: The parameters needed for the target function.
        :param master: TCP master, this is the Pyro object that is used to
            communicate with the IO server
        :param debugprintlevel: Can be a number 0-4, 0 for only minimal prints (fast execution)
            4 for most verbose output.
        :return: No return value
        """
        self.proxy = master
        member_str = member_str.replace(self.internal_preamble, '')
        splitname = member_str.split('.')
        if len(splitname) == 1:  # Reached the end of the attribute dot path. Add function/property
            if parameters == '__CLASS_PROPERTY__':  # Need to dynamically make a property
                @property
                def prop(self):
                    self.proxy._pyroClaimOwnership()  # Claim ownership to keep Receiver thread-safe
                    result = self.proxy.get_property(f"{self.internal_preamble}{fullname}")
                    return self.__parse_result(result)

                @prop.setter
                def prop(self, value):
                    self.proxy._pyroClaimOwnership()  # Claim ownership to keep Receiver thread-safe
                    value = self.__serialize_parameter(value)
                    self.proxy.set_property(f"{self.internal_preamble}{fullname}", value)

                # Assign property to name given from register list
                setattr(self.__class__, splitname[-1], prop)
                self.__properties.add(splitname[-1])

                if debugprintlevel > 3:
                    print(f'retreived property {splitname[-1]} and set on {fullname}, instance {self}')

            else:
                log_str = self.my_name + '.' + fullname
                if debugprintlevel > 2:
                    print(' - ' + log_str)
                elif debugprintlevel > 1:
                    print('.', end='')

                if 'self,' in parameters:
                    parameters = parameters.replace('self, ', '')
                if parameters == 'self':
                    parameters = ''
                if member_str == '__call__':
                    member_str = '_call'
                if r'=(' in member_str:
                    print('Look at this.')

                # Remove defaults from the function signature. Original regexp had problem with defaults that are strings
                # with embedded commas. See VALTECH-150. Moved processing into a function.
                parameter_names = self.extract_param_names(parameters)
                try:
                    func_lambda = f'lambda self, {parameters}: self._run_proxy_function("{self.internal_preamble}{fullname}" ,{parameter_names})'
                    func = types.MethodType(eval(func_lambda), self)
                    function_target = self.__class__ if member_str.startswith('__') and member_str.endswith('__') else self
                    setattr(function_target, member_str, func)
                    if debugprintlevel > 3:
                        print(func_lambda)
                except Exception as err:
                    self.log.debug(f'Got error when evaluating {member_str}({parameters}) [{fullname}]: {repr(err)}')
                    self.log.dev(traceback.format_exc())

        elif len(splitname) > 1:
            if not hasattr(self, splitname[0]):
                # sub_cls = type(f'{splitname[0]}Receiver', (PyroReceiver,), {})
                setattr(self, splitname[0], PyroReceiver(self.my_name, debugprintlevel=self.debugprintlevel))

            existing_subclass = eval('self.' + splitname[0])
            try:
                if 'method' not in str(type(existing_subclass)):
                    existing_subclass.add_member(member_str[member_str.find('.') + 1:], fullname, parameters, master, debugprintlevel)
            except:
                pass
        else:
            print('Confused about ' + fullname)

    def extract_param_names(self, parameters):
        """
        Gathers parameters using a re.search, and then stores parameters.

        :param parameters: The parameter to strip.
        :return: parameter_names
        """
        # remove defaults that are tuples - i.e are surrounded by parenthesis
        parameter_names = re.sub(r'\s*=\s*\([^\)]*\)', '', parameters)  # "outputs=('P6V', 'P25V', 'N25V')" -> "outputs"
        # Remove defaults that are strings in single quotes - possibly with embedded commas.
        parameter_names = re.sub(r'\s*=\s*\'[^\']*\'', '', parameter_names)
        # Remove defaults that are strings in double quotes - possibly with embedded commas.
        parameter_names = re.sub(r'\s*=\s*"[^"]*"', '', parameter_names)
        # Remove non-string defaults. This was the original regexp.
        parameter_names = re.sub(r'\s*=\s*[^,]+', '', parameter_names)
        # Remove any extra white space.
        parameter_names = re.sub(r',\s*', ', ', parameter_names).strip()
        return parameter_names

    def find(self, findstring, **kwargs):
        """
        Finds the 'findstring' in self.register_info

        :param findstring: The string to find.
        :return: Returns the matched string in the register_info.
        """
        findstring = findstring.upper()
        for member_str in self.register_info:
            if member_str.upper().find(findstring) >= 0:
                print(member_str)


EXCLUDED = ['add_block_from_class', 'add_block_from_module', 'add_member', 'attributes', 'debugprintlevel', 'master']


def gen_pyi(obj, indent=0, ref_name=None, max_depth=1):
    """
    Generates pyi stub file contents for PyroReceivers in form of dictionary. Key is pyro proxy name, value is pyi info

    :param obj: Object to convert to pyi
    :param indent: current nest level
    :param ref_name: name of the object for class definition
    :param max_depth: maximum recursion level for member parsing
    :return: Dictionary of form: {PYRONAME: pyi file string}
    """
    pyi_string = '    '*indent + 'class ' + (obj.__class__.__name__ if ref_name is None else ref_name) +\
                 ('_master' if indent == 0 else '') + ':\n'
    try:
        for name, value in inspect.getmembers(obj):
            if name.startswith('_') or name == 'container' or name in EXCLUDED or (name == 'my_name' and indent > 0):
                continue
            if value is None:
                pyi_string += '    ' * (indent + 1) + name + ' = None\n'
            if inspect.ismethod(value):  # function
                sig = inspect.signature(value)
                sig_str = '(self, ' + str(sig)[1:]
                pyi_string += '    ' * (indent + 1) + 'def ' + name + sig_str + ': pass\n'
            elif isinstance(value, PyroReceiver) and indent < max_depth:  # recursively generate class pyi
                pyi_string += gen_pyi(value, indent=indent+1, ref_name=name, max_depth=max_depth) + '\n'
            else:  # Add attribute with type hinting
                pyi_string += '    '*(indent+1) + name + '= None\n'
    except:
        pyi_string = pyi_string[:-1] + ' pass\n'
    if indent == 0:  # Top level
        return {obj.my_name: pyi_string}
    return pyi_string
