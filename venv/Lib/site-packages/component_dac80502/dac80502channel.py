from cl_test_station.components.dacs.dac_channels.dac_channel import DacChannel
from typing import Dict, Union


class Dac80502Channel(DacChannel):
    """Dac80502 Base Channel (Dac + Op Amp"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def initialize(self, **kwargs):
        super().initialize(**kwargs)
        self._curr_voltage = self._calc_voltage(self.ch_block.RW.DATA.value)

    def source_voltage(self, voltage: Union[int, float] = None, *args, **kwargs) -> float:
        """
        Write value to dac channel and immediately update the channel

        :param voltage: Desired voltage on output of channel
        :type voltage: int, float
        :return: voltage value
        :rtype: float
        """
        super().source_voltage(*args, **kwargs)
        if voltage is not None:
            if self.sync_en == 0:
                self.ch_block.RW.DATA.value = self._calc_code(voltage)
            else:
                raise AttributeError(f'syn_en needs to be set to 0 for {self.ref_name} in {self.container.ref_name}'
                                     f' to be written and updated immediately')
        else:
            read_code = self.ch_block.RW.DATA.value
            return self._calc_voltage(read_code)

    def set_next_voltage(self, voltage: Union[int, float] = None, *args, **kwargs) -> float:
        """
        Write value to dac channel without updating channel

        :param voltage: Desired voltage to write
        :type voltage: int, float
        :return: voltage value
        :rtype: float
        """
        if voltage is not None:
            if self.sync_en == 1:
                self.ch_block.RW.DATA.value = self._calc_code(voltage)
            else:
                raise AttributeError(f'syn_en needs to be set to 1 for {self.ref_name} in {self.container.ref_name}'
                                     f' to be written and updated with LDAC funtionality')
        else:
            read_code = self.ch_block.RW.DATA.value
            return self._calc_voltage(read_code)

    def set_code(self, code: int = None) -> int:
        """
        Directly set code of DAC channel ouptut. May automatically update code to channel depending on SYNC_EN

        :param code: Code to set output of DAC channel to.
        :type code: int
        :return: Current code on DAC's output.
        :rtype: int
        """
        if code is not None:
            self.ch_block.RW.DATA.value = code
        else:
            return self.ch_block.RW.DATA.value

    @property
    def sync_en(self):
        """
        Writes update channel immediately or wait for LDAC

        :return: None
        :rtype: None
        """
        return self.ch_block.SYNC.EN.value

    @sync_en.setter
    def sync_en(self, new_sync):
        if new_sync == 0 or new_sync == 1:
            self.ch_block.SYNC.EN.value = new_sync
        else:
            raise ValueError('Invalid gain value')

    @property
    def dac_gain(self):
        """
        Sets internal op amp to gain of 2 or 1

        :return: Actual current gain setting
        :rtype: int
        """
        return self.ch_block.GAIN.DATA.value + 1  # 0 -> gain of 1, 1 -> gain of 2

    @dac_gain.setter
    def dac_gain(self, new_gain):
        if new_gain == 2 or new_gain == 1:
            self._gain = new_gain - 1
            self.ch_block.GAIN.DATA.value = new_gain - 1
        else:
            raise ValueError('Invalid gain value. Gain can be 1 or 2')

    def _calc_code(self, voltage) -> float:
        return super()._calc_code(voltage, dac_gain=self.dac_gain, div=self.container.div)

    def _calc_voltage(self, code: int) -> float:
        return super()._calc_voltage(code, dac_gain=self.dac_gain, div=self.container.div)