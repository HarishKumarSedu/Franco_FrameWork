#
# (c) 2018 Cirrus Logic, Inc.
#
# Author: Daniel Silverstone <daniel.silverstone@cirrus.com>
#
# Owner: SQA
#
# This code is proprietary and should not be shared outside of Cirrus
#

"""
QA Complete's object model is quite consistent throughout the v1 and v2 APIs.

This module provides an abstraction type which handles the basic interaction
with the API and which colludes with the iteration objects to allow objects
to be retrieved by ID or by some form of name/title.
"""
import yaml


class BasicObject(object):

    """
    A basic object, from which all singleton objects are derived.  Construction
    of these objects happen in one of two ways - either an id is provided or
    else a full object is provided.  This allows for construction by known
    id or by iteration-returned object.
    """

    #: The API version for this resource (must be overridden)
    apiver = "v1"

    #: The property used to find this resource kind by name. (must be overridden)
    nameproperty = "id"

    def __init__(self, connection, basis, resource_id=None, content=None):
        if resource_id is None and content is None:
            raise ValueError("One of id or content must be provided")
        self.connection = connection
        self.basis = basis
        if resource_id is None:
            self._populate(content)
        else:
            self.content = {"id": resource_id}
            self._populate(connection.request(self.apiver, self.uri))

    def _populate(self, content):
        """
        Populate this object with the given content from QAC
        """
        self.content = content

    def matches(self, name):
        """
        Check if this object matches the given name/whatever
        """
        return self.content.get(self.nameproperty, None) == name

    @property
    def uri(self):
        """
        The URI segment representing this object within QAC
        """
        return "%s/%d" % (self.basis, self.content["id"])

    def uriadd(self, command):
        """
        The add a resource to this QAC objects URI
        """
        return "{}/{}".format(self.uri,str(command))

    # pylint: disable=invalid-name
    @property
    def id(self):
        """
        The ID of the object.

        Note that it's safe to use this property to compare objects for identity
        when they are of the same class.  Do not use this to compare, for example,
        a :class:`qacomplete.test.Test` with a :class:`qacomplete.project.Project`.
        """
        return self.content["id"]

    def download_file(self, file_name):
        """
        Download file from QAC
        :param file_name: required file name
        :return: QAC file content as dictionary
        """
        for_meta_data = "%s/files" % self.uri
        meta_data_of_test = self.connection.request(self.apiver, for_meta_data)
        file_data = {}
        for meta_data in meta_data_of_test['results']:
            if 'file_name' in meta_data and file_name in meta_data['file_name']:
                file_id = meta_data['id']
                for_file = "%s/%s" % (for_meta_data, file_id)
                file_data = yaml.safe_load(self.connection.request(self.apiver, for_file))
        return file_data

    @property
    def folder(self):
        """
        The folder of the object

        Note that non folder objects return the full path of folders in which this
        item it located but a folder will just return its name, use full_folder_name
        to access its full path.

        For non folder objects this can also be used as a test to determine if a object
        is in a folder as if it is not in a folder this property will be None.
        """

        try:
            return self.content["folder_name"]
        except KeyError:
            return None

    @property
    def full_folder_name(self):
        """
        The full folder name of the folder object

        This trys to always return the full path of the object whether it is a folder
        or a other object.
        """

        try:
            return self.content["full_folder_name"]
        except KeyError:
            try:
                return self.content["folder_name"]
            except KeyError:
                return None
