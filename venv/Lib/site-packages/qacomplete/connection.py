#
# (c) 2018 Cirrus Logic, Inc.
#
# Author: Daniel Silverstone <daniel.silverstone@cirrus.com>
#
# Owner: SQA
#
# This code is proprietary and should not be shared outside of Cirrus
#

"""
Everything in the qacomplete module stems from the connection class herein.

The connection to QAC is not continuous (modulo keepalive HTTP sockets in the
underlying requests layer) but instead is via a RESTful API which is provided
by Swagger on the QAC side.  The ``QACConnection`` class ensures that there
is a consistent pythonic API for accessing the QAC resources.
"""

import requests
import urllib3
import sys
from datetime import datetime

if sys.version_info[0] == 3:
    from urllib.parse import urljoin
    basestring = str
elif sys.version_info[0] == 2:
    import urlparse
    from urlparse import urljoin

from .project import Projects


class QACBadAuthError(Exception):

    """
    Raised when the authentication data in use in a connection is bad.
    """


class QACConnectionError(Exception):

    """
    Raised when the connection has an otherwise unhandled error which usually
    indicates a programming error.
    """


class QACNotAuthorisedError(Exception):

    """
    Raised when a request is made for which the provided authentication data
    does not result in authorisation.  E.g. accessing a project which the user
    does not have rights to.
    """


class QACConnection(object):

    """
    A connection to a QA Complete instance.  You may need to call ``allow_insecure``
    if your QAC instance's SSL certificates are not correct.
    """

    #: The API offset used in this version of ``python-qacomplete``
    API_OFFSET = "rest-api/service/api/"

    def __init__(self, baseuri, username, password):
        """
        Construct a new QAConnection which refers to the given ``baseuri`` and
        authenticates using the supplied ``username`` and ``password``.

        Args:

            baseuri (str): The base URI of the QA Complete instance
            username (str): The username for authenticating to QA Complete
            password (str): The password for authenticating to QA Complete

        The QAConnection will automatically add the relative API URI to the
        given ``baseuri``.  For example, the v1 API is at
        ``/rest-api/service/api/v1/`` relative to the base.

        The resulting object will not have attempted to access the API.  If you
        wish to test the connection early, for example to ensure the parameters
        are correct, then you can try something like::

            try:
                conn = QACConnection(baseuri="http://my-server.com/",
                                     username="my-user",
                                     password="my-pass")
                conn.versions
            except QACBadAuthError, e:
                logging.critical("Unable to access QAComplete: %r" % e)

        """
        self.baseuri = urljoin(baseuri, QACConnection.API_OFFSET)
        self.session = requests.Session()
        self.session.headers.update({"Accept": "application/json"})
        self.session.auth = (username, password)

    def allow_insecure(self):
        """
        Allow contact with an insecure QA Complete installation.
        E.g. if it's http or the SSL cert is bad etc

        If used, this must be called *before* any request method or property
        is accessed.
        """
        self.session.verify = False

        urllib3.disable_warnings()

    @staticmethod
    def _process_response(resource, response):
        """
        Internal routine for processing responses from requests
        """

        if response.status_code == 200:
            try:
                return response.json()
            except ValueError:
                if hasattr(response, 'text'):
                    return response.text
                else:
                    return None

        try:
            message = response.json()["errors"][0]["message"]
        except (KeyError, ValueError, TypeError):
            message = "Unknown reason"
        print("\n\nUTC time: {}\n".format(datetime.utcnow()))
        print("Response code and message is:{} \n{}".format(response.status_code, message))
        print("System call information is: %s " % str(sys.exc_info()))
        if response.status_code == 302:
            # In theory we should follow
            raise NotImplementedError
        if response.status_code == 303:
            raise ValueError("Somehow we got a POST error code?")
        if response.status_code == 401:
            raise QACBadAuthError("Response code 401:User unauthorised. Check username/password")
        if response.status_code == 403:
            raise QACNotAuthorisedError("Response code 403:User Forbidden regardless of authorisation state")
        if response.status_code == 404:
            raise KeyError("Response code 404:%s Not Found" % resource)

        raise QACConnectionError(
            "Unknown/unhandled response code: {} \n{}".format(response.status_code,message))

    def request(self, apiver, resource, params=None):
        """
        Request a specific object from QAC.  This is typically used to retrieve
        a singleton object but it is generic and can be used to access the
        paging API within QAC as well.

        Typically this will be called by the other ``python-qacomplete`` classes
        but can be used to retrieve specific JSON objects by client code.
        """

        try:
            response = self.session.get(self._url(apiver, resource), params=params)
            return self._process_response(resource, response)
        except requests.exceptions.ConnectionError as err:
            raise QACConnectionError("Unable to reach url %s; Exception is: %s" % (self.baseuri, str(err)))
        except (QACBadAuthError, QACNotAuthorisedError) as err:
            raise err.__class__(str(err))
        except (ValueError, NotImplementedError, KeyError, QACConnectionError) as err:
            raise err.__class__(str(err))
        except Exception as err:
            raise err.__class__(str(err))

    def post(self, apiver, resource, body):
        """
        Post something to a resource (e.g. to provide logs).  This is used mostly
        internally but is available for use by client code if needed.
        """

        try:
            if isinstance(body, basestring):
                # Posting logs etc
                raise NotImplementedError
            if hasattr(body, "read"):
                response = self.session.post(
                    self._url(apiver, resource), files={"file": body}
                )
            else:
                # Posting JSON
                response = self.session.post(
                    self._url(apiver, resource), json=body)
                return self._process_response(resource, response)
        except (ValueError, NotImplementedError, KeyError, QACConnectionError) as err:
            raise err.__class__(str(err))
        except Exception as err:
            raise err.__class__(str(err))

    def patch(self, apiver, resource, body=None):
        """
        Patch a resource with some updates.  This is used by the testrunitem
        implementation to patch an item with its status and runtime.  It is
        exposed for use in client code in case something unusual needs to be
        done.
        """

        try:
            response = self.session.request(
                'PATCH', self._url(apiver, resource), json=body)
            return self._process_response(resource, response)
        except (ValueError, NotImplementedError, KeyError, QACConnectionError) as err:
            raise err.__class__(str(err))
        except Exception as err:
            raise err.__class__(str(err))

    def delete(self, apiver, resource):
        """
        Deletes the specified entity or resource from QAComplete project.
        This is used in RMS-QAC Sync Engine for synchronization of requirements in both RMS and QAC projects.

        Parameters:
        @param apiver - Specify version of the API.
        @param resource - Specify resource.

        Returns:
        HTTP status code.
        """

        try:
            response = self.session.delete(self._url(apiver, resource))
            return self._process_response(resource, response)
        except (ValueError, NotImplementedError, KeyError, QACConnectionError) as err:
            raise err.__class__(str(err))
        except Exception as err:
            raise err.__class__(str(err))

    def _url(self, apiver, resource):
        """
        Create a full URL to the QAC resource named
        """
        return urljoin(self.baseuri, "%s/%s" % (apiver, resource))

    @property
    def versions(self):
        """
        The versions of the server.

        The returned dictionary contains keys:

            ``rest``: The API version of the REST interface
            ``qac``: The version of QAC itself
            ``db``: The database version of the QAC instance
        """
        content = self.request("v1", "serverinfo")
        return {
            "rest": content["rest_version"],
            "qac": content["qac_version"],
            "db": content["db_version"],
        }

    @property
    def depts(self):
        """
        Retrieve a list of departments the logged in user is a member of from
        the QAC instance.

        The returned object can be iterated as normal, or indexed to find a
        particular department.  If you know the department's ID, then no paged
        API calls will be made at all, simplifying matters::

            for dept in connection.depts:
                pass

            my_dept = connection.depts[1234]
        """
        raise NotImplementedError

    @property
    def projects(self):
        """
        Retrieve a list of projects from the QAC instance.

        The returned object can be iterated as normal, or indexed to find a
        particular project.  If you know the project's ID, then no paged API
        calls will be made at all, simplifying matters::

            for project in connection.projects:
                pass

            my_project = connection.projects[1234]

        The returned object is a :class:`qacomplete.project.Projects` instance.

        """

        return Projects(self, resource="projects")
