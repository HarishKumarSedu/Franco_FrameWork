#
# (c) 2018 Cirrus Logic, Inc.
#
# Author: Daniel Silverstone <daniel.silverstone@cirrus.com>
#
# Owner: SQA
#
# This code is proprietary and should not be shared outside of Cirrus
#

"""
QA Complete's iteration APIs are semi-consistent between the v1 and v2 APIs.

The types in this module provide a generic abstraction over the paged iteration
APIs and ensures that things feel quite pythonic when used in client code.
"""
import sys
from .basicobject import BasicObject

if sys.version_info[0] == 3:
    basestring = str


class BasicIterableIterator(object):

    """
    A basic iterable object iterator.

    This is the embodiment of the QAC paged iteration API.
    """

    def __init__(self, iterable, start_offset=0, limit=25):
        self.iterable = iterable
        self.offset = start_offset
        self.limit = limit
        self.count = None
        self.cached = []
        self.stopped = False

    def iter(self):
        """
        Return an iterator on this iterator (self)
        """
        return self

    def __iter__(self):
        """
        Allow you to iterate this iterator by returning self
        """
        return self

    def common_next(self):
        """
        Retrieve the next object from the iterable API, refilling the cache
        as and when it runs out.  If we run out of objects in the API then
        raise the StopIteration exception.

        The object returned will be a subclass of :class:`qacomplete.basicobject.BasicObject` such
        as :class:`qacomplete.test.Test` or :class:`qacomplete.project.Project`.
        """
        if self.stopped:
            raise StopIteration
        try:
            return self.cached.pop(0)
        except IndexError:
            self._refill()
            try:
                return self.cached.pop(0)
            except IndexError:
                self.stopped = True
                raise StopIteration

    if sys.version_info[0] == 3:
        def __next__(self):
            """
            Python 3 supported iterators next method
            """
            return self.common_next()

    elif sys.version_info[0] == 2:
        def next(self):
            """
            Python 2 supported iterators next method
            """
            return self.common_next()

    def _refill(self):
        """
        Attempt to refill the cached set be fetching another page from the API
        """
        if (self.count is not None) and (self.offset >= self.count):
            # Early return to cause StopIteration
            return

        page = self.iterable.connection.request(
            apiver=self.iterable.apiver,
            resource=self.iterable.resource,
            params={
                "offset": str(self.offset),
                "limit": str(self.limit)
            }
        )

        meta = page["metadata"]["result_set"]

        if self.count is None:
            self.count = meta["total"]

        if meta["count"] > 0:
            for content in page["results"]:
                self.cached.append(self.iterable.objectclass(
                    connection=self.iterable.connection,
                    basis=self.iterable.resource,
                    content=content
                ))
            self.offset += meta["count"]


class BasicIterable(object):

    """
    A basic iterable object, from which all QAC paged iterables are dervied.

    **Note**: The paged API model in QA Complete means that any iteration will
    run the risk of having changes happen on the server mid-iteration which
    could result in confusing output.

    **Note**: Objects which result from iteration are not guaranteed to match
    identity when compared between iterations.  The reason for this is that
    there can be no guarantee from request to request that the content will be
    the same and so no caching is done at this API level.  To compare two
    returned objects for identity, check the ``id`` property instead.
    """

    @property
    def apiver(self):
        """
        The API Version for this resource.
        """
        return self.objectclass.apiver

    #: The object class which will be instantiated by this iterable.
    objectclass = BasicObject

    def __init__(self, connection, resource, limit=25):
        """
        Construct an iterable, taking the connection object for QA Complete,
        the resource in question (which will be appended to the path) and
        the class of the objects to construct for returned entries.

        Args:

            connection (qacomplete.QACConnection): The connection to QAC
            resource (str): The resource uri segment to be iterated
            limit (int): The number of items to request per page. Defaults to 25

        """
        self.connection = connection
        self.resource = resource
        self.limit = limit
        self.length = None

    def __iter__(self):
        """
        Iterate this resource, using the paged API.
        """
        return BasicIterableIterator(iterable=self, limit=self.limit)

    def iter(self):
        """
        Return an iterator over this resource, using the paged API.
        """
        return self.__iter__()

    def __len__(self):
        """
        Get the number of items in this iterable
        """
        if self.length is None:
            result = self.connection.request(
                apiver=self.apiver,
                resource=self.resource,
                params={
                    "limit": "0"
                }
            )
            self.length = result["metadata"]["result_set"]["total"]

        return self.length

    def len(self):
        """
        Get the number of items in this iterable resource.
        """
        return len(self)

    def __getitem__(self, item):
        """
        Request a specific element for this resource.  If the item requested
        is an integer it is considered an ID, otherwise it's considered to be
        a name/title/whatever and the resource class will be queried to find
        the property to use, and then the resource will be iterated until a
        returned object matches.

        The returned object will be a subclass of :class:`qacomplete.basicobject.BasicObject` such
        as :class:`qacomplete.test.Test` or :class:`qacomplete.project.Project`.
        """

        if isinstance(item, basestring):
            for obj in self:
                if obj.matches(item):
                    return obj
            raise KeyError
        else:
            iddict = {}
            iddict[self.objectclass.__name__.lower() + "_id"] = item
            return self.objectclass(connection=self.connection,
                                    basis=self.resource,
                                    **iddict)
