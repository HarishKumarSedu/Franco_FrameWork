"""
Generic Mmap helper classes for reading and writing words directly to memory addresses
Author: Evan Canter <evan.canter@cirrus.com>
"""
import os
import mmap
import struct
from typing import Dict, List


class MmapManager:

    def __init__(self):
        self.mmaps: Dict[int, MmapController] = {}

    def add_mmap(self, base_addr: int, size: int, word_size: int):
        """
        Creates a new MmapController and adds it to this class's internal dictionary.

        :param base_addr: Raw base address of memory space
        :type base_addr: int
        :param size: Size of Memory map, ie range of valid addresses this Mmap will have access to.
        :type size: int
        :param word_size: Size of word in bytes
        :type word_size: int
        :return: None
        """
        if base_addr in self.mmaps:  # Might already be one added here
            old_map = self.mmaps[base_addr]
            if (size, word_size) == (old_map.size, old_map.word_size):  # Mmap already exists, don't make one
                return
            else:  # Close old and make new
                old_map.close()
        self.mmaps[base_addr] = MmapController(base_addr=base_addr, size=size, word_size=word_size)

    def read(self, base_addr: int, offset: int, num_bytes: int) -> List[int]:
        """
        Uses Mmap with base address 'base_addr' and reads 'num_bytes' bytes from base_addr + offset.

        :param base_addr: Base address of the Mmap. Used to identify with MmapController to use
        :type base_addr: int
        :param offset: Register address offset from base address
        :type offset: int
        :param num_bytes: Number of bytes to read. Will equal the length of the returned list
        :type num_bytes: int
        :return: List of intergers containing bytes read from offset
        :rtype: list
        """
        return self.mmaps[base_addr].read(offset, num_bytes)

    def write(self, base_addr, offset, bytes_out):
        """
        Uses Mmap with base address 'base_addr' and writes 'bytes_out' to base_addr + offset.

        :param base_addr: Base address of the Mmap. Used to identify with MmapController to use
        :type base_addr: int
        :param offset: Register address offset from base address
        :type offset: int
        :param bytes_out: list of integers containing bytes to write
        :type bytes_out: list
        :return: None
        """
        return self.mmaps[base_addr].write(offset, bytes_out)


class MmapController:
    """Class that opens /dev/mem and creates a mmap object that can perform firect memory access"""

    def __init__(self, base_addr: int, size: int, word_size: int):
        self.word_size = word_size
        self.base_addr = base_addr  # Raw non-page alligned base address

        # Align base address with page size
        self.virt_base = self.base_addr & ~(mmap.PAGESIZE - 1)
        # Offset from page aligned base to real base addr
        self.virt_base_offset = (self.base_addr - self.virt_base) & ~(self.word_size - 1)
        # MMap size is always relative to page aligned base. Need to acount for difference
        self.size = self.virt_base_offset + size
        # Virtual size is just from the virtual base address to the end of the mmap region
        self.virt_size = size
        # Open mmap
        self.mmap_fd = os.open('/dev/mem', os.O_RDWR | os.O_SYNC)
        self.mmap = mmap.mmap(self.mmap_fd, self.size, mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE, offset=self.virt_base)

    def read(self, offset: int, num_bytes: int) -> List[int]:
        """
        Moves file pointer to offset and reads 'num_bytes' bytes from memory.

        :param offset: Register address offset from base address
        :type offset: int
        :param num_bytes: Number of bytes to read. Will equal the length of the returned list
        :type num_bytes: int
        :return: List of intergers containing bytes read from offset
        :rtype: list
        """
        if offset + num_bytes > self.virt_size:
            raise IndexError(f"Read out of range, {num_bytes} bytes from offset {offset} exceeds size {self.virt_size}")
        self.mmap.seek(self.virt_base_offset + offset)
        bytes_in = self.mmap.read(num_bytes)
        return list(bytes_in)

    def write(self, offset: int, bytes_out: List[int]):
        """
        Moves file pointer to offset and writes bytes to memory

        :param offset: Register address offset from base address
        :type offset: int
        :param bytes_out: list of integers containing bytes to write
        :type bytes_out: list
        :return: None
        """
        if offset + len(bytes_out) > self.virt_size:
            raise IndexError(f"Write out of range, writing {len(bytes_out)} bytes to offset {offset} exceeds "
                             f"size {self.virt_size}")
        self.mmap.seek(self.virt_base_offset + offset)
        self.mmap.write(bytes(bytes_out))

    def close(self):
        self.mmap.close()
        os.close(self.mmap_fd)
