# HCC Driver Python wrapper
# Writen By Kevin Gilbert and Dakota Koelling
# Tested with python 3.7
# Binding to hcc-spi-1 which is DEV_SPI_CS0
# Need to mux to correct controller:
# xi2c2 -b 2 -a read -P 0x67 -r 0x40 -z 1 -l 1
# xi2c2 -b 2 -a write -P 0x67 -r 0x40 -z 1 -v 01 # Set mux to PL controller

# spi_mux_sel=0x40 bit0, 0=PS, 1=PL
# spi_clk_sel=0x40 bit6:4
# dut_hcc_spi_clk_sel:0=48MHz
# dut_hcc_spi_clk_sel:1=24MHz
# dut_hcc_spi_clk_sel:2=12MHz
# dut_hcc_spi_clk_sel:3=6MHz
# dut_hcc_spi_clk_sel:4=PORTER


import sys
import os
import signal
import fcntl
import array
import traceback
from enum import IntEnum
from ctypes import *
from typing import Callable
from queue import Queue, Empty

HCC_SPI_MAGIC_NUMBER = 0x1A2B3C4D
HCC_SIGNUM = 44


class SPI_XFER_CMD(IntEnum):
    XFER_QUEUE = 0
    XFER_SYNC = 1
    XFER_POP = 2


# define HCC_SPI_REGISTER_TASK       _IOWR(HCC_SPI_MAGIC_NUMBER, 1, void *)
# define HCC_SPI_UNREGISTER_TASK     _IOWR(HCC_SPI_MAGIC_NUMBER, 2, void *)
# define HCC_SPI_QUEUE_XFER          _IOWR(HCC_SPI_MAGIC_NUMBER, 3, void *)
# define HCC_SPI_SYNC                _IOWR(HCC_SPI_MAGIC_NUMBER, 4, void *)
# define HCC_SPI_SETUP_DELAY         _IOWR(HCC_SPI_MAGIC_NUMBER, 5, void *)
# define HCC_SPI_SET_BIT_ORDER       _IOWR(HCC_SPI_MAGIC_NUMBER, 6, void *)
# define HCC_SPI_SET_SPI_CLK_MODE    _IOWR(HCC_SPI_MAGIC_NUMBER, 7, void *)
_IOC_NRBITS = 8
_IOC_TYPEBITS = 8
_IOC_SIZEBITS = 14
_IOC_DIRBITS = 2

_IOC_NRSHIFT = 0
_IOC_TYPESHIFT = (_IOC_NRSHIFT + _IOC_NRBITS)
_IOC_SIZESHIFT = (_IOC_TYPESHIFT + _IOC_TYPEBITS)
_IOC_DIRSHIFT = (_IOC_SIZESHIFT + _IOC_SIZEBITS)

_IOC_NONE = 0
_IOC_WRITE = 1
_IOC_READ = 2


def _IOC(dir, type, nr, size):
    if isinstance(size, str) or isinstance(size, bytes):
        size = struct.calcsize(size)
    return (dir << _IOC_DIRSHIFT | \
            type << _IOC_TYPESHIFT | \
            nr << _IOC_NRSHIFT | \
            size << _IOC_SIZESHIFT) & 0xFFFFFFFF


def _IO(type, nr): return _IOC(_IOC_NONE, type, nr, 0)


def _IOR(type, nr, size): return _IOC(_IOC_READ, type, nr, size)


def _IOW(type, nr, size): return _IOC(_IOC_WRITE, type, nr, size)


def _IOWR(type, nr, size): return _IOC(_IOC_READ | _IOC_WRITE, type, nr, size)


class hcc_spi_io_xfer(Structure):
    _fields_ = [('tx_buf', c_void_p),
                ('rx_buf', c_void_p),
                ('len', c_uint32),
                ('cs_delay', c_uint32),
                ('clock_speed', c_uint32)]


class HCCInterface(object):
    def __init__(self, devpath):
        """
        HCC_SPI_REGISTER_TASK = 0xeb3c4d01
        HCC_SPI_UNREGISTER_TASK = 0xeb3c4d02
        HCC_SPI_QUEUE_XFER = 0xeb3c4d03
        HCC_SPI_SYNC = 0xeb3c4d04
        """
        self.REGISTER_TASK = _IOWR(HCC_SPI_MAGIC_NUMBER, 1, 32)
        self.UNREGISTER_TASK = _IOWR(HCC_SPI_MAGIC_NUMBER, 2, 32)
        self.QUEUE_XFER = _IOWR(HCC_SPI_MAGIC_NUMBER, 3, 32)
        self.SYNC = _IOWR(HCC_SPI_MAGIC_NUMBER, 4, 32)
        self.SETUP_DELAY = _IOWR(HCC_SPI_MAGIC_NUMBER, 5, 32)
        self.SET_BIT_ORDER = _IOWR(HCC_SPI_MAGIC_NUMBER, 6, 32)
        self.SET_SPI_CLK_MODE = _IOWR(HCC_SPI_MAGIC_NUMBER, 7, 32)

        self._fd = None
        self._devpath = devpath
        self.status = 0
        self._queue = []
        self._stashed_queue = []
        self._hint_queue = Queue()

        try:
            self._fd = os.open(devpath, os.O_RDWR)
        except OSError as e:
            print(f'Error opening file descriptor to specified devpath: {devpath}')
            self.status = -1
            return

    def _command(self, cmd, args):
        """Raw IOCTL call wrapper
        """
        fcntl.ioctl(self._fd, cmd, args);

    def run_handler(self, signum, frame):
        print("Running HCC int handler: %s" % self.handler_func.__name__)
        print("Signum: %d" % signum, "Frame %s" % str(frame))
        try:
            self.handler_func()
        except:
            self.hint_queue_put(traceback.format_exc())

    def register(self, func: Callable):
        """Register Task with driver to start receiving interrupt signals
        """
        while not self._hint_queue.empty(): # Clear Queue
            self._hint_queue.get(timeout=0.25)
        self.handler_func = func
        # handler = lambda *args, f=func, q=self._hint_queue, **kwargs: q.put(f())
        signal.signal(HCC_SIGNUM, self.run_handler)
        try:
            self._command(self.REGISTER_TASK, 0)
        except OSError:
            print("Process already registered")

    def unregister(self):
        """Unregister Task with driver to stop receiving interrupt signals
        """
        try:
            self._command(self.UNREGISTER_TASK, 0)
        except OSError:
            print("Process is not regsistered")

    def hint_queue_get(self, timeout):
        try:
            return self._hint_queue.get(timeout=timeout)
        except Empty:
            return '__empty'

    def hint_queue_put(self, value):
        self._hint_queue.put(value, timeout=1)

    def queue_xfer(self, data, cs_delay=0, clock_speed=0):
        """Shift out `data` and return shifted in data.
        Args:
            data (bytes, bytearray, list): a byte array or list of 8-bit integers to shift out.
            cs_delay (int): Delay between CS assertions in usec. If 0, CS stays asserted until last transfer.
            clock_speed (int): clock speed in Hz. 24MHz is 24000000.
        Raises:
            SPIError: if an I/O or OS error occurs.
            TypeError: if `data` type is invalid.
            ValueError: if data is not valid bytes.
        """
        if not isinstance(data, (bytes, bytearray, list)):
            raise TypeError("Invalid data type, should be bytes, bytearray, or list.")

        # Create mutable array
        try:
            buf = array.array('B', data)
        except OverflowError:
            raise ValueError("Invalid data bytes.")

        rx_buf = array.array('B', bytes(len(data)))

        buf_addr, buf_len = buf.buffer_info()
        rx_buf_addr, rx_buf_len = rx_buf.buffer_info()

        # Prepare transfer structure
        spi_xfer = hcc_spi_io_xfer()
        spi_xfer.tx_buf = buf_addr
        spi_xfer.rx_buf = rx_buf_addr
        spi_xfer.len = buf_len
        spi_xfer.cs_delay = cs_delay
        spi_xfer.clock_speed = clock_speed

        # Save a ref
        self._queue.append(rx_buf)

        # Transfer
        try:
            self._command(self.QUEUE_XFER, spi_xfer)
        except (OSError, IOError) as e:
            raise SPIError(e.errno, "SPI transfer: " + e.strerror)

    def sync(self):
        """This will trigger the controller to clock out all queued transfers
        """
        self._command(self.SYNC, 0)


    def set_setup_delay(self, value):
        """This will configure the controller setup delay for transactions
        """
        xfer = c_uint32(value)
        self._command(self.SETUP_DELAY, xfer)

    def set_bit_order(self, value):
        """This will configure the controllers word bit-order (0 = MSB, 1 = LSB)
        """
        xfer = c_uint32(value)
        self._command(self.SET_BIT_ORDER, xfer)

    def set_clk_mode(self, value):
        """This will configure the controllers clock mode
        0 = (!CPHA | !CPOL)
        1 = (CPHA | !CPOL)
        2 = (!CPHA | CPOL)
        3 = (CPHA | CPOL)
        """
        xfer = c_uint32(value)
        self._command(self.SET_SPI_CLK_MODE, xfer)

    def pop(self):
        """Pop the receive buffer out of the FIFO
        Returns:
            list: data shifted in.
        """
        first_xfer_buf = self._queue.pop(0)
        data_list = first_xfer_buf.tolist()
        return data_list

    @property
    def queue_empty(self):
        return not self._queue

    def stash_queue(self):
        self._stashed_queue = self._queue
        self._queue = []

    def stash_pop(self):
        self._queue = self._stashed_queue

    def close(self):
        if self._fd is None:
            return
        try:
            os.close(self._fd)
        except OSError as e:
            print(f'Error closing file descriptor: {e}')
            pass
        self._fd = None

    def __del__(self):
        self.close()


def main():

    a = HCCInterface('/dev/hcc-spi-2.1')  # /dev/hcc-spi-X
    print(f'Return a: {a.status}')

    print(hex(a.REGISTER_TASK))
    data_to_send = [0x12, 0x34, 0x56, 0x78, 0x90]
    a.queue_xfer(data_to_send)
    print("data queued")
    a.sync()
    print("transfer sync'd")
    read_data = a.pop()
    print("transfer pop'd")
    print("["+",".join([hex(p) for p in read_data])+"]")


def main_with_int():
    signal.signal(signal.SIGINT, generic_signal_handler)

    a = HCCInterface('/dev/hcc-spi-1')  # /dev/hcc-spi-X
    print(f'Return a: {a.status}')

    print(hex(a.REGISTER_TASK))
    a.unregister()
    a.register()
    print("Registered wrap")

    data_to_send = [0x12, 0x34, 0x56, 0x78, 0x90]
    a.queue_xfer(data_to_send)
    print("data queued")
    a.sync()
    print("transfer sync'd")
    read_data = a.pop()
    print("transfer pop'd")
    print("[" + ",".join([hex(p) for p in read_data]) + "]")

    a.unregister()
    print("UNRegistered wrap")


if __name__ == '__main__':
    main()
