#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def ping(self):
        pass

    def server_eval(self, expression):
        """
        Parameters:
         - expression

        """
        pass

    def reload_modules(self, modules):
        """
        Parameters:
         - modules

        """
        pass

    def embed_test_station(self, serialized_station, env_vars):
        """
        Parameters:
         - serialized_station
         - env_vars

        """
        pass

    def ping_test_station(self):
        pass

    def burst(self, lines, vars, aliases):
        """
        Parameters:
         - lines
         - vars
         - aliases

        """
        pass

    def get_traceback(self):
        pass

    def program_xmos_image(self, image):
        """
        Parameters:
         - image

        """
        pass

    def get_variants(self):
        pass

    def get_current_variant(self):
        pass

    def set_variant(self, variant, reboot):
        """
        Parameters:
         - variant
         - reboot

        """
        pass

    def gpioinfo(self):
        pass

    def get_active_gpio_info(self):
        pass

    def get_active_gpios_list(self):
        pass

    def get_gpio(self, chip_num, line_num):
        """
        Parameters:
         - chip_num
         - line_num

        """
        pass

    def set_gpio(self, chip_num, line_num, value):
        """
        Parameters:
         - chip_num
         - line_num
         - value

        """
        pass

    def get_gpio_by_name(self, name):
        """
        Parameters:
         - name

        """
        pass

    def set_gpio_by_name(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        pass

    def get_gpio_direction(self, chip_num, line_num):
        """
        Parameters:
         - chip_num
         - line_num

        """
        pass

    def set_gpio_direction(self, chip_num, line_num, direction):
        """
        Parameters:
         - chip_num
         - line_num
         - direction

        """
        pass

    def get_gpio_direction_by_name(self, name):
        """
        Parameters:
         - name

        """
        pass

    def set_gpio_direction_by_name(self, name, direction):
        """
        Parameters:
         - name
         - direction

        """
        pass

    def toggle_gpio(self, chip_num, line_num, active_low, delay, pulse_width):
        """
        Parameters:
         - chip_num
         - line_num
         - active_low
         - delay
         - pulse_width

        """
        pass

    def toggle_gpio_by_name(self, name, active_low, delay, pulse_width):
        """
        Parameters:
         - name
         - active_low
         - delay
         - pulse_width

        """
        pass

    def reset_dut(self, mode, active_low):
        """
        Parameters:
         - mode
         - active_low

        """
        pass

    def reset_wrapper(self, mode, active_low):
        """
        Parameters:
         - mode
         - active_low

        """
        pass

    def set_rail_voltage(self, voltage):
        """
        Parameters:
         - voltage

        """
        pass

    def write_i2c_reg(self, reg_addr, write_data, dev_addr, bus_num, speed, repeat_start, write_reg_addr_size, ainc, address_stride, write_reg_data_size):
        """
        Parameters:
         - reg_addr
         - write_data
         - dev_addr
         - bus_num
         - speed
         - repeat_start
         - write_reg_addr_size
         - ainc
         - address_stride
         - write_reg_data_size

        """
        pass

    def read_i2c_reg(self, reg_addr, byte_count, dev_addr, bus_num, speed, repeat_start, read_reg_addr_size, ainc, address_stride, read_reg_data_size):
        """
        Parameters:
         - reg_addr
         - byte_count
         - dev_addr
         - bus_num
         - speed
         - repeat_start
         - read_reg_addr_size
         - ainc
         - address_stride
         - read_reg_data_size

        """
        pass

    def i2c_device_write(self, bus_num, speed, dev_addr, write_data):
        """
        Parameters:
         - bus_num
         - speed
         - dev_addr
         - write_data

        """
        pass

    def i2c_device_read(self, bus_num, speed, dev_addr, byte_count):
        """
        Parameters:
         - bus_num
         - speed
         - dev_addr
         - byte_count

        """
        pass

    def i2c_check_ack(self, bus_num, speed, dev_addr):
        """
        Parameters:
         - bus_num
         - speed
         - dev_addr

        """
        pass

    def i2c_scan(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        pass

    def set_i2c_bus_speed(self, bus_num, speed):
        """
        Parameters:
         - bus_num
         - speed

        """
        pass

    def spi_fd(self, bytes_out, bus_num, chip_select, speed, keep_cs, clk_mode):
        """
        Parameters:
         - bytes_out
         - bus_num
         - chip_select
         - speed
         - keep_cs
         - clk_mode

        """
        pass

    def spi_apb_block_read(self, bus_num, chip_select, speed, address, addr_size, data_size, length):
        """
        Parameters:
         - bus_num
         - chip_select
         - speed
         - address
         - addr_size
         - data_size
         - length

        """
        pass

    def spi_apb_block_write(self, bus_num, chip_select, speed, address, values, addr_size, data_size):
        """
        Parameters:
         - bus_num
         - chip_select
         - speed
         - address
         - values
         - addr_size
         - data_size

        """
        pass

    def mmap_add(self, base_addr, size, word_size):
        """
        Parameters:
         - base_addr
         - size
         - word_size

        """
        pass

    def mmap_read(self, base_addr, offset, num_bytes):
        """
        Parameters:
         - base_addr
         - offset
         - num_bytes

        """
        pass

    def mmap_write(self, base_addr, offset, bytes_out):
        """
        Parameters:
         - base_addr
         - offset
         - bytes_out

        """
        pass

    def memio_write(self, addr, data):
        """
        Parameters:
         - addr
         - data

        """
        pass

    def memio_read(self, addr):
        """
        Parameters:
         - addr

        """
        pass

    def handle_interrupt(self, int_id):
        """
        Parameters:
         - int_id

        """
        pass

    def start_embedded_interrupt_handling(self, int_map, verbose, functions):
        """
        Parameters:
         - int_map
         - verbose
         - functions

        """
        pass

    def print_from_buffer(self):
        pass

    def stop_embedded_interrupt_handling(self):
        pass

    def empty_server_queue(self):
        pass

    def release_lock(self):
        pass

    def enable_spmi(self, base_addr):
        """
        Parameters:
         - base_addr

        """
        pass

    def disable_spmi(self):
        pass

    def spmi_device_initialize(self, device_type, device_id, f_tclk, ddba_addr, inten, enr):
        """
        Parameters:
         - device_type
         - device_id
         - f_tclk
         - ddba_addr
         - inten
         - enr

        """
        pass

    def spmi_device_disable(self):
        pass

    def spmi_set_master_req_prescaler(self, rate):
        """
        Parameters:
         - rate

        """
        pass

    def spmi_set_slave_addr(self, addr):
        """
        Parameters:
         - addr

        """
        pass

    def spmi_set_master_addr(self, addr):
        """
        Parameters:
         - addr

        """
        pass

    def spmi_set_ip_version(self, version):
        """
        Parameters:
         - version

        """
        pass

    def spmi_poll_command_sent_flag(self, clear_all_flags):
        """
        Parameters:
         - clear_all_flags

        """
        pass

    def spmi_master_write(self, master_id, address, data, use_a_bit, use_sr_bit):
        """
        Parameters:
         - master_id
         - address
         - data
         - use_a_bit
         - use_sr_bit

        """
        pass

    def spmi_master_read(self, master_id, address, size, use_a_bit, use_sr_bit):
        """
        Parameters:
         - master_id
         - address
         - size
         - use_a_bit
         - use_sr_bit

        """
        pass

    def spmi_register_write(self, slave_id, address, data, priority):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority

        """
        pass

    def spmi_register_read(self, slave_id, address, priority):
        """
        Parameters:
         - slave_id
         - address
         - priority

        """
        pass

    def spmi_extended_register_write(self, slave_id, address, data, priority):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority

        """
        pass

    def spmi_extended_register_read(self, slave_id, address, size, priority):
        """
        Parameters:
         - slave_id
         - address
         - size
         - priority

        """
        pass

    def spmi_extended_register_write_long(self, slave_id, address, data, priority):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority

        """
        pass

    def spmi_extended_register_read_long(self, slave_id, address, size, priority):
        """
        Parameters:
         - slave_id
         - address
         - size
         - priority

        """
        pass

    def spmi_24bit_write(self, slave_id, address, data, priority, p_inx):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority
         - p_inx

        """
        pass

    def spmi_24bit_read(self, slave_id, address, word_count, priority, p_inx):
        """
        Parameters:
         - slave_id
         - address
         - word_count
         - priority
         - p_inx

        """
        pass

    def spmi_block_read(self, peripheral_id, start_addr, byte_count, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - start_addr
         - byte_count
         - addressibility
         - priority

        """
        pass

    def spmi_block_write(self, peripheral_id, start_addr, data, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - start_addr
         - data
         - addressibility
         - priority

        """
        pass

    def spmi_chain_read(self, peripheral_id, address, num_reads, read_size, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - address
         - num_reads
         - read_size
         - addressibility
         - priority

        """
        pass

    def spmi_chain_write(self, peripheral_id, address, data, write_size, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - address
         - data
         - write_size
         - addressibility
         - priority

        """
        pass

    def master_write(self, master_id, address, data, use_a_bit):
        """
        Parameters:
         - master_id
         - address
         - data
         - use_a_bit

        """
        pass

    def spmi_dump_registers(self):
        pass

    def hcc_queue_packets(self, packets, cs_delays):
        """
        Parameters:
         - packets
         - cs_delays

        """
        pass

    def hcc_send_packet(self, packet, cs_delay):
        """
        Parameters:
         - packet
         - cs_delay

        """
        pass

    def hcc_execute_packet_queue(self):
        pass

    def enable_hcc(self, bus_num, chip_select):
        """
        Parameters:
         - bus_num
         - chip_select

        """
        pass

    def disable_hcc(self):
        pass

    def hcc_set_speed(self, speed):
        """
        Parameters:
         - speed

        """
        pass

    def hcc_set_setup_delay(self, delay):
        """
        Parameters:
         - delay

        """
        pass

    def hcc_set_bit_order(self, order):
        """
        Parameters:
         - order

        """
        pass

    def hcc_set_clk_mode(self, mode):
        """
        Parameters:
         - mode

        """
        pass

    def hcc_register(self, handler):
        """
        Parameters:
         - handler

        """
        pass

    def hcc_unregister(self):
        pass

    def hcc_hint_queue_get(self, timeout):
        """
        Parameters:
         - timeout

        """
        pass

    def enable_i3c(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        pass

    def disable_i3c(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        pass

    def i3c_controller_rstdaa(self, bus_num, address, detach_devs):
        """
        Parameters:
         - bus_num
         - address
         - detach_devs

        """
        pass

    def i3c_controller_setaasa(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        pass

    def i3c_controller_setdasa(self, bus_num, static_addr, dyn_addr):
        """
        Parameters:
         - bus_num
         - static_addr
         - dyn_addr

        """
        pass

    def i3c_controller_setnewda(self, bus_num, old_addr, new_addr):
        """
        Parameters:
         - bus_num
         - old_addr
         - new_addr

        """
        pass

    def i3c_controller_dodaa(self, bus_num, reset_addr_assignments):
        """
        Parameters:
         - bus_num
         - reset_addr_assignments

        """
        pass

    def i3c_controller_disec(self, bus_num, address, payload):
        """
        Parameters:
         - bus_num
         - address
         - payload

        """
        pass

    def i3c_controller_enec(self, bus_num, payload):
        """
        Parameters:
         - bus_num
         - payload

        """
        pass

    def i3c_controller_getpid(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        pass

    def i3c_controller_getbcr(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        pass

    def i3c_controller_getdcr(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        pass

    def i3c_controller_getstatus(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        pass

    def i3c_controller_add_device(self, bus_num, static_addr, dyn_addr):
        """
        Parameters:
         - bus_num
         - static_addr
         - dyn_addr

        """
        pass

    def i3c_controller_get_devices(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        pass

    def i3c_read_device(self, bus_num, address, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - num_bytes
         - preamble_bytes
         - add_device

        """
        pass

    def i3c_read_reg(self, bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - num_bytes
         - preamble_bytes
         - add_device

        """
        pass

    def i3c_write_device(self, bus_num, address, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - write_data
         - preamble_bytes
         - add_device

        """
        pass

    def i3c_write_reg(self, bus_num, address, reg_addr, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - write_data
         - preamble_bytes
         - add_device

        """
        pass

    def i3c_controller_add_i2c_device(self, bus_num, address, replace):
        """
        Parameters:
         - bus_num
         - address
         - replace

        """
        pass

    def i3c_controller_get_i2c_devices(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        pass

    def i3c_controller_remove_device(self, bus_num, address):
        """
        Parameters:
         - bus_num
         - address

        """
        pass

    def i3c_legacy_i2c_read_device(self, bus_num, address, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - num_bytes
         - preamble_bytes
         - add_device

        """
        pass

    def i3c_legacy_i2c_read_reg(self, bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - num_bytes
         - preamble_bytes
         - add_device

        """
        pass

    def i3c_legacy_i2c_write_device(self, bus_num, address, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - write_data
         - preamble_bytes
         - add_device

        """
        pass

    def i3c_legacy_i2c_write_reg(self, bus_num, address, reg_addr, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - write_data
         - preamble_bytes
         - add_device

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        self.send_ping()
        return self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ping failed: unknown result")

    def server_eval(self, expression):
        """
        Parameters:
         - expression

        """
        self.send_server_eval(expression)
        return self.recv_server_eval()

    def send_server_eval(self, expression):
        self._oprot.writeMessageBegin('server_eval', TMessageType.CALL, self._seqid)
        args = server_eval_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_server_eval(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = server_eval_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.json_err is not None:
            raise result.json_err
        if result.server_err is not None:
            raise result.server_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "server_eval failed: unknown result")

    def reload_modules(self, modules):
        """
        Parameters:
         - modules

        """
        self.send_reload_modules(modules)
        self.recv_reload_modules()

    def send_reload_modules(self, modules):
        self._oprot.writeMessageBegin('reload_modules', TMessageType.CALL, self._seqid)
        args = reload_modules_args()
        args.modules = modules
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reload_modules(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reload_modules_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def embed_test_station(self, serialized_station, env_vars):
        """
        Parameters:
         - serialized_station
         - env_vars

        """
        self.send_embed_test_station(serialized_station, env_vars)
        return self.recv_embed_test_station()

    def send_embed_test_station(self, serialized_station, env_vars):
        self._oprot.writeMessageBegin('embed_test_station', TMessageType.CALL, self._seqid)
        args = embed_test_station_args()
        args.serialized_station = serialized_station
        args.env_vars = env_vars
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_embed_test_station(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = embed_test_station_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "embed_test_station failed: unknown result")

    def ping_test_station(self):
        self.send_ping_test_station()
        return self.recv_ping_test_station()

    def send_ping_test_station(self):
        self._oprot.writeMessageBegin('ping_test_station', TMessageType.CALL, self._seqid)
        args = ping_test_station_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping_test_station(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_test_station_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ping_test_station failed: unknown result")

    def burst(self, lines, vars, aliases):
        """
        Parameters:
         - lines
         - vars
         - aliases

        """
        self.send_burst(lines, vars, aliases)
        return self.recv_burst()

    def send_burst(self, lines, vars, aliases):
        self._oprot.writeMessageBegin('burst', TMessageType.CALL, self._seqid)
        args = burst_args()
        args.lines = lines
        args.vars = vars
        args.aliases = aliases
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_burst(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = burst_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "burst failed: unknown result")

    def get_traceback(self):
        self.send_get_traceback()
        return self.recv_get_traceback()

    def send_get_traceback(self):
        self._oprot.writeMessageBegin('get_traceback', TMessageType.CALL, self._seqid)
        args = get_traceback_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_traceback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_traceback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_traceback failed: unknown result")

    def program_xmos_image(self, image):
        """
        Parameters:
         - image

        """
        self.send_program_xmos_image(image)
        return self.recv_program_xmos_image()

    def send_program_xmos_image(self, image):
        self._oprot.writeMessageBegin('program_xmos_image', TMessageType.CALL, self._seqid)
        args = program_xmos_image_args()
        args.image = image
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_program_xmos_image(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = program_xmos_image_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "program_xmos_image failed: unknown result")

    def get_variants(self):
        self.send_get_variants()
        return self.recv_get_variants()

    def send_get_variants(self):
        self._oprot.writeMessageBegin('get_variants', TMessageType.CALL, self._seqid)
        args = get_variants_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_variants(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_variants_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_variants failed: unknown result")

    def get_current_variant(self):
        self.send_get_current_variant()
        return self.recv_get_current_variant()

    def send_get_current_variant(self):
        self._oprot.writeMessageBegin('get_current_variant', TMessageType.CALL, self._seqid)
        args = get_current_variant_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_current_variant(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_current_variant_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_current_variant failed: unknown result")

    def set_variant(self, variant, reboot):
        """
        Parameters:
         - variant
         - reboot

        """
        self.send_set_variant(variant, reboot)
        self.recv_set_variant()

    def send_set_variant(self, variant, reboot):
        self._oprot.writeMessageBegin('set_variant', TMessageType.CALL, self._seqid)
        args = set_variant_args()
        args.variant = variant
        args.reboot = reboot
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_variant(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_variant_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def gpioinfo(self):
        self.send_gpioinfo()
        return self.recv_gpioinfo()

    def send_gpioinfo(self):
        self._oprot.writeMessageBegin('gpioinfo', TMessageType.CALL, self._seqid)
        args = gpioinfo_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_gpioinfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = gpioinfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "gpioinfo failed: unknown result")

    def get_active_gpio_info(self):
        self.send_get_active_gpio_info()
        return self.recv_get_active_gpio_info()

    def send_get_active_gpio_info(self):
        self._oprot.writeMessageBegin('get_active_gpio_info', TMessageType.CALL, self._seqid)
        args = get_active_gpio_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_active_gpio_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_active_gpio_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_active_gpio_info failed: unknown result")

    def get_active_gpios_list(self):
        self.send_get_active_gpios_list()
        return self.recv_get_active_gpios_list()

    def send_get_active_gpios_list(self):
        self._oprot.writeMessageBegin('get_active_gpios_list', TMessageType.CALL, self._seqid)
        args = get_active_gpios_list_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_active_gpios_list(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_active_gpios_list_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_active_gpios_list failed: unknown result")

    def get_gpio(self, chip_num, line_num):
        """
        Parameters:
         - chip_num
         - line_num

        """
        self.send_get_gpio(chip_num, line_num)
        return self.recv_get_gpio()

    def send_get_gpio(self, chip_num, line_num):
        self._oprot.writeMessageBegin('get_gpio', TMessageType.CALL, self._seqid)
        args = get_gpio_args()
        args.chip_num = chip_num
        args.line_num = line_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_gpio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_gpio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_gpio failed: unknown result")

    def set_gpio(self, chip_num, line_num, value):
        """
        Parameters:
         - chip_num
         - line_num
         - value

        """
        self.send_set_gpio(chip_num, line_num, value)
        self.recv_set_gpio()

    def send_set_gpio(self, chip_num, line_num, value):
        self._oprot.writeMessageBegin('set_gpio', TMessageType.CALL, self._seqid)
        args = set_gpio_args()
        args.chip_num = chip_num
        args.line_num = line_num
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_gpio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_gpio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err is not None:
            raise result.err
        return

    def get_gpio_by_name(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_gpio_by_name(name)
        return self.recv_get_gpio_by_name()

    def send_get_gpio_by_name(self, name):
        self._oprot.writeMessageBegin('get_gpio_by_name', TMessageType.CALL, self._seqid)
        args = get_gpio_by_name_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_gpio_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_gpio_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_gpio_by_name failed: unknown result")

    def set_gpio_by_name(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        self.send_set_gpio_by_name(name, value)
        self.recv_set_gpio_by_name()

    def send_set_gpio_by_name(self, name, value):
        self._oprot.writeMessageBegin('set_gpio_by_name', TMessageType.CALL, self._seqid)
        args = set_gpio_by_name_args()
        args.name = name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_gpio_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_gpio_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err is not None:
            raise result.err
        return

    def get_gpio_direction(self, chip_num, line_num):
        """
        Parameters:
         - chip_num
         - line_num

        """
        self.send_get_gpio_direction(chip_num, line_num)
        return self.recv_get_gpio_direction()

    def send_get_gpio_direction(self, chip_num, line_num):
        self._oprot.writeMessageBegin('get_gpio_direction', TMessageType.CALL, self._seqid)
        args = get_gpio_direction_args()
        args.chip_num = chip_num
        args.line_num = line_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_gpio_direction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_gpio_direction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_gpio_direction failed: unknown result")

    def set_gpio_direction(self, chip_num, line_num, direction):
        """
        Parameters:
         - chip_num
         - line_num
         - direction

        """
        self.send_set_gpio_direction(chip_num, line_num, direction)
        self.recv_set_gpio_direction()

    def send_set_gpio_direction(self, chip_num, line_num, direction):
        self._oprot.writeMessageBegin('set_gpio_direction', TMessageType.CALL, self._seqid)
        args = set_gpio_direction_args()
        args.chip_num = chip_num
        args.line_num = line_num
        args.direction = direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_gpio_direction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_gpio_direction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err is not None:
            raise result.err
        return

    def get_gpio_direction_by_name(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_gpio_direction_by_name(name)
        return self.recv_get_gpio_direction_by_name()

    def send_get_gpio_direction_by_name(self, name):
        self._oprot.writeMessageBegin('get_gpio_direction_by_name', TMessageType.CALL, self._seqid)
        args = get_gpio_direction_by_name_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_gpio_direction_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_gpio_direction_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_gpio_direction_by_name failed: unknown result")

    def set_gpio_direction_by_name(self, name, direction):
        """
        Parameters:
         - name
         - direction

        """
        self.send_set_gpio_direction_by_name(name, direction)
        self.recv_set_gpio_direction_by_name()

    def send_set_gpio_direction_by_name(self, name, direction):
        self._oprot.writeMessageBegin('set_gpio_direction_by_name', TMessageType.CALL, self._seqid)
        args = set_gpio_direction_by_name_args()
        args.name = name
        args.direction = direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_gpio_direction_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_gpio_direction_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err is not None:
            raise result.err
        return

    def toggle_gpio(self, chip_num, line_num, active_low, delay, pulse_width):
        """
        Parameters:
         - chip_num
         - line_num
         - active_low
         - delay
         - pulse_width

        """
        self.send_toggle_gpio(chip_num, line_num, active_low, delay, pulse_width)
        self.recv_toggle_gpio()

    def send_toggle_gpio(self, chip_num, line_num, active_low, delay, pulse_width):
        self._oprot.writeMessageBegin('toggle_gpio', TMessageType.CALL, self._seqid)
        args = toggle_gpio_args()
        args.chip_num = chip_num
        args.line_num = line_num
        args.active_low = active_low
        args.delay = delay
        args.pulse_width = pulse_width
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_toggle_gpio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = toggle_gpio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err is not None:
            raise result.err
        return

    def toggle_gpio_by_name(self, name, active_low, delay, pulse_width):
        """
        Parameters:
         - name
         - active_low
         - delay
         - pulse_width

        """
        self.send_toggle_gpio_by_name(name, active_low, delay, pulse_width)
        self.recv_toggle_gpio_by_name()

    def send_toggle_gpio_by_name(self, name, active_low, delay, pulse_width):
        self._oprot.writeMessageBegin('toggle_gpio_by_name', TMessageType.CALL, self._seqid)
        args = toggle_gpio_by_name_args()
        args.name = name
        args.active_low = active_low
        args.delay = delay
        args.pulse_width = pulse_width
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_toggle_gpio_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = toggle_gpio_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err is not None:
            raise result.err
        return

    def reset_dut(self, mode, active_low):
        """
        Parameters:
         - mode
         - active_low

        """
        self.send_reset_dut(mode, active_low)
        self.recv_reset_dut()

    def send_reset_dut(self, mode, active_low):
        self._oprot.writeMessageBegin('reset_dut', TMessageType.CALL, self._seqid)
        args = reset_dut_args()
        args.mode = mode
        args.active_low = active_low
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reset_dut(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reset_dut_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def reset_wrapper(self, mode, active_low):
        """
        Parameters:
         - mode
         - active_low

        """
        self.send_reset_wrapper(mode, active_low)
        self.recv_reset_wrapper()

    def send_reset_wrapper(self, mode, active_low):
        self._oprot.writeMessageBegin('reset_wrapper', TMessageType.CALL, self._seqid)
        args = reset_wrapper_args()
        args.mode = mode
        args.active_low = active_low
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reset_wrapper(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reset_wrapper_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def set_rail_voltage(self, voltage):
        """
        Parameters:
         - voltage

        """
        self.send_set_rail_voltage(voltage)
        self.recv_set_rail_voltage()

    def send_set_rail_voltage(self, voltage):
        self._oprot.writeMessageBegin('set_rail_voltage', TMessageType.CALL, self._seqid)
        args = set_rail_voltage_args()
        args.voltage = voltage
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_rail_voltage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_rail_voltage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def write_i2c_reg(self, reg_addr, write_data, dev_addr, bus_num, speed, repeat_start, write_reg_addr_size, ainc, address_stride, write_reg_data_size):
        """
        Parameters:
         - reg_addr
         - write_data
         - dev_addr
         - bus_num
         - speed
         - repeat_start
         - write_reg_addr_size
         - ainc
         - address_stride
         - write_reg_data_size

        """
        self.send_write_i2c_reg(reg_addr, write_data, dev_addr, bus_num, speed, repeat_start, write_reg_addr_size, ainc, address_stride, write_reg_data_size)
        return self.recv_write_i2c_reg()

    def send_write_i2c_reg(self, reg_addr, write_data, dev_addr, bus_num, speed, repeat_start, write_reg_addr_size, ainc, address_stride, write_reg_data_size):
        self._oprot.writeMessageBegin('write_i2c_reg', TMessageType.CALL, self._seqid)
        args = write_i2c_reg_args()
        args.reg_addr = reg_addr
        args.write_data = write_data
        args.dev_addr = dev_addr
        args.bus_num = bus_num
        args.speed = speed
        args.repeat_start = repeat_start
        args.write_reg_addr_size = write_reg_addr_size
        args.ainc = ainc
        args.address_stride = address_stride
        args.write_reg_data_size = write_reg_data_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_i2c_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_i2c_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_i2c_reg failed: unknown result")

    def read_i2c_reg(self, reg_addr, byte_count, dev_addr, bus_num, speed, repeat_start, read_reg_addr_size, ainc, address_stride, read_reg_data_size):
        """
        Parameters:
         - reg_addr
         - byte_count
         - dev_addr
         - bus_num
         - speed
         - repeat_start
         - read_reg_addr_size
         - ainc
         - address_stride
         - read_reg_data_size

        """
        self.send_read_i2c_reg(reg_addr, byte_count, dev_addr, bus_num, speed, repeat_start, read_reg_addr_size, ainc, address_stride, read_reg_data_size)
        return self.recv_read_i2c_reg()

    def send_read_i2c_reg(self, reg_addr, byte_count, dev_addr, bus_num, speed, repeat_start, read_reg_addr_size, ainc, address_stride, read_reg_data_size):
        self._oprot.writeMessageBegin('read_i2c_reg', TMessageType.CALL, self._seqid)
        args = read_i2c_reg_args()
        args.reg_addr = reg_addr
        args.byte_count = byte_count
        args.dev_addr = dev_addr
        args.bus_num = bus_num
        args.speed = speed
        args.repeat_start = repeat_start
        args.read_reg_addr_size = read_reg_addr_size
        args.ainc = ainc
        args.address_stride = address_stride
        args.read_reg_data_size = read_reg_data_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_i2c_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_i2c_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_i2c_reg failed: unknown result")

    def i2c_device_write(self, bus_num, speed, dev_addr, write_data):
        """
        Parameters:
         - bus_num
         - speed
         - dev_addr
         - write_data

        """
        self.send_i2c_device_write(bus_num, speed, dev_addr, write_data)
        return self.recv_i2c_device_write()

    def send_i2c_device_write(self, bus_num, speed, dev_addr, write_data):
        self._oprot.writeMessageBegin('i2c_device_write', TMessageType.CALL, self._seqid)
        args = i2c_device_write_args()
        args.bus_num = bus_num
        args.speed = speed
        args.dev_addr = dev_addr
        args.write_data = write_data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i2c_device_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i2c_device_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i2c_device_write failed: unknown result")

    def i2c_device_read(self, bus_num, speed, dev_addr, byte_count):
        """
        Parameters:
         - bus_num
         - speed
         - dev_addr
         - byte_count

        """
        self.send_i2c_device_read(bus_num, speed, dev_addr, byte_count)
        return self.recv_i2c_device_read()

    def send_i2c_device_read(self, bus_num, speed, dev_addr, byte_count):
        self._oprot.writeMessageBegin('i2c_device_read', TMessageType.CALL, self._seqid)
        args = i2c_device_read_args()
        args.bus_num = bus_num
        args.speed = speed
        args.dev_addr = dev_addr
        args.byte_count = byte_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i2c_device_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i2c_device_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i2c_device_read failed: unknown result")

    def i2c_check_ack(self, bus_num, speed, dev_addr):
        """
        Parameters:
         - bus_num
         - speed
         - dev_addr

        """
        self.send_i2c_check_ack(bus_num, speed, dev_addr)
        return self.recv_i2c_check_ack()

    def send_i2c_check_ack(self, bus_num, speed, dev_addr):
        self._oprot.writeMessageBegin('i2c_check_ack', TMessageType.CALL, self._seqid)
        args = i2c_check_ack_args()
        args.bus_num = bus_num
        args.speed = speed
        args.dev_addr = dev_addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i2c_check_ack(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i2c_check_ack_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i2c_check_ack failed: unknown result")

    def i2c_scan(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        self.send_i2c_scan(bus_num)
        return self.recv_i2c_scan()

    def send_i2c_scan(self, bus_num):
        self._oprot.writeMessageBegin('i2c_scan', TMessageType.CALL, self._seqid)
        args = i2c_scan_args()
        args.bus_num = bus_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i2c_scan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i2c_scan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i2c_scan failed: unknown result")

    def set_i2c_bus_speed(self, bus_num, speed):
        """
        Parameters:
         - bus_num
         - speed

        """
        self.send_set_i2c_bus_speed(bus_num, speed)
        self.recv_set_i2c_bus_speed()

    def send_set_i2c_bus_speed(self, bus_num, speed):
        self._oprot.writeMessageBegin('set_i2c_bus_speed', TMessageType.CALL, self._seqid)
        args = set_i2c_bus_speed_args()
        args.bus_num = bus_num
        args.speed = speed
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_i2c_bus_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_i2c_bus_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def spi_fd(self, bytes_out, bus_num, chip_select, speed, keep_cs, clk_mode):
        """
        Parameters:
         - bytes_out
         - bus_num
         - chip_select
         - speed
         - keep_cs
         - clk_mode

        """
        self.send_spi_fd(bytes_out, bus_num, chip_select, speed, keep_cs, clk_mode)
        return self.recv_spi_fd()

    def send_spi_fd(self, bytes_out, bus_num, chip_select, speed, keep_cs, clk_mode):
        self._oprot.writeMessageBegin('spi_fd', TMessageType.CALL, self._seqid)
        args = spi_fd_args()
        args.bytes_out = bytes_out
        args.bus_num = bus_num
        args.chip_select = chip_select
        args.speed = speed
        args.keep_cs = keep_cs
        args.clk_mode = clk_mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spi_fd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spi_fd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spi_fd failed: unknown result")

    def spi_apb_block_read(self, bus_num, chip_select, speed, address, addr_size, data_size, length):
        """
        Parameters:
         - bus_num
         - chip_select
         - speed
         - address
         - addr_size
         - data_size
         - length

        """
        self.send_spi_apb_block_read(bus_num, chip_select, speed, address, addr_size, data_size, length)
        return self.recv_spi_apb_block_read()

    def send_spi_apb_block_read(self, bus_num, chip_select, speed, address, addr_size, data_size, length):
        self._oprot.writeMessageBegin('spi_apb_block_read', TMessageType.CALL, self._seqid)
        args = spi_apb_block_read_args()
        args.bus_num = bus_num
        args.chip_select = chip_select
        args.speed = speed
        args.address = address
        args.addr_size = addr_size
        args.data_size = data_size
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spi_apb_block_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spi_apb_block_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spi_apb_block_read failed: unknown result")

    def spi_apb_block_write(self, bus_num, chip_select, speed, address, values, addr_size, data_size):
        """
        Parameters:
         - bus_num
         - chip_select
         - speed
         - address
         - values
         - addr_size
         - data_size

        """
        self.send_spi_apb_block_write(bus_num, chip_select, speed, address, values, addr_size, data_size)
        self.recv_spi_apb_block_write()

    def send_spi_apb_block_write(self, bus_num, chip_select, speed, address, values, addr_size, data_size):
        self._oprot.writeMessageBegin('spi_apb_block_write', TMessageType.CALL, self._seqid)
        args = spi_apb_block_write_args()
        args.bus_num = bus_num
        args.chip_select = chip_select
        args.speed = speed
        args.address = address
        args.values = values
        args.addr_size = addr_size
        args.data_size = data_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spi_apb_block_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spi_apb_block_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def mmap_add(self, base_addr, size, word_size):
        """
        Parameters:
         - base_addr
         - size
         - word_size

        """
        self.send_mmap_add(base_addr, size, word_size)
        self.recv_mmap_add()

    def send_mmap_add(self, base_addr, size, word_size):
        self._oprot.writeMessageBegin('mmap_add', TMessageType.CALL, self._seqid)
        args = mmap_add_args()
        args.base_addr = base_addr
        args.size = size
        args.word_size = word_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mmap_add(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mmap_add_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def mmap_read(self, base_addr, offset, num_bytes):
        """
        Parameters:
         - base_addr
         - offset
         - num_bytes

        """
        self.send_mmap_read(base_addr, offset, num_bytes)
        return self.recv_mmap_read()

    def send_mmap_read(self, base_addr, offset, num_bytes):
        self._oprot.writeMessageBegin('mmap_read', TMessageType.CALL, self._seqid)
        args = mmap_read_args()
        args.base_addr = base_addr
        args.offset = offset
        args.num_bytes = num_bytes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mmap_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mmap_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mmap_read failed: unknown result")

    def mmap_write(self, base_addr, offset, bytes_out):
        """
        Parameters:
         - base_addr
         - offset
         - bytes_out

        """
        self.send_mmap_write(base_addr, offset, bytes_out)
        self.recv_mmap_write()

    def send_mmap_write(self, base_addr, offset, bytes_out):
        self._oprot.writeMessageBegin('mmap_write', TMessageType.CALL, self._seqid)
        args = mmap_write_args()
        args.base_addr = base_addr
        args.offset = offset
        args.bytes_out = bytes_out
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mmap_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mmap_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def memio_write(self, addr, data):
        """
        Parameters:
         - addr
         - data

        """
        self.send_memio_write(addr, data)
        return self.recv_memio_write()

    def send_memio_write(self, addr, data):
        self._oprot.writeMessageBegin('memio_write', TMessageType.CALL, self._seqid)
        args = memio_write_args()
        args.addr = addr
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_memio_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = memio_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "memio_write failed: unknown result")

    def memio_read(self, addr):
        """
        Parameters:
         - addr

        """
        self.send_memio_read(addr)
        return self.recv_memio_read()

    def send_memio_read(self, addr):
        self._oprot.writeMessageBegin('memio_read', TMessageType.CALL, self._seqid)
        args = memio_read_args()
        args.addr = addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_memio_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = memio_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "memio_read failed: unknown result")

    def handle_interrupt(self, int_id):
        """
        Parameters:
         - int_id

        """
        self.send_handle_interrupt(int_id)
        return self.recv_handle_interrupt()

    def send_handle_interrupt(self, int_id):
        self._oprot.writeMessageBegin('handle_interrupt', TMessageType.CALL, self._seqid)
        args = handle_interrupt_args()
        args.int_id = int_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_handle_interrupt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = handle_interrupt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "handle_interrupt failed: unknown result")

    def start_embedded_interrupt_handling(self, int_map, verbose, functions):
        """
        Parameters:
         - int_map
         - verbose
         - functions

        """
        self.send_start_embedded_interrupt_handling(int_map, verbose, functions)
        return self.recv_start_embedded_interrupt_handling()

    def send_start_embedded_interrupt_handling(self, int_map, verbose, functions):
        self._oprot.writeMessageBegin('start_embedded_interrupt_handling', TMessageType.CALL, self._seqid)
        args = start_embedded_interrupt_handling_args()
        args.int_map = int_map
        args.verbose = verbose
        args.functions = functions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_embedded_interrupt_handling(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_embedded_interrupt_handling_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_embedded_interrupt_handling failed: unknown result")

    def print_from_buffer(self):
        self.send_print_from_buffer()
        return self.recv_print_from_buffer()

    def send_print_from_buffer(self):
        self._oprot.writeMessageBegin('print_from_buffer', TMessageType.CALL, self._seqid)
        args = print_from_buffer_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_print_from_buffer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = print_from_buffer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "print_from_buffer failed: unknown result")

    def stop_embedded_interrupt_handling(self):
        self.send_stop_embedded_interrupt_handling()
        return self.recv_stop_embedded_interrupt_handling()

    def send_stop_embedded_interrupt_handling(self):
        self._oprot.writeMessageBegin('stop_embedded_interrupt_handling', TMessageType.CALL, self._seqid)
        args = stop_embedded_interrupt_handling_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_embedded_interrupt_handling(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_embedded_interrupt_handling_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stop_embedded_interrupt_handling failed: unknown result")

    def empty_server_queue(self):
        self.send_empty_server_queue()
        return self.recv_empty_server_queue()

    def send_empty_server_queue(self):
        self._oprot.writeMessageBegin('empty_server_queue', TMessageType.CALL, self._seqid)
        args = empty_server_queue_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_empty_server_queue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = empty_server_queue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "empty_server_queue failed: unknown result")

    def release_lock(self):
        self.send_release_lock()
        self.recv_release_lock()

    def send_release_lock(self):
        self._oprot.writeMessageBegin('release_lock', TMessageType.CALL, self._seqid)
        args = release_lock_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_release_lock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = release_lock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def enable_spmi(self, base_addr):
        """
        Parameters:
         - base_addr

        """
        self.send_enable_spmi(base_addr)
        return self.recv_enable_spmi()

    def send_enable_spmi(self, base_addr):
        self._oprot.writeMessageBegin('enable_spmi', TMessageType.CALL, self._seqid)
        args = enable_spmi_args()
        args.base_addr = base_addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_spmi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_spmi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_spmi failed: unknown result")

    def disable_spmi(self):
        self.send_disable_spmi()
        self.recv_disable_spmi()

    def send_disable_spmi(self):
        self._oprot.writeMessageBegin('disable_spmi', TMessageType.CALL, self._seqid)
        args = disable_spmi_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_spmi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_spmi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def spmi_device_initialize(self, device_type, device_id, f_tclk, ddba_addr, inten, enr):
        """
        Parameters:
         - device_type
         - device_id
         - f_tclk
         - ddba_addr
         - inten
         - enr

        """
        self.send_spmi_device_initialize(device_type, device_id, f_tclk, ddba_addr, inten, enr)
        return self.recv_spmi_device_initialize()

    def send_spmi_device_initialize(self, device_type, device_id, f_tclk, ddba_addr, inten, enr):
        self._oprot.writeMessageBegin('spmi_device_initialize', TMessageType.CALL, self._seqid)
        args = spmi_device_initialize_args()
        args.device_type = device_type
        args.device_id = device_id
        args.f_tclk = f_tclk
        args.ddba_addr = ddba_addr
        args.inten = inten
        args.enr = enr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_device_initialize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_device_initialize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_device_initialize failed: unknown result")

    def spmi_device_disable(self):
        self.send_spmi_device_disable()
        return self.recv_spmi_device_disable()

    def send_spmi_device_disable(self):
        self._oprot.writeMessageBegin('spmi_device_disable', TMessageType.CALL, self._seqid)
        args = spmi_device_disable_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_device_disable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_device_disable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_device_disable failed: unknown result")

    def spmi_set_master_req_prescaler(self, rate):
        """
        Parameters:
         - rate

        """
        self.send_spmi_set_master_req_prescaler(rate)
        return self.recv_spmi_set_master_req_prescaler()

    def send_spmi_set_master_req_prescaler(self, rate):
        self._oprot.writeMessageBegin('spmi_set_master_req_prescaler', TMessageType.CALL, self._seqid)
        args = spmi_set_master_req_prescaler_args()
        args.rate = rate
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_set_master_req_prescaler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_set_master_req_prescaler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_set_master_req_prescaler failed: unknown result")

    def spmi_set_slave_addr(self, addr):
        """
        Parameters:
         - addr

        """
        self.send_spmi_set_slave_addr(addr)
        return self.recv_spmi_set_slave_addr()

    def send_spmi_set_slave_addr(self, addr):
        self._oprot.writeMessageBegin('spmi_set_slave_addr', TMessageType.CALL, self._seqid)
        args = spmi_set_slave_addr_args()
        args.addr = addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_set_slave_addr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_set_slave_addr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_set_slave_addr failed: unknown result")

    def spmi_set_master_addr(self, addr):
        """
        Parameters:
         - addr

        """
        self.send_spmi_set_master_addr(addr)
        return self.recv_spmi_set_master_addr()

    def send_spmi_set_master_addr(self, addr):
        self._oprot.writeMessageBegin('spmi_set_master_addr', TMessageType.CALL, self._seqid)
        args = spmi_set_master_addr_args()
        args.addr = addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_set_master_addr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_set_master_addr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_set_master_addr failed: unknown result")

    def spmi_set_ip_version(self, version):
        """
        Parameters:
         - version

        """
        self.send_spmi_set_ip_version(version)
        return self.recv_spmi_set_ip_version()

    def send_spmi_set_ip_version(self, version):
        self._oprot.writeMessageBegin('spmi_set_ip_version', TMessageType.CALL, self._seqid)
        args = spmi_set_ip_version_args()
        args.version = version
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_set_ip_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_set_ip_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_set_ip_version failed: unknown result")

    def spmi_poll_command_sent_flag(self, clear_all_flags):
        """
        Parameters:
         - clear_all_flags

        """
        self.send_spmi_poll_command_sent_flag(clear_all_flags)
        return self.recv_spmi_poll_command_sent_flag()

    def send_spmi_poll_command_sent_flag(self, clear_all_flags):
        self._oprot.writeMessageBegin('spmi_poll_command_sent_flag', TMessageType.CALL, self._seqid)
        args = spmi_poll_command_sent_flag_args()
        args.clear_all_flags = clear_all_flags
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_poll_command_sent_flag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_poll_command_sent_flag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_poll_command_sent_flag failed: unknown result")

    def spmi_master_write(self, master_id, address, data, use_a_bit, use_sr_bit):
        """
        Parameters:
         - master_id
         - address
         - data
         - use_a_bit
         - use_sr_bit

        """
        self.send_spmi_master_write(master_id, address, data, use_a_bit, use_sr_bit)
        return self.recv_spmi_master_write()

    def send_spmi_master_write(self, master_id, address, data, use_a_bit, use_sr_bit):
        self._oprot.writeMessageBegin('spmi_master_write', TMessageType.CALL, self._seqid)
        args = spmi_master_write_args()
        args.master_id = master_id
        args.address = address
        args.data = data
        args.use_a_bit = use_a_bit
        args.use_sr_bit = use_sr_bit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_master_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_master_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_master_write failed: unknown result")

    def spmi_master_read(self, master_id, address, size, use_a_bit, use_sr_bit):
        """
        Parameters:
         - master_id
         - address
         - size
         - use_a_bit
         - use_sr_bit

        """
        self.send_spmi_master_read(master_id, address, size, use_a_bit, use_sr_bit)
        return self.recv_spmi_master_read()

    def send_spmi_master_read(self, master_id, address, size, use_a_bit, use_sr_bit):
        self._oprot.writeMessageBegin('spmi_master_read', TMessageType.CALL, self._seqid)
        args = spmi_master_read_args()
        args.master_id = master_id
        args.address = address
        args.size = size
        args.use_a_bit = use_a_bit
        args.use_sr_bit = use_sr_bit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_master_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_master_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_master_read failed: unknown result")

    def spmi_register_write(self, slave_id, address, data, priority):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority

        """
        self.send_spmi_register_write(slave_id, address, data, priority)
        return self.recv_spmi_register_write()

    def send_spmi_register_write(self, slave_id, address, data, priority):
        self._oprot.writeMessageBegin('spmi_register_write', TMessageType.CALL, self._seqid)
        args = spmi_register_write_args()
        args.slave_id = slave_id
        args.address = address
        args.data = data
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_register_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_register_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_register_write failed: unknown result")

    def spmi_register_read(self, slave_id, address, priority):
        """
        Parameters:
         - slave_id
         - address
         - priority

        """
        self.send_spmi_register_read(slave_id, address, priority)
        return self.recv_spmi_register_read()

    def send_spmi_register_read(self, slave_id, address, priority):
        self._oprot.writeMessageBegin('spmi_register_read', TMessageType.CALL, self._seqid)
        args = spmi_register_read_args()
        args.slave_id = slave_id
        args.address = address
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_register_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_register_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_register_read failed: unknown result")

    def spmi_extended_register_write(self, slave_id, address, data, priority):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority

        """
        self.send_spmi_extended_register_write(slave_id, address, data, priority)
        return self.recv_spmi_extended_register_write()

    def send_spmi_extended_register_write(self, slave_id, address, data, priority):
        self._oprot.writeMessageBegin('spmi_extended_register_write', TMessageType.CALL, self._seqid)
        args = spmi_extended_register_write_args()
        args.slave_id = slave_id
        args.address = address
        args.data = data
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_extended_register_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_extended_register_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_extended_register_write failed: unknown result")

    def spmi_extended_register_read(self, slave_id, address, size, priority):
        """
        Parameters:
         - slave_id
         - address
         - size
         - priority

        """
        self.send_spmi_extended_register_read(slave_id, address, size, priority)
        return self.recv_spmi_extended_register_read()

    def send_spmi_extended_register_read(self, slave_id, address, size, priority):
        self._oprot.writeMessageBegin('spmi_extended_register_read', TMessageType.CALL, self._seqid)
        args = spmi_extended_register_read_args()
        args.slave_id = slave_id
        args.address = address
        args.size = size
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_extended_register_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_extended_register_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_extended_register_read failed: unknown result")

    def spmi_extended_register_write_long(self, slave_id, address, data, priority):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority

        """
        self.send_spmi_extended_register_write_long(slave_id, address, data, priority)
        return self.recv_spmi_extended_register_write_long()

    def send_spmi_extended_register_write_long(self, slave_id, address, data, priority):
        self._oprot.writeMessageBegin('spmi_extended_register_write_long', TMessageType.CALL, self._seqid)
        args = spmi_extended_register_write_long_args()
        args.slave_id = slave_id
        args.address = address
        args.data = data
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_extended_register_write_long(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_extended_register_write_long_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_extended_register_write_long failed: unknown result")

    def spmi_extended_register_read_long(self, slave_id, address, size, priority):
        """
        Parameters:
         - slave_id
         - address
         - size
         - priority

        """
        self.send_spmi_extended_register_read_long(slave_id, address, size, priority)
        return self.recv_spmi_extended_register_read_long()

    def send_spmi_extended_register_read_long(self, slave_id, address, size, priority):
        self._oprot.writeMessageBegin('spmi_extended_register_read_long', TMessageType.CALL, self._seqid)
        args = spmi_extended_register_read_long_args()
        args.slave_id = slave_id
        args.address = address
        args.size = size
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_extended_register_read_long(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_extended_register_read_long_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_extended_register_read_long failed: unknown result")

    def spmi_24bit_write(self, slave_id, address, data, priority, p_inx):
        """
        Parameters:
         - slave_id
         - address
         - data
         - priority
         - p_inx

        """
        self.send_spmi_24bit_write(slave_id, address, data, priority, p_inx)
        return self.recv_spmi_24bit_write()

    def send_spmi_24bit_write(self, slave_id, address, data, priority, p_inx):
        self._oprot.writeMessageBegin('spmi_24bit_write', TMessageType.CALL, self._seqid)
        args = spmi_24bit_write_args()
        args.slave_id = slave_id
        args.address = address
        args.data = data
        args.priority = priority
        args.p_inx = p_inx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_24bit_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_24bit_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_24bit_write failed: unknown result")

    def spmi_24bit_read(self, slave_id, address, word_count, priority, p_inx):
        """
        Parameters:
         - slave_id
         - address
         - word_count
         - priority
         - p_inx

        """
        self.send_spmi_24bit_read(slave_id, address, word_count, priority, p_inx)
        return self.recv_spmi_24bit_read()

    def send_spmi_24bit_read(self, slave_id, address, word_count, priority, p_inx):
        self._oprot.writeMessageBegin('spmi_24bit_read', TMessageType.CALL, self._seqid)
        args = spmi_24bit_read_args()
        args.slave_id = slave_id
        args.address = address
        args.word_count = word_count
        args.priority = priority
        args.p_inx = p_inx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_24bit_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_24bit_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_24bit_read failed: unknown result")

    def spmi_block_read(self, peripheral_id, start_addr, byte_count, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - start_addr
         - byte_count
         - addressibility
         - priority

        """
        self.send_spmi_block_read(peripheral_id, start_addr, byte_count, addressibility, priority)
        return self.recv_spmi_block_read()

    def send_spmi_block_read(self, peripheral_id, start_addr, byte_count, addressibility, priority):
        self._oprot.writeMessageBegin('spmi_block_read', TMessageType.CALL, self._seqid)
        args = spmi_block_read_args()
        args.peripheral_id = peripheral_id
        args.start_addr = start_addr
        args.byte_count = byte_count
        args.addressibility = addressibility
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_block_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_block_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_block_read failed: unknown result")

    def spmi_block_write(self, peripheral_id, start_addr, data, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - start_addr
         - data
         - addressibility
         - priority

        """
        self.send_spmi_block_write(peripheral_id, start_addr, data, addressibility, priority)
        self.recv_spmi_block_write()

    def send_spmi_block_write(self, peripheral_id, start_addr, data, addressibility, priority):
        self._oprot.writeMessageBegin('spmi_block_write', TMessageType.CALL, self._seqid)
        args = spmi_block_write_args()
        args.peripheral_id = peripheral_id
        args.start_addr = start_addr
        args.data = data
        args.addressibility = addressibility
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_block_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_block_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        return

    def spmi_chain_read(self, peripheral_id, address, num_reads, read_size, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - address
         - num_reads
         - read_size
         - addressibility
         - priority

        """
        self.send_spmi_chain_read(peripheral_id, address, num_reads, read_size, addressibility, priority)
        return self.recv_spmi_chain_read()

    def send_spmi_chain_read(self, peripheral_id, address, num_reads, read_size, addressibility, priority):
        self._oprot.writeMessageBegin('spmi_chain_read', TMessageType.CALL, self._seqid)
        args = spmi_chain_read_args()
        args.peripheral_id = peripheral_id
        args.address = address
        args.num_reads = num_reads
        args.read_size = read_size
        args.addressibility = addressibility
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_chain_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_chain_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_chain_read failed: unknown result")

    def spmi_chain_write(self, peripheral_id, address, data, write_size, addressibility, priority):
        """
        Parameters:
         - peripheral_id
         - address
         - data
         - write_size
         - addressibility
         - priority

        """
        self.send_spmi_chain_write(peripheral_id, address, data, write_size, addressibility, priority)
        self.recv_spmi_chain_write()

    def send_spmi_chain_write(self, peripheral_id, address, data, write_size, addressibility, priority):
        self._oprot.writeMessageBegin('spmi_chain_write', TMessageType.CALL, self._seqid)
        args = spmi_chain_write_args()
        args.peripheral_id = peripheral_id
        args.address = address
        args.data = data
        args.write_size = write_size
        args.addressibility = addressibility
        args.priority = priority
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_chain_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_chain_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.timeout_err is not None:
            raise result.timeout_err
        if result.arb_err is not None:
            raise result.arb_err
        return

    def master_write(self, master_id, address, data, use_a_bit):
        """
        Parameters:
         - master_id
         - address
         - data
         - use_a_bit

        """
        self.send_master_write(master_id, address, data, use_a_bit)
        return self.recv_master_write()

    def send_master_write(self, master_id, address, data, use_a_bit):
        self._oprot.writeMessageBegin('master_write', TMessageType.CALL, self._seqid)
        args = master_write_args()
        args.master_id = master_id
        args.address = address
        args.data = data
        args.use_a_bit = use_a_bit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_master_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = master_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "master_write failed: unknown result")

    def spmi_dump_registers(self):
        self.send_spmi_dump_registers()
        return self.recv_spmi_dump_registers()

    def send_spmi_dump_registers(self):
        self._oprot.writeMessageBegin('spmi_dump_registers', TMessageType.CALL, self._seqid)
        args = spmi_dump_registers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spmi_dump_registers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spmi_dump_registers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spmi_dump_registers failed: unknown result")

    def hcc_queue_packets(self, packets, cs_delays):
        """
        Parameters:
         - packets
         - cs_delays

        """
        self.send_hcc_queue_packets(packets, cs_delays)
        self.recv_hcc_queue_packets()

    def send_hcc_queue_packets(self, packets, cs_delays):
        self._oprot.writeMessageBegin('hcc_queue_packets', TMessageType.CALL, self._seqid)
        args = hcc_queue_packets_args()
        args.packets = packets
        args.cs_delays = cs_delays
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_queue_packets(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_queue_packets_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        return

    def hcc_send_packet(self, packet, cs_delay):
        """
        Parameters:
         - packet
         - cs_delay

        """
        self.send_hcc_send_packet(packet, cs_delay)
        return self.recv_hcc_send_packet()

    def send_hcc_send_packet(self, packet, cs_delay):
        self._oprot.writeMessageBegin('hcc_send_packet', TMessageType.CALL, self._seqid)
        args = hcc_send_packet_args()
        args.packet = packet
        args.cs_delay = cs_delay
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_send_packet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_send_packet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.hcc_err is not None:
            raise result.hcc_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hcc_send_packet failed: unknown result")

    def hcc_execute_packet_queue(self):
        self.send_hcc_execute_packet_queue()
        return self.recv_hcc_execute_packet_queue()

    def send_hcc_execute_packet_queue(self):
        self._oprot.writeMessageBegin('hcc_execute_packet_queue', TMessageType.CALL, self._seqid)
        args = hcc_execute_packet_queue_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_execute_packet_queue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_execute_packet_queue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.hcc_err is not None:
            raise result.hcc_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hcc_execute_packet_queue failed: unknown result")

    def enable_hcc(self, bus_num, chip_select):
        """
        Parameters:
         - bus_num
         - chip_select

        """
        self.send_enable_hcc(bus_num, chip_select)
        self.recv_enable_hcc()

    def send_enable_hcc(self, bus_num, chip_select):
        self._oprot.writeMessageBegin('enable_hcc', TMessageType.CALL, self._seqid)
        args = enable_hcc_args()
        args.bus_num = bus_num
        args.chip_select = chip_select
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_hcc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_hcc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        if result.i2c_err is not None:
            raise result.i2c_err
        return

    def disable_hcc(self):
        self.send_disable_hcc()
        self.recv_disable_hcc()

    def send_disable_hcc(self):
        self._oprot.writeMessageBegin('disable_hcc', TMessageType.CALL, self._seqid)
        args = disable_hcc_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_hcc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_hcc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        if result.i2c_err is not None:
            raise result.i2c_err
        return

    def hcc_set_speed(self, speed):
        """
        Parameters:
         - speed

        """
        self.send_hcc_set_speed(speed)
        self.recv_hcc_set_speed()

    def send_hcc_set_speed(self, speed):
        self._oprot.writeMessageBegin('hcc_set_speed', TMessageType.CALL, self._seqid)
        args = hcc_set_speed_args()
        args.speed = speed
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_set_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_set_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        if result.i2c_err is not None:
            raise result.i2c_err
        return

    def hcc_set_setup_delay(self, delay):
        """
        Parameters:
         - delay

        """
        self.send_hcc_set_setup_delay(delay)
        self.recv_hcc_set_setup_delay()

    def send_hcc_set_setup_delay(self, delay):
        self._oprot.writeMessageBegin('hcc_set_setup_delay', TMessageType.CALL, self._seqid)
        args = hcc_set_setup_delay_args()
        args.delay = delay
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_set_setup_delay(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_set_setup_delay_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        return

    def hcc_set_bit_order(self, order):
        """
        Parameters:
         - order

        """
        self.send_hcc_set_bit_order(order)
        self.recv_hcc_set_bit_order()

    def send_hcc_set_bit_order(self, order):
        self._oprot.writeMessageBegin('hcc_set_bit_order', TMessageType.CALL, self._seqid)
        args = hcc_set_bit_order_args()
        args.order = order
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_set_bit_order(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_set_bit_order_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        return

    def hcc_set_clk_mode(self, mode):
        """
        Parameters:
         - mode

        """
        self.send_hcc_set_clk_mode(mode)
        self.recv_hcc_set_clk_mode()

    def send_hcc_set_clk_mode(self, mode):
        self._oprot.writeMessageBegin('hcc_set_clk_mode', TMessageType.CALL, self._seqid)
        args = hcc_set_clk_mode_args()
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_set_clk_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_set_clk_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        return

    def hcc_register(self, handler):
        """
        Parameters:
         - handler

        """
        self.send_hcc_register(handler)
        self.recv_hcc_register()

    def send_hcc_register(self, handler):
        self._oprot.writeMessageBegin('hcc_register', TMessageType.CALL, self._seqid)
        args = hcc_register_args()
        args.handler = handler
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_register(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_register_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        return

    def hcc_unregister(self):
        self.send_hcc_unregister()
        self.recv_hcc_unregister()

    def send_hcc_unregister(self):
        self._oprot.writeMessageBegin('hcc_unregister', TMessageType.CALL, self._seqid)
        args = hcc_unregister_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_unregister(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_unregister_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.hcc_err is not None:
            raise result.hcc_err
        return

    def hcc_hint_queue_get(self, timeout):
        """
        Parameters:
         - timeout

        """
        self.send_hcc_hint_queue_get(timeout)
        return self.recv_hcc_hint_queue_get()

    def send_hcc_hint_queue_get(self, timeout):
        self._oprot.writeMessageBegin('hcc_hint_queue_get', TMessageType.CALL, self._seqid)
        args = hcc_hint_queue_get_args()
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hcc_hint_queue_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hcc_hint_queue_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.hcc_err is not None:
            raise result.hcc_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hcc_hint_queue_get failed: unknown result")

    def enable_i3c(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        self.send_enable_i3c(bus_num)
        return self.recv_enable_i3c()

    def send_enable_i3c(self, bus_num):
        self._oprot.writeMessageBegin('enable_i3c', TMessageType.CALL, self._seqid)
        args = enable_i3c_args()
        args.bus_num = bus_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_i3c(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_i3c_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.variant_err is not None:
            raise result.variant_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_i3c failed: unknown result")

    def disable_i3c(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        self.send_disable_i3c(bus_num)
        self.recv_disable_i3c()

    def send_disable_i3c(self, bus_num):
        self._oprot.writeMessageBegin('disable_i3c', TMessageType.CALL, self._seqid)
        args = disable_i3c_args()
        args.bus_num = bus_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_i3c(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_i3c_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.variant_err is not None:
            raise result.variant_err
        return

    def i3c_controller_rstdaa(self, bus_num, address, detach_devs):
        """
        Parameters:
         - bus_num
         - address
         - detach_devs

        """
        self.send_i3c_controller_rstdaa(bus_num, address, detach_devs)
        self.recv_i3c_controller_rstdaa()

    def send_i3c_controller_rstdaa(self, bus_num, address, detach_devs):
        self._oprot.writeMessageBegin('i3c_controller_rstdaa', TMessageType.CALL, self._seqid)
        args = i3c_controller_rstdaa_args()
        args.bus_num = bus_num
        args.address = address
        args.detach_devs = detach_devs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_rstdaa(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_rstdaa_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_setaasa(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        self.send_i3c_controller_setaasa(bus_num)
        self.recv_i3c_controller_setaasa()

    def send_i3c_controller_setaasa(self, bus_num):
        self._oprot.writeMessageBegin('i3c_controller_setaasa', TMessageType.CALL, self._seqid)
        args = i3c_controller_setaasa_args()
        args.bus_num = bus_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_setaasa(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_setaasa_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_setdasa(self, bus_num, static_addr, dyn_addr):
        """
        Parameters:
         - bus_num
         - static_addr
         - dyn_addr

        """
        self.send_i3c_controller_setdasa(bus_num, static_addr, dyn_addr)
        self.recv_i3c_controller_setdasa()

    def send_i3c_controller_setdasa(self, bus_num, static_addr, dyn_addr):
        self._oprot.writeMessageBegin('i3c_controller_setdasa', TMessageType.CALL, self._seqid)
        args = i3c_controller_setdasa_args()
        args.bus_num = bus_num
        args.static_addr = static_addr
        args.dyn_addr = dyn_addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_setdasa(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_setdasa_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_setnewda(self, bus_num, old_addr, new_addr):
        """
        Parameters:
         - bus_num
         - old_addr
         - new_addr

        """
        self.send_i3c_controller_setnewda(bus_num, old_addr, new_addr)
        self.recv_i3c_controller_setnewda()

    def send_i3c_controller_setnewda(self, bus_num, old_addr, new_addr):
        self._oprot.writeMessageBegin('i3c_controller_setnewda', TMessageType.CALL, self._seqid)
        args = i3c_controller_setnewda_args()
        args.bus_num = bus_num
        args.old_addr = old_addr
        args.new_addr = new_addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_setnewda(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_setnewda_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_dodaa(self, bus_num, reset_addr_assignments):
        """
        Parameters:
         - bus_num
         - reset_addr_assignments

        """
        self.send_i3c_controller_dodaa(bus_num, reset_addr_assignments)
        return self.recv_i3c_controller_dodaa()

    def send_i3c_controller_dodaa(self, bus_num, reset_addr_assignments):
        self._oprot.writeMessageBegin('i3c_controller_dodaa', TMessageType.CALL, self._seqid)
        args = i3c_controller_dodaa_args()
        args.bus_num = bus_num
        args.reset_addr_assignments = reset_addr_assignments
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_dodaa(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_dodaa_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_controller_dodaa failed: unknown result")

    def i3c_controller_disec(self, bus_num, address, payload):
        """
        Parameters:
         - bus_num
         - address
         - payload

        """
        self.send_i3c_controller_disec(bus_num, address, payload)
        self.recv_i3c_controller_disec()

    def send_i3c_controller_disec(self, bus_num, address, payload):
        self._oprot.writeMessageBegin('i3c_controller_disec', TMessageType.CALL, self._seqid)
        args = i3c_controller_disec_args()
        args.bus_num = bus_num
        args.address = address
        args.payload = payload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_disec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_disec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_enec(self, bus_num, payload):
        """
        Parameters:
         - bus_num
         - payload

        """
        self.send_i3c_controller_enec(bus_num, payload)
        self.recv_i3c_controller_enec()

    def send_i3c_controller_enec(self, bus_num, payload):
        self._oprot.writeMessageBegin('i3c_controller_enec', TMessageType.CALL, self._seqid)
        args = i3c_controller_enec_args()
        args.bus_num = bus_num
        args.payload = payload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_enec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_enec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_getpid(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        self.send_i3c_controller_getpid(bus_num, address, add_device)
        return self.recv_i3c_controller_getpid()

    def send_i3c_controller_getpid(self, bus_num, address, add_device):
        self._oprot.writeMessageBegin('i3c_controller_getpid', TMessageType.CALL, self._seqid)
        args = i3c_controller_getpid_args()
        args.bus_num = bus_num
        args.address = address
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_getpid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_getpid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_controller_getpid failed: unknown result")

    def i3c_controller_getbcr(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        self.send_i3c_controller_getbcr(bus_num, address, add_device)
        return self.recv_i3c_controller_getbcr()

    def send_i3c_controller_getbcr(self, bus_num, address, add_device):
        self._oprot.writeMessageBegin('i3c_controller_getbcr', TMessageType.CALL, self._seqid)
        args = i3c_controller_getbcr_args()
        args.bus_num = bus_num
        args.address = address
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_getbcr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_getbcr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_controller_getbcr failed: unknown result")

    def i3c_controller_getdcr(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        self.send_i3c_controller_getdcr(bus_num, address, add_device)
        return self.recv_i3c_controller_getdcr()

    def send_i3c_controller_getdcr(self, bus_num, address, add_device):
        self._oprot.writeMessageBegin('i3c_controller_getdcr', TMessageType.CALL, self._seqid)
        args = i3c_controller_getdcr_args()
        args.bus_num = bus_num
        args.address = address
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_getdcr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_getdcr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_controller_getdcr failed: unknown result")

    def i3c_controller_getstatus(self, bus_num, address, add_device):
        """
        Parameters:
         - bus_num
         - address
         - add_device

        """
        self.send_i3c_controller_getstatus(bus_num, address, add_device)
        return self.recv_i3c_controller_getstatus()

    def send_i3c_controller_getstatus(self, bus_num, address, add_device):
        self._oprot.writeMessageBegin('i3c_controller_getstatus', TMessageType.CALL, self._seqid)
        args = i3c_controller_getstatus_args()
        args.bus_num = bus_num
        args.address = address
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_getstatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_getstatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_controller_getstatus failed: unknown result")

    def i3c_controller_add_device(self, bus_num, static_addr, dyn_addr):
        """
        Parameters:
         - bus_num
         - static_addr
         - dyn_addr

        """
        self.send_i3c_controller_add_device(bus_num, static_addr, dyn_addr)
        self.recv_i3c_controller_add_device()

    def send_i3c_controller_add_device(self, bus_num, static_addr, dyn_addr):
        self._oprot.writeMessageBegin('i3c_controller_add_device', TMessageType.CALL, self._seqid)
        args = i3c_controller_add_device_args()
        args.bus_num = bus_num
        args.static_addr = static_addr
        args.dyn_addr = dyn_addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_add_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_add_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_get_devices(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        self.send_i3c_controller_get_devices(bus_num)
        return self.recv_i3c_controller_get_devices()

    def send_i3c_controller_get_devices(self, bus_num):
        self._oprot.writeMessageBegin('i3c_controller_get_devices', TMessageType.CALL, self._seqid)
        args = i3c_controller_get_devices_args()
        args.bus_num = bus_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_get_devices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_get_devices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_controller_get_devices failed: unknown result")

    def i3c_read_device(self, bus_num, address, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - num_bytes
         - preamble_bytes
         - add_device

        """
        self.send_i3c_read_device(bus_num, address, num_bytes, preamble_bytes, add_device)
        return self.recv_i3c_read_device()

    def send_i3c_read_device(self, bus_num, address, num_bytes, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_read_device', TMessageType.CALL, self._seqid)
        args = i3c_read_device_args()
        args.bus_num = bus_num
        args.address = address
        args.num_bytes = num_bytes
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_read_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_read_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_read_device failed: unknown result")

    def i3c_read_reg(self, bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - num_bytes
         - preamble_bytes
         - add_device

        """
        self.send_i3c_read_reg(bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device)
        return self.recv_i3c_read_reg()

    def send_i3c_read_reg(self, bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_read_reg', TMessageType.CALL, self._seqid)
        args = i3c_read_reg_args()
        args.bus_num = bus_num
        args.address = address
        args.reg_addr = reg_addr
        args.num_bytes = num_bytes
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_read_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_read_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_read_reg failed: unknown result")

    def i3c_write_device(self, bus_num, address, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - write_data
         - preamble_bytes
         - add_device

        """
        self.send_i3c_write_device(bus_num, address, write_data, preamble_bytes, add_device)
        self.recv_i3c_write_device()

    def send_i3c_write_device(self, bus_num, address, write_data, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_write_device', TMessageType.CALL, self._seqid)
        args = i3c_write_device_args()
        args.bus_num = bus_num
        args.address = address
        args.write_data = write_data
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_write_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_write_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_write_reg(self, bus_num, address, reg_addr, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - write_data
         - preamble_bytes
         - add_device

        """
        self.send_i3c_write_reg(bus_num, address, reg_addr, write_data, preamble_bytes, add_device)
        self.recv_i3c_write_reg()

    def send_i3c_write_reg(self, bus_num, address, reg_addr, write_data, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_write_reg', TMessageType.CALL, self._seqid)
        args = i3c_write_reg_args()
        args.bus_num = bus_num
        args.address = address
        args.reg_addr = reg_addr
        args.write_data = write_data
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_write_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_write_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_add_i2c_device(self, bus_num, address, replace):
        """
        Parameters:
         - bus_num
         - address
         - replace

        """
        self.send_i3c_controller_add_i2c_device(bus_num, address, replace)
        self.recv_i3c_controller_add_i2c_device()

    def send_i3c_controller_add_i2c_device(self, bus_num, address, replace):
        self._oprot.writeMessageBegin('i3c_controller_add_i2c_device', TMessageType.CALL, self._seqid)
        args = i3c_controller_add_i2c_device_args()
        args.bus_num = bus_num
        args.address = address
        args.replace = replace
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_add_i2c_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_add_i2c_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_controller_get_i2c_devices(self, bus_num):
        """
        Parameters:
         - bus_num

        """
        self.send_i3c_controller_get_i2c_devices(bus_num)
        return self.recv_i3c_controller_get_i2c_devices()

    def send_i3c_controller_get_i2c_devices(self, bus_num):
        self._oprot.writeMessageBegin('i3c_controller_get_i2c_devices', TMessageType.CALL, self._seqid)
        args = i3c_controller_get_i2c_devices_args()
        args.bus_num = bus_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_get_i2c_devices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_get_i2c_devices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_controller_get_i2c_devices failed: unknown result")

    def i3c_controller_remove_device(self, bus_num, address):
        """
        Parameters:
         - bus_num
         - address

        """
        self.send_i3c_controller_remove_device(bus_num, address)
        self.recv_i3c_controller_remove_device()

    def send_i3c_controller_remove_device(self, bus_num, address):
        self._oprot.writeMessageBegin('i3c_controller_remove_device', TMessageType.CALL, self._seqid)
        args = i3c_controller_remove_device_args()
        args.bus_num = bus_num
        args.address = address
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_controller_remove_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_controller_remove_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_legacy_i2c_read_device(self, bus_num, address, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - num_bytes
         - preamble_bytes
         - add_device

        """
        self.send_i3c_legacy_i2c_read_device(bus_num, address, num_bytes, preamble_bytes, add_device)
        return self.recv_i3c_legacy_i2c_read_device()

    def send_i3c_legacy_i2c_read_device(self, bus_num, address, num_bytes, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_legacy_i2c_read_device', TMessageType.CALL, self._seqid)
        args = i3c_legacy_i2c_read_device_args()
        args.bus_num = bus_num
        args.address = address
        args.num_bytes = num_bytes
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_legacy_i2c_read_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_legacy_i2c_read_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_legacy_i2c_read_device failed: unknown result")

    def i3c_legacy_i2c_read_reg(self, bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - num_bytes
         - preamble_bytes
         - add_device

        """
        self.send_i3c_legacy_i2c_read_reg(bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device)
        return self.recv_i3c_legacy_i2c_read_reg()

    def send_i3c_legacy_i2c_read_reg(self, bus_num, address, reg_addr, num_bytes, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_legacy_i2c_read_reg', TMessageType.CALL, self._seqid)
        args = i3c_legacy_i2c_read_reg_args()
        args.bus_num = bus_num
        args.address = address
        args.reg_addr = reg_addr
        args.num_bytes = num_bytes
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_legacy_i2c_read_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_legacy_i2c_read_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "i3c_legacy_i2c_read_reg failed: unknown result")

    def i3c_legacy_i2c_write_device(self, bus_num, address, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - write_data
         - preamble_bytes
         - add_device

        """
        self.send_i3c_legacy_i2c_write_device(bus_num, address, write_data, preamble_bytes, add_device)
        self.recv_i3c_legacy_i2c_write_device()

    def send_i3c_legacy_i2c_write_device(self, bus_num, address, write_data, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_legacy_i2c_write_device', TMessageType.CALL, self._seqid)
        args = i3c_legacy_i2c_write_device_args()
        args.bus_num = bus_num
        args.address = address
        args.write_data = write_data
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_legacy_i2c_write_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_legacy_i2c_write_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return

    def i3c_legacy_i2c_write_reg(self, bus_num, address, reg_addr, write_data, preamble_bytes, add_device):
        """
        Parameters:
         - bus_num
         - address
         - reg_addr
         - write_data
         - preamble_bytes
         - add_device

        """
        self.send_i3c_legacy_i2c_write_reg(bus_num, address, reg_addr, write_data, preamble_bytes, add_device)
        self.recv_i3c_legacy_i2c_write_reg()

    def send_i3c_legacy_i2c_write_reg(self, bus_num, address, reg_addr, write_data, preamble_bytes, add_device):
        self._oprot.writeMessageBegin('i3c_legacy_i2c_write_reg', TMessageType.CALL, self._seqid)
        args = i3c_legacy_i2c_write_reg_args()
        args.bus_num = bus_num
        args.address = address
        args.reg_addr = reg_addr
        args.write_data = write_data
        args.preamble_bytes = preamble_bytes
        args.add_device = add_device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_i3c_legacy_i2c_write_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = i3c_legacy_i2c_write_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.i3c_err is not None:
            raise result.i3c_err
        if result.i3c_driver_err is not None:
            raise result.i3c_driver_err
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["server_eval"] = Processor.process_server_eval
        self._processMap["reload_modules"] = Processor.process_reload_modules
        self._processMap["embed_test_station"] = Processor.process_embed_test_station
        self._processMap["ping_test_station"] = Processor.process_ping_test_station
        self._processMap["burst"] = Processor.process_burst
        self._processMap["get_traceback"] = Processor.process_get_traceback
        self._processMap["program_xmos_image"] = Processor.process_program_xmos_image
        self._processMap["get_variants"] = Processor.process_get_variants
        self._processMap["get_current_variant"] = Processor.process_get_current_variant
        self._processMap["set_variant"] = Processor.process_set_variant
        self._processMap["gpioinfo"] = Processor.process_gpioinfo
        self._processMap["get_active_gpio_info"] = Processor.process_get_active_gpio_info
        self._processMap["get_active_gpios_list"] = Processor.process_get_active_gpios_list
        self._processMap["get_gpio"] = Processor.process_get_gpio
        self._processMap["set_gpio"] = Processor.process_set_gpio
        self._processMap["get_gpio_by_name"] = Processor.process_get_gpio_by_name
        self._processMap["set_gpio_by_name"] = Processor.process_set_gpio_by_name
        self._processMap["get_gpio_direction"] = Processor.process_get_gpio_direction
        self._processMap["set_gpio_direction"] = Processor.process_set_gpio_direction
        self._processMap["get_gpio_direction_by_name"] = Processor.process_get_gpio_direction_by_name
        self._processMap["set_gpio_direction_by_name"] = Processor.process_set_gpio_direction_by_name
        self._processMap["toggle_gpio"] = Processor.process_toggle_gpio
        self._processMap["toggle_gpio_by_name"] = Processor.process_toggle_gpio_by_name
        self._processMap["reset_dut"] = Processor.process_reset_dut
        self._processMap["reset_wrapper"] = Processor.process_reset_wrapper
        self._processMap["set_rail_voltage"] = Processor.process_set_rail_voltage
        self._processMap["write_i2c_reg"] = Processor.process_write_i2c_reg
        self._processMap["read_i2c_reg"] = Processor.process_read_i2c_reg
        self._processMap["i2c_device_write"] = Processor.process_i2c_device_write
        self._processMap["i2c_device_read"] = Processor.process_i2c_device_read
        self._processMap["i2c_check_ack"] = Processor.process_i2c_check_ack
        self._processMap["i2c_scan"] = Processor.process_i2c_scan
        self._processMap["set_i2c_bus_speed"] = Processor.process_set_i2c_bus_speed
        self._processMap["spi_fd"] = Processor.process_spi_fd
        self._processMap["spi_apb_block_read"] = Processor.process_spi_apb_block_read
        self._processMap["spi_apb_block_write"] = Processor.process_spi_apb_block_write
        self._processMap["mmap_add"] = Processor.process_mmap_add
        self._processMap["mmap_read"] = Processor.process_mmap_read
        self._processMap["mmap_write"] = Processor.process_mmap_write
        self._processMap["memio_write"] = Processor.process_memio_write
        self._processMap["memio_read"] = Processor.process_memio_read
        self._processMap["handle_interrupt"] = Processor.process_handle_interrupt
        self._processMap["start_embedded_interrupt_handling"] = Processor.process_start_embedded_interrupt_handling
        self._processMap["print_from_buffer"] = Processor.process_print_from_buffer
        self._processMap["stop_embedded_interrupt_handling"] = Processor.process_stop_embedded_interrupt_handling
        self._processMap["empty_server_queue"] = Processor.process_empty_server_queue
        self._processMap["release_lock"] = Processor.process_release_lock
        self._processMap["enable_spmi"] = Processor.process_enable_spmi
        self._processMap["disable_spmi"] = Processor.process_disable_spmi
        self._processMap["spmi_device_initialize"] = Processor.process_spmi_device_initialize
        self._processMap["spmi_device_disable"] = Processor.process_spmi_device_disable
        self._processMap["spmi_set_master_req_prescaler"] = Processor.process_spmi_set_master_req_prescaler
        self._processMap["spmi_set_slave_addr"] = Processor.process_spmi_set_slave_addr
        self._processMap["spmi_set_master_addr"] = Processor.process_spmi_set_master_addr
        self._processMap["spmi_set_ip_version"] = Processor.process_spmi_set_ip_version
        self._processMap["spmi_poll_command_sent_flag"] = Processor.process_spmi_poll_command_sent_flag
        self._processMap["spmi_master_write"] = Processor.process_spmi_master_write
        self._processMap["spmi_master_read"] = Processor.process_spmi_master_read
        self._processMap["spmi_register_write"] = Processor.process_spmi_register_write
        self._processMap["spmi_register_read"] = Processor.process_spmi_register_read
        self._processMap["spmi_extended_register_write"] = Processor.process_spmi_extended_register_write
        self._processMap["spmi_extended_register_read"] = Processor.process_spmi_extended_register_read
        self._processMap["spmi_extended_register_write_long"] = Processor.process_spmi_extended_register_write_long
        self._processMap["spmi_extended_register_read_long"] = Processor.process_spmi_extended_register_read_long
        self._processMap["spmi_24bit_write"] = Processor.process_spmi_24bit_write
        self._processMap["spmi_24bit_read"] = Processor.process_spmi_24bit_read
        self._processMap["spmi_block_read"] = Processor.process_spmi_block_read
        self._processMap["spmi_block_write"] = Processor.process_spmi_block_write
        self._processMap["spmi_chain_read"] = Processor.process_spmi_chain_read
        self._processMap["spmi_chain_write"] = Processor.process_spmi_chain_write
        self._processMap["master_write"] = Processor.process_master_write
        self._processMap["spmi_dump_registers"] = Processor.process_spmi_dump_registers
        self._processMap["hcc_queue_packets"] = Processor.process_hcc_queue_packets
        self._processMap["hcc_send_packet"] = Processor.process_hcc_send_packet
        self._processMap["hcc_execute_packet_queue"] = Processor.process_hcc_execute_packet_queue
        self._processMap["enable_hcc"] = Processor.process_enable_hcc
        self._processMap["disable_hcc"] = Processor.process_disable_hcc
        self._processMap["hcc_set_speed"] = Processor.process_hcc_set_speed
        self._processMap["hcc_set_setup_delay"] = Processor.process_hcc_set_setup_delay
        self._processMap["hcc_set_bit_order"] = Processor.process_hcc_set_bit_order
        self._processMap["hcc_set_clk_mode"] = Processor.process_hcc_set_clk_mode
        self._processMap["hcc_register"] = Processor.process_hcc_register
        self._processMap["hcc_unregister"] = Processor.process_hcc_unregister
        self._processMap["hcc_hint_queue_get"] = Processor.process_hcc_hint_queue_get
        self._processMap["enable_i3c"] = Processor.process_enable_i3c
        self._processMap["disable_i3c"] = Processor.process_disable_i3c
        self._processMap["i3c_controller_rstdaa"] = Processor.process_i3c_controller_rstdaa
        self._processMap["i3c_controller_setaasa"] = Processor.process_i3c_controller_setaasa
        self._processMap["i3c_controller_setdasa"] = Processor.process_i3c_controller_setdasa
        self._processMap["i3c_controller_setnewda"] = Processor.process_i3c_controller_setnewda
        self._processMap["i3c_controller_dodaa"] = Processor.process_i3c_controller_dodaa
        self._processMap["i3c_controller_disec"] = Processor.process_i3c_controller_disec
        self._processMap["i3c_controller_enec"] = Processor.process_i3c_controller_enec
        self._processMap["i3c_controller_getpid"] = Processor.process_i3c_controller_getpid
        self._processMap["i3c_controller_getbcr"] = Processor.process_i3c_controller_getbcr
        self._processMap["i3c_controller_getdcr"] = Processor.process_i3c_controller_getdcr
        self._processMap["i3c_controller_getstatus"] = Processor.process_i3c_controller_getstatus
        self._processMap["i3c_controller_add_device"] = Processor.process_i3c_controller_add_device
        self._processMap["i3c_controller_get_devices"] = Processor.process_i3c_controller_get_devices
        self._processMap["i3c_read_device"] = Processor.process_i3c_read_device
        self._processMap["i3c_read_reg"] = Processor.process_i3c_read_reg
        self._processMap["i3c_write_device"] = Processor.process_i3c_write_device
        self._processMap["i3c_write_reg"] = Processor.process_i3c_write_reg
        self._processMap["i3c_controller_add_i2c_device"] = Processor.process_i3c_controller_add_i2c_device
        self._processMap["i3c_controller_get_i2c_devices"] = Processor.process_i3c_controller_get_i2c_devices
        self._processMap["i3c_controller_remove_device"] = Processor.process_i3c_controller_remove_device
        self._processMap["i3c_legacy_i2c_read_device"] = Processor.process_i3c_legacy_i2c_read_device
        self._processMap["i3c_legacy_i2c_read_reg"] = Processor.process_i3c_legacy_i2c_read_reg
        self._processMap["i3c_legacy_i2c_write_device"] = Processor.process_i3c_legacy_i2c_write_device
        self._processMap["i3c_legacy_i2c_write_reg"] = Processor.process_i3c_legacy_i2c_write_reg
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            result.success = self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_server_eval(self, seqid, iprot, oprot):
        args = server_eval_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = server_eval_result()
        try:
            result.success = self._handler.server_eval(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except JSONSerializeError as json_err:
            msg_type = TMessageType.REPLY
            result.json_err = json_err
        except ServerError as server_err:
            msg_type = TMessageType.REPLY
            result.server_err = server_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("server_eval", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reload_modules(self, seqid, iprot, oprot):
        args = reload_modules_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reload_modules_result()
        try:
            self._handler.reload_modules(args.modules)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reload_modules", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_embed_test_station(self, seqid, iprot, oprot):
        args = embed_test_station_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = embed_test_station_result()
        try:
            result.success = self._handler.embed_test_station(args.serialized_station, args.env_vars)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("embed_test_station", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ping_test_station(self, seqid, iprot, oprot):
        args = ping_test_station_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_test_station_result()
        try:
            result.success = self._handler.ping_test_station()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping_test_station", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_burst(self, seqid, iprot, oprot):
        args = burst_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = burst_result()
        try:
            result.success = self._handler.burst(args.lines, args.vars, args.aliases)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("burst", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_traceback(self, seqid, iprot, oprot):
        args = get_traceback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_traceback_result()
        try:
            result.success = self._handler.get_traceback()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_traceback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_program_xmos_image(self, seqid, iprot, oprot):
        args = program_xmos_image_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = program_xmos_image_result()
        try:
            result.success = self._handler.program_xmos_image(args.image)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("program_xmos_image", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_variants(self, seqid, iprot, oprot):
        args = get_variants_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_variants_result()
        try:
            result.success = self._handler.get_variants()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_variants", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_current_variant(self, seqid, iprot, oprot):
        args = get_current_variant_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_current_variant_result()
        try:
            result.success = self._handler.get_current_variant()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_current_variant", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_variant(self, seqid, iprot, oprot):
        args = set_variant_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_variant_result()
        try:
            self._handler.set_variant(args.variant, args.reboot)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_variant", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_gpioinfo(self, seqid, iprot, oprot):
        args = gpioinfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = gpioinfo_result()
        try:
            result.success = self._handler.gpioinfo()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("gpioinfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_active_gpio_info(self, seqid, iprot, oprot):
        args = get_active_gpio_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_active_gpio_info_result()
        try:
            result.success = self._handler.get_active_gpio_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_active_gpio_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_active_gpios_list(self, seqid, iprot, oprot):
        args = get_active_gpios_list_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_active_gpios_list_result()
        try:
            result.success = self._handler.get_active_gpios_list()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_active_gpios_list", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_gpio(self, seqid, iprot, oprot):
        args = get_gpio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_gpio_result()
        try:
            result.success = self._handler.get_gpio(args.chip_num, args.line_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_gpio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_gpio(self, seqid, iprot, oprot):
        args = set_gpio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_gpio_result()
        try:
            self._handler.set_gpio(args.chip_num, args.line_num, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_gpio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_gpio_by_name(self, seqid, iprot, oprot):
        args = get_gpio_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_gpio_by_name_result()
        try:
            result.success = self._handler.get_gpio_by_name(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_gpio_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_gpio_by_name(self, seqid, iprot, oprot):
        args = set_gpio_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_gpio_by_name_result()
        try:
            self._handler.set_gpio_by_name(args.name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_gpio_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_gpio_direction(self, seqid, iprot, oprot):
        args = get_gpio_direction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_gpio_direction_result()
        try:
            result.success = self._handler.get_gpio_direction(args.chip_num, args.line_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_gpio_direction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_gpio_direction(self, seqid, iprot, oprot):
        args = set_gpio_direction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_gpio_direction_result()
        try:
            self._handler.set_gpio_direction(args.chip_num, args.line_num, args.direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_gpio_direction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_gpio_direction_by_name(self, seqid, iprot, oprot):
        args = get_gpio_direction_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_gpio_direction_by_name_result()
        try:
            result.success = self._handler.get_gpio_direction_by_name(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_gpio_direction_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_gpio_direction_by_name(self, seqid, iprot, oprot):
        args = set_gpio_direction_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_gpio_direction_by_name_result()
        try:
            self._handler.set_gpio_direction_by_name(args.name, args.direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_gpio_direction_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_toggle_gpio(self, seqid, iprot, oprot):
        args = toggle_gpio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = toggle_gpio_result()
        try:
            self._handler.toggle_gpio(args.chip_num, args.line_num, args.active_low, args.delay, args.pulse_width)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("toggle_gpio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_toggle_gpio_by_name(self, seqid, iprot, oprot):
        args = toggle_gpio_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = toggle_gpio_by_name_result()
        try:
            self._handler.toggle_gpio_by_name(args.name, args.active_low, args.delay, args.pulse_width)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GpioAccessError as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("toggle_gpio_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reset_dut(self, seqid, iprot, oprot):
        args = reset_dut_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reset_dut_result()
        try:
            self._handler.reset_dut(args.mode, args.active_low)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reset_dut", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reset_wrapper(self, seqid, iprot, oprot):
        args = reset_wrapper_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reset_wrapper_result()
        try:
            self._handler.reset_wrapper(args.mode, args.active_low)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reset_wrapper", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_rail_voltage(self, seqid, iprot, oprot):
        args = set_rail_voltage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_rail_voltage_result()
        try:
            self._handler.set_rail_voltage(args.voltage)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_rail_voltage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_i2c_reg(self, seqid, iprot, oprot):
        args = write_i2c_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_i2c_reg_result()
        try:
            result.success = self._handler.write_i2c_reg(args.reg_addr, args.write_data, args.dev_addr, args.bus_num, args.speed, args.repeat_start, args.write_reg_addr_size, args.ainc, args.address_stride, args.write_reg_data_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I2c_error as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_i2c_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_i2c_reg(self, seqid, iprot, oprot):
        args = read_i2c_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_i2c_reg_result()
        try:
            result.success = self._handler.read_i2c_reg(args.reg_addr, args.byte_count, args.dev_addr, args.bus_num, args.speed, args.repeat_start, args.read_reg_addr_size, args.ainc, args.address_stride, args.read_reg_data_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I2c_error as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_i2c_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i2c_device_write(self, seqid, iprot, oprot):
        args = i2c_device_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i2c_device_write_result()
        try:
            result.success = self._handler.i2c_device_write(args.bus_num, args.speed, args.dev_addr, args.write_data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I2c_error as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i2c_device_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i2c_device_read(self, seqid, iprot, oprot):
        args = i2c_device_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i2c_device_read_result()
        try:
            result.success = self._handler.i2c_device_read(args.bus_num, args.speed, args.dev_addr, args.byte_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I2c_error as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i2c_device_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i2c_check_ack(self, seqid, iprot, oprot):
        args = i2c_check_ack_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i2c_check_ack_result()
        try:
            result.success = self._handler.i2c_check_ack(args.bus_num, args.speed, args.dev_addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i2c_check_ack", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i2c_scan(self, seqid, iprot, oprot):
        args = i2c_scan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i2c_scan_result()
        try:
            result.success = self._handler.i2c_scan(args.bus_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i2c_scan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_i2c_bus_speed(self, seqid, iprot, oprot):
        args = set_i2c_bus_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_i2c_bus_speed_result()
        try:
            self._handler.set_i2c_bus_speed(args.bus_num, args.speed)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_i2c_bus_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spi_fd(self, seqid, iprot, oprot):
        args = spi_fd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spi_fd_result()
        try:
            result.success = self._handler.spi_fd(args.bytes_out, args.bus_num, args.chip_select, args.speed, args.keep_cs, args.clk_mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spi_fd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spi_apb_block_read(self, seqid, iprot, oprot):
        args = spi_apb_block_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spi_apb_block_read_result()
        try:
            result.success = self._handler.spi_apb_block_read(args.bus_num, args.chip_select, args.speed, args.address, args.addr_size, args.data_size, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spi_apb_block_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spi_apb_block_write(self, seqid, iprot, oprot):
        args = spi_apb_block_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spi_apb_block_write_result()
        try:
            self._handler.spi_apb_block_write(args.bus_num, args.chip_select, args.speed, args.address, args.values, args.addr_size, args.data_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spi_apb_block_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mmap_add(self, seqid, iprot, oprot):
        args = mmap_add_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mmap_add_result()
        try:
            self._handler.mmap_add(args.base_addr, args.size, args.word_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mmap_add", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mmap_read(self, seqid, iprot, oprot):
        args = mmap_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mmap_read_result()
        try:
            result.success = self._handler.mmap_read(args.base_addr, args.offset, args.num_bytes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mmap_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mmap_write(self, seqid, iprot, oprot):
        args = mmap_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mmap_write_result()
        try:
            self._handler.mmap_write(args.base_addr, args.offset, args.bytes_out)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mmap_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_memio_write(self, seqid, iprot, oprot):
        args = memio_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = memio_write_result()
        try:
            result.success = self._handler.memio_write(args.addr, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("memio_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_memio_read(self, seqid, iprot, oprot):
        args = memio_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = memio_read_result()
        try:
            result.success = self._handler.memio_read(args.addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("memio_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_handle_interrupt(self, seqid, iprot, oprot):
        args = handle_interrupt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = handle_interrupt_result()
        try:
            result.success = self._handler.handle_interrupt(args.int_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("handle_interrupt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_embedded_interrupt_handling(self, seqid, iprot, oprot):
        args = start_embedded_interrupt_handling_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_embedded_interrupt_handling_result()
        try:
            result.success = self._handler.start_embedded_interrupt_handling(args.int_map, args.verbose, args.functions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_embedded_interrupt_handling", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_print_from_buffer(self, seqid, iprot, oprot):
        args = print_from_buffer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = print_from_buffer_result()
        try:
            result.success = self._handler.print_from_buffer()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("print_from_buffer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_embedded_interrupt_handling(self, seqid, iprot, oprot):
        args = stop_embedded_interrupt_handling_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_embedded_interrupt_handling_result()
        try:
            result.success = self._handler.stop_embedded_interrupt_handling()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_embedded_interrupt_handling", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_empty_server_queue(self, seqid, iprot, oprot):
        args = empty_server_queue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = empty_server_queue_result()
        try:
            result.success = self._handler.empty_server_queue()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("empty_server_queue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_release_lock(self, seqid, iprot, oprot):
        args = release_lock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = release_lock_result()
        try:
            self._handler.release_lock()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("release_lock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_spmi(self, seqid, iprot, oprot):
        args = enable_spmi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_spmi_result()
        try:
            result.success = self._handler.enable_spmi(args.base_addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_spmi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_spmi(self, seqid, iprot, oprot):
        args = disable_spmi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_spmi_result()
        try:
            self._handler.disable_spmi()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_spmi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_device_initialize(self, seqid, iprot, oprot):
        args = spmi_device_initialize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_device_initialize_result()
        try:
            result.success = self._handler.spmi_device_initialize(args.device_type, args.device_id, args.f_tclk, args.ddba_addr, args.inten, args.enr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_device_initialize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_device_disable(self, seqid, iprot, oprot):
        args = spmi_device_disable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_device_disable_result()
        try:
            result.success = self._handler.spmi_device_disable()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_device_disable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_set_master_req_prescaler(self, seqid, iprot, oprot):
        args = spmi_set_master_req_prescaler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_set_master_req_prescaler_result()
        try:
            result.success = self._handler.spmi_set_master_req_prescaler(args.rate)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_set_master_req_prescaler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_set_slave_addr(self, seqid, iprot, oprot):
        args = spmi_set_slave_addr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_set_slave_addr_result()
        try:
            result.success = self._handler.spmi_set_slave_addr(args.addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_set_slave_addr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_set_master_addr(self, seqid, iprot, oprot):
        args = spmi_set_master_addr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_set_master_addr_result()
        try:
            result.success = self._handler.spmi_set_master_addr(args.addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_set_master_addr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_set_ip_version(self, seqid, iprot, oprot):
        args = spmi_set_ip_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_set_ip_version_result()
        try:
            result.success = self._handler.spmi_set_ip_version(args.version)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_set_ip_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_poll_command_sent_flag(self, seqid, iprot, oprot):
        args = spmi_poll_command_sent_flag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_poll_command_sent_flag_result()
        try:
            result.success = self._handler.spmi_poll_command_sent_flag(args.clear_all_flags)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_poll_command_sent_flag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_master_write(self, seqid, iprot, oprot):
        args = spmi_master_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_master_write_result()
        try:
            result.success = self._handler.spmi_master_write(args.master_id, args.address, args.data, args.use_a_bit, args.use_sr_bit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_master_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_master_read(self, seqid, iprot, oprot):
        args = spmi_master_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_master_read_result()
        try:
            result.success = self._handler.spmi_master_read(args.master_id, args.address, args.size, args.use_a_bit, args.use_sr_bit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_master_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_register_write(self, seqid, iprot, oprot):
        args = spmi_register_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_register_write_result()
        try:
            result.success = self._handler.spmi_register_write(args.slave_id, args.address, args.data, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_register_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_register_read(self, seqid, iprot, oprot):
        args = spmi_register_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_register_read_result()
        try:
            result.success = self._handler.spmi_register_read(args.slave_id, args.address, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_register_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_extended_register_write(self, seqid, iprot, oprot):
        args = spmi_extended_register_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_extended_register_write_result()
        try:
            result.success = self._handler.spmi_extended_register_write(args.slave_id, args.address, args.data, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_extended_register_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_extended_register_read(self, seqid, iprot, oprot):
        args = spmi_extended_register_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_extended_register_read_result()
        try:
            result.success = self._handler.spmi_extended_register_read(args.slave_id, args.address, args.size, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_extended_register_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_extended_register_write_long(self, seqid, iprot, oprot):
        args = spmi_extended_register_write_long_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_extended_register_write_long_result()
        try:
            result.success = self._handler.spmi_extended_register_write_long(args.slave_id, args.address, args.data, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_extended_register_write_long", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_extended_register_read_long(self, seqid, iprot, oprot):
        args = spmi_extended_register_read_long_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_extended_register_read_long_result()
        try:
            result.success = self._handler.spmi_extended_register_read_long(args.slave_id, args.address, args.size, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_extended_register_read_long", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_24bit_write(self, seqid, iprot, oprot):
        args = spmi_24bit_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_24bit_write_result()
        try:
            result.success = self._handler.spmi_24bit_write(args.slave_id, args.address, args.data, args.priority, args.p_inx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_24bit_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_24bit_read(self, seqid, iprot, oprot):
        args = spmi_24bit_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_24bit_read_result()
        try:
            result.success = self._handler.spmi_24bit_read(args.slave_id, args.address, args.word_count, args.priority, args.p_inx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_24bit_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_block_read(self, seqid, iprot, oprot):
        args = spmi_block_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_block_read_result()
        try:
            result.success = self._handler.spmi_block_read(args.peripheral_id, args.start_addr, args.byte_count, args.addressibility, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_block_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_block_write(self, seqid, iprot, oprot):
        args = spmi_block_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_block_write_result()
        try:
            self._handler.spmi_block_write(args.peripheral_id, args.start_addr, args.data, args.addressibility, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_block_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_chain_read(self, seqid, iprot, oprot):
        args = spmi_chain_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_chain_read_result()
        try:
            result.success = self._handler.spmi_chain_read(args.peripheral_id, args.address, args.num_reads, args.read_size, args.addressibility, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_chain_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_chain_write(self, seqid, iprot, oprot):
        args = spmi_chain_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_chain_write_result()
        try:
            self._handler.spmi_chain_write(args.peripheral_id, args.address, args.data, args.write_size, args.addressibility, args.priority)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Spmi_timeout as timeout_err:
            msg_type = TMessageType.REPLY
            result.timeout_err = timeout_err
        except Spmi_arb_failure as arb_err:
            msg_type = TMessageType.REPLY
            result.arb_err = arb_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_chain_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_master_write(self, seqid, iprot, oprot):
        args = master_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = master_write_result()
        try:
            result.success = self._handler.master_write(args.master_id, args.address, args.data, args.use_a_bit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("master_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spmi_dump_registers(self, seqid, iprot, oprot):
        args = spmi_dump_registers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spmi_dump_registers_result()
        try:
            result.success = self._handler.spmi_dump_registers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spmi_dump_registers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_queue_packets(self, seqid, iprot, oprot):
        args = hcc_queue_packets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_queue_packets_result()
        try:
            self._handler.hcc_queue_packets(args.packets, args.cs_delays)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_queue_packets", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_send_packet(self, seqid, iprot, oprot):
        args = hcc_send_packet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_send_packet_result()
        try:
            result.success = self._handler.hcc_send_packet(args.packet, args.cs_delay)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_send_packet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_execute_packet_queue(self, seqid, iprot, oprot):
        args = hcc_execute_packet_queue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_execute_packet_queue_result()
        try:
            result.success = self._handler.hcc_execute_packet_queue()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_execute_packet_queue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_hcc(self, seqid, iprot, oprot):
        args = enable_hcc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_hcc_result()
        try:
            self._handler.enable_hcc(args.bus_num, args.chip_select)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except I2c_error as i2c_err:
            msg_type = TMessageType.REPLY
            result.i2c_err = i2c_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_hcc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_hcc(self, seqid, iprot, oprot):
        args = disable_hcc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_hcc_result()
        try:
            self._handler.disable_hcc()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except I2c_error as i2c_err:
            msg_type = TMessageType.REPLY
            result.i2c_err = i2c_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_hcc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_set_speed(self, seqid, iprot, oprot):
        args = hcc_set_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_set_speed_result()
        try:
            self._handler.hcc_set_speed(args.speed)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except I2c_error as i2c_err:
            msg_type = TMessageType.REPLY
            result.i2c_err = i2c_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_set_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_set_setup_delay(self, seqid, iprot, oprot):
        args = hcc_set_setup_delay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_set_setup_delay_result()
        try:
            self._handler.hcc_set_setup_delay(args.delay)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_set_setup_delay", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_set_bit_order(self, seqid, iprot, oprot):
        args = hcc_set_bit_order_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_set_bit_order_result()
        try:
            self._handler.hcc_set_bit_order(args.order)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_set_bit_order", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_set_clk_mode(self, seqid, iprot, oprot):
        args = hcc_set_clk_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_set_clk_mode_result()
        try:
            self._handler.hcc_set_clk_mode(args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_set_clk_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_register(self, seqid, iprot, oprot):
        args = hcc_register_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_register_result()
        try:
            self._handler.hcc_register(args.handler)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_register", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_unregister(self, seqid, iprot, oprot):
        args = hcc_unregister_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_unregister_result()
        try:
            self._handler.hcc_unregister()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_unregister", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hcc_hint_queue_get(self, seqid, iprot, oprot):
        args = hcc_hint_queue_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hcc_hint_queue_get_result()
        try:
            result.success = self._handler.hcc_hint_queue_get(args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except HccDriverError as hcc_err:
            msg_type = TMessageType.REPLY
            result.hcc_err = hcc_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hcc_hint_queue_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_i3c(self, seqid, iprot, oprot):
        args = enable_i3c_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_i3c_result()
        try:
            result.success = self._handler.enable_i3c(args.bus_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cDriverError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except VariantError as variant_err:
            msg_type = TMessageType.REPLY
            result.variant_err = variant_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_i3c", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_i3c(self, seqid, iprot, oprot):
        args = disable_i3c_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_i3c_result()
        try:
            self._handler.disable_i3c(args.bus_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except VariantError as variant_err:
            msg_type = TMessageType.REPLY
            result.variant_err = variant_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_i3c", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_rstdaa(self, seqid, iprot, oprot):
        args = i3c_controller_rstdaa_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_rstdaa_result()
        try:
            self._handler.i3c_controller_rstdaa(args.bus_num, args.address, args.detach_devs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_rstdaa", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_setaasa(self, seqid, iprot, oprot):
        args = i3c_controller_setaasa_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_setaasa_result()
        try:
            self._handler.i3c_controller_setaasa(args.bus_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_setaasa", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_setdasa(self, seqid, iprot, oprot):
        args = i3c_controller_setdasa_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_setdasa_result()
        try:
            self._handler.i3c_controller_setdasa(args.bus_num, args.static_addr, args.dyn_addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_setdasa", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_setnewda(self, seqid, iprot, oprot):
        args = i3c_controller_setnewda_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_setnewda_result()
        try:
            self._handler.i3c_controller_setnewda(args.bus_num, args.old_addr, args.new_addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_setnewda", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_dodaa(self, seqid, iprot, oprot):
        args = i3c_controller_dodaa_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_dodaa_result()
        try:
            result.success = self._handler.i3c_controller_dodaa(args.bus_num, args.reset_addr_assignments)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_dodaa", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_disec(self, seqid, iprot, oprot):
        args = i3c_controller_disec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_disec_result()
        try:
            self._handler.i3c_controller_disec(args.bus_num, args.address, args.payload)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_disec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_enec(self, seqid, iprot, oprot):
        args = i3c_controller_enec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_enec_result()
        try:
            self._handler.i3c_controller_enec(args.bus_num, args.payload)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_enec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_getpid(self, seqid, iprot, oprot):
        args = i3c_controller_getpid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_getpid_result()
        try:
            result.success = self._handler.i3c_controller_getpid(args.bus_num, args.address, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_getpid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_getbcr(self, seqid, iprot, oprot):
        args = i3c_controller_getbcr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_getbcr_result()
        try:
            result.success = self._handler.i3c_controller_getbcr(args.bus_num, args.address, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_getbcr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_getdcr(self, seqid, iprot, oprot):
        args = i3c_controller_getdcr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_getdcr_result()
        try:
            result.success = self._handler.i3c_controller_getdcr(args.bus_num, args.address, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_getdcr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_getstatus(self, seqid, iprot, oprot):
        args = i3c_controller_getstatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_getstatus_result()
        try:
            result.success = self._handler.i3c_controller_getstatus(args.bus_num, args.address, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_getstatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_add_device(self, seqid, iprot, oprot):
        args = i3c_controller_add_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_add_device_result()
        try:
            self._handler.i3c_controller_add_device(args.bus_num, args.static_addr, args.dyn_addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_add_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_get_devices(self, seqid, iprot, oprot):
        args = i3c_controller_get_devices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_get_devices_result()
        try:
            result.success = self._handler.i3c_controller_get_devices(args.bus_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_get_devices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_read_device(self, seqid, iprot, oprot):
        args = i3c_read_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_read_device_result()
        try:
            result.success = self._handler.i3c_read_device(args.bus_num, args.address, args.num_bytes, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_read_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_read_reg(self, seqid, iprot, oprot):
        args = i3c_read_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_read_reg_result()
        try:
            result.success = self._handler.i3c_read_reg(args.bus_num, args.address, args.reg_addr, args.num_bytes, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_read_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_write_device(self, seqid, iprot, oprot):
        args = i3c_write_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_write_device_result()
        try:
            self._handler.i3c_write_device(args.bus_num, args.address, args.write_data, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_write_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_write_reg(self, seqid, iprot, oprot):
        args = i3c_write_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_write_reg_result()
        try:
            self._handler.i3c_write_reg(args.bus_num, args.address, args.reg_addr, args.write_data, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_write_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_add_i2c_device(self, seqid, iprot, oprot):
        args = i3c_controller_add_i2c_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_add_i2c_device_result()
        try:
            self._handler.i3c_controller_add_i2c_device(args.bus_num, args.address, args.replace)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_add_i2c_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_get_i2c_devices(self, seqid, iprot, oprot):
        args = i3c_controller_get_i2c_devices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_get_i2c_devices_result()
        try:
            result.success = self._handler.i3c_controller_get_i2c_devices(args.bus_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_get_i2c_devices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_controller_remove_device(self, seqid, iprot, oprot):
        args = i3c_controller_remove_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_controller_remove_device_result()
        try:
            self._handler.i3c_controller_remove_device(args.bus_num, args.address)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_controller_remove_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_legacy_i2c_read_device(self, seqid, iprot, oprot):
        args = i3c_legacy_i2c_read_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_legacy_i2c_read_device_result()
        try:
            result.success = self._handler.i3c_legacy_i2c_read_device(args.bus_num, args.address, args.num_bytes, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_legacy_i2c_read_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_legacy_i2c_read_reg(self, seqid, iprot, oprot):
        args = i3c_legacy_i2c_read_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_legacy_i2c_read_reg_result()
        try:
            result.success = self._handler.i3c_legacy_i2c_read_reg(args.bus_num, args.address, args.reg_addr, args.num_bytes, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_legacy_i2c_read_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_legacy_i2c_write_device(self, seqid, iprot, oprot):
        args = i3c_legacy_i2c_write_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_legacy_i2c_write_device_result()
        try:
            self._handler.i3c_legacy_i2c_write_device(args.bus_num, args.address, args.write_data, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_legacy_i2c_write_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_i3c_legacy_i2c_write_reg(self, seqid, iprot, oprot):
        args = i3c_legacy_i2c_write_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = i3c_legacy_i2c_write_reg_result()
        try:
            self._handler.i3c_legacy_i2c_write_reg(args.bus_num, args.address, args.reg_addr, args.write_data, args.preamble_bytes, args.add_device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except I3cError as i3c_err:
            msg_type = TMessageType.REPLY
            result.i3c_err = i3c_err
        except I3cDriverError as i3c_driver_err:
            msg_type = TMessageType.REPLY
            result.i3c_driver_err = i3c_driver_err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("i3c_legacy_i2c_write_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class server_eval_args(object):
    """
    Attributes:
     - expression

    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('server_eval_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(server_eval_args)
server_eval_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class server_eval_result(object):
    """
    Attributes:
     - success
     - json_err
     - server_err

    """


    def __init__(self, success=None, json_err=None, server_err=None,):
        self.success = success
        self.json_err = json_err
        self.server_err = server_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.json_err = JSONSerializeError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.server_err = ServerError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('server_eval_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.json_err is not None:
            oprot.writeFieldBegin('json_err', TType.STRUCT, 1)
            self.json_err.write(oprot)
            oprot.writeFieldEnd()
        if self.server_err is not None:
            oprot.writeFieldBegin('server_err', TType.STRUCT, 2)
            self.server_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(server_eval_result)
server_eval_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'json_err', [JSONSerializeError, None], None, ),  # 1
    (2, TType.STRUCT, 'server_err', [ServerError, None], None, ),  # 2
)


class reload_modules_args(object):
    """
    Attributes:
     - modules

    """


    def __init__(self, modules=None,):
        self.modules = modules

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modules = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.modules.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reload_modules_args')
        if self.modules is not None:
            oprot.writeFieldBegin('modules', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.modules))
            for iter6 in self.modules:
                oprot.writeString(iter6.encode('utf-8') if sys.version_info[0] == 2 else iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reload_modules_args)
reload_modules_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'modules', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class reload_modules_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reload_modules_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reload_modules_result)
reload_modules_result.thrift_spec = (
)


class embed_test_station_args(object):
    """
    Attributes:
     - serialized_station
     - env_vars

    """


    def __init__(self, serialized_station=None, env_vars=None,):
        self.serialized_station = serialized_station
        self.env_vars = env_vars

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serialized_station = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.env_vars = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('embed_test_station_args')
        if self.serialized_station is not None:
            oprot.writeFieldBegin('serialized_station', TType.STRING, 1)
            oprot.writeString(self.serialized_station.encode('utf-8') if sys.version_info[0] == 2 else self.serialized_station)
            oprot.writeFieldEnd()
        if self.env_vars is not None:
            oprot.writeFieldBegin('env_vars', TType.STRING, 2)
            oprot.writeString(self.env_vars.encode('utf-8') if sys.version_info[0] == 2 else self.env_vars)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(embed_test_station_args)
embed_test_station_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serialized_station', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'env_vars', 'UTF8', None, ),  # 2
)


class embed_test_station_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('embed_test_station_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(embed_test_station_result)
embed_test_station_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class ping_test_station_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_test_station_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_test_station_args)
ping_test_station_args.thrift_spec = (
)


class ping_test_station_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_test_station_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_test_station_result)
ping_test_station_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class burst_args(object):
    """
    Attributes:
     - lines
     - vars
     - aliases

    """


    def __init__(self, lines=None, vars=None, aliases=None,):
        self.lines = lines
        self.vars = vars
        self.aliases = aliases

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lines = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.lines.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.vars = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.aliases = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('burst_args')
        if self.lines is not None:
            oprot.writeFieldBegin('lines', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.lines))
            for iter13 in self.lines:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vars is not None:
            oprot.writeFieldBegin('vars', TType.STRING, 2)
            oprot.writeString(self.vars.encode('utf-8') if sys.version_info[0] == 2 else self.vars)
            oprot.writeFieldEnd()
        if self.aliases is not None:
            oprot.writeFieldBegin('aliases', TType.STRING, 3)
            oprot.writeString(self.aliases.encode('utf-8') if sys.version_info[0] == 2 else self.aliases)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(burst_args)
burst_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lines', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'vars', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'aliases', 'UTF8', None, ),  # 3
)


class burst_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('burst_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(burst_result)
burst_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_traceback_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_traceback_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_traceback_args)
get_traceback_args.thrift_spec = (
)


class get_traceback_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_traceback_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_traceback_result)
get_traceback_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class program_xmos_image_args(object):
    """
    Attributes:
     - image

    """


    def __init__(self, image=None,):
        self.image = image

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.image = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('program_xmos_image_args')
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 1)
            oprot.writeString(self.image.encode('utf-8') if sys.version_info[0] == 2 else self.image)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(program_xmos_image_args)
program_xmos_image_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'image', 'UTF8', None, ),  # 1
)


class program_xmos_image_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('program_xmos_image_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(program_xmos_image_result)
program_xmos_image_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_variants_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_variants_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_variants_args)
get_variants_args.thrift_spec = (
)


class get_variants_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_variants_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter20 in self.success:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_variants_result)
get_variants_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_current_variant_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_current_variant_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_current_variant_args)
get_current_variant_args.thrift_spec = (
)


class get_current_variant_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_current_variant_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_current_variant_result)
get_current_variant_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class set_variant_args(object):
    """
    Attributes:
     - variant
     - reboot

    """


    def __init__(self, variant=None, reboot=None,):
        self.variant = variant
        self.reboot = reboot

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.variant = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.reboot = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_variant_args')
        if self.variant is not None:
            oprot.writeFieldBegin('variant', TType.STRING, 1)
            oprot.writeString(self.variant.encode('utf-8') if sys.version_info[0] == 2 else self.variant)
            oprot.writeFieldEnd()
        if self.reboot is not None:
            oprot.writeFieldBegin('reboot', TType.BOOL, 2)
            oprot.writeBool(self.reboot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_variant_args)
set_variant_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'variant', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'reboot', None, None, ),  # 2
)


class set_variant_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_variant_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_variant_result)
set_variant_result.thrift_spec = (
)


class gpioinfo_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('gpioinfo_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(gpioinfo_args)
gpioinfo_args.thrift_spec = (
)


class gpioinfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('gpioinfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(gpioinfo_result)
gpioinfo_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_active_gpio_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_active_gpio_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_active_gpio_info_args)
get_active_gpio_info_args.thrift_spec = (
)


class get_active_gpio_info_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_active_gpio_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_active_gpio_info_result)
get_active_gpio_info_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_active_gpios_list_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_active_gpios_list_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_active_gpios_list_args)
get_active_gpios_list_args.thrift_spec = (
)


class get_active_gpios_list_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_active_gpios_list_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter27 in self.success:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_active_gpios_list_result)
get_active_gpios_list_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_gpio_args(object):
    """
    Attributes:
     - chip_num
     - line_num

    """


    def __init__(self, chip_num=None, line_num=None,):
        self.chip_num = chip_num
        self.line_num = line_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.chip_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.line_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_args')
        if self.chip_num is not None:
            oprot.writeFieldBegin('chip_num', TType.I32, 1)
            oprot.writeI32(self.chip_num)
            oprot.writeFieldEnd()
        if self.line_num is not None:
            oprot.writeFieldBegin('line_num', TType.I32, 2)
            oprot.writeI32(self.line_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_args)
get_gpio_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'chip_num', None, None, ),  # 1
    (2, TType.I32, 'line_num', None, None, ),  # 2
)


class get_gpio_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_result)
get_gpio_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class set_gpio_args(object):
    """
    Attributes:
     - chip_num
     - line_num
     - value

    """


    def __init__(self, chip_num=None, line_num=None, value=None,):
        self.chip_num = chip_num
        self.line_num = line_num
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.chip_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.line_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_args')
        if self.chip_num is not None:
            oprot.writeFieldBegin('chip_num', TType.I32, 1)
            oprot.writeI32(self.chip_num)
            oprot.writeFieldEnd()
        if self.line_num is not None:
            oprot.writeFieldBegin('line_num', TType.I32, 2)
            oprot.writeI32(self.line_num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 3)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_args)
set_gpio_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'chip_num', None, None, ),  # 1
    (2, TType.I32, 'line_num', None, None, ),  # 2
    (3, TType.I32, 'value', None, None, ),  # 3
)


class set_gpio_result(object):
    """
    Attributes:
     - err

    """


    def __init__(self, err=None,):
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_result')
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_result)
set_gpio_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class get_gpio_by_name_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_by_name_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_by_name_args)
get_gpio_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_gpio_by_name_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_by_name_result)
get_gpio_by_name_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class set_gpio_by_name_args(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_by_name_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_by_name_args)
set_gpio_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)


class set_gpio_by_name_result(object):
    """
    Attributes:
     - err

    """


    def __init__(self, err=None,):
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_by_name_result')
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_by_name_result)
set_gpio_by_name_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class get_gpio_direction_args(object):
    """
    Attributes:
     - chip_num
     - line_num

    """


    def __init__(self, chip_num=None, line_num=None,):
        self.chip_num = chip_num
        self.line_num = line_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.chip_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.line_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_direction_args')
        if self.chip_num is not None:
            oprot.writeFieldBegin('chip_num', TType.I32, 1)
            oprot.writeI32(self.chip_num)
            oprot.writeFieldEnd()
        if self.line_num is not None:
            oprot.writeFieldBegin('line_num', TType.I32, 2)
            oprot.writeI32(self.line_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_direction_args)
get_gpio_direction_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'chip_num', None, None, ),  # 1
    (2, TType.I32, 'line_num', None, None, ),  # 2
)


class get_gpio_direction_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_direction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_direction_result)
get_gpio_direction_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class set_gpio_direction_args(object):
    """
    Attributes:
     - chip_num
     - line_num
     - direction

    """


    def __init__(self, chip_num=None, line_num=None, direction=None,):
        self.chip_num = chip_num
        self.line_num = line_num
        self.direction = direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.chip_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.line_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_direction_args')
        if self.chip_num is not None:
            oprot.writeFieldBegin('chip_num', TType.I32, 1)
            oprot.writeI32(self.chip_num)
            oprot.writeFieldEnd()
        if self.line_num is not None:
            oprot.writeFieldBegin('line_num', TType.I32, 2)
            oprot.writeI32(self.line_num)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 3)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_direction_args)
set_gpio_direction_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'chip_num', None, None, ),  # 1
    (2, TType.I32, 'line_num', None, None, ),  # 2
    (3, TType.I32, 'direction', None, None, ),  # 3
)


class set_gpio_direction_result(object):
    """
    Attributes:
     - err

    """


    def __init__(self, err=None,):
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_direction_result')
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_direction_result)
set_gpio_direction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class get_gpio_direction_by_name_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_direction_by_name_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_direction_by_name_args)
get_gpio_direction_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_gpio_direction_by_name_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_gpio_direction_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_gpio_direction_by_name_result)
get_gpio_direction_by_name_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class set_gpio_direction_by_name_args(object):
    """
    Attributes:
     - name
     - direction

    """


    def __init__(self, name=None, direction=None,):
        self.name = name
        self.direction = direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_direction_by_name_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 2)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_direction_by_name_args)
set_gpio_direction_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'direction', None, None, ),  # 2
)


class set_gpio_direction_by_name_result(object):
    """
    Attributes:
     - err

    """


    def __init__(self, err=None,):
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_gpio_direction_by_name_result')
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_gpio_direction_by_name_result)
set_gpio_direction_by_name_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class toggle_gpio_args(object):
    """
    Attributes:
     - chip_num
     - line_num
     - active_low
     - delay
     - pulse_width

    """


    def __init__(self, chip_num=None, line_num=None, active_low=None, delay=None, pulse_width=None,):
        self.chip_num = chip_num
        self.line_num = line_num
        self.active_low = active_low
        self.delay = delay
        self.pulse_width = pulse_width

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.chip_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.line_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.active_low = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.delay = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.pulse_width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('toggle_gpio_args')
        if self.chip_num is not None:
            oprot.writeFieldBegin('chip_num', TType.I32, 1)
            oprot.writeI32(self.chip_num)
            oprot.writeFieldEnd()
        if self.line_num is not None:
            oprot.writeFieldBegin('line_num', TType.I32, 2)
            oprot.writeI32(self.line_num)
            oprot.writeFieldEnd()
        if self.active_low is not None:
            oprot.writeFieldBegin('active_low', TType.BOOL, 3)
            oprot.writeBool(self.active_low)
            oprot.writeFieldEnd()
        if self.delay is not None:
            oprot.writeFieldBegin('delay', TType.DOUBLE, 4)
            oprot.writeDouble(self.delay)
            oprot.writeFieldEnd()
        if self.pulse_width is not None:
            oprot.writeFieldBegin('pulse_width', TType.DOUBLE, 5)
            oprot.writeDouble(self.pulse_width)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(toggle_gpio_args)
toggle_gpio_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'chip_num', None, None, ),  # 1
    (2, TType.I32, 'line_num', None, None, ),  # 2
    (3, TType.BOOL, 'active_low', None, None, ),  # 3
    (4, TType.DOUBLE, 'delay', None, None, ),  # 4
    (5, TType.DOUBLE, 'pulse_width', None, None, ),  # 5
)


class toggle_gpio_result(object):
    """
    Attributes:
     - err

    """


    def __init__(self, err=None,):
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('toggle_gpio_result')
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(toggle_gpio_result)
toggle_gpio_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class toggle_gpio_by_name_args(object):
    """
    Attributes:
     - name
     - active_low
     - delay
     - pulse_width

    """


    def __init__(self, name=None, active_low=None, delay=None, pulse_width=None,):
        self.name = name
        self.active_low = active_low
        self.delay = delay
        self.pulse_width = pulse_width

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.active_low = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.delay = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.pulse_width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('toggle_gpio_by_name_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.active_low is not None:
            oprot.writeFieldBegin('active_low', TType.BOOL, 2)
            oprot.writeBool(self.active_low)
            oprot.writeFieldEnd()
        if self.delay is not None:
            oprot.writeFieldBegin('delay', TType.DOUBLE, 3)
            oprot.writeDouble(self.delay)
            oprot.writeFieldEnd()
        if self.pulse_width is not None:
            oprot.writeFieldBegin('pulse_width', TType.DOUBLE, 4)
            oprot.writeDouble(self.pulse_width)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(toggle_gpio_by_name_args)
toggle_gpio_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'active_low', None, None, ),  # 2
    (3, TType.DOUBLE, 'delay', None, None, ),  # 3
    (4, TType.DOUBLE, 'pulse_width', None, None, ),  # 4
)


class toggle_gpio_by_name_result(object):
    """
    Attributes:
     - err

    """


    def __init__(self, err=None,):
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err = GpioAccessError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('toggle_gpio_by_name_result')
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(toggle_gpio_by_name_result)
toggle_gpio_by_name_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'err', [GpioAccessError, None], None, ),  # 1
)


class reset_dut_args(object):
    """
    Attributes:
     - mode
     - active_low

    """


    def __init__(self, mode=None, active_low=None,):
        self.mode = mode
        self.active_low = active_low

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.active_low = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reset_dut_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 1)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.active_low is not None:
            oprot.writeFieldBegin('active_low', TType.BOOL, 2)
            oprot.writeBool(self.active_low)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reset_dut_args)
reset_dut_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mode', None, None, ),  # 1
    (2, TType.BOOL, 'active_low', None, None, ),  # 2
)


class reset_dut_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reset_dut_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reset_dut_result)
reset_dut_result.thrift_spec = (
)


class reset_wrapper_args(object):
    """
    Attributes:
     - mode
     - active_low

    """


    def __init__(self, mode=None, active_low=None,):
        self.mode = mode
        self.active_low = active_low

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.active_low = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reset_wrapper_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 1)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.active_low is not None:
            oprot.writeFieldBegin('active_low', TType.BOOL, 2)
            oprot.writeBool(self.active_low)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reset_wrapper_args)
reset_wrapper_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mode', None, None, ),  # 1
    (2, TType.BOOL, 'active_low', None, None, ),  # 2
)


class reset_wrapper_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reset_wrapper_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reset_wrapper_result)
reset_wrapper_result.thrift_spec = (
)


class set_rail_voltage_args(object):
    """
    Attributes:
     - voltage

    """


    def __init__(self, voltage=None,):
        self.voltage = voltage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.voltage = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_rail_voltage_args')
        if self.voltage is not None:
            oprot.writeFieldBegin('voltage', TType.DOUBLE, 1)
            oprot.writeDouble(self.voltage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_rail_voltage_args)
set_rail_voltage_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'voltage', None, None, ),  # 1
)


class set_rail_voltage_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_rail_voltage_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_rail_voltage_result)
set_rail_voltage_result.thrift_spec = (
)


class write_i2c_reg_args(object):
    """
    Attributes:
     - reg_addr
     - write_data
     - dev_addr
     - bus_num
     - speed
     - repeat_start
     - write_reg_addr_size
     - ainc
     - address_stride
     - write_reg_data_size

    """


    def __init__(self, reg_addr=None, write_data=None, dev_addr=None, bus_num=None, speed=None, repeat_start=None, write_reg_addr_size=None, ainc=None, address_stride=None, write_reg_data_size=None,):
        self.reg_addr = reg_addr
        self.write_data = write_data
        self.dev_addr = dev_addr
        self.bus_num = bus_num
        self.speed = speed
        self.repeat_start = repeat_start
        self.write_reg_addr_size = write_reg_addr_size
        self.ainc = ainc
        self.address_stride = address_stride
        self.write_reg_data_size = write_reg_data_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reg_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.write_data = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI16()
                        self.write_data.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dev_addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.bus_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.speed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.repeat_start = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.write_reg_addr_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.ainc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.address_stride = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.write_reg_data_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_i2c_reg_args')
        if self.reg_addr is not None:
            oprot.writeFieldBegin('reg_addr', TType.I64, 1)
            oprot.writeI64(self.reg_addr)
            oprot.writeFieldEnd()
        if self.write_data is not None:
            oprot.writeFieldBegin('write_data', TType.LIST, 2)
            oprot.writeListBegin(TType.I16, len(self.write_data))
            for iter34 in self.write_data:
                oprot.writeI16(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dev_addr is not None:
            oprot.writeFieldBegin('dev_addr', TType.I32, 3)
            oprot.writeI32(self.dev_addr)
            oprot.writeFieldEnd()
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I32, 4)
            oprot.writeI32(self.bus_num)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I32, 5)
            oprot.writeI32(self.speed)
            oprot.writeFieldEnd()
        if self.repeat_start is not None:
            oprot.writeFieldBegin('repeat_start', TType.BOOL, 6)
            oprot.writeBool(self.repeat_start)
            oprot.writeFieldEnd()
        if self.write_reg_addr_size is not None:
            oprot.writeFieldBegin('write_reg_addr_size', TType.I32, 7)
            oprot.writeI32(self.write_reg_addr_size)
            oprot.writeFieldEnd()
        if self.ainc is not None:
            oprot.writeFieldBegin('ainc', TType.BOOL, 8)
            oprot.writeBool(self.ainc)
            oprot.writeFieldEnd()
        if self.address_stride is not None:
            oprot.writeFieldBegin('address_stride', TType.I32, 9)
            oprot.writeI32(self.address_stride)
            oprot.writeFieldEnd()
        if self.write_reg_data_size is not None:
            oprot.writeFieldBegin('write_reg_data_size', TType.I32, 10)
            oprot.writeI32(self.write_reg_data_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_i2c_reg_args)
write_i2c_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reg_addr', None, None, ),  # 1
    (2, TType.LIST, 'write_data', (TType.I16, None, False), None, ),  # 2
    (3, TType.I32, 'dev_addr', None, None, ),  # 3
    (4, TType.I32, 'bus_num', None, None, ),  # 4
    (5, TType.I32, 'speed', None, None, ),  # 5
    (6, TType.BOOL, 'repeat_start', None, None, ),  # 6
    (7, TType.I32, 'write_reg_addr_size', None, None, ),  # 7
    (8, TType.BOOL, 'ainc', None, None, ),  # 8
    (9, TType.I32, 'address_stride', None, None, ),  # 9
    (10, TType.I32, 'write_reg_data_size', None, None, ),  # 10
)


class write_i2c_reg_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = I2c_error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_i2c_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_i2c_reg_result)
write_i2c_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'err', [I2c_error, None], None, ),  # 1
)


class read_i2c_reg_args(object):
    """
    Attributes:
     - reg_addr
     - byte_count
     - dev_addr
     - bus_num
     - speed
     - repeat_start
     - read_reg_addr_size
     - ainc
     - address_stride
     - read_reg_data_size

    """


    def __init__(self, reg_addr=None, byte_count=None, dev_addr=None, bus_num=None, speed=None, repeat_start=None, read_reg_addr_size=None, ainc=None, address_stride=None, read_reg_data_size=None,):
        self.reg_addr = reg_addr
        self.byte_count = byte_count
        self.dev_addr = dev_addr
        self.bus_num = bus_num
        self.speed = speed
        self.repeat_start = repeat_start
        self.read_reg_addr_size = read_reg_addr_size
        self.ainc = ainc
        self.address_stride = address_stride
        self.read_reg_data_size = read_reg_data_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reg_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.byte_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dev_addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.bus_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.speed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.repeat_start = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.read_reg_addr_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.ainc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.address_stride = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.read_reg_data_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_i2c_reg_args')
        if self.reg_addr is not None:
            oprot.writeFieldBegin('reg_addr', TType.I64, 1)
            oprot.writeI64(self.reg_addr)
            oprot.writeFieldEnd()
        if self.byte_count is not None:
            oprot.writeFieldBegin('byte_count', TType.I32, 2)
            oprot.writeI32(self.byte_count)
            oprot.writeFieldEnd()
        if self.dev_addr is not None:
            oprot.writeFieldBegin('dev_addr', TType.I32, 3)
            oprot.writeI32(self.dev_addr)
            oprot.writeFieldEnd()
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I32, 4)
            oprot.writeI32(self.bus_num)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I32, 5)
            oprot.writeI32(self.speed)
            oprot.writeFieldEnd()
        if self.repeat_start is not None:
            oprot.writeFieldBegin('repeat_start', TType.BOOL, 6)
            oprot.writeBool(self.repeat_start)
            oprot.writeFieldEnd()
        if self.read_reg_addr_size is not None:
            oprot.writeFieldBegin('read_reg_addr_size', TType.I32, 7)
            oprot.writeI32(self.read_reg_addr_size)
            oprot.writeFieldEnd()
        if self.ainc is not None:
            oprot.writeFieldBegin('ainc', TType.BOOL, 8)
            oprot.writeBool(self.ainc)
            oprot.writeFieldEnd()
        if self.address_stride is not None:
            oprot.writeFieldBegin('address_stride', TType.I32, 9)
            oprot.writeI32(self.address_stride)
            oprot.writeFieldEnd()
        if self.read_reg_data_size is not None:
            oprot.writeFieldBegin('read_reg_data_size', TType.I32, 10)
            oprot.writeI32(self.read_reg_data_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_i2c_reg_args)
read_i2c_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reg_addr', None, None, ),  # 1
    (2, TType.I32, 'byte_count', None, None, ),  # 2
    (3, TType.I32, 'dev_addr', None, None, ),  # 3
    (4, TType.I32, 'bus_num', None, None, ),  # 4
    (5, TType.I32, 'speed', None, None, ),  # 5
    (6, TType.BOOL, 'repeat_start', None, None, ),  # 6
    (7, TType.I32, 'read_reg_addr_size', None, None, ),  # 7
    (8, TType.BOOL, 'ainc', None, None, ),  # 8
    (9, TType.I32, 'address_stride', None, None, ),  # 9
    (10, TType.I32, 'read_reg_data_size', None, None, ),  # 10
)


class read_i2c_reg_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI16()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = I2c_error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_i2c_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter41 in self.success:
                oprot.writeI16(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_i2c_reg_result)
read_i2c_reg_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'err', [I2c_error, None], None, ),  # 1
)


class i2c_device_write_args(object):
    """
    Attributes:
     - bus_num
     - speed
     - dev_addr
     - write_data

    """


    def __init__(self, bus_num=None, speed=None, dev_addr=None, write_data=None,):
        self.bus_num = bus_num
        self.speed = speed
        self.dev_addr = dev_addr
        self.write_data = write_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.bus_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.speed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dev_addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.write_data = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI16()
                        self.write_data.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_device_write_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I32, 1)
            oprot.writeI32(self.bus_num)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I32, 2)
            oprot.writeI32(self.speed)
            oprot.writeFieldEnd()
        if self.dev_addr is not None:
            oprot.writeFieldBegin('dev_addr', TType.I32, 3)
            oprot.writeI32(self.dev_addr)
            oprot.writeFieldEnd()
        if self.write_data is not None:
            oprot.writeFieldBegin('write_data', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.write_data))
            for iter48 in self.write_data:
                oprot.writeI16(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_device_write_args)
i2c_device_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'bus_num', None, None, ),  # 1
    (2, TType.I32, 'speed', None, None, ),  # 2
    (3, TType.I32, 'dev_addr', None, None, ),  # 3
    (4, TType.LIST, 'write_data', (TType.I16, None, False), None, ),  # 4
)


class i2c_device_write_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = I2c_error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_device_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_device_write_result)
i2c_device_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'err', [I2c_error, None], None, ),  # 1
)


class i2c_device_read_args(object):
    """
    Attributes:
     - bus_num
     - speed
     - dev_addr
     - byte_count

    """


    def __init__(self, bus_num=None, speed=None, dev_addr=None, byte_count=None,):
        self.bus_num = bus_num
        self.speed = speed
        self.dev_addr = dev_addr
        self.byte_count = byte_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.bus_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.speed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dev_addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.byte_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_device_read_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I32, 1)
            oprot.writeI32(self.bus_num)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I32, 2)
            oprot.writeI32(self.speed)
            oprot.writeFieldEnd()
        if self.dev_addr is not None:
            oprot.writeFieldBegin('dev_addr', TType.I32, 3)
            oprot.writeI32(self.dev_addr)
            oprot.writeFieldEnd()
        if self.byte_count is not None:
            oprot.writeFieldBegin('byte_count', TType.I32, 4)
            oprot.writeI32(self.byte_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_device_read_args)
i2c_device_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'bus_num', None, None, ),  # 1
    (2, TType.I32, 'speed', None, None, ),  # 2
    (3, TType.I32, 'dev_addr', None, None, ),  # 3
    (4, TType.I32, 'byte_count', None, None, ),  # 4
)


class i2c_device_read_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readI16()
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = I2c_error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_device_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter55 in self.success:
                oprot.writeI16(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_device_read_result)
i2c_device_read_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'err', [I2c_error, None], None, ),  # 1
)


class i2c_check_ack_args(object):
    """
    Attributes:
     - bus_num
     - speed
     - dev_addr

    """


    def __init__(self, bus_num=None, speed=None, dev_addr=None,):
        self.bus_num = bus_num
        self.speed = speed
        self.dev_addr = dev_addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.bus_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.speed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dev_addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_check_ack_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I32, 1)
            oprot.writeI32(self.bus_num)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I32, 2)
            oprot.writeI32(self.speed)
            oprot.writeFieldEnd()
        if self.dev_addr is not None:
            oprot.writeFieldBegin('dev_addr', TType.I32, 3)
            oprot.writeI32(self.dev_addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_check_ack_args)
i2c_check_ack_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'bus_num', None, None, ),  # 1
    (2, TType.I32, 'speed', None, None, ),  # 2
    (3, TType.I32, 'dev_addr', None, None, ),  # 3
)


class i2c_check_ack_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_check_ack_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_check_ack_result)
i2c_check_ack_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class i2c_scan_args(object):
    """
    Attributes:
     - bus_num

    """


    def __init__(self, bus_num=None,):
        self.bus_num = bus_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_scan_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_scan_args)
i2c_scan_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
)


class i2c_scan_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i2c_scan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i2c_scan_result)
i2c_scan_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class set_i2c_bus_speed_args(object):
    """
    Attributes:
     - bus_num
     - speed

    """


    def __init__(self, bus_num=None, speed=None,):
        self.bus_num = bus_num
        self.speed = speed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.speed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_i2c_bus_speed_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I32, 2)
            oprot.writeI32(self.speed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_i2c_bus_speed_args)
set_i2c_bus_speed_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I32, 'speed', None, None, ),  # 2
)


class set_i2c_bus_speed_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_i2c_bus_speed_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_i2c_bus_speed_result)
set_i2c_bus_speed_result.thrift_spec = (
)


class spi_fd_args(object):
    """
    Attributes:
     - bytes_out
     - bus_num
     - chip_select
     - speed
     - keep_cs
     - clk_mode

    """


    def __init__(self, bytes_out=None, bus_num=None, chip_select=None, speed=None, keep_cs=None, clk_mode=None,):
        self.bytes_out = bytes_out
        self.bus_num = bus_num
        self.chip_select = chip_select
        self.speed = speed
        self.keep_cs = keep_cs
        self.clk_mode = clk_mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.bytes_out = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readI16()
                        self.bytes_out.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.chip_select = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.speed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.keep_cs = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I16:
                    self.clk_mode = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spi_fd_args')
        if self.bytes_out is not None:
            oprot.writeFieldBegin('bytes_out', TType.LIST, 1)
            oprot.writeListBegin(TType.I16, len(self.bytes_out))
            for iter62 in self.bytes_out:
                oprot.writeI16(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 2)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.chip_select is not None:
            oprot.writeFieldBegin('chip_select', TType.I16, 3)
            oprot.writeI16(self.chip_select)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I64, 4)
            oprot.writeI64(self.speed)
            oprot.writeFieldEnd()
        if self.keep_cs is not None:
            oprot.writeFieldBegin('keep_cs', TType.BOOL, 5)
            oprot.writeBool(self.keep_cs)
            oprot.writeFieldEnd()
        if self.clk_mode is not None:
            oprot.writeFieldBegin('clk_mode', TType.I16, 6)
            oprot.writeI16(self.clk_mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spi_fd_args)
spi_fd_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'bytes_out', (TType.I16, None, False), None, ),  # 1
    (2, TType.I16, 'bus_num', None, None, ),  # 2
    (3, TType.I16, 'chip_select', None, None, ),  # 3
    (4, TType.I64, 'speed', None, None, ),  # 4
    (5, TType.BOOL, 'keep_cs', None, None, ),  # 5
    (6, TType.I16, 'clk_mode', None, None, ),  # 6
)


class spi_fd_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readI16()
                        self.success.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spi_fd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter69 in self.success:
                oprot.writeI16(iter69)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spi_fd_result)
spi_fd_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
)


class spi_apb_block_read_args(object):
    """
    Attributes:
     - bus_num
     - chip_select
     - speed
     - address
     - addr_size
     - data_size
     - length

    """


    def __init__(self, bus_num=None, chip_select=None, speed=None, address=None, addr_size=None, data_size=None, length=None,):
        self.bus_num = bus_num
        self.chip_select = chip_select
        self.speed = speed
        self.address = address
        self.addr_size = addr_size
        self.data_size = data_size
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.chip_select = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.speed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.addr_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.data_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.length = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spi_apb_block_read_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.chip_select is not None:
            oprot.writeFieldBegin('chip_select', TType.I16, 2)
            oprot.writeI16(self.chip_select)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I64, 3)
            oprot.writeI64(self.speed)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 4)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.addr_size is not None:
            oprot.writeFieldBegin('addr_size', TType.I32, 5)
            oprot.writeI32(self.addr_size)
            oprot.writeFieldEnd()
        if self.data_size is not None:
            oprot.writeFieldBegin('data_size', TType.I32, 6)
            oprot.writeI32(self.data_size)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I64, 7)
            oprot.writeI64(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spi_apb_block_read_args)
spi_apb_block_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'chip_select', None, None, ),  # 2
    (3, TType.I64, 'speed', None, None, ),  # 3
    (4, TType.I64, 'address', None, None, ),  # 4
    (5, TType.I32, 'addr_size', None, None, ),  # 5
    (6, TType.I32, 'data_size', None, None, ),  # 6
    (7, TType.I64, 'length', None, None, ),  # 7
)


class spi_apb_block_read_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readI64()
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spi_apb_block_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter76 in self.success:
                oprot.writeI64(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spi_apb_block_read_result)
spi_apb_block_read_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
)


class spi_apb_block_write_args(object):
    """
    Attributes:
     - bus_num
     - chip_select
     - speed
     - address
     - values
     - addr_size
     - data_size

    """


    def __init__(self, bus_num=None, chip_select=None, speed=None, address=None, values=None, addr_size=None, data_size=None,):
        self.bus_num = bus_num
        self.chip_select = chip_select
        self.speed = speed
        self.address = address
        self.values = values
        self.addr_size = addr_size
        self.data_size = data_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.chip_select = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.speed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readI64()
                        self.values.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.addr_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.data_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spi_apb_block_write_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.chip_select is not None:
            oprot.writeFieldBegin('chip_select', TType.I16, 2)
            oprot.writeI16(self.chip_select)
            oprot.writeFieldEnd()
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.I64, 3)
            oprot.writeI64(self.speed)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 4)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.values))
            for iter83 in self.values:
                oprot.writeI64(iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.addr_size is not None:
            oprot.writeFieldBegin('addr_size', TType.I32, 6)
            oprot.writeI32(self.addr_size)
            oprot.writeFieldEnd()
        if self.data_size is not None:
            oprot.writeFieldBegin('data_size', TType.I32, 7)
            oprot.writeI32(self.data_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spi_apb_block_write_args)
spi_apb_block_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'chip_select', None, None, ),  # 2
    (3, TType.I64, 'speed', None, None, ),  # 3
    (4, TType.I64, 'address', None, None, ),  # 4
    (5, TType.LIST, 'values', (TType.I64, None, False), None, ),  # 5
    (6, TType.I32, 'addr_size', None, None, ),  # 6
    (7, TType.I32, 'data_size', None, None, ),  # 7
)


class spi_apb_block_write_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spi_apb_block_write_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spi_apb_block_write_result)
spi_apb_block_write_result.thrift_spec = (
)


class mmap_add_args(object):
    """
    Attributes:
     - base_addr
     - size
     - word_size

    """


    def __init__(self, base_addr=None, size=None, word_size=None,):
        self.base_addr = base_addr
        self.size = size
        self.word_size = word_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.base_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.word_size = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mmap_add_args')
        if self.base_addr is not None:
            oprot.writeFieldBegin('base_addr', TType.I64, 1)
            oprot.writeI64(self.base_addr)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I64, 2)
            oprot.writeI64(self.size)
            oprot.writeFieldEnd()
        if self.word_size is not None:
            oprot.writeFieldBegin('word_size', TType.I16, 3)
            oprot.writeI16(self.word_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mmap_add_args)
mmap_add_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'base_addr', None, None, ),  # 1
    (2, TType.I64, 'size', None, None, ),  # 2
    (3, TType.I16, 'word_size', None, None, ),  # 3
)


class mmap_add_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mmap_add_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mmap_add_result)
mmap_add_result.thrift_spec = (
)


class mmap_read_args(object):
    """
    Attributes:
     - base_addr
     - offset
     - num_bytes

    """


    def __init__(self, base_addr=None, offset=None, num_bytes=None,):
        self.base_addr = base_addr
        self.offset = offset
        self.num_bytes = num_bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.base_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mmap_read_args')
        if self.base_addr is not None:
            oprot.writeFieldBegin('base_addr', TType.I64, 1)
            oprot.writeI64(self.base_addr)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.num_bytes is not None:
            oprot.writeFieldBegin('num_bytes', TType.I64, 3)
            oprot.writeI64(self.num_bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mmap_read_args)
mmap_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'base_addr', None, None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I64, 'num_bytes', None, None, ),  # 3
)


class mmap_read_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readI16()
                        self.success.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mmap_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter90 in self.success:
                oprot.writeI16(iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mmap_read_result)
mmap_read_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
)


class mmap_write_args(object):
    """
    Attributes:
     - base_addr
     - offset
     - bytes_out

    """


    def __init__(self, base_addr=None, offset=None, bytes_out=None,):
        self.base_addr = base_addr
        self.offset = offset
        self.bytes_out = bytes_out

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.base_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.bytes_out = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readI16()
                        self.bytes_out.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mmap_write_args')
        if self.base_addr is not None:
            oprot.writeFieldBegin('base_addr', TType.I64, 1)
            oprot.writeI64(self.base_addr)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.bytes_out is not None:
            oprot.writeFieldBegin('bytes_out', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.bytes_out))
            for iter97 in self.bytes_out:
                oprot.writeI16(iter97)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mmap_write_args)
mmap_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'base_addr', None, None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.LIST, 'bytes_out', (TType.I16, None, False), None, ),  # 3
)


class mmap_write_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mmap_write_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mmap_write_result)
mmap_write_result.thrift_spec = (
)


class memio_write_args(object):
    """
    Attributes:
     - addr
     - data

    """


    def __init__(self, addr=None, data=None,):
        self.addr = addr
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.data = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('memio_write_args')
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I64, 1)
            oprot.writeI64(self.addr)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.I64, 2)
            oprot.writeI64(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(memio_write_args)
memio_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'addr', None, None, ),  # 1
    (2, TType.I64, 'data', None, None, ),  # 2
)


class memio_write_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('memio_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(memio_write_result)
memio_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class memio_read_args(object):
    """
    Attributes:
     - addr

    """


    def __init__(self, addr=None,):
        self.addr = addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('memio_read_args')
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I64, 1)
            oprot.writeI64(self.addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(memio_read_args)
memio_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'addr', None, None, ),  # 1
)


class memio_read_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('memio_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(memio_read_result)
memio_read_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class handle_interrupt_args(object):
    """
    Attributes:
     - int_id

    """


    def __init__(self, int_id=None,):
        self.int_id = int_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.int_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('handle_interrupt_args')
        if self.int_id is not None:
            oprot.writeFieldBegin('int_id', TType.I16, 1)
            oprot.writeI16(self.int_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(handle_interrupt_args)
handle_interrupt_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'int_id', None, None, ),  # 1
)


class handle_interrupt_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('handle_interrupt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(handle_interrupt_result)
handle_interrupt_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class start_embedded_interrupt_handling_args(object):
    """
    Attributes:
     - int_map
     - verbose
     - functions

    """


    def __init__(self, int_map=None, verbose=None, functions=None,):
        self.int_map = int_map
        self.verbose = verbose
        self.functions = functions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.int_map = {}
                    (_ktype99, _vtype100, _size98) = iprot.readMapBegin()
                    for _i102 in range(_size98):
                        _key103 = iprot.readI32()
                        _val104 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.int_map[_key103] = _val104
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.verbose = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.functions = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_embedded_interrupt_handling_args')
        if self.int_map is not None:
            oprot.writeFieldBegin('int_map', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.int_map))
            for kiter105, viter106 in self.int_map.items():
                oprot.writeI32(kiter105)
                oprot.writeString(viter106.encode('utf-8') if sys.version_info[0] == 2 else viter106)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.verbose is not None:
            oprot.writeFieldBegin('verbose', TType.BOOL, 2)
            oprot.writeBool(self.verbose)
            oprot.writeFieldEnd()
        if self.functions is not None:
            oprot.writeFieldBegin('functions', TType.STRING, 3)
            oprot.writeString(self.functions.encode('utf-8') if sys.version_info[0] == 2 else self.functions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_embedded_interrupt_handling_args)
start_embedded_interrupt_handling_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'int_map', (TType.I32, None, TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.BOOL, 'verbose', None, None, ),  # 2
    (3, TType.STRING, 'functions', 'UTF8', None, ),  # 3
)


class start_embedded_interrupt_handling_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_embedded_interrupt_handling_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_embedded_interrupt_handling_result)
start_embedded_interrupt_handling_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class print_from_buffer_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('print_from_buffer_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(print_from_buffer_args)
print_from_buffer_args.thrift_spec = (
)


class print_from_buffer_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('print_from_buffer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(print_from_buffer_result)
print_from_buffer_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class stop_embedded_interrupt_handling_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_embedded_interrupt_handling_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_embedded_interrupt_handling_args)
stop_embedded_interrupt_handling_args.thrift_spec = (
)


class stop_embedded_interrupt_handling_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_embedded_interrupt_handling_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_embedded_interrupt_handling_result)
stop_embedded_interrupt_handling_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class empty_server_queue_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('empty_server_queue_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(empty_server_queue_args)
empty_server_queue_args.thrift_spec = (
)


class empty_server_queue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('empty_server_queue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter113 in self.success:
                oprot.writeString(iter113.encode('utf-8') if sys.version_info[0] == 2 else iter113)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(empty_server_queue_result)
empty_server_queue_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class release_lock_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('release_lock_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(release_lock_args)
release_lock_args.thrift_spec = (
)


class release_lock_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('release_lock_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(release_lock_result)
release_lock_result.thrift_spec = (
)


class enable_spmi_args(object):
    """
    Attributes:
     - base_addr

    """


    def __init__(self, base_addr=None,):
        self.base_addr = base_addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.base_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_spmi_args')
        if self.base_addr is not None:
            oprot.writeFieldBegin('base_addr', TType.I64, 1)
            oprot.writeI64(self.base_addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_spmi_args)
enable_spmi_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'base_addr', None, None, ),  # 1
)


class enable_spmi_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_spmi_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_spmi_result)
enable_spmi_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_spmi_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_spmi_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_spmi_args)
disable_spmi_args.thrift_spec = (
)


class disable_spmi_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_spmi_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_spmi_result)
disable_spmi_result.thrift_spec = (
)


class spmi_device_initialize_args(object):
    """
    Attributes:
     - device_type
     - device_id
     - f_tclk
     - ddba_addr
     - inten
     - enr

    """


    def __init__(self, device_type=None, device_id=None, f_tclk=None, ddba_addr=None, inten=None, enr=None,):
        self.device_type = device_type
        self.device_id = device_id
        self.f_tclk = f_tclk
        self.ddba_addr = ddba_addr
        self.inten = inten
        self.enr = enr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.device_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.device_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.f_tclk = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ddba_addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.inten = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.enr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_device_initialize_args')
        if self.device_type is not None:
            oprot.writeFieldBegin('device_type', TType.STRING, 1)
            oprot.writeString(self.device_type.encode('utf-8') if sys.version_info[0] == 2 else self.device_type)
            oprot.writeFieldEnd()
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I32, 2)
            oprot.writeI32(self.device_id)
            oprot.writeFieldEnd()
        if self.f_tclk is not None:
            oprot.writeFieldBegin('f_tclk', TType.DOUBLE, 3)
            oprot.writeDouble(self.f_tclk)
            oprot.writeFieldEnd()
        if self.ddba_addr is not None:
            oprot.writeFieldBegin('ddba_addr', TType.I32, 4)
            oprot.writeI32(self.ddba_addr)
            oprot.writeFieldEnd()
        if self.inten is not None:
            oprot.writeFieldBegin('inten', TType.I32, 5)
            oprot.writeI32(self.inten)
            oprot.writeFieldEnd()
        if self.enr is not None:
            oprot.writeFieldBegin('enr', TType.I32, 6)
            oprot.writeI32(self.enr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_device_initialize_args)
spmi_device_initialize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'device_type', 'UTF8', None, ),  # 1
    (2, TType.I32, 'device_id', None, None, ),  # 2
    (3, TType.DOUBLE, 'f_tclk', None, None, ),  # 3
    (4, TType.I32, 'ddba_addr', None, None, ),  # 4
    (5, TType.I32, 'inten', None, None, ),  # 5
    (6, TType.I32, 'enr', None, None, ),  # 6
)


class spmi_device_initialize_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_device_initialize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_device_initialize_result)
spmi_device_initialize_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_device_disable_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_device_disable_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_device_disable_args)
spmi_device_disable_args.thrift_spec = (
)


class spmi_device_disable_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_device_disable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_device_disable_result)
spmi_device_disable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_set_master_req_prescaler_args(object):
    """
    Attributes:
     - rate

    """


    def __init__(self, rate=None,):
        self.rate = rate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.rate = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_master_req_prescaler_args')
        if self.rate is not None:
            oprot.writeFieldBegin('rate', TType.I32, 1)
            oprot.writeI32(self.rate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_master_req_prescaler_args)
spmi_set_master_req_prescaler_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'rate', None, None, ),  # 1
)


class spmi_set_master_req_prescaler_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_master_req_prescaler_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_master_req_prescaler_result)
spmi_set_master_req_prescaler_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_set_slave_addr_args(object):
    """
    Attributes:
     - addr

    """


    def __init__(self, addr=None,):
        self.addr = addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_slave_addr_args')
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I32, 1)
            oprot.writeI32(self.addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_slave_addr_args)
spmi_set_slave_addr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'addr', None, None, ),  # 1
)


class spmi_set_slave_addr_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_slave_addr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_slave_addr_result)
spmi_set_slave_addr_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_set_master_addr_args(object):
    """
    Attributes:
     - addr

    """


    def __init__(self, addr=None,):
        self.addr = addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_master_addr_args')
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I32, 1)
            oprot.writeI32(self.addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_master_addr_args)
spmi_set_master_addr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'addr', None, None, ),  # 1
)


class spmi_set_master_addr_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_master_addr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_master_addr_result)
spmi_set_master_addr_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_set_ip_version_args(object):
    """
    Attributes:
     - version

    """


    def __init__(self, version=None,):
        self.version = version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_ip_version_args')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I32, 1)
            oprot.writeI32(self.version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_ip_version_args)
spmi_set_ip_version_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'version', None, None, ),  # 1
)


class spmi_set_ip_version_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_set_ip_version_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_set_ip_version_result)
spmi_set_ip_version_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_poll_command_sent_flag_args(object):
    """
    Attributes:
     - clear_all_flags

    """


    def __init__(self, clear_all_flags=None,):
        self.clear_all_flags = clear_all_flags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.clear_all_flags = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_poll_command_sent_flag_args')
        if self.clear_all_flags is not None:
            oprot.writeFieldBegin('clear_all_flags', TType.BOOL, 1)
            oprot.writeBool(self.clear_all_flags)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_poll_command_sent_flag_args)
spmi_poll_command_sent_flag_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'clear_all_flags', None, None, ),  # 1
)


class spmi_poll_command_sent_flag_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_poll_command_sent_flag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_poll_command_sent_flag_result)
spmi_poll_command_sent_flag_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_master_write_args(object):
    """
    Attributes:
     - master_id
     - address
     - data
     - use_a_bit
     - use_sr_bit

    """


    def __init__(self, master_id=None, address=None, data=None, use_a_bit=None, use_sr_bit=None,):
        self.master_id = master_id
        self.address = address
        self.data = data
        self.use_a_bit = use_a_bit
        self.use_sr_bit = use_sr_bit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.master_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.data = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.use_a_bit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.use_sr_bit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_master_write_args')
        if self.master_id is not None:
            oprot.writeFieldBegin('master_id', TType.I32, 1)
            oprot.writeI32(self.master_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.I64, 3)
            oprot.writeI64(self.data)
            oprot.writeFieldEnd()
        if self.use_a_bit is not None:
            oprot.writeFieldBegin('use_a_bit', TType.BOOL, 4)
            oprot.writeBool(self.use_a_bit)
            oprot.writeFieldEnd()
        if self.use_sr_bit is not None:
            oprot.writeFieldBegin('use_sr_bit', TType.BOOL, 5)
            oprot.writeBool(self.use_sr_bit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_master_write_args)
spmi_master_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'master_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.I64, 'data', None, None, ),  # 3
    (4, TType.BOOL, 'use_a_bit', None, None, ),  # 4
    (5, TType.BOOL, 'use_sr_bit', None, None, ),  # 5
)


class spmi_master_write_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_master_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_master_write_result)
spmi_master_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spmi_master_read_args(object):
    """
    Attributes:
     - master_id
     - address
     - size
     - use_a_bit
     - use_sr_bit

    """


    def __init__(self, master_id=None, address=None, size=None, use_a_bit=None, use_sr_bit=None,):
        self.master_id = master_id
        self.address = address
        self.size = size
        self.use_a_bit = use_a_bit
        self.use_sr_bit = use_sr_bit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.master_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.use_a_bit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.use_sr_bit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_master_read_args')
        if self.master_id is not None:
            oprot.writeFieldBegin('master_id', TType.I32, 1)
            oprot.writeI32(self.master_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.use_a_bit is not None:
            oprot.writeFieldBegin('use_a_bit', TType.BOOL, 4)
            oprot.writeBool(self.use_a_bit)
            oprot.writeFieldEnd()
        if self.use_sr_bit is not None:
            oprot.writeFieldBegin('use_sr_bit', TType.BOOL, 5)
            oprot.writeBool(self.use_sr_bit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_master_read_args)
spmi_master_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'master_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.I32, 'size', None, None, ),  # 3
    (4, TType.BOOL, 'use_a_bit', None, None, ),  # 4
    (5, TType.BOOL, 'use_sr_bit', None, None, ),  # 5
)


class spmi_master_read_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_master_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_master_read_result)
spmi_master_read_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class spmi_register_write_args(object):
    """
    Attributes:
     - slave_id
     - address
     - data
     - priority

    """


    def __init__(self, slave_id=None, address=None, data=None, priority=None,):
        self.slave_id = slave_id
        self.address = address
        self.data = data
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype117, _size114) = iprot.readListBegin()
                    for _i118 in range(_size114):
                        _elem119 = iprot.readI16()
                        self.data.append(_elem119)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_register_write_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I32, 1)
            oprot.writeI32(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.data))
            for iter120 in self.data:
                oprot.writeI16(iter120)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 4)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_register_write_args)
spmi_register_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.LIST, 'data', (TType.I16, None, False), None, ),  # 3
    (4, TType.I32, 'priority', None, None, ),  # 4
)


class spmi_register_write_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_register_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_register_write_result)
spmi_register_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_register_read_args(object):
    """
    Attributes:
     - slave_id
     - address
     - priority

    """


    def __init__(self, slave_id=None, address=None, priority=None,):
        self.slave_id = slave_id
        self.address = address
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_register_read_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I32, 1)
            oprot.writeI32(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 3)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_register_read_args)
spmi_register_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.I32, 'priority', None, None, ),  # 3
)


class spmi_register_read_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_register_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_register_read_result)
spmi_register_read_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_extended_register_write_args(object):
    """
    Attributes:
     - slave_id
     - address
     - data
     - priority

    """


    def __init__(self, slave_id=None, address=None, data=None, priority=None,):
        self.slave_id = slave_id
        self.address = address
        self.data = data
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = iprot.readI16()
                        self.data.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_write_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I32, 1)
            oprot.writeI32(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.data))
            for iter127 in self.data:
                oprot.writeI16(iter127)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 4)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_write_args)
spmi_extended_register_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.LIST, 'data', (TType.I16, None, False), None, ),  # 3
    (4, TType.I32, 'priority', None, None, ),  # 4
)


class spmi_extended_register_write_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_write_result)
spmi_extended_register_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_extended_register_read_args(object):
    """
    Attributes:
     - slave_id
     - address
     - size
     - priority

    """


    def __init__(self, slave_id=None, address=None, size=None, priority=None,):
        self.slave_id = slave_id
        self.address = address
        self.size = size
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_read_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I32, 1)
            oprot.writeI32(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 4)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_read_args)
spmi_extended_register_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.I32, 'size', None, None, ),  # 3
    (4, TType.I32, 'priority', None, None, ),  # 4
)


class spmi_extended_register_read_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype131, _size128) = iprot.readListBegin()
                    for _i132 in range(_size128):
                        _elem133 = iprot.readI16()
                        self.success.append(_elem133)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter134 in self.success:
                oprot.writeI16(iter134)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_read_result)
spmi_extended_register_read_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_extended_register_write_long_args(object):
    """
    Attributes:
     - slave_id
     - address
     - data
     - priority

    """


    def __init__(self, slave_id=None, address=None, data=None, priority=None,):
        self.slave_id = slave_id
        self.address = address
        self.data = data
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = iprot.readI16()
                        self.data.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_write_long_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I32, 1)
            oprot.writeI32(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.data))
            for iter141 in self.data:
                oprot.writeI16(iter141)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 4)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_write_long_args)
spmi_extended_register_write_long_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.LIST, 'data', (TType.I16, None, False), None, ),  # 3
    (4, TType.I32, 'priority', None, None, ),  # 4
)


class spmi_extended_register_write_long_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_write_long_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_write_long_result)
spmi_extended_register_write_long_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_extended_register_read_long_args(object):
    """
    Attributes:
     - slave_id
     - address
     - size
     - priority

    """


    def __init__(self, slave_id=None, address=None, size=None, priority=None,):
        self.slave_id = slave_id
        self.address = address
        self.size = size
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_read_long_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I32, 1)
            oprot.writeI32(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 4)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_read_long_args)
spmi_extended_register_read_long_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.I32, 'size', None, None, ),  # 3
    (4, TType.I32, 'priority', None, None, ),  # 4
)


class spmi_extended_register_read_long_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype145, _size142) = iprot.readListBegin()
                    for _i146 in range(_size142):
                        _elem147 = iprot.readI16()
                        self.success.append(_elem147)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_extended_register_read_long_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter148 in self.success:
                oprot.writeI16(iter148)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_extended_register_read_long_result)
spmi_extended_register_read_long_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_24bit_write_args(object):
    """
    Attributes:
     - slave_id
     - address
     - data
     - priority
     - p_inx

    """


    def __init__(self, slave_id=None, address=None, data=None, priority=None, p_inx=None,):
        self.slave_id = slave_id
        self.address = address
        self.data = data
        self.priority = priority
        self.p_inx = p_inx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.slave_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = iprot.readI64()
                        self.data.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.p_inx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_24bit_write_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I64, 1)
            oprot.writeI64(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.data))
            for iter155 in self.data:
                oprot.writeI64(iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 4)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        if self.p_inx is not None:
            oprot.writeFieldBegin('p_inx', TType.I32, 5)
            oprot.writeI32(self.p_inx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_24bit_write_args)
spmi_24bit_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.LIST, 'data', (TType.I64, None, False), None, ),  # 3
    (4, TType.I32, 'priority', None, None, ),  # 4
    (5, TType.I32, 'p_inx', None, None, ),  # 5
)


class spmi_24bit_write_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_24bit_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_24bit_write_result)
spmi_24bit_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_24bit_read_args(object):
    """
    Attributes:
     - slave_id
     - address
     - word_count
     - priority
     - p_inx

    """


    def __init__(self, slave_id=None, address=None, word_count=None, priority=None, p_inx=None,):
        self.slave_id = slave_id
        self.address = address
        self.word_count = word_count
        self.priority = priority
        self.p_inx = p_inx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.slave_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.word_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.p_inx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_24bit_read_args')
        if self.slave_id is not None:
            oprot.writeFieldBegin('slave_id', TType.I64, 1)
            oprot.writeI64(self.slave_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.word_count is not None:
            oprot.writeFieldBegin('word_count', TType.I64, 3)
            oprot.writeI64(self.word_count)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 4)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        if self.p_inx is not None:
            oprot.writeFieldBegin('p_inx', TType.I32, 5)
            oprot.writeI32(self.p_inx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_24bit_read_args)
spmi_24bit_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'slave_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.I64, 'word_count', None, None, ),  # 3
    (4, TType.I32, 'priority', None, None, ),  # 4
    (5, TType.I32, 'p_inx', None, None, ),  # 5
)


class spmi_24bit_read_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype159, _size156) = iprot.readListBegin()
                    for _i160 in range(_size156):
                        _elem161 = iprot.readI64()
                        self.success.append(_elem161)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_24bit_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter162 in self.success:
                oprot.writeI64(iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_24bit_read_result)
spmi_24bit_read_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_block_read_args(object):
    """
    Attributes:
     - peripheral_id
     - start_addr
     - byte_count
     - addressibility
     - priority

    """


    def __init__(self, peripheral_id=None, start_addr=None, byte_count=None, addressibility=None, priority=None,):
        self.peripheral_id = peripheral_id
        self.start_addr = start_addr
        self.byte_count = byte_count
        self.addressibility = addressibility
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.peripheral_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.byte_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.addressibility = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_block_read_args')
        if self.peripheral_id is not None:
            oprot.writeFieldBegin('peripheral_id', TType.I16, 1)
            oprot.writeI16(self.peripheral_id)
            oprot.writeFieldEnd()
        if self.start_addr is not None:
            oprot.writeFieldBegin('start_addr', TType.I64, 2)
            oprot.writeI64(self.start_addr)
            oprot.writeFieldEnd()
        if self.byte_count is not None:
            oprot.writeFieldBegin('byte_count', TType.I64, 3)
            oprot.writeI64(self.byte_count)
            oprot.writeFieldEnd()
        if self.addressibility is not None:
            oprot.writeFieldBegin('addressibility', TType.I16, 4)
            oprot.writeI16(self.addressibility)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 5)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_block_read_args)
spmi_block_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'peripheral_id', None, None, ),  # 1
    (2, TType.I64, 'start_addr', None, None, ),  # 2
    (3, TType.I64, 'byte_count', None, None, ),  # 3
    (4, TType.I16, 'addressibility', None, None, ),  # 4
    (5, TType.I32, 'priority', None, None, ),  # 5
)


class spmi_block_read_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype166, _size163) = iprot.readListBegin()
                    for _i167 in range(_size163):
                        _elem168 = iprot.readI16()
                        self.success.append(_elem168)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_block_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter169 in self.success:
                oprot.writeI16(iter169)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_block_read_result)
spmi_block_read_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_block_write_args(object):
    """
    Attributes:
     - peripheral_id
     - start_addr
     - data
     - addressibility
     - priority

    """


    def __init__(self, peripheral_id=None, start_addr=None, data=None, addressibility=None, priority=None,):
        self.peripheral_id = peripheral_id
        self.start_addr = start_addr
        self.data = data
        self.addressibility = addressibility
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.peripheral_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start_addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype173, _size170) = iprot.readListBegin()
                    for _i174 in range(_size170):
                        _elem175 = iprot.readI16()
                        self.data.append(_elem175)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.addressibility = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_block_write_args')
        if self.peripheral_id is not None:
            oprot.writeFieldBegin('peripheral_id', TType.I16, 1)
            oprot.writeI16(self.peripheral_id)
            oprot.writeFieldEnd()
        if self.start_addr is not None:
            oprot.writeFieldBegin('start_addr', TType.I64, 2)
            oprot.writeI64(self.start_addr)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.data))
            for iter176 in self.data:
                oprot.writeI16(iter176)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.addressibility is not None:
            oprot.writeFieldBegin('addressibility', TType.I16, 4)
            oprot.writeI16(self.addressibility)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 5)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_block_write_args)
spmi_block_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'peripheral_id', None, None, ),  # 1
    (2, TType.I64, 'start_addr', None, None, ),  # 2
    (3, TType.LIST, 'data', (TType.I16, None, False), None, ),  # 3
    (4, TType.I16, 'addressibility', None, None, ),  # 4
    (5, TType.I32, 'priority', None, None, ),  # 5
)


class spmi_block_write_result(object):
    """
    Attributes:
     - timeout_err
     - arb_err

    """


    def __init__(self, timeout_err=None, arb_err=None,):
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_block_write_result')
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_block_write_result)
spmi_block_write_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_chain_read_args(object):
    """
    Attributes:
     - peripheral_id
     - address
     - num_reads
     - read_size
     - addressibility
     - priority

    """


    def __init__(self, peripheral_id=None, address=None, num_reads=None, read_size=None, addressibility=None, priority=None,):
        self.peripheral_id = peripheral_id
        self.address = address
        self.num_reads = num_reads
        self.read_size = read_size
        self.addressibility = addressibility
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.peripheral_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_reads = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.read_size = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.addressibility = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_chain_read_args')
        if self.peripheral_id is not None:
            oprot.writeFieldBegin('peripheral_id', TType.I16, 1)
            oprot.writeI16(self.peripheral_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.num_reads is not None:
            oprot.writeFieldBegin('num_reads', TType.I32, 3)
            oprot.writeI32(self.num_reads)
            oprot.writeFieldEnd()
        if self.read_size is not None:
            oprot.writeFieldBegin('read_size', TType.I16, 4)
            oprot.writeI16(self.read_size)
            oprot.writeFieldEnd()
        if self.addressibility is not None:
            oprot.writeFieldBegin('addressibility', TType.I16, 5)
            oprot.writeI16(self.addressibility)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 6)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_chain_read_args)
spmi_chain_read_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'peripheral_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.I32, 'num_reads', None, None, ),  # 3
    (4, TType.I16, 'read_size', None, None, ),  # 4
    (5, TType.I16, 'addressibility', None, None, ),  # 5
    (6, TType.I32, 'priority', None, None, ),  # 6
)


class spmi_chain_read_result(object):
    """
    Attributes:
     - success
     - timeout_err
     - arb_err

    """


    def __init__(self, success=None, timeout_err=None, arb_err=None,):
        self.success = success
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype180, _size177) = iprot.readListBegin()
                    for _i181 in range(_size177):
                        _elem182 = iprot.readI16()
                        self.success.append(_elem182)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_chain_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter183 in self.success:
                oprot.writeI16(iter183)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_chain_read_result)
spmi_chain_read_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class spmi_chain_write_args(object):
    """
    Attributes:
     - peripheral_id
     - address
     - data
     - write_size
     - addressibility
     - priority

    """


    def __init__(self, peripheral_id=None, address=None, data=None, write_size=None, addressibility=None, priority=None,):
        self.peripheral_id = peripheral_id
        self.address = address
        self.data = data
        self.write_size = write_size
        self.addressibility = addressibility
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.peripheral_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.address = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = iprot.readI16()
                        self.data.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.write_size = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.addressibility = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_chain_write_args')
        if self.peripheral_id is not None:
            oprot.writeFieldBegin('peripheral_id', TType.I16, 1)
            oprot.writeI16(self.peripheral_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I64, 2)
            oprot.writeI64(self.address)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.data))
            for iter190 in self.data:
                oprot.writeI16(iter190)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.write_size is not None:
            oprot.writeFieldBegin('write_size', TType.I16, 4)
            oprot.writeI16(self.write_size)
            oprot.writeFieldEnd()
        if self.addressibility is not None:
            oprot.writeFieldBegin('addressibility', TType.I16, 5)
            oprot.writeI16(self.addressibility)
            oprot.writeFieldEnd()
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 6)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_chain_write_args)
spmi_chain_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'peripheral_id', None, None, ),  # 1
    (2, TType.I64, 'address', None, None, ),  # 2
    (3, TType.LIST, 'data', (TType.I16, None, False), None, ),  # 3
    (4, TType.I16, 'write_size', None, None, ),  # 4
    (5, TType.I16, 'addressibility', None, None, ),  # 5
    (6, TType.I32, 'priority', None, None, ),  # 6
)


class spmi_chain_write_result(object):
    """
    Attributes:
     - timeout_err
     - arb_err

    """


    def __init__(self, timeout_err=None, arb_err=None,):
        self.timeout_err = timeout_err
        self.arb_err = arb_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.timeout_err = Spmi_timeout.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arb_err = Spmi_arb_failure.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_chain_write_result')
        if self.timeout_err is not None:
            oprot.writeFieldBegin('timeout_err', TType.STRUCT, 1)
            self.timeout_err.write(oprot)
            oprot.writeFieldEnd()
        if self.arb_err is not None:
            oprot.writeFieldBegin('arb_err', TType.STRUCT, 2)
            self.arb_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_chain_write_result)
spmi_chain_write_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'timeout_err', [Spmi_timeout, None], None, ),  # 1
    (2, TType.STRUCT, 'arb_err', [Spmi_arb_failure, None], None, ),  # 2
)


class master_write_args(object):
    """
    Attributes:
     - master_id
     - address
     - data
     - use_a_bit

    """


    def __init__(self, master_id=None, address=None, data=None, use_a_bit=None,):
        self.master_id = master_id
        self.address = address
        self.data = data
        self.use_a_bit = use_a_bit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.master_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.address = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.data = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.use_a_bit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('master_write_args')
        if self.master_id is not None:
            oprot.writeFieldBegin('master_id', TType.I16, 1)
            oprot.writeI16(self.master_id)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I32, 2)
            oprot.writeI32(self.address)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.I32, 3)
            oprot.writeI32(self.data)
            oprot.writeFieldEnd()
        if self.use_a_bit is not None:
            oprot.writeFieldBegin('use_a_bit', TType.BOOL, 4)
            oprot.writeBool(self.use_a_bit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(master_write_args)
master_write_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'master_id', None, None, ),  # 1
    (2, TType.I32, 'address', None, None, ),  # 2
    (3, TType.I32, 'data', None, None, ),  # 3
    (4, TType.BOOL, 'use_a_bit', None, None, ),  # 4
)


class master_write_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I16:
                    self.success = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('master_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I16, 0)
            oprot.writeI16(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(master_write_result)
master_write_result.thrift_spec = (
    (0, TType.I16, 'success', None, None, ),  # 0
)


class spmi_dump_registers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_dump_registers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_dump_registers_args)
spmi_dump_registers_args.thrift_spec = (
)


class spmi_dump_registers_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype194, _size191) = iprot.readListBegin()
                    for _i195 in range(_size191):
                        _elem196 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem196)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spmi_dump_registers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter197 in self.success:
                oprot.writeString(iter197.encode('utf-8') if sys.version_info[0] == 2 else iter197)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spmi_dump_registers_result)
spmi_dump_registers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class hcc_queue_packets_args(object):
    """
    Attributes:
     - packets
     - cs_delays

    """


    def __init__(self, packets=None, cs_delays=None,):
        self.packets = packets
        self.cs_delays = cs_delays

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.packets = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = []
                        (_etype207, _size204) = iprot.readListBegin()
                        for _i208 in range(_size204):
                            _elem209 = iprot.readI16()
                            _elem203.append(_elem209)
                        iprot.readListEnd()
                        self.packets.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cs_delays = []
                    (_etype213, _size210) = iprot.readListBegin()
                    for _i214 in range(_size210):
                        _elem215 = iprot.readI32()
                        self.cs_delays.append(_elem215)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_queue_packets_args')
        if self.packets is not None:
            oprot.writeFieldBegin('packets', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.packets))
            for iter216 in self.packets:
                oprot.writeListBegin(TType.I16, len(iter216))
                for iter217 in iter216:
                    oprot.writeI16(iter217)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cs_delays is not None:
            oprot.writeFieldBegin('cs_delays', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.cs_delays))
            for iter218 in self.cs_delays:
                oprot.writeI32(iter218)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_queue_packets_args)
hcc_queue_packets_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'packets', (TType.LIST, (TType.I16, None, False), False), None, ),  # 1
    (2, TType.LIST, 'cs_delays', (TType.I32, None, False), None, ),  # 2
)


class hcc_queue_packets_result(object):
    """
    Attributes:
     - hcc_err

    """


    def __init__(self, hcc_err=None,):
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_queue_packets_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_queue_packets_result)
hcc_queue_packets_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class hcc_send_packet_args(object):
    """
    Attributes:
     - packet
     - cs_delay

    """


    def __init__(self, packet=None, cs_delay=None,):
        self.packet = packet
        self.cs_delay = cs_delay

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.packet = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = iprot.readI16()
                        self.packet.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.cs_delay = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_send_packet_args')
        if self.packet is not None:
            oprot.writeFieldBegin('packet', TType.LIST, 1)
            oprot.writeListBegin(TType.I16, len(self.packet))
            for iter225 in self.packet:
                oprot.writeI16(iter225)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cs_delay is not None:
            oprot.writeFieldBegin('cs_delay', TType.I32, 2)
            oprot.writeI32(self.cs_delay)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_send_packet_args)
hcc_send_packet_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'packet', (TType.I16, None, False), None, ),  # 1
    (2, TType.I32, 'cs_delay', None, None, ),  # 2
)


class hcc_send_packet_result(object):
    """
    Attributes:
     - success
     - hcc_err

    """


    def __init__(self, success=None, hcc_err=None,):
        self.success = success
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype229, _size226) = iprot.readListBegin()
                    for _i230 in range(_size226):
                        _elem231 = iprot.readI16()
                        self.success.append(_elem231)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_send_packet_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter232 in self.success:
                oprot.writeI16(iter232)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_send_packet_result)
hcc_send_packet_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class hcc_execute_packet_queue_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_execute_packet_queue_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_execute_packet_queue_args)
hcc_execute_packet_queue_args.thrift_spec = (
)


class hcc_execute_packet_queue_result(object):
    """
    Attributes:
     - success
     - hcc_err

    """


    def __init__(self, success=None, hcc_err=None,):
        self.success = success
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype236, _size233) = iprot.readListBegin()
                    for _i237 in range(_size233):
                        _elem238 = []
                        (_etype242, _size239) = iprot.readListBegin()
                        for _i243 in range(_size239):
                            _elem244 = iprot.readI16()
                            _elem238.append(_elem244)
                        iprot.readListEnd()
                        self.success.append(_elem238)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_execute_packet_queue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter245 in self.success:
                oprot.writeListBegin(TType.I16, len(iter245))
                for iter246 in iter245:
                    oprot.writeI16(iter246)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_execute_packet_queue_result)
hcc_execute_packet_queue_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.I16, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class enable_hcc_args(object):
    """
    Attributes:
     - bus_num
     - chip_select

    """


    def __init__(self, bus_num=None, chip_select=None,):
        self.bus_num = bus_num
        self.chip_select = chip_select

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.bus_num = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.chip_select = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_hcc_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.BYTE, 1)
            oprot.writeByte(self.bus_num)
            oprot.writeFieldEnd()
        if self.chip_select is not None:
            oprot.writeFieldBegin('chip_select', TType.BYTE, 2)
            oprot.writeByte(self.chip_select)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_hcc_args)
enable_hcc_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'bus_num', None, None, ),  # 1
    (2, TType.BYTE, 'chip_select', None, None, ),  # 2
)


class enable_hcc_result(object):
    """
    Attributes:
     - hcc_err
     - i2c_err

    """


    def __init__(self, hcc_err=None, i2c_err=None,):
        self.hcc_err = hcc_err
        self.i2c_err = i2c_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i2c_err = I2c_error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_hcc_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i2c_err is not None:
            oprot.writeFieldBegin('i2c_err', TType.STRUCT, 2)
            self.i2c_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_hcc_result)
enable_hcc_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
    (2, TType.STRUCT, 'i2c_err', [I2c_error, None], None, ),  # 2
)


class disable_hcc_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_hcc_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_hcc_args)
disable_hcc_args.thrift_spec = (
)


class disable_hcc_result(object):
    """
    Attributes:
     - hcc_err
     - i2c_err

    """


    def __init__(self, hcc_err=None, i2c_err=None,):
        self.hcc_err = hcc_err
        self.i2c_err = i2c_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i2c_err = I2c_error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_hcc_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i2c_err is not None:
            oprot.writeFieldBegin('i2c_err', TType.STRUCT, 2)
            self.i2c_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_hcc_result)
disable_hcc_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
    (2, TType.STRUCT, 'i2c_err', [I2c_error, None], None, ),  # 2
)


class hcc_set_speed_args(object):
    """
    Attributes:
     - speed

    """


    def __init__(self, speed=None,):
        self.speed = speed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.speed = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_speed_args')
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.BYTE, 1)
            oprot.writeByte(self.speed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_speed_args)
hcc_set_speed_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'speed', None, None, ),  # 1
)


class hcc_set_speed_result(object):
    """
    Attributes:
     - hcc_err
     - i2c_err

    """


    def __init__(self, hcc_err=None, i2c_err=None,):
        self.hcc_err = hcc_err
        self.i2c_err = i2c_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i2c_err = I2c_error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_speed_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i2c_err is not None:
            oprot.writeFieldBegin('i2c_err', TType.STRUCT, 2)
            self.i2c_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_speed_result)
hcc_set_speed_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
    (2, TType.STRUCT, 'i2c_err', [I2c_error, None], None, ),  # 2
)


class hcc_set_setup_delay_args(object):
    """
    Attributes:
     - delay

    """


    def __init__(self, delay=None,):
        self.delay = delay

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.delay = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_setup_delay_args')
        if self.delay is not None:
            oprot.writeFieldBegin('delay', TType.I32, 1)
            oprot.writeI32(self.delay)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_setup_delay_args)
hcc_set_setup_delay_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'delay', None, None, ),  # 1
)


class hcc_set_setup_delay_result(object):
    """
    Attributes:
     - hcc_err

    """


    def __init__(self, hcc_err=None,):
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_setup_delay_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_setup_delay_result)
hcc_set_setup_delay_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class hcc_set_bit_order_args(object):
    """
    Attributes:
     - order

    """


    def __init__(self, order=None,):
        self.order = order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.order = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_bit_order_args')
        if self.order is not None:
            oprot.writeFieldBegin('order', TType.BYTE, 1)
            oprot.writeByte(self.order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_bit_order_args)
hcc_set_bit_order_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'order', None, None, ),  # 1
)


class hcc_set_bit_order_result(object):
    """
    Attributes:
     - hcc_err

    """


    def __init__(self, hcc_err=None,):
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_bit_order_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_bit_order_result)
hcc_set_bit_order_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class hcc_set_clk_mode_args(object):
    """
    Attributes:
     - mode

    """


    def __init__(self, mode=None,):
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.mode = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_clk_mode_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.BYTE, 1)
            oprot.writeByte(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_clk_mode_args)
hcc_set_clk_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'mode', None, None, ),  # 1
)


class hcc_set_clk_mode_result(object):
    """
    Attributes:
     - hcc_err

    """


    def __init__(self, hcc_err=None,):
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_set_clk_mode_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_set_clk_mode_result)
hcc_set_clk_mode_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class hcc_register_args(object):
    """
    Attributes:
     - handler

    """


    def __init__(self, handler=None,):
        self.handler = handler

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.handler = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_register_args')
        if self.handler is not None:
            oprot.writeFieldBegin('handler', TType.STRING, 1)
            oprot.writeString(self.handler.encode('utf-8') if sys.version_info[0] == 2 else self.handler)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_register_args)
hcc_register_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'handler', 'UTF8', None, ),  # 1
)


class hcc_register_result(object):
    """
    Attributes:
     - hcc_err

    """


    def __init__(self, hcc_err=None,):
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_register_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_register_result)
hcc_register_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class hcc_unregister_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_unregister_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_unregister_args)
hcc_unregister_args.thrift_spec = (
)


class hcc_unregister_result(object):
    """
    Attributes:
     - hcc_err

    """


    def __init__(self, hcc_err=None,):
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_unregister_result')
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_unregister_result)
hcc_unregister_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class hcc_hint_queue_get_args(object):
    """
    Attributes:
     - timeout

    """


    def __init__(self, timeout=None,):
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.timeout = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_hint_queue_get_args')
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.DOUBLE, 1)
            oprot.writeDouble(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_hint_queue_get_args)
hcc_hint_queue_get_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'timeout', None, None, ),  # 1
)


class hcc_hint_queue_get_result(object):
    """
    Attributes:
     - success
     - hcc_err

    """


    def __init__(self, success=None, hcc_err=None,):
        self.success = success
        self.hcc_err = hcc_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.hcc_err = HccDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hcc_hint_queue_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.hcc_err is not None:
            oprot.writeFieldBegin('hcc_err', TType.STRUCT, 1)
            self.hcc_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hcc_hint_queue_get_result)
hcc_hint_queue_get_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'hcc_err', [HccDriverError, None], None, ),  # 1
)


class enable_i3c_args(object):
    """
    Attributes:
     - bus_num

    """


    def __init__(self, bus_num=None,):
        self.bus_num = bus_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_i3c_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_i3c_args)
enable_i3c_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
)


class enable_i3c_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - variant_err

    """


    def __init__(self, success=None, i3c_err=None, variant_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.variant_err = variant_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.variant_err = VariantError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_i3c_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.variant_err is not None:
            oprot.writeFieldBegin('variant_err', TType.STRUCT, 2)
            self.variant_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_i3c_result)
enable_i3c_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cDriverError, None], None, ),  # 1
    (2, TType.STRUCT, 'variant_err', [VariantError, None], None, ),  # 2
)


class disable_i3c_args(object):
    """
    Attributes:
     - bus_num

    """


    def __init__(self, bus_num=None,):
        self.bus_num = bus_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_i3c_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_i3c_args)
disable_i3c_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
)


class disable_i3c_result(object):
    """
    Attributes:
     - variant_err

    """


    def __init__(self, variant_err=None,):
        self.variant_err = variant_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.variant_err = VariantError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_i3c_result')
        if self.variant_err is not None:
            oprot.writeFieldBegin('variant_err', TType.STRUCT, 1)
            self.variant_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_i3c_result)
disable_i3c_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'variant_err', [VariantError, None], None, ),  # 1
)


class i3c_controller_rstdaa_args(object):
    """
    Attributes:
     - bus_num
     - address
     - detach_devs

    """


    def __init__(self, bus_num=None, address=None, detach_devs=None,):
        self.bus_num = bus_num
        self.address = address
        self.detach_devs = detach_devs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.detach_devs = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_rstdaa_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.detach_devs is not None:
            oprot.writeFieldBegin('detach_devs', TType.BOOL, 3)
            oprot.writeBool(self.detach_devs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_rstdaa_args)
i3c_controller_rstdaa_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.BOOL, 'detach_devs', None, None, ),  # 3
)


class i3c_controller_rstdaa_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_rstdaa_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_rstdaa_result)
i3c_controller_rstdaa_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_setaasa_args(object):
    """
    Attributes:
     - bus_num

    """


    def __init__(self, bus_num=None,):
        self.bus_num = bus_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_setaasa_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_setaasa_args)
i3c_controller_setaasa_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
)


class i3c_controller_setaasa_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_setaasa_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_setaasa_result)
i3c_controller_setaasa_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_setdasa_args(object):
    """
    Attributes:
     - bus_num
     - static_addr
     - dyn_addr

    """


    def __init__(self, bus_num=None, static_addr=None, dyn_addr=None,):
        self.bus_num = bus_num
        self.static_addr = static_addr
        self.dyn_addr = dyn_addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.static_addr = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.dyn_addr = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_setdasa_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.static_addr is not None:
            oprot.writeFieldBegin('static_addr', TType.I16, 2)
            oprot.writeI16(self.static_addr)
            oprot.writeFieldEnd()
        if self.dyn_addr is not None:
            oprot.writeFieldBegin('dyn_addr', TType.I16, 3)
            oprot.writeI16(self.dyn_addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_setdasa_args)
i3c_controller_setdasa_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'static_addr', None, None, ),  # 2
    (3, TType.I16, 'dyn_addr', None, None, ),  # 3
)


class i3c_controller_setdasa_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_setdasa_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_setdasa_result)
i3c_controller_setdasa_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_setnewda_args(object):
    """
    Attributes:
     - bus_num
     - old_addr
     - new_addr

    """


    def __init__(self, bus_num=None, old_addr=None, new_addr=None,):
        self.bus_num = bus_num
        self.old_addr = old_addr
        self.new_addr = new_addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.old_addr = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.new_addr = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_setnewda_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.old_addr is not None:
            oprot.writeFieldBegin('old_addr', TType.I16, 2)
            oprot.writeI16(self.old_addr)
            oprot.writeFieldEnd()
        if self.new_addr is not None:
            oprot.writeFieldBegin('new_addr', TType.I16, 3)
            oprot.writeI16(self.new_addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_setnewda_args)
i3c_controller_setnewda_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'old_addr', None, None, ),  # 2
    (3, TType.I16, 'new_addr', None, None, ),  # 3
)


class i3c_controller_setnewda_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_setnewda_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_setnewda_result)
i3c_controller_setnewda_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_dodaa_args(object):
    """
    Attributes:
     - bus_num
     - reset_addr_assignments

    """


    def __init__(self, bus_num=None, reset_addr_assignments=None,):
        self.bus_num = bus_num
        self.reset_addr_assignments = reset_addr_assignments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.reset_addr_assignments = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_dodaa_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.reset_addr_assignments is not None:
            oprot.writeFieldBegin('reset_addr_assignments', TType.BOOL, 2)
            oprot.writeBool(self.reset_addr_assignments)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_dodaa_args)
i3c_controller_dodaa_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.BOOL, 'reset_addr_assignments', None, None, ),  # 2
)


class i3c_controller_dodaa_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype248, _vtype249, _size247) = iprot.readMapBegin()
                    for _i251 in range(_size247):
                        _key252 = iprot.readI64()
                        _val253 = iprot.readI32()
                        self.success[_key252] = _val253
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_dodaa_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.I32, len(self.success))
            for kiter254, viter255 in self.success.items():
                oprot.writeI64(kiter254)
                oprot.writeI32(viter255)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_dodaa_result)
i3c_controller_dodaa_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_disec_args(object):
    """
    Attributes:
     - bus_num
     - address
     - payload

    """


    def __init__(self, bus_num=None, address=None, payload=None,):
        self.bus_num = bus_num
        self.address = address
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.payload = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_disec_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.I16, 3)
            oprot.writeI16(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_disec_args)
i3c_controller_disec_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.I16, 'payload', None, None, ),  # 3
)


class i3c_controller_disec_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_disec_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_disec_result)
i3c_controller_disec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_enec_args(object):
    """
    Attributes:
     - bus_num
     - payload

    """


    def __init__(self, bus_num=None, payload=None,):
        self.bus_num = bus_num
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.payload = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_enec_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.I16, 2)
            oprot.writeI16(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_enec_args)
i3c_controller_enec_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'payload', None, None, ),  # 2
)


class i3c_controller_enec_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_enec_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_enec_result)
i3c_controller_enec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_getpid_args(object):
    """
    Attributes:
     - bus_num
     - address
     - add_device

    """


    def __init__(self, bus_num=None, address=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getpid_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 3)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getpid_args)
i3c_controller_getpid_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.BOOL, 'add_device', None, None, ),  # 3
)


class i3c_controller_getpid_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getpid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getpid_result)
i3c_controller_getpid_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_getbcr_args(object):
    """
    Attributes:
     - bus_num
     - address
     - add_device

    """


    def __init__(self, bus_num=None, address=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getbcr_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 3)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getbcr_args)
i3c_controller_getbcr_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.BOOL, 'add_device', None, None, ),  # 3
)


class i3c_controller_getbcr_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getbcr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getbcr_result)
i3c_controller_getbcr_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_getdcr_args(object):
    """
    Attributes:
     - bus_num
     - address
     - add_device

    """


    def __init__(self, bus_num=None, address=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getdcr_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 3)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getdcr_args)
i3c_controller_getdcr_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.BOOL, 'add_device', None, None, ),  # 3
)


class i3c_controller_getdcr_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getdcr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getdcr_result)
i3c_controller_getdcr_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_getstatus_args(object):
    """
    Attributes:
     - bus_num
     - address
     - add_device

    """


    def __init__(self, bus_num=None, address=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getstatus_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 3)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getstatus_args)
i3c_controller_getstatus_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.BOOL, 'add_device', None, None, ),  # 3
)


class i3c_controller_getstatus_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_getstatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_getstatus_result)
i3c_controller_getstatus_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_add_device_args(object):
    """
    Attributes:
     - bus_num
     - static_addr
     - dyn_addr

    """


    def __init__(self, bus_num=None, static_addr=None, dyn_addr=None,):
        self.bus_num = bus_num
        self.static_addr = static_addr
        self.dyn_addr = dyn_addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.static_addr = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.dyn_addr = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_add_device_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.static_addr is not None:
            oprot.writeFieldBegin('static_addr', TType.I16, 2)
            oprot.writeI16(self.static_addr)
            oprot.writeFieldEnd()
        if self.dyn_addr is not None:
            oprot.writeFieldBegin('dyn_addr', TType.I16, 3)
            oprot.writeI16(self.dyn_addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_add_device_args)
i3c_controller_add_device_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'static_addr', None, None, ),  # 2
    (3, TType.I16, 'dyn_addr', None, None, ),  # 3
)


class i3c_controller_add_device_result(object):
    """
    Attributes:
     - i3c_driver_err

    """


    def __init__(self, i3c_driver_err=None,):
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_add_device_result')
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 1)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_add_device_result)
i3c_controller_add_device_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 1
)


class i3c_controller_get_devices_args(object):
    """
    Attributes:
     - bus_num

    """


    def __init__(self, bus_num=None,):
        self.bus_num = bus_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_get_devices_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_get_devices_args)
i3c_controller_get_devices_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
)


class i3c_controller_get_devices_result(object):
    """
    Attributes:
     - success
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype259, _size256) = iprot.readListBegin()
                    for _i260 in range(_size256):
                        _elem261 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem261)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_get_devices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter262 in self.success:
                oprot.writeString(iter262.encode('utf-8') if sys.version_info[0] == 2 else iter262)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 1)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_get_devices_result)
i3c_controller_get_devices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 1
)


class i3c_read_device_args(object):
    """
    Attributes:
     - bus_num
     - address
     - num_bytes
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, num_bytes=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.num_bytes = num_bytes
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = iprot.readI16()
                        self.preamble_bytes.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_read_device_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.num_bytes is not None:
            oprot.writeFieldBegin('num_bytes', TType.I64, 3)
            oprot.writeI64(self.num_bytes)
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter269 in self.preamble_bytes:
                oprot.writeI16(iter269)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 5)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_read_device_args)
i3c_read_device_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.I64, 'num_bytes', None, None, ),  # 3
    (4, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 4
    (5, TType.BOOL, 'add_device', None, None, ),  # 5
)


class i3c_read_device_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = iprot.readI16()
                        self.success.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_read_device_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter276 in self.success:
                oprot.writeI16(iter276)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_read_device_result)
i3c_read_device_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_read_reg_args(object):
    """
    Attributes:
     - bus_num
     - address
     - reg_addr
     - num_bytes
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, reg_addr=None, num_bytes=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.reg_addr = reg_addr
        self.num_bytes = num_bytes
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.reg_addr = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = iprot.readI16()
                        self.reg_addr.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.num_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = iprot.readI16()
                        self.preamble_bytes.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_read_reg_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.reg_addr is not None:
            oprot.writeFieldBegin('reg_addr', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.reg_addr))
            for iter289 in self.reg_addr:
                oprot.writeI16(iter289)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_bytes is not None:
            oprot.writeFieldBegin('num_bytes', TType.I64, 4)
            oprot.writeI64(self.num_bytes)
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 5)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter290 in self.preamble_bytes:
                oprot.writeI16(iter290)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 6)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_read_reg_args)
i3c_read_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.LIST, 'reg_addr', (TType.I16, None, False), None, ),  # 3
    (4, TType.I64, 'num_bytes', None, None, ),  # 4
    (5, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 5
    (6, TType.BOOL, 'add_device', None, None, ),  # 6
)


class i3c_read_reg_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = iprot.readI16()
                        self.success.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_read_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter297 in self.success:
                oprot.writeI16(iter297)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_read_reg_result)
i3c_read_reg_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_write_device_args(object):
    """
    Attributes:
     - bus_num
     - address
     - write_data
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, write_data=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.write_data = write_data
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.write_data = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = iprot.readI16()
                        self.write_data.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = iprot.readI16()
                        self.preamble_bytes.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_write_device_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.write_data is not None:
            oprot.writeFieldBegin('write_data', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.write_data))
            for iter310 in self.write_data:
                oprot.writeI16(iter310)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter311 in self.preamble_bytes:
                oprot.writeI16(iter311)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 5)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_write_device_args)
i3c_write_device_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.LIST, 'write_data', (TType.I16, None, False), None, ),  # 3
    (4, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 4
    (5, TType.BOOL, 'add_device', None, None, ),  # 5
)


class i3c_write_device_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_write_device_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_write_device_result)
i3c_write_device_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_write_reg_args(object):
    """
    Attributes:
     - bus_num
     - address
     - reg_addr
     - write_data
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, reg_addr=None, write_data=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.reg_addr = reg_addr
        self.write_data = write_data
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.reg_addr = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = iprot.readI16()
                        self.reg_addr.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.write_data = []
                    (_etype321, _size318) = iprot.readListBegin()
                    for _i322 in range(_size318):
                        _elem323 = iprot.readI16()
                        self.write_data.append(_elem323)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype327, _size324) = iprot.readListBegin()
                    for _i328 in range(_size324):
                        _elem329 = iprot.readI16()
                        self.preamble_bytes.append(_elem329)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_write_reg_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.reg_addr is not None:
            oprot.writeFieldBegin('reg_addr', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.reg_addr))
            for iter330 in self.reg_addr:
                oprot.writeI16(iter330)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.write_data is not None:
            oprot.writeFieldBegin('write_data', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.write_data))
            for iter331 in self.write_data:
                oprot.writeI16(iter331)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 5)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter332 in self.preamble_bytes:
                oprot.writeI16(iter332)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 6)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_write_reg_args)
i3c_write_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.LIST, 'reg_addr', (TType.I16, None, False), None, ),  # 3
    (4, TType.LIST, 'write_data', (TType.I16, None, False), None, ),  # 4
    (5, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 5
    (6, TType.BOOL, 'add_device', None, None, ),  # 6
)


class i3c_write_reg_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_write_reg_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_write_reg_result)
i3c_write_reg_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_controller_add_i2c_device_args(object):
    """
    Attributes:
     - bus_num
     - address
     - replace

    """


    def __init__(self, bus_num=None, address=None, replace=None,):
        self.bus_num = bus_num
        self.address = address
        self.replace = replace

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.replace = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_add_i2c_device_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.replace is not None:
            oprot.writeFieldBegin('replace', TType.BOOL, 3)
            oprot.writeBool(self.replace)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_add_i2c_device_args)
i3c_controller_add_i2c_device_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.BOOL, 'replace', None, None, ),  # 3
)


class i3c_controller_add_i2c_device_result(object):
    """
    Attributes:
     - i3c_driver_err

    """


    def __init__(self, i3c_driver_err=None,):
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_add_i2c_device_result')
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 1)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_add_i2c_device_result)
i3c_controller_add_i2c_device_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 1
)


class i3c_controller_get_i2c_devices_args(object):
    """
    Attributes:
     - bus_num

    """


    def __init__(self, bus_num=None,):
        self.bus_num = bus_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_get_i2c_devices_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_get_i2c_devices_args)
i3c_controller_get_i2c_devices_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
)


class i3c_controller_get_i2c_devices_result(object):
    """
    Attributes:
     - success
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_get_i2c_devices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter339 in self.success:
                oprot.writeString(iter339.encode('utf-8') if sys.version_info[0] == 2 else iter339)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 1)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_get_i2c_devices_result)
i3c_controller_get_i2c_devices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 1
)


class i3c_controller_remove_device_args(object):
    """
    Attributes:
     - bus_num
     - address

    """


    def __init__(self, bus_num=None, address=None,):
        self.bus_num = bus_num
        self.address = address

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_remove_device_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_remove_device_args)
i3c_controller_remove_device_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
)


class i3c_controller_remove_device_result(object):
    """
    Attributes:
     - i3c_driver_err

    """


    def __init__(self, i3c_driver_err=None,):
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_controller_remove_device_result')
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 1)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_controller_remove_device_result)
i3c_controller_remove_device_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 1
)


class i3c_legacy_i2c_read_device_args(object):
    """
    Attributes:
     - bus_num
     - address
     - num_bytes
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, num_bytes=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.num_bytes = num_bytes
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype343, _size340) = iprot.readListBegin()
                    for _i344 in range(_size340):
                        _elem345 = iprot.readI16()
                        self.preamble_bytes.append(_elem345)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_read_device_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.num_bytes is not None:
            oprot.writeFieldBegin('num_bytes', TType.I64, 3)
            oprot.writeI64(self.num_bytes)
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter346 in self.preamble_bytes:
                oprot.writeI16(iter346)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 5)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_read_device_args)
i3c_legacy_i2c_read_device_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.I64, 'num_bytes', None, None, ),  # 3
    (4, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 4
    (5, TType.BOOL, 'add_device', None, None, ),  # 5
)


class i3c_legacy_i2c_read_device_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = iprot.readI16()
                        self.success.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_read_device_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter353 in self.success:
                oprot.writeI16(iter353)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_read_device_result)
i3c_legacy_i2c_read_device_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_legacy_i2c_read_reg_args(object):
    """
    Attributes:
     - bus_num
     - address
     - reg_addr
     - num_bytes
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, reg_addr=None, num_bytes=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.reg_addr = reg_addr
        self.num_bytes = num_bytes
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.reg_addr = []
                    (_etype357, _size354) = iprot.readListBegin()
                    for _i358 in range(_size354):
                        _elem359 = iprot.readI16()
                        self.reg_addr.append(_elem359)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.num_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype363, _size360) = iprot.readListBegin()
                    for _i364 in range(_size360):
                        _elem365 = iprot.readI16()
                        self.preamble_bytes.append(_elem365)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_read_reg_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.reg_addr is not None:
            oprot.writeFieldBegin('reg_addr', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.reg_addr))
            for iter366 in self.reg_addr:
                oprot.writeI16(iter366)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_bytes is not None:
            oprot.writeFieldBegin('num_bytes', TType.I64, 4)
            oprot.writeI64(self.num_bytes)
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 5)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter367 in self.preamble_bytes:
                oprot.writeI16(iter367)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 6)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_read_reg_args)
i3c_legacy_i2c_read_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.LIST, 'reg_addr', (TType.I16, None, False), None, ),  # 3
    (4, TType.I64, 'num_bytes', None, None, ),  # 4
    (5, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 5
    (6, TType.BOOL, 'add_device', None, None, ),  # 6
)


class i3c_legacy_i2c_read_reg_result(object):
    """
    Attributes:
     - success
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, success=None, i3c_err=None, i3c_driver_err=None,):
        self.success = success
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = iprot.readI16()
                        self.success.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_read_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter374 in self.success:
                oprot.writeI16(iter374)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_read_reg_result)
i3c_legacy_i2c_read_reg_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_legacy_i2c_write_device_args(object):
    """
    Attributes:
     - bus_num
     - address
     - write_data
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, write_data=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.write_data = write_data
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.write_data = []
                    (_etype378, _size375) = iprot.readListBegin()
                    for _i379 in range(_size375):
                        _elem380 = iprot.readI16()
                        self.write_data.append(_elem380)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype384, _size381) = iprot.readListBegin()
                    for _i385 in range(_size381):
                        _elem386 = iprot.readI16()
                        self.preamble_bytes.append(_elem386)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_write_device_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.write_data is not None:
            oprot.writeFieldBegin('write_data', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.write_data))
            for iter387 in self.write_data:
                oprot.writeI16(iter387)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter388 in self.preamble_bytes:
                oprot.writeI16(iter388)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 5)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_write_device_args)
i3c_legacy_i2c_write_device_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.LIST, 'write_data', (TType.I16, None, False), None, ),  # 3
    (4, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 4
    (5, TType.BOOL, 'add_device', None, None, ),  # 5
)


class i3c_legacy_i2c_write_device_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_write_device_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_write_device_result)
i3c_legacy_i2c_write_device_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)


class i3c_legacy_i2c_write_reg_args(object):
    """
    Attributes:
     - bus_num
     - address
     - reg_addr
     - write_data
     - preamble_bytes
     - add_device

    """


    def __init__(self, bus_num=None, address=None, reg_addr=None, write_data=None, preamble_bytes=None, add_device=None,):
        self.bus_num = bus_num
        self.address = address
        self.reg_addr = reg_addr
        self.write_data = write_data
        self.preamble_bytes = preamble_bytes
        self.add_device = add_device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.bus_num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.address = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.reg_addr = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = iprot.readI16()
                        self.reg_addr.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.write_data = []
                    (_etype398, _size395) = iprot.readListBegin()
                    for _i399 in range(_size395):
                        _elem400 = iprot.readI16()
                        self.write_data.append(_elem400)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.preamble_bytes = []
                    (_etype404, _size401) = iprot.readListBegin()
                    for _i405 in range(_size401):
                        _elem406 = iprot.readI16()
                        self.preamble_bytes.append(_elem406)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.add_device = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_write_reg_args')
        if self.bus_num is not None:
            oprot.writeFieldBegin('bus_num', TType.I16, 1)
            oprot.writeI16(self.bus_num)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.I16, 2)
            oprot.writeI16(self.address)
            oprot.writeFieldEnd()
        if self.reg_addr is not None:
            oprot.writeFieldBegin('reg_addr', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.reg_addr))
            for iter407 in self.reg_addr:
                oprot.writeI16(iter407)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.write_data is not None:
            oprot.writeFieldBegin('write_data', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.write_data))
            for iter408 in self.write_data:
                oprot.writeI16(iter408)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.preamble_bytes is not None:
            oprot.writeFieldBegin('preamble_bytes', TType.LIST, 5)
            oprot.writeListBegin(TType.I16, len(self.preamble_bytes))
            for iter409 in self.preamble_bytes:
                oprot.writeI16(iter409)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.add_device is not None:
            oprot.writeFieldBegin('add_device', TType.BOOL, 6)
            oprot.writeBool(self.add_device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_write_reg_args)
i3c_legacy_i2c_write_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'bus_num', None, None, ),  # 1
    (2, TType.I16, 'address', None, None, ),  # 2
    (3, TType.LIST, 'reg_addr', (TType.I16, None, False), None, ),  # 3
    (4, TType.LIST, 'write_data', (TType.I16, None, False), None, ),  # 4
    (5, TType.LIST, 'preamble_bytes', (TType.I16, None, False), None, ),  # 5
    (6, TType.BOOL, 'add_device', None, None, ),  # 6
)


class i3c_legacy_i2c_write_reg_result(object):
    """
    Attributes:
     - i3c_err
     - i3c_driver_err

    """


    def __init__(self, i3c_err=None, i3c_driver_err=None,):
        self.i3c_err = i3c_err
        self.i3c_driver_err = i3c_driver_err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.i3c_err = I3cError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.i3c_driver_err = I3cDriverError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('i3c_legacy_i2c_write_reg_result')
        if self.i3c_err is not None:
            oprot.writeFieldBegin('i3c_err', TType.STRUCT, 1)
            self.i3c_err.write(oprot)
            oprot.writeFieldEnd()
        if self.i3c_driver_err is not None:
            oprot.writeFieldBegin('i3c_driver_err', TType.STRUCT, 2)
            self.i3c_driver_err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(i3c_legacy_i2c_write_reg_result)
i3c_legacy_i2c_write_reg_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'i3c_err', [I3cError, None], None, ),  # 1
    (2, TType.STRUCT, 'i3c_driver_err', [I3cDriverError, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
