import fcntl
import io
import inspect
import json
import logging
import os
import re
import shutil
import socket
import struct
import subprocess
import sys
import threading
import time
import traceback

# ----- Imports for burst code ----- #
import signal
import statistics
import random
import math
# ---------------------------------- #

from collections import namedtuple
from fnmatch import fnmatch
from functools import lru_cache
from glob import glob
from importlib import reload
from importlib import import_module
from io import StringIO
from pathlib import Path
from queue import Queue
from time import sleep
from typing import Any, Dict, List, TYPE_CHECKING

sys.path.append('/home')
from cirrusvue.core.connection.native.i2c import I2C
from cirrusvue.core.connection.native.spi import SPI
from cirrusvue.core.connection.native.periphery.i2c import I2CError
from cirrusvue.core.connection.native.periphery.gpio import GPIO, GPIOError
from cl_test_station.gpio.enums import PinDirection
# ToDo: Re-add these imports when bit-array makes it into the next AH image
if TYPE_CHECKING:
    from cl_test_station.host_controllers.audiohub_controller.embedded_results import EmbeddedResults
    from cl_test_station.test_station import TestStation
    from cl_test_station.utilities.ts_function_serializer import func_loads
    from cl_test_station.utilities.ts_json import ts_dumps, ts_loads
    from cl_test_station.utilities.ts_logging import add_stream_handler, get_logger, TsLoggingAdapter
# Import generated thrift classes
from embedded_thrift_server.ah_thrift.ttypes import *
import embedded_thrift_server.ah_thrift.ah_thrift as ah_thrift
# Internal protocol imports
from embedded_thrift_server.dwc_i3c.dwc_i3c import DwcI3c
from embedded_thrift_server.dwc_i3c.i3c_device import i3c_device_info, i3c_priv_xfer
from embedded_thrift_server.dwc_i3c.i2c_device import i2c_device_info, i2c_msg, I2C_FLAG_DEF
from embedded_thrift_server.hcc.hcc_driver import HCCInterface, HCC_SIGNUM
from embedded_thrift_server.mmap_manager import MmapManager
from embedded_thrift_server.periphery_gpio import PeripheryGpio
from embedded_thrift_server.spmi_ctrl_api_mmap import SPMI
# Thrift imports for server construction
from thrift.protocol import TBinaryProtocol, TCompactProtocol
from thrift.server import TServer, TNonblockingServer
from thrift.transport import TSocket
from thrift.transport import TTransport

server_error_log = None

SPI_MUX_KWARGS = {
    'reg_addr': 0x40,
    'dev_addr': 0x67,
    'bus_num': 2,
    'speed': 0,
    'repeat_start': False,
    'ainc': False,
    'address_stride': 1

}

I3C_ERROR_DESC = {
    1: 'RESPONSE_ERROR_CRC',
    2: 'RESPONSE_ERROR_PARITY',
    3: 'RESPONSE_ERROR_FRAME',
    4: 'RESPONSE_ERROR_IBA_NACK',
    5: 'RESPONSE_ERROR_ADDRESS_NACK',
    6: 'RESPONSE_ERROR_OVER_UNDER_FLOW',
    7: 'RESPONSE_ERROR_TRANSF_ABORT',
    8: 'RESPONSE_ERROR_TRANSF_ABORT',
    9: 'RESPONSE_ERROR_I2C_W_NACK_ERR'
}

PinLocation = namedtuple("gpio", "chip line_num")

FPGA_PATH = Path("/home/cirrus/fpga/")
BOOT_PATH = Path("/mnt/boot/")
REGMAP_PATH = Path("/home/regmap")


class PrintBuffer(object):
    """
    Custom IO class that stores all written data into a queue. Stored data can then be read back at any time. Used by
    thrift interface to capture print statements and traceback so that it can be relayed back to the client.
    """
    def __init__(self):
        self.q = Queue()

    def write(self, str):
        self.q.put(str)

    def read(self):
        s = ''
        while not self.q.empty():
            s += self.q.get()
        return s

    def flush(self):
        with self.q.mutex:
            self.q.queue.clear()


def require_variant(*variant_names: str):
    """
    Decorator for requiring certain variants in order to run a function. Input values are string-matched using fnmatch,
    so wildcard patterns (*, ?) are valid. Raises a VariantError if this requirement is not met at runtime.

    For example:

    @require_variant('*_i3c')
    def foo(self, ...):
         pass

    Any variant that ends in '_i3c' will be considered valid.

    :param variant_names: Names of variants that are required for this function to run.
    :type variant_names: str
    """
    def wrapper(func):
        def inner(ah_thrift: 'ah_thrift_handler', *args, **kwargs):
            # Get currnent variant name
            current_variant = ah_thrift.get_current_variant()
            # Check to see if this variant meets function requirements
            if not any([fnmatch(current_variant, v) for v in variant_names]):  # No match, raise error
                raise VariantError(f"Invalid variant {current_variant}: Must be {', '.join(variant_names)}")
            # Call function and return the result
            return func(ah_thrift, *args, **kwargs)
        return inner
    return wrapper


class ah_thrift_handler(ah_thrift.Iface):

    int_dict = None
    MAX_I2C_SIZE = 2048  # TODO: Find an accurate value for this (and figure out timeout issue)

    def __init__(self):
        global server_error_log
        server_error_log = open('/home/ah_ctrl_server_log.log', 'w+')
        sys.stderr = server_error_log
        self.mmap_manager = MmapManager()
        self.log = {}
        self.handler_lock = threading.Lock()
        self.verbose = False
        self.framework = None
        self.test_station = None
        self.spmi: SPMI = None
        self.hostname = socket.gethostname()

        # Params for I2C: bus, i2c_addr, map_size = 1, word_size = 1, bus_speed = 0, repeated_start = True,
        for i in range(0, 5):
            if os.path.exists('/dev/i2c-' + str(i)):
                i2c_controller = I2C(bus=i, i2c_addr=0, map_size=0, word_size=1, bus_speed=0, repeated_start=True)
                self.__setattr__('i2c_controller_' + str(i), i2c_controller)

        self.gpio_chip = None
        self.active_gpios = {}
        if self.hostname.startswith('zdc'):
            self.__init_zdc_gpios()
        elif self.hostname.startswith('ah'):
            self.__init_ah_gpios()
        elif self.hostname.startswith('gtp'):
            self.__init_remy_gpios()
        self.hcc_driver = None  # type: HCCInterface
        self.hcc_enabled = False
        # Dictionary to store I3C drivers. Key is bus num (int), value is DwcI3c instance
        self.dwc_i3c: Dict[int, DwcI3c] = {}
        self.i3c_initial_devices: Dict[int, List[int]] = {}  # Dict of initial dynamic address present in DwcI3c drivers
        self._hint_queue = Queue()

    @lru_cache(maxsize=128)
    def server_func_wrapper(self, func):
        """
        Wraps all Thrift functions in a try-except to prevent thrift from grouping all exceptions as "internal error: x"

        :param func: Function to wrap
        :type func: Callable
        :return: Wrapped function that includes a try-except.
        :rtype: Callable
        """
        def call_with_traceback(*args, **kwargs):
            try:
                return func(*args, **kwargs)  # Try executing function
            except Exception as thrift_error:
                server_error_log.write(traceback.format_exc())  # Write traceback to error stream
                raise thrift_error
        return call_with_traceback

    def __getattribute__(self, item):
        attr = object.__getattribute__(self, item)
        if inspect.ismethod(attr) and item != "server_func_wrapper":  # This is a class function, wrap it
            return self.server_func_wrapper(attr)
        return attr

    def __del__(self):
        # Close the log file
        server_error_log.close()

    def get_traceback(self):
        """
        Flushes stderr and returns full error output as a string. Then clears stderr stream.

        :return: All traceback's and exceptions logged to stderr since this function was last called/
        :rtype: str
        """
        server_error_log.flush()  # Send all written error data to the file
        server_error_log.seek(0)
        traceback = server_error_log.read()
        server_error_log.seek(0)
        server_error_log.truncate(0)  # Clear log
        return traceback

    def __init_ah_gpios(self):
        """
        Creates periphery GPIO controllers for AH GPIOs.
        Controllers are attributes of this class as gpio_<chip>_<line_num>_controller
        :return:
        :rtype:
        """
        import gpiod #here becasue zdc image does not support it
        # Constants
        gpio_mapping = {
            'DEV_GPIO0': PinLocation(chip= 0, line_num=0),
            'DEV_GPIO1': PinLocation(chip= 0, line_num=1),
            'DEV_GPIO2': PinLocation(chip= 0, line_num=2),
            'DEV_GPIO3': PinLocation(chip= 0, line_num=3),
            'DEV_DUT_RESET_N': PinLocation(chip= 1, line_num=54),
            'DEV_SYS_RESET_N': PinLocation(chip= 1, line_num=55)}
        self.__GPIO_LINE_REQ_DIR_IN = gpiod.LINE_REQ_DIR_IN
        self.__GPIO_LINE_REQ_DIR_OUT = gpiod.LINE_REQ_DIR_OUT

        # Request GPIO access
        for pin_name, location in gpio_mapping.items():
            controller = gpiod.Chip(f"/dev/gpiochip{location.chip}").get_line(location.line_num)
            if controller.is_used():
                raise GpioAccessError(f'gpio{location.chip}_{location.line_num} is busy, cannot create controller class')
            else:
                if controller.is_requested():
                    controller.release()
                if controller.direction() == controller.DIRECTION_INPUT:
                    controller.request(consumer=pin_name, type=self.__GPIO_LINE_REQ_DIR_IN)
                else:
                    controller.request(consumer=pin_name, type=self.__GPIO_LINE_REQ_DIR_OUT)
                self.__setattr__(f'gpio{location.chip}_{location.line_num}_controller', controller)
                self.active_gpios[pin_name] = location

    def __init_remy_gpios(self):
        """
        Creates periphery GPIO controllers for AH GPIOs.
        Controllers are attributes of this class as gpio_<chip>_<line_num>_controller
        :return:
        :rtype:
        """
        pass

    def __init_zdc_gpios(self):
        """
        Creates periphery GPIO controllers for ZDC GPIOs.
        Controllers are attributes of this class as gpio_<chip>_<line_num>_controller
        """
        # Constants
        gpio_mapping = {
            'GPIO_39': PinLocation(chip= 0, line_num=0),
            'GPIO_41': PinLocation(chip= 0, line_num=1),
            'GPIO_42': PinLocation(chip= 0, line_num=2),
            'GPIO_43': PinLocation(chip= 0, line_num=3)}

        # Request GPIO access
        for pin_name, location in gpio_mapping.items():
            try:
                controller = PeripheryGpio(location.chip, location.line_num)
            except GPIOError:  # Line is busy, raise error
                raise GpioAccessError(f'gpio line {gpio_line} is busy, cannot create controller class')
            if controller.is_used():
                raise GpioAccessError(f'gpio{location.chip}_{location.line_num} is busy, cannot create controller class')
            else:
                if controller.is_requested():
                    controller.release()
                if controller.direction() == controller.DIRECTION_INPUT:
                    controller.request(consumer=pin_name, type=controller.DIRECTION_INPUT)
                else:
                    controller.request(consumer=pin_name, type=controller.DIRECTION_OUTPUT)
                self.__setattr__(f'gpio{location.chip}_{location.line_num}_controller', controller)
                self.active_gpios[pin_name] = location

        self.__GPIO_LINE_REQ_DIR_IN = controller.DIRECTION_INPUT
        self.__GPIO_LINE_REQ_DIR_OUT = controller.DIRECTION_OUTPUT

    def gpioinfo(self):
        """
        Returns line name, line number, consumer, directions, and active state] for every line in each gpio chip.
        :return:
        :rtype: str
        """
        if self.hostname.startswith('ah'):
            fulltext=''
            for chip in gpiod.ChipIter():
                fulltext += '{} - {} lines:'.format(chip.name(), chip.num_lines())

                for line in gpiod.LineIter(chip):
                    offset = line.offset()
                    name = line.name()
                    consumer = line.consumer()
                    direction = line.direction()
                    active_state = line.active_state()

                    output = '\tline {:>3}: {:>18} {:>12} {:>8} {:>10}'.format(
                        offset,
                        'unnamed' if name is None else name,
                        'unused' if consumer is None else consumer,
                        'input' if direction == gpiod.Line.DIRECTION_INPUT else 'output',
                        'active-low' if active_state == gpiod.Line.ACTIVE_LOW else 'active-high')

                    fulltext += '\n' + output
                chip.close()
                fulltext += '\n'
            return fulltext
        elif self.hostname.startswith('zdc'):
            return "gpioinfo is not implement for zdc controller"

    def set_gpio(self, chip_num=0, line_num=0, value=0):
        """
        Sets GPIO to value
        :param chip_num: chip number
        :type chip_num: int
        :param line_num: line number for the gpio pin
        :type line_num: int
        :param value: Value to set the line to
        :type value: int
        :return: None
        :rtype: None
        """
        controller_str = f'gpio{chip_num}_{line_num}_controller'
        controller = self.__getattribute__(controller_str)
        if not controller.is_requested():
            raise GpioAccessError(f'Line {line_num} has not been requested.')
        if controller.direction() == controller.DIRECTION_INPUT:
            raise GpioAccessError(f"Error seting {controller_str}. Pin direction is set to {PinDirection.INPUT.name}.")
        else:
            controller.set_value(value)

    def get_gpio(self, chip_num=0, line_num=0):
        """
        Gets GPIO value
        :param chip_num:  chip number
        :type chip_num: int
        :param line_num: number for the gpio
        :type line_num: int
        :return: Value (0 for low, 1 for high)
        :rtype: int
        """
        controller_str = f'gpio{chip_num}_{line_num}_controller'
        controller = self.__getattribute__(controller_str)
        if not controller.is_requested():
            raise GpioAccessError(f'Line {line_num} has not been requested.')
        value = controller.get_value()
        return value

    def set_gpio_by_name(self, name:str, value:int):
        """
        Sets gpio value using the pin name as string. Retrieves the chip number and line number from the active gpios list and calls the set_gpio function.
        :param name: pin name. Call get_active_gpios_list() to find a list of options.
        :type name: str
        :param value: value to set the line to
        :type value: int
        :return: None
        :rtype: None
        """
        self.verify_gpio_name(name)
        chip_num, line_num = self.active_gpios[name]
        self.set_gpio(chip_num, line_num, value)

    def get_gpio_by_name(self, name:str):
        """
        Gets the gpio value using the pin name as string. Retrieves the chip number and line number from the active gpios list and calls the get_gpio function.
        :param name: pin name. Call get_active_gpios_list() to find a list of options.
        :type name: str
        :return: Value read from the gpio
        :rtype: int
        """
        self.verify_gpio_name(name)
        chip_num, line_num = self.active_gpios[name]
        return self.get_gpio(chip_num, line_num)

    def get_gpio_direction_by_name(self, name:str):
        """
        Sets the gpio direction using the pin name as string. Retrieves the chip number and line number from the active gpios list and calls the get_gpio_direction function.
        :param name: pin name. Call get_active_gpios_list() to find a list of options.
        :type name: str
        :return: direction. 0=OUTPUT, 1=INPUT
        :rtype: int
        """
        self.verify_gpio_name(name)
        chip_num, line_num = self.active_gpios[name]
        return self.get_gpio_direction(chip_num, line_num)

    def set_gpio_direction_by_name(self, name:str, direction:int):
        """
        Sets the gpio direction using the pin name as string. Retrieves the chip number and line number from the active gpios list and calls the get_gpio_direction function.
        :param name: pin name. Call get_active_gpios_list() to find a list of options.
        :type name: str
        :param direction: direction. 0=OUTPUT, 1=INPUT
        :type direction: int
        :return: None
        :rtype: None
        """
        self.verify_gpio_name(name)
        chip_num, line_num = self.active_gpios[name]
        self.set_gpio_direction(chip_num, line_num, direction)

    def get_active_gpios_list(self):
        """
        Returns all active gpio names.
        :return: a list of active gpio pin names
        :rtype: [str]
        """
        return self.active_gpios.keys()

    def get_active_gpio_info(self):
        """
        Gets info on the active gpios. Returns: pin name, controller_name, direction, and current value - for each active gpio line.
        :return: str
        :rtype:
        """
        printout='Active GPIOs:'
        for pin_name in self.active_gpios.keys():
            chip_num, line_num = self.active_gpios[pin_name]
            controller_str = f'gpio{chip_num}_{line_num}_controller'
            controller = self.__getattribute__(controller_str)
            linetext = '\t{:<20} {:<25} {:<10} value={:<20}'.format(
                    pin_name,
                    controller_str,
                    PinDirection.INPUT.name if controller.direction() == controller.DIRECTION_INPUT else PinDirection.OUTPUT.name,
                    self.get_gpio(chip_num,line_num))
            printout = printout + '\n' + linetext
        return printout

    def get_gpio_direction(self, chip_num:int=0, line_num:int=0):
        """
        Get the gpio direction.
        :param chip_num: gpio chip number
        :type chip_num: int
        :param line_num: line number
        :type line_num: int
        :return: direction. 0=OUTPUT, 1=INPUT
        :rtype: int
        """
        controller_str = f'gpio{chip_num}_{line_num}_controller'
        controller = self.__getattribute__(controller_str)
        if not controller.is_requested():
            raise GpioAccessError(f'Line {line_num} has not been requested.')
        else:
            return PinDirection.INPUT.value if controller.direction() == controller.DIRECTION_INPUT else PinDirection.OUTPUT.value

    def set_gpio_direction(self, chip_num:int=0, line_num:int=0, direction:int=1):
        """
        Sets the gpio pin direction. Does nothing if cahched value is already the requested direction.
        :param chip_num:
        :type chip_num: int
        :param line_num:
        :type line_num: int
        :param direction: Corresponds to values of PinDirection enum. OUTPUT=0, INPUT=1
        :type direction: int
        :return:
        :rtype: None
        """
        controller_str = f'gpio{chip_num}_{line_num}_controller'
        controller = self.__getattribute__(controller_str)
        if direction == PinDirection.INPUT.value:
            type=self.__GPIO_LINE_REQ_DIR_IN
            desired_direction=controller.DIRECTION_INPUT
        elif direction == PinDirection.OUTPUT.value:
            type=self.__GPIO_LINE_REQ_DIR_OUT
            desired_direction = controller.DIRECTION_OUTPUT
        else:
            raise GpioAccessError(f"Direction options are {PinDirection.INPUT.value}={PinDirection.INPUT.name}"
                                  f" or {PinDirection.OUTPUT.value}={PinDirection.OUTPUT.name}")
        if controller.direction() != desired_direction: #Only set if not already in correct direction.
            if controller.is_requested():
                pin_name = controller.consumer()
                controller.release()
            controller.request(consumer=pin_name, type=type)

    def toggle_gpio_by_name(self, name:str, active_low=False, delay=0.2, pulse_width=0.2):
        """
        Toggles the gpio once. If active low then toggles 1,0,1. If active high then toggles 0,1,0.
        :param name: pin name
        :type name: Call get_active_gpios_list() to find a list of options.
        :param active_low: designates if the active level is low.
        :type active_low: bool
        :param delay: Time in seconds before 1st edge and after falling edge
        :type delay: float
        :param pulse_width: Pulse width of active level
        :type pulse_width: float
        :return: None
        :rtype: None
        """
        self.verify_gpio_name(name)
        chip_num, line_num = self.active_gpios[name]
        self.toggle_gpio(chip_num, line_num, active_low, delay, pulse_width)

    def toggle_gpio(self, chip_num=0, line_num=0, active_low=False, delay=0.2, pulse_width=0.2):
        """
        toggles GPIO denoted by gpio_num
        :param chip_num: number of the gpiochip
        :type chip_num: int
        :param line_num: number for the gpio
        :type line_num: int
        :param active_low: Boolean indicating if pin is active low.
        :type active_low: bool
        :param delay: Time in seconds before 1st edge and after falling edge
        :type delay: float
        :param pulse_width: Pulse width of active level
        :type pulse_width: float
        :return:
        :rtype:
        """
        controller_str = f'gpio{chip_num}_{line_num}_controller'
        controller = self.__getattribute__(controller_str)
        if not controller.is_requested():
            raise GpioAccessError(f'Line {line_num} has not been requested.')
        if controller.direction() == controller.DIRECTION_INPUT:
            raise GpioAccessError(f"Pin direction is set to {PinDirection.INPUT.name}. Cannot toggle output.")
        else:
            # Toggle for pulse_width seconds
            controller.set_value(int(active_low))
            time.sleep(delay)
            controller.set_value(int(not active_low))
            time.sleep(pulse_width)
            controller.set_value(int(active_low))
            time.sleep(delay)

    def verify_gpio_name(self, name: str):
        if name not in self.active_gpios.keys():
            raise GpioAccessError(f'Pin {name} is not an active gpio. Valid names are {self.get_active_gpios_list()}')

    def ping(self):
        print('Received ping from client')
        return 'Received'

    def release_lock(self):
        self.handler_lock.release()

    def set_rail_voltage(self, voltage):
        """
        AH3 ONLY: Sets the rail voltage to specified value in voltage
        :param voltage: float, can either be 1.2 or 1.8
        :return: None
        """
        # Enable rail updates
        self.write_i2c_reg(reg_addr=0x20, write_data=[1], dev_addr=0x60, bus_num=2, speed=0, repeat_start=True,
                           write_reg_data_size=1, ainc=False, address_stride=1, write_reg_addr_size=1)
        # Set rail voltage, 0x9 corresponds to 1.2v, 0x15 to 1.8v
        reg_value = 0x15 if voltage == 1.8 else 0x9
        self.write_i2c_reg(reg_addr=0x23, write_data=[reg_value], dev_addr=0x60, bus_num=2, speed=0, repeat_start=True,
                           write_reg_data_size=1, ainc=False, address_stride=1, write_reg_addr_size=1)

    def reset_dut(self, mode, active_low):
        """
        Set or toggle TP85 RESET on the interpose board
        :param mode: int, changes mode of reset:
            0: Set pin low
            1: Set pin high
            2: Toggle pin based on active_low value
        :param active_low: Boolean indicating if reset pin is active low.
        :return: None
        """
        low_cmd = 'echo 0 > /sys/class/gpio/gpio54/value'
        high_cmd = 'echo 1 > /sys/class/gpio/gpio54/value'
        if mode == 0:  # Set to low ie put dut in reset
            rst_cmd = low_cmd
        elif mode == 1:  # Set to high, take dut out of reset
            rst_cmd = high_cmd
        elif mode == 2:
            if active_low:
                rst_cmd = '%s;%s;%s' % (high_cmd, low_cmd, high_cmd)
            else:
                rst_cmd = '%s;%s;%s' % (low_cmd, high_cmd, low_cmd)

        process = subprocess.Popen(rst_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        console_output, error_output = process.communicate("")
        time.sleep(0.5)

    def reset_wrapper(self, mode, active_low):
        """
        Set or toggle TP93 GPIO_0 on the interpose board
        :param mode: int, changes mode of reset:
            0: Set pin low
            1: Set pin high
            2: Toggle pin based on active_low value
        :param active_low: Boolean indicating if reset pin is active low.
        :return: None
        """
        #todo: change this to use periphery
        low_cmd = 'echo 0 > /sys/class/gpio/gpio1008/value'
        high_cmd = 'echo 1 > /sys/class/gpio/gpio1008/value'
        if mode == 0:  # Set to low ie put dut in reset
            rst_cmd = low_cmd
        elif mode == 1:  # Set to high, take dut out of reset
            rst_cmd = high_cmd
        elif mode == 2:
            if active_low:
                rst_cmd = '%s;%s;%s' % (high_cmd, low_cmd, high_cmd)
            else:
                rst_cmd = '%s;%s;%s' % (low_cmd, high_cmd, low_cmd)

        process = subprocess.Popen(rst_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        console_output, error_output = process.communicate("")
        time.sleep(0.5)

    def i2c_check_ack(self, bus_num: int, speed: int, dev_addr: int) -> bool:
        """
        Addresses device on bus and returns True if the device ACK'd, False otherwise

        :param bus_num: Bus number
        :type bus_num: int
        :param speed: Bus speed code
        :type speed: int
        :param dev_addr: 7-bit device address
        :type dev_addr: int
        :return: If the device ACK'd
        :rtype: bool
        """
        i2c_controller = getattr(self, f'i2c_controller_{bus_num}')
        # Configure I2C controller
        i2c_controller._i2c_addr = dev_addr
        if i2c_controller._bus_speed != speed:  # Set speed (kHz)
            i2c_controller.set_speed(speed)
        # Create message with no data, just looking for ACK
        msg = i2c_controller._handle.Message(data=[], read=True, flags=i2c_controller._handle._I2C_M_NO_RD_ACK)
        # Driver sometimes errors when transferring directly after a previously timed out call. Attempt 2 times
        for attempt in range(2):
            try:
                i2c_controller._handle.transfer(dev_addr, [msg])
                return True
            except I2CError as err:
                if 'Connection timed out' in str(err):  # This is a failed AC
                    return False
        # Return False for any other I2C related error
        return False

    def i2c_device_write(self, bus_num, speed, dev_addr, write_data):
        if len(write_data) > self.MAX_I2C_SIZE:
            command = f"i2c_device_write(bus_num={bus_num}, speed={speed}, dev_addr={dev_addr}, write_data={write_data})"
            raise I2c_error(f"write_data ({len(write_data)} bytes) is larger than max I2C "
                            f"transfer size of {self.MAX_I2C_SIZE} bytes", command)
        i2c_controller = getattr(self, f'i2c_controller_{bus_num}')
        # Configure I2C controller
        i2c_controller._i2c_addr = dev_addr
        if i2c_controller._bus_speed != speed:  # Set speed (kHz)
            i2c_controller.set_speed(speed)
        write_msg = i2c_controller._handle.Message(write_data, read=False)  # Send address and write_data to bus
        try:
            i2c_controller._handle.transfer(dev_addr, [write_msg])  # Perform HW transaction
            return 0
        except Exception as i2c_err:  # Re-raise thrift exception
            command = f"i2c_device_write(bus_num={bus_num}, speed={speed}, dev_addr={dev_addr}, write_data={write_data})"
            raise I2c_error('I2c_error: ' + str(i2c_err), command)

    def i2c_device_read(self, bus_num, speed, dev_addr, byte_count):
        if byte_count > self.MAX_I2C_SIZE:
            command = f"i2c_device_read(bus_num={bus_num}, speed={speed}, dev_addr={dev_addr}, byte_count={byte_count})"
            raise I2c_error(f"byte_count ({byte_count} bytes) is larger than max I2C "
                            f"transfer size of {self.MAX_I2C_SIZE} bytes", command)
        i2c_controller = getattr(self, f'i2c_controller_{bus_num}')
        # Configure I2C controller
        i2c_controller._i2c_addr = dev_addr
        if i2c_controller._bus_speed != speed:  # Set speed (kHz)
            i2c_controller.set_speed(speed)
        read_bytes = [0] * byte_count  # Placeholder buffer to indicate number of bytes to read
        read_msg = [i2c_controller._handle.Message(read_bytes, read=True)]  # bytes_in will be populated with read data
        try:
            i2c_controller._handle.transfer(dev_addr, read_msg)  # Perform HW transaction
            return read_msg[0].data
        except Exception as i2c_err:  # Re-raise thrift exception
            command = f"i2c_device_read(bus_num={bus_num}, speed={speed}, dev_addr={dev_addr}, byte_count={byte_count})"
            raise I2c_error('I2c_error: ' + str(i2c_err), command)

    def write_i2c_reg(self, reg_addr: int, write_data: List[int], dev_addr: int, bus_num: int, speed: int, repeat_start: bool,
                      write_reg_addr_size: int, ainc: bool, address_stride: int, write_reg_data_size: int):
        i2c_controller = getattr(self, 'i2c_controller_' + str(bus_num))  # Grab controller for given bus
        # Configure I2C controller
        i2c_controller._i2c_addr = dev_addr
        i2c_controller._repeated_start = repeat_start
        i2c_controller._map_size = write_reg_addr_size  # Set address size
        if i2c_controller._bus_speed != speed:
            i2c_controller.set_speed(speed)
        try:  # Attempt transaction
            kwargs = {}
            if self.hostname.startswith('ah2'):  # Legacy AH2 I2C controller has extra param
                kwargs['auto_incr'] = 0
            # Chunk up I2C transactions
            max_xfer_size = self.MAX_I2C_SIZE - self.MAX_I2C_SIZE % write_reg_data_size  # Word aligned chunk size
            for chunk_base in range(0, len(write_data), max_xfer_size):  # chunk_base is number of bytes written
                # Get read address with offset
                chunk_addr = reg_addr + (chunk_base // write_reg_data_size) * address_stride if ainc else reg_addr
                if chunk_addr >= 2**(write_reg_addr_size << 3):  # Address out of range
                    raise ValueError(f"Address {chunk_addr} is larger than given address size "
                                     f"({write_reg_addr_size} byte{'s' if write_reg_addr_size > 1 else ''})")
                # Perform HW transaction
                num_bytes = min(len(write_data) - chunk_base, max_xfer_size)
                i2c_controller.write_block(chunk_addr, write_data[chunk_base:chunk_base+num_bytes], **kwargs)
                time.sleep(0.001)
            return 0
        except Exception as i2c_err:
            # Relay exact function call back up to the user
            command = f"write_i2c_reg(bus_num={bus_num}, speed={speed}, repeat_start={repeat_start}," \
                      f" dev_addr={dev_addr}, reg_addr={reg_addr}, reg_size={write_reg_addr_size}, write_data={write_data}"
            raise I2c_error('I2c_error: ' + str(i2c_err), command)

    def read_i2c_reg(self, reg_addr: int, byte_count: int, dev_addr: int, bus_num: int, speed: int, repeat_start: bool,
                     read_reg_addr_size: int, ainc: bool, address_stride: int, read_reg_data_size: int) -> List[int]:
        i2c_controller = getattr(self, 'i2c_controller_%d' % bus_num)  # Grab controller for given bus
        # Configure I2C controller
        i2c_controller._i2c_addr = dev_addr
        i2c_controller._repeated_start = repeat_start
        i2c_controller._map_size = read_reg_addr_size  # Set address size
        if i2c_controller._bus_speed != speed:
            i2c_controller.set_speed(speed)
        try:  # Attempt transaction
            kwargs = {}
            if self.hostname.startswith('ah2'):  # Legacy AH2 I2C controller has extra param
                kwargs['auto_incr'] = 0
            bytes_in = []
            # Chunk up I2C transactions
            max_xfer_size = self.MAX_I2C_SIZE - self.MAX_I2C_SIZE % read_reg_data_size
            for chunk_base in range(0, byte_count, max_xfer_size):  # chunk_base is number of bytes read
                # Get read address with offset
                chunk_addr = reg_addr + (chunk_base // read_reg_data_size) * address_stride if ainc else reg_addr
                if chunk_addr >= 2**(read_reg_addr_size << 3):  # Address out of range
                    raise ValueError(f"Address {chunk_addr} is larger than given address size "
                                     f"({read_reg_addr_size} byte{'s' if read_reg_addr_size > 1 else ''})")
                # Perform HW transaction
                bytes_in.extend(i2c_controller.read_block(chunk_addr, min(byte_count - chunk_base, max_xfer_size), **kwargs))
                time.sleep(0.001)
            return bytes_in  # List of bytes read
        except Exception as i2c_err:
            # Relay exact function call back up to the user
            command = f"read_i2c_reg(bus_num={bus_num}, speed={speed}, repeat_start={repeat_start}," \
                      f" dev_addr={dev_addr}, reg_addr={reg_addr}, reg_size={read_reg_addr_size}, byte_count={byte_count}, " \
                      f"ainc={ainc}, address_stride={address_stride}, data_size={read_reg_data_size}"
            raise I2c_error('I2c_error: ' + str(i2c_err), command)

    def i2c_scan(self, bus_num, speed=None):
        if speed:
            self.set_i2c_bus_speed(bus_num, speed)
        process = subprocess.Popen('xi2c -b %d -q' % bus_num, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        console_output, error_output = process.communicate("")
        return console_output.decode('utf-8').strip()

    def set_i2c_bus_speed(self, bus_num, speed):
        process = subprocess.Popen('xi2c -b %d -s %d' % (bus_num, speed), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        console_output, error_output = process.communicate("")

    def mmap_add(self, base_addr, size, word_size):
        self.mmap_manager.add_mmap(base_addr, size, word_size)

    def mmap_read(self, base_addr, offset, num_bytes):
        return self.mmap_manager.read(base_addr, offset, num_bytes)

    def mmap_write(self, base_addr, offset, bytes_out):
        self.mmap_manager.write(base_addr, offset, bytes_out)

    def memio_write(self, addr, data):
        self.handler_lock.acquire()
        self.spmi.ctrl.write(addr, data)
        self.handler_lock.release()
        return 0

    def memio_read(self, addr):
        self.handler_lock.acquire()
        val = self.spmi.ctrl.read(addr)
        self.handler_lock.release()
        return val

    def spi_fd(self, bytes_out, bus_num, chip_select, speed, keep_cs, clk_mode):
        # Get spi driver
        spi_dev_name = 'spi_%d_%d' % (bus_num, chip_select)
        if not hasattr(self, spi_dev_name):   # Create controller
            spi_driver = SPI(bus_num, chip_select, spi_clk_mode=clk_mode)
            setattr(self, spi_dev_name, spi_driver)
        else:
            spi_driver = getattr(self, spi_dev_name)
        # Set speed and clock mode
        spi_driver._handle.max_speed = speed
        spi_driver._handle.mode = clk_mode  # Can be 0, 1, 2, or 3
        # Issue full-duplex transfer
        bytes_in = spi_driver.transfer(bytes_out, keep_cs)
        return bytes_in

    def spi_apb_block_read(self, bus_num, chip_select, speed, address, addr_size=4, data_size=4, length=1):
        spi_dev_name = 'crus_spi%d.%d' % (bus_num, chip_select)
        if not hasattr(self, spi_dev_name):   # Create controller
            spi_driver = SPI(bus_num, chip_select, speed=speed, apb_mode=True, verbose=False, addr_size=addr_size, word_size=data_size)
            setattr(self, spi_dev_name, spi_driver)
        else:
            spi_driver = getattr(self, spi_dev_name)
            if spi_driver._addr_size != addr_size:
                spi_driver._addr_size = addr_size
            if spi_driver._word_size != data_size:
                spi_driver._word_size = data_size
        # Issue block read
        bytes_read = spi_driver.read_block(address, length)
        return bytes_read

    def spi_apb_block_write(self, bus_num, chip_select, speed, address, values, addr_size=4, data_size=4):
        # Get spi driver
        spi_dev_name = 'crus_spi%d.%d' % (bus_num, chip_select)
        if not hasattr(self, spi_dev_name):   # Create controller
            spi_driver = SPI(bus_num, chip_select, speed=speed, apb_mode=True, verbose=False, addr_size=addr_size, word_size=data_size)
            setattr(self, spi_dev_name, spi_driver)
        else:
            spi_driver = getattr(self, spi_dev_name)
            if spi_driver._addr_size != addr_size:
                spi_driver._addr_size = addr_size
            if spi_driver._word_size != data_size:
                spi_driver._word_size = data_size
        # Issue block read
        spi_driver.write_block(address, values)

    def enable_spmi(self, base_addr):
        if self.spmi:
            self.spmi.close()
        self.spmi = SPMI(base_addr)  # Create SPMI mmap for client requests
        self.spmi.ctrl.write(self.spmi.REG_INT_MASK, 0x01)  # enable interrupts
        self.spmi.ctrl.write(self.spmi.REG_INT_STATUS, 0x03)  # Clear status bits

        self.file_lock = threading.Lock()

        self.int_queue = Queue()

        # Flag for killing the handler thread
        self.kill_thread = True
        self.thread_on = False

        return 0

    def embed_test_station(self, serialized_station, env_vars):
        """
        Embeds a given Cl Test Station as attribute of server, for use with RCS interrupts or Bursts.

        :param serialized_station: string containing JSON compatible serialized representation of the TestStation
        :param env_vars: dictionary holding all environmental variables at point of the thrift function call;
          these are converted to be linux accessible (paths) and then applied to the server
        :return:
        """
        try:
            # Set environment variables
            env_dict = ts_loads(env_vars)
            if 'PROJECT_ROOT' in env_dict:  # Apply this first in case the order is not preserved
                os.environ['PROJECT_ROOT'] = os.path.expandvars(env_dict.pop('PROJECT_ROOT'))
            for name, value in env_dict.items():  # Transfer rest of env variables
                os.environ[name] = os.path.expandvars(value)
                if '/' in os.environ[name]:  # This is a path, expand sys.path to enable imports
                    sys.path.append(os.environ[name])
            # Load json and insert handler into controller config. Construct station
            serialized_station_expanded = os.path.expandvars(serialized_station)
            station_config: Dict[str, Any] = ts_loads(serialized_station_expanded)
            ts_class_type: str = station_config.pop('test_station')
            station_id = station_config.pop('id')
            pkg_path = ts_class_type.split(".")
            class_name = pkg_path.pop()
            ts_cls = getattr(import_module(".".join(pkg_path)), class_name)

            # Look for host controller definitions, change them to the embedded version, and set their client to handler
            supported_controllers = ['AudioHubController', "ZdcController"]
            for key in station_config.keys():
                if type(station_config[key]) is dict and 'class_type' in station_config[key]:  # ts_obj definition
                    class_name = station_config[key]['class_type'].split('.')[-1]  # get class name (last in dot path)
                    if class_name in supported_controllers:  # Change class type to embedded and set client
                        station_config[key]['class_type'] = \
                            station_config[key]['class_type'].replace(class_name, 'Embedded'+class_name)
                        station_config[key]['client'] = self

            # Add StreamHandler to cl logger
            self.log_buffer = StringIO()
            logger = get_logger()
            shandler = logging.StreamHandler(self.log_buffer)
            shandler.setLevel(logging.DEBUG)
            shandler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)-8s - %(message)s'))
            logger.addHandler(shandler)
            self.log = TsLoggingAdapter(logger, 'Burst')

            # Create test station from config dict
            test_station: TestStation = ts_cls(station_config, logger=self.log)
            err_cnt, warning_count = test_station.construct_system()
            self.test_station = test_station
            dbg_dict = {}
            self.test_station.generate_id(dbg_dict=dbg_dict)
            ts_id = self.test_station.station_id
            if ts_id != station_id:
                if err_cnt > 0:  # Return console log
                    self.log_buffer.seek(0)
                    log = self.log_buffer.read()
                    self.log_buffer.seek(0)
                    self.log_buffer.truncate()
                    return json.dumps(log)  # String
                else:  # Return debug dictionary
                    return json.dumps(dbg_dict)
            return json.dumps(ts_id)  # Int
        except:
            return json.dumps(traceback.format_exc())

    def ping_test_station(self):
        """
        Check to see if there is a CL Test Station already embedded into the server.
        :return: string containing result. 'success' if there is a test_station, 'failure' otherwise
        """
        if self.test_station is not None:
            # todo: Maybe create ID for test station and return that
            return str(self.test_station.station_id)
        else:
            return 'failure'

    def reload_modules(self, modules):
        for mod_name in modules:
            try:
                module = import_module(mod_name)
                reload(module)
            except:
                print(traceback.format_exc())

    def interrupt_handler(self, spmi_api, lock, file_lock, int_queue, client_req, req_int_id=-1):
        """
        Internal method for handling interrupts.
        Reads input device stream for SPMI_IRQ edge, then reads master write data. Executes interrupt handlers base on
          that master write value and the given int_map
        :param spmi_api: mmap api to use
        :param client_req: flag to indicate that the client requested interrupt handling and wants a return value
        :param req_int_id: ID of interrupt the client wants polled and serviced
        """
        if not req_int_id == -1 and req_int_id not in self.int_map.keys():
            raise ValueError("Invalid requested interrupt ID: " + req_int_id)

        infile_path = "/dev/input/int-keys"
        FORMAT = 'llHHI'
        EVENT_SIZE = struct.calcsize(FORMAT)

        in_file_raw = io.FileIO(infile_path, 'r')
        in_file = io.BufferedReader(in_file_raw)
        fd = in_file.fileno()
        flag = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, flag | os.O_NONBLOCK)
        flag = fcntl.fcntl(fd, fcntl.F_GETFL)

        if self.verbose:
            self.prnt_buf = PrintBuffer()
            sys.stdout = self.prnt_buf

        # Indefinite loop for background polling

        self.thread_on = True
        while 1:
            if client_req:
                # Read IO Stream (non-blocking),  break when key code 96 is read
                with file_lock:
                    while not self.kill_thread:
                        event = in_file.read1(EVENT_SIZE)
                        if event:
                            (tv_sec, tv_usec, type, code, value) = struct.unpack(FORMAT, event)
                            if code == 0x108 and value == 0:
                                with lock:
                                    int_id = spmi_api.ctrl.read(0x400)
                                    spmi_api.ctrl.write(spmi_api.REG_INT_STATUS, 0x01)
                                break
            else:
                while not self.kill_thread:
                    with file_lock:
                        event = in_file.read1(EVENT_SIZE)
                    if event:
                        (tv_sec, tv_usec, type, code, value) = struct.unpack(FORMAT, event)
                        if code == 0x108 and value == 0:
                            with lock:
                                int_id = spmi_api.ctrl.read(0x400)
                                spmi_api.ctrl.write(spmi_api.REG_INT_STATUS, 0x01)
                            break

            if self.kill_thread:
                in_file.close()
                return {}

            """Handling interrupts based on ID"""
            # Get int handler function
            int_type = self.int_map[int_id].lower()
            method_name = int_type + '_handler'
            self.result = EmbeddedResults(int_type.upper(), int_id)
            if self.legacy:
                self.handler_test.result = self.result
                self.handler_test.int_id = int_id
                int_handler = getattr(self.handler_test, method_name)
                # Call interrupt handler method based on ID
            else:
                int_handler = getattr(self, method_name)
            result_dict = {}
            try:
                if self.legacy:
                    int_handler()
                else:
                    int_handler(self)
            except:
                trace = traceback.format_exc()
                result_dict.update({"EXCEPTION": trace})
            result_dict.update(self.result.results)
            if self.verbose:
                result_dict['CONSOLE_LOG'] = sys.stdout.read()
            result_str = ts_dumps(result_dict)
            int_queue.put(result_str, block=False)


    def handle_interrupt(self, int_id):
        # Get dictionary from handler
        return self.interrupt_handler(self.spmi, self.handler_lock, self.file_lock, self.int_queue, True, int_id)

    def empty_server_queue(self):
        """
        Empties the interrupt result queue and sends all entries to the client
        :return: list of strings containing JSON dictionaries of interrupt data
        """
        strings = []
        while not self.int_queue.empty():
            strings.append(self.int_queue.get(block=False))
        #print(strings)
        return strings

    def start_embedded_interrupt_handling(self, int_map, verbose, functions):
        """
        Starts the interrupt handling thread, which polls for SPMI interrupts and services them with defined handlers.
        """

        self.int_dict = int_map

        if verbose:
            self.verbose = True

        self.int_map = int_map

        print("Starting background handler...")
        """INLINE HANDLER PROCESSING"""
        custom_functions = []
        self.legacy = (functions == 'legacy')
        if self.legacy:
            # Try Loading/Instantiating - report traceback to client if exception occurs
            import cl_test_station.host_controllers.audiohub_controller.interrupt_handler_embedded as int_module
            reload(int_module)
            self.handler_test = int_module.InterruptHandler(self.test_station)
        else:  # Here we will create functions and set aliases/static variables
            for id, group_name in self.int_map.items():  # Create basic functions
                setattr(self, group_name.lower() + '_handler', lambda self: None)

            function_map = ts_loads(functions, self.test_station)
            for func_name, config in function_map.items():
                # Add all test station objects
                for name, path in config['aliases'].items():
                    setattr(self, name, self.test_station.resolve_path(path))
                # Add variables
                for name, value in config['static_variables'].items():
                    if value is not None:
                        self.__dict__.update({name: value})
                # Compile code and create lambda
                block = compile(config['code'], func_name, 'exec')
                setattr(self, func_name, lambda self, block=block: exec(block))
                #ah_thrift_handler.__setattr__(func_name, func)
                custom_functions.append(func_name)

        self.kill_thread = False

        # Instantiate Daemon thread for constantly checking for interrupts and requesting to service them
        int_thread = threading.Thread(target=self.interrupt_handler,
                                      args=(self.spmi, self.handler_lock, self.file_lock, self.int_queue, False),
                                      daemon=True, name='handler')
        int_thread.start()

        timeout = 5
        start = time.time()
        while time.time() - start < 30:
            if self.thread_on:
                return True
        return False

    def print_from_buffer(self):
        if self.verbose:
            return self.prnt_buf.read()
        return ''

    def stop_embedded_interrupt_handling(self):
        """
        Kills interrupt handling thread and restores stdout
        :return: True if thread successfully killed, otherwise False
        """
        if self.verbose:
            sys.stdout = sys.__stdout__
            self.verbose = False
        self.kill_thread = True
        self.legacy = None
        if hasattr(self, 'int_map'):
            for group in self.int_map.values():
                self.__setattr__(group+'_handler', None)
        count = 0
        while count < 3:
            found = False
            for th in threading.enumerate():
                if th.getName() == 'handler':
                    found = True
            if not found:
                self.thread_on = False
                return True
            sleep(1e-2)
        return False

    # FUNCTIONS FOR SPMI API
    def spmi_device_initialize(self, device_type, device_id, f_tclk, ddba_addr, inten, enr):
        return self.spmi.device_initialize(device_type, device_id, f_tclk, ddba_addr, inten, enr)

    def spmi_device_disable(self):
        return self.spmi.device_disable()

    def spmi_dump_registers(self):
        return self.spmi.dump_registers()

    def spmi_poll_command_sent_flag(self, clear_all_flags=True):
        return self.spmi.poll_command_sent_flag(clear_all_flags)

    def spmi_master_write(self, master_id, address, data, use_a_bit=False, use_sr_bit=False):
        return self.spmi.master_write(master_id, address, data, use_a_bit, use_sr_bit)

    def spmi_master_read(self, master_id, address, size, use_a_bit=False, use_sr_bit=False):
        return self.spmi.master_read(master_id, address, size, use_a_bit, use_sr_bit)

    def spmi_extended_register_write(self, slave_id, address, data, priority):
        self.handler_lock.acquire()
        val = self.spmi.extended_register_write(slave_id, address, data, priority)
        self.handler_lock.release()
        return val

    def spmi_set_master_req_prescaler(self, rate):
        self.handler_lock.acquire()
        val = self.spmi.set_master_req_prescaler(rate)
        self.handler_lock.release()
        return val

    def spmi_extended_register_read(self, slave_id, address, size, priority):
        self.handler_lock.acquire()
        read_data = self.spmi.extended_register_read(slave_id, address, size, priority)
        self.handler_lock.release()
        return read_data

    def spmi_extended_register_write_long(self, slave_id, address, data, priority):
        self.handler_lock.acquire()
        val = self.spmi.extended_register_write_long(slave_id, address, data, priority)
        self.handler_lock.release()
        return val

    def spmi_extended_register_read_long(self, slave_id, address, size, priority):
        self.handler_lock.acquire()
        val = self.spmi.extended_register_read_long(slave_id, address, size, priority)
        self.handler_lock.release()
        return val

    def spmi_set_slave_addr(self, addr):
        return self.spmi.set_slave_addr(addr)

    def spmi_set_master_addr(self, addr):
        return self.spmi.set_master_addr(addr)

    def spmi_set_ip_version(self, version):
        return self.spmi.set_ip_version(version)

    def spmi_register_write(self, slave_id, address, data, priority):
        self.handler_lock.acquire()
        val = self.spmi.register_write(slave_id, address, data, priority)
        self.handler_lock.release()
        return val

    def spmi_register_read(self, slave_id, address, priority):
        self.handler_lock.acquire()
        val = self.spmi.register_read(slave_id, address, priority)
        self.handler_lock.release()
        return val

    def spmi_block_read(self, peripheral_id, start_addr, byte_count, addressibility, priority):
        """
        Performs multiple SPMI transactions to read bytes from successive addresses.

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param start_addr: Start address if block read
        :type start_addr: int
        :param byte_count: Number of bytes to read
        :type byte_count: int
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: List of Bytes rec'd from SDATA
        :rtype: list
        """
        self.handler_lock.acquire()
        bytes_in = []
        addr = start_addr
        cutoff = 0x100 - int(16 / addressibility)  # If a full 16 byte ERR will overflow, need to use ERRL
        while byte_count:
            if addr <= cutoff:  # Use ERR
                bytes_to_read = min(byte_count, 16)
                bytes_in.extend(self.spmi.extended_register_read(peripheral_id, addr, bytes_to_read, priority))
            else:  # Use ERRL
                bytes_to_read = min(byte_count, 8)
                bytes_in.extend(self.spmi.extended_register_read_long(peripheral_id, addr, bytes_to_read, priority))
            addr += int(bytes_to_read / addressibility)  # Increment address accounting for addressibility
            byte_count -= bytes_to_read  # Decrement remaining bytes to read
        self.handler_lock.release()
        return bytes_in

    def spmi_block_write(self, peripheral_id, start_addr, data, addressibility, priority):
        """
        Performs multiple SPMI transactions to write bytes from successive addresses.

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param start_addr: Start address if block read
        :type start_addr: int
        :param data: List of bytes to write
        :type data: list
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: None
        """
        self.handler_lock.acquire()
        addr = start_addr
        cutoff = 0x100 - int(16 / addressibility)  # If a full 16 byte ERW will overflow, need to use ERWL
        byte_index = 0  # Pointer to current byte to write
        while byte_index < len(data):  # Loop while the pointer hasn't reached the end of the list
            if addr <= cutoff:  # Use ERW
                max_transfer_size = 16
                spmi_write_func = self.spmi.extended_register_write
            else:  # Use ERWL
                max_transfer_size = 8
                spmi_write_func = self.spmi.extended_register_write_long
            bytes_to_write = min(len(data) - byte_index, max_transfer_size)  # Either max size or last set of data bytes
            chunk = data[byte_index:byte_index + bytes_to_write]  # Grab bytes_to_write bytes starting at byte_index
            spmi_write_func(peripheral_id, addr, chunk, priority)  # Perform write transaction
            addr += int(bytes_to_write / addressibility)  # Increment address accounting for addressibility
            byte_index += bytes_to_write  # Move byte_index up
        self.handler_lock.release()

    def spmi_chain_read(self, peripheral_id, address, num_reads, read_size, addressibility, priority):
        """
        Performs successive reads on the same address and returns concatenated list of bytes

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param address: Address of chain read
        :type address: int
        :param num_reads: Number of separate SPMI transactions to perform
        :type num_reads: int
        :param read_size: Number of bytes to read per SPMI transaction
        :type read_size: int
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: List of bytes
        :rtype: list
        """
        self.handler_lock.acquire()
        bytes_in = []
        cutoff = 0x100 - int(read_size / addressibility)
        spmi_func = self.spmi.extended_register_read if address <= cutoff else self.spmi.extended_register_read_long
        for i in range(num_reads):
            bytes_in.extend(spmi_func(peripheral_id, address, read_size, priority))
        self.handler_lock.release()
        return bytes_in

    def spmi_chain_write(self, peripheral_id, address, data, write_size, addressibility, priority):
        """
        Performs successive writes to the same address

        :param peripheral_id: ID of SPMI peripheral to read from. 0-15
        :type peripheral_id: int
        :param address: Address of chain read
        :type address: int
        :param data: List of bytes to write
        :type data: list
        :param write_size: Number of bytes to read per SPMI transaction
        :type write_size: int
        :param addressibility: number of bytes per memory location (Address)
        :type addressibility: int
        :param priority: Arbitration level
        :type priority: int
        :return: None
        """
        self.handler_lock.acquire()
        cutoff = 0x100 - int(write_size / addressibility)
        spmi_func = self.spmi.extended_register_write if address <= cutoff else self.spmi.extended_register_write_long
        for chunk in [data[i:i+write_size] for i in range(0, len(data), write_size)]:
            spmi_func(peripheral_id, address, chunk, priority)
        self.handler_lock.release()

    def burst(self, lines, vars, aliases):
        """
        For use with cl_test_station. Takes in list of lines, compiles and executes them as python code.
        :param lines: List of strings representing lines of python code. Uses 4 spaces for indentation
        :param vars: dictionary containing variable information that the lines of code needs to execute.
          Updates the server with the values in this dictionary
        :param aliases: dictionary of TestStationObject references used by lines. updates server with these aliases by
         finding them in its embedded test_station
        :return: Dictionary containing updated variables if changed, exception traceback and console log if applicable
        """
        try:
            ret_dict = {}
            var_dict = ts_loads(vars, self.test_station)
            alias_dict = ts_loads(aliases, self.test_station)

            # Re-route print statements to custom stream
            old = sys.stdout
            #out = PrintBuffer()
            # sys.stdout = out

            # Clear log buffer
            self.log_buffer.seek(0)
            self.log_buffer.truncate()
            sys.stdout = self.log_buffer

            try:
                # Add necessary variables
                for name, value in var_dict.items():
                    if value is not None:
                        self.__dict__.update({name: value})

                # Add all test station objects
                for name, tso in alias_dict.items():
                    self.__setattr__(name, tso)

                # Form the code block, compile it into a code object, and execute it in 'exec' mode
                block_string = ''
                for line in lines:
                    block_string += line + '\n'
                _thrift_handler = self
                block_code = compile(block_string, "burst_block", "exec")
                exec(block_code)

                # Update any variables that may have changed
                for var in var_dict.keys():
                    if var in self.__dict__.keys() and self.__dict__[var] is not None:
                        ret_dict[var] = self.__dict__[var]
            except:
                trace = traceback.format_exc()
                ret_dict.update({"EXCEPTION": trace})

            #out_contents = out.read()
            self.log_buffer.seek(0)
            out_contents = self.log_buffer.read()
            sys.stdout = old
            ret_dict.update({'CONSOLE_LOG': out_contents})
            return ts_dumps(ret_dict)
        except:
            return ts_dumps({'EXCEPTION': traceback.format_exc(), 'CONSOLE_LOG': ''})

    def unpack_byte_array(self, bytes, data_size, length):
        """
        Unpacks list of bytes into a list of words based on data_size and length
        :param bytes: list of bytes
        :param data_size: bytes in a word
        :param length: number of words
        :return: list of words
        """
        data_list = []
        for i in range(0, length * data_size, data_size):
            data = 0
            for j in range(0, data_size):
                data += (bytes[i+j] << j*8)
            data_list.append(data)
        return data_list

    def pack_byte_array(self, data, data_size):
        """
        Packs list of words into SPMI compatible list of bytes.
        List is ordered as: LSB to MSB of each word.
        :param data: List of words to pack
        :param data_size: size in bytes of each word
        :return: list of bytes
        """
        data_list = []
        for i in range(0, len(data)):
            word = data[i]
            for j in range(0, data_size):
                data_list.append((word >> j*8) & 0xFF)
        return data_list

    def poll_for_int(self):
        """
        Busy waits for interrupt status in SPMI core to be set, then returns Master write data at address 0x400
        :return: int, master write byte
        """
        return self.spmi.poll_for_int()

    """ MAHONEY SPECIFIC FUNCTIONALITY """
    # SPMI ASYNC Pointer constants
    PTR_CTRL = 0x0
    PTR0_BASE = 0x04
    PTR1_BASE = 0x08
    PTR2_BASE = 0x0C
    PTR3_BASE = 0x10
    PTR_BASE = [PTR0_BASE, PTR1_BASE, PTR2_BASE, PTR3_BASE]

    PTR0_DATA = 0x20
    PTR1_DATA = 0x30
    PTR2_DATA = 0x40
    PTR3_DATA = 0x50
    PTR_DATA = [PTR0_DATA, PTR1_DATA, PTR2_DATA, PTR3_DATA]

    PTR0_EN = 0x01
    PTR1_EN = 0x02
    PTR2_EN = 0x04
    PTR3_EN = 0x08
    PTR_EN = [PTR0_EN, PTR1_EN, PTR2_EN, PTR3_EN]

    def spmi_24bit_read(self, slave_id, address, word_count, priority, p_inx):
        """
        Uses Mahoney's 24bit pointers and data buffer to read word_count words from address
        :return: list of words
        """
        self.handler_lock.acquire()
        # Convert address to byte array
        address_list = []
        for i in range(0, 4):
            address_list.append((address >> 8 * i) & 0xFF)
        # Set pointer0 to read addr
        self.spmi.extended_register_write(slave_id, self.PTR_BASE[p_inx], address_list, priority)
        # reset pointer0
        self.spmi.register_write(slave_id, self.PTR_CTRL, self.PTR_EN[p_inx], priority)
        data_list = []  # add to data_list in groups of 4 words
        for i in range(0, int(word_count / 2)):
            pointer_data = self.spmi.extended_register_read(slave_id, self.PTR_DATA[p_inx], 8, priority)
            data_list.extend(self.unpack_byte_array(pointer_data, 4, 2))
        if not word_count % 2 == 0:  # remaining words
            pointer_data = self.spmi.extended_register_read(slave_id, self.PTR_DATA[p_inx], 4, priority)
            data_list.extend(self.unpack_byte_array(pointer_data, 4, 1))
        self.handler_lock.release()
        return data_list

    def spmi_24bit_write(self, slave_id, address, data, priority, p_inx):
        """
        Uses Mahoney's 24bit pointers and data buffer to write word_count words to address
        :return: 0
        """
        self.handler_lock.acquire()
        # Convert address to byte array
        address_list = []
        for i in range(0, 4):
            address_list.append((address >> 8 * i) & 0xFF)
        # Set pointer0 to write address
        self.spmi.extended_register_write(slave_id, self.PTR_BASE[p_inx], address_list, priority)
        # Reset the pointer
        self.spmi.register_write(slave_id, self.PTR_CTRL, self.PTR_EN[p_inx], priority)
        # Split up into chunks of 16 bytes (4 words)
        for i in range(0, (int(len(data) / 2)) * 2, 2):
            # Convert words to byte array
            pointer_data = self.pack_byte_array(data[i:i + 2], 4)
            self.spmi.extended_register_write(slave_id, self.PTR_DATA[p_inx], pointer_data, priority)
        if not len(data) % 2 == 0:  # Last few words
            pointer_data = self.pack_byte_array([data[len(data) - 1]], 4)
            self.spmi.extended_register_write(slave_id, self.PTR_DATA[p_inx], pointer_data, priority)
        self.handler_lock.release()
        return 0

    # # ----- HCC Functions ----- # #

    def hcc_queue_packets(self, packets, cs_delays):
        """
        Queues packets using the HCC Driver. len(packets) needs to equal len(cs_delays)

        :param packets: List of lists of bytes. Each list of bytes is a separate HCC Packet
        :type packets: list
        :param cs_delays: List of ints. Contains CS delay for packet at matching index.
        :type cs_delays: list
        :return: None
        """
        if not self.hcc_enabled:
            raise HccDriverError("Hcc is not enabled. Call enable_hcc() first.")
        for packet, cs_delay in zip(packets, cs_delays):
            self.hcc_driver.queue_xfer(packet, cs_delay=cs_delay)


    def hcc_send_packet(self, packet, cs_delay):
        """
        Sends packet onto the physical bus, returns bytes received from HCC Device.

        :param packet: List of bytes to send onto the bus.
        :type packet: list
        :param cs_delay: Time in usec the CS line is deasserted todo: before/after the packet is finished transmitting
        :type cs_delay: int
        :return: List of ints representing bytes received from the HCC Device
        :rtype: list
        """
        if not self.hcc_enabled:
            raise HccDriverError("Hcc is not enabled. Call enable_hcc() first.")
        self.hcc_driver.stash_queue()  # Stash any queued packets
        self.hcc_driver.queue_xfer(packet, cs_delay=cs_delay)  # Queue single packet
        self.hcc_driver.sync() # Send packet onto bus
        bytes_in = self.hcc_driver.pop()  # Grab rx buffer
        self.hcc_driver.stash_pop()  # Restore stashed queue
        return bytes_in


    def hcc_execute_packet_queue(self):
        """
        Issues all queued packets and returns list of lists of ints (list of return packets from HCC Device)

        :return: List of list of integers (Bytes), packets received from HCC Device
        :rtype: list
        """
        if not self.hcc_enabled:
            raise HccDriverError("Hcc is not enabled. Call enable_hcc() first.")
        packets_in = []
        self.hcc_driver.sync()
        while not self.hcc_driver.queue_empty:
            packets_in.append(self.hcc_driver.pop())
        return packets_in

    def enable_hcc(self, bus_num, chip_select):
        # Select HCC Controller
        spi_mux_value = self.read_i2c_reg(**SPI_MUX_KWARGS, byte_count=1, read_reg_addr_size=1, read_reg_data_size=1)
        spi_mux_value[0] |= 1  # Set bit 0
        self.write_i2c_reg(**SPI_MUX_KWARGS, write_data=spi_mux_value, write_reg_data_size=1, write_reg_addr_size=1)
        self.hcc_enabled = True
        # Create HCC Driver instance
        hcc_device = '/dev/hcc-spi-%d.%d' % (bus_num, chip_select + 1)  # Offset chip_select since 0 is XMOS
        self.hcc_driver = HCCInterface(hcc_device)

    def disable_hcc(self):
        # Select HCC Controller
        spi_mux_value = self.read_i2c_reg(**SPI_MUX_KWARGS, byte_count=1, read_reg_addr_size=1, read_reg_data_size=1)
        spi_mux_value[0] &= ~0x01  # Clear bit 0
        self.write_i2c_reg(**SPI_MUX_KWARGS, write_data=spi_mux_value, write_reg_data_size=1, write_reg_addr_size=1)
        self.hcc_enabled = False
        self.hcc_driver = None

    def hcc_set_speed(self, speed):
        """
        Sets bus speed of HCC Driver. Supported speeds are 24MHz, 12MHz, 6MHz, 3MHz. Can also use Porter.

        :param speed: 0=24MHz, 1=12MHz, 2=6MHz, 3=3MHz, 4=PORTER
        :type speed: int
        :return: None
        """
        spi_mux_value = self.read_i2c_reg(**SPI_MUX_KWARGS, byte_count=1, read_reg_addr_size=1, read_reg_data_size=1)
        spi_mux_value[0] &= ~0x70  # Clear speed field (bits 6:4)
        spi_mux_value[0] |= speed << 4  # Set speed field
        self.write_i2c_reg(**SPI_MUX_KWARGS, write_data=spi_mux_value, write_reg_data_size=1, write_reg_addr_size=1)

    def hcc_set_setup_delay(self, delay: int):
        """
        Configures the controller setup delay for transactions.

        :param delay: Setup delay in usec
        :type delay: int
        :return: None
        :rtype: None
        """
        if not self.hcc_enabled:
            raise HccDriverError("Hcc is not enabled. Call enable_hcc() first.")
        self.hcc_driver.set_setup_delay(delay)

    def hcc_set_bit_order(self, order: int):
        """
        Sets bit order of Bytes sent out over MOSI

        :param order: Bit order, 0 = MSB first, 1 = LSB first
        :type order: int
        :return: None
        :rtype: None
        """
        if not self.hcc_enabled:
            raise HccDriverError("Hcc is not enabled. Call enable_hcc() first.")
        if order not in [0, 1]:
            raise HccDriverError(f"Invalid order given ({order}), can either be 0 (MSB first) or 1 (LSB first)")
        self.hcc_driver.set_bit_order(order)

    def hcc_set_clk_mode(self, mode: int):
        """
        Sets hcc-spi clock mode.

        :param mode: SPI mode. Can be 0, 1, 2, 3. Denotes value of CPOL and CPHA:

        ======== ==== ==== ========== ======================
        clk_mode CPOL CPHA Idle Clock Sample edge/Shift edge
        -------- ---- ---- ---------- ----------------------
        0        0    0    logic low  rising/falling
        1        0    1    logic low  falling/rising
        2        1    0    logic high rising/falling
        3        1    1    logic high falling/rising
        ======== ==== ==== ========== ======================

        :type mode: int
        :return: None
        :rtype: None
        """
        if not self.hcc_enabled:
            raise HccDriverError("Hcc is not enabled. Call enable_hcc() first.")
        if mode not in range(0, 4):
            raise HccDriverError(f"Invalid clock mode given ({mode}), can be 0, 1, 2, 3")
        self.hcc_driver.set_clk_mode(mode)

    def __hcc_default_hint_handler(self):
        self.hcc_driver.hint_queue_put(1)

    def hcc_register(self, handler):
        if not self.hcc_enabled:
            raise HccDriverError("HCC needs to be enabled first, call enable_hcc(bus_num, chip_select)")
        if handler:  # Deserialize and set aliases
            handler, aliases = func_loads(handler, locals(), self.hcc_driver._hint_queue)
            for attr_name, path in aliases.items():
                self.__setattr__(attr_name,self.test_station.resolve_path(path))
        else:
            handler = self.__hcc_default_hint_handler
        self.hcc_driver.register(handler)

    def hcc_unregister(self):
        if not self.hcc_enabled:
            raise HccDriverError("HCC needs to be enabled first, call enable_hcc(bus_num, chip_select)")
        self.hcc_driver.unregister()

    def hcc_hint_queue_get(self, timeout):
        if not self.hcc_enabled:
            raise HccDriverError("HCC needs to be enabled first, call enable_hcc(bus_num, chip_select)")
        return json.dumps(self.hcc_driver.hint_queue_get(timeout))

    # # ----- I3C Functions ----- # #

    @require_variant('*_i3c')
    def enable_i3c(self, bus_num: int) -> bool:
        if bus_num not in self.dwc_i3c:
            device = f"crus-i3c{bus_num}"
            dev_path = f"/dev/{device}"
            if device not in os.listdir('/dev/'):  # Try modprobe
                process = subprocess.Popen('modprobe crus-i3c', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                process.communicate("")
            try:
                self.dwc_i3c[bus_num] = DwcI3c(filename=dev_path)
                self.i3c_initial_devices[bus_num] = [dev.dyn_addr for dev in self.dwc_i3c[bus_num].i3cboardinfo]
            except Exception as i3c_init_err:
                raise I3cDriverError(f"Could not create I3C driver, received {repr(i3c_init_err)}")
        return True

    @require_variant('*_i3c')
    def disable_i3c(self, bus_num: int):
        if bus_num in self.dwc_i3c:
            self.dwc_i3c[bus_num].close()
            self.dwc_i3c.pop(bus_num)

    def _get_dwc_i3c(self, bus_num: int) -> DwcI3c:
        if bus_num not in self.dwc_i3c:
            raise I3cDriverError(f"I3C is not enabled for bus {bus_num}, call enable_i3c({bus_num}) first.")
        return self.dwc_i3c[bus_num]

    def i3c_controller_rstdaa(self, bus_num: int, address: int, detach_devs: bool):
        """
        Uses I3C Controller to issue the RSTDAA CCC (Reset dynamic address assignments) to 'address'

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: I3C address. For broadcast, use 0x7E
        :type address: int
        :param detach_devs: After issuing the CCC, remove all devices from the driver's interal device list
        :type detach_devs: bool
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        # Send CCC
        try:
            dwc_i3c.i3c_master_rstdaa_locked(address)
        except (IOError, OSError) as err:
            msg = f"Recevied ({err}) when issuing RSTDAA (bus_num={bus_num}, address=0x{address:2X}"
            raise I3cError(str(err), msg)
        # Remove devices stored in software
        if detach_devs:
            devices = []
            for device in dwc_i3c.i3cboardinfo:
                if device.dyn_addr != 0x8: # not in self.i3c_initial_devices[bus_num]:  # Only remove user added devices
                    devices.append(device)
            for device in devices:
                dwc_i3c.i3c_master_detach_i3c_dev(device)

    def i3c_controller_setaasa(self, bus_num: int):
        """
        Uses I3C Controller to issue the SETAASA Broadcast CCC (Set static address as dynamic address)

        :param bus_num: I3C bus number
        :type bus_num: int
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        try:
            dwc_i3c.i3c_master_setaasa_locked()
        except IOError as err:
            msg = f"Recevied ({err}) when issuing SETAASA (bus_num={bus_num})"
            raise I3cError(str(err), msg)

    def i3c_controller_setdasa(self, bus_num: int, static_addr: int, dyn_addr: int):
        """
        Uses I3C Controller to issue the SETDASA CCC (Set dynamic address from static address)

        :param bus_num: I3C bus number
        :type bus_num: int
        :param static_addr: I3C static device address
        :type static_addr: int
        :param dyn_addr: Desired I3C dynamic device address
        :type dyn_addr: int
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        try:
            dwc_i3c.i3c_master_setdasa_locked(static_addr=static_addr, dyn_addr=dyn_addr)
        except IOError as err:
            msg = f"Recevied ({err}) when issuing SETDASA (bus_num={bus_num}, static_addr=0x{static_addr:2X}, " \
                  f"dyn_addr=0x{dyn_addr:2X})"
            raise I3cError(str(err), msg)

    def i3c_controller_setnewda(self, bus_num: int, old_addr: int, new_addr: int):
        """
        Uses I3C Controller to issue the SETDASA CCC (Set dynamic address from static address)

        :param bus_num: I3C bus number
        :type bus_num: int
        :param old_addr: Device address to change
        :type old_addr: int
        :param new_addr: New device address
        :type new_addr: int
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        try:
            dwc_i3c.i3c_master_setnewda_locked(oldaddr=old_addr, newaddr=new_addr)
        except IOError as err:
            msg = f"Recevied ({err}) when issuing SETNEWDA (bus_num={bus_num}, old_addr=0x{old_addr:2X}, " \
                  f"new_addr=0x{new_addr:2X})"
            raise I3cError(str(err), msg)
        # If SETNEWDA succeeded, remove old addr and add device with new addr
        dev = dwc_i3c.i3c_master_search_i3c_dev_by_Daddr(old_addr)
        if dev:
            dwc_i3c.i3c_master_detach_i3c_dev(dev)
        new_device = i3c_device_info(dyn_addr=new_addr)  # Create new device info with new_addr as dynamic address
        dwc_i3c.i3c_master_attach_i3c_dev(new_device)  # Add device to driver

    def i3c_controller_dodaa(self, bus_num: int, reset_addr_assignments: bool) -> Dict[int, int]:
        """
        Performs a DAA (dynamic address assignment) and returns a dictionary where the keys are device PIDs and values
        are the assigned dynamic addresses.

        :param bus_num: I3C bus number
        :type bus_num: int
        :return: Dynamic address assignments
        :rtype: Dict[int, int]
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        # RSTDAA to clear all devices previously added
        if reset_addr_assignments:
            self.i3c_controller_rstdaa(bus_num, address=0x7E, detach_devs=True)
        # Perform ENTDAA and enumeration
        dwc_i3c.i3c_master_do_daa()
        # Return new devices
        return {dev.pid: dev.dyn_addr for dev in dwc_i3c.i3cboardinfo if dev.dyn_addr != 0x8}

    def i3c_controller_enec(self, bus_num: int, address: int, payload: int):
        """
        Uses I3C Controller to issue the ENEC CCC (Enable Events Command). Paylod contains which events will be
        enabled.

        Payload format (1 Byte):

        
               reserved          hot_join     reserved     mastership    int_req   
        
                4 Bits           1 Bit       1 Bit         1 Bit         1 Bit     
        

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device, or all devices if address==BROADCAST
        :type address: int
        :param payload: Byte that determines which events to enable
        :type payload: int
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        try:
            dwc_i3c.i3c_master_enec_locked(addr=address, evts=payload)
        except IOError as err:
            msg = f"Recevied ({err}) when issuing ENEC (bus_num={bus_num}, address=0x{address:02X}, " \
                  f"payload=0x{payload:02X})"
            raise I3cError(str(err), msg)

    def i3c_controller_disec(self, bus_num: int, address: int, payload: int):
        """
        Uses I3C Controller to issue the DISEC CCC (Disable Events Command). Paylod contains which events will be
        disabled.

        Payload format (1 Byte):

        
               reserved          hot_join     reserved     mastership    int_req   
        
                4 Bits           1 Bit       1 Bit         1 Bit         1 Bit     
        

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device, or all devices if address==BROADCAST
        :type address: int
        :param payload: Byte that determines which events to disable
        :type payload: int
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        try:
            dwc_i3c.i3c_master_disec_locked(addr=address, evts=payload)
        except IOError as err:
            msg = f"Recevied ({err}) when issuing DISEC (bus_num={bus_num}, address=0x{address:02X}," \
                  f" payload=0x{payload:02X})"
            raise I3cError(str(err), msg)

    def i3c_controller_getpid(self, bus_num: int, address: int, add_device: bool) -> int:
        """
        Uses I3C Controller to issue the GETPID CCC (Get Provisional ID). The driver's device info will be updated with
        the PID response, and this function will also return the PID in the form of an integer.

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: Provisional ID
        :rtype: int
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_device_exists(bus_num, address, add_device)
        # Send GETPID and update device info dataclass
        dwc_i3c.i3c_master_getpid_locked(device)
        return device.pid

    def i3c_controller_getbcr(self, bus_num: int, address: int, add_device: bool) -> int:
        """
        Uses I3C Controller to issue the GETBCR CCC (Get Bus Characteristics Register). The driver's device info will
        be updated with the BCR value, and this function will also return the BCR in the form of an integer.

        BCR Format:
        
         device_role  reserve   bridge    offline capable  ibi_payload  ibi_req_capable  max_data_speed_limited 
        
           2 Bits     1 Bit     1 Bit     1 Bit            1 Bit        1 Bit            1 Bit                  
        

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: BCR value
        :rtype: int
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_device_exists(bus_num, address, add_device)
        # Send GETPID and update device info dataclass
        dwc_i3c.i3c_master_getbcr_locked(device)
        return device.bcr

    def i3c_controller_getdcr(self, bus_num: int, address: int, add_device: bool) -> int:
        """
        Uses I3C Controller to issue the GETDCR CCC (Get Device Characteristics Register). The driver's device info will
        be updated with the DCR value, and this function will also return the DCR in the form of an integer.

        The DCR is a 1 Byte code the describes the type of device. Default value is 0x00 for a generic device.

        MIPI DCR code definitions can be found here: https://www.mipi.org/mipi_i3c_device_characteristics_register

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: DCR value
        :rtype: int
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_device_exists(bus_num, address, add_device)
        # Send GETPID and update device info dataclass
        dwc_i3c.i3c_master_getdcr_locked(device)
        return device.dcr

    def i3c_controller_getstatus(self, bus_num: int, address: int, add_device: bool) -> int:
        """
        Uses I3C Controller to issue the GETSTATUS CCC (Get Device Status). The driver's device info will
        be updated with the device's status value, and this function will also return the DCR in the form of an integer.

        Status format:

        
           vendor_reserved       activity_mode    protocol_error    reserved     pending_interrupt     
        
                8 Bits             2 Bits         1 Bit             1 Bit              4 Bits          
        

        :param bus_num: I3C bus number
        :type bus_num: int
        :param address: Target device
        :type address: int
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: DCR value
        :rtype: int
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_device_exists(bus_num, address, add_device)
        # Send GETPID and update device info dataclass
        dwc_i3c.i3c_master_getstatus_locked(device)
        return device.status

    def i3c_controller_add_device(self, bus_num: int, static_addr: int, dyn_addr: int):
        """
        Attaches a new I3C device to the driver.

        1. If only a static address is given (dyn_addr==0), the SETAASA CCC is assumed to have been broadcasted already.
        2. If only a dynamic address is given (static_addr==0), a device will be added using 'dyn_addr'
        3. If a static and dynamic address is given, this function will issue a SETDASA.

        :param bus_num: I3C bus number
        :type bus_num: int
        :param static_addr: I3C static device address
        :type static_addr: int
        :param dyn_addr: Desired I3C dynamic device address
        :type dyn_addr: int
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        if dyn_addr and not static_addr:  # Just add the device using dynamic address, swap address values
            static_addr, dyn_addr = dyn_addr, static_addr
        if static_addr:  # Add device using static address as dyamic address
            if dwc_i3c.i3c_master_search_i3c_dev_by_Daddr(static_addr):  # Device already exists
                raise I3cDriverError(f"Device with address 0x{static_addr:2X} already exists")
            device = i3c_device_info(dyn_addr=static_addr)
            # Attempt to attach device
            try:
                dwc_i3c.i3c_master_attach_i3c_dev(device)
            except ValueError:
                raise I3cDriverError(f"Address slot 0x{device.dyn_addr:2X} taken ({dwc_i3c.addrslots[device.dyn_addr].name})")
            if dyn_addr:  # Use new device to SETDASA
                if dwc_i3c.i3c_master_search_i3c_dev_by_Daddr(dyn_addr):  # Device already exists
                    raise I3cDriverError(f"Device with address 0x{dyn_addr:2X} already exists")
                # Set dynamic address
                # dwc_i3c.i3c_master_setdasa_locked(static_addr=static_addr, dyn_addr=dyn_addr)
                self.i3c_controller_setdasa(bus_num=bus_num, static_addr=static_addr, dyn_addr=dyn_addr)
                # Detach static device
                dwc_i3c.i3c_master_detach_i3c_dev(device)
                # Create dynamic device and attach to driver
                device = i3c_device_info(dyn_addr=dyn_addr)
                try:
                    dwc_i3c.i3c_master_attach_i3c_dev(device)
                except ValueError:
                    raise I3cDriverError(f"Address slot 0x{device.dyn_addr:2X} taken ({dwc_i3c.addrslots[device.dyn_addr].name})")
        else:
            raise I3cDriverError("No static address given")

    def i3c_controller_add_i2c_device(self, bus_num: int, address: int, replace: bool):
        """
        Adds legacy I2C device to the DWC I3C driver. If replace is True, exitsting devices at 'address' will be
        removed. If replace is False and a device already exists (Either I3C or legacy I2C), an I3cDriverError is raised.

        :param bus_num: Bus number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param replace: Replace existing device with new I2C device
        :type replace: bool
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        # Check for I3C device with address
        existing_i3c_device = dwc_i3c.i3c_master_search_i3c_dev_by_Daddr(address)
        if existing_i3c_device:
            if replace:
                dwc_i3c.i3c_master_detach_i3c_dev(existing_i3c_device)
            else:
                raise I3cDriverError(f"I3C device with address 0x{address:2X} already exists")
        # Check for I2C device with address
        existing_i2c_device = dwc_i3c._i3c_master_search_i2c_dev_by_addr(address)
        if existing_i2c_device:
            if replace:
                dwc_i3c.i3c_master_detach_i2c_dev(existing_i2c_device)
            else:
                raise I3cDriverError(f"I2C device with address 0x{address:2X} already exists")
        # Add device
        i2c_dev = i2c_device_info(addr=address, lvr=0x00)  # TODO see if LVR needs to be configurable
        dwc_i3c.i3c_master_attach_i2c_dev(i2c_dev)

    def i3c_controller_remove_device(self, bus_num: int, address: int):
        """
        Removes device from I3C driver. Can be I3C or legacy I2C device.

        :param bus_num: Bus number
        :type bus_num: int
        :param address: Either I3C dynamic address or I2C address
        :type address: int
        :return: None
        :rtype: None
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        # Search for I3C devices
        i3c_device = dwc_i3c.i3c_master_search_i3c_dev_by_Daddr(address)
        if i3c_device:
            dwc_i3c.i3c_master_detach_i3c_dev(i3c_device)
        # Search for legacy I2C devices
        i2c_device = dwc_i3c._i3c_master_search_i2c_dev_by_addr(address)
        if i2c_device:
            dwc_i3c.i3c_master_detach_i2c_dev(i2c_device)
  
    def i3c_controller_get_i2c_devices(self, bus_num: int) -> List[str]:
        """
        Returns a list string representations of all legacy I2C devices currently registered to the I3C driver.

        :param bus_num: Bus number
        :type bus_num: int
        :return: List of devices
        :rtype: List[str]
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        return [str(device) for device in dwc_i3c.i2cboardinfo]

    def i3c_controller_get_devices(self, bus_num: int) -> List[str]:
        """
        Returns list of str() strings for all i3c devices attached to the driver. Ignores internal device at address 0x8

        :return: List of i3c_device_info __str__ results
        :rtype: List[str]
        """
        dwc_i3c = self._get_dwc_i3c(bus_num)
        return [str(device) for device in dwc_i3c.i3cboardinfo if device.dyn_addr != 0x8]

    def _i3c_check_device_exists(self, bus_num: int, address: int, add_device: bool = False) -> i3c_device_info:
        dwc_i3c = self._get_dwc_i3c(bus_num)
        i3c_device = dwc_i3c.i3c_master_search_i3c_dev_by_Daddr(address)
        if i3c_device is None:
            if add_device:  # Need to create a new device and attach it to the driver
                # Check if address is used for an I2C device, detach it if one exists
                i2c_device = dwc_i3c._i3c_master_search_i2c_dev_by_addr(address)
                if i2c_device:
                    dwc_i3c.i3c_master_detach_i2c_dev(i2c_device)
                # Add new device
                self.i3c_controller_add_device(bus_num=bus_num, static_addr=0, dyn_addr=address)
                i3c_device = dwc_i3c.i3c_master_search_i3c_dev_by_Daddr(address)
            else:  # Device does not exist, raise exception
                raise I3cDriverError(f"No device found with address 0x{address:2X}, use i3c_add_device() first.")
        return i3c_device

    def _i3c_check_i2c_device_exists(self, bus_num: int, address: int, add_device: bool = False) -> i2c_device_info:
        dwc_i3c = self._get_dwc_i3c(bus_num)
        i2c_device = dwc_i3c._i3c_master_search_i2c_dev_by_addr(address)
        if not i2c_device:
            if add_device:  # Need to create a new device and attach it to the driver
                self.i3c_controller_add_i2c_device(bus_num=bus_num, address=address, replace=True)
                i2c_device = dwc_i3c._i3c_master_search_i2c_dev_by_addr(address)
            else:  # Device does not exist, raise exception
                raise I3cDriverError(f"No device found with address 0x{address:2X}, use i3c_add_device() first.")
        return i2c_device

    def i3c_read_device(self, bus_num: int, address: int, num_bytes: int, preamble_bytes: List[int], add_device: bool) -> List[int]:
        """
        Reads 'num_bytes' from an I3C device at 'address'. If preamble_bytes is populated, those bytes will be written
        to the device before the read operation. Otherwise, only a read transfer will be executed.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: List of bytes read from the device
        :rtype: List[int]
        """
        # Get driver objects
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_device_exists(bus_num, address, add_device)
        # Create necessary transfers
        transfers = []
        if preamble_bytes:  # Write preamble bytes to device before read
            transfers.append(i3c_priv_xfer(rnw=False, len=len(preamble_bytes), data=bytearray(preamble_bytes)))
        read_transfer = i3c_priv_xfer(rnw=True, len=num_bytes, data=bytearray(num_bytes))
        transfers.append(read_transfer)
        # Execute transfers
        dwc_i3c.i3c_master_do_priv_xfers_locked(device, transfers)
        # Check if either transfer had an error code
        for transfer in transfers:
            if transfer.err:
                op = 'read' if transfer.rnw else 'write'
                msg = f"Recevied ({transfer.err}) when issuing I3C {op} (bus_num={bus_num}, " \
                      f"address=0x{address:2X}, num_bytes={num_bytes}, preamble_bytes={preamble_bytes})"
                raise I3cError(transfer.err, msg)
        # Return bytes from read transfer
        return list(read_transfer.data)


    def i3c_read_reg(self, bus_num: int, address: int, reg_addr: List[int], num_bytes: int, preamble_bytes: List[int],
                     add_device: bool) -> List[int]:
        """
        Reads 'num_bytes' from register address 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before the register address.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :type reg_addr:
        :param reg_addr:
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: List of bytes read starting from register at address 'reg_addr'
        :rtype: List[int]
        """
        # Perform device read with preamble + register address concatenated
        concat_preamble = preamble_bytes + reg_addr
        return self.i3c_read_device(bus_num=bus_num, address=address, num_bytes=num_bytes,
                                    preamble_bytes=concat_preamble, add_device=add_device)

    def i3c_write_device(self, bus_num: int, address: int, write_data: List[int], preamble_bytes: List[int], add_device: bool):
        """
        Writes 'write_data' to I3C device at 'address'. If preamble_bytes is populated,those bytes will be written
        to the device before write_data.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: None
        :rtype: None
        """
        # Get driver objects
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_device_exists(bus_num, address, add_device)
        # Create transfer
        xfer_len = len(preamble_bytes) + len(write_data)
        data = bytearray(preamble_bytes + write_data)
        write_transfer = i3c_priv_xfer(rnw=False, len=xfer_len, data=data)
        # Execute transfer
        dwc_i3c.i3c_master_do_priv_xfers_locked(device, [write_transfer])
        if write_transfer.err:
            msg = f"Recevied ({write_transfer.err}) when issuing I3C write (bus_num={bus_num}, " \
                  f"address=0x{address:2X}, preamble_bytes={preamble_bytes}, len(write_data)={len(write_data)})"
            raise I3cError(write_transfer.err, msg)

    def i3c_write_reg(self, bus_num: int, address: int, reg_addr: List[int], write_data: List[int],
                      preamble_bytes: List[int], add_device: bool):
        """
        Writes 'write_data' to I3C register at 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before register address.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I3C device address
        :type address: int
        :param reg_addr: Register address
        :type reg_addr: List[int]
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: None
        :rtype: None
        """
        # Perform device write with preamble + register address concatenated
        concat_preamble = preamble_bytes + reg_addr
        self.i3c_write_device(bus_num=bus_num, address=address, write_data=write_data,
                              preamble_bytes=concat_preamble, add_device=add_device)

    def i3c_legacy_i2c_read_device(self, bus_num: int, address: int, num_bytes: int, preamble_bytes: List[int],
                                   add_device: bool) -> List[int]:
        """
        Reads 'num_bytes' from an legacy I2C device at 'address'. If preamble_bytes is populated, those bytes will be
        written to the device before the read operation. Otherwise, only a read transfer will be executed.

        If an error code is found in either the preamble write or the read, this function will raise an I3cError.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: List of bytes read from the device
        :rtype: List[int]
        """
        # Get driver objects
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_i2c_device_exists(bus_num, address, add_device)
        read_flag = I2C_FLAG_DEF.I2C_M_RD
        # Create necessary transfers
        transfers = []
        if preamble_bytes:  # Write preamble bytes to device before read
            transfers.append(i2c_msg(addr=device.addr, flags=0, buf=bytearray(preamble_bytes), len=len(preamble_bytes)))
        read_transfer = i2c_msg(addr=device.addr, flags=read_flag, buf=bytearray(num_bytes), len=num_bytes)
        transfers.append(read_transfer)
        # Execute transfers
        dwc_i3c.i3c_master_i2c_xfers(device.addr, transfers)
        # Check if either transfer had an error code
        for transfer in transfers:
            if transfer.err:
                op = 'read' if transfer.flags & read_flag else 'write'
                msg = f"Recevied ({transfer.err}) when issuing legacy I2C {op} (bus_num={bus_num}, " \
                      f"address=0x{address:2X}, num_bytes={num_bytes}, preamble_bytes={preamble_bytes})"
                raise I3cError(transfer.err, msg)
        # Return bytes from read transfer
        return list(read_transfer.buf)

    def i3c_legacy_i2c_read_reg(self, bus_num: int, address: int, reg_addr: List[int], num_bytes: int,
                                preamble_bytes: List[int], add_device: bool) -> List[int]:
        """
        Performs an legacy I2C read register operation using the I3C lines. Will attempt to add a new device
        (replacing existing devices) if 'add_device' is True.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :type reg_addr: Register address
        :param reg_addr: int
        :param num_bytes: Number of bytes to read from the device
        :type num_bytes: int
        :param preamble_bytes: List of bytes to write to the device before issuing the read.
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: List of bytes read starting from register at address 'reg_addr'
        :rtype: List[int]
        """
        # Perform device read with preamble + register address concatenated
        concat_preamble = preamble_bytes + reg_addr
        return self.i3c_legacy_i2c_read_device(bus_num=bus_num, address=address, num_bytes=num_bytes,
                                               preamble_bytes=concat_preamble, add_device=add_device)

    def i3c_legacy_i2c_write_device(self, bus_num: int, address: int, write_data: List[int], preamble_bytes: List[int], add_device: bool):
        """
        Writes 'write_data' to I2C device at 'address'. If preamble_bytes is populated,those bytes will be written
        to the device before write_data.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: None
        :rtype: None
        """
        # Get driver objects
        dwc_i3c = self._get_dwc_i3c(bus_num)
        device = self._i3c_check_i2c_device_exists(bus_num, address, add_device)
        # Create transfer
        xfer_len = len(preamble_bytes) + len(write_data)
        data = bytearray(preamble_bytes + write_data)
        write_transfer = i2c_msg(addr=device.addr, flags=0, buf=data, len=xfer_len)
        # Execute transfer
        dwc_i3c.i3c_master_i2c_xfers(device.addr, [write_transfer])
        print(hex(device.addr))
        print('data: ', list(data), data)
        print(write_transfer)
        print('buf', write_transfer.buf)
        print('err:', write_transfer.err)
        if write_transfer.err:
            msg = f"Recevied ({write_transfer.err}) when issuing legacy I2C write (bus_num={bus_num}, " \
                  f"address=0x{address:2X}, preamble_bytes={preamble_bytes}, len(write_data)={len(write_data)})"
            raise I3cError(write_transfer.err, msg)

    def i3c_legacy_i2c_write_reg(self, bus_num: int, address: int, reg_addr: List[int], write_data: List[int],
                                 preamble_bytes: List[int], add_device: bool):
        """
        Writes 'write_data' to I2C device register at 'reg_addr'. If preamble_bytes is populated, those bytes will be written
        to the device before register address.

        :param bus_num: Bus Number
        :type bus_num: int
        :param address: I2C device address
        :type address: int
        :param reg_addr: Register address
        :type reg_addr: List[int]
        :param write_data: Bytes to write
        :type write_data: List[int]
        :param preamble_bytes: Bytes to write before write_data
        :type preamble_bytes: List[int]
        :param add_device: When True, will add new device with dynamic address if one does not exist
        :type add_device: bool
        :return: None
        :rtype: None
        """
        # Perform device write with preamble + register address concatenated
        concat_preamble = preamble_bytes + reg_addr
        self.i3c_legacy_i2c_write_device(bus_num=bus_num, address=address, write_data=write_data,
                                         preamble_bytes=concat_preamble, add_device=add_device)

    def server_eval(self, expression):
        """
        runs eval() and returns JSON string of result.

        :param expression: String that will get called in eval()
        :type expression: str
        :return: JSON String
        :rtype: str
        """
        err = None
        try:
            result = eval(expression, globals(), locals())
        except:
            err = ServerError(traceback.format_exc())
        if err:
            raise err
        try:
            return json.dumps(result)
        except:
            err = JSONSerializeError(traceback.format_exc())
        raise err

    def program_xmos_image(self, image):
        """
        Programs XMOS image given. Images are found in /home/ah2webapp/media

        :param image: name of xmos image file, eg. "xmos_uac2_16in_16out_tdm8.bin"
        :type image: str
        :return: "Programming complete." if image was successfully programmed
        :rtype: str
        """
        if 'audiohub.py' not in os.listdir('/home'):
            raise Exception("This device does not support XMOS Programming")
        if not os.path.exists(os.path.join('/home/ah2webapp/media', image)):
            images = os.listdir('/home/ah2webapp/media')
            raise ValueError(f"Image '{image}' not found. Valid images: {', '.join(images)}")
        from audiohub import program_xmos_image as ah_program_xmos_image
        result = ah_program_xmos_image(None, image)
        if result != "Programing complete.":
            raise Exception(f"Programming XMOS image {image} was not soccessful.")
        return result.replace("Programing", "Programming")

    def get_variants(self) -> List[str]:
        variants = []
        for folder in FPGA_PATH.glob("*"):  # Each subdirectory is a different variant
            if folder.is_dir():
                variants.append(folder.name)
        return variants

    def get_current_variant(self) -> str:
        current_boot_file = BOOT_PATH / "boot.bin"
        with current_boot_file.open('rb') as f:
            current_boot_contents = f.read()
        for variant in self.get_variants():
            boot_file = FPGA_PATH / variant / "bin" / "boot.bin"
            with boot_file.open('rb') as f:
                boot_contents = f.read()
            if boot_contents == current_boot_contents:
                return variant
        else:
            raise FileNotFoundError("Unknown boot.bin")

    def set_variant(self, variant: str, reboot: bool):
        # Copy boot.bin into /mnt
        new_boot_file = FPGA_PATH / variant / "bin" / "boot.bin"
        shutil.copy2(new_boot_file, BOOT_PATH)
        # Symlink new regmap folder
        new_target_reg = FPGA_PATH / variant / "reg"
        if REGMAP_PATH.is_symlink():
            REGMAP_PATH.unlink()
            REGMAP_PATH.symlink_to(new_target_reg)
        # Sync to apply variant
        os.system('sync')
        # Reboot to reload FPGA
        if reboot:
            def reboot_after_wait():
                time.sleep(3)
                os.system('reboot')
            threading.Thread(target=reboot_after_wait, daemon=True).start()


if __name__ == "__main__":
    # Get the current hostname
    this_host = socket.gethostname() + '.local'
    print('This hostname:', this_host)
    handler = ah_thrift_handler()
    processor = ah_thrift.Processor(handler)
    transport = TSocket.TServerSocket(host=this_host, port=1025, socket_family=socket.AF_INET)
    tfactory = TTransport.TBufferedTransportFactory()
    pfactory = TBinaryProtocol.TBinaryProtocolFactory()

    server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)
    print('Starting the CirrusLink Thrift server...')
    server.serve()
    print('Server terminated')
