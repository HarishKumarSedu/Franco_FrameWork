"""
Convenient wrapper for creating python thrift clients. Generates python interface at instantiation with given .thrift
 file and service. After instantiation, use open() with a hostname and port to connect to a given thrift server.
Author: Evan Canter
"""
import inspect
import logging
import os
import posixpath
import re
import sys
import time
import warnings
from importlib import import_module
from functools import lru_cache
from typing import *
import embedded_thrift_server
from cl_test_station.utilities.ts_logging import TsLoggingAdapter
from embedded_thrift_server.utilities.thrift_utils import gen_single_thrift, gen_stub_file
from thrift.protocol import TBinaryProtocol
from thrift.Thrift import TApplicationException
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.transport.TTransport import TTransportException
warnings.filterwarnings("ignore", category=ResourceWarning)


class TClient:

    package_path = os.path.dirname(os.path.realpath(__file__)) + '/'

    def __init__(self, thrift_filepath: str = '', thrift_service: str = '', log: TsLoggingAdapter = None):
        """
        Generates python code based on given thrift file+service, then imports the generated interface to make a client
        :param thrift_filepath: path to the .thrift file
        :param thrift_service: name of the service within the .thrift file
        """
        self.client_functions = {}
        self.log = log if log is not None else logging.getLogger()
        self.transport = None
        # todo: change these default checks to yaml field required params
        #  (only necessary for when you can have .thrift inheritance)
        if thrift_filepath == '':
            thrift_filepath = self.package_path + 'ah_thrift.thrift'
        if thrift_service == '':
            thrift_service = 'ah_thrift'

        # Generate python client interface
        self.log.info("Generating thrift interface")
        gen_single_thrift(target='py', thrift_file=thrift_filepath, out_dir=self.package_path)
        # Generate client stub for autocomplete
        gen_stub_file(thrift_filepath, thrift_service, stub_path=self.package_path+'tclient.pyi', class_name='TClient')

        # save current working directory
        cwd = os.getcwd()
        os.chdir(self.package_path)
        # Get name of generated folder in gen-py
        thrift_fname = os.path.basename(thrift_filepath).split('.')[0]
        # import generated client interface
        self.client_module = import_module(f'embedded_thrift_server.{thrift_fname}.{thrift_service}')
        os.chdir(cwd)

    def __getattribute__(self, item):
        """
        Any time a client function is accessed, it gets wrapped to allow traceback printing
        :param item: Attribute name
        :type item: str
        :return: Attribute, warpped method if applicable
        :rtype: Any
        """
        if item in object.__getattribute__(self, 'client_functions'):  # This is a thrift function, wrap
            return self.client_func_wrapper(object.__getattribute__(self, 'client_functions')[item])
        return object.__getattribute__(self, item)  # Use normal getattr otherwise

    @lru_cache(maxsize=128)
    def client_func_wrapper(self, func: Callable) -> Callable:
        """
        Wrapper for thrift client functions. If an Error occurs, TClient will interrogate the server log and print the
        server traceback. Error is re-raised to prevent silent exceptions.
        :param func: Thrift function to wrap
        :type func: Callable
        :return: Wrapped function
        :rtype: Callable
        """
        def attempt_func(*args, **kwargs):
            try:
                return func(*args, **kwargs)  # Try running Thrift function
            except Exception as server_error:  # If exception occus, get traceback and log it
                server_tb = self.get_server_traceback()
                err_msg = f"Encountered exception on server:\n{server_tb}"
                self.log.error(err_msg)
                if isinstance(server_error, TApplicationException) and server_error.type == TApplicationException.INTERNAL_ERROR:
                    server_error.message = f"\n{server_tb}"
                raise
        attempt_func.__signature__ = inspect.signature(func)  # Transfer signature to maintain param autocomplete
        return attempt_func

    def get_server_traceback(self) -> str:
        """
        Gets the stderr output from the point of the last call to this function and returns a formatted version of it.
        File paths are updated to enable clickable links in the console.
        :return: Formatted traceback
        :rtype: str
        """
        trace = self.client.get_traceback()  # Get raw stderr traceback
        pkg_path = os.path.dirname(inspect.getfile(embedded_thrift_server))  # Get local path to embedded_thrift_server
        for path in re.findall(r'File\s+"(.+embedded_thrift_server)', trace): # Find any references to linux path
            trace = trace.replace(path, pkg_path).replace(posixpath.sep, os.sep)  # Replace with local path
        return trace

    def open(self, hostname: str, socket: int):
        """
        Creates the thrift client and matching transport with hostname and socket
        :param hostname: hostname of server
        :param socket: port
        :return:
        """
        self.log.info('Creating client [hostname: %s, socket: %d]' % (hostname, socket))
        self.raw_transport = TSocket.TSocket(hostname, socket)
        self.raw_transport.setTimeout(30000)
        # Buffering is critical. Raw sockets are very slow
        self.transport = TTransport.TBufferedTransport(self.raw_transport)
        # Wrap in a protocol
        self.protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
        # Create a client to use the protocol encoder
        self.client = self.client_module.Client(self.protocol)
        # Bring up self.client functions to self level, so from the user perspective the code looks the same
        self.raise_functions()

    def connect(self):
        """
        Will try to open the thrift transport up to 10 times. If every attempt fails, it will raise an Exception
        :return:
        """
        if self.transport is None:
            raise Exception("Cannot connect because client is not open. Call open(hostname, socket) first")
        # Filter out TSocket Errors on failed attempts
        socket_logger = logging.getLogger('thrift.transport.TSocket')
        old_level = socket_logger.getEffectiveLevel()
        socket_logger.setLevel(logging.CRITICAL)
        # Try to connect
        for attempt in range(10):
            try:
                self.transport.open()
                break
            except TTransportException:
                self.transport.close()
                time.sleep(.5)
        else:
            raise TimeoutError(f"Could not connect to Host_Controller: connection retry limit reached.")
        # Restore TSocket logging level
        socket_logger.setLevel(old_level)
        self.log.info("Successfully connected TClient to thrift server")

    def close(self):
        self.log.info("Closing TClient transport")
        self.transport.close()

    def raise_functions(self):
        """
        Pulls all client thrift functions up to TClient level
        Returns:
        """
        for name, attr in inspect.getmembers(self.client):
            if callable(attr) and not name.startswith('_'):  # give tclient public functions
                func = lambda *a, _client_func=attr, **kw: _client_func(*a, **kw)
                func.__signature__ = inspect.signature(attr)
                self.__setattr__(name, func)
                self.client_functions[name] = func

    @property
    def connected(self):
        """
        Returns True if client successfully pings server, False otherwise
        :return: bool, connection status
        """
        try:
            return self.client.ping() == 'Received'
            # return self.transport.isOpen()
        except Exception as e:
            return False

    def is_connected(self):
        """
        getter for 'connected' since pyro doesn't like decorators
        :return:
        """
        return self.connected
