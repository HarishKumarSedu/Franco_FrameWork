"""
API for controlling the SmartDv SPMI core through python memory map
Authors: Jim Antone, Evan Canter
"""
import logging
import mmap
import os
import struct
from random import randint
from time import sleep
from importlib import import_module

from embedded_thrift_server.ah_thrift.ttypes import Spmi_timeout, Spmi_arb_failure


logging.basicConfig(filename='log.sh', level=logging.DEBUG)


class DummySPMIController:
    word = 4
    mask = ~(word - 1)

    def __init__(self, base_addr, size):
        self.base_addr = base_addr
        self.size = size

        # mmap creation
        virt_base = base_addr & ~(mmap.PAGESIZE - 1)
        self.virt_offset = base_addr - virt_base
        self.mmap_fd = os.open('/dev/mem', os.O_RDWR | os.O_SYNC)
        self.mem = mmap.mmap(self.mmap_fd, size, mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE, offset=virt_base)

    def write(self, addr, data):
        virt_base_addr = self.virt_offset & self.mask
        self.mem.seek(virt_base_addr + addr)
        self.mem.write(struct.pack('I', data))

        return 0

    def read(self, addr):
        virt_base_addr = self.virt_offset & self.mask
        self.mem.seek(virt_base_addr + addr)
        return int(struct.unpack('I', self.mem.read(self.word))[0])

    def close(self):
        self.mem.close()
        os.close(self.mmap_fd)

class SPMI:
    RND_RANGE4 = 4

    offsets = {
        "REG_MASTER_CNTRL_OFFSET": 0x00 * 4,  # CONTROL
        "REG_VERSION_OFFSET": 0x01 * 4,  # VERSION
        "REG_INT_MASK": 0x02 * 4,  # INT_MASK
        "REG_INT_STATUS": 0x03 * 4,  # INT_STATUS
        "REG_HD1_OFFSET": 0x04 * 4,  # ARB_TST_LSB
        "REG_HD2_OFFSET": 0x05 * 4,  # ARB_TST_MSB
        "REG_HD3_OFFSET": 0x06 * 4,  # RSP_ADDR
        "REG_PE_OFFSET": 0x07 * 4,  # ARB_SYNC
        "REG_RC_OFFSET": 0x08 * 4,  # ARB_SYNC_ID
        "REG_RD0_OFFSET": 0x09 * 4,  # RSP_CMD
        "REG_RD1_OFFSET": 0x0A * 4,
        "REG_RD2_OFFSET": 0x0B * 4,
        "REG_RD3_OFFSET": 0x0C * 4,
        "REG_TS_OFFSET": 0x0D * 4,  # USEDJAA timer setup orig
        "REG_STC_OFFSET": 0x0E * 4,  # USEDJAA Status orig
        "REG_DDBA_OFFSET": 0x0F * 4,  # USEDJAA orig
        "REG_INTF_OFFSET": 0x10 * 4,  # INTerrupt flags orig now REQ_PRES
        "REG_REQ_COMMAND_OFFSET": 0x11 * 4,  # INTerrupt enable orig now REQ_COMMAND
        "REG_REQ_SLVA_BC_OFFSET": 0x12 * 4,  # NEW stuff
        "REG_REQ_ADDRLO_OFFSET": 0x13 * 4,  # REQ ADDR LOW
        "REG_REQ_ADDRHI_OFFSET": 0x14 * 4,  # REQ ADDR HI
        "REG_REQ_STATUS_OFFSET": 0x15 * 4,  # REQ ADDR LOW
        "REG_REQ_RD_WAIT_OFFSET": 0x16 * 4,  # REQ ADDR HI
        "REG_REQ_DATA0_OFFSET": 0x20 * 4,  # REQ DATA 0
        "REG_REQ_DATA1_OFFSET": 0x21 * 4,  # REQ
        "REG_REQ_DATA2_OFFSET": 0x22 * 4,  # REQ
        "REG_REQ_DATA3_OFFSET": 0x23 * 4,  # REQ
        "REG_REQ_DATA4_OFFSET": 0x24 * 4,  # REQ
        "REG_REQ_DATA5_OFFSET": 0x25 * 4,  # REQ
        "REG_REQ_DATA6_OFFSET": 0x26 * 4,  # REQ
        "REG_REQ_DATA7_OFFSET": 0x27 * 4,  # REQ
        "REG_REQ_DATA8_OFFSET": 0x28 * 4,  # REQ
        "REG_REQ_DATA9_OFFSET": 0x29 * 4,  # REQ
        "REG_REQ_DATAA_OFFSET": 0x2A * 4,  # REQ
        "REG_REQ_DATAB_OFFSET": 0x2B * 4,  # REQ
        "REG_REQ_DATAC_OFFSET": 0x2C * 4,  # REQ
        "REG_REQ_DATAD_OFFSET": 0x2D * 4,  # REQ
        "REG_REQ_DATAE_OFFSET": 0x2E * 4,  # REQ
        "REG_REQ_DATAF_OFFSET": 0x2F * 4,  # REQ  DATA F
        "REG_REQ_RD_STATUS0_OFFSET": 0x30 * 4,  # REQ RD STATUS0
        "REG_REQ_RD_STATUS1_OFFSET": 0x31 * 4,  # REQ RD STATUS1
        "REG_REQ_ABORT_WAIT_LSB_OFFSET": 0x32 * 4,  # REQ ABORT WAIT LSB
        "REG_REQ_ABORT_WAIT_MSB_OFFSET": 0x33 * 4,  # REQ ABORT WAIT MSB
        "REG_REQ_ERR_INJ_OFFSET": 0x41 * 4,  # REQ ABORT WAIT LSB
        "REG_REQ_ERR_VALUE_OFFSET": 0x42 * 4,  # REQ ERROR VALUE
        "REG_MST_CLOCKSEL_OFFSET": 0xFF * 4,  # REQ ERROR VALUE

    }

    # MASTER REGISTERS
    REG_MASTER_CNTRL_OFFSET = 0x00 * 4
    REG_ID_OFFSET = 0x00 * 4
    REG_VERSION_OFFSET = 0x01 * 4
    REG_INT_MASK = 0x02 * 4
    REG_INT_STATUS = 0x03 * 4
    REG_HD1_OFFSET = 0x04 * 4
    REG_HD2_OFFSET = 0x05 * 4
    REG_HD3_OFFSET = 0x06 * 4
    REG_PE_OFFSET = 0x07 * 4
    REG_RC_OFFSET = 0x08 * 4
    REG_RD0_OFFSET = 0x09 * 4
    REG_RD1_OFFSET = 0x0A * 4
    REG_RD2_OFFSET = 0x0B * 4
    REG_RD3_OFFSET = 0x0C * 4
    REG_TS_OFFSET = 0x0D * 4
    REG_STC_OFFSET = 0x0E * 4
    REG_DDBA_OFFSET = 0x0F * 4
    REG_REQ_PRES_OFFSET = 0x10 * 4
    REG_REQ_COMMAND_OFFSET = 0x11 * 4
    REG_REQ_SLVA_BC_OFFSET = 0x12 * 4
    REG_REQ_ADDRLO_OFFSET = 0x13 * 4
    REG_REQ_ADDRHI_OFFSET = 0x14 * 4
    REG_REQ_STATUS_OFFSET = 0x15 * 4
    REG_REQ_DATA0_OFFSET = 0x20 * 4  # REQ DATA 0
    REG_REQ_DATA1_OFFSET = 0x21 * 4  # REQ
    REG_REQ_DATA2_OFFSET = 0x22 * 4  # REQ
    REG_REQ_DATA3_OFFSET = 0x23 * 4  # REQ
    REG_REQ_DATA4_OFFSET = 0x24 * 4  # REQ DATA 0
    REG_REQ_DATA5_OFFSET = 0x25 * 4  # REQ
    REG_REQ_DATA6_OFFSET = 0x26 * 4  # REQ
    REG_REQ_DATA7_OFFSET = 0x27 * 4  # REQ
    REG_REQ_DATA8_OFFSET = 0x28 * 4  # REQ DATA 0
    REG_REQ_DATA9_OFFSET = 0x29 * 4  # REQ
    REG_REQ_DATAA_OFFSET = 0x2A * 4  # REQ
    REG_REQ_DATAB_OFFSET = 0x2B * 4  # REQ
    REG_REQ_DATAC_OFFSET = 0x2C * 4  # REQ DATA 0
    REG_REQ_DATAD_OFFSET = 0x2D * 4  # REQ
    REG_REQ_DATAE_OFFSET = 0x2E * 4  # REQ
    REG_REQ_DATAF_OFFSET = 0x2F * 4  # REQ
    REG_REQ_RD_STATUS0_OFFSET = 0x30 * 4  # REQ RD STATUS0
    REG_REQ_RD_STATUS1_OFFSET = 0x31 * 4  # REQ RD STATUS1

    # SLAVE REGISTERS
    REG_CONTROL_OFFSET = (0x400) * 4
    REG_REQ_SLV_COMMAND_OFFSET = (0x400 + 0x40) * 4
    REG_SET_SLAVE_ID_OFFSET = (0x400 + 0x41) * 4
    REG_REQ_SLV_ADDRLO_OFFSET = (0x400 + 0x42) * 4
    REG_REQ_SLV_ADDRHI_OFFSET = (0x400 + 0x43) * 4
    REG_REQ_SLV_DATA0_OFFSET = (0x400 + 0xA0) * 4

    def __init__(self, base_addr):
        self.ctrl = DummySPMIController(base_addr, 0x2000)

    def close(self):
        self.ctrl.close()

    def device_initialize(self, device_type, device_id, f_tclk, ddba_addr, inten, enr):
        # Calculate the TS according to the Tclk frequency
        srpc_val = int(64.0 * f_tclk)
        btpc_val = int(96.0 * f_tclk)
        if btpc_val > ((1 << 16) - 1):
            raise ValueError("Tclk frequency too high to program the TS.")

        # Write parameters
        self.ctrl.write(self.REG_ID_OFFSET, device_id | (randint() << 2))  # device ID, unused bits
        self.ctrl.write(self.REG_TS_OFFSET, srpc_val << 16 | btpc_val)  # timer setup
        self.ctrl.write(self.REG_DDBA_OFFSET, ddba_addr)  # device descriptor block address
        # Enable Device
        self.ctrl.write(self.REG_STC_OFFSET, enr << 8)
        return 0

    def device_disable(self):
        # Disconnected Master master priority level 4
        enr_val = self.ctrl.read(self.REG_STC_OFFSET)
        enr_val &= ~(1 << 8)
        self.ctrl.write(self.REG_STC_OFFSET, enr_val)
        return 0

    def device_enable(self):
        enr_val = self.ctrl.read(self.REG_REQ_COMMAND_OFFSET)  # JAA was REG_INT_MASK
        return 0

    def dump_registers(self):
        dump_str = []
        for name, offset in self.offsets.items():
            val = self.ctrl.read(offset)
            dump_str.append(hex(offset) + ":\t" + name + "\t" + hex(val))
            # print(name[4:-7] + ": " + hex(val))
        return dump_str

    def poll_command_sent_flag(self, clear_all_flags=True):
        """
        check periodically if CSF flag is set
        """
        # Wait for flags(complete, error)
        intf_reg = self.ctrl.read(self.REG_INTF_OFFSET)  # int
        while not bool(
                intf_reg & (1 << 9)):  # || intf_reg[12] != 'b0):  # command sent flag is active or unknown command
            sleep(0.000005)  # wait 5us
            intf_reg = self.ctrl.read(self.REG_INTF_OFFSET)  # int
        if clear_all_flags:
            self.ctrl.write(self.REG_INTF_OFFSET, 0x0)  # clear all flags
        return 0

    def wait(self):
        """
        wait
        polls the command req register until the master clears the 0 bit
        """
        count = 0
        while self.ctrl.read(self.REG_REQ_COMMAND_OFFSET) & 0x01:
            count = count + 1  # reads take about 20 usec
            if count >= 50:  # about 1ms, time out, throw exception
                timeout_err = Spmi_timeout("Bus timeout: Could not issue command")
                raise timeout_err
        return 0

    def send_test_cmd(self, device_type, device_id, cmd_code, data):
        pass

    def master_write(self, master_id, address, data, use_a_bit=False, use_sr_bit=False):
        """
        Master write
        Limits set by Figure 55 of MIPI SPMI Spec v2.0
        :param master_id: Master ID
        :param address: register address
        :param data: 8-bit payload
        :param use_a_bit: High priority arbitration
        :param use_sr_bit: Low priority arbitration
        """
        if master_id > 0x3 or master_id < 0:
            raise ValueError("slave_id must be 2-bit: " + hex(master_id))
        if address > 0xFF or address < 0:
            raise ValueError("address must be 8-bit: " + hex(address))
        if data > 0xFF or data < 0:
            raise Exception("data must be 8-bit: " + hex(data))

        # New smartDV
        self.ctrl.write(self.REG_REQ_SLV_DATA0_OFFSET, (data & 0xFF))

        self.ctrl.write(self.REG_REQ_SLV_ADDRLO_OFFSET, (address & 0xff))
        self.ctrl.write(self.REG_REQ_SLV_ADDRHI_OFFSET, ((address >> 8) & 0xff))

        slvc = 0
        if use_a_bit == 1:
            slvc = 2
        slvc = slvc + 32

        self.ctrl.write(self.REG_REQ_SLV_COMMAND_OFFSET, slvc)
        self.ctrl.write(self.REG_REQ_SLV_COMMAND_OFFSET, slvc + 1)
        # Cleanup
        # self.ctrl.write(self.REG_REQ_DATA0_OFFSET)
        return 0

    def master_read(self, master_id, address, size, use_a_bit=False, use_sr_bit=False):
        """
        Extended read from slave register
        Limits set by Figure 55 of MIPI SPMI Spec v2.0

        :param slave_id: Slave ID
        :param address: register address
        :param size: number of bytes to read
        :param use_a_bit: High priority arbitration
        :param use_sr_bit: Low priority arbitration
        """
        if master_id > 0x3 or master_id < 0:
            raise ValueError("slave_id must be 2-bit: " + hex(master_id))
        if address > 0xFF or address < 0:
            raise ValueError("address must be 8-bit: " + hex(address))
        if size > 16 or size < 1:
            raise ValueError("size is out of range: " + hex(size))

        # hd_offsets = [self.REG_REQ_DAT A0_OFFSET]
        self.ctrl.write(self.REG_REQ_SLV_ADDRLO_OFFSET, (address & 0xff))
        self.ctrl.write(self.REG_REQ_SLV_ADDRHI_OFFSET, ((address >> 8) & 0xff))

        slvc = 0
        if (use_a_bit == 1):
            slvc = 2

        slvc = slvc + 28

        self.ctrl.write(self.REG_REQ_SLV_COMMAND_OFFSET, slvc)  # Drive read command out
        self.ctrl.write(self.REG_REQ_SLV_COMMAND_OFFSET, slvc + 1)

        datause = self.ctrl.read(self.REG_REQ_SLV_DATA0_OFFSET)
        return datause  # i64 FOR NOW

    def extended_register_write(self, slave_id, address, data, priority):
        """
        Extended write to slave register
        Limits set by Figure 55 of MIPI SPMI Spec v2.0

        :param slave_id: Slave ID
        :param address: register address
        :param data: 16-byte payload
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        """
        if slave_id > 0xF or slave_id < 0:
            raise ValueError("slave_id must be 4-bit: " + hex(slave_id))
        if address > 0xFF or address < 0:
            raise ValueError("address must be 8-bit: " + hex(address))
        juke = data
        junk = len(data)
        if len(data) > 16:
            raise ValueError("data must be less than 16 bytes: " + str(len(data)) + "bytes")

        hd_offsets = [self.REG_REQ_DATA0_OFFSET, self.REG_REQ_DATA1_OFFSET, self.REG_REQ_DATA2_OFFSET,
                      self.REG_REQ_DATA3_OFFSET,
                      self.REG_REQ_DATA4_OFFSET, self.REG_REQ_DATA5_OFFSET, self.REG_REQ_DATA6_OFFSET,
                      self.REG_REQ_DATA7_OFFSET,
                      self.REG_REQ_DATA8_OFFSET, self.REG_REQ_DATA9_OFFSET, self.REG_REQ_DATAA_OFFSET,
                      self.REG_REQ_DATAB_OFFSET,
                      self.REG_REQ_DATAC_OFFSET, self.REG_REQ_DATAD_OFFSET, self.REG_REQ_DATAE_OFFSET,
                      self.REG_REQ_DATAF_OFFSET
                      ]

        packetsize = len(data)
        for i in range(0, len(data)):
            valy = data[i]

            self.ctrl.write(hd_offsets[(i)], valy)

        datalen_slavid = ((packetsize - 1) << 4) | (slave_id & 0xF)

        self.ctrl.write(self.REG_REQ_SLVA_BC_OFFSET, datalen_slavid)  # (slave_id & 0xF))

        self.ctrl.write(self.REG_REQ_ADDRLO_OFFSET, (address & 0xFF))
        self.ctrl.write(self.REG_REQ_ADDRHI_OFFSET, ((address >> 8) & 0xFF))

        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x08 + ((priority << 1) & 0x2))  # Drive read command out
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x09 + ((priority << 1) & 0x2))
        self.wait()
        self.ctrl.write(self.REG_INT_STATUS, 0x02)  # clear int mask

        status = self.ctrl.read(self.REG_REQ_STATUS_OFFSET)
        

        if status & 0x01:  # Bit 0 -> NACK for write thing
            arb_err = Spmi_arb_failure(
                "extended_register_write: Received NACK on write to slave ID  " + str(slave_id))
            raise arb_err
        if status & 0x02:  # Bit 1 -> Parity error
            arb_err = Spmi_arb_failure(
                "extended_register_write: Received parity error detection on write to slave ID  " + str(slave_id))
            raise arb_err

        return 0

    def set_master_req_prescaler(self, rate):
        self.ctrl.write(self.REG_REQ_PRES_OFFSET, rate)
        return 0

    def extended_register_read(self, slave_id, address, size, priority):
        """
        Extended read from slave register
        Limits set by Figure 55 of MIPI SPMI Spec v2.0

        :param slave_id: Slave ID
        :param address: register address
        :param size: number of bytes to read
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        """
        if slave_id > 0xF or slave_id < 0:
            raise ValueError("slave_id must be 4-bit: " + hex(slave_id))
        if address > 0xFF or address < 0:
            raise ValueError("address must be 8-bit: " + hex(address))
        if size > 16 or size < 1:
            raise ValueError("size is out of range: " + hex(size))
        
        hd_offsets = [self.REG_REQ_DATA0_OFFSET, self.REG_REQ_DATA1_OFFSET, self.REG_REQ_DATA2_OFFSET,
                      self.REG_REQ_DATA3_OFFSET,
                      self.REG_REQ_DATA4_OFFSET, self.REG_REQ_DATA5_OFFSET, self.REG_REQ_DATA6_OFFSET,
                      self.REG_REQ_DATA7_OFFSET,
                      self.REG_REQ_DATA8_OFFSET, self.REG_REQ_DATA9_OFFSET, self.REG_REQ_DATAA_OFFSET,
                      self.REG_REQ_DATAB_OFFSET,
                      self.REG_REQ_DATAC_OFFSET, self.REG_REQ_DATAD_OFFSET, self.REG_REQ_DATAE_OFFSET,
                      self.REG_REQ_DATAF_OFFSET
                      ]

        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0)
        datalen_slavid = ((size - 1) << 4) | (slave_id & 0xF)

        self.ctrl.write(self.REG_REQ_SLVA_BC_OFFSET, datalen_slavid)  # (slave_id & 0xF))

        self.ctrl.write(self.REG_REQ_ADDRLO_OFFSET, (address & 0xFF))
        self.ctrl.write(self.REG_REQ_ADDRHI_OFFSET, ((address >> 8) & 0xFF))

        self.ctrl.write(self.REG_REQ_DATA0_OFFSET, 0)  # Clear first data location
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x0c + ((priority << 1) & 0x2))  # Drive read command out
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x0d + ((priority << 1) & 0x2))
        self.wait()
        self.ctrl.write(self.REG_INT_STATUS, 0x02)  # clear int mask

        sts0 = self.ctrl.read(self.REG_REQ_RD_STATUS0_OFFSET)
        sts1 = self.ctrl.read(self.REG_REQ_RD_STATUS1_OFFSET)

        datause = []
        for i in range(0, size):
            result = self.ctrl.read(hd_offsets[(i)])
            datause.append(result)
        
        # Check REQ_RD_STATUS0 for arb error
        if sts0 or sts1:
            arb_err = Spmi_arb_failure("extended_register_read: Parity error or no response on read to slave ID  " + str(slave_id))
            self.ctrl.write(self.REG_REQ_RD_STATUS0_OFFSET, 0)
            self.ctrl.write(self.REG_REQ_RD_STATUS1_OFFSET, 0)
            raise arb_err

        return datause  # list<i16>

    def extended_register_write_long(self, slave_id, address, data, priority):
        """
        Extended write to slave register using 16-bit address
        Limits set by Figure 55 of MIPI SPMI Spec v2.0

        :param slave_id: Slave ID
        :param address: register address
        :param data: 16-byte payload
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        """
        if slave_id > 0xF or slave_id < 0:
            raise ValueError("slave_id must be 4-bit: " + hex(slave_id))
        if address > 0xFFFF or address < 0:
            raise ValueError("address must be 16-bit: " + hex(address))
        if len(data) > 16:
            raise ValueError("data must be less than 8 bytes: " + str(len(data)) + "bytes")

        hd_offsets = [self.REG_REQ_DATA0_OFFSET, self.REG_REQ_DATA1_OFFSET, self.REG_REQ_DATA2_OFFSET,
                      self.REG_REQ_DATA3_OFFSET,
                      self.REG_REQ_DATA4_OFFSET, self.REG_REQ_DATA5_OFFSET, self.REG_REQ_DATA6_OFFSET,
                      self.REG_REQ_DATA7_OFFSET,
                      self.REG_REQ_DATA8_OFFSET, self.REG_REQ_DATA9_OFFSET, self.REG_REQ_DATAA_OFFSET,
                      self.REG_REQ_DATAB_OFFSET,
                      self.REG_REQ_DATAC_OFFSET, self.REG_REQ_DATAD_OFFSET, self.REG_REQ_DATAE_OFFSET,
                      self.REG_REQ_DATAF_OFFSET
                      ]

        packetsize = len(data)
        for i in range(0, len(data)):
            valy = data[i]
            self.ctrl.write(hd_offsets[i], valy)

        datalen_slavid = ((packetsize - 1) << 4) | (slave_id & 0xF)

        self.ctrl.write(self.REG_REQ_SLVA_BC_OFFSET, datalen_slavid)  # (slave_id & 0xF))

        self.ctrl.write(self.REG_REQ_ADDRLO_OFFSET, (address & 0xFF))
        self.ctrl.write(self.REG_REQ_ADDRHI_OFFSET, ((address >> 8) & 0xFF))

        # self.ctrl.write(self.REG_REQ_DATA0_OFFSET, 0)  # Clear first data location
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x10 + ((priority << 1) & 0x2))  # Drive read command out
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x11 + ((priority << 1) & 0x2))
        self.wait()

        self.ctrl.write(self.REG_INT_STATUS, 0x02)  # clear int mask

        status = self.ctrl.read(self.REG_REQ_STATUS_OFFSET)
        
        if status & 0x01:  # Bit 0 -> NACK for write thing
            arb_err = Spmi_arb_failure("extended_register_write_long: Received NACK on write to slave ID  " + str(slave_id))
            raise arb_err
        if status & 0x02:  # Bit 1 -> Parity error
            arb_err = Spmi_arb_failure(
                "extended_register_write_long: Received parity error detection on write to slave ID  " + str(slave_id))
            raise arb_err
        return 0

    def extended_register_read_long(self, slave_id, address, size, priority):
        """
        Extended read from slave register using 16-bit address
        Limits set by Figure 55 of MIPI SPMI Spec v2.0

        :param slave_id: Slave ID
        :param address: register address
        :param size: number of bytes to read
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        """
        if slave_id > 0xF or slave_id < 0:
            raise ValueError("slave_id must be 4-bit: " + hex(slave_id))
        if address > 0xFFFF or address < 0:
            raise ValueError("address must be 16-bit: " + hex(address))
        if size > 16 or size < 1:
            raise ValueError("size is out of range: " + hex(size))

        hd_offsets = [self.REG_REQ_DATA0_OFFSET, self.REG_REQ_DATA1_OFFSET, self.REG_REQ_DATA2_OFFSET,
                      self.REG_REQ_DATA3_OFFSET,
                      self.REG_REQ_DATA4_OFFSET, self.REG_REQ_DATA5_OFFSET, self.REG_REQ_DATA6_OFFSET,
                      self.REG_REQ_DATA7_OFFSET,
                      self.REG_REQ_DATA8_OFFSET, self.REG_REQ_DATA9_OFFSET, self.REG_REQ_DATAA_OFFSET,
                      self.REG_REQ_DATAB_OFFSET,
                      self.REG_REQ_DATAC_OFFSET, self.REG_REQ_DATAD_OFFSET, self.REG_REQ_DATAE_OFFSET,
                      self.REG_REQ_DATAF_OFFSET
                      ]
        #for i in range(0, size):
        #    self.ctrl.write(hd_offsets[i], 0)
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0)
        datalen_slavid = ((size - 1) << 4) | (slave_id & 0xF)

        self.ctrl.write(self.REG_REQ_SLVA_BC_OFFSET, datalen_slavid)  # (slave_id & 0xF))

        self.ctrl.write(self.REG_REQ_ADDRLO_OFFSET, (address & 0xFF))
        self.ctrl.write(self.REG_REQ_ADDRHI_OFFSET, ((address >> 8) & 0xFF))

        self.ctrl.write(self.REG_REQ_DATA0_OFFSET, 0)  # Clear first data location
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x14 + ((priority << 1) & 0x2))  # Drive read command out
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x15 + ((priority << 1) & 0x2))
        self.wait()

        self.ctrl.write(self.REG_INT_STATUS, 0x02)  # clear int mask

        sts0 = self.ctrl.read(self.REG_REQ_RD_STATUS0_OFFSET)
        sts1 = self.ctrl.read(self.REG_REQ_RD_STATUS1_OFFSET)

        datause = []
        for i in range(0, size):
            result = self.ctrl.read(hd_offsets[(i)])
            datause.append(result)
        
        if sts0 or sts1:
            arb_err = Spmi_arb_failure("extended_register_read_long: Parity error or no response on read to slave ID  " + str(slave_id))
            self.ctrl.write(self.REG_REQ_RD_STATUS0_OFFSET, 0)
            self.ctrl.write(self.REG_REQ_RD_STATUS1_OFFSET, 0)
            raise arb_err
        return datause  # list<i16>

    def set_slave_addr(self, addr):  # not master api remove
        datause = self.ctrl.read(self.REG_CONTROL_OFFSET)
        datause = datause & 240
        datause = datause | (addr & 0xF)
        self.ctrl.write(self.REG_CONTROL_OFFSET, datause)
        return 0

    def set_master_addr(self, addr):
        datause = self.ctrl.read(self.REG_MASTER_CNTRL_OFFSET)
        datause = datause & 3
        datause = datause | (addr & 0x3)
        self.ctrl.write(self.REG_MASTER_CNTRL_OFFSET, datause)
        return 0

    def set_ip_version(self, version):
        self.ctrl.write(self.REG_VERSION_OFFSET, 1)
        return 0

    def register_write(self, slave_id, address, data, priority):
        """
        Write to slave register. Limits set by Figure 55 of MIPI SPMI Spec v2.0
        :param slave_id: Slave ID
        :param address: register address
        :param data: list 8-bit payload
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        """
        # Set the rate to setting 3 which seems to avoid clearing the slave address
        if not isinstance(data, int):
            data = data[0]
        if slave_id > 0xF or slave_id < 0:
            raise ValueError("slave_id must be 4-bit: " + hex(slave_id))
        # if address > 0x1F or address < 0:
        #     raise ValueError("address must be 5-bit: " + hex(address))
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0)
        self.ctrl.write(self.REG_REQ_SLVA_BC_OFFSET, (slave_id & 0xFF))

        self.ctrl.write(self.REG_REQ_ADDRLO_OFFSET, (address & 0xFF))

        self.ctrl.write(self.REG_REQ_DATA0_OFFSET, (data & 0xFF))

        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x0 + ((priority << 1) & 0x2))
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x1 + ((priority << 1) & 0x2))  # Drive write command out
        self.wait()

        self.ctrl.write(self.REG_INT_STATUS, 0x02)  # clear int mask

        status = self.ctrl.read(self.REG_REQ_STATUS_OFFSET)

        if status & 0x01:  # Bit 0 -> NACK for write thing
            arb_err = Spmi_arb_failure(
                "register_write: Received NACK on write to slave ID  " + str(slave_id))
            raise arb_err
        if status & 0x02:  # Bit 1 -> Parity error
            arb_err = Spmi_arb_failure(
                "register_write: Received parity error detection on write to slave ID  " + str(slave_id))
            raise arb_err

        return 0

    def register_read(self, slave_id, address, priority):
        """
        Read from slave register
        Limits set by Figure 55 of MIPI SPMI Spec v2.0
        :param slave_id: Slave ID
        :param address: register address
        :param priority: arbitration level. 0=secondary master arb, 1=primary master arb
        """
        if slave_id > 0xF or slave_id < 0:
            raise ValueError("slave_id must be 4-bit: " + hex(slave_id))
        # if address > 0x1F or address < 0:
        # raise ValueError("address must be 5-bit: " + hex(address))
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x0)

        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0)
        self.ctrl.write(self.REG_REQ_SLVA_BC_OFFSET, (slave_id & 0xFF))

        self.ctrl.write(self.REG_REQ_ADDRLO_OFFSET, (address & 0xFF))

        self.ctrl.write(self.REG_REQ_DATA0_OFFSET, 0)  # Clear first data location
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x4 + ((priority << 1) & 0x2))  # Drive read command out
        self.ctrl.write(self.REG_REQ_COMMAND_OFFSET, 0x5 + ((priority << 1) & 0x2))
        self.wait()

        self.ctrl.write(self.REG_INT_STATUS, 0x02)  # clear int mask

        sts0 = self.ctrl.read(self.REG_REQ_RD_STATUS0_OFFSET)
        sts1 = self.ctrl.read(self.REG_REQ_RD_STATUS1_OFFSET)

        datause = self.ctrl.read(self.REG_REQ_DATA0_OFFSET)
        if sts0 or sts1:
            self.ctrl.write(self.REG_REQ_RD_STATUS0_OFFSET, 0)
            self.ctrl.write(self.REG_REQ_RD_STATUS1_OFFSET, 0)
            raise Spmi_arb_failure("register_read: Parity error or no response on read to slave ID  " + str(slave_id))

        return datause  # i64

    def poll_for_int(self):
        # enable interrupts on Rx
        self.ctrl.write(self.REG_INT_MASK, 0x01)
        while not self.ctrl.read(self.REG_INT_STATUS) & 0x01:
            pass
        val = self.ctrl.read(0x400)
        # clear int mask by writing a 3
        self.ctrl.write(self.REG_INT_STATUS, 0x03)
        return val
