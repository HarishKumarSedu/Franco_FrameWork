import os
# from math import ceil
from ctypes import *
from dataclasses import dataclass, field
from typing import List, Union
from enum import Enum
from array import array
from fcntl import ioctl
from embedded_thrift_server.dwc_i3c.i3c_device import i3c_device_info, i3c_priv_xfer
from embedded_thrift_server.dwc_i3c.i2c_device import I2C_FLAG_DEF, i2c_device_info, i2c_msg
from embedded_thrift_server.dwc_i3c.i3c_ccc import I3C_CCC_DEF, i3c_ccc_cmd, i3c_ccc_cmd_dest
from embedded_thrift_server.dwc_i3c.linux_common import LinuxCommon


class crus_i3c_reg(Structure):
    _fields_ = [('addr', c_uint32),
                ('val', c_uint32)]


class crus_i3c_io_response(Structure):
    _pack_ = True
    _fields_ = [('error', c_uint8),
                ('rx_len', c_uint16),
                ('rx_buf', c_void_p)]


class crus_i3c_io_response_list(Structure):
    """
    pretty sure this is packed as well
    selecting buffer size of 4 responses just because I feel like it. Test to make it bigger or smaller
    """
    _fields_ = [('num_resps', c_uint32),
                ('resps', crus_i3c_io_response * 4)]


class crus_i3c_io_xfer(Structure):
    _pack_ = True
    _fields_ = [('cmd_lo', c_uint32),
                ('cmd_hi', c_uint32),
                ('tx_len', c_uint16),
                ('tx_buf', c_void_p)]


class crus_i3c_io_xfer_list(Structure):
    """
    pretty sure this is packed as well
    selecting buffer size of 4 xfers just because I feel like it. Test to make it bigger or smaller
    """
    _fields_ = [('num_xfers', c_uint32),
                ('xfers', crus_i3c_io_xfer * 4)]


@dataclass
class dw_i3c_cmd:
    cmd_lo: int = 0  # u32
    cmd_hi: int = 0  # u32
    tx_len: int = 0  # u16
    tx_buf: bytearray = field(default_factory=bytearray)  # const void *
    rx_len: int = 0  # u16
    rx_buf: bytearray = field(default_factory=bytearray)  # void *
    error: Union[int, str, None] = None


class dw_i3c_xfer:
    def __init__(self, ncmds: int = 1):
        self.comp: bool = False
        self.cmds: List[dw_i3c_cmd] = []
        for _ in range(ncmds):
            self.cmds.append(dw_i3c_cmd())
        self.ret: Union[str, None] = "TimedOut"


class i3c_bus_mode(Enum):
    """
    enum i3c_bus_mode - I3C bus mode
    @I3C_BUS_MODE_PURE: only I3C devices are connected to the bus. No limitation expected
    @I3C_BUS_MODE_MIXED_FAST: I2C devices with 50ns spike filter are present on
                    the bus. The only impact in this mode is that the
                    high SCL pulse has to stay below 50ns to trick I2C
                    devices when transmitting I3C frames
    @I3C_BUS_MODE_MIXED_LIMITED: I2C devices without 50ns spike filter are
                    present on the bus. However they allow
                    compliance up to the maximum SDR SCL clock frequency.
    @I3C_BUS_MODE_MIXED_SLOW: I2C devices without 50ns spike filter are present on the bus
    """
    I3C_BUS_MODE_PURE = 0
    I3C_BUS_MODE_MIXED_FAST = 1
    I3C_BUS_MODE_MIXED_LIMITED = 2
    I3C_BUS_MODE_MIXED_SLOW = 3


class i3c_addr_slot_status(Enum):
    """
    enum i3c_addr_slot_status - I3C address slot status
    @I3C_ADDR_SLOT_FREE: address is free
    @I3C_ADDR_SLOT_RSVD: address is reserved
    @I3C_ADDR_SLOT_I2C_DEV: address is assigned to an I2C device
    @I3C_ADDR_SLOT_I3C_DEV: address is assigned to an I3C device
    @I3C_ADDR_SLOT_STATUS_MASK: address slot mask

    On an I3C bus, addresses are assigned dynamically, and we need to know which
    addresses are free to use and which ones are already assigned.

    Addresses marked as reserved are those reserved by the I3C protocol
    (broadcast address, ...).
    """
    I3C_ADDR_SLOT_FREE = 0
    I3C_ADDR_SLOT_RSVD = 1
    I3C_ADDR_SLOT_I2C_DEV = 2
    I3C_ADDR_SLOT_I3C_DEV = 3


@dataclass
class dw_i3c_master_caps:
    cmdfifodepth: int  # u8
    datafifodepth: int  # u8


class DwcI3c(LinuxCommon):

    CRUS_I3C_MAGIC_NUMBER = 0x594CAE10

    @classmethod
    def CRUS_I3C_QUEUE_XFERS(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 1, 32)

    @classmethod
    def CRUS_I3C_FLUSH_XFERS(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 2, 32)

    @classmethod
    def CRUS_I3C_POP_RESPONSES(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 3, 32)

    @classmethod
    def CRUS_I3C_NUM_XFERS(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 4, 32)

    @classmethod
    def CRUS_I3C_NUM_RESPONSES(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 5, 32)

    @classmethod
    def CRUS_I3C_CLEAR_XFERS(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 6, 32)

    @classmethod
    def CRUS_I3C_CLEAR_RESPONSES(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 7, 32)

    @classmethod
    def CRUS_I3C_FAKE_RESPONSE(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 8, 32)

    @classmethod
    def CRUS_I3C_READ_CTLR_REG(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 11, 32)

    @classmethod
    def CRUS_I3C_WRITE_CTLR_REG(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 12, 32)

    @classmethod
    def CRUS_I3C_REGISTER_TASK(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 21, 32)

    @classmethod
    def CRUS_I3C_UNREGISTER_TASK(cls):
        return cls._IOWR(cls.CRUS_I3C_MAGIC_NUMBER, 22, 32)

    I3C_BROADCAST_ADDR = 0x7e

    @classmethod
    def I3C_MAX_ADDR(cls):
        return cls.GENMASK(6, 0)

    @classmethod
    def I3C_LVR_I2C_INDEX_MASK(cls):
        return cls.GENMASK(7, 5)

    @classmethod
    def I3C_LVR_I2C_INDEX(cls, x):
        return x << 5

    @classmethod
    def I3C_LVR_I2C_FM_MODE(cls):
        return cls.BIT(4)

    @classmethod
    def I2C_MAX_ADDR(cls):
        return cls.GENMASK(6, 0)

    """
    The I3C specification says the maximum number of devices connected on the
    bus is 11, but this number depends on external parameters like trace length,
    capacitive load per Device, and the types of Devices present on the Bus.
    I3C master can also have limitations, so this number is just here as a
    reference and should be adjusted on a per-controller/per-board basis.
    """
    I3C_BUS_MAX_DEVS = 11

    I3C_BUS_MAX_I3C_SCL_RATE = 12900000
    I3C_BUS_TYP_I3C_SCL_RATE = 12500000
    I3C_BUS_I2C_FM_PLUS_SCL_RATE = 1000000
    I3C_BUS_I2C_FM_SCL_RATE = 400000
    I3C_BUS_TLOW_OD_MIN_NS = 200

    DEVICE_CTRL = 0x0
    DEV_CTRL_ENABLE = 1 << 31
    DEV_CTRL_RESUME = 1 << 30
    DEV_CTRL_HOT_JOIN_NACK = 1 << 8
    DEV_CTRL_I2C_SLAVE_PRESENT = 1 << 7

    DEVICE_ADDR = 0x4
    DEV_ADDR_DYNAMIC_ADDR_VALID = 1 << 31

    @classmethod
    def DEV_ADDR_DYNAMIC(cls, x: int):
        return (x << 16) & cls.GENMASK(22, 16)

    HW_CAPABILITY = 0x8
    COMMAND_QUEUE_PORT = 0xc
    COMMAND_PORT_TOC = 1 << 30
    COMMAND_PORT_READ_TRANSFER = 1 << 28
    COMMAND_PORT_SDAP = 1 << 27
    COMMAND_PORT_ROC = 1 << 26

    @classmethod
    def COMMAND_PORT_SPEED(cls, x):
        return (x << 21) & cls.GENMASK(23, 21)

    @classmethod
    def COMMAND_PORT_DEV_INDEX(cls, x):
        return (x << 16) & cls.GENMASK(20, 16)

    COMMAND_PORT_CP = 1 << 15

    @classmethod
    def COMMAND_PORT_CMD(cls, x):
        return (x << 7) & cls.GENMASK(14, 7)

    @classmethod
    def COMMAND_PORT_TID(cls, x):
        return (x << 3) & cls.GENMASK(6, 3)

    @classmethod
    def COMMAND_PORT_ARG_DATA_LEN(cls, x):
        return (x << 16) & cls.GENMASK(31, 16)

    COMMAND_PORT_ARG_DATA_LEN_MAX = 65536
    COMMAND_PORT_TRANSFER_ARG = 0x01

    @classmethod
    def COMMAND_PORT_SDA_DATA_BYTE_3(cls, x):
        return (x << 24) & cls.GENMASK(31, 24)

    @classmethod
    def COMMAND_PORT_SDA_DATA_BYTE_2(cls, x):
        return (x << 16) & cls.GENMASK(23, 16)

    @classmethod
    def COMMAND_PORT_SDA_DATA_BYTE_1(cls, x):
        return (x << 8) & cls.GENMASK(15, 8)

    COMMAND_PORT_SDA_BYTE_STRB_3 = 1 << 5
    COMMAND_PORT_SDA_BYTE_STRB_2 = 1 << 4
    COMMAND_PORT_SDA_BYTE_STRB_1 = 1 << 3
    COMMAND_PORT_SHORT_DATA_ARG = 0x02

    @classmethod
    def COMMAND_PORT_DEV_COUNT(cls, x):
        return (x << 21) & cls.GENMASK(25, 21)

    COMMAND_PORT_ADDR_ASSGN_CMD = 0x03

    RESPONSE_QUEUE_PORT = 0x10

    @classmethod
    def RESPONSE_PORT_ERR_STATUS(cls, x):
        return (x & cls.GENMASK(31, 28)) >> 28

    RESPONSE_NO_ERROR = 0
    RESPONSE_ERROR_CRC = 1
    RESPONSE_ERROR_PARITY = 2
    RESPONSE_ERROR_FRAME = 3
    RESPONSE_ERROR_IBA_NACK = 4
    RESPONSE_ERROR_ADDRESS_NACK = 5
    RESPONSE_ERROR_OVER_UNDER_FLOW = 6
    RESPONSE_ERROR_TRANSF_ABORT = 8
    RESPONSE_ERROR_I2C_W_NACK_ERR = 9

    @classmethod
    def RESPONSE_PORT_TID(cls, x):
        return (x & cls.GENMASK(27, 24)) >> 24

    @classmethod
    def RESPONSE_PORT_DATA_LEN(cls, x):
        return x & cls.GENMASK(15, 0)

    RX_TX_DATA_PORT = 0x14
    IBI_QUEUE_STATUS = 0x18
    IBI_QUEUE_DATA = 0x18  # Yes, these^ are mapped to the same reg offset
    QUEUE_THLD_CTRL = 0x1c

    @classmethod
    def QUEUE_THLD_CTRL_IBI_STATUS_MASK(cls):
        return cls.GENMASK(31, 24)

    @classmethod
    def QUEUE_THLD_CTRL_IBI_STATUS(cls, x):
        return (x - 1) << 24

    @classmethod
    def QUEUE_THLD_CTRL_IBI_DATA_MASK(cls):
        return cls.GENMASK(23, 16)

    @classmethod
    def QUEUE_THLD_CTRL_IBI_DATA(cls, x):
        return (x - 1) << 16

    @classmethod
    def QUEUE_THLD_CTRL_RESP_BUF_MASK(cls):
        return cls.GENMASK(15, 8)

    @classmethod
    def QUEUE_THLD_CTRL_RESP_BUF(cls, x):
        return (x - 1) << 8

    DATA_BUFFER_THLD_CTRL = 0x20

    @classmethod
    def DATA_BUFFER_THLD_CTRL_RX_BUF(cls):
        return cls.GENMASK(11, 8)

    IBI_QUEUE_CTRL = 0x24
    IBI_MR_REQ_REJECT = 0x2C
    IBI_SIR_REQ_REJECT = 0x30

    @classmethod
    def IBI_REQ_REJECT_ALL(cls):
        return cls.GENMASK(31, 0)

    RESET_CTRL = 0x34
    RESET_CTRL_IBI_QUEUE = 1 << 5
    RESET_CTRL_RX_FIFO = 1 << 4
    RESET_CTRL_TX_FIFO = 1 << 3
    RESET_CTRL_RESP_QUEUE = 1 << 2
    RESET_CTRL_CMD_QUEUE = 1 << 1
    RESET_CTRL_SOFT = 1 << 0

    SLV_EVENT_CTRL = 0x38
    INTR_STATUS = 0x3c
    INTR_STATUS_EN = 0x40
    INTR_SIGNAL_EN = 0x44
    INTR_FORCE = 0x48
    INTR_BUSOWNER_UPDATE_STAT = 1 << 13
    INTR_IBI_UPDATED_STAT = 1 << 12
    INTR_READ_REQ_RECV_STAT = 1 << 11
    INTR_DEFSLV_STAT = 1 << 10
    INTR_TRANSFER_ERR_STAT = 1 << 9
    INTR_DYN_ADDR_ASSGN_STAT = 1 << 8
    INTR_CCC_UPDATED_STAT = 1 << 6
    INTR_TRANSFER_ABORT_STAT = 1 << 5
    INTR_RESP_READY_STAT = 1 << 4
    INTR_CMD_QUEUE_READY_STAT = 1 << 3
    INTR_IBI_THLD_STAT = 1 << 2
    INTR_RX_THLD_STAT = 1 << 1
    INTR_TX_THLD_STAT = 1 << 0
    INTR_ALL = (INTR_BUSOWNER_UPDATE_STAT |
                INTR_IBI_UPDATED_STAT |
                INTR_READ_REQ_RECV_STAT |
                INTR_DEFSLV_STAT |
                INTR_TRANSFER_ERR_STAT |
                INTR_DYN_ADDR_ASSGN_STAT |
                INTR_CCC_UPDATED_STAT |
                INTR_TRANSFER_ABORT_STAT |
                INTR_RESP_READY_STAT |
                INTR_CMD_QUEUE_READY_STAT |
                INTR_IBI_THLD_STAT |
                INTR_TX_THLD_STAT |
                INTR_RX_THLD_STAT)

    INTR_MASTER_MASK = INTR_TRANSFER_ERR_STAT | INTR_RESP_READY_STAT | INTR_IBI_THLD_STAT

    QUEUE_STATUS_LEVEL = 0x4c

    @classmethod
    def QUEUE_STATUS_IBI_STATUS_CNT(cls, x):
        return (x & cls.GENMASK(28, 24)) >> 24

    @classmethod
    def QUEUE_STATUS_IBI_BUF_BLR(cls, x):
        return (x & cls.GENMASK(23, 16)) >> 16

    @classmethod
    def QUEUE_STATUS_LEVEL_RESP(cls, x):
        return (x & cls.GENMASK(15, 8)) >> 8

    @classmethod
    def QUEUE_STATUS_LEVEL_CMD(cls, x):
        return x & cls.GENMASK(7, 0)

    DATA_BUFFER_STATUS_LEVEL = 0x50

    @classmethod
    def DATA_BUFFER_STATUS_LEVEL_TX(cls, x):
        return x & cls.GENMASK(7, 0)

    PRESENT_STATE = 0x54
    CCC_DEVICE_STATUS = 0x58
    DEVICE_ADDR_TABLE_POINTER = 0x5c

    @classmethod
    def DEVICE_ADDR_TABLE_DEPTH(cls, x):
        return (x & cls.GENMASK(31, 16)) >> 16

    @classmethod
    def DEVICE_ADDR_TABLE_ADDR(cls, x):
        return x & cls.GENMASK(7, 0)

    DEV_CHAR_TABLE_POINTER = 0x60
    VENDOR_SPECIFIC_REG_POINTER = 0x6c
    SLV_PID_VALUE = 0x74
    SLV_CHAR_CTRL = 0x78
    SLV_MAX_LEN = 0x7c
    MAX_READ_TURNAROUND = 0x80
    MAX_DATA_SPEED = 0x84
    SLV_DEBUG_STATUS = 0x88
    SLV_INTR_REQ = 0x8c
    DEVICE_CTRL_EXTENDED = 0xb0
    SCL_I3C_OD_TIMING = 0xb4
    SCL_I3C_PP_TIMING = 0xb8

    @classmethod
    def SCL_I3C_TIMING_HCNT(cls, x):
        return (x << 16) & cls.GENMASK(23, 16)

    @classmethod
    def SCL_I3C_TIMING_LCNT(cls, x):
        return x & cls.GENMASK(7, 0)

    SCL_I3C_TIMING_CNT_MIN = 5

    SCL_I2C_FM_TIMING = 0xbc

    @classmethod
    def SCL_I2C_FM_TIMING_HCNT(cls, x):
        return (x << 16) & cls.GENMASK(31, 16)

    @classmethod
    def SCL_I2C_FM_TIMING_LCNT(cls, x):
        return x & cls.GENMASK(15, 0)

    SCL_I2C_FMP_TIMING = 0xc0

    @classmethod
    def SCL_I2C_FMP_TIMING_HCNT(cls, x):
        return (x << 16) & cls.GENMASK(23, 16)

    @classmethod
    def SCL_I2C_FMP_TIMING_LCNT(cls, x):
        return x & cls.GENMASK(15, 0)

    SCL_EXT_LCNT_TIMING = 0xc8

    @classmethod
    def SCL_EXT_LCNT_4(cls, x):
        return (x << 24) & cls.GENMASK(31, 24)

    @classmethod
    def SCL_EXT_LCNT_3(cls, x):
        return (x << 16) & cls.GENMASK(23, 16)

    @classmethod
    def SCL_EXT_LCNT_2(cls, x):
        return (x << 8) & cls.GENMASK(15, 8)

    @classmethod
    def SCL_EXT_LCNT_1(cls, x):
        return x & cls.GENMASK(7, 0)

    SCL_EXT_TERMN_LCNT_TIMING = 0xcc
    BUS_FREE_TIMING = 0xd4

    @classmethod
    def BUS_I3C_MST_FREE(cls, x):
        return x & cls.GENMASK(15, 0)

    BUS_IDLE_TIMING = 0xd8
    I3C_VER_ID = 0xe0
    I3C_VER_TYPE = 0xe4
    EXTENDED_CAPABILITY = 0xe8
    SLAVE_CONFIG = 0xec

    DEV_ADDR_TABLE_LEGACY_I2C_DEV = 1 << 31

    @classmethod
    def DEV_ADDR_TABLE_NACK_RETRY_CNT(cls, x):
        return (x << 29) & cls.GENMASK(30, 29)

    @classmethod
    def DEV_ADDR_TABLE_DYNAMIC_ADDR(cls, x):
        return (x << 16) & cls.GENMASK(23, 16)

    DEV_ADDR_TABLE_MR_REJECT = 1 << 14
    DEV_ADDR_TABLE_SIR_REJECT = 1 << 13
    DEV_ADDR_TABLE_IBI_PAYLOAD = 1 << 12

    @classmethod
    def DEV_ADDR_TABLE_STATIC_ADDR(cls, x):
        return x & cls.GENMASK(6, 0)

    @classmethod
    def DEV_ADDR_TABLE_LOC(cls, start, idx):
        return start + (idx << 2)

    MAX_DEVS = 32

    I3C_BUS_SDR1_SCL_RATE = 8000000
    I3C_BUS_SDR2_SCL_RATE = 6000000
    I3C_BUS_SDR3_SCL_RATE = 4000000
    I3C_BUS_SDR4_SCL_RATE = 2000000
    I3C_BUS_I2C_FM_TLOW_MIN_NS = 1300
    I3C_BUS_I2C_FMP_TLOW_MIN_NS = 500
    I3C_BUS_THIGH_MAX_NS = 41

    XFER_TIMEOUT = '1sec'  # change to int value

    def __init__(self, filename: str, verbose: bool = False, test: bool = False):
        self.i2cboardinfo: List[i2c_device_info] = []
        self.i3cboardinfo: List[i3c_device_info] = []

        self.addrslots: List[i3c_addr_slot_status] = []
        self._i3c_bus_init_addrslots()
        self.mode = i3c_bus_mode.I3C_BUS_MODE_PURE

        self.i3c_scl_rate = 0
        self.i2c_scl_rate = self.I3C_BUS_I2C_FM_PLUS_SCL_RATE
        self.init_done = False
        self.verbose = verbose
        self._devpath: str = filename

        self.addrs = []  # u8[MAX_DEVS] This is the list of used addrs on this bus. Limited to MAX_DEVS num of devs
        for _ in range(self.MAX_DEVS):
            self.addrs.append(0)

        # clock rate (in Hz) for a clock source
        self.core_clk_rate = 125000000

        # This is new C driver
        self._fd = None
        self.test = test
        if not test:
            self._fd = os.open(filename, os.O_RDWR)
            # Disable controller while setting up
            self._dw_i3c_master_disable()
            # Setup IRQ pin
            self.write_reg(self.INTR_STATUS, self.INTR_ALL)

            # Information regarding the FIFOs/QUEUEs depth
            val1 = self.read_reg(self.QUEUE_STATUS_LEVEL)
            val2 = self.read_reg(self.DATA_BUFFER_STATUS_LEVEL)
            self.caps = dw_i3c_master_caps(self.QUEUE_STATUS_LEVEL_CMD(val1), self.DATA_BUFFER_STATUS_LEVEL_TX(val2))

            val3 = self.read_reg(self.DEVICE_ADDR_TABLE_POINTER)
            self.datstartaddr = val3 & 0xFFFF  # u16  Holds start_addr for TABLE supported by controller. Build param
            self.maxdevs = (val3 >> 16) & 0xFFFF  # u16  Holds maxdevs supported by controller. Build param
            self.free_pos = self.GENMASK(self.maxdevs - 1, 0)

            for i2cdev in self.i2cboardinfo:
                lvr = i2cdev.lvr & self.I3C_LVR_I2C_INDEX_MASK()
                if lvr == self.I3C_LVR_I2C_INDEX(0):
                    if self.mode < i3c_bus_mode.I3C_BUS_MODE_MIXED_FAST:
                        self.mode = i3c_bus_mode.I3C_BUS_MODE_MIXED_FAST
                elif lvr == self.I3C_LVR_I2C_INDEX(1):
                    if self.mode < i3c_bus_mode.I3C_BUS_MODE_MIXED_LIMITED:
                        self.mode = i3c_bus_mode.I3C_BUS_MODE_MIXED_LIMITED
                elif lvr == self.I3C_LVR_I2C_INDEX(2):
                    if self.mode < i3c_bus_mode.I3C_BUS_MODE_MIXED_SLOW:
                        self.mode = i3c_bus_mode.I3C_BUS_MODE_MIXED_SLOW
                else:
                    raise ValueError("Invalid LVR for I2C device")

                if lvr & self.I3C_LVR_I2C_FM_MODE():
                    self.i2c_scl_rate = self.I3C_BUS_I2C_FM_SCL_RATE

            self.i3c_bus_set_mode()
            self._i3c_master_bus_init(False)
            self.init_done = True

    def __del__(self):
        self.close()

    def close(self):
        self._dw_i3c_master_disable()
        if self._fd is None:
            return
        try:
            os.close(self._fd)
        except OSError as e:
            print(f"Error closing file descriptor: {e}")
        self._fd = None

    def write_reg(self, addr, data):
        if not self.test:
            reg = crus_i3c_reg()
            reg.addr = addr
            reg.val = data

            ret = ioctl(self._fd, self.CRUS_I3C_WRITE_CTLR_REG(), reg)
            if ret < 0:
                print(f"IOCTL error {ret}")

    def read_reg(self, addr) -> int:
        if not self.test:
            reg = crus_i3c_reg()
            reg.addr = addr
            reg.val = 0

            ret = ioctl(self._fd, self.CRUS_I3C_READ_CTLR_REG(), reg)
            if ret < 0:
                print(f"IOCTL error {ret}")
            return reg.val
        else:
            return 0

    def get_num_xfers(self):
        val = c_uint32(0)
        ret = ioctl(self._fd, self.CRUS_I3C_NUM_XFERS(), val)
        if ret < 0:
            print(f"IOCTL error {ret}")
        return val.value

    def get_num_resps(self):
        val = c_uint32(0)
        ret = ioctl(self._fd, self.CRUS_I3C_NUM_RESPONSES(), val)
        if ret < 0:
            print(f"IOCTL error {ret}")
        return val.value

    def clear_xfers(self):
        ret = ioctl(self._fd, self.CRUS_I3C_CLEAR_XFERS(), 0)
        if ret < 0:
            print(f"IOCTL error {ret}")

    def clear_resps(self):
        ret = ioctl(self._fd, self.CRUS_I3C_CLEAR_RESPONSES(), 0)
        if ret < 0:
            print(f"IOCTL error {ret}")

    def _test_inject_resp(self):
        ret = ioctl(self._fd, self.CRUS_I3C_FAKE_RESPONSE(), 0)
        if ret < 0:
            print(f"IOCTL error {ret}")

    def enqueue_xfer(self, xfer: dw_i3c_xfer):
        xfer_buff = crus_i3c_io_xfer_list()
        xfer_buff.num_xfers = len(xfer.cmds)
        xfers = xfer_buff.xfers
        for i, cmd in enumerate(xfer.cmds):
            xfers[i].cmd_lo = cmd.cmd_lo
            xfers[i].cmd_hi = cmd.cmd_hi
            if cmd.tx_len:
                tbuf = array('B', cmd.tx_buf)
                xfers[i].tx_len = tbuf.buffer_info()[1]
                xfers[i].tx_buf = tbuf.buffer_info()[0]
            else:
                xfers[i].tx_len = 0
                xfers[i].tx_buf = 0
        ret = ioctl(self._fd, self.CRUS_I3C_QUEUE_XFERS(), xfer_buff)
        if ret < 0:
            print(f"IOCTL error {ret}")

    def dequeue_xfer(self, xfer: dw_i3c_xfer):
        expected_nresp = len(xfer.cmds)
        rbufs = []
        resp_buff = crus_i3c_io_response_list()
        resps = resp_buff.resps
        for i in range(expected_nresp):
            rbuf = array('B', bytes(2048))
            resps[i].rx_buf = rbuf.buffer_info()[0]
            rbufs.append(rbuf)

        ret = ioctl(self._fd, self.CRUS_I3C_FLUSH_XFERS(), resp_buff)
        if ret < 0:
            print(f"IOCTL error {ret}")
        ret = ioctl(self._fd, self.CRUS_I3C_POP_RESPONSES(), resp_buff)
        if ret < 0:
            print(f"IOCTL error {ret}")

        ret = None
        nresp = resp_buff.num_resps
        for i in range(nresp):
            rbuf = rbufs[i]
            cmd = xfer.cmds[i]
            cmd.error = resps[i].error
            rx_len = resps[i].rx_len
            cmd.rx_len = rx_len
            if rx_len:
                cmd.rx_buf = rbuf.tobytes()[:rx_len]
            if not resps[i].error == self.RESPONSE_NO_ERROR:
                ret = "Some type of error"
                error = resps[i].error
                if error == self.RESPONSE_ERROR_PARITY:
                    ret = "Parity Error"
                elif error == self.RESPONSE_ERROR_IBA_NACK:
                    ret = "I3C Broadcast Address NACK"
                elif error == self.RESPONSE_ERROR_TRANSF_ABORT:
                    ret = "Transfer Aborted"
                elif error == self.RESPONSE_ERROR_CRC:
                    ret = "CRC Error"
                elif error == self.RESPONSE_ERROR_FRAME:
                    ret = "Frame Error"
                elif error == self.RESPONSE_ERROR_OVER_UNDER_FLOW:
                    ret = "Over Under flow error"
                elif error == self.RESPONSE_ERROR_I2C_W_NACK_ERR:
                    ret = "I2C NACK"
                elif error == self.RESPONSE_ERROR_ADDRESS_NACK:
                    ret = "Address NACK"
                cmd.error = ret

        xfer.ret = ret
        xfer.comp = True

    @staticmethod
    def _even_parity(p: int) -> int:
        """u8 in and u8 out"""
        p ^= p >> 4
        p &= 0xf
        return (0x9669 >> p) & 1

    def _i3c_bus_init_addrslots(self):
        for i in range(self.I3C_MAX_ADDR() + 1):
            self.addrslots.append(i3c_addr_slot_status.I3C_ADDR_SLOT_FREE)

        # Addresses 0 to 7 are reserved
        for i in range(8):
            self.addrslots[i] = i3c_addr_slot_status.I3C_ADDR_SLOT_RSVD

        # Reserve broadcast address and all addresses that might collide
        # with the broadcast address when facing a single bit error.
        self.addrslots[self.I3C_BROADCAST_ADDR] = i3c_addr_slot_status.I3C_ADDR_SLOT_RSVD
        for i in range(7):
            self.addrslots[self.I3C_BROADCAST_ADDR ^ self.BIT(i)] = i3c_addr_slot_status.I3C_ADDR_SLOT_RSVD

    def _i3c_master_search_i2c_dev_by_addr(self, addr: int) -> Union[None, i2c_device_info]:
        """
        _i3c_master_search_i2c_dev_by_addr
        C name: i3c_master_find_i2c_dev_by_addr
        u16 addr"""
        for dev in self.i2cboardinfo:
            if dev.addr == addr:
                return dev
        return None

    def _i3c_master_get_free_addr(self, start_addr: int) -> int:
        for addr in range(start_addr, self.I3C_MAX_ADDR()):
            status: i3c_addr_slot_status = self.addrslots[addr]
            if status == i3c_addr_slot_status.I3C_ADDR_SLOT_FREE:
                return addr

        raise MemoryError(f'No more I3C addresses available')

    def i3c_master_rstdaa_locked(self, addr: int):
        """
        Send RSTDAA CCC to addr
        addr can be BROADCAST or Directed
        Reset Dynamic Addresses
        """
        addrstat = self.addrslots[addr]
        if addr != self.I3C_BROADCAST_ADDR and addrstat != i3c_addr_slot_status.I3C_ADDR_SLOT_I3C_DEV:
            return ValueError()

        dest = i3c_ccc_cmd_dest(addr=addr, payload=bytearray())
        cmd = i3c_ccc_cmd(rnw=False, id=I3C_CCC_DEF.I3C_CCC_RSTDAA(addr == self.I3C_BROADCAST_ADDR), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

    def i3c_master_setaasa_locked(self):
        """
        Send SETAASA CCC to BROADCAST
        Set All Addresses from Static Address
        """
        dest = i3c_ccc_cmd_dest(addr=self.I3C_BROADCAST_ADDR, payload=bytearray())
        cmd = i3c_ccc_cmd(rnw=False, id=I3C_CCC_DEF.I3C_CCC_SETAASA(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

    def i3c_master_entdaa_locked(self):
        """
        i3c_master_entdaa_locked() - start a DAA (Dynamic Address Assignment) procedure

        DK: This is probably not needed in normal operation. Only for Test?

        Send a ENTDAA CCC command to start a DAA procedure.

        Note that this function only sends the ENTDAA CCC command, all the logic
        behind dynamic address assignment has to be handled in the I3C master
        driver.
        """
        dest = i3c_ccc_cmd_dest(addr=self.I3C_BROADCAST_ADDR, payload=bytearray())
        cmd = i3c_ccc_cmd(rnw=False, id=I3C_CCC_DEF.I3C_CCC_ENTDAA(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

    def _i3c_master_enec_disec_locked(self, addr: int, enable: bool, evts: int):
        """u8 addr, bool enable, u8 evts"""
        dest = i3c_ccc_cmd_dest(addr=addr, payload=bytearray([evts]))
        cmd_id = I3C_CCC_DEF.I3C_CCC_ENEC(addr == self.I3C_BROADCAST_ADDR) if enable else \
            I3C_CCC_DEF.I3C_CCC_DISEC(addr == self.I3C_BROADCAST_ADDR)
        cmd = i3c_ccc_cmd(rnw=False, id=cmd_id, dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

    def i3c_master_disec_locked(self, addr: int, evts: int):
        """
        i3c_master_disec_locked() - send a DISEC CCC command
        @addr: a valid I3C slave address or I3C_BROADCAST_ADDR
        @evts: events to disable

        Send a DISEC CCC command to disable some or all events coming from a
        specific slave, or all devices if @addr is %I3C_BROADCAST_ADDR.
        """
        self._i3c_master_enec_disec_locked(addr, False, evts)

    def i3c_master_enec_locked(self, addr: int, evts: int):
        """
        i3c_master_enec_locked() - send an ENEC CCC command
        @addr: a valid I3C slave address or I3C_BROADCAST_ADDR
        @evts: events to disable

        Sends an ENEC CCC command to enable some or all events coming from a
        specific slave, or all devices if @addr is %I3C_BROADCAST_ADDR.
        """
        self._i3c_master_enec_disec_locked(addr, True, evts)

    def _i3c_master_setda_locked(self, oldaddr: int, newaddr: int, setdasa: bool):
        """u8 oldaddr, u8 newaddr"""

        if not oldaddr or not newaddr:
            raise ValueError('Old and new address required')

        # setda.addr = newaddr << 1
        setda_payload = bytearray([newaddr << 1])
        dest = i3c_ccc_cmd_dest(addr=oldaddr, payload=setda_payload)
        cmd_id = I3C_CCC_DEF.I3C_CCC_SETDASA() if setdasa else I3C_CCC_DEF.I3C_CCC_SETNEWDA()
        cmd = i3c_ccc_cmd(rnw=False, id=cmd_id, dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

    def i3c_master_setdasa_locked(self, static_addr: int, dyn_addr: int):
        """
        Send SETDASA CCC to change device from static to dynamic addressing
        Set Dynamic Address from Static Address
        """
        return self._i3c_master_setda_locked(static_addr, dyn_addr, True)

    def i3c_master_setnewda_locked(self, oldaddr: int, newaddr: int):
        """
        Send SETNEWDA CCC to change device from oldaddr to newaddr
        Set New Dynamic Address
        """
        return self._i3c_master_setda_locked(oldaddr, newaddr, False)

    def i3c_master_getmrl_locked(self, info: i3c_device_info):

        mrl_payload = bytearray(3)
        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=mrl_payload)

        # When the device does not have IBI payload GETMRL only returns 2 bytes of data.
        if not (info.bcr & i3c_device_info.I3C_BCR_IBI_PAYLOAD):
            dest.payload = bytearray(len(dest.payload) - 1)

        expected_len = len(dest.payload)
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETMRL(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

        if len(dest.payload) != expected_len:
            raise IOError('Payload length did not match expected length')

        info.max_read_len = int.from_bytes(dest.payload[:2], byteorder='big')

        if info.bcr & i3c_device_info.I3C_BCR_IBI_PAYLOAD:
            info.max_ibi_len = int(dest.payload[2])

    def i3c_master_getmwl_locked(self, info: i3c_device_info):

        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=bytearray(2))
        expected_len = len(dest.payload)
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETMWL(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

        if len(dest.payload) != expected_len:
            raise IOError('Payload length did not match expected length')

        info.max_write_len = int.from_bytes(dest.payload, byteorder='big')

    def i3c_master_getmxds_locked(self, info: i3c_device_info):

        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=bytearray(5))
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETMXDS(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

        if len(dest.payload) not in [2, 5]:
            raise IOError('Payload length did not match expected length')

        info.max_read_ds = int(dest.payload[0])
        info.max_write_ds = int(dest.payload[1])
        if len(dest.payload) == 5:
            info.max_read_turnaround = int.from_bytes(dest.payload[2:4], byteorder='big')

    def i3c_master_gethdrcap_locked(self, info: i3c_device_info):

        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=bytearray(1))
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETHDRCAP(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

        if len(dest.payload) != 1:
            raise IOError('Payload length did not match expected length')

        info.hdr_cap = int.from_bytes(dest.payload, byteorder='big')

    def i3c_master_send_ccc_cmd_locked(self, cmd: i3c_ccc_cmd):
        if self._dw_i3c_master_supports_ccc_cmd(cmd):
            self._dw_i3c_master_send_ccc_cmd(cmd)
        else:
            raise ValueError("Invalid CCC/not supported")

        if cmd.err:
            raise IOError(cmd.err)

    def i3c_master_getstatus_locked(self, info: i3c_device_info):

        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=bytearray(2))
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETSTATUS(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

        info.status = int.from_bytes(dest.payload, byteorder='big')

    def i3c_master_getpid_locked(self, info: i3c_device_info):

        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=bytearray(6))
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETPID(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)

        info.pid = int.from_bytes(dest.payload, byteorder='big')

    def i3c_master_getbcr_locked(self, info: i3c_device_info):
        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=bytearray(1))
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETBCR(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)
        info.bcr = int.from_bytes(dest.payload, byteorder='big')

    def i3c_master_getdcr_locked(self, info: i3c_device_info):
        dest = i3c_ccc_cmd_dest(addr=info.dyn_addr, payload=bytearray(1))
        cmd = i3c_ccc_cmd(rnw=True, id=I3C_CCC_DEF.I3C_CCC_GETDCR(), dests=[dest])
        self.i3c_master_send_ccc_cmd_locked(cmd)
        info.dcr = int.from_bytes(dest.payload, byteorder='big')

    def i3c_master_retrieve_dev_info(self, dev: i3c_device_info):
        if not dev.dyn_addr:
            raise ValueError('Device requires a dynamic address')

        slot_status: i3c_addr_slot_status = self.addrslots[dev.dyn_addr]
        if (slot_status == i3c_addr_slot_status.I3C_ADDR_SLOT_RSVD or
                slot_status == i3c_addr_slot_status.I3C_ADDR_SLOT_I2C_DEV):
            raise ValueError("Device's dynamic address must be available for I3C")

        self.i3c_master_getpid_locked(dev)
        self.i3c_master_getbcr_locked(dev)
        self.i3c_master_getdcr_locked(dev)

        if dev.bcr & i3c_device_info.I3C_BCR_MAX_DATA_SPEED_LIM:
            self.i3c_master_getmxds_locked(dev)

        if dev.bcr & i3c_device_info.I3C_BCR_IBI_PAYLOAD:
            dev.max_ibi_len = 1

        self.i3c_master_getmrl_locked(dev)
        self.i3c_master_getmwl_locked(dev)

        if dev.bcr & i3c_device_info.I3C_BCR_HDR_CAP:
            self.i3c_master_gethdrcap_locked(dev)

    def _i3c_master_search_i3c_dev_duplicate(self, refdev: i3c_device_info) -> Union[i3c_device_info, None]:
        for i3cdev in self.i3cboardinfo:
            if i3cdev != refdev and i3cdev.pid == refdev.pid:
                return i3cdev

        return None

    def i3c_master_search_i3c_dev_by_pid(self, pid: int):
        for i3cdev in self.i3cboardinfo:
            if i3cdev.pid == pid:
                return i3cdev

        return None

    def i3c_master_search_i3c_dev_by_Daddr(self, dyn_addr: int):
        for i3cdev in self.i3cboardinfo:
            if i3cdev.dyn_addr == dyn_addr:
                return i3cdev

        return None

    def i3c_master_search_i3c_dev_by_Saddr(self, static_addr: int):
        for i3cdev in self.i3cboardinfo:
            if i3cdev.static_addr == static_addr:
                return i3cdev

        return None

    def i3c_master_add_i3c_dev_locked(self, addr: int, skip_info_fetch: bool = False):
        """I3C slave dynamic address assigned to the device"""
        newdev = i3c_device_info(dyn_addr=addr)
        old_dyn_addr: int = addr  # u8
        expected_dyn_addr: int = 0  # u8

        self.i3c_master_attach_i3c_dev(newdev)
        if skip_info_fetch:
            return
        self.i3c_master_retrieve_dev_info(newdev)
        olddev = self._i3c_master_search_i3c_dev_duplicate(newdev)

        if olddev:
            newdev.static_addr = olddev.static_addr
            old_dyn_addr = olddev.dyn_addr
            self.i3c_master_detach_i3c_dev(olddev)

        self.i3c_master_reattach_i3c_dev(newdev, old_dyn_addr)

        """
        Depending on our previous state, the expected dynamic address might differ:
        - if the device already had a dynamic address assigned, let's try to re-apply this one
        - if the device did not have a dynamic address and the firmware
          requested a specific address, pick this one
        - in any other case, keep the address automatically assigned by the master
        """
        if old_dyn_addr and old_dyn_addr != newdev.dyn_addr:
            expected_dyn_addr = old_dyn_addr
        elif newdev.init_dyn_addr:
            expected_dyn_addr = newdev.init_dyn_addr
        else:
            expected_dyn_addr = newdev.dyn_addr

        if newdev.dyn_addr != expected_dyn_addr:
            # Try to apply the expected dynamic address. If it fails, keep
            # the address assigned by the master.
            try:
                self.i3c_master_setnewda_locked(newdev.dyn_addr, expected_dyn_addr)
            except IOError as e:
                print(f"Failed to assign reserved/old address to device {newdev.pid}")
            else:
                old_dyn_addr = newdev.dyn_addr
                newdev.dyn_addr = expected_dyn_addr
                self.i3c_master_reattach_i3c_dev(newdev, old_dyn_addr)

    def i3c_bus_set_mode(self):
        if self.mode == i3c_bus_mode.I3C_BUS_MODE_PURE:
            if not self.i3c_scl_rate:
                self.i3c_scl_rate = self.I3C_BUS_TYP_I3C_SCL_RATE
        elif self.mode in [i3c_bus_mode.I3C_BUS_MODE_MIXED_FAST, i3c_bus_mode.I3C_BUS_MODE_MIXED_LIMITED]:
            if not self.i3c_scl_rate:
                self.i3c_scl_rate = self.I3C_BUS_TYP_I3C_SCL_RATE
        elif self.mode == i3c_bus_mode.I3C_BUS_MODE_MIXED_SLOW:
            if not self.i3c_scl_rate or self.i3c_scl_rate > self.i2c_scl_rate:
                self.i3c_scl_rate = self.i2c_scl_rate
        else:
            raise ValueError("Invalid bus mode")

        print(f"i2c-scl={self.i2c_scl_rate}Hz   i3c-scl={self.i3c_scl_rate}Hz\n")

        # I3C/I2C frequency may have been overridden, check that user-provided
        # values are not exceeding max possible frequency.
        if self.i3c_scl_rate > self.I3C_BUS_MAX_I3C_SCL_RATE or self.i2c_scl_rate > self.i3c_scl_rate:
            raise ValueError("Invalid I3C bus rates")

    def _i3c_master_pre_assign_dyn_addr(self, dev: i3c_device_info):
        if not dev.init_dyn_addr or not dev.static_addr:
            return

        self.i3c_master_setdasa_locked(dev.static_addr, dev.init_dyn_addr)

        dev.dyn_addr = dev.init_dyn_addr
        self.i3c_master_reattach_i3c_dev(dev, 0)
        self.i3c_master_retrieve_dev_info(dev)

    def i3c_master_do_daa(self):
        """
        i3c_master_do_daa() - do a DAA (Dynamic Address Assignment)

        This function is instantiating an I3C device object and adding it to the
        I3C device list. All device information are automatically retrieved using
        standard CCC commands.
        """

        self._dw_i3c_master_daa()

    def _i3c_master_bus_init(self, autoenum: bool = False):
        # First attach all devices with static definitions provided by the FW.
        for i2cdev in self.i2cboardinfo:
            status = self.addrslots[i2cdev.addr]
            if status != i3c_addr_slot_status.I3C_ADDR_SLOT_FREE:
                raise ValueError("Slot taken")
            self.addrslots[i2cdev.addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_I2C_DEV

            #i2cdev = self.i3c_master_alloc_i2c_dev(i2cboardinfo)
            #self.i3c_master_attach_i2c_dev(i2cdev)

        for i3cdev in self.i3cboardinfo:
            info = i3c_device_info(static_addr=i3cdev.static_addr)

            if i3cdev.init_dyn_addr:
                status = self.addrslots[i3cdev.init_dyn_addr]
                if status != i3c_addr_slot_status.I3C_ADDR_SLOT_FREE:
                    raise ValueError("Slot taken")

            #i3cdev = self.i3c_master_alloc_i3c_dev(info)
            #self.i3c_master_attach_i3c_dev(i3cdev)

        # Now execute the controller specific ->bus_init() routine, which
        # might configure its internal logic to match the bus limitations.
        self._dw_i3c_master_bus_init()

        # Normally this would continue to enumerate the I3C bus with do_daa()
        # Cirrus does not want this so skip
        if autoenum:

            # Reset all dynamic address that may have been assigned before
            # (assigned by the bootloader for example).
            self.i3c_master_rstdaa_locked(self.I3C_BROADCAST_ADDR)

            # Disable all slave events before starting DAA.
            self.i3c_master_disec_locked(self.I3C_BROADCAST_ADDR, I3C_CCC_DEF.I3C_CCC_EVENT_SIR |
                                         I3C_CCC_DEF.I3C_CCC_EVENT_MR | I3C_CCC_DEF.I3C_CCC_EVENT_HJ)

            # Pre-assign dynamic address and retrieve device information if needed.
            for i3cdev in self.i3cboardinfo:
                self._i3c_master_pre_assign_dyn_addr(i3cdev)

            self.i3c_master_do_daa()

    def _dw_i3c_master_disable(self):
        val = self.read_reg(self.DEVICE_CTRL) & ~self.DEV_CTRL_ENABLE
        self.write_reg(self.DEVICE_CTRL, val)

    def _dw_i3c_master_enable(self):
        val = self.read_reg(self.DEVICE_CTRL) | self.DEV_CTRL_ENABLE
        self.write_reg(self.DEVICE_CTRL, val)

    def _dw_i3c_master_get_addr_pos(self, addr: int) -> int:
        """u8 addr"""
        for pos in range(self.maxdevs):
            if addr == self.addrs[pos]:
                return pos
        else:
            raise ValueError("addr not found")
        
    SUPPORTED_CCC_CMDS = [I3C_CCC_DEF.I3C_CCC_ENEC(True),
                          I3C_CCC_DEF.I3C_CCC_ENEC(False),
                          I3C_CCC_DEF.I3C_CCC_DISEC(True),
                          I3C_CCC_DEF.I3C_CCC_DISEC(False),
                          I3C_CCC_DEF.I3C_CCC_ENTAS(0, True),
                          I3C_CCC_DEF.I3C_CCC_ENTAS(0, False),
                          I3C_CCC_DEF.I3C_CCC_RSTDAA(True),
                          I3C_CCC_DEF.I3C_CCC_RSTDAA(False),
                          I3C_CCC_DEF.I3C_CCC_ENTDAA(),
                          I3C_CCC_DEF.I3C_CCC_SETMWL(True),
                          I3C_CCC_DEF.I3C_CCC_SETMWL(False),
                          I3C_CCC_DEF.I3C_CCC_SETMRL(True),
                          I3C_CCC_DEF.I3C_CCC_SETMRL(False),
                          I3C_CCC_DEF.I3C_CCC_ENTHDR(0),
                          I3C_CCC_DEF.I3C_CCC_SETAASA(),
                          I3C_CCC_DEF.I3C_CCC_SETDASA(),
                          I3C_CCC_DEF.I3C_CCC_SETNEWDA(),
                          I3C_CCC_DEF.I3C_CCC_GETMWL(),
                          I3C_CCC_DEF.I3C_CCC_GETMRL(),
                          I3C_CCC_DEF.I3C_CCC_GETPID(),
                          I3C_CCC_DEF.I3C_CCC_GETBCR(),
                          I3C_CCC_DEF.I3C_CCC_GETDCR(),
                          I3C_CCC_DEF.I3C_CCC_GETSTATUS(),
                          I3C_CCC_DEF.I3C_CCC_GETMXDS(),
                          I3C_CCC_DEF.I3C_CCC_GETHDRCAP()]

    @classmethod
    def _dw_i3c_master_supports_ccc_cmd(cls, cmd: i3c_ccc_cmd) -> bool:
        if len(cmd.dests) > 1:
            return False

        return cmd.id in cls.SUPPORTED_CCC_CMDS

    def _dw_i3c_master_get_free_pos(self):
        if not self.free_pos & self.GENMASK(self.maxdevs - 1, 0):
            raise ValueError("No slots available")
        else:
            return (self.free_pos & -self.free_pos).bit_length() - 1

    def _dw_i3c_clk_cfg(self):

        core_period = self.DIV_ROUND_UP(1000000000, self.core_clk_rate)

        hcnt = self.DIV_ROUND_UP(self.I3C_BUS_THIGH_MAX_NS, core_period) - 1
        if hcnt < self.SCL_I3C_TIMING_CNT_MIN:
            hcnt = self.SCL_I3C_TIMING_CNT_MIN

        lcnt = self.DIV_ROUND_UP(self.core_clk_rate, self.I3C_BUS_TYP_I3C_SCL_RATE) - hcnt
        if lcnt < self.SCL_I3C_TIMING_CNT_MIN:
            lcnt = self.SCL_I3C_TIMING_CNT_MIN

        lcnt = 0xA
        hcnt = 0xA
        scl_timing = self.SCL_I3C_TIMING_HCNT(hcnt) | self.SCL_I3C_TIMING_LCNT(lcnt)
        self.write_reg(self.SCL_I3C_PP_TIMING, scl_timing)

        if not self.read_reg(self.DEVICE_CTRL) & self.DEV_CTRL_I2C_SLAVE_PRESENT:
            self.write_reg(self.BUS_FREE_TIMING, self.BUS_I3C_MST_FREE(lcnt))

        lcnt = self.DIV_ROUND_UP(self.I3C_BUS_TLOW_OD_MIN_NS, core_period)
        lcnt = 0x30  # Testing slower broadcast
        hcnt = 0x30
        scl_timing = self.SCL_I3C_TIMING_HCNT(hcnt) | self.SCL_I3C_TIMING_LCNT(lcnt)
        self.write_reg(self.SCL_I3C_OD_TIMING, scl_timing)

        lcnt = self.DIV_ROUND_UP(self.core_clk_rate, self.I3C_BUS_SDR1_SCL_RATE) - hcnt
        scl_timing = self.SCL_EXT_LCNT_1(lcnt)
        lcnt = self.DIV_ROUND_UP(self.core_clk_rate, self.I3C_BUS_SDR2_SCL_RATE) - hcnt
        scl_timing |= self.SCL_EXT_LCNT_2(lcnt)
        lcnt = self.DIV_ROUND_UP(self.core_clk_rate, self.I3C_BUS_SDR3_SCL_RATE) - hcnt
        scl_timing |= self.SCL_EXT_LCNT_3(lcnt)
        lcnt = self.DIV_ROUND_UP(self.core_clk_rate, self.I3C_BUS_SDR4_SCL_RATE) - hcnt
        scl_timing |= self.SCL_EXT_LCNT_4(lcnt)
        self.write_reg(self.SCL_EXT_LCNT_TIMING, scl_timing)

    def _dw_i2c_clk_cfg(self):

        core_period = self.DIV_ROUND_UP(1000000000, self.core_clk_rate)

        lcnt = self.DIV_ROUND_UP(self.I3C_BUS_I2C_FMP_TLOW_MIN_NS, core_period)
        hcnt = self.DIV_ROUND_UP(self.core_clk_rate, self.I3C_BUS_I2C_FM_PLUS_SCL_RATE) - lcnt
        scl_timing = self.SCL_I2C_FMP_TIMING_HCNT(hcnt) | self.SCL_I2C_FMP_TIMING_LCNT(lcnt)
        self.write_reg(self.SCL_I2C_FMP_TIMING, scl_timing)

        lcnt = self.DIV_ROUND_UP(self.I3C_BUS_I2C_FM_TLOW_MIN_NS, core_period)
        hcnt = self.DIV_ROUND_UP(self.core_clk_rate, self.I3C_BUS_I2C_FM_SCL_RATE) - lcnt
        scl_timing = self.SCL_I2C_FM_TIMING_HCNT(hcnt) | self.SCL_I2C_FM_TIMING_LCNT(lcnt)
        self.write_reg(self.SCL_I2C_FM_TIMING, scl_timing)

        self.write_reg(self.BUS_FREE_TIMING, self.BUS_I3C_MST_FREE(lcnt))
        # FIXME do we have to set DEV_CTRL_I2C_SLAVE_PRESENT?
        val = self.read_reg(self.DEVICE_CTRL) | self.DEV_CTRL_I2C_SLAVE_PRESENT
        self.write_reg(self.DEVICE_CTRL, val)

    def _dw_i3c_master_bus_init(self):
        info = i3c_device_info()  # info is the device_info for this I3C Primary Master device

        if self.i2cboardinfo:
            self._dw_i2c_clk_cfg()
        self._dw_i3c_clk_cfg()

        thld_ctrl = self.read_reg(self.QUEUE_THLD_CTRL)
        thld_ctrl &= ~self.QUEUE_THLD_CTRL_IBI_STATUS_MASK()
        thld_ctrl &= ~self.QUEUE_THLD_CTRL_IBI_DATA_MASK()
        thld_ctrl &= ~self.QUEUE_THLD_CTRL_RESP_BUF_MASK()
        self.write_reg(self.QUEUE_THLD_CTRL, thld_ctrl)

        thld_ctrl = self.read_reg(self.DATA_BUFFER_THLD_CTRL)
        thld_ctrl &= ~self.DATA_BUFFER_THLD_CTRL_RX_BUF()
        self.write_reg(self.DATA_BUFFER_THLD_CTRL, thld_ctrl)

        self.write_reg(self.INTR_STATUS, self.INTR_ALL)
        self.write_reg(self.INTR_STATUS_EN, self.INTR_MASTER_MASK)
        self.write_reg(self.INTR_SIGNAL_EN, self.INTR_MASTER_MASK)

        val = self._i3c_master_get_free_addr(0)

        self.write_reg(self.DEVICE_ADDR, self.DEV_ADDR_DYNAMIC_ADDR_VALID | self.DEV_ADDR_DYNAMIC(val))

        info.dyn_addr = val
        # info needs to be added to the devices dictionary
        self.addrslots[val] = i3c_addr_slot_status.I3C_ADDR_SLOT_I3C_DEV
        self.i3cboardinfo.append(info)

        # Accept IBI
        self.write_reg(self.IBI_SIR_REQ_REJECT, 0)
        # Reject IBI
        # self.write_reg(self.IBI_SIR_REQ_REJECT, self.IBI_REQ_REJECT_ALL())
        self.write_reg(self.IBI_MR_REQ_REJECT, self.IBI_REQ_REJECT_ALL())

        # For now don't support Hot-Join
        val = self.read_reg(self.DEVICE_CTRL) | self.DEV_CTRL_HOT_JOIN_NACK
        self.write_reg(self.DEVICE_CTRL, val)

        self._dw_i3c_master_enable()

    def _dw_i3c_ccc_set(self, ccc: i3c_ccc_cmd):
        pos: int = 0

        if ccc.id & I3C_CCC_DEF.I3C_CCC_DIRECT:
            pos = self._dw_i3c_master_get_addr_pos(ccc.dests[0].addr)

        xfer = dw_i3c_xfer()

        cmd: dw_i3c_cmd = xfer.cmds[0]
        cmd.tx_buf = ccc.dests[0].payload
        cmd.tx_len = len(ccc.dests[0].payload)

        cmd.cmd_hi = self.COMMAND_PORT_ARG_DATA_LEN(len(ccc.dests[0].payload)) | self.COMMAND_PORT_TRANSFER_ARG

        cmd.cmd_lo = (self.COMMAND_PORT_CP |
                      self.COMMAND_PORT_DEV_INDEX(pos) |
                      self.COMMAND_PORT_CMD(ccc.id) |
                      self.COMMAND_PORT_TOC |
                      self.COMMAND_PORT_ROC)

        self.enqueue_xfer(xfer)
        self.dequeue_xfer(xfer)
        ccc.err = xfer.ret

    def _dw_i3c_ccc_get(self, ccc: i3c_ccc_cmd):
        pos: int = self._dw_i3c_master_get_addr_pos(ccc.dests[0].addr)

        xfer = dw_i3c_xfer()

        cmd: dw_i3c_cmd = xfer.cmds[0]
        cmd.rx_len = len(ccc.dests[0].payload)

        cmd.cmd_hi = self.COMMAND_PORT_ARG_DATA_LEN(len(ccc.dests[0].payload)) | self.COMMAND_PORT_TRANSFER_ARG

        cmd.cmd_lo = (self.COMMAND_PORT_READ_TRANSFER |
                      self.COMMAND_PORT_CP |
                      self.COMMAND_PORT_DEV_INDEX(pos) |
                      self.COMMAND_PORT_CMD(ccc.id) |
                      self.COMMAND_PORT_TOC |
                      self.COMMAND_PORT_ROC)

        self.enqueue_xfer(xfer)
        self.dequeue_xfer(xfer)
        ccc.dests[0].payload = cmd.rx_buf
        ccc.err = xfer.ret

    def _dw_i3c_master_send_ccc_cmd(self, ccc: i3c_ccc_cmd):
        if ccc.id == I3C_CCC_DEF.I3C_CCC_ENTDAA():
            raise ValueError("send_ccc_cmd does not support ENTDAA, use do_daa")

        if ccc.rnw:
            self._dw_i3c_ccc_get(ccc)
        else:
            self._dw_i3c_ccc_set(ccc)

    def _dw_i3c_master_daa(self):
        last_addr: int = 0  # u8
        olddevs: int = ~self.free_pos  # u32

        # Prepare DAT before launching DAA.
        for pos in range(self.maxdevs):
            if olddevs & (1 << pos):
                continue

            val: int = self._i3c_master_get_free_addr(last_addr + 1)

            self.addrs[pos] = val
            p: int = self._even_parity(val)  # u8
            last_addr = val
            val |= p << 7

            self.write_reg(self.DEV_ADDR_TABLE_LOC(self.datstartaddr, pos),
                           self.DEV_ADDR_TABLE_DYNAMIC_ADDR(val) | self.DEV_ADDR_TABLE_IBI_PAYLOAD)

        xfer = dw_i3c_xfer()

        pos: int = self._dw_i3c_master_get_free_pos()
        cmd: dw_i3c_cmd = xfer.cmds[0]
        cmd.cmd_hi = 0x1
        cmd.cmd_lo = (self.COMMAND_PORT_DEV_COUNT(self.maxdevs - pos) |
                      self.COMMAND_PORT_DEV_INDEX(pos) |
                      self.COMMAND_PORT_CMD(I3C_CCC_DEF.I3C_CCC_ENTDAA()) |
                      self.COMMAND_PORT_ADDR_ASSGN_CMD |
                      self.COMMAND_PORT_TOC |
                      self.COMMAND_PORT_ROC)

        self.enqueue_xfer(xfer)
        self.dequeue_xfer(xfer)
        if xfer.ret:
            print(f"XFER ERROR {xfer.ret}")

        newdevs: int = self.GENMASK(self.maxdevs - cmd.rx_len - 1, 0)  # u32
        newdevs &= ~olddevs

        for pos in range(self.maxdevs):
            if newdevs & self.BIT(pos):
                self.i3c_master_add_i3c_dev_locked(self.addrs[pos])

        self.i3c_master_disec_locked(self.I3C_BROADCAST_ADDR, I3C_CCC_DEF.I3C_CCC_EVENT_HJ |
                                     I3C_CCC_DEF.I3C_CCC_EVENT_MR | I3C_CCC_DEF.I3C_CCC_EVENT_SIR)

    def i3c_master_do_priv_xfers_locked(self, dev: i3c_device_info, i3c_xfers: List[i3c_priv_xfer]):

        i3c_nxfers: int = len(i3c_xfers)

        if not i3c_nxfers:
            return

        if i3c_nxfers > self.caps.cmdfifodepth:
            raise ValueError("Transfer exceeds cmd fifo depth")

        nrxwords: int = 0  # unsigned int
        ntxwords: int = 0  # unsigned int
        for i in range(i3c_nxfers):
            if i3c_xfers[i].rnw:
                nrxwords += self.DIV_ROUND_UP(i3c_xfers[i].len, 4)
            else:
                ntxwords += self.DIV_ROUND_UP(i3c_xfers[i].len, 4)

        if (ntxwords > self.caps.datafifodepth) or (nrxwords > self.caps.datafifodepth):
            raise ValueError("Transfer exceeds data fifo depth")

        xfer = dw_i3c_xfer(ncmds=i3c_nxfers)

        for i in range(i3c_nxfers):
            cmd: dw_i3c_cmd = xfer.cmds[i]

            cmd.cmd_hi = self.COMMAND_PORT_ARG_DATA_LEN(i3c_xfers[i].len) | self.COMMAND_PORT_TRANSFER_ARG

            if i3c_xfers[i].rnw:
                cmd.rx_buf = i3c_xfers[i].data
                cmd.rx_len = i3c_xfers[i].len
                cmd.cmd_lo = self.COMMAND_PORT_READ_TRANSFER | self.COMMAND_PORT_SPEED(dev.max_read_ds)
            else:
                cmd.tx_buf = i3c_xfers[i].data
                cmd.tx_len = i3c_xfers[i].len
                cmd.cmd_lo = self.COMMAND_PORT_SPEED(dev.max_write_ds)

            cmd.cmd_lo |= self.COMMAND_PORT_TID(i) | self.COMMAND_PORT_DEV_INDEX(dev.index) | self.COMMAND_PORT_ROC

            if i == (i3c_nxfers - 1):
                cmd.cmd_lo |= self.COMMAND_PORT_TOC

        self.enqueue_xfer(xfer)
        self.dequeue_xfer(xfer)
        for i in range(i3c_nxfers):
            i3c_xfers[i].data = xfer.cmds[i].rx_buf
            i3c_xfers[i].err = xfer.cmds[i].error

    def i3c_master_reattach_i3c_dev(self, dev: i3c_device_info, old_dyn_addr: int):
        """u8 old_dyn_addr"""

        if dev.dyn_addr != old_dyn_addr:
            if self.addrslots[dev.dyn_addr] != i3c_addr_slot_status.I3C_ADDR_SLOT_FREE:
                raise ValueError("Slot taken")
            self.addrslots[dev.dyn_addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_I3C_DEV

        self.write_reg(self.DEV_ADDR_TABLE_LOC(self.datstartaddr, dev.index),
                       self.DEV_ADDR_TABLE_DYNAMIC_ADDR(dev.dyn_addr) | self.DEV_ADDR_TABLE_IBI_PAYLOAD)

        self.addrs[dev.index] = dev.dyn_addr

    def i3c_master_attach_i3c_dev(self, dev: i3c_device_info):
        # We don't attach devices to the controller until they are addressable on the bus.
        if not dev.static_addr and not dev.dyn_addr:
            return

        if dev.static_addr:
            if self.addrslots[dev.static_addr] != i3c_addr_slot_status.I3C_ADDR_SLOT_FREE:
                raise ValueError("Slot taken")
            self.addrslots[dev.static_addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_I3C_DEV

        # ->init_dyn_addr should have been reserved before that, so, if we're
        # trying to apply a pre-reserved dynamic address, we should not try
        # to reserve the address slot a second time.
        if dev.dyn_addr and (dev.init_dyn_addr != dev.dyn_addr):
            if self.addrslots[dev.dyn_addr] != i3c_addr_slot_status.I3C_ADDR_SLOT_FREE:
                raise ValueError("Slot taken")
            self.addrslots[dev.dyn_addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_I3C_DEV

        pos: int = self._dw_i3c_master_get_free_pos()

        dev.index = pos
        self.addrs[pos] = dev.dyn_addr if dev.dyn_addr else dev.static_addr
        self.free_pos &= ~self.BIT(pos)

        self.write_reg(self.DEV_ADDR_TABLE_LOC(self.datstartaddr, dev.index),
                       self.DEV_ADDR_TABLE_DYNAMIC_ADDR(self.addrs[pos]) | self.DEV_ADDR_TABLE_IBI_PAYLOAD)

        self.i3cboardinfo.append(dev)

    def i3c_master_detach_i3c_dev(self, dev: i3c_device_info):
        self.write_reg(self.DEV_ADDR_TABLE_LOC(self.datstartaddr, dev.index), 0)

        self.addrs[dev.index] = 0
        self.free_pos |= self.BIT(dev.index)
        dev.index = -1

        if dev.static_addr:
            self.addrslots[dev.static_addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_FREE

        if dev.dyn_addr:
            self.addrslots[dev.dyn_addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_FREE

        if dev.init_dyn_addr:
            # FIXME not sure if this needs to be init_dyn_addr or not
            self.addrslots[dev.dyn_addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_FREE

        self.i3cboardinfo.remove(dev)

    def i3c_master_i2c_xfers(self, addr: int, i2c_xfers: List[i2c_msg]):
        i2c_nxfers: int = len(i2c_xfers)

        if not i2c_nxfers:
            return

        # Doing transfers to different devices is not supported.
        check_addr = i2c_xfers[0].addr
        for i in range(1, i2c_nxfers):
            if check_addr != i2c_xfers[i].addr:
                raise NotImplementedError("Doing transfers to different devices is not supported")

        dev: i2c_device_info = self._i3c_master_search_i2c_dev_by_addr(addr)

        if not dev:
            raise ValueError(f"Device at addr {hex(addr)} is not attached to bus")

        if i2c_nxfers > self.caps.cmdfifodepth:
            raise ValueError("Transfer exceeds cmd fifo depth")

        nrxwords: int = 0
        ntxwords: int = 0
        for i in range(i2c_nxfers):
            if i2c_xfers[i].flags & I2C_FLAG_DEF.I2C_M_RD:
                nrxwords += self.DIV_ROUND_UP(i2c_xfers[i].len, 4)
            else:
                ntxwords += self.DIV_ROUND_UP(i2c_xfers[i].len, 4)

        if (ntxwords > self.caps.datafifodepth) or (nrxwords > self.caps.datafifodepth):
            raise ValueError("Transfer exceeds data fifo depth")

        xfer = dw_i3c_xfer(ncmds=i2c_nxfers)
        for i in range(i2c_nxfers):
            cmd: dw_i3c_cmd = xfer.cmds[i]

            cmd.cmd_hi = self.COMMAND_PORT_ARG_DATA_LEN(i2c_xfers[i].len) | self.COMMAND_PORT_TRANSFER_ARG
            if (dev.lvr & self.I3C_LVR_I2C_FM_MODE()):
                cmd.cmd_lo = self.COMMAND_PORT_TID(i) | self.COMMAND_PORT_DEV_INDEX(
                    dev.index) | self.COMMAND_PORT_ROC | self.COMMAND_PORT_SPEED(0)
            else:
                cmd.cmd_lo = self.COMMAND_PORT_TID(i) | self.COMMAND_PORT_DEV_INDEX(
                    dev.index) | self.COMMAND_PORT_ROC | self.COMMAND_PORT_SPEED(1)

            if i2c_xfers[i].flags & I2C_FLAG_DEF.I2C_M_RD:
                cmd.cmd_lo |= self.COMMAND_PORT_READ_TRANSFER
                cmd.rx_buf = i2c_xfers[i].buf
                cmd.rx_len = i2c_xfers[i].len
            else:
                cmd.tx_buf = i2c_xfers[i].buf
                cmd.tx_len = i2c_xfers[i].len

            if i == (i2c_nxfers - 1):
                cmd.cmd_lo |= self.COMMAND_PORT_TOC

        self.enqueue_xfer(xfer)
        self.dequeue_xfer(xfer)

        for i in range(i2c_nxfers):
            i2c_xfers[i].buf = xfer.cmds[i].rx_buf
            i2c_xfers[i].err = xfer.cmds[i].error

    def i3c_master_attach_i2c_dev(self, dev: i2c_device_info):

        # Check slots
        if self.addrslots[dev.addr] != i3c_addr_slot_status.I3C_ADDR_SLOT_FREE:
            raise ValueError("Slot taken")

        pos: int = self._dw_i3c_master_get_free_pos()

        dev.index = pos
        self.addrs[pos] = dev.addr
        self.free_pos &= ~self.BIT(pos)

        self.write_reg(self.DEV_ADDR_TABLE_LOC(self.datstartaddr, dev.index),
                       self.DEV_ADDR_TABLE_LEGACY_I2C_DEV | self.DEV_ADDR_TABLE_STATIC_ADDR(dev.addr))

        self.i2cboardinfo.append(dev)

        # Mark this address as taken by an I2C device
        self.addrslots[dev.addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_I2C_DEV

        # Use lvr to set i2c but rate
        lvr = dev.lvr & self.I3C_LVR_I2C_INDEX_MASK()
        if lvr & self.I3C_LVR_I2C_FM_MODE():
            self.i2c_scl_rate = self.I3C_BUS_I2C_FM_SCL_RATE
        else:
            self.i2c_scl_rate = self.I3C_BUS_I2C_FM_PLUS_SCL_RATE

        # Configure clocks
        self._dw_i2c_clk_cfg()
        
    def i3c_master_detach_i2c_dev(self, dev: i2c_device_info):
        self.i2cboardinfo.remove(dev)

        self.write_reg(self.DEV_ADDR_TABLE_LOC(self.datstartaddr, dev.index), 0)

        self.addrs[dev.index] = 0
        self.free_pos |= self.BIT(dev.index)
        dev.index = -1

        self.addrslots[dev.addr] = i3c_addr_slot_status.I3C_ADDR_SLOT_FREE

    def i3c_master_print_bus_status(self):
        print("--: FREE")
        print("RR: RSVD")
        print("D2: I2C DEV")
        print("D3: I3C DEV")
        print("     00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F")
        for i in range(0x00, 0x80, 0x10):
            print(f"{i:02x}: ", end='')
            for j in range(0x10):
                msg = " --"
                if self.addrslots[i + j] == i3c_addr_slot_status.I3C_ADDR_SLOT_RSVD:
                    msg = " RR"
                elif self.addrslots[i + j] == i3c_addr_slot_status.I3C_ADDR_SLOT_I2C_DEV:
                    msg = " D2"
                elif self.addrslots[i + j] == i3c_addr_slot_status.I3C_ADDR_SLOT_I3C_DEV:
                    msg = " D3"
                print(msg, end='')
            print("")

