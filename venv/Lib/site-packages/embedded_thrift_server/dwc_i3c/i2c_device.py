from embedded_thrift_server.dwc_i3c.linux_common import LinuxCommon
from dataclasses import dataclass
from typing import Union


class I2C_FLAG_DEF:
    I2C_M_RD = 0x0001  # read data, from slave to master
    I2C_M_TEN = 0x0010  # this is a ten bit chip address
    I2C_M_RECV_LEN = 0x0400  # length will be first received byte
    I2C_M_NO_RD_ACK = 0x0800  # if I2C_FUNC_PROTOCOL_MANGLING
    I2C_M_IGNORE_NAK = 0x1000  # if I2C_FUNC_PROTOCOL_MANGLING
    I2C_M_REV_DIR_ADDR = 0x2000  # if I2C_FUNC_PROTOCOL_MANGLING
    I2C_M_NOSTART = 0x4000  # if I2C_FUNC_NOSTART
    I2C_M_STOP = 0x8000  # if I2C_FUNC_PROTOCOL_MANGLING


@dataclass
class i2c_msg:
    addr: int  # u16 slave address
    flags: int  # u16
    len: int  # u16 msg length
    buf: bytearray  # u8 * pointer to msg data
    err: Union[str, None] = None  # enum i3c_error_code


class i2c_device_info(LinuxCommon):
    """
    Legacy I2C Device
    Addr: I2C static address
    LVR: Legacy Virtual Register
        bit[7:5] - Limits, 0,1,2 are valid
        bit[4] - I2C Mode Indicator, 0=FM+, 1=FM
    Index: device store location
    """

    def __init__(self, addr: int, lvr: int, index: int = -1):
        self.addr: int = addr  # u16 Static address
        self.lvr: int = lvr  # u8 Legacy Virtual Register
        self.index: int = index  # u8 Added from dw_i3c_i2c_dev_data

    def __repr__(self):
        info = f"""Addr:{hex(self.addr)}, LVR:{hex(self.lvr)}, Index:{self.index}"""
        return info

    def __str__(self):
        info = f"""Addr:{hex(self.addr)}, LVR:{hex(self.lvr)}"""
        return info
