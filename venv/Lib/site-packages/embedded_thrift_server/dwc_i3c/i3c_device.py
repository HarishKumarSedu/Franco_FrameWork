from embedded_thrift_server.dwc_i3c.linux_common import LinuxCommon
from dataclasses import dataclass
from typing import Union


@dataclass
class i3c_priv_xfer:
    """
    struct i3c_priv_xfer - I3C SDR private transfer
    @rnw: encodes the transfer direction. true for a read, false for a write
    @len: transfer length in bytes of the transfer
    @data: input/output buffer
    @data.in: input buffer. Must point to a DMA-able buffer
    @data.out: output buffer. Must point to a DMA-able buffer
    @err: I3C error code
    """
    rnw: bool = False
    len: int = 0  # u16
    data: bytearray = None  # pointer
    err: Union[str, None] = None  # enum i3c_error_code


class i3c_device_info(LinuxCommon):

    @classmethod
    def I3C_PID_MANUF_ID(cls, pid) -> int:
        return (pid & cls.GENMASK(47, 33)) >> 33
    @classmethod
    def I3C_PID_RND_LOWER_32BITS(cls, pid) -> bool:
        return bool(pid & cls.BIT(32))
    @classmethod
    def I3C_PID_RND_VAL(cls, pid) -> int:
        return pid & cls.GENMASK(31, 0)
    @classmethod
    def I3C_PID_PART_ID(cls, pid) -> int:
        return (pid & cls.GENMASK(31, 16)) >> 16
    @classmethod
    def I3C_PID_INSTANCE_ID(cls, pid) -> int:
        return (pid & cls.GENMASK(15, 12)) >> 12
    @classmethod
    def I3C_PID_EXTRA_INFO(cls, pid) -> int:
        return pid & cls.GENMASK(11, 0)

    @classmethod
    def I3C_BCR_DEVICE_ROLE(cls, bcr) -> int:
        return bcr & cls.GENMASK(7, 6)
    I3C_BCR_I3C_SLAVE = 0 << 6
    I3C_BCR_I3C_MASTER = 1 << 6
    I3C_BCR_HDR_CAP = 1 << 5
    I3C_BCR_BRIDGE = 1 << 4
    I3C_BCR_OFFLINE_CAP = 1 << 3
    I3C_BCR_IBI_PAYLOAD = 1 << 2
    I3C_BCR_IBI_REQ_CAP = 1 << 1
    I3C_BCR_MAX_DATA_SPEED_LIM = 1 << 0

    def __init__(self, pid: int = 0, bcr: int = 0, dcr: int = 0, init_dyn_addr: int = 0, static_addr: int = 0,
                 dyn_addr: int = 0, hdr_cap: int = 0, max_read_ds: int = 0, max_write_ds: int = 0, max_ibi_len: int = 0,
                 max_read_turnaround: int = 0, max_read_len: int = 0, max_write_len: int = 0, index: int = -1, status: int = 0):
        """
        struct i3c_device_info - I3C device information
        - pid: Provisional ID
        - bcr: Bus Characteristic Register
        - dcr: Device Characteristic Register
        - static_addr: static/I2C address
        - dyn_addr: dynamic address
        - hdr_cap: supported HDR modes
        - max_read_ds: max read speed information
        - max_write_ds: max write speed information
        - max_ibi_len: max IBI payload length
        - max_read_turnaround: max read turn-around time in micro-seconds
        - max_read_len: max private SDR read length in bytes
        - max_write_len: max private SDR write length in bytes
        - index: Added from dw_i3c_i2c_dev_data, -1 for invalid

        These are all basic information that should be advertised by an I3C device.
        Some of them are optional depending on the device type and device capabilities.
        For each I3C slave attached to a master with
        i3c_master_add_i3c_dev_locked(), the core will send the relevant CCC command
        to retrieve these data.
        """
        self.pid: int = pid  # u64
        self.bcr: int = bcr  # u8
        self.dcr: int = dcr  # u8
        self.init_dyn_addr: int = init_dyn_addr  # u8
        self.static_addr: int = static_addr  # u8
        self.dyn_addr: int = dyn_addr  # u8
        self.hdr_cap: int = hdr_cap  # u8
        self.max_read_ds: int = max_read_ds  # u8
        self.max_write_ds: int = max_write_ds  # u8
        self.max_ibi_len: int = max_ibi_len  # u8
        self.max_read_turnaround: int = max_read_turnaround  # u32
        self.max_read_len: int = max_read_len  # u16
        self.max_write_len: int = max_write_len  # u16
        self.status: int = status # u16
        self.index: int = index  # u8 Added from dw_i3c_i2c_dev_data

    def __repr__(self):
        info = f"""PID:{hex(self.pid)}, BCR:{self.bcr}, DCR:{self.dcr}, InitDynAddr:{hex(self.init_dyn_addr)}, StaticAddr:{hex(self.static_addr)}, DynAddr:{hex(self.dyn_addr)}, HdrCap:{self.hdr_cap}, MaxReadDs:{self.max_read_ds}, MaxWriteDs:{self.max_write_ds}, MaxIbiLen:{self.max_ibi_len}, MaxReadTurnaround:{self.max_read_turnaround}, MaxReadLen:{hex(self.max_read_len)}, MaxWriteLen:{hex(self.max_write_len)}, Index:{self.index}"""
        return info

    def __str__(self):
        info = f"""PID:{hex(self.pid)}, InitDynAddr:{hex(self.init_dyn_addr)}, StaticAddr:{hex(self.static_addr)}, DynAddr:{hex(self.dyn_addr)}"""
        return info
