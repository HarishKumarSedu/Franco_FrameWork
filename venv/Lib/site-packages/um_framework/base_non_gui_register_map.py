"""
@brief
Base class for all device definition xml verification tests
"""
import os
import itertools
import re
from time import sleep

from collections import namedtuple, OrderedDict
from switch import Switch

from unified_modules.test_support.testresults import TestResultsFailures, ABORT_STEP, PASS_STEP, FAIL_STEP
from unified_modules.test_support.testresourcebase import ResourceBase
from unified_modules.test_support.xmlrpc_support import XmlRpcRemoteException
from unified_modules.test_support.testutils import get_stack_trace
from unified_modules.test_support.testlogger import log_file_time_stamp

from unified_modules.resources.resource_ftp.resource_ftp import MyFTPClient, ResourceFTPError
from unified_modules.resources.resource_power_switch.resource_power_switch import ResourcePowerSwitch

from .um_baseclass import UmBaseTest, BST_TARGET_DEVICES, VIRTUAL_BSP, BSP, BSP_DEVICE_MAPPING, BSP_DICT

from unified_modules.test_support.testresourceclaimer import ResourceRequirement

# Dev_def and Register map test area DUT types
REGISTER_TARGET_DEVICES = list(itertools.chain(BST_TARGET_DEVICES[BSP.Cornell],
                                               BST_TARGET_DEVICES[BSP.Taylor],
                                               BST_TARGET_DEVICES[BSP.Trucks],
                                               BST_TARGET_DEVICES[BSP.Berry],
                                               BST_TARGET_DEVICES[BSP.Becker],
                                               BST_TARGET_DEVICES[BSP.Jones],
                                               BST_TARGET_DEVICES[BSP.Domino],
                                               BST_TARGET_DEVICES[BSP.BBking],
                                               BST_TARGET_DEVICES[BSP.Dollar],
                                               BST_TARGET_DEVICES[BSP.Sterling],
                                               BST_TARGET_DEVICES[BSP.Lynott]))


class BaseNonGuiRegisterMapError(Exception):
    """
    Custom Exception,can be used to raise we we fail to read or write to
    register using SCSLink API
    """
    def __init__(self, message=None):
        super(BaseNonGuiRegisterMapError, self).__init__(message)


class BaseNonGuiRegisterMap(UmBaseTest):
    """
    Base test for Device Definition file verification
    """
    def __init__(self, result=None, testsystem=None, dut_resource='scs_link'):
        """
        - Named tuple for register,bit field attributes and access modes
        - Parsing white listed registers and adding them to register_not_validate
        - Requesting the SCSLinkAPI and ResourceDeviceDefParser resources
        - Parsing skip registers yml and updating register_not_validate

        @param result: Test results Object
        @param testsystem: Test Framework to be used
        """
        self.power_switch_tag = 'power_switch'
        local_resources = []
        if VIRTUAL_BSP not in testsystem.target_device:
            local_resources = [ResourceRequirement(tag=self.power_switch_tag,
                                                   class_of_resource=ResourcePowerSwitch,
                                                   res_type=self.power_switch_tag)]
        super(BaseNonGuiRegisterMap, self).__init__(result, testsystem, local_resources=local_resources)
        # Named tuple for Access modes
        access_modes = namedtuple('AccessModes', 'R_O R_W W_O W1C')
        self.access_mode = access_modes('R/O', 'R/W', 'W/O', 'W1C')
        # Named tuple for Register attributes
        register_attr = namedtuple('RegisterAttr', 'Name DisplayName Access DefaultValue Address BitFields')
        self.reg_attr = register_attr('Name', 'DisplayName', 'Access', 'DefaultValue', 'Address', 'BitFields')
        # Named tuple for bit field attributes
        bitfield_attr = namedtuple('RegisterAttr', 'Name Access DefaultValue Address Values Start End FieldType '
                                                   'TextField RadioButton ComboBox Slider Value SoftwareAccess '
                                                   'Volatile Test BitFieldLocation')
        self.bit_field_attr = bitfield_attr('Name', 'Access', 'DefaultValue', 'Address', 'Values', 'Start', 'End',
                                            'FieldType', 'text_field', 'radio_button', 'combo_box', 'slider', 'Value',
                                            'SoftwareAccess', 'Volatile', 'Test',
                                            'BitFieldLocation')
        # Default to 5 registers
        self.reg_width = None
        self.dut = None
        self.devicetype = None
        self.each_register_info = None
        self.register_class_dict = None
        self.registers_not_validate = None
        self.dev_def_parser = None
        self.sanity_reg_count = 5
        self.hex_base = 16
        self.ftp_server = ''
        self.test_type = 'valid'
        self.dut_tag = 'dut'
        self.parser_tag = 'dev_def_parser'
        self.cirruslink_tag = 'cirruslink'
        self.ftp_tag = 'ftp_server'
        self.failed_registers = []
        self.failed_bit_fields = []
        self.wc_bit_fields = []
        self.skip_bit_fields = []
        # TS6 is a register test script written to verify out of range register values.
        # Some registers have internal bit fields locked to a non-zero default value.
        # These must be skipped only for the test script ts6. This is why the variable is called this
        # way to make it simpler to call it.
        self.registers_ts6 = []
        self.reg_not_validate = []
        self.rw_total, self.ro_total, self.wo_total = (0, 0, 0)
        [self.bit_wo_total, self.bit_ro_total, self.combo_total,
         self.text_total, self.radio_total, self.slider_total] = (0, 0, 0, 0, 0, 0)
        self.dut_tag = dut_resource
        self.device_name = self.get_target_device()

        self.set_device_details()
        self.set_target_device_name()
        self.set_target_system_name_and_file()

        # Creating Resource requirement objects for SCSLinkAPI and ResourceDeviceDefParser resources
        resources = [ResourceRequirement(tag=self.dut_tag,
                                         class_of_resource=ResourceBase,
                                         res_type=self.dut_tag),
                     ResourceRequirement(tag=self.parser_tag,
                                         class_of_resource=ResourceBase,
                                         res_type=self.parser_tag),
                     ]
        # Creating FTP resource requirement object to export SCS logs if not soak
        if not self.soak:
            resources.append(ResourceRequirement(tag=self.ftp_tag,
                                                 class_of_resource=ResourceBase,
                                                 res_type=self.ftp_tag))
        # Requesting list of resources
        self.request_resources(resources)

        # Getting xmlrpc instances of resources using resource tags
        self.dut = self.resources[self.dut_tag]
        self.cirruslink_present = self.dut.config['cirruslink_present']
        # Creating Resource requirement objects  ResourceCirrusLink if cirruslink_present
        if self.cirruslink_present and VIRTUAL_BSP not in self.device_name:
            self.request_resources([ResourceRequirement(tag=self.cirruslink_tag,
                                                        class_of_resource=ResourceBase,
                                                        res_type=self.cirruslink_tag)])
            self.cirruslink = self.resources[self.cirruslink_tag]
        self.dev_def_parser = self.resources[self.parser_tag]
        if not self.soak:
            self.ftp_server = self.resources[self.ftp_tag]

        # Parsing skip_registers yml file
        skip_registers = self.dev_def_parser.get_registers_to_skip(self.dev_def_parser.config['skip_registers'])
        # Named tuple for keys in skip registers.yml file
        yaml_variables = namedtuple('yaml_variables', 'registers address_range wc_bit_fields registers_ts6 bit_fields')
        self.skip_reg_keys = yaml_variables('registers', 'address_range', 'wc_bit_fields', 'registers_ts6',
                                            'bit_fields')
        try:
            self.reg_not_validate = skip_registers[self.skip_reg_keys.registers]
        except KeyError:
            self.log.warning("No registers skipped for device %s" % self.device_name)
        # Reading all project specific skip_registers and updating them to self.reg_not_validate and self.address_range
        # variables
        try:
            self.address_range = skip_registers[self.skip_reg_keys.address_range]
            if isinstance(self.address_range, str):
                if ";" in self.address_range:
                    self.address_range = self.address_range.split(";")
                else:
                    self.address_range = [self.address_range]
        except KeyError:
            self.address_range = None
        try:
            # These are applicable only with real hardware. With Simulated system, WC registers check will fail
            self.wc_bit_fields = skip_registers[self.skip_reg_keys.wc_bit_fields]
        except KeyError:
            pass
        try:
            self.registers_ts6 = skip_registers[self.skip_reg_keys.registers_ts6]
        except KeyError:
            pass

        try:
            self.skip_bit_fields = skip_registers[self.skip_reg_keys.bit_fields]
        except KeyError:
            pass
        self.local_resources = self.test_system.local_claimed_resources
        if VIRTUAL_BSP not in self.get_target_device():
            self.power_switch = self.local_resources[self.power_switch_tag].resource
            self.power_switch.set_config_details()
            self.power_switch_socket = self.local_resources[self.power_switch_tag].config['socket_number']

    def setup(self):
        """
        - Validating and parsing the the device definition file
        - Updating registers_not_validate with all registers in skip_register yml file and skip address range registers
        - Start StudioLink
        """
        super(BaseNonGuiRegisterMap, self).setup()
        self.dev_def_parser.set_config_details(device_xml_file=self.dev_def_parser.config['dev_def_file'])
        self.dev_def_parser.parse_dev_def_file()
        self.each_register_info = self.dev_def_parser.get_each_register_info()
        self.register_class_dict = self.dev_def_parser.get_register_class_dict()
        self.reg_width = self.dev_def_parser.get_register_width()
        self.registers_not_validate = self._get_register_not_validate()
        self._init_scs_link()

    def initiate(self):
        """
        - If target device is sim,adding system manually and connecting to the system
        - If target device is real,waiting for system and connecting to the system
        - If soak flag is set to true,then calculating total register and bit field count
        """
        self.result.test_step("Connect to device %s" % self.device_name)
        if VIRTUAL_BSP in self.device_name:
            self.target_system_file = self.dut.config['system_file_path']
            self.dut.add_system_manually(self.target_system_name_sim, self.target_system_file)
            self.dut.connect_to_system_and_device(self.target_system_name_sim,
                                                  self.target_device_name,
                                                  cirruslink_present=self.cirruslink_present)
        else:
            if not self.dut.wait_until_system_available_to_connect(self.target_system_name_real):
                self.dut_power_reset()
            if self.dut.wait_until_system_available_to_connect(self.target_system_name_real):
                self.dut.connect_to_board(self.target_system_name_real)
                self.dut.connect_to_system_and_device(self.target_system_name_real,
                                                      self.target_device_name,
                                                      init_pyhelper=True,
                                                      target_device=self.device_name,
                                                      cirruslink_present=self.cirruslink_present)
            else:
                raise BaseNonGuiRegisterMapError("Unable to discover target device %s" % self.target_system_name_real)
        if self.soak:
            self.rw_total, self.ro_total, self.wo_total = self._calculate_expected_register_counter()
            [self.bit_wo_total, self.bit_ro_total,
             self.combo_total, self.text_total,
             self.radio_total, self.slider_total] = self._calculate_expected_bit_fields_counter()
            self.log.info("Totals: self.rw_total %s, self.ro_total %s, self.wo_total %s"
                          "self.bit_wo_total %s, self.bit_ro_total %s, self.combo_total %s, self.text_total %s, "
                          "self.radio_total %s, self.slider_total %s",
                          self.rw_total, self.ro_total, self.wo_total,
                          self.bit_wo_total, self.bit_ro_total,
                          self.combo_total, self.text_total,
                          self.radio_total, self.slider_total
                          )

    def teardown(self):
        """
        - Stopping the SCS Link
        - If soak is set to false,downloading scs log file from Test Head using FTP
        """
        scs_latest_log = self.dut.stop_link()
        if not self.soak and scs_latest_log is not None:
            ftp_user = self.ftp_server.config.get('username')
            ftp_password = self.ftp_server.config.get('password')
            self.ftp_server.start_server(self.ftp_server.testhead.host,
                                         ftp_user,
                                         ftp_password,
                                         os.path.split(scs_latest_log)[0])
            ftp_ip, ftp_port = self.ftp_server.get_ftp_ip_and_port()
            ftp_client = MyFTPClient(ftp_ip, ftp_port, ftp_user, ftp_password)
            scs_log_file = "-".join([self.__class__.__name__, self.dut_type, self.get_test_platform(),
                                     'SCSLogs', log_file_time_stamp() + ".log"])
            scs_log_path = os.path.join(self.test_system.results_label, scs_log_file)
            try:
                ftp_client.download_file(os.path.split(scs_latest_log)[1], scs_log_path)
            except ResourceFTPError as ftp_error:
                self.log.warning(ftp_error)
        super(BaseNonGuiRegisterMap, self).teardown()

    def rw_dev_def_registers(self,
                             mode_to_test='R/W',
                             log_msg='',
                             abv_max_below_min_values=False,
                             block_write=False,
                             count=None,
                             invalid_data=False):
        """
        Method to test registers of access modes R/O,R/W,W/O
        Test steps for R/O
            - register read
                1. Write default value to R/O register and verify exception "CLR_READ_ONLY" exception to be raised from
                   StudioLink
            - register block read
                1. Write default value to R/O registers and verify exception "CLR_READ_ONLY" exception to be raised
                   from StudioLink
        Test steps for R/W
            - Writing valid value
                1. Write default value to register
                2. Read register value
                3. Check if value written to register is same as expected value
            - Writing Invalid value
                1. Write default value to R/O register and verify exception "invalid_data" exception to be raised from
                   StudioLink
            - Writing Out of range values
                - Writing Max + 1 value
                    1. Write 2 ** register width to register.
                    2. Read register and check if register value equals 0 or previous value is retained
                - Writing Min - 1 value
                    1. Write -1 register.
                    2. Read register and check if exception is raised by StudioLink
            - block write
                    1. Write list of values to R/W registers using block write method by giving address, page, count.
                    2. Read list of values starting from address, page and count and check if registers are updated as
                       expected
        - Update failed registers if any
        - At end display Result metric
            1. Number of registers tested
            2. Number of failure registers with register names
        """
        reg_counter = 0
        main_result = self.result

        reg_above_max_outcome = []
        reg_below_min_outcome = []
        reg_rw_outcome = []

        try:
            for register in self.each_register_info:
                self.result = TestResultsFailures()
                self.result.set_test_title(self.__class__.__name__)
                register_name = register.get(self.reg_attr.DisplayName, register[self.reg_attr.Name])
                access_mode = register[self.reg_attr.Access]
                register_addr = register[self.reg_attr.Address]
                try:
                    xml_default = register[self.reg_attr.DefaultValue]
                except KeyError:
                    # If DefaultValue key is not found then set it with 0
                    xml_default = '0x' + '0' * (self.reg_width / 4)
                if abv_max_below_min_values and register_name in self.registers_ts6:
                    self.log.info("Register %s specific to Ts6 test script skipped. This register contains internal "
                                  "bit fields with locked in non-zero default value" % register_name)
                    self.rw_total -= 1
                    continue
                if not self.soak and reg_counter >= self.sanity_reg_count:
                    break
                elif isinstance(self.address_range, int):
                    if int(register_addr, self.hex_base) > self.address_range:
                        self.log.info('Register %s skipped,as its address is above %s', register_name,
                                      self.address_range)
                        continue
                elif isinstance(self.address_range, list):
                    stop_verifying = False
                    for addr_range in self.address_range:
                        addr_ranges = addr_range.split(",")
                        addr_ranges = [int(addr, 16) for addr in addr_ranges]
                        if addr_ranges[0] <= int(register_addr, self.hex_base) <= addr_ranges[1]:
                            self.log.info('Register %s skipped,as its address is between %s,%s', register_name,
                                          hex(addr_ranges[0]),
                                          hex(addr_ranges[1]))
                            stop_verifying = True
                            break
                    if stop_verifying:
                        continue
                if register_name in self.reg_not_validate:
                    self.log.info('Register %s skipped', register_name)
                    continue
                if mode_to_test == access_mode:
                    self.log.info("Verify register:%s, access mode:%s, def xml val:%s",
                                  register_name, access_mode, xml_default)
                    if abv_max_below_min_values:
                        self._reg_out_of_range_values(register_name)
                        reg_below_min_outcome.append(self.result.step_outcome()[0])
                        reg_above_max_outcome.append(self.result.step_outcome()[1])
                        failure_reg = self._check_for_failures(register_name)
                        if failure_reg:
                            self.failed_registers.append(failure_reg)
                    elif block_write:
                        access_mode_values = []
                        block_write_default_values = []
                        address = int(register_addr, self.hex_base)
                        register_index = self.each_register_info.index(register)
                        for _ in range(count):
                            next_register = self.each_register_info[register_index]
                            access_mode_values.append(next_register[self.reg_attr.Access])
                            try:
                                next_reg_default_val = next_register[self.reg_attr.DefaultValue]
                            except KeyError:
                                next_reg_default_val = '0x' + '0' * (self.reg_width / 4)
                            block_write_default_values.append(next_reg_default_val)
                            register_index += 1
                        if all(access_mode == self.access_mode.R_W for access_mode in access_mode_values):
                            self._rw_dev_def_reg_block(address=address, page=0, count=count,
                                                       write_values=block_write_default_values, mode=mode_to_test)
                        elif access_mode == self.access_mode.R_O:
                            self._rw_dev_def_reg_block(address=address, page=0, count=count,
                                                       write_values=block_write_default_values, mode=mode_to_test)
                        else:
                            continue
                        try:
                            if FAIL_STEP in self.result.step_outcome():
                                reg_rw_outcome.append(FAIL_STEP)
                            else:
                                reg_rw_outcome.append(PASS_STEP)
                            failure_reg = self._check_for_failures(register_name)
                            if failure_reg:
                                self.failed_registers.append(failure_reg)
                        except IndexError:
                            reg_rw_outcome.append(ABORT_STEP)
                    elif invalid_data:
                        self._rw_register(register_name, xml_default, access_mode, invalid_data=True)
                        try:
                            if FAIL_STEP in self.result.step_outcome():
                                reg_rw_outcome.append(FAIL_STEP)
                            else:
                                reg_rw_outcome.append(PASS_STEP)
                            failure_reg = self._check_for_failures(register_name)
                            if failure_reg:
                                self.failed_registers.append(failure_reg)
                        except IndexError:
                            reg_rw_outcome.append(ABORT_STEP)
                    else:
                        self._rw_register(register_name, xml_default, access_mode)
                        try:
                            self.log.info("Register name:%s. The result step outcome:%s",
                                          register_name,
                                          self.result.step_outcome())
                            if FAIL_STEP in self.result.step_outcome():
                                reg_rw_outcome.append(FAIL_STEP)
                            else:
                                reg_rw_outcome.append(PASS_STEP)
                            failure_reg = self._check_for_failures(register_name)
                            if failure_reg:
                                self.failed_registers.append(failure_reg)
                        except IndexError:
                            reg_rw_outcome.append(ABORT_STEP)
                    reg_counter += 1
        finally:
            self.result = main_result
            if self.soak:
                if mode_to_test == self.access_mode.R_O:
                    reg_counter = self.ro_total
                elif mode_to_test == self.access_mode.R_W:
                    reg_counter = self.rw_total
                elif mode_to_test == self.access_mode.W_O:
                    reg_counter = self.wo_total
            if abv_max_below_min_values:
                log_msg_max_val = "Check writing Above max value to registers raises an error, " \
                                  "num of registers tested: %s" % reg_counter
                log_msg_above_max = "Check writing below min value to registers raises an error, " \
                                    "num of registers tested: %s" % reg_counter
                self.result.assert_equal(reg_above_max_outcome.count(PASS_STEP), reg_counter,
                                         log_msg_max_val)
                self.result.assert_equal(reg_below_min_outcome.count(PASS_STEP), reg_counter,
                                         log_msg_above_max)
            else:
                log_msg = log_msg + " register count: " + str(reg_counter)
                self.result.assert_equal(reg_rw_outcome.count(PASS_STEP), reg_counter, log_msg)
        self.result.assert_equal(self.failed_registers, [], "Check for failed registers")

    def rw_dev_def_bit_fields(self, mode_to_test='R/O', log_msg="", test_name=None, block_write=False,
                              count=1, block_write_values=None, invalid_data=False, neg_case=False):
        """
        Method to test bit field of access modes R/O,R/W,W/O,WC
        - R/O Bit fields
            - testing single bit field
                1. Write default value to R/O bit field
                2. Check if exception is raised from StudioLink
            - testing block bit fields
                1. Write default values starting from address to registers
                2. Check if exception is raised from StudioLink
        - R/W bit fields
            - Radio button and combo box bit field
                - Valid case
                    1. Read possible values for radio button(eg. Enable(0x1), Disable(0x0)) and Combo box
                    2. Write each possible value to bit field
                    3. Calculate register value according to written bit field value and check for register value
                - neg_case
                    1. Writing a value exceeding bit field length(Ex if len 2, writing "0x111")
                    2. Check if register value is equal to register max value
            - Text field bit field
                - Valid case
                    1. Write max value to the bit field
                    2. Calculate register value according to written bit field value and check for register value
                - neg_case
                    1. Writing a value exceeding bit field length(Ex if len 2, writing "0x111")
                    2. Check if register value is equal to register max value
            - Slider bit field
                - Valid case
                    1. Write start, mid and max values to the bit field
                    2. Calculate register value according to written bit field value and check for register value
                - neg_case
                    1. Writing a value exceeding bit field length(Ex if len 2, writing "0x111")
                    2. Check if register value is equal to register max value
        - W/O bit field
            - Write default value to the bit field
            - Check if no exception is raised writing writing value to write only field

        @param mode_to_test: [str] Access of a bit field
        @param log_msg: [str] Log message string
        @param test_name: [str] Corresponds to type of Bit field
        @param block_write: [bool] True if write a block to bit field
        @param count: [int] number of bit fields to write
        @param block_write_values [list<int|str>] values list
        @param invalid_data [bool] True if want to write invalid value to field
        @param neg_case [bool] if true negative case else positive case
        """
        main_result = self.result
        self.result = TestResultsFailures()
        self.result.set_test_title(self.__class__.__name__)
        counter = 0
        bitfield_rw_outcome = []
        field_count_rw = 0
        decrement_count = 0
        for reg_name, reg_object in self.register_class_dict.items():
            if not self.soak and counter >= self.sanity_reg_count:
                break
            reg_def_val = reg_object[self.reg_attr.DefaultValue]
            if not reg_def_val:
                reg_def_val = '0x' + '0' * (self.reg_width / 4)
            bit_fields = reg_object[self.reg_attr.BitFields]
            register_addr = reg_object[self.reg_attr.Address]
            # register_name = reg_object.get(self.reg_attr.DisplayName, reg_object[self.reg_attr.Name])
            # Writing sample value(5) to validate R/O register
            value_to_write_to_reg_ro = 5
            increment_counter = False
            if isinstance(self.address_range, int):
                if int(register_addr, self.hex_base) > self.address_range:
                    self.log.info('Register %s skipped,as its address is above %s', reg_name, self.address_range)
                    continue
            elif isinstance(self.address_range, list):
                stop_verifying = False
                for addr_range in self.address_range:
                    addr_ranges = addr_range.split(",")
                    addr_ranges = [int(addr, 16) for addr in addr_ranges]
                    if addr_ranges[0] <= int(register_addr, self.hex_base) <= addr_ranges[1]:
                        self.log.info('Register %s skipped,as its address is between %s,%s', reg_name,
                                                                                              hex(addr_ranges[0]),
                                                                                              hex(addr_ranges[1]))
                        stop_verifying = True
                        break
                if stop_verifying:
                    continue
            if reg_name in self.reg_not_validate:
                self.log.info('Register %s skipped', reg_name)
                continue
            for bit_field in bit_fields:
                bit_field_name = bit_field[self.bit_field_attr.Name]
                if self.skip_bit_fields and bit_field_name in self.skip_bit_fields:
                    self.log.info('Bit field %s skipped', bit_field_name)
                    increment_counter = False
                    continue
                if bit_field[self.bit_field_attr.SoftwareAccess] == self.access_mode.W1C:
                    self.log.info('Skipped verifying Bit field %s because its '
                                  'SoftwareAccess is "WIC"', bit_field_name)
                    increment_counter = False
                    continue
                if self.bit_field_attr.RadioButton == test_name:
                    # Exclude these fields for cornell due to SCSCRN-458 and SCSCRN-390
                    if BSP.Cornell in self.device_type:
                        if bool(re.match('SWIRE[1-2]_DP[1-6]_PREPARE_CHANNEL[1-6]',
                                         bit_field[self.bit_field_attr.Name])) or  \
                                        bit_field[self.bit_field_attr.Name] == 'INTEXTCLK_SEL':
                            decrement_count += 1
                            continue
                if bit_field[self.bit_field_attr.Access] == mode_to_test:
                    field_name = bit_field[self.bit_field_attr.Name]
                    # Switch case which verifies registers of R/O,R/W,W/O access mode
                    with Switch(mode_to_test) as access_mode:
                        if access_mode(self.access_mode.R_O):
                            # Writing to R/O register and checking if exception is raised from StudioLink
                            self._ro_bit_fields(field_name, value_to_write_to_reg_ro, block_write, block_write_values)
                        if access_mode(self.access_mode.W_O):
                            # Checking if no exception is raised when writing to W/O register
                            self._rw_bit_fields(reg_name, reg_def_val,
                                                bit_field, test_name, write_only=True)
                        if access_mode(self.access_mode.R_W):
                            # if invalid_data: Writing a value exceeding bit field length
                            # else: Reading possible values of bit field and writing them,
                            #       calculating the expected register value and checking for
                            #       expected register value in the register
                            if invalid_data:
                                self._rw_bit_fields(reg_name, reg_def_val, bit_field,
                                                    test_name, invalid_data=True, neg_case=neg_case)
                            else:
                                self._rw_bit_fields(reg_name, reg_def_val, bit_field,
                                                    test_name, block_write, count, neg_case=neg_case)
                        if access_mode.default:
                            raise BaseNonGuiRegisterMapError("Unsupported bit field mode to test:%s" % mode_to_test)

                    if test_name == bit_field[self.bit_field_attr.FieldType] or mode_to_test == self.access_mode.R_O\
                            or mode_to_test == self.access_mode.W_O:
                        try:
                            self.log.info("field_name:%s. The result step outcome:%s",
                                          bit_field[self.bit_field_attr.Name],
                                          self.result.step_outcome())
                            if FAIL_STEP in self.result.step_outcome():
                                bitfield_rw_outcome.append(FAIL_STEP)
                            else:
                                bitfield_rw_outcome.append(PASS_STEP)
                            failed_bit_field = self._check_for_failures(bit_field[self.bit_field_attr.Name])
                            if failed_bit_field:
                                self.failed_bit_fields.append(failed_bit_field)
                            field_count_rw += 1
                            if not increment_counter:
                                increment_counter = True
                        except IndexError:
                            bitfield_rw_outcome.append(ABORT_STEP)
            if increment_counter:
                counter += 1
                self.log.info("Matching count no.%d register %s", counter, reg_name)
        self.result = main_result
        if self.soak:
            if mode_to_test == self.access_mode.R_O:
                field_count_rw = self.bit_ro_total
            elif mode_to_test == self.access_mode.W_O:
                field_count_rw = self.bit_wo_total
            elif mode_to_test == self.access_mode.R_W:
                if test_name == self.bit_field_attr.TextField:
                    field_count_rw = self.text_total
                elif test_name == self.bit_field_attr.RadioButton:
                    field_count_rw = self.radio_total
                elif test_name == self.bit_field_attr.ComboBox:
                    field_count_rw = self.combo_total
                elif test_name == self.bit_field_attr.Slider:
                    field_count_rw = self.slider_total

        field_count_rw = field_count_rw - decrement_count
        log_msg = log_msg + " field count %s" % str(field_count_rw)
        self.result.assert_equal(bitfield_rw_outcome.count(PASS_STEP), field_count_rw, log_msg)
        self.result.assert_equal(self.failed_bit_fields, [], "Check for failed bit fields")

    def verify_device_info(self):
        """
        Compare values of System device Information of real device with values configured in Device Info xml
        """
        if BSP.Trucks in self.device_name:
            device_name_list = re.findall('\d+', self.device_name)
            dev_name = ''.join(["CS37L90 Device ", (device_name_list[0])])
        elif BSP.Berry in self.device_name:
            device_name_list = re.findall('\d+', self.device_name)
            dev_name = ''.join(["CS35L91 Device ", (device_name_list[0])])
        elif BSP.Becker in self.device_name:
            device_name_list = re.findall('\d+', self.device_name)
            dev_name = ''.join(["CS44L22 Device ", (device_name_list[0])])
        elif BSP.Domino in self.device_name:
            device_name_list = re.findall('\d+', self.device_name)
            dev_name = ''.join(["CS40L60 Mode ", (device_name_list[0])])
        else:
            dev_name = self.target_device_name
        dev_desc = self.dut.get_system_device_information(dev_name)
        dev_info = self.dev_def_parser.get_device_info()
        ctrl_intfs = dev_info['ControlInterfaces']
        dev_desc_ctrl_inf = dev_desc["ControlInterface"].split('_')
        dev_addr_desc = dev_desc['DeviceAddress']
        inf_protocol = None
        dev_addr = None
        if BSP.Sterling in self.device_name:
            i2c_interface_name = 'SMbus_%sinx_%sdat' % (2*self.reg_width, self.reg_width)
        else:
            i2c_interface_name = 'SMbus_%sinx_%sdat' % (self.reg_width, self.reg_width)
        for key, val in ctrl_intfs.items():
            if not isinstance(val, list):
                dev_addr = self._ctrl_interface(val['DeviceAddress'], dev_addr_desc)
                inf_protocol = val['InterfaceProtocol']
            else:
                for dev_a in val:
                    dev_addr = self._ctrl_interface(dev_a['DeviceAddress'], dev_addr_desc)
                    if dev_addr == dev_addr_desc:
                        inf_protocol = dev_a['InterfaceProtocol']
                        break
            if 'I2C' in dev_desc_ctrl_inf:
                self.result.assert_equal(inf_protocol, i2c_interface_name,
                                         "Check controller interface value %s read from device"
                                         " against value in xml" % inf_protocol)
            elif 'SPI' in dev_desc_ctrl_inf:
                interface_present = False
                if isinstance(dev_desc_ctrl_inf, list):
                    for intf in dev_desc_ctrl_inf:
                        if intf in inf_protocol:
                            interface_present = True
                else:
                    interface_present = dev_desc_ctrl_inf in inf_protocol
                self.result.assert_true(interface_present,
                                        "Check controller interface value %s read from device"
                                        " against value in xml" % inf_protocol)
            else:
                self.result.assert_true(False, "Interface name:%s is not matching" % dev_desc_ctrl_inf)

        self.result.assert_equal(dev_info["Type"], dev_desc["Type"],
                                 "Check device type value %s read from"
                                 " device against value in xml" % dev_info["Type"])
        self.result.assert_equal(dev_addr, dev_desc["DeviceAddress"],
                                 "Check device address value %s read "
                                 "from device against value in xml" % dev_addr)

    def dut_power_reset(self):
        """
        Stop link
        Release the scs link resource
        Perform DUT power reset
        Request the scs link resource
        Init scs link
        """
        self.log.info("failed to connect to device,performing DUT power reset and trying again")
        # Stopping link
        self.dut.stop_link()

        if self.cirruslink_present and VIRTUAL_BSP not in self.device_name:
            ipaddress = self.cirruslink.config['ipaddress']
            self.cirruslink.cirruslink_restart(ipaddress)
        else:
            self.dut.stop()
            self.dut.resource_base.stop()
            del self.resources[self.dut_tag]
            # Performing power reset
            if BSP.Dollar in self.device_name:
                self.power_switch.power_off(self.power_switch_socket)
                sleep(30)
                self.power_switch.power_on(self.power_switch_socket)
            else:
                self.power_switch.power_reset(self.power_switch_socket)
            # Requesting scs_link again
            self.request_resources(
                [ResourceRequirement(tag=self.dut_tag, class_of_resource=ResourceBase, res_type='scs_link')])

        # Starting link
        self._init_scs_link()

    def _init_scs_link(self):
        """
        Creates StudioLink instance and start StudioLink
        """
        self.dut = self.resources[self.dut_tag]
        self.target_system_name_real = self.dut.config['system_name']
        scs_link_path = self.dut.config['path_to_scslink']
        self.result.test_step('Init studio link with path %s and start link' % scs_link_path)
        self.dut.set_bsp_mapping(BSP_DICT, BSP_DEVICE_MAPPING)
        # StudioLink instance
        self.dut.initiate_studiolink(scs_link_path)
        # Start StudioLink
        self.dut.start_link()

    def _rw_register(self, register_name, def_value, mode='R/W', invalid_data=False):
        """
        Write Value to register and reading it back
        @param register_name: name of register
        @param def_value: Default value
        @param mode: access mode
        @param invalid_data: invalid data or valid data
        @return: Outcome of the assertion
        """
        with Switch(mode) as reg_mode_case:
            if reg_mode_case(self.access_mode.R_O):
                reg_value = '0xff'
                exc_message = "Field or register is read only (CLR_READ_ONLY)"
                assert_msg = "Writing %s to read only reg: %s" % (reg_value, register_name)
                self._verify_excep_on_reg_write(register_name, reg_value, exc_message, assert_msg)
            if reg_mode_case(self.access_mode.W_O):
                self.result.assert_not_raises(XmlRpcRemoteException,
                                              self.dut.write_register_by_name,
                                              "Write to W/O register: %s does not raise error" % register_name,
                                              register_name,
                                              def_value,
                                              raise_excep_on_fail=True)
            if reg_mode_case(self.access_mode.R_W):
                if invalid_data:
                    reg_value = 'invalid_data'
                    exc_message = "caused by '%s' has type <type 'str'>" % reg_value
                    assert_msg = "Writing %s to register %s" % (reg_value, register_name)
                    self._verify_excep_on_reg_write(register_name, reg_value, exc_message, assert_msg,
                                                    invalid_data=True)
                else:
                    self._verify_register(register_name, def_value, "Register: %s is set with default value: %s" %
                                          (register_name, def_value))
            if reg_mode_case.default:
                raise BaseNonGuiRegisterMapError('Invalid register mode: %s' % mode)

    def _check_for_failures(self, reg_or_field_name):
        """
        Check for failure in outcome and return reg_or_field_name if latest outcome is not pass
        @param reg_or_field_name: [str]   Register/BitField name

        @return: [str] Returns failing register/bit field assertion details
        """
        failed_info = OrderedDict()
        if FAIL_STEP in self.result.step_outcome():
            failed_info['Name'] = reg_or_field_name
            failed_assertions = [assertion for assertion in self.result.assertions if assertion.startswith('FAIL')]
            failed_info['Assertion'] = failed_assertions
        return failed_info


    def _reg_out_of_range_values(self, register_name):
        """
        Writing Values to register out of range
        """
        max_value = (2 ** self.reg_width)
        self.log.info("Verify register:%s, reg width: %s, max value: %s" % (register_name, self.reg_width, max_value))
        if self.device_name == BSP.Domino:
            default_value = self._assert_read_register(register_name)
        else:
            default_value = 0
        self.dut.write_register_by_name(register_name, reg_width=self.reg_width)
        reg_value = self._assert_read_register(register_name)

        self.result.assert_equal(reg_value, default_value, "register:%s, after writing max value+1 is %s" % (
            register_name, default_value))

        # SCSCRN-269 minor issue, might need to remove min value check once this bug is closed.
        min_value = '-0x1'
        self.log.info("Verify register:%s, reg width: %s, min value: %s" % (register_name, self.reg_width, min_value))
        self.result.assert_raises(XmlRpcRemoteException,
                                  self.dut.write_register_by_name, "Writing -1 to reg: %s" % register_name,
                                  register_name, min_value, raise_excep_on_fail=True)
        return self.result.step_outcome()

    def _ro_bit_fields(self, bit_field_name, value_to_write, block_write=False, block_write_values=None):
        """
        Writing a value to R/O bit field,then reading corresponding bit field register,expecting
        it be be same as register default value.
        @param bit_field_name: [str] bit field name
        @param value_to_write: [int] value to be written to bit field
        """
        self.result = TestResultsFailures()
        self.result.set_test_title(self.__class__.__name__)

        if block_write:
            count = len(block_write_values)
            exception_raised = self.result.assert_raises(XmlRpcRemoteException,
                                                         self.dut.write_block_to_field,
                                                         "Check that the block write to read only "
                                                         "reg bit field fails",
                                                         bit_field_name, count, block_write_values,
                                                         raise_excep_on_fail=True)
        else:
            exception_raised = self.result.assert_raises(XmlRpcRemoteException, self.dut.write_to_field,
                                                         "Check that the write to read "
                                                         "only bit field fails",
                                                         bit_field_name,
                                                         value_to_write,
                                                         raise_excep_on_fail=True)
        if exception_raised:
            self.result.assert_true("Field or register is read only (CLR_READ_ONLY)" in exception_raised.message,
                                    "Exception raised when tried to write to read only Register")

    def _rw_bit_fields(self,
                       reg_name,
                       reg_default,
                       bit_field,
                       test_name,
                       block_write=False,
                       count=1,
                       invalid_data=False,
                       write_only=False,
                       neg_case=False):
        """
        Writing a value to a bit field ,reading the register value and expecting it to be same as
        expected value
        @param reg_name: [str] Register name
        @param reg_default: [str] Bit field default value
        @param bit_field: [list<int>] list of possible bit field values
        @param test_name: [str] it can be test case(radio_button, combo_box, text_field)
        @param block_write: [bool] block write enable or disable
        @param count: [int] number of fields to write
        @param invalid_data: [bool] invalid data or valid data
        @param write_only: [bool] write only or not
        @param neg_case: [bool] Negative or positive case
        @return: result step outcome or None
        """
        self.result = TestResultsFailures()
        self.result.set_test_title(self.__class__.__name__)
        bitfield_values, bit_field_name, bit_field_addr, bit_field_type, bit_field_width, bit_field_loc = (None, None, None, None,
                                                                                            None, None)
        try:
            bitfield_values = bit_field[self.bit_field_attr.Values]
            bit_field_name = bit_field[self.bit_field_attr.Name]
            bit_field_addr = bit_field[self.bit_field_attr.Address]
            bit_field_type = bit_field[self.bit_field_attr.FieldType]
            bit_field_loc = bit_field[self.bit_field_attr.BitFieldLocation]
        except KeyError:
            # This bit field is missing a mandatory attribute. So this counts as a failure
            self.log.warning("Mandatory bit field attribute missing, Stacktrace:%s", get_stack_trace())

        bit_width_pattern = re.search('\[(\d+):?(\d+)?\]', bit_field_addr)
        try:
            bit_field_width = int(bit_width_pattern.group(1)) - int(bit_width_pattern.group(2))
            bit_field_width += 1
        except TypeError:
            bit_field_width = 1
        if block_write:
            # Consecutive registers/bit-field data(Access Modes, bit Field value, default values) stores in below lists
            consecutive_registers = []
            consecutive_access_modes = []
            consecutive_bitfields = []
            consecutive_def_values = []
            bitfield_index = None
            # Gets the names of required registers from self.each_register_info based on the given count value
            for register in self.each_register_info:
                if reg_name == register[self.reg_attr.Name]:
                    register_index = self.each_register_info.index(register)
                    for _ in range(count):
                        next_register = self.each_register_info[register_index]
                        consecutive_registers.append(next_register[self.reg_attr.Name])
                        register_index += 1
            # Gets the bit fields data of consecutive registers
            for reg in consecutive_registers:
                if reg in self.register_class_dict:
                    reg_bitfields = self.register_class_dict[reg][self.reg_attr.BitFields]
                    for bitfield in reg_bitfields:
                        if bitfield[self.bit_field_attr.Name] == bit_field_name:
                            bitfield_index = reg_bitfields.index(bitfield)
                            break
                    if len(reg_bitfields) > bitfield_index:
                        try:
                            consecutive_access_modes.append(reg_bitfields[bitfield_index][self.bit_field_attr.Access])
                            consecutive_bitfields.append(reg_bitfields[bitfield_index][self.bit_field_attr.Name])
                            consecutive_def_values.append(reg_bitfields[bitfield_index]
                                                          [self.bit_field_attr.DefaultValue])
                        except KeyError:
                            # This bit field is missing a mandatory attribute. So this counts as a failure
                            self.log.warning("Mandatory bit field attribute missing, Stacktrace:%s", get_stack_trace())

            # Checks whether all consecutive bitfields access modes are read/write
            if all(access_mode == self.access_mode.R_W for access_mode in consecutive_access_modes):
                # writes default values to consecutive registers
                self.dut.write_block_to_field(bit_field_name, count, consecutive_def_values)
                log_msg = "Check block write and read for register %s bit field %s, count %s with values %s" % (
                           reg_name, bit_field_name, count, consecutive_def_values)
                # Reads values from consecutive registers for cross verification of written values
                current_bitfield_values = self.dut.read_block_field(bit_field_name, count)
                current_bitfield_values = [int(value, self.hex_base) for value in current_bitfield_values]
                block_write_values = [int(value, self.hex_base) for value in consecutive_def_values]
                self.result.assert_equal(current_bitfield_values, block_write_values, log_msg)
        elif invalid_data:
            bitfield_val = "invalid_data"
            exp_expected_msg = "caused by 'invalid_data' has type <type 'str'>"
            assert_msg = "Writing %s to bit field %s" % (bitfield_val, bit_field_name)
            self._verify_excep_for_bit_field_write(bit_field_name, bitfield_val, assert_msg, exp_expected_msg)
        elif write_only:
            bitfield_val = (2 ** bit_field_width) - 1
            self.result.assert_not_raises(XmlRpcRemoteException, self.dut.write_to_field,
                                          "Check that the write to W/O bit field does not raise error",
                                          bit_field[self.bit_field_attr.Name], str(bitfield_val),
                                          raise_excep_on_fail=True, string_value=True)
        elif self.bit_field_attr.TextField == test_name == bit_field_type:
            expected_bit_val = None
            if neg_case:
                bitfield_val = 2 ** (bit_field_width + 1) - 1
                expected_bit_val = 2 ** bit_field_width - 1
            else:
                bitfield_val = str((2 ** bit_field_width) - 1)
            assertion_msg = "Writing %s to text field: %s" % (bitfield_val, bit_field_name)
            bitfield_val = str(bitfield_val)
            if bit_field_loc not in bit_field_addr:
                bit_width_pattern = re.search(r'\[(\d+):?(\d+)?\]', bit_field_loc)
                try:
                    bit_field_width = int(bit_width_pattern.group(1)) - int(bit_width_pattern.group(2))
                    bit_field_width += 1
                except TypeError:
                    bit_field_width = 1
                expected_bit_val = str((2 ** bit_field_width) - 1)
            self._verify_bit_field(reg_name, bit_field_name, bit_field_addr, bitfield_val,
                                   reg_default, self.reg_width, assertion_msg, string_value=True,
                                   expected_value=expected_bit_val, bit_field_loc=bit_field_loc)
        elif(self.bit_field_attr.ComboBox == test_name == bit_field_type or
                self.bit_field_attr.RadioButton == test_name == bit_field_type):
            if self.bit_field_attr.ComboBox == test_name == bit_field_type:
                # If test_all_combos command line argument is not passed and
                # Combo box has more than 5 values then testing only first,
                # last and middle combo box elements
                if(not hasattr(self.test_system.run_options, 'test_all_combos')
                        and len(bitfield_values) > 5):
                    bitfield_values = [bitfield_values[0],
                                       bitfield_values[(len(bitfield_values) - 1)/2],
                                       bitfield_values[-1]]
            if neg_case:
                bitfield_val = 2 ** (bit_field_width + 1) - 1
                expected_bit_val = 2 ** bit_field_width - 1
                if write_only:
                    bitfield_val = str(bitfield_val)
                    self.result.assert_not_raises(XmlRpcRemoteException,
                                                  self.dut.write_to_field,
                                                  "Check that the write to W/O bit field does not raise error",
                                                  bit_field_name,
                                                  bitfield_val,
                                                  raise_excep_on_fail=True,
                                                  string_value=True)
                else:
                    assert_msg = "Writing %s to bit field: %s" % (bitfield_val, bit_field_name)
                    bitfield_val = str(bitfield_val)
                    self._verify_bit_field(reg_name, bit_field_name, bit_field_addr, bitfield_val, reg_default,
                                           self.reg_width, assert_msg, expected_value=expected_bit_val,
                                           string_value=True, bit_field_loc=bit_field_loc)
            else:
                possible_values = []
                for bitfield_val_node in bitfield_values:
                    for bitfield_val in bitfield_val_node:
                        try:
                            possible_values.append(bitfield_val[self.bit_field_attr.Value])
                        except KeyError:
                            possible_values.extend([bitfield_val[self.bit_field_attr.Start],
                                                    hex((int(bitfield_val[self.bit_field_attr.End],
                                                             self.hex_base)
                                                         - int(bitfield_val[self.bit_field_attr.Start],
                                                               self.hex_base))/2),
                                                    bitfield_val[self.bit_field_attr.End]])
                for bitfield_val in possible_values:
                    bitfield_val = int(bitfield_val, self.hex_base)
                    if write_only:
                        bitfield_val = str(bitfield_val)
                        self.result.assert_not_raises(XmlRpcRemoteException,
                                                      self.dut.write_to_field,
                                                      "Check that the write to W/O bit field does not raise error",
                                                      bit_field_name,
                                                      bitfield_val,
                                                      raise_excep_on_fail=True,
                                                      string_value=True)
                    else:
                        assert_msg = "Writing %s to bit field: %s" % (bitfield_val,
                                                                      bit_field_name)
                        bitfield_val = str(bitfield_val)
                        self._verify_bit_field(reg_name, bit_field_name, bit_field_addr,
                                               bitfield_val, reg_default, self.reg_width, assert_msg,
                                               string_value=True, bit_field_loc=bit_field_loc)
        elif test_name == bit_field_type == self.bit_field_attr.Slider:
            slider_values = bit_field[self.bit_field_attr.Values][0][0]
            start_value = slider_values[self.bit_field_attr.Start]
            end_value = slider_values[self.bit_field_attr.End]
            mid_value = hex((int(end_value, self.hex_base) - int(start_value, self.hex_base)) / 2)
            if neg_case:
                bitfield_val = 2 ** bit_field_width
                # Workaround for now, expect slider to be set to MIN instead of MAX when we write MAX+1.
                # Change the following line to have "1" instead of "0" once SCSCRN-457 is fixed.
                # This is how SCS core currently works and it is just an inconsistency in how the core behaves
                expected_bit_val = 0
                slider_values = [str(bitfield_val)]
                string_values = True
            else:
                slider_values = [start_value, mid_value, end_value]
                string_values = True
                expected_bit_val = None
            for slider_val in slider_values:
                assertion_msg = 'Writing %s to bit field: %s' % (slider_val, bit_field_name)
                self._verify_bit_field(reg_name, bit_field_name, bit_field_addr, slider_val, reg_default,
                                       self.reg_width, assertion_msg, expected_value=expected_bit_val,
                                       string_value=string_values, slider_neg=neg_case, bit_field_loc=bit_field_loc)

    def _rw_dev_def_reg_block(self, address, page=0, count=3, write_values=None, mode='R/W'):
        """
        Verifies block read/write to a register address
        @param address: register address
        @param page: page to write to
        @param count: number of blocks to write to
        @param write_values: list of values to write to
        @param mode: read only or read write mode
        """
        if write_values is None:
            write_values = [20, 21, 22]
        if self.access_mode.R_O == mode:
            exception_raised = self.result.assert_raises(XmlRpcRemoteException,
                                                         self.dut.write_block_to_reg_by_addr,
                                                         "block write to read only reg: %s " % address,
                                                         address, page, count, write_values,
                                                         raise_excep_on_fail=True)
            if exception_raised:
                exp_message = exception_raised.message
                expected_exc_bool = "Field or register is read only (CLR_READ_ONLY)" in exp_message
                self.result.assert_true(expected_exc_bool, "Exception raised when tried to write block to read "
                                                           "only register: %s, %s" % (address, exp_message))
            else:
                self.result.assert_true(False, "Exception raised when tried to write block to read only register %s" %
                                               address)
        else:
            self.dut.write_block_to_reg_by_addr(address, page, count, write_values)
            log_msg = "Check block write and read for address %s, page %s, count %s with values %s" % (address,
                                                                                                       page,
                                                                                                       count,
                                                                                                       write_values)
            read_values = self.dut.read_block_from_reg_by_addr(address, page, count)
            read_values = [int(val, self.hex_base) for val in read_values]
            write_values = [int(val, self.hex_base) for val in write_values]
            self.log.info("Reg value read after writing a block:%s", read_values)
            self.result.assert_equal(read_values, write_values, log_msg)

    def _assert_read_register(self, register_name):
        """
        Read register and verify its asserts its validity
        @param register_name: [str] register name to write

        @return: [int|None] value if succesfull, None otherwise
        """
        message = "Could not read register value by name. reg_name %s"
        reg_val = self.dut.read_register_value_by_name(register_name)
        self.result.assert_not_equal(reg_val, None, message % register_name)
        return int(reg_val) if reg_val is not None else None

    def _verify_register(self, register_name, register_value, assert_message):
        """
        Verify writing value to and register and expected to be as same after reading the register.

        @param register_name: [str] register name to write
        @param register_value: [int|long] register value to write
        @param assert_message: [str] assert message on failure
        """
        self.dut.write_register_by_name(register_name, register_value)
        current_reg_val = self._assert_read_register(register_name)
        if current_reg_val is None:
            return
        self.log.info("Reg name: %s, Value written:%s. Value read after writing:%s" % (register_name,
                                                                                       register_value,
                                                                                       hex(int(current_reg_val))))
        register_value = int(register_value, self.hex_base)
        self.result.assert_equal(current_reg_val, register_value, assert_message)

    def _verify_bit_field(self, reg_name, bit_field_name, bit_field_addr, bit_field_value,
                          reg_default_value, reg_width, assertion_msg, string_value=False,
                          expected_value=None, slider_neg=False, bit_field_loc=None):
        """
        Verify bit field calculating the expected register value
        @param reg_name: [str] Name of the register
        @param bit_field_name: [str] Name of the bit field
        @param bit_field_addr: [str] Address of the bit field
        @param bit_field_value: [str] Value to be written to bit field
        @param reg_default_value: [str] Default value of the bit field
        @param reg_width: [int] Number of bit in register
        @param assertion_msg: [str] Assertion message for result metrics
        @param string_value: [bool] True if bit field value is str else false
        @param expected_value: [int] Expected bit field value
        @param slider_neg: Expect different value for slider negative case
                           This is because of bug id SCSCRN-457. This is a core issue.
        """
        temp_bit_value = bit_field_value
        prev_reg_val = self._assert_read_register(reg_name)
        if prev_reg_val is None:
            return
        self.dut.write_to_field(bit_field_name, bit_field_value, string_value=string_value, raise_excep_on_fail=True)
        cur_reg_val = self._assert_read_register(reg_name)
        if expected_value:
            bit_field_value = expected_value
        if self.wc_bit_fields and bit_field_name in self.wc_bit_fields:
            bit_field_value = 0
        if slider_neg:
            expected_value = self.calculate_expected_value(prev_reg_val, expected_value, reg_width, bit_field_loc)
        else:
            expected_value = self.calculate_expected_value(prev_reg_val, bit_field_value, reg_width, bit_field_loc)
        if isinstance(temp_bit_value, str) and '0x' in temp_bit_value:
            temp_bit_value = temp_bit_value.rstrip('L')
            temp_bit_value = int(temp_bit_value, self.hex_base)
        self.result.assert_equal(cur_reg_val, int(expected_value), assertion_msg)
        self.dut.write_register_by_name(reg_name, reg_default_value)
        revert_reg_val = self._assert_read_register(reg_name)
        self.log.info("Value %s written to bit field %s. Prev reg value:%s Expected value:%s."
                      "Actual reg value after write:%s, "
                      "reverted reg value:%s", temp_bit_value, bit_field_name, prev_reg_val,
                      expected_value, cur_reg_val, revert_reg_val)

    def _verify_excep_on_reg_write(self, register_name, register_value, exception_message,
                                   assert_message, invalid_data=False):
        """
        Verify an exception to be raised on writing a value to register

        @param register_name: register name to write
        @param register_value: register value to write
        @param exception_message: exception message on writing the register value
        @param assert_message: assert message on failure
        @param invalid_data: boolean on invalid data
        """
        exception_raised = self.result.assert_raises(XmlRpcRemoteException, self.dut.write_register_by_name,
                                                     assert_message, register_name,
                                                     register_value, invalid_data=invalid_data,
                                                     raise_excep_on_fail=True)
        if exception_raised:
            exp_message = exception_raised.message
            self.result.assert_true(exception_message in exp_message,
                                    "Exception raised:%s when tried to write:%s to register: %s" % (
                                        exception_message, register_name, register_value))
        else:
            self.result.assert_true(False, "when tried to write:%s to register: %s" % (exception_message,
                                                                                       register_name))

    def _verify_excep_for_bit_field_write(self, bit_field_name, bitfield_val, assert_msg,
                                          exp_exception_msg):
        """
        Method to verify expected exception message to be raised on writing to a bit field

        @param bit_field_name: [str] name of the bit field
        @param bitfield_val: [str] bit field value
        @param assert_msg: [str] Assertion message for result metrics
        @param exp_exception_msg: [str] Expected exception message which is raised on writing
        """
        exception_raised = self.result.assert_raises(XmlRpcRemoteException, self.dut.write_to_field,
                                                     assert_msg, bit_field_name, bitfield_val,
                                                     raise_excep_on_fail=True)
        if exception_raised:
            exp_message = exception_raised.message
            exception_bool = exp_exception_msg in exp_message
            self.result.assert_true(exception_bool, "Exception raised when tried to write %s to bit field %s"
                                    % (bitfield_val, bit_field_name))
        else:
            self.result.assert_true(False, "Exception raised when tried to write %s to bit field %s"
                                    % (bitfield_val, bit_field_name))

    def _calculate_expected_bit_fields_counter(self):
        """
        Returns the R/O,W/O,Combo box,text field,radio button,slider bit fields count
        We need this for soak mode where we test all the registers.This could be different for each BSP based on their
        corresponding register map
        """
        combo_counter = 0
        text_field_counter = 0
        radio_button_counter = 0
        slider_counter = 0
        bit_wo_counter = 0
        bit_ro_counter = 0
        for register in self._get_register_not_validate():
            del self.register_class_dict[register]
        for reg_name, reg_object in self.register_class_dict.items():
            bit_fields = reg_object[self.reg_attr.BitFields]
            for bit_field in bit_fields:
                if bit_field[self.bit_field_attr.Access] == self.access_mode.W_O:
                    bit_wo_counter += 1
                elif bit_field[self.bit_field_attr.Access] == self.access_mode.R_O:
                    bit_ro_counter += 1
                elif bit_field[self.bit_field_attr.Access] == self.access_mode.R_W\
                        and bit_field[self.bit_field_attr.SoftwareAccess] != self.access_mode.W1C:
                    if bit_field[self.bit_field_attr.FieldType] == self.bit_field_attr.ComboBox:
                        combo_counter += 1
                    elif bit_field[self.bit_field_attr.FieldType] == self.bit_field_attr.RadioButton:
                        radio_button_counter += 1
                    elif bit_field[self.bit_field_attr.FieldType] == self.bit_field_attr.Slider:
                        slider_counter += 1
                    elif bit_field[self.bit_field_attr.FieldType] == self.bit_field_attr.TextField:
                        text_field_counter += 1
        return bit_wo_counter, bit_ro_counter, combo_counter, text_field_counter, radio_button_counter, slider_counter

    def _get_register_not_validate(self):
        """
        Returns a list of sensitive registers to be skipped for testing.
        Testing these registers might result in breaking the test system.
        This list comes from APPS team for each BSP or derive this from the datasheet.
        """
        registers_to_delete = []
        for register in self.each_register_info:
            register_name = register.get(self.reg_attr.DisplayName, register[self.reg_attr.Name])
            if register_name in self.reg_not_validate:
                registers_to_delete.append(register_name)
            elif(BSP.Cornell in self.device_type and
                    int(register[self.reg_attr.Address], self.hex_base) > self.address_range):
                registers_to_delete.append(register_name)
            elif isinstance(self.address_range, int):
                if self.address_range <= int(register[self.reg_attr.Address], self.hex_base):
                    registers_to_delete.append(register_name)
            elif isinstance(self.address_range, list):
                for addr_range in self.address_range:
                    addr_ranges = addr_range.split(",")
                    addr_ranges = [int(addr, 16) for addr in addr_ranges]
                    if addr_ranges[0] <= int(register[self.reg_attr.Address], self.hex_base) <= addr_ranges[1]:
                        registers_to_delete.append(register_name)
        return registers_to_delete

    def _calculate_expected_register_counter(self):
        """
        Returns the R/W,R/O,W/O registers counts
        We need this for soak mode where we test all the registers.This could be different for each BSP based on their
        corresponding register map
        """
        rw_counter = 0
        ro_counter = 0
        wo_counter = 0
        for register in self.each_register_info:
            register_name = register.get(self.reg_attr.DisplayName, register[self.reg_attr.Name])
            if register_name in self.registers_not_validate:
                continue
            else:
                access_mode = register[self.reg_attr.Access]
                if access_mode == self.access_mode.R_W:
                    rw_counter += 1
                elif access_mode == self.access_mode.R_O:
                    ro_counter += 1
                elif access_mode == self.access_mode.W_O:
                    wo_counter += 1
        return rw_counter, ro_counter, wo_counter

    @staticmethod
    def _ctrl_interface(dev_addr, dev_desc_addr):
        """
        Extracting device address values
        @param dev_addr [list] device address list
        @param dev_desc_addr [str] device description address
        """
        if not isinstance(dev_addr, list):
            dev_addr = int(dev_addr, 16)
            return dev_addr
        else:
            dev_addr_list = [int(value, 16) for value in dev_addr]
            for dev_addr in dev_addr_list:
                if dev_desc_addr == dev_addr:
                    return dev_addr
                else:
                    if isinstance(dev_addr, list):
                        dev_addr = dev_addr[0]
        return dev_addr

    @staticmethod
    def calculate_expected_value(prev_reg_value_bin, bit_field_val, reg_width, bit_field_addr):
        """
        Calculating the expected register value based on change in bit field

        @param prev_reg_value_bin: Previous register value
        @param bit_field_val: Bit field value
        @param reg_width: Width of the Register
        @param bit_field_addr: Address of Field
        @return: [int] expected register value
        """
        last_index = None
        prev_reg_value_bin = bin(int(prev_reg_value_bin))[2:]
        if isinstance(bit_field_val, str) and '0x' in bit_field_val:
            bit_field_val = bit_field_val.rstrip('L')
            bit_field_val_bin = bin(int(bit_field_val, 16))[2:]
        else:
            bit_field_val_bin = bin(int(bit_field_val))[2:]
        indexes = re.search(r'\[(\d+(:\d+)?)\]', bit_field_addr)

        if ":" in indexes.group(1):
            indexes = [int(index) for index in indexes.group(1).split(":")]
            indexes.sort()
        else:
            if indexes is not None:
                indexes = [int(indexes.group(1))]
            else:
                indexes = [0, reg_width]
        prev_reg_value_bin = list(prev_reg_value_bin.zfill(reg_width))
        if len(indexes) == 1:
            index = abs(indexes[0] - reg_width) - 1
            prev_reg_value_bin[index] = bit_field_val_bin
        else:
            if not indexes[0] == 0:
                last_index = -indexes[0]
            bit_field_width = -(indexes[1] + 1)
            bit_field_val_bin = bit_field_val_bin.zfill(indexes[1] - indexes[0] + 1)
            prev_reg_value_bin[bit_field_width:last_index] = bit_field_val_bin
        expected_value = int("".join(prev_reg_value_bin), 2)
        return expected_value

    def read_field_default(self, bit_field_name, register_name=None):
        """
        Returns the default value of a bitfield

        @param bit_field_name: [str] Bit field name
        @param register_name: [str] Register name of the bit field
        @return: [str] default value of bit field
        """
        if not register_name:
            register_name = self.dev_def_parser.get_regname_for_field(bit_field_name)

        register_info = self.register_class_dict[register_name]
        bit_field_info = self.get_bit_field_info(register_info, bit_field_name)

        return bit_field_info[self.bit_field_attr.DefaultValue]

    def get_bit_field_info(self, register_info, bit_field_name):
        """
        Returns bit field info

        @param register_info: [dict] Register Info to look for bit field
        @param bit_field_name: [str] Bit field name to look in register_info
        @return: [dict] Bit field info
        """
        for field in register_info[self.reg_attr.BitFields]:
            if field[self.bit_field_attr.Name] == bit_field_name:
                return field
