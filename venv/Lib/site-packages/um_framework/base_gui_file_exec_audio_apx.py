"""
@brief
Base class for file->execute Jython scripts using squish with AP box audio verification.
"""
import os
import math

from unified_modules.test_support.xmlrpc_support import XmlRpcRemoteException
from unified_modules.test_support.testresourceclaimer import ResourceRequirement
from unified_modules.resources.resource_apx import resource_apbox
from unified_modules.resources.resource_apx.resource_apbox import ApxBox
from .base_gui_squish import BaseGuiSquish


class BaseGuiFileExecAudioAPxError(Exception):
    """BaseGuiFileExecAudioAPxError for BaseGuiFileExecAudioAPx"""
    pass


class BaseGuiFileExecAudioAPx(BaseGuiSquish):
    def __init__(self,
                 apx_proj_name="EMU_Cornell_Audio_Configurations.approjx",
                 result=None,
                 testsystem=None):
        """
        Base class for file->execute Jython scripts using squish with AP box audio verification.
        """
        self.apx_tag = "ap_box"
        local_resources = [ResourceRequirement(tag=self.apx_tag,
                                               class_of_resource=ApxBox,
                                               res_type=self.apx_tag)]
        super(BaseGuiFileExecAudioAPx, self).__init__(result, testsystem, local_resources=local_resources)
        self.panel_test_suite = "suite_file_execute"
        self.panel_test_case = 'tst_TsAudioJythonExecute'
        self.skip_tests = ["tst_sampleTest"]
        self.test_case_inputs['panel_name'] = 'Device Overview'
        self.measurement_struct = {}
        self.measured_values = None
        self.tolerance = 20
        self.jython_script_executed = False
        self.nan = float('nan')

        self.local_resources = self.test_system.local_claimed_resources
        self.apx_box = self.local_resources[self.apx_tag].resource
        self.ap_box_config = self.local_resources[self.apx_tag].config
        self.ap_projects_path = self.ap_box_config['ap_projects_path']
        self.apx_proj_name = apx_proj_name
        self.ap_projects_full_path = os.path.join(self.ap_projects_path, self.apx_proj_name)
        apx_api_path = self.ap_box_config['apx_api_path']
        iron_python_path = self.ap_box_config['iron_python_path']
        self.apx_box.set_inputs(path_apx_api=apx_api_path, iron_python_path=iron_python_path)
        self.signal_name = ''
        self.expected_measurement = []
        self.report_name = "-".join([self.__class__.__name__, self.get_test_platform(), "APBox_report"])
        self.results_dir = os.path.join(os.path.dirname((os.path.abspath(__file__))), self.get_results_label())

    def setup(self):
        super(BaseGuiFileExecAudioAPx, self).setup()
        if not self.signal_name:
            raise BaseGuiFileExecAudioAPxError("AP project signal name is empty, set self.signal_name in test script")

    def initiate(self):
        try:
            self.squish_result = self.squish_resource.run_test_case(self.panel_test_case, self.panel_test_suite)
        except XmlRpcRemoteException as exc:
            raise BaseGuiFileExecAudioAPxError("Unable to execute jython script to configure the board,"
                                               " error:%s" % exc.message)

        if self.squish_result == "PASS":
            self.open_apx_project_run_signal_path()
            self.jython_script_executed = True

    def open_apx_project_run_signal_path(self):
        """
        Open apx project
        Run specified signal path
        Get measurement value of the specified signal path
        """
        self.apx_box.open_apx_proj(self.ap_projects_full_path)
        self.apx_box.set_report_name(self.results_dir, self.report_name)
        self.apx_box.run_signal_path(self.signal_name)
        self.measured_values = self.apx_box.get_measurement(self.measurement_struct)
        self.log.info("Audio measurements %s" % self.measured_values)

    def complete(self):
        """Check Audio measurements and squish test result."""
        if self.jython_script_executed:
            self.result.assert_true(self.apx_box.get_result(), "Check if AP signal was run successfully")
            for measurement_title, measurement_info in self.measurement_struct.items():
                channel_counter = 1
                measurement_type = measurement_info['m_type']
                expected_val = measurement_info['m_val']
                obtained_val = self.measured_values[measurement_title][measurement_type]['m_val']
                if isinstance(expected_val, list):
                    exp_val = expected_val[channel_counter - 1]
                else:
                    exp_val = expected_val
                for ob_val, exp_val in zip(obtained_val, expected_val):
                    if math.isnan(exp_val):
                        log_msg = "Check if %s measurement is nan for channel %s" % (measurement_type, channel_counter)
                        self.result.assert_true(math.isnan(ob_val), log_msg)
                    else:
                        log_msg = "Check if %s measurement is within limits for channel %s" % (measurement_type,
                                                                                               channel_counter)
                        self.result.assert_within_percentage(ob_val, exp_val, self.tolerance, log_msg)
                    channel_counter += 1
        self.print_squish_results()
        self.result.assert_true(self.download_scs_logs(), "Download SCS logs")

    def teardown(self):
        self.apx_box.close_apx_proj()
        super(BaseGuiFileExecAudioAPx, self).teardown()

