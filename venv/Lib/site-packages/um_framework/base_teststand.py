"""
Base class for GUI panels test automation using teststand tool.
"""
import os
import time

from unified_modules.test_support.testresults import PASS
from unified_modules.test_support.testresourceclaimer import ResourceRequirement
from unified_modules.test_support.testresourcebase import ResourceBase
from unified_modules.test_support.testlogger import log_file_time_stamp

from unified_modules.resources.resource_teststand.resource_teststand import ResourceTestStand

from .um_baseclass import UmBaseTest, read_project_mapping_config


class BaseTestStandError(Exception):
    """BaseTestStandError for BaseTestStand"""
    pass


class BaseTestStand(UmBaseTest):
    """
    Base class for test automation using teststand tool.
    """
    def __init__(self, result=None, testsystem=None, resources=None, test_platform='win10', local_resources=None):
        self.teststand_tag = 'resource_teststand'
        self.block = None
        self.seq_name = None

        local_resources = [ResourceRequirement(tag=self.teststand_tag,
                                                   class_of_resource=ResourceTestStand,
                                                   res_type=self.teststand_tag)]

        super(BaseTestStand, self).__init__(result, testsystem, local_resources=local_resources)
        self.local_resources = self.test_system.local_claimed_resources

        # This grabs the resource configuration that is extracted by the resource config file
        self.teststand_config = self.local_resources[self.teststand_tag].config
        # TODO - This works in getting a ResourceTestStand object, but not sure exactly how this happens
        self.teststand = self.local_resources[self.teststand_tag].resource

    def setup(self):
        """
        Check the test sequence path here
        """
        super(BaseTestStand, self).setup()

        # This will actually configure the ResourceTestStand object from the resource config object
        self.teststand.configure(self.teststand_config)
        if(self.seq_name == None):
            raise BaseTestStandError('The sequence name is not defined in the test. Define the seq_name attribute before running')

        # Build the sequence path based on the block name and sequence name
        search_dir = self.teststand.seq_root
        result = []
        for root, dir, files in os.walk(search_dir):
            if self.seq_name in files:
                result.append(os.path.join(root, self.seq_name))
        if(len(result)==0):
            raise BaseTestStandError('The sequence is not found in the path %s' % (search_dir))
        elif(len(result)>1):
            raise BaseTestStandError('Multiple sequences with the same name is found under the path %s' % (search_dir))
        self.seq_path = result[0]

    def initiate(self):
        super(BaseTestStand, self).initiate()
        self.ts_results = self.teststand.run_test_seq(self.seq_path)

    def complete(self):
        # Generate call stack for all issues. If there are no issues, this will be empty
        report = '\nCall Stack of Issues:\n'
        for issues in self.ts_results.issues:
            report += issues.gen_report() + '\n'

        # Assert based on the number of issues
        self.result.assert_true(len(self.ts_results.issues) == 0, report)
