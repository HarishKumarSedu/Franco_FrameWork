#!/usr/bin/env python
"""
Base class for Audio Tests using audiohub.
"""
import os
import platform
import re
import wave
from collections import namedtuple

try:
    from cirrusvue.core.connection.cirruslink.discovery import get_audiohub2
    from cirrusvue.common.audiohub2 import AudioHub as AudioHub2
except ImportError:
    print('Unable to import cirrus view package')

from studiolink.exceptions.StudioLinkException import StudioLinkException

import unified_modules.test_support.testlogger as logging

from unified_modules.test_support.xmlrpc_support import XmlRpcRemoteException
from unified_modules.test_support.testresourceclaimer import ResourceRequirement
from unified_modules.test_support.testresourcebase import ResourceBase

from unified_modules.resources.resource_squish.resource_squish import ResourceSquish
from unified_modules.resources.resource_bsp.resource_bsp_cmdline import BspCmdLine
from unified_modules.resources.resource_ftp.resource_ftp import MyFTPClient, ResourceFTPError

from unified_modules.resources.resource_scslinkapi.resource_scslinkapi import ScsLinkApi

from unified_modules.resources.resource_cirruslink.resource_cirruslink import ResourceCirrusLink
from unified_modules.resources.resource_audio_analysis.resource_audio_analysis \
    import ResourceAudioAnalysis
from unified_modules.resources.resource_audio_playrec.resource_audio_playrec import ResourceAudioPlayRec
from unified_modules.resources.resource_wav_generator.resource_wav_generator import ResourceWavGenerator


from .um_baseclass import UmBaseTest, MAX_TEST_DURATION, BSP, read_project_mapping_config, BSP_DEVICE_MAPPING, BSP_DICT

from .base_gui_squish import BaseGuiSquish


_non_gui_test_type = namedtuple('TestType', 'ScsLink CirrusVue')
NonGuiTestType = _non_gui_test_type('ScsLink', 'CirrusVue')


class BaseAudioHubError(Exception):
    def __init__(self, message=None):
        super(BaseAudioHubError, self).__init__(message)


class ExpectedAudioMetrics:
    def __init__(self, rms_level, peak_amplitude, dominant_frequency, thdn_db):
        self.rms_level = rms_level
        self.peak_amplitude = peak_amplitude
        self.dominant_frequency = dominant_frequency
        self.thdn_db = thdn_db


class BaseAudioHub(BaseGuiSquish, UmBaseTest):
    def __init__(self, result, test_system, log=None):
        """
        Requests modules required for Audio test as local resources
        """
        self.non_gui = "NonGui" in self.__class__.__name__
        UmBaseTest.__init__(self, result, test_system)
        self.os_platform = platform.system()
        self.results_folder_path = self.test_system.results_folder
        self.cirruslink_tag = 'cirruslink'
        self.wav_generator_tag = 'wav_generator'
        self.ftp_tag = 'ftp_server'
        self.scs_link_tag = 'scs_link'
        self.squish_tag = 'squish'
        self.bsp_cmdline_tag = "bsp_cmdline"
        self.power_switch_tag = 'power_switch'
        self.ftp_tag = 'ftp_server'
        self.non_gui_test_type = NonGuiTestType.ScsLink
        self.test_case_inputs = {}
        self.start_squish_server = True
        self.stop_squish_server = True
        self.set_target_system_name_and_file()
        self.set_target_device_name()
        self.expected_audio_metrics = ExpectedAudioMetrics(rms_level=10,
                                                           peak_amplitude=3,
                                                           dominant_frequency=3,
                                                           thdn_db=20)
        try:
            self.flag_remote_resources = self.test_system.run_options.remote
        except AttributeError:
            self.flag_remote_resources = False
        self.using_pa_multitrack = False
        if self.flag_remote_resources:
            if not self.non_gui:
                super(BaseAudioHub, self).__init__(result, test_system)
            if "win" in self.test_system.test_platform:
                self.resource_audio_play_rec_tag = 'audio_playrec_pamultitrack'
                self.using_pa_multitrack = True
            else:
                self.resource_audio_play_rec_tag = 'audio_play_rec'

            remote_resources = [ResourceRequirement(tag=self.resource_audio_play_rec_tag,
                                                    class_of_resource=ResourceBase,
                                                    res_type=self.resource_audio_play_rec_tag),
                                ResourceRequirement(tag=self.cirruslink_tag,
                                                    class_of_resource=ResourceBase,
                                                    res_type=self.cirruslink_tag),
                                ResourceRequirement(tag=self.wav_generator_tag,
                                                    class_of_resource=ResourceBase,
                                                    res_type=self.wav_generator_tag),
                                ResourceRequirement(tag=self.scs_link_tag,
                                                    class_of_resource=ResourceBase,
                                                    res_type=self.scs_link_tag),
                                ]
            if self.non_gui:
                remote_resources.append(ResourceRequirement(tag=self.ftp_tag,
                                                    class_of_resource=ResourceBase,
                                                    res_type=self.ftp_tag))
            self.request_resources(remote_resources)
            self.ah_cirruslink = self.resources[self.cirruslink_tag]
            self.wav_generator = self.resources[self.wav_generator_tag]
            self.rec_play = self.resources[self.resource_audio_play_rec_tag]
            self.rec_play_config = self.rec_play.config
            self.fpga_name = self.ah_cirruslink.config["fpga_name"]
            self.scs_link_resource = self.resources[self.scs_link_tag]
            self.system_name = self.resources[self.scs_link_tag].config["system_name"]
            self.ftp_server = self.resources[self.ftp_tag]
            self.scs_link_path = self.resources[self.scs_link_tag].config["path_to_scslink"]
            self.system_name = self.resources[self.scs_link_tag].config["system_name"]
            self.cirruslink_present = self.resources[self.scs_link_tag].config["cirruslink_present"]
            if not self.using_pa_multitrack:
                self.rec_play = self.resources[self.resource_audio_play_rec_tag]
                self.rec_play_config = self.resources[self.resource_audio_play_rec_tag].config
                self.rec_play.set_config_details(self.rec_play_config)
        else:
            self.resource_audio_play_rec_tag = 'audio_play_rec'
            local_resources = [ResourceRequirement(tag=self.cirruslink_tag,
                                                   class_of_resource=ResourceCirrusLink,
                                                   res_type=self.cirruslink_tag),
                               ResourceRequirement(tag=self.wav_generator_tag,
                                                   class_of_resource=ResourceWavGenerator,
                                                   res_type=self.wav_generator_tag),
                               ResourceRequirement(tag=self.resource_audio_play_rec_tag,
                                                   class_of_resource=ResourceAudioPlayRec,
                                                   res_type=self.resource_audio_play_rec_tag)]
            if self.non_gui:
                local_resources.append(ResourceRequirement(tag=self.scs_link_tag,
                                                           class_of_resource=ScsLinkApi,
                                                           res_type=self.scs_link_tag))
            else:
                local_resources.extend([ResourceRequirement(tag=self.squish_tag,
                                                            class_of_resource=ResourceSquish,
                                                            res_type=self.squish_tag),
                                        ResourceRequirement(tag=self.bsp_cmdline_tag,
                                                            class_of_resource=BspCmdLine,
                                                            res_type=self.bsp_cmdline_tag)])

            self.test_system.startup(resource_reqs=[], local_resources=local_resources)
            self.local_resources = self.test_system.local_claimed_resources
            if self.non_gui:
                self.scs_link_resource = self.local_resources[self.scs_link_tag].resource
                self.scs_link_path = self.local_resources[self.scs_link_tag].config["path_to_scslink"]
                self.system_name = self.local_resources[self.scs_link_tag].config["system_name"]
                self.cirruslink_present = self.local_resources[self.scs_link_tag].config["cirruslink_present"]
            self.ah_cirruslink = self.local_resources[self.cirruslink_tag].resource
            self.wav_generator = self.local_resources[self.wav_generator_tag].resource
            self.rec_play = self.local_resources[self.resource_audio_play_rec_tag].resource
            self.rec_play_config = self.local_resources[self.resource_audio_play_rec_tag].config
            self.rec_play.device_name = self.rec_play_config["device_string"]
            self.fpga_name = self.local_resources[self.cirruslink_tag].config["fpga_name"]
            if not self.non_gui:
                self.set_squish_test_inputs()
        self.audio_analysis = ResourceAudioAnalysis()
        self.fpga = None
        if log:
            self.log = log
        else:
            self.log = logging.getLogger(BaseAudioHub.__name__)
        self.sine_tone_wave_files = []

    def set_squish_test_inputs(self):
        """
        Set required inputs for squish like creating test inputs configuration files.
        """
        self.squish_resource = self.local_resources[self.squish_tag].resource
        self.squish_config = self.local_resources[self.squish_tag].config
        self.global_shared_folder = self.squish_config['global_shared_folder']
        self.bsp_cmdline_resource = self.local_resources[self.bsp_cmdline_tag].resource
        self.bsp_cmdline_resource.set_config_details(self.local_resources[self.bsp_cmdline_tag].config)
        self.test_case_inputs['real_system'] = 'sim' not in self.get_target_device()
        if self.test_case_inputs['real_system']:
            self.test_case_inputs['system_name'] = self.squish_config['system_name']
        else:
            target_device_list = self.target_device_name.split(" ")
            if BSP.Berry in self.device_type:
                target_device_name = ''.join([target_device_list[0], self.get_target_device().split("_")[1]])
            else:
                target_device_name = self.target_device_name
            self.test_case_inputs['system_name'] = ' '.join([target_device_name, self.system_type])
        self.test_case_inputs['device_name'] = self.target_device_name
        self.test_case_inputs['test_inputs_path'] = self.squish_config['test_inputs_path']
        self.test_case_inputs['test_inputs_common_path'] = self.squish_config['test_inputs_common_path']
        self.squish_config['target_system_name'] = self.get_target_device().split("_")[0]
        self.squish_config['bsp_mapping'] = read_project_mapping_config()

    def setup(self):
        """
        Connects to scs link or cirrusvue depending on test type
        """
        UmBaseTest.setup(self)
        if self.flag_remote_resources and not self.non_gui:
            super(BaseAudioHub, self).setup()
        elif self.non_gui:
            if self.non_gui_test_type == NonGuiTestType.ScsLink:
                self.result.test_step("Start SCS link")
                self.init_scs_link()
                self.result.test_step("Connect to audiohub device")
                try:
                    self.connect()
                except StudioLinkException:
                    self.dut.stop_link()
                    self.ah_cirruslink.audio_hub_cirruslink_restart(
                        self.local_resources[self.cirruslink_tag].config['ipaddress'])
                    self.init_scs_link()
                    self.connect()
            elif self.non_gui_test_type == NonGuiTestType.CirrusVue:
                self.connect_to_system_using_cirrusvue()
            else:
                raise BaseAudioHubError('Unsupported non-gui test type: %s' % self.non_gui_test_type)
        else:
            self.squish_resource.set_server_inputs(self._get_local_ip_address(),
                                                   self.squish_config,
                                                   self.global_shared_folder)
            self.squish_resource.start_squish_server()
            self.squish_resource.create_yml_file(self.test_case_inputs)

    def connect_to_system_using_cirrusvue(self):
        """
        Connect to system using cirrusvue
        """
        hub_name = re.search(r'\((.*?)\)', self.system_name).group(1)
        self.result.test_step("Start Cirrusvue")
        link = get_audiohub2(hubname=hub_name, transport='rndis')
        hub = AudioHub2(link)
        self.fpga = hub.fpga
        self.fpga.readField = hub.fpga.read_field
        self.fpga.writeField = hub.fpga.write_field

    def run_test(self):
        """
        Overriding bst base class run_test method to skip the timeout decorator.
        :return: None
        """
        MAX_TEST_DURATION['flag'] = False
        super(BaseAudioHub, self).run_test()

    def initiate(self, nchannels):
        """
        Generates sine wave
        In the case of gui executes the squish test case
        param nchannels:[int] Number of channels in wave file
        """
        for sine_wave in self.sine_tone_wave_files:
            sine_wave.filename = re.sub(r'generated_CH(\d)?-', 'generated_CH%s-' % nchannels, sine_wave.filename)
            if self.iteration_count == 1:
                sine_wave.filename = "-".join([os.path.splitext(sine_wave.filename)[0], self.get_target_device(),
                                               self.get_test_platform()]) + ".wav"
            if self.rec_play_config['wav_files_path'] not in sine_wave.filename:
                if self.get_test_platform().startswith("mac"):
                    sine_wave.filename = self.rec_play_config['wav_files_path'] + "/" + sine_wave.filename
                else:
                    sine_wave.filename = os.path.join(self.rec_play_config['wav_files_path'], sine_wave.filename)
            sine_wave.nchannels = nchannels
            self.log.info("Generating wav file: %s" % sine_wave.filename)
            self.wav_generator.make_sine_tone_wav(sine_wave)
        if self.non_gui:
            UmBaseTest.initiate(self)
        else:
            self.squish_result = self.squish_resource.run_test_case(self.panel_test_case, self.panel_test_suite)

    @staticmethod
    def create_tracklist(input_wav, output_wav, channels):
        """
        Creates tracklist required for input wav file

        @param input_wav: [str] Path of input wav file
        @param output_wav: [str] Path of output wav file
        @param channels: [Int] Number of channels of input wav file
        @return: list<list> tracklist required for pa_multitrack.exe
        """
        if channels > 1:
            channels = " ".join([str(ch) for ch in range(1, channels+1)])
        track_list = [[input_wav, channels, None], [output_wav, None, channels]]
        return track_list

    @staticmethod
    def get_samples_in_wav_file(wav_file_path):
        """
        Get number of samples in wav files

        @param wav_file_path: [str] wav file path
        @return: [int] Number of samples in a wav file
        """
        wav_handle = wave.open(wav_file_path, 'r')
        sample_rate = wav_handle.getframerate()
        duration = wav_handle.getnframes() / float(sample_rate)
        samples = int(sample_rate * duration)
        return samples

    def complete(self, nchannels):
        """
        Performs play and record
        Performs audio analysis on play and recorded wave files
        @param nchannels: Number of channels in a wave file
        """
        if self.flag_remote_resources and not self.non_gui:
            self.print_squish_results()
            self.result.assert_true(self.download_scs_logs(), "Download SCS logs")
            self.ftp_server.stop_ftp_server()
        for sine_wav in self.sine_tone_wave_files:
            input_wav = sine_wav.filename
            self.result.test_step("Play and record audio of %s stream" % input_wav)
            rec_file_name = input_wav.replace('generated', 'recorded')
            if self.using_pa_multitrack:
                self.rec_play.set_config(device_string=self.rec_play_config["device_string"],
                                         sample_rate=sine_wav.samplerate, bit_depth=sine_wav.sample_width * 8)
                track_list = self.create_tracklist(input_wav, rec_file_name, sine_wav.nchannels)
                self.rec_play.play_record_track_list(track_list, record=True, samples=self.get_samples_in_wav_file(
                    input_wav))
            else:
                try:
                    status = self.rec_play.play_record(input_wav, rec_file_name)
                    self.result.assert_true(status, "Record Play Method Status of %s stream" % input_wav)
                except XmlRpcRemoteException as e:
                    e = e.message
                    if self.non_gui and self.flag_remote_resources and 'Failed to load ASIO driver' in e:
                        exception_msg = "Exception raised: %s, known bug " \
                                        "https://tracker.cirrus.com/browse/FRAMEDEV-1152" % e
                        raise BaseAudioHubError(exception_msg)
                    else:
                        raise BaseAudioHubError(e)
            if self.flag_remote_resources:
                self.get_test_head_files([input_wav, rec_file_name])
                test_ctrl_gen_file = os.path.join(self.results_folder_path, os.path.basename(input_wav))
                test_ctrl_rec_file = os.path.join(self.results_folder_path, os.path.basename(rec_file_name))
            else:
                test_ctrl_gen_file = input_wav
                test_ctrl_rec_file = rec_file_name
            self.log.info("%s, %s", test_ctrl_rec_file, test_ctrl_gen_file)
            if 'win' in self.get_test_platform() and 'Dig' in self.__class__.__name__:
                status = self.audio_analysis.is_bit_perfect(test_ctrl_gen_file, test_ctrl_rec_file)
                self.result.assert_true(status, "Bit compare output signal with input signal for %s stream"
                                        % input_wav)
            play_metrics_dict = self.audio_analysis.analyse_channels(test_ctrl_gen_file)
            rec_metrics_dict = self.audio_analysis.analyse_channels(test_ctrl_rec_file)
            for play_ch, rec_ch in zip(play_metrics_dict, rec_metrics_dict):
                play_metrics = play_metrics_dict[play_ch]
                rec_metrics = rec_metrics_dict[rec_ch]
                self.result.assert_within_percentage(rec_metrics['rms_level'], play_metrics['rms_level'],
                                                     self.expected_audio_metrics.rms_level,
                                                     "Recorded: Check RMS level of the recorded audio for %s channel"
                                                     " stream" % play_ch)
                self.result.assert_within_percentage(rec_metrics['peak_amplitude'], play_metrics['peak_amplitude'],
                                                     self.expected_audio_metrics.peak_amplitude,
                                                     "Check Peak Amplitude of the recorded audio for %s channel "
                                                     "stream" % play_ch)
                self.result.assert_within_percentage(rec_metrics['dominant_frequency'],
                                                     play_metrics['dominant_frequency'],
                                                     self.expected_audio_metrics.dominant_frequency,
                                                     "dominant frequency of the recorded audio for %s "
                                                     "channel stream" % play_ch)
                self.result.assert_within_percentage(rec_metrics['thdn_db'], play_metrics['thdn_db'],
                                                     self.expected_audio_metrics.thdn_db,
                                                     "Recorded: Check THDN in dB of the recorded audio for %s "
                                                     "channel stream" % play_ch)

    def teardown(self):
        if self.non_gui:
            if self.non_gui_test_type == NonGuiTestType.ScsLink:
                self.scs_link_resource.stop_link()
            UmBaseTest.teardown(self)
        else:
            super(BaseAudioHub, self).teardown()

    def connect(self):
        """
        Connects to system using scs link
        """
        try:
            self.log.info("----- Searching for AudioHub -------")
            self.bsp_system_name = self.scs_link_resource.wait_until_system_available_to_connect(self.system_name,
                                                                                                retries=5)
            self.scs_link_resource.set_bsp_mapping(BSP_DICT, BSP_DEVICE_MAPPING)
            self.scs_link_resource.connect_to_board(self.bsp_system_name)
            if self.flag_remote_resources:
                system_name = self.scs_link_resource.config['system_name']
            else:
                system_name = self.local_resources[self.scs_link_tag].config['system_name']
            self.scs_link_resource.connect_to_system_and_device(system_name,
                                                                self.target_device_name,
                                                                init_pyhelper=False,
                                                                target_device=self.get_target_device(),
                                                                cirruslink_present=self.cirruslink_present)
        except StudioLinkException as ex:
            self.log.error("Communication error with Studio Link %s", ex)
            self.disconnect()

    def disconnect(self):
        """
        Stops scs link
        """
        self.scs_link_resource.stop_link()

    def init_scs_link(self):
        """
        Starts scs link
        """
        self.result.test_step("Init studio link with path %s and start link" % self.scs_link_path)
        self.scs_link_resource.initiate_studiolink(self.scs_link_path)
        self.scs_link_resource.start_link()

    def get_test_head_files(self, audio_files):
        """
        This method will transfer files from test head to test controller.
        :param audio_files: list of files which will be transferred from test head to controller
        """
        test_head_files_path = os.path.split(audio_files[0])[0]
        self.log.info(str(test_head_files_path))
        ftp_user = self.ftp_server.config.get('username')
        ftp_password = self.ftp_server.config.get('password')
        self.ftp_server.start_server(self.ftp_server.testhead.host,
                                     ftp_user,
                                     ftp_password,
                                     test_head_files_path)
        ftp_ip, ftp_port = self.ftp_server.get_ftp_ip_and_port()
        ftp_client = MyFTPClient(ftp_ip, ftp_port, ftp_user, ftp_password)
        for audio_file in audio_files:
            audio_file_name = os.path.basename(audio_file)
            results_folder_path = os.path.join(self.results_folder_path, audio_file_name)
            try:
                ftp_client.download_file(os.path.split(audio_file)[1], results_folder_path)
            except ResourceFTPError as ftp_error:
                self.log.warning(ftp_error)
        self.ftp_server.stop_ftp_server()

    def write_to_fpga_field(self, field_name, field_value):
        """
        Writes to a fpga bit field
        @param field_name: [str] Bit field name
        @param field_value: [hex] Bit field value
        """
        self.scs_link_resource.connect_to_device_write_to_field(self.fpga_name, field_name, field_value)

    def write_to_device_reg_by_addr(self, device_name, reg_addr, reg_value):
        """
        Connect to device and write to a register address on that device
        @param device_name: [str] Device name
        @param reg_addr: [hex] Register address
        @param reg_value: [hex] Register value
        """
        self.scs_link_resource.connect_to_device_write_to_reg_by_address(device_name, reg_addr, reg_value)

    def write_to_dev_field(self, device_name, field_name, field_value):
        """
        Connect to device and write to a bit field on that device
        @param device_name: [str] Device name
        @param field_name: [str] Bit field name
        @param field_value: [hex] Bit field value
        """
        self.scs_link_resource.connect_to_device_write_to_field(device_name, field_name, field_value)

    def write_to_fpga_reg_by_addr(self, reg_addr, reg_value):
        """
        Writes to fpga register by register address
        @param reg_addr: [hex] Register address
        @param reg_value: [hex] Register value
        """
        self.scs_link_resource.connect_to_device_write_to_reg_by_address(self.fpga_name, reg_addr, reg_value)
