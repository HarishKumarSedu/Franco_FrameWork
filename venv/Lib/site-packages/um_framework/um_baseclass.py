"""
Base class for UM tests
"""
import os
import sys
import importlib
import re
import time
import shutil
import itertools
import socket
import yaml
import json
from collections import namedtuple
if sys.version_info[0] == 3:
    import builtins as builtin
elif sys.version_info[0] == 2:
    import __builtin__ as builtin

from unified_modules.test_support.testbaseclass import BaseTest
from unified_modules.test_support.testutils import timeout
from unified_modules.test_support.testresourceclaimer import ResourceRequirement
from unified_modules.resources.resource_uvision.resource_uvision import ResourceUvision
from unified_modules.resources.resource_power_switch.resource_power_switch import ResourcePowerSwitch


# Target device sim postfix
VIRTUAL_BSP = 'sim'

# 15 mins for setup, remainder of test will not be attempted on timeout
MAX_SETUP_DURATION = {'duration': int(10 * 60), 'flag': True}

# 15 mins for non-soak test
MAX_TEST_DURATION = {'duration': int(15 * 60), 'flag': True}

# 15 mins for teardown
MAX_TEARDOWN_DURATION = {'duration': int(10 * 60), 'flag': True}

_FS_PLATFORMS = namedtuple('FS_PLATFORM', 'WISCE REMOTE')
FS_PLATFORMS = _FS_PLATFORMS('wisce', 'remote')

_proj_list = namedtuple('PROJ_LIST_USES_UVISION', 'LYNOTT DOMINO MAHONEY')
PROJ_LIST = _proj_list('lynott', 'domino', 'mahoney')


def read_project_mapping_config():
    """
    Reads project_mapping.yml and returns its content as dictionary
    return: [dict]  project_mapping.yml content
    """
    project_mapping_config = os.environ.get('PROJECT_MAPPING_CONFIG')
    if project_mapping_config is None:
        raise UmBaseTestError("PROJECT_MAPPING_CONFIG env variable not set")
    config_handle = open(project_mapping_config)
    return yaml.safe_load(config_handle)

def get_bsp_details():
    """
    Reads BSP details from project_mapping config
    @return: [namedtuple, dict, dict] BSP details
    """
    bsp_mapping = read_project_mapping_config()
    bsp_dev_id_keys = list(bsp_mapping['BSP'].keys())
    _BSP = namedtuple('BspProjects', ' '.join(bsp_dev_id_keys))
    return _BSP(*list(bsp_mapping['BSP'].values())), bsp_mapping['BSP_DEVICE_MAPPING'], \
           bsp_mapping['BSP']


BSP, BSP_DEVICE_MAPPING, BSP_DICT = get_bsp_details()

BST_TARGET_DEVICES = {BSP.Cornell: ['cornell_sim', 'cornell_emu_sim', 'cornell', 'cornell_emu'],
                      BSP.Taylor: ['taylor', 'taylor_sim'],
                      BSP.Jones: ['jones', 'jones_sim'],
                      BSP.Trucks: ['trucks_device1', 'trucks_device2',
                                   'trucks_device1_sim', 'trucks_device2_sim',
                                   'trucks_deviceA_emu_sim', 'trucks_deviceB_emu_sim', 'trucks_deviceA_emu',
                                   'trucks_deviceB_emu'],
                      BSP.Berry: ['berry_x4_device1', 'berry_x4_device2', 'berry_x4_device3', 'berry_x4_device4',
                                  'berry_x4_device1_sim', 'berry_x4_device2_sim', 'berry_x4_device3_sim',
                                  'berry_x4_device4_sim', 'berry_x4_device1_emu', 'berry_x4_device2_emu',
                                  'berry_x4_device3_emu', 'berry_x4_device4_emu', 'berry_x4_device1_emu_sim',
                                  'berry_x4_device2_emu_sim', 'berry_x4_device3_emu_sim', 'berry_x4_device4_emu_sim',
                                  'berry_x8_device1', 'berry_x8_device2', 'berry_x8_device3', 'berry_x8_device4',
                                  'berry_x8_device5', 'berry_x8_device6', 'berry_x8_device7', 'berry_x8_device8',
                                  'berry_x8_device1_sim', 'berry_x8_device2_sim', 'berry_x8_device3_sim',
                                  'berry_x8_device4_sim','berry_x8_device5_sim', 'berry_x8_device6_sim',
                                  'berry_x8_device7_sim', 'berry_x8_device8_sim', 'berry_x8_device1_emu',
                                  'berry_x8_device2_emu', 'berry_x8_device3_emu', 'berry_x8_device4_emu',
                                  'berry_x8_device5_emu', 'berry_x8_device6_emu', 'berry_x8_device7_emu',
                                  'berry_x8_device8_emu', 'berry_x8_device1_emu_sim', 'berry_x8_device2_emu_sim',
                                  'berry_x8_device3_emu_sim', 'berry_x8_device4_emu_sim' 'berry_x8_device5_emu_sim',
                                  'berry_x8_device6_emu_sim', 'berry_x8_device7_emu_sim', 'berry_x8_device8_emu_sim'],
                      BSP.Becker: ['becker_device1', 'becker_device2',
                                   'becker_device1_sim', 'becker_device2_sim',
                                   'becker_device0x62_emu', 'becker_device0x64_emu', 'becker_device0x66_emu',
                                   'becker_device0x68_emu', 'becker_device0x62_emu_sim', 'becker_device0x64_emu_sim',
                                   'becker_device0x66_emu_sim', 'becker_device0x68_emu_sim'],
                      BSP.Domino: ['domino_mode0_emu', 'domino_mode1_emu', 'domino_mode2_emu',
                                   'domino_mode3_emu', 'domino_mode0_emu_sim', 'domino_mode1_emu_sim',
                                   'domino_mode2_emu_sim','domino_mode3_emu_sim',
                                   'domino_mode0', 'domino_mode1', 'domino_mode2',
                                   'domino_mode3', 'domino_mode0_sim', 'domino_mode1_sim',
                                   'domino_mode2_sim','domino_mode3_sim'
                                    ],
                      BSP.BBking: ['bbking_1a_sim', 'bbking_1b_sim', 'bbking_1c_sim', 'bbking_1a', 'bbking_1b', 'bbking_1c'],
                      BSP.Dollar: ['dollar_emu', 'dollar_emu_sim', 'dollar', 'dollar_sim'],
                      BSP.Sterling: ['sterling_sim', 'sterling_emu_sim', 'sterling', 'sterling_emu'],
                      BSP.Lynott: ['lynott_emu', 'lynott_emu_sim', 'lynott', 'lynott_sim', 'lynott_emu_a0',
                                   'lynott_emu_b0', 'lynott_a0', 'lynott_b0', 'lynott_a0_ff']
                      }

BSP_ALL_TARGET_DEVICES = list(itertools.chain(BST_TARGET_DEVICES[BSP.Cornell],
                                              BST_TARGET_DEVICES[BSP.Taylor],
                                              BST_TARGET_DEVICES[BSP.Trucks],
                                              BST_TARGET_DEVICES[BSP.Berry],
                                              BST_TARGET_DEVICES[BSP.Becker],
                                              BST_TARGET_DEVICES[BSP.Jones],
                                              BST_TARGET_DEVICES[BSP.Domino],
                                              BST_TARGET_DEVICES[BSP.BBking],
                                              BST_TARGET_DEVICES[BSP.Dollar],
                                              BST_TARGET_DEVICES[BSP.Sterling],
                                              BST_TARGET_DEVICES[BSP.Lynott]))


BSP_REAL_HARDWARE_TARGET_DEVICES = ['cornell_emu', 'becker_emu', 'berry_emu', 'trucks_emu', 'domino_emu', 'bbking_emu',
                                    'sterling_emu', 'dollar_emu', 'lynott_emu']

BSP_SLIDER_TARGET_DEVICES = list(itertools.chain(BST_TARGET_DEVICES[BSP.Cornell],
                                                 BST_TARGET_DEVICES[BSP.Trucks],
                                                 BST_TARGET_DEVICES[BSP.Berry],
                                                 BST_TARGET_DEVICES[BSP.Domino],
                                                 BST_TARGET_DEVICES[BSP.BBking],
                                                 BST_TARGET_DEVICES[BSP.Dollar],
                                                 BST_TARGET_DEVICES[BSP.Sterling],
                                                 BST_TARGET_DEVICES[BSP.Lynott]))


class UmBaseTestError(Exception):
    """UmBaseTestError for UmBaseTest"""
    def __init__(self, *args):
        if args:
            self.message = args[0]
        else:
            self.message = None

    def __str__(self):
        if self.message:
            return self.message
        else:
            pass


class UmBaseTest(BaseTest):
    """UmBaseTest derived from testbaseclass"""
    def __init__(self, result=None, test_system=None, resources=None, test_platform='win10',
                 local_resources=[]):
        """Initialise default parameters"""
        self.code_coverage = False
        self.uvision_debug = False
        self.uvision = None

        if not test_system.get_test_platform():
            log_prefix = test_platform
            test_system.set_test_platform(test_platform)
            self.test_platform = test_platform
        else:
            log_prefix = test_platform
            self.test_platform = test_system.get_test_platform()
        self.soak = test_system.get_soak_flag()
        self.results_folder_flag = test_system.get_results_folder_flag()

        super(UmBaseTest, self).__init__(result=result,
                                         test_system=test_system,
                                         resources=resources,
                                         log_prefix=log_prefix,
                                         target_device="dummy")
        self.project_test_name = "-".join([self.__class__.__name__, self.get_target_device(), self.get_test_platform()])
        self.dut_type = ''
        self.device_type = ''
        self.target_system_name_sim = None
        self.target_system_name_real = None
        self.target_device_name = None
        self.target_system_file = None
        self.target_type = self.test_system.get_target_device().split("_")[0]
        fs_targets = list(FS_PLATFORMS._asdict().values())
        self.fs_in_um = self.target_type in fs_targets
        self.set_device_details()
        if self.soak:
            self.project_test_name = "-".join([self.project_test_name, "soak"])
            # some squish tests in soak mode takes more than 5 hours for cornell
            MAX_TEST_DURATION['duration'] = int(5 * 60 * 60)

        if "dual_domino" in self.get_target_device():
            self.project = "domino"
        else:
            self.project = self.get_target_device().split("_")[0]
        self.uvision_projects = [PROJ_LIST.LYNOTT, PROJ_LIST.DOMINO, PROJ_LIST.MAHONEY]
        self.mtb_projects = [PROJ_LIST.LYNOTT]

        try:
            self.uvision_debug = test_system.run_options.uvision_debug
        except AttributeError:
            self.log.info("Production mode, no runtime debugging using uVision enabled")

        if hasattr(test_system.run_options, "code_coverage"):
            self.code_coverage = test_system.run_options.code_coverage
        else:
            self.code_coverage = False
        if self.code_coverage and self.project in self.uvision_projects or self.uvision_debug:
            self.uvision = None
            self.uvision_tag = "resource_uvision"
            self.power_switch_tag = "resource_powerswitch"

        if self.code_coverage and self.project in self.mtb_projects:
            self.mtb_trace_started = False
            self.mtb_file_count = 0

        if self.code_coverage and self.project in self.uvision_projects or self.uvision_debug:
            if not ResourcePowerSwitch in [res.class_of_resource for res in local_resources]:
                local_resources.extend([ResourceRequirement(tag=self.power_switch_tag,
                                                            class_of_resource=ResourcePowerSwitch,
                                                            res_type=self.power_switch_tag)])
            if not ResourceUvision in [res.class_of_resource for res in local_resources]:
                local_resources.extend([ResourceRequirement(tag=self.uvision_tag,
                                                            class_of_resource=ResourceUvision,
                                                            res_type=self.uvision_tag)])
        if self.fs_in_um:
            fs_res_name = 'resource_%ssalad' % self.target_type.lower()
            if any(target_platform in self.target_type
                   for target_platform in fs_targets):
                target_class_name = "Resource%sSalad" % self.target_type.capitalize()
                fs_target_resource = importlib.import_module("unified_modules.resources.resource_fruitsalad.%s" %
                                                             fs_res_name)
                target_class = getattr(fs_target_resource, target_class_name)
                fs_res_req = ResourceRequirement(tag=fs_res_name, class_of_resource=target_class, res_type=fs_res_name)
                if local_resources:
                    local_resources.extend([fs_res_req])
                else:
                    local_resources = [fs_res_req]
            if self.test_system.test_config:
                for (config_key, config_value) in list(self.test_system.test_config.items()):
                    setattr(self, config_key, config_value)
        self.test_system.startup(local_resources=local_resources)
        if self.fs_in_um:
            self.fs_target = self.test_system.local_claimed_resources[fs_res_name].resource
            self.fs_target_config = self.test_system.local_claimed_resources[fs_res_name].config

        self.local_resources = self.test_system.local_claimed_resources

        if self.code_coverage and self.project in self.uvision_projects or self.uvision_debug:
            self.power_switch = self.local_resources[self.power_switch_tag].resource
            self.power_switch.set_config_details(fpga_load_delay=60)
            self.socket_number_mtb = self.local_resources[self.power_switch_tag].config.get('socket_number_mtb')
            self.powerswitch_present_mtb = self.local_resources[self.power_switch_tag].config.get('powerswitch_present')

            self.uvision = self.local_resources[self.uvision_tag].resource
            self.uvision_config = self.local_resources[self.uvision_tag].config
            self.uvision.set_config_details(self.uvision_config)
            if not self.uvision_config["hw_code_coverage"]:
                if self.project == PROJ_LIST.LYNOTT:
                    raise UmBaseTestError("Connect the MTB board for code coverage and set hw_code_coverage to True"
                                          " in test_controller_config.yml file")
                elif self.project == PROJ_LIST.DOMINO:
                    raise UmBaseTestError("Connect the Ulink Pro for code coverage and set hw_code_coverage to True"
                                          " in test_controller_config.yml file")
                else:
                    raise UmBaseTestError("Connect code coverage supported hardware and set hw_code_coverage to True")

    def setup(self):
        """UMF setup method"""
        self.record_test_name(self.project_test_name)
        self.code_coverage_folder = os.path.join(self.get_results_label(), 'code_coverage')
        if self.uvision_debug:
            self.uvision.open_project(debug_mode=True)

    def initiate(self):
        """UMF initiate method"""
        pass

    def complete(self):
        """UMF complete method"""
        pass

    def teardown(self):
        """UMF teardown method"""
        if self.uvision_debug:
            self.uvision.uv_pid.communicate()
        if self.fs_in_um:
            self.copy_fruit_salad_log_to_results_folder()
            self.fs_target.stop_resource_fruitsalad()
        super(UmBaseTest, self).teardown()

    @timeout(MAX_SETUP_DURATION)
    def run_setup(self):
        super(UmBaseTest, self).run_setup()

    @timeout(MAX_TEST_DURATION)
    def run_test(self):
        super(UmBaseTest, self).run_test()

    @timeout(MAX_TEARDOWN_DURATION)
    def run_teardown(self):
        # Removing time out on teardown to allow uVision debugging
        # Verifying the Debug flag
        # Setting the teardown flag to false
        if self.uvision_debug:
            MAX_TEARDOWN_DURATION['flag'] = False
        super(UmBaseTest, self).run_teardown()

    def set_device_details(self):
        """"To get the device details based on the target"""
        if self.fs_in_um:
            self.dut_type = self.test_system.target_device
            self.device_type = "_".join(self.test_system.target_device.split('_')[1:])
        else:
            self.bsp_target_dev_mapping = BSP_DEVICE_MAPPING
            self.dut_type = self.test_system.get_target_device()
            self.device_type = self.dut_type.split('_')[0]

    def get_test_platform(self):
        """
        Gets the test's execution platform name.

        Returns:
            str: the test's platform name.
        """
        return self.test_system.get_test_platform()

    def copy_fruit_salad_log_to_results_folder(self):
        """
        Copy fruit-salad log file to results label name folder
        """
        fs_log_path = self.fs_target.get_fs_log_file()
        fs_log = os.path.join(self.test_system.results_folder, self.__class__.__name__ + "-fruit_salad_log-" +
                              time.strftime('%Y%m%d%H%M%S'))
        shutil.copyfile(fs_log_path, fs_log)

    @staticmethod
    def _get_local_ip_address():
        tcp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # connect() for UDP doesn't send packets
        tcp.connect(('8.8.8.8', 1))
        local_ip_address = tcp.getsockname()[0]
        tcp.close()
        return local_ip_address

    def set_target_system_name_and_file(self):
        """
        Method to set BSP target system name and system file(Specific to BSP)
        """
        if "_emu" in self.dut_type:
            self.target_system_name_sim = "CS" + self.bsp_target_dev_mapping[
                self.device_type] + " Emulation Simulated_System"
            self.target_system_file = "emu" + self.bsp_target_dev_mapping[self.device_type].lower() + ".xml"
        else:
            self.target_system_name_sim = "CS" + self.bsp_target_dev_mapping[
                self.device_type] + " CDB Simulated_System"
            if BSP.Berry in self.device_type:
                self.target_system_file = ''.join(
                    ["cdb", self.bsp_target_dev_mapping[self.device_type].lower(), "_",
                     self.dut_type.split('_')[1], ".xml"])
            else:
                self.target_system_file = ''.join(["cdb", self.bsp_target_dev_mapping[self.device_type].lower(),
                                                   ".xml"])

    def set_target_device_name(self):
        """
        Method to set BSP target device name(Specific to BSP)
        """
        if BSP.Berry in self.device_type:
            self.device_type = BSP.Berry
        self.target_device_name = "CS" + self.bsp_target_dev_mapping[self.device_type]

        if BSP.Berry in self.device_type or BSP.Becker in self.device_type or BSP.Trucks in self.device_type:
            device_postfix = re.search('(device)(\d+)', self.dut_type)
            device_postfix = ' '.join([device_postfix.group(1).title(), device_postfix.group(2)])
            self.target_device_name += " " + device_postfix

        elif BSP.Domino in self.device_type:
            device_postfix = re.search('(mode)(\d+)', self.dut_type)
            device_postfix = ' '.join([device_postfix.group(1).title(), device_postfix.group(2)])
            self.target_device_name += " " + device_postfix
        elif BSP.BBking in self.device_type:
            self.target_device_name += " " + self.dut_type.split('_')[1].upper()

    def get_config(self, attr_name, optional_value=None):
        """
        Method to read test configuration value

        @param attr_name: [str] Configuration key
        @param optional_value: Optional value, if config key is not present.
        @return: Configuration key value
        """
        try:
            attr_value = builtin.getattr(self, attr_name)
            if attr_value is None:
                attr_value = optional_value
        except AttributeError:
            attr_value = optional_value
        return attr_value

    def record_test_name(self, name=None):
        if self.results_folder_flag:
            folder_name = "-".join([self.__class__.__name__, self.get_target_device(), self.get_test_platform()])
            log_folder = os.path.join(self.test_system.results_label, folder_name)
            if not os.path.exists(log_folder):
                os.mkdir(log_folder)
            self.test_system.results_label = log_folder
        super(UmBaseTest, self).record_test_name(name)

    def download_mtb_file(self):
        """
        Download mtb data
        @return: None
        """
        if not os.path.isdir(self.code_coverage_folder):
            try:
                os.makedirs(self.code_coverage_folder)
            except:
                # Code coverage folder already exists
                pass
        file_name = "-".join([self.project_test_name, "MTB%s" % self.mtb_file_count, self.test_timestamp])
        file_name = file_name + ".csv"
        self.log.info("Dumping memory in %s" % file_name)
        try:
            self.uvision.dump_mtb_memory(self.code_coverage_folder, file_name)
        except Exception as e:
            self.log.warning(e)
            if self.powerswitch_present_mtb and self.socket_number_mtb:
                self.power_switch.power_reset(self.socket_number_mtb)
