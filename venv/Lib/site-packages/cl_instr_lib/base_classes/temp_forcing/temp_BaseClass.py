from time import time, sleep
from abc import ABC, abstractmethod
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa


class Temp_BaseClass(InstrumentVisa, ABC):
    """
    Abstract base class for a generic temperature forcing systems.

    Classes for specific systems (i.e Sensata) may inherit from this to define a basic interface including the state
    machine for set_temp_and_soak() and its configuration parameters.
    """

    def __init__(self, visa_resource_name, **kwargs):
        """Initializes base class attributes needed for the methods provided by the base class."""
        super().__init__(visa_resource_name, **kwargs)

        # Child class __init__ can redefine __name to make it more specific. (Add COM port for example).
        self.__name = __class__.__name__

        # property defaults - I guess child classes for specific temperature machines could set new values for these
        # in their __init__ methods.
        self.__msg_style = 'scroll'
        self.__settling_trials = 10
        self.__settling_interval = 1.0  # Units are seconds.
        self.__ramping_interval = 1.0  # Units are seconds.
        self.__soaking_interval = 1.0  # Units are seconds.
        self.__timeout = 10  # units are minutes

        self.__prev_msg = ''

    def configure(self, msg_style=None, ramping_interval=None, settling_trials=None, settling_interval=None,
                  soaking_interval=None, timeout=None):
        """
        Query or set parameters to control driver behavior regarding status messages and settling criteria.

        :param msg_style: Determines if messages scroll up the screen or are printed on a single line.

            * 'inline' - messages are printed over and over on the same line without scrolling.
            * 'scroll' - messages scroll up the screen with the newest message printed at the bottom.
            * 'none' -  no messages are printed during ramping to new setpoint, settling, or soaking.
        :type msg_style: str
        :param ramping_interval: During transition from one temperature to another, temperature readings are taken this
            many seconds apart.
        :type ramping_interval: float
        :param settling_trials: This number of consecutive readings falling within the set point tolerance determines
            that we have ramped to and settled at the set point temperature.
        :type settling_trials: int
        :param settling_interval: Seconds between each settling trial.
        :type settling_interval: float
        :param soaking_interval: During soak time, temperature readings are taken this many seconds apart.
        :type soaking_interval: float
        :param timeout: If the set_temp_and_soak method state machine stays in the RAMPING or SETTLING states
            for longer than this number of **minutes**, then a RuntimeError exception is raised. This could occur
            because  of a machine malfunction that causes the desired temperature to not be achieved.
        :type timeout: float
        :return: If no input parameters are given, current settings are returned as a dictionary. Otherwise None.
        :rtype: dict|None
        """

        # Return all the current configuration settings
        if all([x is None for x in (msg_style, ramping_interval, settling_trials, settling_interval,
                                    soaking_interval, timeout)]):

            # Return all the present settings as a dict.

            return_values = {}
            return_values.update(msg_style=self.__msg_style)
            return_values.update(ramping_interval=self.__ramping_interval)
            return_values.update(settling_trials=self.__settling_trials)
            return_values.update(settling_interval=self.__settling_interval)
            return_values.update(soaking_interval=self.__soaking_interval)
            return_values.update(timeout=self.__timeout)
            return return_values

        # Check validity of all user provided inputs:

        if msg_style is not None:
            msg_style = msg_style.lower()
            if msg_style not in ['none', 'scroll', 'inline']:
                raise ValueError(f"bad style '{msg_style}', should be one of: 'none', 'scroll', 'inline'.")

        if ramping_interval is not None:
            if ramping_interval < 0.1 or ramping_interval > 10.:
                raise ValueError(f"Bad interval {ramping_interval}, should be 0.1 to 10 sec.")

        if settling_trials is not None:
            settling_trials = int(settling_trials)
            if settling_trials < 0:
                raise ValueError(f"Bad trials, {settling_trials}, should be integer >= 0.")

        if settling_interval is not None:
            if settling_interval < 0.1 or settling_interval > 10.:
                raise ValueError(f"Bad interval {settling_interval}, should be 0.1 to 10 sec.")

        if soaking_interval is not None:
            if soaking_interval < 0.1 or soaking_interval > 10.:
                raise ValueError(f"Bad interval {soaking_interval}, should be 0.1 to 10 sec.")

        if timeout is not None:
            if timeout < 1.0:
                raise ValueError(f"Bad timeout {timeout} < 1 minute, probably would not allow state machine to "
                                 f"complete the RAMPING and SETTLING states during a temperature change.")
            if timeout > 60:
                self.log.warn(f"Long timeout {timeout} minutes for RAMPING / SETTLING, use with care!")

        # If we got here then all inputs were valid then write them

        if msg_style is not None:
            self.__msg_style = msg_style

        if ramping_interval is not None:
            self.__ramping_interval = ramping_interval

        if settling_trials is not None:
            self.__settling_trials = settling_trials

        if settling_interval is not None:
            self.__settling_interval = settling_interval

        if soaking_interval is not None:
            self.__soaking_interval = soaking_interval

        if timeout is not None:
            self.__timeout = timeout

    def __del__(self):
        """When object is garbage collected, this will get called to reset to a safe temp."""
        print(f"Deleting {self.__name}, returning to room temperature.")
        self.set_temperature(25)

    def _print_msg(self, msg):
        """
        Prints msg according to the msg_style.
        """
        if self.__msg_style == 'inline':
            backspaces = '\b' * len(self.__prev_msg)
            print(backspaces, end='')
            print(msg, end='')
            self.__prev_msg = msg
        elif self.__msg_style == 'scroll':
            print(msg)
            self.__prev_msg = ''
        else:
            self.__prev_msg = ''

    @abstractmethod
    def get_temperature(self):
        """Returns the set point of the temperature forcing system in deg C.

        :return: Set point value read back from the temperature forcing system. Units are degrees C.
        :rtype: float
        """
        pass

    @abstractmethod
    def measure_temperature(self):
        """Returns the present temperature in deg C.

        :return: The present temperature as measured by the temperature forcing system. Units are degrees C.
        :rtype: float
        """
        pass

    @abstractmethod
    def set_temperature(self, temperature):
        """Set the set point of the temperature forcing system in deg C."""
        pass

    def set_temp_and_soak(self, setpoint, soak_time=0, tolerance=2.5):
        """
        Set parameters to specify the set point, soak time, and the tolerance above and below the set point.

        This method implements a state machine with states: START, RAMPING, SETTLING, SOAKING and DONE.

        During RAMPING, temperature is measured at intervals defined by the configuration parameter *ramping_interval*.
        RAMPING ends and SETTLING begins at the first measurement that falls within +/- tolerance of setpoint.

        During SETTLING, measurements are made at intervals defined by the configuration parameter *settling_interval*.
        SETTLING ends when a number of *consecutive* readings within +/- tolerance of setpoint occurs; this number is
        defined by the configuration parameter *settling_trials*. This helps ensure the settling of overshoot/undershoot
        that can occur following the transition to the new temperature.

        Following SETTLING, the specified soak_time soak interval begins. After this time a final measurement is made
        and the value returned.

        :param setpoint: Sets the desired target temperature in degrees C.
        :type setpoint: float
        :param soak_time: Once temperature has ramped to the set point and met the settling criteria, wait this many
            *seconds* for the DUT to reach thermal equilibrium. Can be 0 to skip the soak phase.
        :type soak_time: int, float
        :param tolerance: Ramping to setpoint is considered complete when the measured temperature is
            within +/- tolerance of setpoint for the configured number of settling_trials. Once this has
            been achieved, any overshoot/undershoot of the desired temperature is assumed to be settled and the soak
            time begins.
        :type tolerance: int, float
        :return: Returns the post soak time measured temperature in degrees C.
        :rtype: float
        """

        temp_min = setpoint - tolerance
        temp_max = setpoint + tolerance

        symbol_degc = u'\xb0' + 'C'

        settling_queue = []
        # Run a state machine...

        self.__prev_msg = ''
        time_entered = time()

        sleep_time = 0
        state = 'START'
        next_state = 'START'
        msg = ""
        actual_temp = ""
        while True:
            sleep(sleep_time)

            if next_state != 'START':
                full_msg = f"{state:8s} {msg} measured_temp={actual_temp:3.1f}{symbol_degc}."
                self._print_msg(full_msg)

            if state != next_state:
                state = next_state
                time_entered = time()

            if state in ('RAMPING', 'SETTLING') and (time() - time_entered) > self.__timeout * 60:
                raise RuntimeError(f"Timeout ({self.__timeout} minutes) exceeded during {state}.")

            actual_temp = self.measure_temperature()

            if state == 'START':
                msg = f"setting setpoint to {setpoint:3.1f}{symbol_degc}."
                self.set_temperature(setpoint)
                sleep_time = self.__ramping_interval
                next_state = 'RAMPING'

            elif state == 'RAMPING':
                msg = f"to setpoint {setpoint: 3.1f}{symbol_degc}, after {time() - time_entered:3.0f} sec "
                if abs(actual_temp - setpoint) > tolerance:
                    continue
                next_state = 'SETTLING'

            elif state == 'SETTLING':
                if self.__settling_trials < 1:
                    msg = f"skipped, {self.__settling_trials} settling_trials configured."
                    next_state = 'SOAKING'
                    continue

                # Create a list of last 10 measurements.
                settling_queue.append(actual_temp)
                if len(settling_queue) > self.__settling_trials:
                    settling_queue.pop(0)  # remove oldest

                # Create char string depicting the history.
                history = ''.join(['L' if t < temp_min else 'H' if t > temp_max else 'T' for t in settling_queue])

                msg = "to {:3.1f} +/- {:2.1f}{} for {:2d} consecutive readings: {:{width}s}, {:3.1f} sec.". \
                    format(setpoint, tolerance, symbol_degc, self.__settling_trials, history[::-1],
                           time() - time_entered, width=self.__settling_trials)

                if history.count('T') < self.__settling_trials:  # Where all within tolerance?
                    sleep_time = self.__settling_interval
                else:
                    next_state = 'SOAKING'

            elif state == 'SOAKING':
                if soak_time < 0.1:
                    msg = f"skipped, 0 sec soak time configured."
                    next_state = 'DONE'
                    continue

                soak_remaining = soak_time - (time() - time_entered)
                if soak_remaining > 0:
                    msg = f"for {soak_time:3.0f} sec, {soak_remaining:3.0f} sec remaining."
                    sleep_time = self.__soaking_interval
                else:
                    next_state = 'DONE'
                    sleep_time = 0
                    msg = f"soak for {soak_time:3.0f} sec completed,"

            elif state == 'DONE':
                msg = f"Final "
                next_state = 'EXIT'

            else:
                if self.__msg_style == 'inline':
                    print('')
                return actual_temp
