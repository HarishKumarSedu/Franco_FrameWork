import os
import logging
import inspect
from enum import Enum

import cl_instr_lib
from cl_instr_lib.base_classes.pyro_isinstance import PyroIsinstance
from cl_instr_lib.helpers.instr_logging import InstrLoggingAdapter, add_file_handler, add_stream_handler
from cl_instr_lib.helpers.check_enum_str import check_enum_str


class Instrument(PyroIsinstance):
    enum_unused_args_handling = Enum('enum_unused_args_handling', 'LOG_UNUSED RAISE LOG_ALWAYS')

    """Framework instrument adapter identifies drivers as classes with Instrument in their ancestry. Driver classes
    inherit Instrument indirectly through interface specific (visa, pxie) Instrument classes that are derived from
    this.
    """

    def __init__(self, resource_name):
        self.resource_name = resource_name

        # Establish default
        self.unused_args_handling = self.enum_unused_args_handling.LOG_UNUSED

        # Must have attribute named visa_resource_name for Framework to recognize as a driver class.
        self.visa_resource_name = resource_name

    def get_logger_adapter(self, logger):
        # Set up logger
        log_path = os.path.join(cl_instr_lib.__path__[0], f'log_files/{self.__class__.__name__}_log.log')
        if logger is None:  # Grab cl_test_station logger and add handlers
            logger = logging.getLogger(f'cl_instr_lib.{self.resource_name}')
            if len(logger.handlers) == 0:  # logger.handlers == []
                add_stream_handler(logger)
                add_file_handler(logger, log_path)
        elif isinstance(logger, InstrLoggingAdapter):  # log adapter is passed in from another TSO, use its internal
            # logger
            logger = logger.logger
        else:  # External logger passed in, transfer handlers and add File handler and stdout handler
            instr_logger = logging.getLogger(f'cl_instr_lib.{self.resource_name}')
            if isinstance(logger, logging.Logger):
                instr_logger.handlers.extend(logger.handlers)
            elif isinstance(logger, logging.LoggerAdapter):
                instr_logger.handlers.extend(logger.logger.handlers)
            # add_stream_handler(instr_logger)
            add_file_handler(instr_logger, log_path)
            logger = instr_logger
        logger.propagate = False  # Prevents double prints, cl_test_station uses custom color formatted stdout handler

        return InstrLoggingAdapter(logger, self.__class__.__name__, self.resource_name)
    
    def log_unused_args(self, args, kwargs):
        """
        Used in driver methods to log extra inputs which may occur when instruments models are substituted and/or
        incorrect keyword argument names are used.

        Example: Client code for a PSM6003 might include the range='LOW' parameter in a call to source_voltage. If the
        supply is in fact an E3631A, its source_voltage method ignores the range parameter, absorbing it into its kwargs
        parameter, and log_unused_args will generate a log message to let us know this occurred.

        **NOTE:** The behavior of log_unused_args is defined by the unused_args_handling parameter of debug_options().

        :param args: List of positional arguments not absorbed by the normal arguments of the driver.
        :param kwargs: Dictionary of keyword arguments not absorbed by the normal arguments of the driver.
        :return: None
        """

        if args or kwargs or self.unused_args_handling == self.enum_unused_args_handling.LOG_ALWAYS:
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            filename = os.path.basename(filename)
            caller = frame_record[3]
            lineno = frame_record[2]
            msg = f"log_unused_args: {filename}: line {lineno} : {caller} : "
        else:
            return

        if args:
            msg += ', '.join([str(v) for v in args])

        if kwargs:
            if args:
                msg += ', '
            msg += ', '.join([f"{k}={str(v)}" for k, v in kwargs.items() if k != 'skip_write'])
            # 'skip_write' is special key used for delegating a portion of input checking to a parent driver class.

        if self.unused_args_handling == self.enum_unused_args_handling.RAISE:
            self.log.error(msg)
            raise RuntimeError(msg)

        if not args and not kwargs:
            msg += 'No unused args.'

        self.log.info(msg)


    def debug_options(self, unused_args_handling=None, *args, **kwargs):
        """
        Query or set driver debug options.

        :param unused_args_handling: Driver methods designed to accommodate instrument substitution use args and kwargs
            to absorb and ignore any extra arguments passed from calling code that was written for another instrument.
            Such methods begin with a call to log_unused_args. This parameter controls what log_unused_args does.

            * 'LOG_UNUSED' - Just log the unused parameters that were passed in using the INFO logging level. This is \
                the default mode, allowing instrument substitution to function. The message contains the location \
                within the driver where log_unused_args was called.
            * 'RAISE' - Does what LOG_UNUSED does, but the ERROR logging level is used and a RuntimeError exception \
                is raised. Instrument substitution will fail if parameters are passed in that are not used by the \
                present instrument driver. In interactive use, 'RAISE' can be useful to make it obvious when you \
                misspell a keyword argument name.
            * 'LOG_ALWAYS' - Always generates logging output showing the location where log_unused_args was called.

        :type unused_args_handling: None|enum_unused_args_handling|str
        :return: dict|None
        """

        if all([v is None for v in [unused_args_handling]]):
            return_values = {}
            return_values.update(unused_args_handling=self.unused_args_handling.name)
            return return_values

        # Check all inputs

        unused_args_handling = check_enum_str('unused_args_handling', unused_args_handling,
                                              self.enum_unused_args_handling)

        if unused_args_handling is not None:
            self.unused_args_handling = unused_args_handling


