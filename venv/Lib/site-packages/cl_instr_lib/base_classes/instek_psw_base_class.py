from collections import namedtuple
from enum import Enum

from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_VI_ABC
from cl_instr_lib.helpers.check_enum_str import check_enum_str

ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])
ProtectionBounds = namedtuple('ProtectionBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])


class InstekPswBaseClass(InstrumentVisa, PowerSupply):
    """Base class for driver implementation shared between PSWx supplies."""

    def __init__(self, visa_resource_name, logger, programming_bounds, protection_bounds, **kwargs):

        # Setup the Instrument class which creates the GPIB resource.
        super().__init__(visa_resource_name, logger, **kwargs)

        # Create the channel objects. (Note creating the attributes directly enables auto-complete in editor.)
        # Pass power supply self down to channel so he knows who his container is.
        self.OUTPUT = Channel(self, 'OUTPUT', 1, programming_bounds, protection_bounds)
        self._channel_names = ['OUTPUT']

    def output_state(self, on_off=None):
        """
        Queries or sets the power supply output state OFF or ON.

        :param on_off: For ON accepts 'ON', True, 1 or '1'. For OFF accepts 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.

        """
        if on_off is None:
            return self.on_off.to_api(self.query('OUTP', int))  # Supply will return 0 for off, 1 for on.

        self.write('OUTP', self.on_off.to_inst(on_off))  # Works because supply can use 0 for OFF, 1 for ON.

    def reset(self):
        """
        Resets the supply to VOLTAGE mode and 0.0V output.

        :return: None
        """
        super().reset()

        # Sets last_forcing_mode to 'VOLTAGE' which is post reset default.
        # Also, in simulation, puts forcing_range into sim buffer so query readback works.
        self.OUTPUT.source_voltage(voltage=0.0, current_limit=0.0)


class Channel(PSChannel_VI_ABC):

    def __init__(self, power_supply, channel_name, channel_id, programming_bounds,
                 protection_bounds):

        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)

        self.channel_id = channel_id
        self.protection_bounds = protection_bounds

        self.last_forcing_mode = None  # Used to save the mode programmed because there is no SCPI read back command.

    def source_voltage(self, voltage=None, current_limit=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **VOLTAGE** source.

        :param voltage: Output in Volts. Max value depends on forcing_range setting, see attribute programming_bounds.
        :type voltage: float
        :param current_limit: Compliance limit in Amps. Max value depends on forcing_range setting, see attribute
                              programming_bounds.
        :type current_limit: float
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit}):
            if self.last_forcing_mode is None:
                raise RuntimeError(f"Last operating mode unknown, set values and mode using either the source_voltage "
                                   f"or source_current method.")
            elif self.last_forcing_mode == 'CURRENT':
                raise RuntimeError(f"Output was last programmed to be a current source, "
                                   f"use source_current method to retrieve settings.")
            return_value = {}
            return_value.update(voltage=self.power_supply.query("VOLT", float))
            return_value.update(current_limit=self.power_supply.query("CURR", float))

            return return_value

        # Based on the name of the range, get the appropriate voltage bounds.
        volts_min = self.programming_bounds.volts_min
        volts_max = self.programming_bounds.volts_max

        if voltage is None:
            # User didn't provide the voltage, so read it from the instrument.
            voltage_setting = self.power_supply.query('VOLT', float)

        elif not (volts_min <= voltage <= volts_max):
            # User gave us a new voltage, it is not valid for the range that will be in effect.
            raise ValueError(f"Bad voltage {voltage} V for {type(self.power_supply).__name__}"
                             f", should be {volts_min} to {volts_max} V.")

        else:
            # The voltage the user input is OK.
            voltage_setting = voltage

        # Based on the name of the range, get the appropriate current bounds.
        amps_min = self.programming_bounds.amps_min
        amps_max = self.programming_bounds.amps_max

        if current_limit is None:
            # User didn't provide the current, read it from the instrument.
            current_setting = self.power_supply.query('CURR', float)

        elif not (amps_min <= current_limit <= amps_max):
            raise ValueError(f"Bad current_limit {current_limit} A for {type(self.power_supply).__name__}"
                             f", should be {amps_min} to {amps_max} A.")

        else:
            current_setting = current_limit

        # Order is critical, it sets the forcing mode! Also, note that we MUST set both, even if user only specified,
        # one, this preserves the operating mode.
        self.power_supply.write("VOLT", voltage_setting)
        self.power_supply.write("CURR", current_setting)

        # Since there is no SCPI cmd to read back the present mode, we use this to help ensure the read back results are
        # correctly interpreted.
        self.last_forcing_mode = 'VOLTAGE'

        self.power_supply.log_inst_errors()

    def source_current(self, current=None, voltage_limit=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **CURRENT** source.

        :param current: Output in Amps. Max value depends on forcing_range setting, see attribute programming_bounds.
        :type current: float
        :param voltage_limit: Compliance limit in Volts. Max value depends on forcing_range setting, see attribute
                              programming_bounds.
        :type voltage_limit: float
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {current, voltage_limit}):
            if self.last_forcing_mode is None:
                raise RuntimeError(f"Last operating mode unknown, set values and mode using the source_current or "
                                   f"source_voltage method.")
            elif self.last_forcing_mode == 'VOLTAGE':
                raise RuntimeError(f"Output was last programmed to be a voltage source, "
                                   f"use source_voltage method to retrieve settings.")
            return_value = {}
            return_value.update(current=self.power_supply.query("CURR", float))
            return_value.update(voltage_limit=self.power_supply.query("VOLT", float))

            return return_value

        # Based on the name of the range, get the appropriate voltage bounds.
        volts_min = self.programming_bounds.volts_min
        volts_max = self.programming_bounds.volts_max

        if voltage_limit is None:
            # User didn't provide the voltage, so read it from the instrument.
            voltage_setting = self.power_supply.query('VOLT', float)

        elif not (volts_min <= voltage_limit <= volts_max):
            # User gave us a new voltage_limit, is it valid for the range that will be in effect?
            raise ValueError(f"Bad voltage_limit {voltage_limit} V for {type(self.power_supply).__name__},"
                             f" should be {volts_min} to {volts_max} V.")

        else:
            # The voltage_limit the user input is OK.
            voltage_setting = voltage_limit

        # Based on the name of the range, get the appropriate current bounds.
        amps_min = self.programming_bounds.amps_min
        amps_max = self.programming_bounds.amps_max

        if current is None:
            # User didn't provide the current, read it from the instrument.
            current_setting = self.power_supply.query('CURR', float)

        elif not (amps_min <= current <= amps_max):
            raise ValueError(f"Bad current {current} A, for  {type(self.power_supply).__name__},"
                             f" should be {amps_min} to {amps_max} A.")

        else:
            current_setting = current

        # Order is critical, it sets the forcing mode! Also, note that we MUST set both, even if user only specified,
        # one, this preserves the operating mode.
        self.power_supply.write("CURR", current_setting)
        self.power_supply.write("VOLT", voltage_setting)

        # Since there is no SCPI cmd to read back the present mode, we use this to help ensure the read back results are
        # correctly interpreted.
        self.last_forcing_mode = 'CURRENT'
        self.power_supply.log_inst_errors()

    def measure_voltage(self):
        return self.power_supply.query("MEAS:VOLT", float)

    def measure_current(self):
        return self.power_supply.query("MEAS:CURR", float)

    def output_state(self, on_off=None):
        """Queries or sets the power supply output state: OFF or ON.

        "param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """

        return self.power_supply.output_state(on_off)

    def ocp_value(self, ilimit=None):

        if ilimit is None:
            return self.power_supply.query('CURR:PROT', float)

        if self.output_tripped():
            raise ValueError("OCP is tripped, clear before changing value.")

        if self.protection_bounds.amps_min <= ilimit <= self.protection_bounds.amps_max:
            self.power_supply.write('CURR:PROT', ilimit)
        else:
            raise ValueError(f"Bad ilimit {ilimit} A, should be from "
                             f"{self.protection_bounds.amps_min} A to {self.protection_bounds.amps_max} A.")

    def ocp_state(self, on_off=None):

        if on_off is None:
            return self.power_supply.on_off.to_api(self.power_supply.query('CURR:PROT:STAT', int))

        # if on_off not in self.power_supply.enum_on_off:
        #     raise ValueError(f"Bad on_off {on_off}, should be one of enum_off_on")

        if self.output_tripped():
            raise ValueError("Output protection is tripped, clear before changing state.")

        inst_value = self.power_supply.on_off.to_inst(on_off)
        self.power_supply.write('CURR:PROT:STAT', inst_value)

    def ovp_value(self, vlimit=None):

        if vlimit is None:
            return self.power_supply.query('VOLT:PROT', float)

        if self.output_tripped():
            raise ValueError("Output protection is tripped, clear before changing value.")

        if self.protection_bounds.volts_min <= vlimit <= self.protection_bounds.volts_max:
            self.power_supply.write('VOLT:PROT', vlimit)
        else:
            raise ValueError(f"Bad vlimit {vlimit} V, should be from "
                             f"{self.protection_bounds.volts_min} V to {self.protection_bounds.volts_max} V.")

    def output_prot_clear(self):
        """ Clears over-voltage, over-current and overtemperature (OVP, OCP, OTP) protection circuits.
            It also clears the shutdown protection circuit. Writes command to clear Over Voltage Protection trip.
            Protection circuits, if enabled, shut down the supply when the voltage/current/temp at the
            terminals exceeds the set value. Note that after clearing the trip state,
            the output will remain off until reactivated using the state method.
        """
        self.power_supply.write('OUTP:PROT:CLE', "")

    def output_tripped(self):
        """ Returns the state of the protection circuits (OVP, OCP, OTP).
            Protection circuits, if enabled, shut down the supply when the voltage/current/temp at the
            terminals exceeds the set value.

            Return:
                Query returns True if trip has occurred..
        """
        return bool(self.power_supply.query('OUTP:PROT:TRIP', int))