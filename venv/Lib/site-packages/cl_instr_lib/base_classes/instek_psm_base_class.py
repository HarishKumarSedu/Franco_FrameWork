from collections import namedtuple
from enum import Enum

from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_VI_ABC
from cl_instr_lib.helpers.check_enum_str import check_enum_str

ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])
RangeBounds = namedtuple('RangeBounds', ['LOW', 'HIGH'])
ProtectionBounds = namedtuple('ProtectionBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])


class InstekPsmBaseClass(InstrumentVisa, PowerSupply):
    """Base class for driver implementation shared between PSM6003, PSM2010 supplies."""

    def __init__(self, visa_resource_name, logger, range_bounds, protection_bounds, enum_forcing_ranges, **kwargs):

        # Setup the Instrument class which creates the GPIB resource.
        super().__init__(visa_resource_name, logger, **kwargs)

        self.enum_forcing_ranges = enum_forcing_ranges

        # Work around to bug in PSM-2010: FW1.09 and 1.10. For 'VOLT:RANGE' write needs 'P8V', but query returns 'P08V'!
        model = self.get_model()
        if model == 'PSM-2010' and not self.simulated_inst:
            enum_forcing_ranges_query = Enum('_enum_forcing_ranges_read', {'LOW': 'P08V', 'HIGH': 'P20V'})
        else:
            enum_forcing_ranges_query = self.enum_forcing_ranges

        # Create the channel objects. (Note creating the attributes directly enables auto-complete in editor.)
        # Pass power supply self down to channel so he knows who his container is.
        self.OUTPUT = Channel(self, 'OUTPUT', 1, range_bounds, protection_bounds, enum_forcing_ranges_query)
        self._channel_names = ['OUTPUT']

    def output_state(self, on_off=None):
        """Queries or sets the power supply output state OFF or ON.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """

        if on_off is None:
            return self.on_off.to_api(self.query('OUTP', int))  # Supply will return 0 for off, 1 for on.

        self.write('OUTP', self.on_off.to_inst(on_off))  # Works because supply can use 0 for OFF, 1 for ON.

    def reset(self):
        """
        Resets the supply to VOLTAGE mode and 0.0V output.

        :return: None
        """
        super().reset()

        # Sets last_forcing_mode to 'VOLTAGE' which is post reset default.
        # Also, in simulation, puts forcing_range into sim buffer so query readback works.
        self.OUTPUT.source_voltage(voltage=0.0, current_limit=0.0, forcing_range='LOW')


class Channel(PSChannel_VI_ABC):

    def __init__(self, power_supply, channel_name, channel_id, programming_bounds,
                 protection_bounds, enum_forcing_ranges_query):

        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)

        self.channel_id = channel_id
        self.enum_forcing_ranges = power_supply.enum_forcing_ranges
        self._enum_forcing_ranges_query = enum_forcing_ranges_query
        self.protection_bounds = protection_bounds

        self.last_forcing_mode = None  # Used to save the mode programmed because there is no SCPI read back command.

    def source_voltage(self, voltage=None, current_limit=None, forcing_range=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **VOLTAGE** source.

        :param voltage: Output in Volts. Max value depends on forcing_range setting, see attribute programming_bounds.
        :type voltage: float
        :param current_limit: Compliance limit in Amps. Max value depends on forcing_range setting, see attribute
                              programming_bounds.
        :type current_limit: float
        :param forcing_range: 'LOW' or 'HIGH' or element of enum_forcing_ranges. See attribute programming_bounds
                              for the voltage and current capabilities of each range.
        :type forcing_range: enum_forcing_ranges, str
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit, forcing_range}):
            if self.last_forcing_mode is None:
                raise RuntimeError(f"Last operating mode unknown, set values and mode using either the source_voltage "
                                   f"or source_current method.")
            elif self.last_forcing_mode == 'CURRENT':
                raise RuntimeError(f"Output was last programmed to be a current source, "
                                   f"use source_current method to retrieve settings.")
            return_value = {}
            return_value.update(voltage=self.power_supply.query("VOLT", float))
            return_value.update(current_limit=self.power_supply.query("CURR", float))
            return_value.update(forcing_range=self.power_supply.query('VOLT:RANG',
                                                                      self._enum_forcing_ranges_query).name)
            return return_value

        # get the object of the setting regardless of user input or instrument query.
        # Note that we are providing for different enum for write vs read because of PSM-2010 FW1.10.
        forcing_range_obj = check_enum_str("forcing_range", forcing_range, self.enum_forcing_ranges)
        if forcing_range_obj is None:  # User didn't provide range, get it from the instrument.
            forcing_range_obj = self.power_supply.query('VOLT:RANG', self._enum_forcing_ranges_query)

        # get the object of the setting regardless of user input or instrument query.

        # Based on the name of the range, get the appropriate voltage bounds.
        volts_min = getattr(self.programming_bounds, forcing_range_obj.name).volts_min
        volts_max = getattr(self.programming_bounds, forcing_range_obj.name).volts_max

        if voltage is None:
            # User didn't provide the voltage, so read it from the instrument.
            voltage_setting = self.power_supply.query('VOLT', float)

            if voltage_setting > volts_max:
                # User shifted from high range to low, so supply would limit to upper bound of low range!
                raise ValueError(f"Requested range {forcing_range_obj.name} does not support present output "
                                 f"voltage setting {voltage_setting} V.")

        elif not (volts_min <= voltage <= volts_max):
            # User gave us a new voltage, it is not valid for the range that will be in effect.
            raise ValueError(f"Bad voltage {voltage} V for {type(self.power_supply).__name__} "
                             f"forcing_range {forcing_range_obj.name}, should be {volts_min} to {volts_max} V.")

        else:
            # The voltage the user input is OK.
            voltage_setting = voltage

        # Based on the name of the range, get the appropriate current bounds.
        amps_min = getattr(self.programming_bounds, forcing_range_obj.name).amps_min
        amps_max = getattr(self.programming_bounds, forcing_range_obj.name).amps_max

        if current_limit is None:
            # User didn't provide the current, read it from the instrument.
            current_setting = self.power_supply.query('CURR', float)

            if current_setting > amps_max:
                # User shifted from low voltage range to high, so supply will limit to upper bound of high range!
                raise ValueError(f"Requested range {forcing_range_obj.name} does not support present current_limit "
                                 f" of {current_setting} A. Should be {amps_min} to {amps_max} A.")

        elif not (amps_min <= current_limit <= amps_max):
            raise ValueError(f"Bad current_limit {current_limit} A for {type(self.power_supply).__name__} forcing_range"
                             f" {forcing_range_obj.name}, should be {amps_min} to {amps_max} A.")

        else:
            current_setting = current_limit

        # Now that all values have been checked, write new values to the instrument.
        if forcing_range is not None:
            self.power_supply.write("VOLT:RANG", forcing_range_obj.value)

        # Order is critical, it sets the forcing mode! Also, note that we MUST set both, even if user only specified,
        # one, this preserves the operating mode.
        self.power_supply.write("VOLT", voltage_setting)
        self.power_supply.write("CURR", current_setting)

        # Since there is no SCPI cmd to read back the present mode, we use this to help ensure the read back results are
        # correctly interpreted.
        self.last_forcing_mode = 'VOLTAGE'

        self.power_supply.log_inst_errors()

    def source_current(self, current=None, voltage_limit=None, forcing_range=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **CURRENT** source.

        :param current: Output in Amps. Max value depends on forcing_range setting, see attribute programming_bounds.
        :type current: float
        :param voltage_limit: Compliance limit in Volts. Max value depends on forcing_range setting, see attribute
                              programming_bounds.
        :type voltage_limit: float
        :param forcing_range: 'LOW' or 'HIGH' or element of enum_forcing_ranges. See attribute programming_bounds
                              for the voltage and current capabilities of each range.
        :type forcing_range: enum_forcing_ranges, str
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {current, voltage_limit, forcing_range}):
            if self.last_forcing_mode is None:
                raise RuntimeError(f"Last operating mode unknown, set values and mode using the source_current or "
                                   f"source_voltage method.")
            elif self.last_forcing_mode == 'VOLTAGE':
                raise RuntimeError(f"Output was last programmed to be a voltage source, "
                                   f"use source_voltage method to retrieve settings.")
            return_value = {}
            return_value.update(current=self.power_supply.query("CURR", float))
            return_value.update(voltage_limit=self.power_supply.query("VOLT", float))
            return_value.update(forcing_range=self.power_supply.query('VOLT:RANG',
                                                                      self._enum_forcing_ranges_query).name)
            return return_value

        # get the object of the setting regardless of user input or instrument query.
        forcing_range_obj = check_enum_str("forcing_range", forcing_range, self.enum_forcing_ranges)
        if forcing_range_obj is None:  # User didn't provide range, get it from the instrument.
            forcing_range_obj = self.power_supply.query('VOLT:RANG', self._enum_forcing_ranges_query)

        # Based on the name of the range, get the appropriate voltage bounds.
        volts_min = getattr(self.programming_bounds, forcing_range_obj.name).volts_min
        volts_max = getattr(self.programming_bounds, forcing_range_obj.name).volts_max

        if voltage_limit is None:
            # User didn't provide the voltage, so read it from the instrument.
            voltage_setting = self.power_supply.query('VOLT', float)
            if voltage_setting > volts_max:
                # Going from high range to low, so supply will limit to upper bound of low range!
                raise ValueError(f"Requested range {forcing_range_obj.name} does not support present output "
                                 f"voltage_limit setting {voltage_setting} V. Should be {volts_min} to {volts_max} V.")
        elif not (volts_min <= voltage_limit <= volts_max):
            # User gave us a new voltage_limit, is it valid for the range that will be in effect?
            raise ValueError(f"Bad voltage_limit {voltage_limit} V for forcing_range {forcing_range_obj.name},"
                             f"should be {volts_min} to {volts_max} V.")
        else:
            # The voltage_limit the user input is OK.
            voltage_setting = voltage_limit

        # Based on the name of the range, get the appropriate current bounds.
        amps_min = getattr(self.programming_bounds, forcing_range_obj.name).amps_min
        amps_max = getattr(self.programming_bounds, forcing_range_obj.name).amps_max

        if current is None:
            # User didn't provide the current, read it from the instrument.
            current_setting = self.power_supply.query('CURR', float)

            if current_setting > amps_max:
                # User shifted from high range to low, so supply will limit to upper bound of low range!
                raise ValueError(f"Requested range {forcing_range_obj.name} does not support present current "
                                 f"setting {current_setting} A. Should be {amps_min} to {amps_max} A.")
        elif not (amps_min <= current <= amps_max):
            raise ValueError(f"Bad current {current} A, for forcing_range {forcing_range_obj.name}, should be "
                             f"{amps_min} to {amps_max} A.")
        else:
            current_setting = current

        # Now that all values have been checked, write new values to the instrument.
        if forcing_range is not None:
            self.power_supply.write("VOLT:RANG", forcing_range_obj.value)  # NOTE: No CURR:RANG in instrument.

        # Order is critical, it sets the forcing mode! Also, note that we MUST set both, even if user only specified,
        # one, this preserves the operating mode.
        self.power_supply.write("CURR", current_setting)
        self.power_supply.write("VOLT", voltage_setting)

        # Since there is no SCPI cmd to read back the present mode, we use this to help ensure the read back results are
        # correctly interpreted.
        self.last_forcing_mode = 'CURRENT'
        self.power_supply.log_inst_errors()

    def measure_voltage(self):
        return self.power_supply.query("MEAS:VOLT", float)

    def measure_current(self):
        return self.power_supply.query("MEAS:CURR", float)

    def output_state(self, on_off=None):
        """Queries or sets the power supply output state: OFF or ON.

        "param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """

        return self.power_supply.output_state(on_off)

    def ocp_value(self, ilimit=None):

        if ilimit is None:
            return self.power_supply.query('CURR:PROT', float)

        if self.ocp_tripped():
            raise ValueError("OCP is tripped, clear before changing value.")

        if self.protection_bounds.amps_min <= ilimit <= self.protection_bounds.amps_max:
            self.power_supply.write('CURR:PROT', ilimit)
        else:
            raise ValueError(f"Bad ilimit {ilimit} A, should be from "
                             f"{self.protection_bounds.amps_min} A to {self.protection_bounds.amps_max} A.")

    def ocp_state(self, on_off=None):

        if on_off is None:
            return self.power_supply.on_off.to_api(self.power_supply.query('CURR:PROT:STAT', int))

        # if on_off not in self.power_supply.enum_on_off:
        #     raise ValueError(f"Bad on_off {on_off}, should be one of enum_off_on")

        if self.ocp_tripped():
            raise ValueError("OCP is tripped, clear before changing state.")

        inst_value = self.power_supply.on_off.to_inst(on_off)
        self.power_supply.write('CURR:PROT:STAT', inst_value)

    def ocp_tripped(self):
        """ Queries if Over Current Protection has tripped.
            OCP, if enabled, shuts down the supply when the current drawn from
            it exceeds the set value.

            Return:
                Query returns True if trip has occurred..
        """

        return bool(self.power_supply.query('CURR:PROT:TRIP', int))

    def ocp_clear(self):
        """ Writes command to clear Over Current Protection trip.
            OCP, if enabled, shuts down the supply when the current drawn from
            it exceeds the set value. Note that after clearing the trip state,
            the output will remain off until reactivated using the state method.

        """
        self.power_supply.write('CURR:PROT:CLE', "")

    def ovp_value(self, vlimit=None):

        if vlimit is None:
            return self.power_supply.query('VOLT:PROT', float)

        if self.ovp_tripped():
            raise ValueError("OVP is tripped, clear before changing value.")

        if self.protection_bounds.volts_min <= vlimit <= self.protection_bounds.volts_max:
            self.power_supply.write('VOLT:PROT', vlimit)
        else:
            raise ValueError(f"Bad vlimit {vlimit} V, should be from "
                             f"{self.protection_bounds.volts_min} V to {self.protection_bounds.volts_max} V.")

    def ovp_state(self, on_off=None):

        if on_off is None:
            return self.power_supply.on_off.to_api(self.power_supply.query('VOLT:PROT:STAT', int))

        if self.ovp_tripped():
            raise ValueError("OVP is tripped, clear before changing state.")

        # if on_off not in self.power_supply.enum_on_off:
        #     raise ValueError(f"Bad on_off {on_off}, should be one of enum_off_on")
        inst_value = self.power_supply.on_off.to_inst(on_off)
        self.power_supply.write('VOLT:PROT:STAT', inst_value)

    def ovp_tripped(self):
        """ Queries if Over Voltage Protection has tripped.
            OVP, if enabled, shuts down the supply when the voltage at the
            terminals exceeds the set value.

            Return:
                Query returns True if trip has occurred..
        """
        return bool(self.power_supply.query('VOLT:PROT:TRIP', int))

    def ovp_clear(self):
        """ Writes command to clear Over Voltage Protection trip.
            OVP, if enabled, shuts down the supply when the voltage at the
            terminals exceeds the set value. Note that after clearing the trip state,
            the output will remain off until reactivated using the state method.
        """
        self.power_supply.write('VOLT:PROT:CLE', "")
