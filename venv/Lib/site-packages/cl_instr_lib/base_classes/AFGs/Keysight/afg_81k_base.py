from cl_instr_lib.base_classes.signal_generator import SignalGenerator
from cl_instr_lib.base_classes.sg_channel_ABC import SGChannel_ABC

from cl_instr_lib.helpers.check_enum_str import check_enum_str

from collections import namedtuple
from enum import Enum
from re import match

import math

ProgrammingBounds = namedtuple('ProgrammingBounds', ['load_z_min', 'load_z_max',
                                                     'ampl_pp_hiz_min', 'ampl_pp_hiz_max',
                                                     # freq
                                                     'phase_min', 'phase_max',
                                                     'offset_hiz_min', 'offset_hiz_max',
                                                     'voltage_window_hiz_min', 'voltage_window_hiz_max',
                                                     'freq_min', 'freq_max',
                                                     'freq_sine_burst_min', 'freq_sine_burst_max',
                                                     'freq_arb_burst_min', 'freq_arb_burst_max',
                                                     'ramp_symmetry_min', 'ramp_symmetry_max',
                                                     'edge_min',
                                                     'duty_min', 'duty_max',
                                                     'noise_percent_max',
                                                     'am_depth_percent_max',
                                                     'fm_deviation_max',
                                                     'pm_deviation_max',
                                                     'mod_freq_internal_min', 'mod_freq_internal_max',  # AM,FM,PM,PWM
                                                     'fsk_keyrate_min', 'fsk_keyrate_max',
                                                     'hop_freq_hz_max',
                                                     'burst_ncycles_min', 'burst_ncycles_max',
                                                     'burst_tdelay_sec_max']
                               )

ProgrammingRange = namedtuple('ProgrammingRange', 'MIN MAX')


class Afg81kBase(SignalGenerator):
    """Base class for Driver class Keysight AFG81k family."""

    def __init__(self, visa_resource_name, chan_pgm_bounds, logger=None, **kwargs):

        # Setup the simulation code inherited from Instrument.
        super().__init__(visa_resource_name, logger, **kwargs)

        # A couple parameters require unusual handling. Define some data for those and pass into the generic channel
        # objects.

        # Second, the two channels differ in that CH2 cannot sum with the EXT input.
        enum_combine_ch1 = Enum('enum_combine_ch1',
                                {'OFF': '""', 'NOISE': '"NOIS"', 'EXTERNAL': '"EXT"', 'BOTH': '"BOTH"'})
        enum_combine_ch2 = Enum('enum_combine_ch2', {'OFF': '""', 'NOISE': '"NOIS"'})

        # Create the channel objects. Pass signal generator self down to channel so he knows who his container is.

        # #: Attribute containing object that controls saving and recalling **AFG setups**. See `setup class`_.
        # self.setup = AfgSetup(self)

        #: Attribute containing object that controls **CH1**. See `channel class`_.
        self.CH1 = Channel(self, 'CH1', 1, chan_pgm_bounds, enum_combine_ch1)

        #: Attribute containing object that controls  **CH2**. See `channel class`_.
        self.CH2 = Channel(self, 'CH2', 2, chan_pgm_bounds, enum_combine_ch2)

        self._channel_names = ['CH1', 'CH2']

        # These items are controlled at the AFG level (not per channel):
        self.enum_trig_slope = Enum('enum_trig_slope', {'RISING': 'POS', 'FALLING': 'NEG'})
        self.enum_trig_source = Enum('enum_trig_source', {'EXTERNAL': 'EXT', 'TIMER': 'TIM'})
        self.bounds_timer_sec = ProgrammingRange(1e-6, 500.0)


class Channel(SGChannel_ABC):
    """Implements the methods to control an output channel of Keysight 81160A signal generator."""

    enum_function_shapes = Enum('enum_function_shapes',
                                {'SINE': 'SIN', 'SQUARE': 'SQU', 'RAMP': 'RAMP', 'PULSE': 'PULS',
                                 'NOISE': 'NOIS', 'DC': 'DC',
                                 'USER1': 'USER'})

    enum_run_modes = Enum('enum_run_modes',
                          {'CONTINUOUS': 'CONTINUOUS', 'MOD_AM': 'AM:STAT', 'MOD_FM': 'FM:STAT', 'MOD_PM': 'PM:STAT',
                           'MOD_FSK': 'FSK:STAT', 'MOD_PWM': 'PWM:STAT', 'SWEEP': 'SWE', 'BURST': 'BURS'}
                          )

    enum_amplitude_units = Enum('enum_amplitude_units', {'VPP': 'VPP', 'VRMS': 'VRMS', 'DBM': 'DBM'})
    enum_burst_mode = Enum('enum_burst_mode', {'TRIGGERED': 'TRIG', 'GATE': 'GAT'})

    enum_mod_source = Enum('enum_mod_source', {'INTERNAL': 'INT', 'EXTERNAL': 'EXT'})

    enum_mod_shapes = Enum('enum_mod_shapes', {
        'SINE': 'SIN', 'SQUARE': 'SQU', 'TRIANGLE': 'TRI', 'UP_RAMP': 'RAMP', 'DOWN_RAMP': 'NRAM', 'NOISE': 'PRN',
        'USER1': 'USER1', 'USER2': 'USER2', 'USER3': 'USER3', 'USER4': 'USER4',
        'EDIT_MEM': 'EMEM', 'FILE': 'EFIL'
    })

    enum_pulse_hold = Enum('enum_pulse_hold', {'WIDTH': 'WIDT', 'DUTY': 'DUTY'})

    enum_sweep_mode = Enum('enum_sweep_mode', {'AUTO': 'AUTO', 'MANUAL': 'MAN'})

    def __init__(self, signal_generator, channel_name, channel_id, programming_bounds, enum_combine):
        super().__init__(signal_generator=signal_generator, channel_name=channel_name,
                         programming_bounds=programming_bounds)
        self.channel_id = channel_id

        # Define references to objects in the container object.
        self.log = signal_generator.log
        self.write = signal_generator.write
        self.query = signal_generator.query
        self.on_off = signal_generator.on_off
        self.log_inst_errors = signal_generator.log_inst_errors
        self.get_inst_errors = signal_generator.get_inst_errors
        self.log_unused_args = signal_generator.log_unused_args
        self.enum_combine = enum_combine

        self.pulse_width_min = 4e-9

    def output_state(self, on_off=None):
        """Queries or sets the state (OFF or ON) of the AFG channel main output.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """
        # OUTPut[1|2][:STATe] {ON|OFF|<NR1>}

        if on_off is None:
            return self.on_off.to_api(self.query(f'OUTP{self.channel_id}', int))

        self.write(f'OUTP{self.channel_id}', self.on_off.to_inst(on_off))

    def output_state_complement(self, on_off=None):
        """Queries or sets the state (OFF or ON) of the AFG channel **complemented** output.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """
        # :OUTPut[1|2]:COMPlement {0|1|OFF|ON}

        if on_off is None:
            return self.on_off.to_api(self.query(f'OUTP{self.channel_id}:COMP', int))

        self.write(f'OUTP{self.channel_id}:COMP', self.on_off.to_inst(on_off))

    def output_state_both(self, on_off):
        """Sets the state (OFF or ON) of **BOTH** the main and complement outputs of the AFG channel. Unlike most
        methods, this method provides no read back functionality. For read back, use methods output_state and
        output_state complement.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: None
        """

        # :OUTput[1|2] {0|1|OFF|ON}
        # :OUTPut[1|2]:COMPlement {0|1|OFF|ON}

        if on_off is None:
            raise ValueError("You must specify a valid on_off value: 'ON' or 'OFF', 0 or 1, True or False.")

        on_off = self.on_off.to_inst(on_off)

        self.write(f'OUTP{self.channel_id}', on_off)
        self.write(f'OUTP{self.channel_id}:COMP', on_off)

    def function_shape(self, shape=None, *args, **kwargs):
        """
        Query or set shape of output waveform. Corresponds to front panel buttons in the Function group.

        :param shape: Select shape from the built-in functions: 'SINE', 'SQUARE', 'RAMP', 'PULSE', 'SINC', 'NOISE',
            'DC', 'GAUSSIAN', 'LORENTZ', 'EXP_RISE', 'EXP_DECAY', 'HAVERSINE'; or from the storage locations for
            user defined arbitrary waveforms: 'USER1', 'USER2', 'USER3', 'USER4', 'EDIT_MEM', 'FILE'.
        :type shape: enum_function_shapes | str
        :return: Query form (no input parameters) returns dict of current settings. If any parameters are supplied,
            None is returned.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:FUNCtion[:SHAPe] {SINusoid|SQUare|PULSe|RAMP|PRNoise|DC|SINC|GAUSsian|LORentz|ERISe|EDECay|
        #                                 HAVersine|USER[1]|USER2|USER3|USER4|EMEMory|EFILe}

        self.log_unused_args(args, kwargs)

        # Handle the pure query case.
        if all([v is None for v in (shape, None)]):
            return_values = {}
            return_values.update(shape=self.query(f'SOUR{self.channel_id}:FUNC', self.enum_function_shapes).name)
            return return_values

        # Ok, we have some inputs to check...

        shape = check_enum_str('shape', shape, self.enum_function_shapes)

        if shape is not None:
            self.write(f'SOUR{self.channel_id}:FUNC', shape.value)

        self.signal_generator.log_inst_errors()

    def function_freq(self, freq_hz=None, *args, **kwargs):
        """
        Query or set the output frequency and phase.

        Corresponds to the bezel button "Frequency/Period/Phase Menu".

        :param freq_hz: Frequency of the generated waveform function in Hz.
        :type freq_hz: int | float
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:FREQuency[:CW|:FIXed]
        # [SOURce[1|2]]:FREQuency:CONCurrent[:STATe]
        # [SOURce[1|2]]:PHASe[:ADJust]

        self.log_unused_args(args, kwargs)

        if all([v is None for v in (freq_hz, None)]):
            return_dict = {}
            tmp = self.query(f"SOUR{self.channel_id}:FREQ", float)
            return_dict.update(freq_hz=tmp)
            return return_dict

        if freq_hz is not None:
            freq_min = self.programming_bounds.freq_min
            shape = self.function_shape()['shape']
            key = shape
            arb_str = ''
            if match('USER\d?', shape) or shape in ('EDIT_MEM', 'FILE'):
                key = 'ARB'
                arb_str = 'ARB'
            elif shape not in self.programming_bounds.freq_max:
                key = 'OTHER'
            else:
                key = shape
            freq_max = self.programming_bounds.freq_max[key]
            if not (isinstance(freq_hz, (float, int)) and (freq_min <= freq_hz <= freq_max)):
                raise ValueError(f'Bad freq_hz {freq_hz} for {arb_str} function {shape}. Should be from {freq_min} Hz '
                                 f'to {freq_max} Hz.')
        #
        #     if self.run_mode() == 'SWEEP':
        #         raise ValueError(f"Cannot program freq_hz while run_mode is 'SWEEP'.")
        #     elif self.run_mode() == 'BURST' and key == 'SINE':
        #         freq_min = self.programming_bounds.freq_sine_burst_min
        #         freq_max = self.programming_bounds.freq_sine_burst_max
        #         if not(freq_min <= freq_hz <= freq_max):
        #             raise ValueError(f'Bad freq_hz {freq_hz} for function {key} in BURST mode. Should be from'
        #                              f' {freq_min} Hz to {freq_max} Hz.')
        #     elif self.run_mode() == 'BURST' and key == 'ARB':
        #         freq_min = self.programming_bounds.freq_arb_burst_min
        #         freq_max = self.programming_bounds.freq_arb_burst_max
        #         if not(freq_min <= freq_hz <= freq_max):
        #             raise ValueError(f'Bad freq_hz {freq_hz} for function {key} in BURST mode. Should be from'
        #                              f' {freq_min} Hz to {freq_max} Hz.')

        if freq_hz is not None:
            self.write(f"SOUR{self.channel_id}:FREQ", freq_hz)

        self.log_inst_errors()

    def function_level(self, amplitude=None, offset=None, high_level=None, low_level=None, units=None, *args, **kwargs):
        """
        Query all or set any of the level related parameters of the generated function.

        Corresponds to the bezel button "Amplitude/Level Menu".

        :param amplitude: Output amplitude **at the load** in either the units presently selected in the AFG or passed
            in the units parameter. The value you program and what the AFG displays takes into account the voltage
            divider formed by the AFG output impedance (**always** 50 Ohms) in series with the load impedance you
            have programmed into the AFG. See method output, parameter load_z. The maximum amplitude that can
            be programmed depends on load_z: for load_z = 'INF' it is 10VPP (3.536VRMS for sine wave); for load_z=50
            it is 5VPP (1.768VRMS for sine wave).
        :type amplitude: float
        :param offset: The DC offset voltage of the generated waveform. Not affected by choice of units.
        :type offset: float
        :param high_level: The waveform voltage maxima including offset. Not affected by choice of units.
        :type high_level: float
        :param low_level: The waveform voltage minima including offset. Not affected by choice of units.
        :type low_level: float
        :param units: Units of amplitude: 'VPP', 'VRMS', 'DBM'. Changing units does not modify the actual output,
            just how it is programmed and displayed. Does not effect offset, high_level or low_level. For example,
            if the output is presently a 1Vpp sine wave, changing units from 'VPP' to 'VRMS' to 'DBM' changes the AFG
            display from 1Vpp to 353.6mVrms to 3.979Bm without any change in the voltage across the load.  'DBM' is
            can only be selected for sine waves. Note that dBm also depends upon load_z and is referenced to 1mW.
        :type units: enum_amplitude_units | str
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate][:AMPLitude]
        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate]:OFFSet
        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate]:HIGH
        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate]:LOW
        # [SOURce[1|2]]:VOLTage:UNIT

        self.log_unused_args(args, kwargs)

        if all([v is None for v in (amplitude, offset, high_level, low_level, units)]):
            return_values = {}
            return_values.update(amplitude=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL", float))
            return_values.update(offset=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", float))
            return_values.update(high_level=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:HIGH", float))
            return_values.update(low_level=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:LOW", float))
            return_values.update(units=self.query(f"SOUR{self.channel_id}:VOLT:UNIT", self.enum_amplitude_units).name)
            return return_values

        units = check_enum_str('units', units, self.enum_amplitude_units)
        if units is None:
            units_state = self.query(f"SOUR{self.channel_id}:VOLT:UNIT", self.enum_amplitude_units).name
        else:
            units_state = units.name

        # Calculate voltage divider effect of load_z in combination with AFG output impedance which is always 50 Ohms.
        load_z = self.query(f"OUTP{self.channel_id}:IMP:EXT", float)
        ratio = 1.0 if load_z >= 1E6 else (1.0 / (1.0 + 50.0 / load_z))
        load_z = 'INF' if load_z > 90e36 else load_z

        shape_state = self.query(f'SOUR{self.channel_id}:FUNC', self.enum_function_shapes).name

        if amplitude:
            do_check = True
            amplitude_min = amplitude_max = None  # Suppresses warning about uninitialized variable.
            if units_state == 'VPP':
                amplitude_min = self.programming_bounds.ampl_pp_hiz_min * ratio
                amplitude_max = self.programming_bounds.ampl_pp_hiz_max * ratio
            elif units_state == 'VRMS':
                if shape_state == 'SINE':
                    amplitude_min = self.programming_bounds.ampl_pp_hiz_min * ratio / (2.0 * math.sqrt(2.0))
                    amplitude_max = self.programming_bounds.ampl_pp_hiz_max * ratio / (2.0 * math.sqrt(2.0))
                elif shape_state == 'SQUARE':
                    amplitude_min = self.programming_bounds.ampl_pp_hiz_min * ratio / 2.0
                    amplitude_max = self.programming_bounds.ampl_pp_hiz_max * ratio / 2.0
                else:
                    do_check = False
                    self.log.warning(f"Driver cannot check amplitude VRMS for shape {shape_state}, only for 'SINE' and "
                                     f"'SQUARE'.")
            elif units_state == 'DBM':
                if load_z == 'INF':
                    raise ValueError(f"DBM units not allowed when load_z='INF'.")
                shape = self.query(f'SOUR{self.channel_id}:FUNC', self.enum_function_shapes).name
                if shape != 'SINE':
                    raise ValueError(f"Units 'DBM' not allowed for function shape '{shape}'. 'SINE' only.")
                rms_min = self.programming_bounds.ampl_pp_hiz_min * ratio / (2.0 * math.sqrt(2.0))
                rms_max = self.programming_bounds.ampl_pp_hiz_max * ratio / (2.0 * math.sqrt(2.0))
                amplitude_min = 10.0 * math.log10((rms_min**2 / load_z) / 0.001)  # DBM is power relative to 1mW.
                amplitude_max = 10.0 * math.log10((rms_max**2 / load_z) / 0.001)

            if do_check and (amplitude_min is None or amplitude_max is None):
                raise RuntimeError("Program bug: amplitude_min or amplitude_max is None!")

            if not(amplitude_min <= amplitude <= amplitude_max):
                msg = f"Bad amplitude {amplitude:.3f} {units_state}, should be {amplitude_min:.3f} to "\
                      f" {amplitude_max:.3f} {units_state} into {load_z} Ohm load for {shape_state} wave."
                raise ValueError(msg)

        if offset is not None:
            offset_max = self.programming_bounds.offset_hiz_max * ratio
            offset_min = self.programming_bounds.offset_hiz_min * ratio
            if not(offset_min <= offset <= offset_max):
                raise ValueError(f"Bad offset {offset:.3f}V, for load_z={load_z} Ohms, offset range is {offset_min:.3f}"
                                 f" to {offset_max:.3f}V.")

        if amplitude is not None or offset is not None:
            do_check = True
            amplitude_state = amplitude
            if amplitude_state is None:
                amplitude_state = self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL", float)

            offset_state = offset
            if offset_state is None:
                offset_state = self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", float)

            # Convert amplitude to VPK.
            if units_state == 'VPP':
                amplitude_pk = amplitude_state / 2.0
            elif units_state == 'VRMS':
                if shape_state == 'SINE':
                    amplitude_pk = amplitude_state * math.sqrt(2.0)
                elif shape_state == 'SQUARE':
                    amplitude_pk = amplitude_state
                else:
                    do_check = False
                    self.log.warning(f"Driver cannot check voltage window with VRMS amplitude for shape"
                                     f" {shape_state}, only for 'SINE' and 'SQUARE'.")
            elif units_state == 'DBM':
                if shape_state != 'SINE':
                    do_check = False
                    self.log.warning(f"Driver cannot check voltage window with DBM amplitude for shape"
                                     f" {shape_state}, only for 'SINE'.")

                amplitude_rms = math.sqrt(0.001 * load_z * 10**(amplitude_state/10.0))
                amplitude_pk = amplitude_rms * math.sqrt(2.0)

            if do_check:
                v_pos_max = offset_state + amplitude_pk
                v_neg_min = offset_state - amplitude_pk
                v_window_pos = self.programming_bounds.voltage_window_hiz_max * ratio
                v_window_neg = self.programming_bounds.voltage_window_hiz_min * ratio
                if v_pos_max > v_window_pos:
                    raise ValueError(f"Bad combination of amplitude {amplitude_state} {units_state} and offset "
                                     f"{offset_state}V, will violate voltage window maximum {v_window_pos}V for "
                                     f"{load_z} Ohm load.")
                if v_neg_min < v_window_neg:
                    raise ValueError(f"Bad combination of amplitude {amplitude_state} {units_state} and offset "
                                     f"{offset_state}V, will violate voltage window minimum {v_window_neg}V for "
                                     f"{load_z} Ohm load.")

        if units is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:UNIT", units.value)
        if high_level is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:HIGH", high_level)
        if low_level is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:LOW", low_level)
        if offset is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", offset)
        if amplitude is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL", amplitude)

        self.log_inst_errors()

    def output(self, load_z=None, invert=None, high_limit=None, low_limit=None, *args, **kwargs):
        """
        Query all or set any of the parameters on the Output Menu of the AFG output channel.

        :param load_z: The impedance of your **LOAD**. The AFG uses this to display the amplitude, offset and
            high/low levels as they will appear at the load, taking into account the voltage divider formed by your load
            and the output impedance of the AFG which is **always** 50 Ohms. load_z can be 1 to 10,000 Ohms or 'INF'.
        :type load_z: (float | str)
        :param invert: If 'ON' waveform is inverted relative to the offset level. Query returns 'ON' or 'OFF'.
        :type invert: Can be any of the forms permitted by the OnOff class.
        :param high_limit: Setting an amplitude + offset value that would produce a positive going peak of the
            output more positive than this will cause an instrument error.
        :type high_limit: float
        :param low_limit: Setting an amplitude + offset value that would produce a negative going peak of the
            output more negative than this will cause an instrument error.
        :type low_limit: float
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # OUTPut[1|2]:IMPedance
        # OUTPut[1|2]:POLarity
        # [SOURce[1|2]]:VOLTage:LIMit:HIGH
        # [SOURce[1|2]]:VOLTage:LIMit:LOW
        # [SOURce[1|2]]:COMBine:FEED
        # SOURce<3|4>:POWer[:LEVel][:IMMediate][:AMPLitude]

        self.log_unused_args(args, kwargs)

        if all([v is None for v in (load_z, invert, high_limit, low_limit)]):
            return_values = {}
            tmp = self.query(f"OUTP{self.channel_id}:IMP:EXT", float)
            return_values.update(load_z='INF' if tmp > 90e36 else tmp)
            tmp = {'NORM': '0', 'INV': '1'}[self.query(f"OUTP{self.channel_id}:POL", str)]  # See comment below.
            return_values.update(invert=self.on_off.to_api(tmp))
            return_values.update(high_limit=self.query(f"SOUR{self.channel_id}:VOLT:LIM:HIGH", float))
            return_values.update(low_limit=self.query(f"SOUR{self.channel_id}:VOLT:LIM:LOW", float))
            return return_values

        if load_z is not None:
            if not(isinstance(load_z, (int, float)) and
                self.programming_bounds.load_z_min <= load_z <= self.programming_bounds.load_z_max
                    or load_z == 'INF'):
                raise ValueError(f"Bad load_z {load_z}, should be 1.0 to 10000.0 Ohms or 'INF'.")
            load_z_state = load_z
        else:
            load_z_state = self.query(f"OUTP{self.channel_id}:IMP:EXT", float)

        if load_z_state == 'INF' or load_z_state > 90e36:
            limit = self.programming_bounds.ampl_pp_hiz_max
        else:
            limit = self.programming_bounds.ampl_pp_hiz_max * load_z_state/(load_z_state+50.0)

        # This is weird because we want use ON/OFF values for two reasons. AFG GUI uses on/off and previous versions of
        # this driver did too. Problem is instrument API uses 'NORM' and 'INV'.
        invert = self.on_off.to_inst(invert)
        if invert is not None:
            invert = {'0': 'NORM', '1': 'INV'}[invert]

        if high_limit is not None:
            if not (-1.*limit <= high_limit <= limit):
                raise ValueError(f"Bad high_limit {high_limit}, must be {-1.0*limit} to {limit} V.")
            high_limit_state = high_limit
        else:
            high_limit_state = self.query(f"SOUR{self.channel_id}:VOLT:LIM:HIGH", float)

        if low_limit is not None:
            if not (-1.*limit <= low_limit <= limit):
                raise ValueError(f"Bad low_limit {low_limit}, must be {-1.0*limit} to {limit} V.")
            low_limit_state = low_limit
        else:
            low_limit_state = self.query(f"SOUR{self.channel_id}:VOLT:LIM:LOW", float)

        if not(low_limit_state < high_limit_state):
            raise ValueError(f"Bad limits. low_limit ({low_limit}) must be <= high_limit {high_limit}.")

        if load_z is not None:
            self.write(f"OUTP{self.channel_id}:IMP:EXT", load_z)
        if invert is not None:
            self.write(f"OUTP{self.channel_id}:POL", invert)
        if high_limit is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LIM:HIGH", high_limit)
        if low_limit is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LIM:LOW", low_limit)

        self.log_inst_errors()


if __name__ == '__main__':
    afg81160A = AFG81160A('GPIB0::15')  # Replace visa_resource_name with None for simulated hardware.
    afg81160A.debug_options(log_scpi=True, unused_args_handling='LOG_UNUSED', inst_error_handling='LOG_ALWAYS')
