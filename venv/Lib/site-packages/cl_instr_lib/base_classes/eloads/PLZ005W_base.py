# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# # -*- coding: utf-8 -*-
# Inherit from the instrument class
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
# Include Other Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
# Include Python libraries
from time import sleep
# import os
import csv
from enum import Enum
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# TODO: Support for triggered level changes.
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------

resetText = '\033[00m'
redText = '\033[91m'
greenText = '\033[92m'
yellowText = '\033[93m'
blueText = '\033[94m'
purpleText = '\033[95m'
cyanText = '\033[96m'


class PLZ005W_base(InstrumentVisa):
    """
    |   Class for controlling Kikusui PLZ-5W Series Electronic Loads.
    |

    .. For docstrings, any line preceded with '.. (double period)' will be treated as a comment
    .. However, care needed as 'directives' are also preceded with '..', e.g. '.. code-block::'

    """

    # these are variable definitions that get assigned in the derived class.
    _ratings = dict()
    _rating_curr_max = None
    _rating_pow_max = None

    cfg_max_disp_list_errors = 10

    # standard dictionaries of Modes and actions - these are used to make lists used in the enums creation
    _std_mode_dict = {'CC': 'CURR', 'CV': 'VOLT', 'CP': 'POW', 'CR': 'COND'}  # standard modes
    _add_mode_dict = {'ARB': 'ARB'}  # 'ARB' is PLZ-5W specific
    _legacy_mode_dict = {'CCCV': 'CURR', 'CRCV': 'COND'}  # additional modes kept for 'compatibility' with PLZ-4W series
    _add_ratings_dict = {'SLEW': 'SLEW'}
    _meas_list = ['CURR', 'VOLT', 'POW', 'ETIM', 'ENER', 'CAP']  # ENER & CAP from PLZ-5W series

    _protection_action_dict = {'0': 0, '1': 1, 'OFF': 0, 'ON': 1, 'LIM': 0, 'TRIP': 1}  # allow same 'labels' as PLZ-4W

    # New enumerations of the dictionaries above. separated as to not break code and cleanup implementation
    enum_curr_range = Enum("enum_curr_range", {'L': 'LOW', 'M': 'MED', 'H': 'HIGH'})  # -- same as PLZ-4W
    enum_volt_range = Enum("enum_volt_range", {'L': 'LOW', 'H': 'HIGH'})  # -- same as PLZ-4W

    # enumerations of existing method dictionaries
    # enum_ratings_param = Enum('enum_ratings_param', ['COND', 'CURR', 'VOLT', 'POW', 'SLEW'])
    enum_ratings_param = Enum('enum_ratings_param', list(_std_mode_dict.values()) + list(_add_ratings_dict.values()))
    # enum_range_param = Enum('enum_range_param', ['COND', 'CURR', 'VOLT', 'POW'])
    enum_range_param = Enum('enum_range_param', list(_std_mode_dict.values()))
    enum_level_param = enum_range_param  # aliases of the parameter lists
    # ENER & CAP PLZ-5W Only
    # enum_meas_param = Enum('enum_meas_param', ['POW', 'CURR', 'VOLT', 'ETIM', 'ENER', 'CAP'])
    enum_meas_param = Enum('enum_meas_param', _meas_list)
    # 'CCCV' & 'CRCV' kept for 'compatibility' with PLZ-4W series, 'ARB' is PLZ-5W specific
    # enum_mode_list = Enum('enum_mode_list', ['CC', 'CV', 'CP', 'CR', 'ARB', 'CCCV', 'CRCV'])
    enum_mode_list = Enum('enum_mode_list', list(_std_mode_dict.keys()) + list(_add_mode_dict.keys()) +
                          list(_legacy_mode_dict.keys()))

    enum_dynamics_response = Enum("enum_dynamics_response", ['NORM', 'FAST'])  # Not relevant

    # this is replaced by POW:PROT:STAT ON (1 = TRIP) / OFF (0 = LIMIT)
    enum_opp_action = Enum('enum_opp_action', list(_protection_action_dict.keys()))  # allow same 'labels' as PLZ-4W
    enum_ocp_action = enum_opp_action  # aliases of the parameter lists

    # PLZ-5W appears to combine the CSUM and OPER Status registers from PLZ-4W series into the OPER Status register
    enum_status_regs = Enum("enum_status_regs",
                            {'OPER': {'CV': 0, 'CC': 1, 'CR': 2, 'CP': 3, 'ACQ BUSY': 4, 'ACQ WTG': 5,
                                      'TRAN Busy': 6, 'TRAN WTG': 7, 'LOAD': 8, 'PAUSE': 9, 'INT': 10, 'ACQ DAV': 11},
                             'QUES': {'Over Voltage': 0, 'Over Current': 1, 'Over Power': 3, 'Over Temp': 4,
                                      'Watchdog': 5, 'Current Limiting': 6, 'Power Limiting': 7, 'Under Voltage': 9,
                                      'External Problem': 10, 'Reverse Voltage': 11, 'FORM': 12}}
                            )

    def __init__(self, visa_resource_name, logger=None, **kwargs):

        super().__init__(visa_resource_name, logger, **kwargs)

        # reset the machine, was in the legacy code
        # self.reset()

        # Enabling these to allow propagation to the status byte.
        self.write(f'STAT:OPER:ENAB {0xFF}')  # Only bits 0-11 are used.
        # self.write(f'STAT:CSUM:ENAB {0x10F}')  # Not Applicable to PLZ-5W
        self.write(f'STAT:QUES:ENAB {0x1EFB}')  # Only bits 0,1,3,4-7,9-12 are used.

        """
        Might want to look at creating attributes that reflect (and to reduce times reading these parameters back)
        * current operating mode and range
        * current applicable ratings
        * a list of available programs in memory
        this assumes all users only use methods in driver, and don't use the raw SCPI commands 
        """
        # self._curr_operating_mode = self.mode()
        # self._curr_operating_range = self.range(self._std_mode_dict[self._curr_operating_mode])
        # self._curr_prog_dict = self.program.get_programs()


    # ------------------------------------------------------------------------------------------------------------------

    def reset(self):
        """
        |   Reset the Electronic Load to factory defaults, mostly. Does not modify STATUS enable
        |   registers.
        """

        self.write('*RST')
        sleep(2)

        # self._curr_operating_mode = 'CC'
        # self._curr_operating_range = 'H'

        # create a 'global' attribute that contains the program names and can be looked-up easily
        # read all program/sequence memory and check for duplicate program names?
        # self._curr_prog_dict = self.program.get_programs()
    # ------------------------------------------------------------------------------------------------------------------

    def ratings(self, param, range_val=None):
        """
        |   Method to retrieve the range for specific parameters controllable for the Electronic
        |   Load.
        |   If range_val is 'None', a dictionary is returned consisting of available ranges and
        |   limits/units applicable for the specified parameter.
        |       If range_val is specified, e.g. 'L', a tuple consisting of minval, maxval and units
        |   for the specified parameter and range will be returned.

        :param param:       Electrical parameter controlled by the Load. Options are:

                                * 'COND' - Conductance
                                * 'CURR' - Current
                                * 'POW'  - Power
                                * 'VOLT' - Voltage
                                * 'SLEW' - Slew
        :type param:        str | enum_ratings_param
        :param range_val:   range setting for the parameter.

                                * 'L': low
                                * 'M': medium, Not valid when param is 'VOLT'.
                                * 'H': high
                                * None: Returns the self._ratings sub-dictionary for the specified
                                  parameter.
        :type range_val:    str
        :return:            Read Back current parameters if the method is called empty.
        :rtype:             dict | None
        """

        # check if the parameter exists
        param_obj = check_enum_str('param', param.upper(), self.enum_ratings_param)

        if range_val is not None:
            min_val, max_val = self._ratings[param_obj.name][range_val[0].upper()]
            units = self._ratings[param_obj.name]['units']
            return min_val, max_val, units
        else:
            return self._ratings[param_obj.name]
    # ------------------------------------------------------------------------------------------------------------------

    def mode(self, mode=None):
        """
        |   Queries or writes operating mode of the Electronic load.
        |
        |   Note that modes 'CCCV' & 'CRCV' are not actually returned by the unit (as is the case for
        |   the PLZ-4W series).
        |   The '+CV' option will be checked/set separately, and is only available for 'CC'& 'CR'
        |   modes (similar to the PLZ-4W).

        :param mode:    Operating mode. Options are:

                            * None   - Queries instrument, returns one of the following strings:
                            * 'CC'   - sets Constant Current mode.
                            * 'CV'   - sets Constant Voltage mode.
                            * 'CP'   - sets Constant Power mode.
                            * 'CR'   - sets Constant Resistance mode.
                            * 'CCCV' - sets Constant Current with Constant Voltage mode.
                            * 'CRCV' - sets Constant Resistance with Constant Voltage mode.
                            * 'ARB'  - Arbitrary I-V Characteristics mode.
        :type mode: str | enum_mode_list
        :return: Read Back current parameters if the method is called empty.
        :rtype: str | None
        """
        # SCPI Commands:    PLZ-5W options are slightly different compared to PLZ-4W series
        # W/R   [SOURce:]FUNCtion[:MODE] {CC | CV | CP | CR | ARB}
        #    "Query if +CV enabled (CC or CR only)"
        # W/R   [SOURce:]FUNCtion[:MODE]:CVOPtion[:STATe] {0 | 1 | OFF | ON} / {0 | 1}

        # DONE: Disallow changing modes if switching is active.
        self.log_inst_errors()

        rslt = self.query('FUNCtion?').rstrip().upper()

        cvop = False
        if rslt in ['CC', 'CR']:
            cvop = bool(int(self.query(f'FUNCtion:CVOPtion?'), 10))

        if mode is None:
            if rslt in ['CC', 'CR']:
                # check if '+CV' has been enabled
                if cvop:
                    rslt += 'CV'

            return rslt

        # if mode is not none, check if it is in the enum
        mode_obj = check_enum_str('mode', mode.upper(), self.enum_mode_list)

        # Check for Switching or Sequence Mode Running on PLZ-5W series
        if 'IDLE' not in self.query(f'TRIGger:TRANsient:EXECution?').split(',')[0].upper():
            raise RuntimeError(f"Switching Enabled or Sequence Mode running! "
                               f"Disable before changing Mode and reconfigure settings as required.")

        if self.state() == 'ON':
            raise ValueError("Cannot program mode while load state is ON.")  # Or you get error 24.

        if mode_obj.name.upper() in ['CCCV', 'CRCV']:
            self.write('FUNCtion ' + mode_obj.name[0:2])
            self.write(f'FUNCtion:CVOPtion {1}')
        else:
            if cvop:
                self.write(f'FUNCtion:CVOPtion {0}')

            self.write('FUNCtion ' + mode_obj.name)

        sleep(0.25)

        self.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def state(self, state=None):
        """
        |   Queries or writes the state of the Electronic Load input terminals.

        :param state:   State of the Input to the Electronic Load

                            * None   - Queries instrument, returns one of the following strings:
                            * 'ON'   - Load terminals are connected to the DUT.
                            * 'OFF'  - Load terminals are disconnected from the DUT.
        :type state:    str
        :return:        Read Back current parameters if the method is called empty.
        :rtype:         str | None
        """
        # SCPI Commands:
        # W/R   INPut:STATe {0 | 1 | OFF | ON} / {0 | 1}

        if state is None:
            return self.on_off.to_api(self.query('INPUT:STATe?').strip())

        self.write('INPUT:STATe', self.on_off.to_inst(state))
    # ------------------------------------------------------------------------------------------------------------------

    def range(self, param=None, range_val=None):
        """
        |   Queries or writes the range for the specified parameter.
        |
        |       Note that changes to a single range can 'unintentionally' affect the ranges of the
            others, i.e. CURR will affect 'POW' and 'COND' and vice versa.

        :param param:       Electrical parameter controlled by the Load. Options are:

                                * 'COND' - Conductance
                                * 'CURR' - Current
                                * 'POW'  - Power
                                * 'VOLT' - Voltage
        :type param:        str | enum_range_param
        :param range_val:   Range to be set

                                * None   - Queries instrument, returns one of the following strings:
                                * 'L'    - Low range, valid for all param.
                                * 'M'    - Medium range, not valid for VOLT param.
                                * 'H'    - High range, valid for all param.
        :type range_val:    str
        :return:            Read Back current parameters if the method is called empty.
        :rtype:             str | dict | None
        """
        # SCPI Commands:
        #    <param> = CURRent | POWer | CONDuctance
        # W/R   [SOURce:]<param>:RANGe {LOW | MEDium | HIGH} / {LOW | MED | HIGH}
        # W/R   [SOURce:]VOLTage:RANGe {LOW | HIGH}

        if param is None:  # read back all the ranges for the specified controllable parameters - output a dictionary
            rtn_dict = {}
            for item in list(self.enum_range_param.__members__):
                rtn_dict[item] = self.query(f'{item}:RANGe?').strip()

            return rtn_dict

        param_obj = check_enum_str('param', param.upper(), self.enum_range_param)
        if param_obj.name == 'VOLT':
            enum_chosen = self.enum_volt_range  # {'L': 'LOW', 'H': 'HIGH'}
        else:
            enum_chosen = self.enum_curr_range  # {'L': 'LOW', 'M': 'MED', 'H': 'HIGH'}

        if range_val is None:  # echo back range of given parameter
            return self.query(f'{param_obj.name}:RANGE?', enum_chosen).name

        error_template = "Bad {name} '{value}' for" + f" '{param_obj.name}'. " + "Should be one of {cls_name}: {keys}."

        for key in enum_chosen.__members__.keys():
            minval, maxval, units = self.ratings(param_obj.name, key)
            error_template += f"\n   '{key}': {minval} to {maxval} {units}"

        range_val_obj = check_enum_str("range_val", range_val[0].upper(), enum_chosen, error_template)
        self.write(f'{param_obj.name}:RANGE {range_val_obj.value}')

        self.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def level(self, param, level=None):
        """
        |   Queries or writes the level for the specified parameter.

        :param param:   Electrical parameter controlled by the Load. Options are:

                            * 'COND' - Conductance
                            * 'CURR' - Current
                            * 'POW'  - Power
                            * 'VOLT' - Voltage
        :type param:    str | enum_level_param
        :param level:   main/primary level to be set

                            * None   - Queries from instrument the present level setting for param.
                            * 'MIN'  - Minimum level of the range presently in effect for param.
                            * 'MAX'  - Maximum level of the range presently in effect for param.
                            * <numeric> - Sets level of param. Units are Seimens, Amps, Watts, or Volts.
        :type level:    str | int | float
        :return:        Read Back current parameters if the method is called empty.
        :rtype:         dict | None
        """
        # SCPI Commands:
        #    <param> = CONDuctance | Current | Voltage | POWer
        # W/R     [SOURce:]<param>[:LEVel][:IMMediate][:AMPLitude] {<numeric> | MINimum | MAXimum}

        param_obj = check_enum_str('param', param.upper(), self.enum_level_param)

        if level is None:
            return float(self.query(f'{param_obj.name}?').strip())

        # If we got here, we are writing to the instrument.
        min_val, max_val, units = self.ratings(param_obj.name, self.range(param_obj.name))
        if str(level).upper() in ('MIN', 'MAX'):
            self.write(f'{param_obj.name} {level}')
        elif type(float(level)) is float:
            # if level < min_val or level > max_val:  # not(min_val <= level <= max_val)
            if min_val <= float(level) <= max_val:
                self.write(f'{param_obj.name} {str(level)}')
            else:
                raise ValueError(f"Bad level {level} for {param_obj.name}, should be {min_val} to "
                                 f"{max_val} {units}.")
        else:
            raise ValueError(f"Bad level '{level}' for {param_obj.name}. Should be one of: "
                             f"{min_val} to {max_val} {units}, 'MIN' or 'MAX'.")

        self.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def meas(self, param):
        """
        |   Queries measured level of the specified parameter.

        :param param:   Electrical parameter controlled by the Load. Options are:

                            * 'CURR' - measured Current (Amps)
                            * 'POW'  - measured Power   (Watts)
                            * 'VOLT' - measured Voltage (Volts)
                            * 'ETIM' - Elapsed Time (s)
                            * 'ENER' - measuerd Energy (Wh - Watt Hrs)
                            * 'CAP'  - measured Capacity (Ah - Amp Hrs)
        :type param:    str | enum_meas_param
        :return:        Read Back current parameters
        :rtype:         float
        """
        # SCPI Commands:    PLZ-5W options are slightly different compared to PLZ-4W series
        #    <param> = Current | Voltage | POWer | ETIMe | ENERgy | CAPacity
        # R/-   MEASure:<param>?

        param_obj = check_enum_str('param', param.upper(), self.enum_meas_param)
        rslt = self.query('MEASURE:' + param_obj.name + '?')
        return float(rslt.rstrip())
    # ------------------------------------------------------------------------------------------------------------------

    def switching(self, state=None, level_low=None, percent_low=None, freq=None, period=None,
                  duty_cycle=None, level_hi=None):
        """
        |   Method to configures switching between two load currents in CC or CR mode **ONLY**.
        |   Attempting to use this in other modes will throw an exception.
        |
        |   The load will switch between the two levels defined by:
        |       High Level = 'level_hi' or whatever has been set by using the **level** method if not
        |       set in this method.
        |       Low Level = 'level_low' or 'percent low' (aka **Depth**) : Note that 'percent_low'
        |       will take **precedence**.
        |
        |   The frequency of the switching is defined by 'freq' or 'period', with 'period' taking
        |   **precedence**.
        |
        |   The duty_cycle defines the 'duration' of the **High** level.
        |
        |   If operating in **CC mode**, this affects the load current and level_low is interpreted
        |   as **amps**.
        |   If operating in **CR mode**, this affects the load conductance and level_low is is
        |   interpreted as **Siemens**.

        :param state:       'ON' or 'OFF'. Enables/Disables toggling between the two load currents.
                            Current in OFF state corresponds to the high level or 100% of the level
                            set by the level method.
        :type state:        str
        :param level_hi:    The current or conductance corresponding to the high level of the resulting
                            waveform.
        :type level_hi:     str
        :param level_low:   The current or conductance corresponding to the low level of the resulting
                            waveform. Setting this equal to or greater than the high level defined by
                            the level method just gives a waveform that is constant at the high level.
        :type level_low:    str
        :param percent_low: The low level of the waveform expressed as a percentage of the high level.
                            The high level is the level set through the level method (or level_hi).
                            Percent ranges from 0 to 100. A level of 100 just gives a waveform that is
                            constant at the high level. **NOTE:** If both level_low and percent_low
                            are specified, the percent_low takes precedence.
        :type percent_low:  float
        :param freq:        The number of high/low cycles per second, the reciprocal of period.
        :type freq:         float
        :param period:      Time interval (in sec) for one high/low cycle. The reciprocal of freq.
                            **NOTE:** If both freq and period are specified, the period takes precedence.
        :type period:       float
        :param duty_cycle:  The percentage of each high / low cycle time (period) at the high level.
        :type duty_cycle:   float
        :return:            Read Back current parameters if the method is called empty.
        :rtype:             dict | None
        """
        # SCPI Commands:    PLZ-5W uses different commands to for Switching Mode compared to PLZ-4W series
        # -/R   TRIGger:TRANsient:EXECution[:STATe]? {IDLE | PULS | RUN | SUSP | WTG}
        #           PULS, 0, 0 = Switching Mode Enabled
        #           IDLE, 0, 0 = Switching Mode Disabled (Static Level)
        #           RUN, #1, #2 = Sequence Running (#1 = steps, #2 = iteration)
        #           SUSP, #1, #2 = Sequence Suspended/Paused (#1 = steps, #2 = iteration)
        # W/-   INITiate:IMMediate:PULSe    "Initiate the PULSe/Switching Mode"
        #    <param> = CONDuctance | CURRent
        # W/R   [SOURce:]<param>[:LEVel][:IMMediate][:AMPLitude] {<numeric> | MINimum | MAXimum}
        # W/R   [SOURce:]<param>:PULSe:LEVel {<numeric> | MINimum | MAXimum}
        # W/R   [SOURce:]<param>:FREQuency {<numeric> | MINimum | MAXimum}
        # W/R   [SOURce:]<param>:DCYCle {<numeric> | MINimum | MAXimum}

        mode = self.mode()
        param = {'CC': 'CURR', 'CR': 'COND'}.get(mode)

        if param is None:
            # Attempting to program these parameters in other modes would cause error 27.
            raise ValueError(f"Cannot set switching parameters in {mode}, only in modes 'CC' and 'CR'.")

        ref_level = float(self.query(f'{param}:LEVel:IMMediate:AMPLitude?'))

        if all(v is None for v in {state, level_low, percent_low, freq, period, duty_cycle, level_hi}):
            return_val = dict()
            # tmp = self.query('PULS?')
            tmp = self.query('TRIGger:TRANsient:EXECution?').strip().split(',')[0]

            if 'PULS' in tmp.upper():
                return_val.update(state=f'ON')
            elif 'IDLE' in tmp.upper():
                return_val.update(state=f'OFF')
            else:
                return_val.update(state=f'Sequence Enabled')

            depth_level = float(self.query(f'{param}:PULS:LEV?'))
            depth_perc = round(100*(depth_level/ref_level), 3)
            return_val.update(level_low=depth_level)
            return_val.update(percent_low=depth_perc)
            puls_freq = float(self.query(f'{param}:PULS:FREQ?'))
            puls_period = round(1/puls_freq, 7)
            return_val.update(freq=puls_freq)
            return_val.update(period=puls_period)
            return_val.update(duty=float(self.query(f'{param}:PULS:DCYC?')))
            return_val.update(level_hi=ref_level)
            return return_val

        # Out of bound values for other parameters don't cause errors, they just cause the setting to go to one of
        # it extreme values.

        # also checks if the state param is valid. Needs to be first.
        if state is not None and ('OFF' in self.on_off.to_api(state).upper()):
            self.write('ABORt:PULS')  # command to disabled Switching
        elif state is not None and ('ON' in self.on_off.to_api(state).upper()):
            self.write('INITiate:IMMediate:PULSe')  # command to execute the Switching

        minval, maxval, units = self.ratings(param.upper(), self.range(param.upper()))
        if level_hi is not None and (minval <= level_hi <= maxval):
            self.write(f'{param.upper()}:LEVel:IMMediate:AMPLitude ', float(level_hi))
            ref_level = float(level_hi)
        elif level_hi is not None:
            raise ValueError(f"Bad level_hi {level_hi}, should be {minval} to {maxval} {units}.")

        if percent_low is not None and (0.0 <= percent_low <= 100.0):
            # calculate and write the 'level_low' based on 'percent' - Note it will overwrite 'level_low' passed in
            level_low = ref_level * percent_low / 100
        elif percent_low is not None:
            raise ValueError(f"Bad percent {percent_low}, should be 0 to 100.")

        if level_low is not None and (0.0 <= level_low <= ref_level):
            self.write(f'{param.upper()}:PULSe:LEVel ', float(level_low))
        elif level_hi is not None:
            raise ValueError(f"Bad level_low {level_low}, should be {0.0} to {ref_level} {units}.")

        minval, maxval = self._ratings['FREQ']['L']
        if period is not None and (1.0/maxval <= period <= 1/minval):
            # calculate and write the 'freq' based on 'period' - Note it will overwrite 'freq' passed in
            freq = round(1.0/period, 3)
        elif period is not None:
            raise ValueError(f"Bad period {period}, should be {1.0/maxval} to {1.0/minval} sec.")

        if freq is not None and (minval <= freq <= maxval):
            self.write(f'{param.upper()}:PULSe:FREQuency {float(freq)}')
        elif freq is not None:
            raise ValueError(f"Bad freq {freq}, should be {minval} to {maxval} Hz.")

        if duty_cycle is not None and (5.0 <= duty_cycle <= 95):
            self.write(f'{param.upper()}:PULS:DCYC {duty_cycle}')
        elif duty_cycle is not None:
            raise ValueError(f"Bad duty {duty_cycle}, should be 5 to 95 percent.")

        # if state is not None and ('ON' in self.on_off.to_api(state).upper()):
        #     self.write('INITiate:IMMediate:PULSe')  # command to execute the Switching

        self.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def dynamics(self, cc_slew=None, cv_response=None, cr_response=None):
        """
        |   Queries or sets current slew rate and/or transient response speeds for CV and CR modes.

        :param cc_slew:     Slew rate in Amps/uSec. Numeric value within the present current range
        :type cc_slew:      int | float
        :param cv_response: "NORM" or "FAST"
        :type cv_response:  str | enum_dynamics_response
        :param cr_response: "NORM" or "FAST"
        :type cr_response:  str | enum_dynamics_response
        :return:            Read Back current parameters if the method is called empty.
        :rtype:             dict | None
        """
        # SCPI Commands:    PLZ-5W options are slightly different compared to PLZ-4W series
        # W/R   [SOURce:]CURRent:SLEW {<numeric>|MINimum|MAXimum}
        #    <param> = VOLTage | CONDuctance
        # W/R   [SOURce:]<param>:RESPonse {NORMal|FAST} / {NORM|FAST}

        if all(v is None for v in {cc_slew, cv_response, cr_response}):
            return_val = dict()
            return_val.update(cc_slew=float(self.query('CURRent:SLEW?')))
            return_val.update(cv_response=self.query('VOLTage:RESPonse?').strip())
            return_val.update(cr_response=self.query('CONDuctance:RESPonse?').strip())
            return return_val

        if cc_slew is not None:
            # curr_range = self.range("CURR")
            min_val, max_val, units = self.ratings('SLEW', self.range("CURR"))
            if type(cc_slew) not in (int, float) or (min_val <= cc_slew <= max_val):
                self.write(f'CURR:SLEW {cc_slew}')
            else:
                raise ValueError(f"Bad cc_slew {cc_slew} for {self.range('CURR')} current range, "
                                 f"should be type int/float and in range {min_val} to {max_val} {units}.")

        # legal_responses = ('NORM', 'FAST')

        if cv_response is not None:
            cv_resp_obj = check_enum_str('cv_response', cv_response.upper(), self.enum_dynamics_response)
            self.write(f'VOLTage:RESPonse {cv_resp_obj.name}')

        if cr_response is not None:
            cr_resp_obj = check_enum_str('cr_response', cr_response.upper(), self.enum_dynamics_response)
            self.write(f'CONDuctance:RESPonse {cr_resp_obj.name}')

        self.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def trig_sources(self, transient_src=None, acquire_src=None):
        """
        |   Set or query the source for the triggering a transient or measurement.

        :param transient_src:   Character set defining the source for triggering a transient.
                                Options are:

                                    * IMMediate (Default)
                                    * BUS - software trigger \*TRG
                                    * DIGITAL2
                                    * MSYNc
        :type transient_src:    str | None
        :param acquire_src:     Character set defining the source for triggering a measurement.
                                Options are:

                                    * IMMediate (Default)
                                    * BUS - software trigger \*TRG
                                    * DIGITAL2
                                    * TALink
                                    * MSYNc
        :type acquire_src:      str | None
        :return:                dict of trigger sources
        :rtype:                 str
        """
        # SCPI Commands:
        # W/R   TRIGger:ACQuire:SOURce <character>
        # W/R   TRIGger:TRANsient:SOURce <character>

        if all(v is None for v in {transient_src, acquire_src}):  # lambda
            return {'transient': self.query(f'TRIGger:TRANsient:SOURce?').strip(),
                    'acquire': self.query(f'TRIGger:ACQuire:SOURce?').strip()}

        if transient_src.upper() in ['IMM', 'BUS', 'DIGITAL2', 'MSYN']:
            self.write(f'TRIGger:TRANsient:SOURce {transient_src.upper()}')

        if acquire_src.upper() in ['IMM', 'BUS', 'DIGITAL2', 'MSYN', 'TAL']:
            self.write(f'TRIGger:ACQuire:SOURce {acquire_src.upper()}')
    # ------------------------------------------------------------------------------------------------------------------

    def abort(self, disable_input=False):
        """
        |   Abort all active 'switching' scenarios, i.e. Switching/Pulse mode or executing a
        |   Program/Sequence.
        |       **NOTE** that abort will only disable 'active' TRANsient switching, and not the **input**
        |   of the Electronic Load. However, an option has been included in the code to also be able
        |   to disable the Input.

        :param disable_input:   Switch to also disable the output when 'aborting' the any active
                                switching.
        :type disable_input:    bool
        :return:
        :rtype:
        """
        # SCPI Commands:
        # W/-   ABORt[:ALL]

        self.write(f'ABORt:ALL')

        if disable_input:
            self.write(f'INPut:STATe OFF')
    # ------------------------------------------------------------------------------------------------------------------

    def ocp_value(self, ilimit=None, action=None):
        """
        |   Queries or sets Over Current Protection parameters.

        :param ilimit:  When load current exceeds this number of Amps, the OCP either limits the
                        current or changes the state of the load to 'OFF'.
        :type ilimit:   float
        :param action:  Defines what the load does when the OCP ilimit is reached.

                            * 0, 'OFF' or 'LIM' - Load still enabled, but current is limited by level
                              set by 'ilimit'.
                            * 1, 'ON' or 'TRIP' - The state of the load is switched to 'OFF'.
        :type action:   str | enum_ocp_action
        :return:        Read Back current parameters if the method is called empty.
        :rtype:         dict | None
        """
        # SCPI Commands:    PLZ-5W options are slightly different compared to PLZ-4W series
        # W/R   [SOURce:]CURRent:PROTection[:LEVel][:UPPer] {<numeric> | MINimum | MAXimum}
        # W/R   [SOURce:]CURRent:PROTection:STATe {0 | 1 | OFF | ON} / {0 | 1}      "0 = LIMit | 1 = TRIP"
        #           'LIM', 'TRIP' have been added as valid options to 'self.enum_ocp_action'

        if all(v is None for v in {ilimit, action}):
            return_val = dict()
            return_val.update(ilimit=float(self.query('CURRent:PROTection?')))
            return_val.update(action=['LIM', 'TRIP'][int(self.query('CURRent:PROTection:STATe?').strip())])
            return return_val

        if ilimit is not None and (0 <= ilimit <= self._rating_curr_max):
            self.write(f'CURRent:PROTection {ilimit}')
        elif ilimit is not None:
            raise ValueError(f"Bad ilimit {ilimit}, should be 0 to {self._rating_curr_max} Amps.")

        if action is not None:
            action_obj = check_enum_str('action', str(action).upper(), self.enum_ocp_action)
            self.write(f'CURRent:PROTection:STATe {self._protection_action_dict[action_obj.name]}')

        self.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def ocp_clear(self):
        """
        |   Writes command to clear Over Current Protection trip.
        |
        |   If the OCP action is set to 'TRIP', the load state is changed to 'OFF' by OCP current
        |   through the load exceeding the set level.
        |       Note that after clearing the trip state, the output will remain off until reactivated
        |   using the state method.
        """
        # SCPI Command:
        # W/-   INPut:PROTection:CLEar

        self.write('INPut:PROTection:CLEar')
    # ------------------------------------------------------------------------------------------------------------------

    def opp_value(self, plimit=None, action=None):
        """
        |   Queries or sets Over Power Protection parameters.

        :param plimit:  When load power exceeds this number of Watts, the OPP either limits the power
                        or changes the state of the load to 'OFF'.
        :type plimit:   float
        :param action:  Defines what the load does when the OPP plimit is reached.

                            * 'LIM': Current still flows but power is prevented from exceeding the
                              level set by plimit.
                            * 'TRIP': The state of the load is switched to 'OFF'.
        :type action:   str | enum_opp_action
        :return:        If called without parameters, read back current parameter values. Otherwise None.
        :rtype:         dict | None
        """
        # SCPI Commands:        PLZ-5W options are slightly different compared to PLZ-4W series
        # W/R   [SOURce:]POWer:PROTection[:LEVel][:UPPer] {<numeric> | MINimum | MAXimum}
        # W/R   [SOURce:]POWer:PROTection:STATe {0 | 1 | OFF | ON} / {0 | 1}        "0 = LIMit | 1 = TRIP"
        #           'LIM', 'TRIP' have been added as valid options to 'self.enum_ocp_action'

        if all(v is None for v in {plimit, action}):
            return_val = dict()
            return_val.update(plimit=float(self.query('POWer:PROTection?')))
            return_val.update(action=['LIM', 'TRIP'][int(self.query('POWer:PROTection:STATe?').strip())])
            return return_val

        if plimit is not None and (0 <= plimit <= self._rating_pow_max):
            self.write(f'POWer:PROTection {plimit}')
        elif plimit is not None:
            raise ValueError(f"Bad plimit {plimit}, should be 0 to {self._rating_pow_max}.")

        if action is not None:
            action_obj = check_enum_str('action', str(action).upper(), self.enum_opp_action)
            self.write(f'POWer:PROTection:STATe {self._protection_action_dict[action_obj.name]}')

        self.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def opp_clear(self):
        """
        |   Writes command to clear Over Current Protection trip.
        |
        |   If the OPP action is set to 'TRIP', the load state is changed to 'OFF' by OPP power across
        |   the load exceeding the set level.
        |       Note that after clearing the trip state, the output will remain off until reactivated
        |   using the state method.
        """
        # SCPI Command:
        # W/-   INPut:PROTection:CLEar

        self.write('INPut:PROTection:CLEar')
    # ------------------------------------------------------------------------------------------------------------------

    def status_reg_bits(self, regname):
        """
        |   Queries OPER or QUES status register and returns dictionary showing name-values of bits.
        |
        |       Note that PLZ-5W does not have a CSUM register as on PLZ-4W - this will read the OPER
        |   status register instead.

        :param regname: 'OPER' or 'QUES' ('CSUM' string supported). Not case sensitive.
        :type regname:  str
        :return:        values of the selected status register
        :rtype:         dict
        """
        # SCPI Commands:
        #    <param> = OPERation | QUEStionable
        # -/R   STATus:<param>>[:EVENt]?

        # the enum has a second dictionary of conditions embedded as the value of the first dictionary.
        # The reg name acts as the key to find it within the enumeration.

        if 'CSUM' in regname.upper():
            regname = 'OPER'

        regname_obj = check_enum_str("regname", regname.upper(), self.enum_status_regs)

        value = 0
        if regname_obj is not None:
            value = int(self.query(f'STAT:{regname_obj.name}:COND?'))

        # prepare the read out.
        result = dict()
        for name, bit in regname_obj.value.items():  # iterate through the items in the embedded dictionary
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})
        return result
    # ------------------------------------------------------------------------------------------------------------------

    def status(self):
        """
        |   Reads the status byte register and returns the names-values of the 3 status bits as a dict.
        |
        |   Does not clear the STB, call status_clear to do that, but beware that clears the error
        |   queue as well.
        """
        # SCPI Commands:
        # -/R   *STB?

        value = int(self.query('*STB?').rstrip())
        conditions = {'EEQ': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPER': 7}
        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})
        return result
    # ------------------------------------------------------------------------------------------------------------------

    def status_clear(self):
        """
        |   Clears the STB (status byte) and the error queue by sending \*CLS command.
        """
        # SCPI Commands:
        # W/-   *CLS

        self.write('*CLS')
    # ------------------------------------------------------------------------------------------------------------------

    # --------------------------------------- """ Helper Methods/Functions """ --------------------------------------- #
    def regulate(self, desired_value, tolerance=0.1, max_iterations=10, delay=0.5):
        """
        |   Alters the level setting of the parameter controlled by the present mode to achieve a
        |   measured level equal to desired_value.

        :param desired_value:   Target measured level for parameter.
        :type desired_value:    float
        :param tolerance:       Value is considered to have hit the target when
                                measured level falls within +/- tolerance percent
                                of the desired_value.
        :type tolerance:        float
        :param max_iterations:  Upper limit on number of adjustments to level
                                setting before giving up on achieving the
                                desired_value +/- tolerance percent. If 0, then no
                                adjustments are made to present level setting.
        :type max_iterations:   int
        :param delay:           Settling time between level change and measurement.
        :type delay:            float
        :return:                True/False if measured level is within +/- tolerance percent of
                                desired_value.
        :rtype:                 bool
        """

        # param = {'CC': 'CURR', 'CV': 'VOLT', 'CP': 'POW', 'CR': 'COND', 'CCCV': 'CURR', 'CRCV': 'COND'}[self.mode()]
        param = {**self._std_mode_dict, **self._add_mode_dict}[self.mode()]

        self.level(param, desired_value)
        self.state('ON')

        sleep(delay)
        delta = self.meas(param) - desired_value
        error_percent = 100 * abs(delta / desired_value)

        iteration = 0
        while iteration < max_iterations:
            if error_percent <= tolerance:
                print('Regulated level is within %4.3f%% of desired after %d iterations.' % (error_percent, iteration))
                return True

            self.level(param, desired_value - delta)

            iteration += 1
            print('iter = %d' % iteration)

            sleep(delay)
            delta = self.meas(param) - desired_value
            error_percent = 100 * abs(delta / desired_value)

        # If we got here, either regulation failed or user put in max_iterations=0.
        print('After %d iterations, level is within %4.3f%% of desired.' % (iteration, error_percent))
        if error_percent > tolerance:
            return False
        else:
            return True


class Program(object):
    """
    |   Class for the Program/Sequence feature, to implement the methods required
    """

    def __init__(self, instr, *args, **kwargs):
        """
        Pass in the object for the instrument to be extracted for functionality

        :param instr:   Base object for the instrument
        """

        self._eload = instr
    # ------------------------------------------------------------------------------------------------------------------

    def get_programs(self, mode=None):
        """
        |   Method to retrieve all stored programs/sequences for a specific mode, i.e. (CC/CCCV,
        |   CR/CRCV, CV  CP, ARB) and return a dictionary.
        |       Note that each 'mode' stores a set of programs/sequences separately.
        |
        |   If no mode is specified, i.e. mode=None, then the code will retrieve all stored
        |   programs/sequences for **each** 'mode' and return a dictionary with the programs/sequences
        |   available.
        |
        |   The PLZ-5W can store a total of 30 Programs, with a 'combined' total numbers of steps of
        |   10,000 for all programs.

        :param mode:    If None will search all stored sequences for each mode. Applicable Modes are:

                            * CC/CCCV
                            * CR/CRCV
                            * CV
                            * CP
                            * ARB : Program/Sequences not applicable for this mode
        :type mode:     str
        :return:        Dictionary of all sequences stored for each mode or only for the specified mode
        :rtype:         dict()
        """
        # SCPI Commands:
        # -/R   [SOURce:]PROGram:LIST?      'Queries the unit for a list of saved/registered programs in Memory'

        if 'ON' in self._eload.state():
            raise RuntimeError(f'Cannot retrieve Informaton if unit is on')

        previous_mode = self._eload.mode()
        if mode is None:
            mode_list = list(self._eload._std_mode_dict.keys()) + list(self._eload._add_mode_dict.keys())
        else:
            mode_list = [f'{mode.upper()}']

        pgm_dict = {}
        for item in mode_list:
            self._eload.mode(item)
            pgm_dict[item] = list(self._eload.query('PROGram:LIST?').replace('"', '').strip().split(','))

        if self._eload.mode() != previous_mode:  # Return unit to previous mode
            self._eload.mode(previous_mode)

        return pgm_dict
    # ------------------------------------------------------------------------------------------------------------------

    def get_program_info(self, pgm_name=None):
        """
        |   Method to retrieve the information for the specified program/sequence.
        |       The information returned about the specified program will be retrieved from the
        |   instrument.
        |   If no match is found, code will return a list of applicable programs/sequences for the
        |   current mode.
        |
        |   The information returned should include the following for a selected program:
        |       * program name
        |       * mode
        |       * number of loops                           (1 to 100,000 or 'INFinite')
        |       * number of steps that have been defined    (a maximum of 10,000 steps in total)
        |       * a list of the settings for each step

        :param pgm_name:    Name of stored program. A 'combined' max of 30 programs can be stored in
                            the unit for a combined total of 10,000 steps. The 'program name' should
                            be preceded with '/', for example"/NEW PROGRAM1"
        :type pgm_name:     str
        :return:            If function is called without parameters, will return saved sequences available.
        :rtype:             dict
        """
        # SCPI Commands:
        # W/R   [SOURce:]PROGram[:SELected] "/<program name>"   'Programs are selected by Name, not number as PLZ-4W'
        # W/R   [SOURce:]PROGram[:SELected]:LOOP {<numeric> | INFinite}
        # W/R   [SOURce:]PROGram[:SELected]:STEPS:COUNt <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:LEVel <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:SLEWrate <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:DWELl <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:INPut {ON | OFF | 1 | 0}     '# OUTPUT interchangable with INPUT
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRANsient {IMMediate|RAMP}  # This is 'Load' column in the editor
        #
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:WAIT <char> [,<char>,<char>,<char>, <char>]
        #         e.g. PROG:STEP1:TRIG:WAIT IMM, BUS, or TRIGIN with/without DIGITAL2 and/or MSYNc
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:GENerate <char> [,<char>,<char>,<char>, <char>]
        #         e.g. PROG:STEP1:TRIG:GEN NONE or a combination of TRIGOUT, DIGITAL0, DIGITAL1, DIGITAL3, TALink

        if 'ON' in self._eload.state():
            raise RuntimeError(f'Cannot retrieve Informaton if unit is on')

        # get all programs/sequences stored for the currently configured mode
        current_mode = self._eload.mode()  # Get the current 'mode.'
        current_range = self._eload.range(self._eload._std_mode_dict[current_mode.upper()])
        pgm_dict = self.get_programs(current_mode)  # Get the list of applicable programs/sequences

        if pgm_name is None:  # If Nothing specified, return list of applicable programs/sequences
            return pgm_dict

        selected_pgm = self._check_program_valid(pgm_name, pgm_dict)

        if selected_pgm is not None:
            self.load(current_mode, selected_pgm)
            # pgm_details['Pgm Name'] = selected_pgm
            # pgm_details['Mode'] = current_mode
            # pgm_details['Num Loops'] = int(self.query(f'PROGram:SELected:LOOP?').strip())
            step_count = int(self._eload.query(f'PROGram:SELected:STEPS:COUNt?').strip())
            # pgm_details['Num Steps'] = step_count

            # Header Row
            steps = [f'Step, Level, Slew, dwell, Load, Transient, Trig Wait Options, Trigger Gen Options\n']
            for step_idx in range(1, step_count+1):
                # step_level = float(self.eload.query(f'PROGram:SELected:STEP{step_idx}:LEVel?').strip())
                steps.append(f"{step_idx}"
                             f", {float(self._eload.query(f'PROGram:SELected:STEP{step_idx}:LEVel?').strip())}"
                             f", {float(self._eload.query(f'PROGram:SELected:STEP{step_idx}:SLEW?').strip())}"
                             f", {float(self._eload.query(f'PROGram:SELected:STEP{step_idx}:DWELl?').strip())}"
                             f", {self._eload.query(f'PROGram:SELected:STEP{step_idx}:INPut?').strip()}"
                             f", {self._eload.query(f'PROGram:SELected:STEP{step_idx}:TRANsient?').strip()}"
                             f", \"{self._eload.query(f'PROGram:SELected:STEP{step_idx}:TRIGger:WAIT?').strip()}\""
                             f", \"{self._eload.query(f'PROGram:SELected:STEP{step_idx}:TRIGger:GENerate?').strip()}\""
                             f"\n")

            return {'pgm_name': selected_pgm,
                    'mode': current_mode,
                    'range': current_range,
                    'num_loops': int(self._eload.query(f'PROGram:SELected:LOOP?').strip()),
                    'num_steps': step_count,
                    'steps': steps
                    }
            # self.write(f'PROGram ""')  # Clear the Program selection
        else:  # this is actually redundant, but added as a 'safe guard'
            raise ValueError(f'Bad pgm_name {pgm_name}. Available programs/sequences in memory are {pgm_dict}.')
    # ------------------------------------------------------------------------------------------------------------------

    @staticmethod
    def _check_program_valid(pgm_name, pgm_dict, check_for_match=True):
        """
        |   Internal helper function to check program name exists.

        :param pgm_name:        name of program - name can have '/' and is not case sensitive.
        :type pgm_name:         str
        :param pgm_dict:        dictionary of available programs (should be for a single mode).
        :type pgm_dict:         dict
        :param check_for_match: switch for checking if match found
        :type check_for_match:  bool
        :return:
        :rtype:
        """

        if len(pgm_dict) > 1:
            raise ValueError(f'Bad pgm_dict {pgm_dict}: list should be for one mode only.')

        for item in pgm_dict[list(pgm_dict.keys())[0]]:
            if pgm_name.strip('/').upper() == item.strip('/').upper():
                pgm_rtn = item
                if not check_for_match:
                    raise ValueError(f'Bad pgm_name {pgm_name}: program/sequence name already in used - {pgm_dict}')
                break
        else:  # FOR .. else loop
            pgm_rtn = None
            if check_for_match:
                raise ValueError(f'Bad pgm_name {pgm_name}: applicable programs/sequences are {pgm_dict}')

        return pgm_rtn

    def load(self, mode=None, pgm_name=None):
        """
        |   Load specified Program/Sequence to the sequencer memory.
        |
        |   If either 'mode' or 'pgm_name' is None, will return a tuple with current mode and currently
        |   loaded Program/Sequence.

        :param mode:        Operating Mode
        :type mode:         str
        :param pgm_name:    Name of Program/Sequence stored in Memory
        :type pgm_name:     str
        :return:            if pgm_name none, dictionary of available sequences
        :rtype:             dict
        """
        # SCPI Commands:
        # W/R   [SOURce:]PROGram[:SELected] "/<program name>"

        if mode is None and pgm_name is None:
            return self._eload.mode(), self._eload.query('PROGram:SELected?').replace('"', '').strip()
        elif mode is None or pgm_name is None:
            raise ValueError(f'Operating mode {mode} or pgm_name {pgm_name} has not been specified. No changes '
                             f'have been made.')

        self._eload.mode(mode.upper())
        pgm_dict = self.get_programs(mode.upper())
        selected_pgm = self._check_program_valid(pgm_name, pgm_dict)
        self._eload.write(f'PROGram:SELected "{selected_pgm}"')
    # ------------------------------------------------------------------------------------------------------------------

    def load_from_file(self, filename, plz_5w_format=True, dataline_start=9, overwite_existing=False,
                       use_file_mode=True, info_dict=None):
        """
        |   Load a sequence from file and create a sequence with the name provided in the file. If no
        |   'pgm_name' supplied in the file, then a generic program name will be used, i.e. '/CSVFILESEQ'.
        |
        |   Warnings will be given in the following instances:
        |       * If sequence name already exists (existing sequence can be overwritten).
        |       * If current mode configured does not match the mode specified in file. Options
        |         available will be:
        |           - change the operating mode to match the mode specified in file
        |           - enter the data without changing the current operating mode
        |
        |   File format should be a 'csv' file with the following as a minimum:
        |       step #, level, slew, dwell     i.e. 4 columns
        |           *The other columns will not be edited, but they may copy settings from previous rows.*
        |   Format generated by this code has 8 columns, and the 4 unused columns can be left
        |   blank

        :param filename:            pathname to file to be loaded (assumption that format matches
                                    required)
        :type filename:             str
        :param plz_5w_format:       switch stating if file format matches that saved by 'pgm_save'
        :type plz_5w_format:        bool
        :param dataline_start:      line number from which the data for the sequence starts (0 indexed)
        :type dataline_start:       int
        :param overwite_existing:   switch to overwrite an existing sequence with same name
        :type overwite_existing:    bool
        :param use_file_mode:       switch to change the operating mode to match the file
        :type use_file_mode:        bool
        :param info_dict:           special parameter - unlikely to use
        :type info_dict:            dict
        :return:                    name given to the program/sequence saved
        :rtype:                     str
        """

        # open and read ALL the lines to a list
        if filename != 'input from get_program_info':
            with open(filename) as fo:
                contents = fo.readlines()

        num_loops = 1
        num_steps = 1
        # initialise variables before assignment
        num_steps_created = 1
        pgm_name = None
        pgm_mode = None
        pgm_range = None
        # print(contents)

        if plz_5w_format:
            for line_num in range(dataline_start):
                # print(f'line_num - {line_num}')
                # print(f'contents(line_num) = {contents[line_num]}')
                if 'Program/Sequence name' in contents[line_num]:
                    pgm_name = contents[line_num].split(',')[1].strip()
                if 'Operating Mode' in contents[line_num]:
                    pgm_mode = contents[line_num].split(',')[1].strip()
                if 'Operating Range' in contents[line_num]:
                    pgm_range = contents[line_num].split(',')[1].strip()
                if 'Number of Loops' in contents[line_num]:
                    num_loops = contents[line_num].split(',')[1].strip()
                if 'Number of Steps' in contents[line_num]:  # will be used as a check against steps loaded
                    num_steps = contents[line_num].split(',')[1].strip()

            if pgm_name in ['', ' ', '   ']:
                pgm_name = '/CSVFILESEQ'

            if use_file_mode:
                selected_mode = pgm_mode
                self._eload.mode(pgm_mode.upper())
                self._eload.range(self._eload._std_mode_dict[pgm_mode.upper()], pgm_range.upper())
            else:
                selected_mode = self._eload.mode()

            pgm_dict = self.get_programs(selected_mode)
            try:
                # if unique, create a new Program/Sequence
                self._check_program_valid(pgm_name, pgm_dict, check_for_match=False)
                self.create(selected_mode, pgm_name.strip('/').upper())
                # self._eload.mode(pgm_mode)
                self.load(selected_mode, pgm_name.strip("/").upper())
                # self._eload.write(f'PROGram:SELected "/{pgm_name.strip("/").upper()}"')
            except ValueError:
                # if duplicate, confirm if want to overwrite, else raise Error
                if overwite_existing:
                    self.load(selected_mode, pgm_name.strip("/").upper())
                    # self._eload.write(f'PROGram:SELected "{pgm_name.upper()}"')
                else:
                    raise RuntimeError(f'Permission to overwrite existing Program/Sequence not given')

        # parse the csv data using the csv module
        if filename == 'input from get_program_info':
            # dictionary from get_program_info
            parsed = csv.reader(info_dict['steps'][1:], skipinitialspace=True, doublequote=True)
            num_loops = info_dict['num_loops']
            num_steps = info_dict['num_steps']
        else:
            # contents of file
            parsed = csv.reader(contents[dataline_start:], skipinitialspace=True, doublequote=True)

        self._eload.write(f'PROGram:SELected:LOOP {num_loops}')
        self._eload.write(f'PROGram:SELected:STEPS:COUNT {num_steps}')

        for idx, row_data in enumerate(parsed):
            # print(f'idx:{idx}, {row_data}')  # debug
            # print(f'idx:{idx}, {len(row_data)}')  # debug
            if idx == 0:
                if len(row_data) != 8:
                    plz_5w_format = False

            # if more steps being added compared to what is stated, then added more steps
            if idx >= int(num_steps):
                self._eload.write(f'PROGram:SELected:STEPS:COUNT {idx+1}')
                sleep(0.25)

            self.edit_step_param(step_num=row_data[0], step_param='level', value=row_data[1])

            if pgm_mode == 'CC':
                self.edit_step_param(step_num=row_data[0], step_param='slew', value=row_data[2])

            self.edit_step_param(step_num=row_data[0], step_param='dwell', value=row_data[3])

            if plz_5w_format:
                if row_data[4].strip() is not '':
                    self.edit_step_param(step_num=row_data[0], step_param='load', value=row_data[4])
                # else:
                #     # Write the default?
                #     self.edit_step_param(step_num=row_data[0], step_param='load', value='ON')

                if row_data[5].strip() is not '':
                    self.edit_step_param(step_num=row_data[0], step_param='transient', value=row_data[5])
                # else:
                #     # Write the default?
                #     self.edit_step_param(step_num=row_data[0], step_param='transient', value='IMM')

                if row_data[6].strip() is not '':
                    self.edit_step_param(step_num=row_data[0], step_param='trig_input', value=row_data[6])
                # else:
                #     # Write the default?
                #     self.edit_step_param(step_num=row_data[0], step_param='trig_input', value='IMM')

                if row_data[7].strip() is not '':
                    self.edit_step_param(step_num=row_data[0], step_param='trig_output', value=row_data[7])
                # else:
                #     # Write the default?
                #     self.edit_step_param(step_num=row_data[0], step_param='trig_output', value='NONE')

                # self.edit_step_param(step_num=row_data[0], step_param='level', value=row_data[1])
            # else:
            #     # write the 'unused' columns to default, otherwise these will be a copy of previous row
            #     # which could cause issues if not from a newly created Program/Sequence.
            #     self.edit_step_param(step_num=row_data[0], step_param='load', value='ON')
            #     self.edit_step_param(step_num=row_data[0], step_param='transient', value='IMM')
            #     self.edit_step_param(step_num=row_data[0], step_param='trig_input', value='IMM')
            #     self.edit_step_param(step_num=row_data[0], step_param='trig_output', value='NONE')

            num_steps_created = idx + 1

        if num_steps == num_steps_created:
            self._eload.log.info('Number of steps stated in file matches number of steps created')

        self.save()  # Save the Program/Seqeunce

        return pgm_name
    # ------------------------------------------------------------------------------------------------------------------

    def save(self):
        """
        |   Will save any changes made to the **currently** loaded program/sequence.

        :return:
        :rtype:
        """
        # SCPI Commands:
        # W/-   [SOURce:]PROGram[:SELected]:SAVE

        self._eload.write(f'PROGram:SELected:SAVE')
    # ------------------------------------------------------------------------------------------------------------------

    def save_to_file(self, pgm_name, filename=None):
        """
        |   Save the Program Sequence from Unit Memory to a Python module that provides a function
        |   'load_from_file'.
        |
        |   The PLZ-5W series can store up to a max of **30 Sequences** (across the different 'modes'),
        |   with a combined total of 10,000 steps. Unlike the PLZ-4W series, the PLZ-5W series does not
        |   have a 'NORM' or 'FAST' mode, and the timing resolutions are applicable for all sequences.
        |
        |   When executing 'load_from_file,' this will write the cfg and step information into the
        |   specified Program Sequence location in the PLZ instrument.

        :param pgm_name:    Name to be given to the program/sequence. Program name should start with
                            '/' but can be omitted as code will insert this.
        :type pgm_name:     str
        :param filename:    desired Filename if also wanting to save to a location as a csv. If None,
                            will save to Unit Memory.
        :type filename:     str
        :return:            If called without parameters, read back current parameter values.
                            Otherwise None.
        :rtype:             dict | none
        """

        fileobj = open(filename, mode='w')

        # this assumes the mode has been correctly set
        info = self.get_program_info(pgm_name)
        # 'info is a dictionary with the following info:
        #     {'pgm_name': program name,
        #      'mode': mode,
        #      'num_loops': number of loops,
        #      'num_steps': number of steps,
        #      'steps': List containing the details for each step
        #      }

        file_str = f'Saved Sequence for Kikusui PLZ-5W series Electronic Load.\n' \
                   f'To recall this, use the \'program.load_from_file\' method.\n' \
                   f'Program/Sequence name, {info["pgm_name"].upper()}\n' \
                   f'Operating Mode, {info["mode"]}\n' \
                   f'Operating Range, {info["range"]}\n' \
                   f'Number of Loops, {info["num_loops"]}\n' \
                   f'Number of Steps, {info["num_steps"]}\n\n'

        for item in info['steps']:
            file_str += item

        fileobj.write(file_str)
        fileobj.flush()
        fileobj.close()

        return f'Sequence saved to file {filename}'
    # ------------------------------------------------------------------------------------------------------------------

    def rename(self, pgm_name, pgm_rename=None):
        """
        |   Rename an existing sequence. Assumption is that unit is in correct mode.
        |
        |   Code will confirm current pgm_name exists, then make change and confirm the renamed file
        |   exists and force it to be saved in **UPPERCASE**.

        :param pgm_name:    Previous name of sequence
        :type pgm_name:     str
        :param pgm_rename:  New name for sequence
        :type pgm_rename:   str
        :return success:    True or False
        :rtype:             bool
        """
        # SCPI Commands:
        # W/-   [SOURce:]PROGram[:SELected]:REName "<name>"

        if pgm_rename is None:
            raise ValueError(f'Bad \'pgm_rename\' {pgm_name}. New name required! No action has been performed')

        rtn_mode = self._eload.mode()
        pgm_dict = self.get_programs(rtn_mode)

        # check if new name exists - ValueError raised if it exists
        self._check_program_valid(pgm_rename, pgm_dict, check_for_match=False)

        selected_pgm = self._check_program_valid(pgm_name, pgm_dict)
        self.load(rtn_mode, selected_pgm)
        self._eload.write(f'PROGram:SELected:REName "{pgm_rename.upper()}"')

        new_list = self._eload.query('PROGram:LIST?')

        for item in new_list:
            if pgm_rename.strip('/').upper() == item.strip('/'):
                success = True
                break
        else:
            success = False

        return success
    # ------------------------------------------------------------------------------------------------------------------

    def create(self, mode, pgm_name):
        """
        |   Creates a new Program/Seqeunce for the specified mode, and the name will be forced to
        |   **UPPERCASE**.
        |
        |   **NOTE**: It is possible to have the duplicate program names stored in each of the
        |   different modes.
        |
        |   Program Names are **Case** sensitive, hence code forces name to be UPPERCASE.

        :param mode:        Operating mode where the Program/Sequence will be stored, i.e. CC,CV,CP,
                            CR,ARB
        :type mode:         str
        :param pgm_name:    Name of new Program to be created. Case insenstive as input, but will be
                            saved in UPPERCASE.
        :type pgm_name:     str
        :return:            success
        :rtype:             bool
        """
        # SCPI Commands
        # w/-   [SOURce:]PROGram:CREate "/<program name>"

        if mode.upper() not in (list(self._eload._std_mode_dict.keys()) + list(self._eload._add_mode_dict.keys())):
            raise ValueError(f'Bad mode {mode}: valid modes are '
                             f'{list(self._eload._std_mode_dict.keys()) + list(self._eload._add_mode_dict.keys())}')
        else:
            self._eload.mode(mode.upper())

        pgm_dict = self.get_programs(mode.upper())

        self._check_program_valid(pgm_name, pgm_dict, check_for_match=False)

        self._eload.write(f'PROGram:CREate "{pgm_name.upper()}"')

        if pgm_name.upper() in self.get_programs(mode.upper())[mode.upper()]:
            return True
        else:
            return False
    # ------------------------------------------------------------------------------------------------------------------

    def clear(self, pgm_name=None, mode=None, pgm_delete=False):
        """
        |   Clears the sequencers memory, or can be used to delete the specified program from memory.
        |   pgm_clear() will unload/de-select the program.

        :param pgm_name:    Name of the program/sequence to be deleted (leave blank or None to unload)
        :type pgm_name:     str
        :param mode:        Operating mode where Program/Sequence is stored. If None, error will be
                            raised
        :type mode:         str
        :param pgm_delete:  switch to confirm program is to be deleted, otherwise it will just be
                            unloaded
        :type pgm_delete:   bool
        """
        # SCPI Commands:
        # W/R   [SOURce:]PROGram[:SELected] ""     # Unload program/sequence
        # W/-   [SOURce:]PROGram:DELete "/<program name>"

        self._eload.write(f'PROGram:SELected ""')  # Unload all programs/sequences
        rtn_mode = self._eload.mode()
        pgm_dict = self.get_programs(rtn_mode)

        if not pgm_delete:
            self._eload.log.warn(f'{yellowText}'
                                 f'Program/Sequence has only been unloaded, not deleted.'
                                 f'{resetText}')
        else:
            if mode is None:
                raise ValueError(f'No Programs/Sequences deleted. User has forgot to specify mode')

            self._eload.mode(mode.upper())
            select_pgm = self._check_program_valid(pgm_name, pgm_dict)
            self._eload.write(f'PROGram:DELete "{select_pgm}"')

        self._eload.log_inst_errors()
    # ------------------------------------------------------------------------------------------------------------------

    def program_ctrl(self, action=None, ):
        """
        |   Method to control the program. If action=None, will return the status of the TRANsient
        |   function, otherwise the options are:
        |       * 'RUN'     - Run the loaded program/sequence
        |       * 'ABORT'   - abort the sequence (will abort all active transients)
        |       * 'SUSP'    - Pause the program/sequence
        |       * 'CONT'    - Continue/resume the program/sequence
        |       * 'WTG'     - WTG for Trigger (this is a status return only)

        :param action:  action to be performed. Options are:

                            * 'RUN'     - Run the loaded program/sequence
                            * 'ABORT'   - abort the sequence
                            * 'SUSP'    - Pause the program/sequence
                            * 'CONT'    - Continue/resume the program/sequence
                            * 'WTG'     - WTG for Trigger (this is a status return only)
        :type action:   str
        :return:        if action None, then returns the status of unit
        :rtype:         dict()
        """
        # SCPI Commands:
        # W/-   INITiate[:IMMediate]:TRANsient:PROGram      # - 'RUN'
        # W/-   TRIGger:TRANsient:SUSPend                   # - 'SUSP'
        # W/-   TRIGger:TRANsient:RESume                    # - 'CONT'
        # W/-   ABORt:ALL                                   # - 'ABORT'
        #    Since PULSE and TRANsient are mutually exclusive, the ABORTS for PULSE and TRANsient appear redundant
        # -/R   TRIGger:TRANsient:EXECution[:STATe]?    {IDLE | WTG | RUN | SUSP | PULS}

        action_dict = {'RUN': f'INITiate:TRANsient:PROGram',
                       'ABORT': f'ABORt:ALL',
                       'SUSP': f'TRIGger:TRANsient:SUSPend',
                       'CONT': f'TRIGger:TRANsient:RESume'}

        if action is None:
            return self.get_status()
            # return self._eload.query(f'TRIGger:TRANsient:EXECution:STATe?').strip().split(',')[0]
        elif action.upper() in list(action_dict.keys()):
            self._eload.write(action_dict[action.upper()])
        else:
            raise ValueError(f'Bad action {action}: valid actions are {list(action_dict.keys())}')
    # ------------------------------------------------------------------------------------------------------------------

    def get_status(self):
        """
        |   Queries status of the program sequence engine.

        :return:    returns dictionary containing 'pgm_num', 'status', 'exec_time', 'step_idx', 'loop_num'.
        :rtype:     dict | str
        """
        # SCPI Commands:
        # -/R   TRIGger:TRANsient:EXECution? {IDLE | PULS | RUN | SUSP | WTG}

        # Return is 'STATUS, step, loop
        tmp = self._eload.query('TRIGger:TRANsient:EXECution?').strip().split(',')

        return {'pgm_name': self._eload.query(f'PROGram:SELected?').strip(), 'status': tmp[0], 'exec_time': 'N/A',
                'step_idx': int(tmp[1]), 'loop_num': int(tmp[2])}
    # ------------------------------------------------------------------------------------------------------------------

    def add_step(self, level=0, slew=None, dwell=None, load=None, transient=None, trig_input=None, trig_output=None,
                 first_step=False):
        """
        |   Method to add/append a step to a program/sequence.
        |       Default is to append, therefore if 'adding' to a newly created program/sequence,
        |   either set 'first_step'=True or use the 'edit_step()' method with step_num=1.

        :param level:       Level to set the input of the Electronic Load to
        :type level:        float
        :param slew:        Slew Ratew for Current (only applicable in 'CC' mode, i.e. 'CURR')
        :type slew:         float
        :param dwell:       Duration time that the step will be executed for
        :type dwell:        float
        :param load:        'OFF' or 'ON'
        :type load:         str
        :param transient:   IMM or RAMP (only relevent if load ='ON'
        :type transient:    str
        :param trig_input:  Define the input triggers for the step. Choose from 'IMM', 'BUS', or
                            combination of 'TRIGIN', 'DIGITAL2', and 'MSYN'
        :type trig_input:   str
        :param trig_output:    Define the trigger outputs for each step. Choose from combination of
                            'TRIGOUT', 'DIGITAL0', 'DIGITAL1', 'DIGITAL3', and 'TAL'
        :type trig_output:     str
        :param first_step:  False or True - Confirm whether editing the first step in Program/Sequence
                            or appending
        :type first_step:   bool
        :return:
        :rtype:
        """
        # SCPI Commands
        # W/R   [SOURce:]PROGram[:SELected]:STEPS:COUNt <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:LEVel <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:SLEWrate <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:DWELl <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:INPut {ON | OFF | 1 | 0}  /  {0 | 1}
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRANsient {IMMediate|RAMP}
        #
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:WAIT <char> [,<char>,<char>,<char>, <char>]
        #           e.g. PROG:STEP1:TRIG:WAIT IMM, BUS, or TRIGIN with/without DIGITAL2 and/or MSYNc
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:GENerate <char> [,<char>,<char>,<char>, <char>]
        #           e.g. PROG:STEP1:TRIG:GEN NONE or a combination of TRIGOUT, DIGITAL0, DIGITAL1, DIGITAL3, TALink

        if first_step:
            current_step = 1
        else:
            # Get current number of steps, then increase number of steps by one.
            current_step = int(self._eload.query(f'PROGram:SELected:STEPS:COUNT?').strip()) + 1
            self._eload.write(f'PROGram:SELected:STEPS:COUNT {current_step}')
            # sleep(0.25)

        self.edit_step(current_step, level, slew, dwell, load, transient, trig_input, trig_output)
        # self.save()  # Program/Sequence saved after each parameter is edited
    # ------------------------------------------------------------------------------------------------------------------

    def edit_step(self, step_num, level=None, slew=None, dwell=None, load=None, transient=None,
                  trig_input=None, trig_output=None):
        """
        |   Method to edit all the step parameters in a program/sequence. Note that changes are not
        |   saved at end of this method.

        :param step_num:    Number of step to be edited
        :type step_num:     int
        :param level:       Level to set the input of the Electronic Load to
        :type level:        float
        :param slew:        Slew Ratew for Current (only applicable in 'CC' mode, i.e. 'CURR')
        :type slew:         float
        :param dwell:       Duration time that the step will be executed for
        :type dwell:        float
        :param load:        'OFF' or 'ON'   - this refers to the state if the INPUT ('load' on
                            sequencer panel)
        :type load:         str
        :param transient:   IMM or RAMP (only relevent if load ='ON')
        :type transient:    str
        :param trig_input:  Define the input triggers for the step. Choose from 'IMM', 'BUS', or
                            combination of 'TRIGIN', 'DIGITAL2', and 'MSYN'
        :type trig_input:   str
        :param trig_output: Define the trigger outputs for each step. Choose from combination of
                            'TRIGOUT', 'DIGITAL0', 'DIGITAL1', 'DIGITAL3', and 'TAL'
        :type trig_output:  str
        :return:
        :rtype:
        """
        # SCPI Commands
        # W/R   [SOURce:]PROGram[:SELected]:STEPS:COUNt <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:LEVel <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:SLEWrate <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:DWELl <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:INPut {ON | OFF | 1 | 0}  /  {0 | 1}
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRANsient {IMMediate|RAMP}
        #
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:WAIT <char> [,<char>,<char>,<char>, <char>]
        #           e.g. PROG:STEP1:TRIG:WAIT IMM, BUS, or TRIGIN with/without DIGITAL2 and/or MSYNc
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:GENerate <char> [,<char>,<char>,<char>, <char>]
        #           e.g. PROG:STEP1:TRIG:GEN NONE or a combination of TRIGOUT, DIGITAL0, DIGITAL1, DIGITAL3, TALink

        if not step_num:
            raise ValueError(f'No step number has been entered')
        else:
            # Get current number of steps, and then check if step_num is valid
            num_steps = int(self._eload.query(f'PROGram:SELected:STEPS:COUNT?').strip())
            if not (0 < int(step_num) <= num_steps):
                raise ValueError(f'Bad step_num {{{step_num}}}: Valid range is 1 to {num_steps}')

        # Get mode/param and range, in order to get the 'ratings'
        current_mode = self._eload.mode()
        current_param = self._eload._std_mode_dict[current_mode.upper()]
        current_range = self._eload.range(current_param)
        min_val, max_val, _ = self._eload.ratings(current_param, current_range)
        min_slew, max_slew, _ = self._eload.ratings('SLEW', current_range)  # only applicable in 'CC' mode

        # use previously written helper function for this section?????
        if level is not None:
            self.edit_step_param(step_num=step_num, step_param='level', value=level)

        if slew is not None and current_mode == 'CC':
            self.edit_step_param(step_num=step_num, step_param='slew', value=slew)

        if dwell is not None:
            self.edit_step_param(step_num=step_num, step_param='dwell', value=dwell)

        if load is not None:
            self.edit_step_param(step_num=step_num, step_param='load', value=load)

        if transient is not None:
            self.edit_step_param(step_num=step_num, step_param='transient', value=transient)

        if trig_input is not None:
            self.edit_step_param(step_num=step_num, step_param='trig_input', value=trig_input)

        if trig_output is not None:
            self.edit_step_param(step_num=step_num, step_param='trig_output', value=trig_output)
    # ------------------------------------------------------------------------------------------------------------------

    def edit_step_param(self, step_num, step_param, value):
        """
        |   Method to edit each of the step parameters in a program/sequence. Note that
        |   program/sequence will be saved after each parameter is edited.

        :param step_num:    Number of step to be edited
        :type step_num:     int
        :param step_param:  parameter to be edited, i.e. ['level', 'slew', 'dwell', 'load',
                            'transient', 'trig_input', 'trig_output']
        :type step_param:   str
        :param value:       value to be entered for the parameter - data dependent on parameter
        :type value:        any - dependent on parameter
        :return:
        :rtype:
        """
        # SCPI Commands
        # W/R   [SOURce:]PROGram[:SELected]:STEPS:COUNt <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:LEVel <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:SLEWrate <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:DWELl <numeric>
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:INPut {ON | OFF | 1 | 0}  /  {0 | 1}
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRANsient {IMMediate|RAMP}
        #
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:WAIT <char> [,<char>,<char>,<char>, <char>]
        #           e.g. PROG:STEP1:TRIG:WAIT IMM, BUS, or TRIGIN with/without DIGITAL2 and/or MSYNc
        # W/R   [SOURce:]PROGram[:SELected]:STEP<n>:TRIGger:GENerate <char> [,<char>,<char>,<char>, <char>]
        #           e.g. PROG:STEP1:TRIG:GEN NONE or a combination of TRIGOUT, DIGITAL0, DIGITAL1, DIGITAL2, TALink

        if not step_num or not step_param or not value:
            raise ValueError(f'Missing parameter to method/function')
        else:
            # Get current number of steps, and then check if step_num is valid
            num_steps = int(self._eload.query(f'PROGram:SELected:STEPS:COUNT?').strip())
            if not (0 < int(step_num) <= num_steps):
                raise ValueError(f'Bad step_num {{{step_num}}}: Valid range is 1 to {num_steps}')

        if step_param not in ['level', 'slew', 'dwell', 'load', 'transient', 'trig_input', 'trig_output']:
            raise ValueError(f"Bad step_param {{{step_param}}}: should be one of ['level', 'slew', 'dwell', 'load', "
                             f"'transient', 'trig_input','trig_output']")

        # Get mode/param and range, in order to get the 'ratings'
        current_mode = self._eload.mode()
        current_param = self._eload._std_mode_dict[current_mode.upper()]
        current_range = self._eload.range(current_param)
        min_val, max_val, _ = self._eload.ratings(current_param, current_range)
        min_slew, max_slew, _ = self._eload.ratings('SLEW', current_range)  # only applicable in 'CC' mode

        if step_param.strip().lower() in 'level':
            if float(min_val) <= float(value) <= float(max_val):
                self._eload.write(f'PROGram:SELected:STEP{step_num}:LEVel {float(value)}')
            else:
                raise ValueError(f'Bad Level {{{value}}}: should be in range {min_val} to {max_val}')
        elif step_param.strip().lower() in 'slew':
            if current_mode == 'CC' and (float(min_slew) <= float(value) <= float(max_slew)):
                self._eload.write(f'PROGram:SELected:STEP{step_num}:SLEWrate {float(value)}')
            elif current_mode == 'CC':
                raise ValueError(f'Bad Slew {{{value}}}: should be in range {min_slew} to {max_slew}')
            else:
                self._eload.log.warn(f'No changes made - Slew not applicable in current operating mode '
                                     f'\'{current_mode}\'')
        elif step_param.strip().lower() in 'dwell':
            if 25.0e-6 <= float(value) <= 3.6e6:
                self._eload.write(f'PROGram:SELected:STEP{step_num}:DWELl {float(value)}')
            else:
                raise ValueError(f'Bad dwell {{{value}}}: should be in range {25.0e-6} to {3.6e6}')
        elif step_param.strip().lower() in 'load':
            if str(value).upper() in ['OFF', 'ON', '0', '1']:
                self._eload.write(f'PROGram:SELected:STEP{step_num}:INPut {str(value)}')
            else:
                raise ValueError(f'Bad load {{{value}}}: acceptable values are '
                                 f'{["OFF", "ON", "0", "1"]}')
        elif step_param.strip().lower() in 'transient':
            if str(value).upper() in ['IMM', 'RAMP', 'IMMEDIATE']:
                self._eload.write(f'PROGram:SELected:STEP{step_num}:TRANsient {str(value)}')
            else:
                raise ValueError(f'Bad transient {{{value}}}: acceptable values are \'IMM\' or \'RAMP\'')
        elif step_param.strip().lower() in 'trig_input':
            tmp_list = str(value).upper().replace('"', '').replace(' ', '').split(',')
            valid_list = ['IMM', 'BUS', 'TRIGIN', 'DIGITAL2', 'MSYN']
            if len([elem for elem in tmp_list if elem not in set(valid_list)]) == 0:
                # minor issue - using the write method from instrument class causes issues when certain values passed in
                # e.g. DIGITAL2 - combos appear to work
                self._eload.write(f'PROGram:SELected:STEP{step_num}:TRIGger:WAIT {str(value)}')
            else:
                raise ValueError(f'Bad trig_input {{{value}}}: acceptable values are '
                                 f'{valid_list}')
        elif step_param.strip().lower() in 'trig_output':
            tmp_list = str(value).upper().replace('"', '').replace(' ', '').split(',')
            valid_list = ['NONE', 'TRIGOUT', 'DIGITAL0', 'DIGITAL1', 'DIGITAL2', 'TAL']
            if len([elem for elem in tmp_list if elem not in set(valid_list)]) == 0:
                # minor issue - using the write method from instrument class causes issues when certain values passed in
                # e.g. TRIGOUT only, DIGITAL0 (or 1, 2) only - combos appear to work
                self._eload.write(f'PROGram:SELected:STEP{step_num}:TRIGger:GENerate {str(value).upper()}')
            else:
                raise ValueError(f'Bad trig_out {{{value}}}: acceptable values are '
                                 f'{valid_list}')

        self.save()
    # ------------------------------------------------------------------------------------------------------------------

    # Is there any benefit in this method being added (also, should an insert_step also be added).
    # If Program/Sequence being generated by code, would be reasonable for user to make change in
    # their code rather than making changes to an existing Program/Sequence loaded onto the unit.
    def _delete_step(self, step_num):
        """
        |   Method to delete a step from a Program/Sequence. This can be done on front panel, but
        |   there is no SCPI command from this, therefore has to be coded in.

        :param step_num: step number to be deleted from the sequence
        :type step_num:  int
        :return:
        :rtype:
        """

        pgm_mode, pgm_name = self.load()
        pgm_info = self.get_program_info(pgm_name)
        pgm_steps = pgm_info['steps']

        # can use pgm_steps.pop(step_num) to remove the step, but need to update the step number in the 'listing'
        pgm_steps.pop(step_num)  # remove targeted step
        pgm_info['num_steps'] = int(pgm_info['num_steps']) - 1  # update number of steps
        for idx in range(0, len(pgm_steps)-step_num):  # following lines have been split to fit nicely within 80 chars
            comma_pos = pgm_steps[step_num+idx].find(',')  # find the first comma
            new_step_num = pgm_steps[step_num+idx][:comma_pos].replace(f'{step_num+idx+1}', f'{step_num+idx}')
            pgm_steps[step_num+idx] = f"{new_step_num}{pgm_steps[step_num+idx][comma_pos:]}"

        return pgm_info


class Arbitrary(object):
    """
    |   Class for the Arb feature, to implement the methods required
    """

    def __init__(self, instr, *args, **kwargs):
        """
        Pass in the object for the instrument to be extracted for functionality

        :param instr:   Base object for the instrument
        """

        self._eload = instr
    # ------------------------------------------------------------------------------------------------------------------

    def clear(self):
        """
        |   Revert the '**mapped**' VI Characteristics to default.
        |       (0.0, 0.0), (1.0, 0.0), (157.5, 0.0)    - 3 x Voltage, Current pairs, shown as tuples

        :return:
        :rtype:
        """
        # SCPI Commands
        # W/-   [SOURce:]ARBitrary[:LEVel][:IMMediate]:CLEar

        self._eload.write(f'ARBitrary:LEVel:IMMediate:CLEar')
    # ------------------------------------------------------------------------------------------------------------------

    def apply(self):
        """
        |   Apply the '**mapped**' I-V Characteristics to to the output.

        :return:
        :rtype:
        """
        # SCPI Commands
        # W/-   [SOURce:]ARBitrary[:LEVel][:IMMediate]:APPLy

        self._eload.write(f'ARBitrary:LEVel:IMMediate:APPLy')
    # ------------------------------------------------------------------------------------------------------------------

    def count(self, num_pts=None):
        """
        |   Query or set the number of '**mapped**' points in the I-V Characteristics.

        :param num_pts: number of pts to be mapped
        :type num_pts:  int
        :return:        None | number of points mapped in the I-V Characteristics
        :rtype:         None | int
        """
        # SCPI Commands
        # W/R   [SOURce:]ARBitrary[:LEVel][:IMMediate]:COUNt <numeric>

        if num_pts is None:
            return self._eload.query(f'ARBitrary:LEVel:IMMediate:COUNt?').strip()

        self._eload.write(f'ARBitrary:LEVel:IMMediate:COUNt {num_pts}')
    # ------------------------------------------------------------------------------------------------------------------

    def map(self, index=2, volt=None, curr=None):
        """
        |   Set or query the specified point in the I-V Characteristic map.
        |       **Note** that the 1st point cannot be changed.

        :param index:   index of amp to be set/queried. Cannot be 1.
        :type index:    int
        :param volt:    voltage element of I-V Characteristic
        :type volt:     float
        :param curr:    current element of I-V Characteristic
        :type curr:     float
        :return:        None | tuple of three element, i.e. (index, voltage, current)
        :rtype:         None | tuple
        """
        # SCPI Commands
        # W/R   [SOURce:]ARBitrary[:LEVel][:IMMediate]:MAP <index>,{<voltage> | MINimum | MAXimum },
        #                                                  {<current> | MINimum | MAXimum }

        if index < 1:
            raise ValueError(f"Bad index {{{index}}}: should be in range 2 to number of points "
                             f"specified (max number of points is 100)")

        if volt is None and curr is None:
            rtn = self._eload.rm_handle.query(f'ARBitrary:LEVel:IMMediate:MAP? {index}').strip().split(',')
            return index, rtn[0], rtn[1]
        elif volt is None and curr is not None:
            raise ValueError(f"Bad curr {{{curr}}}: should be a float")
        elif volt is not None and curr is None:
            raise ValueError(f"Bad volt {{{volt}}}: should be a float")

        self._eload.write(f'ARBitrary:LEVel:IMMediate:MAP {int(index)}, {float(volt)}, {float(curr)}')
        sleep(0.25)
    # ------------------------------------------------------------------------------------------------------------------

    def list(self, mapping=None):
        """
        |   Method to set/query an I-V Characteristics map. The mapping should be entered as a list of
        |   tuples, i.e. [(1, 0.0, 0.0), (index+1, voltage, current), ...]
        |       Minimum list size is 3, and maximum is 100.
        |
        |   The number of points will be determined from the size of the list entered.
        |
        |   This method will apply the new mapping to the output.

        :param mapping: List of tuples, with each tuple consisting (index, voltage, current). The list
                        must be of size (3 <= size <= 100).
        :type mapping:  list
        :return:        None | List of tuples, with each tuple consisting (index, voltage, current).
        :rtype:         None | list
        """
        # SCPI Commands
        # W/R   [SOURce:]ARBitrary[:LEVel][:IMMediate]:COUNt <numeric>
        # W/R   [SOURce:]ARBitrary[:LEVel][:IMMediate]:MAP <index>,{<voltage> | MINimum | MAXimum },
        #                                                  {<current> | MINimum | MAXimum }
        # -/R   [SOURce:]ARBitrary[:LEVel][:IMMediate]:MAP:LIST?

        if mapping is None:
            rtn = self._eload.query(f'ARBitrary:LEVel:IMMediate:MAP:LIST?').strip().split(',')

            rtn_list = []
            for idx in range(0, int(len(rtn)/2)):
                rtn_list.append((idx+1, rtn[2*idx], rtn[(2*idx)+1]))

            return rtn_list

        if type(mapping) is not list:
            raise ValueError(f"Bad mapping {{{mapping}}}: should be a list of tuples in the following"
                             f"format [(index, voltage, current), (index+1, voltage, current), ...]")

        num_points = len(mapping)
        self.count(num_points)

        for idx, item in enumerate(mapping):
            if type(item) is not tuple and len(item) != 3:
                raise ValueError(f"Bad index, voltage, current {{{item}}}: should be a tuples in the"
                                 f" following format (index, voltage, current)")
            elif idx > 0:
                self.map(index=int(item[0]), volt=item[1], curr=item[2])

        self.apply()

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
