# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# # -*- coding: utf-8 -*-
# Inherit from the instrument class
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
# Include Other Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
# Include Python libraries
from time import sleep
import numpy as np
import os
from enum import Enum
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# TODO: Support for triggered level changes.
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class PLZ004WL_base(InstrumentVisa):
    """Class for controlling Kikusui Electronic Loads."""
    # these are variable definitions that get assigned in the derived class.
    _ratings = dict()
    _rating_curr_max = None
    _rating_pow_max = None

    cfg_max_disp_list_errors = 10

    # New enumerations of the dictionaries above. separated as to not break code and cleanup implementation
    enum_pgm_norm_modes = Enum("enum_pgm_norm_modes", ('NCC', 'NCR', 'NCV', 'NCP'))
    enum_pgm_fast_modes = Enum("enum_pgm_fast_modes", ('FCC', 'FCR'))
    enum_curr_range = Enum("enum_curr_range", {'L': 'LOW', 'M': 'MED', 'H': 'HIGH'})
    enum_volt_range = Enum("enum_volt_range", {'L': 'LOW', 'H': 'HIGH'})
    enum_pgm_status = Enum("enum_pgm_status", ('TRUN', 'RUN', 'STOP', 'PAUS', 'CONT'))

    # enumerations of existing method dictionaries
    enum_ratings_param = Enum('enum_ratings_param', ['COND', 'CURR', 'VOLT', 'POW', 'SLEW'])
    enum_range_param = Enum('enum_range_param', ['COND', 'CURR', 'VOLT', 'POW'])
    enum_meas_param = Enum('enum_meas_param', ['POW', 'CURR', 'VOLT'])
    enum_level_param = enum_range_param  # aliases of the parameter lists
    enum_mode_list = Enum('enum_mode_list', ['CC', 'CV', 'CP', 'CR', 'CCCV', 'CRCV'])
    enum_dynamics_response = Enum("enum_dynamics_response", ['NORM', 'FAST'])
    enum_opp_action = Enum('enum_opp_action', ['LIM', 'TRIP'])
    enum_ocp_action = enum_opp_action  # aliases of the parameter lists

    enum_status_regs = Enum("enum_status_regs",
                            {'OPER': {'Calibrating': 0, 'Waiting for TRIG': 5},
                             'CSUM': {'CC': 0, 'CV': 1, 'CR': 2, 'CP': 3, 'PRUN': 8},
                             'QUES': {'Over Voltage': 0, 'Over Current': 1, 'Over Power': 3, 'Over Temp': 4,
                                      'Under Voltage': 9, 'External Problem': 10, 'Reverse Voltage': 11}}
                            )

    def __init__(self, visa_resource_name, logger=None, **kwargs):

        super().__init__(visa_resource_name, logger, **kwargs)

        # reset the machine, was in the legacy code
        self.reset()

        # Enabling these to allow propagation to the status byte.
        self.write(f'STAT:OPER:ENAB {0x21}')  # Only bits 0 and 5 are used.
        self.write(f'STAT:CSUM:ENAB {0x10F}')  # Only bits 0-3 and 8 are used.
        self.write(f'STAT:QUES:ENAB {0xE1B}')  # Only bits 0,1,3,4,9-11 are used.

    def ratings(self, param, range_val=None):
        """
        If range is specified, Returns a tuple consisting of minval, maxval and units for the
        specified parameter and range. If range is None, returns a dictionary.

        :param param: Electrical parameter controlled by the Load.

                * 'COND' - Conductance
                * 'CURR' - Current
                * 'POW'  - Power
                * 'VOLT' - Voltage
                * 'SLEW' - Slew
        :type param: str | enum_ratings_param
        :param range_val:  range setting for the parameter.

                * 'L': low
                * 'M': medium, Not valid when param is 'VOLT'.
                * 'H': high
                *  None: Returns the self._ratings sub-dictionary for the specified parameter.
        :type range_val: str
        :return: Read Back current parameters if the method is called empty.
        :rtype: dict | None
        """
        # check if the parameter exists
        param_obj = check_enum_str('param', param, self.enum_ratings_param)

        if range_val is not None:
            min_val, max_val = self._ratings[param_obj.name][range_val.upper()]
            units = self._ratings[param_obj.name]['units']
            return min_val, max_val, units
        else:
            return self._ratings[param_obj.name]

    def mode(self, mode=None):
        """
        Queries or writes operating mode of the Electronic load.

        :param mode:
                * None   - Queries instrument, returns one of the following strings:
                * 'CC'   - sets Constant Current mode.
                * 'CV'   - sets Constant Voltage mode.
                * 'CP'   - sets Constant Power mode.
                * 'CR'   - sets Constant Resistance mode.
                * 'CCCV' - sets Constant Current with Constant Voltage mode.
                * 'CRCV' - sets Constant Resistance with Constant Voltage mode.
        :type mode: str | enum_mode_list
        :return: Read Back current parameters if the method is called empty.
        :rtype: str | None
        """

        # TODO: Disallow changing modes if switching is active.
        self.log_inst_errors()
        if mode is None:
            rslt = self.query('FUNC?')
            return rslt.rstrip()

        # if mode is not none, check if it is in the enum
        mode_obj = check_enum_str('mode', mode, self.enum_mode_list)
        if self.state() == 'ON':
            raise ValueError("Cannot program mode while load state is ON.")  # Or you get error 24.
        self.write('FUNC ' + mode_obj.name)
        self.log_inst_errors()

    def state(self, state=None):
        """
        Queries or writes the state of the Electronic Load input terminals.

        :param state:
            * None   - Queries instrument, returns one of the following strings:
            * 'ON'   - Load terminals are connected to the DUT.
            * 'OFF'  - Load terminals are disconnected from the DUT.
        :type state: str
        :return: Read Back current parameters if the method is called empty.
        :rtype: str | None
        """
        if state is None:
            return self.on_off.to_api(self.query('INP:STAT:IMM?').strip())

        self.write('INP:STAT:IMM', self.on_off.to_inst(state))

    def range(self, param, range_val=None):
        """
        Queries or writes the range for the specified parameter.

        :param param: Electrical parameter controlled by the Load.

                * 'COND' - Conductance
                * 'CURR' - Current
                * 'POW'  - Power
                * 'VOLT' - Voltage
        :type param:  str | enum_range_param
        :param range_val:
                * None   - Queries instrument, returns one of the following strings:
                * 'L'    - Low range, valid for all param.
                * 'M'    - Medium range, not valid for VOLT param.
                * 'H'    - High range, valid for all param.

        :type range_val: str
        :return: Read Back current parameters if the method is called empty.
        :rtype: str | dict | None
        """
        param_obj = check_enum_str('param', param, self.enum_range_param)
        if param_obj.name == 'VOLT':
            enum_chosen = self.enum_volt_range  # write_dict = {'L': 'LOW', 'H': 'HIGH'}
        else:
            enum_chosen = self.enum_curr_range  # write_dict = {'L': 'LOW', 'M': 'MED', 'H': 'HIGH'}

        if range_val is None:  # echo back range of given parameter
            return self.query(param_obj.name + ':RANG?', enum_chosen).name

        error_template = "Bad {name} '{value}' for" + f" '{param_obj.name}'. " + "Should be one of {cls_name}: {keys}."

        for key in enum_chosen.__members__.keys():
            minval, maxval, units = self.ratings(param_obj.name, key)
            error_template += f"\n   '{key}': {minval} to {maxval} {units}"

        range_val_obj = check_enum_str("range_val", range_val, enum_chosen, error_template)
        self.write(param_obj.name + ':RANG ' + range_val_obj.value)

        self.log_inst_errors()

    def level(self, param, level=None):
        """
        Queries or writes the level for the specified parameter.

        :param param: Electrical parameter controlled by the Load.

                * 'COND' - Conductance
                * 'CURR' - Current
                * 'POW'  - Power
                * 'VOLT' - Voltage
        :type param: str | enum_level_param
        :param level:
                * None   - Queries from instrument the present level setting for param.
                * 'MIN'  - Minimum level of the range presently in effect for param.
                * 'MAX'  - Maximum level of the range presently in effect for param.
                * <numeric> - Sets level of param. Units are Seimens, Amps, Watts, or Volts.
        :type level: str | int | float
        :return: Read Back current parameters if the method is called empty.
        :rtype: dict | None
        """
        param_obj = check_enum_str('param', param, self.enum_level_param)

        if level is None:
            return float(self.query(param_obj.name + '?'))

        # If we got here, we are writing to the instrument.
        min_val, max_val, units = self.ratings(param_obj.name, self.range(param_obj.name))
        if type(level) in (int, float):
            if level < min_val or level > max_val:  # not(min_val <= level <= max_val)
                raise ValueError(f"Bad level {level} for {param_obj.name}, should be {min_val} to {max_val} {units}.")
            self.write(param_obj.name + ' ' + str(level))
        elif level in ('MIN', 'MAX'):
            self.write(param_obj.name + ' ' + level)
        else:
            raise ValueError(f"Bad level '{level}' for {param_obj.name}. Should be one of: "
                             f"{min_val} to {max_val} {units}, 'MIN' or 'MAX'.")

        self.log_inst_errors()

    def meas(self, param):
        """
        Queries measured level of the specified parameter.

        :param param: Electrical parameter controlled by the Load.

                * 'CURR' - measured Current (Amps)
                * 'POW'  - measured Power   (Watts)
                * 'VOLT' - measured Voltage (Volts)
        :type param: str | enum_meas_param
        :return: Read Back current parameters
        :rtype: float
        """
        param_obj = check_enum_str('param', param, self.enum_meas_param)
        rslt = self.query('MEAS:' + param_obj.name + '?')
        return float(rslt.rstrip())

    def regulate(self, desired_value, tolerance=0.1, max_iterations=10, delay=0.5):
        """
        Alters the level setting of the parameter controlled by the present mode
        to achieve a measured level equal to desired_value.

        :param desired_value: Target measured level for parameter.
        :type desired_value: float
        :param tolerance: Value is considered to have hit the target when
                             measured level falls within +/- tolerance percent
                             of the desired_value.
        :type tolerance: float
        :param max_iterations: Upper limit on number of adjustments to level
                             setting before giving up on achieving the
                             desired_value +/- tolerance percent. If 0, then no
                             adjustments are made to present level setting.
        :type max_iterations: int
        :param delay: Settling time between level change and measurement.
        :type delay: float
        :return: True/False if measured level is within +/- tolerance percent of desired_value.
        :rtype: bool
        """
        param = {'CC': 'CURR', 'CV': 'VOLT', 'CP': 'POW', 'CR': 'COND', 'CCCV': 'CURR', 'CRCV': 'COND'}[self.mode()]

        self.level(param, desired_value)
        self.state('ON')

        sleep(delay)
        delta = self.meas(param) - desired_value
        error_percent = 100 * abs(delta / desired_value)

        iteration = 0
        while iteration < max_iterations:
            if error_percent <= tolerance:
                print('Regulated level is within %4.3f%% of desired after %d iterations.' % (error_percent, iteration))
                return True

            self.level(param, desired_value - delta)

            iteration += 1
            print('iter = %d' % iteration)

            sleep(delay)
            delta = self.meas(param) - desired_value
            error_percent = 100 * abs(delta / desired_value)

        # If we got here, either regulation failed or user put in max_iterations=0.
        print('After %d iterations, level is within %4.3f%% of desired.' % (iteration, error_percent))
        if error_percent > tolerance:
            return False
        else:
            return True

    def switching(self, state=None, level_low=None, percent=None, freq=None, period=None, duty_cycle=None):
        """
        Configures switching between two load currents in CC or CR mode. Attempting to use this in other modes throws
        an exception.

        The higher of the two currents corresponds to the current or conductance set using the level method.
        The lower of the two currents corresponds to the current or conductance set here through the level_low
        parameter or the percent parameter.

        If operating in CC mode, this affects the load current and level_low is interpreted as amps.
        If operating in CR mode, this affects the load conductance and level_low is is interpreted as Siemens.

        :param state: 'ON' or 'OFF'. Enables/Disables toggling between the two load currents. Current in OFF state
                    corresponds to the high level or 100% of the level set by the level method.
        :type state: str
        :param level_low: The current or conductance corresponding to the low level of the resulting waveform.
                       Setting this equal to or greater than the high level defined by the level method just gives a
                       waveform that is constant at the high level.
        :type level_low: str
        :param percent:
                       The low level of the wave form expressed as a percentage of the high level. The high level is
                       the level set through the level method. Percent ranges from 0 to 100. A level of 100 just gives a
                       waveform that is constant at the high level.
                       **NOTE:**  If both level_low and percent are specified, the percent level takes precedence.
        :type percent: float
        :param freq: The number of high/low cycles per second, the reciprocal of period.
        :type freq: float
        :param period: Time interval (in sec) for one high/low cycle. The reciprocal of freq.
                **NOTE:**  If both freq and period are specified, the period level takes precedence.
        :type period: float
        :param duty_cycle: The percentage of each high / low cycle time (period) at the high level.
        :type duty_cycle:
        :return: Read Back current parameters if the method is called empty.
        :rtype: dict | None
        """
        # SCPI Commands:
        # [SOURce:]PULSe[:STATe] {ON | OFF | 1 | 0}
        # [SOURce:]PULSe: LEVel[:VALue]:CONDuctance { < numeric > | MINimum | MAXimum}
        # [SOURce:]PULSe: LEVel:PERCentage: CONDuctance [SOURce:]PULSe: LEVel:PERCentage: CONDuctance
        # [SOURce:]PULSe: LEVel[:VALue]:CURRent { < numeric > | MINimum | MAXimum}
        # [SOURce:]PULSe: LEVel:PERCentage: CURRent { < numeric > | MINimum | MAXimum}
        # [SOURce:]PULSe: FREQuency { < numeric > | MINimum | MAXimum}
        # [SOURce:]PULSe: PERiod  { < numeric > | MINimum | MAXimum}
        # [SOURce:]PULSe: DCYCle { < numeric > | MINimum | MAXimum}

        mode = self.mode()
        param = {'CC': 'CURR', 'CR': 'COND'}.get(mode)

        if param is None:
            # Attempting to program these parameters in other modes would cause error 27.
            raise ValueError(f"Cannot set switching parameters in {mode}, only in modes 'CC' and 'CR'.")

        if all(v is None for v in {state, level_low, percent, freq, period, duty_cycle}):
            return_val = dict()
            tmp = self.query('PULS?')
            return_val.update(state=self.on_off.to_api(int(tmp)))
            return_val.update(level=float(self.query(f'PULS:LEV:{param}?')))
            return_val.update(percent=float(self.query(f'PULS:LEV:PERC:{param}?')))
            return_val.update(freq=float(self.query('PULS:FREQ?')))
            return_val.update(period=float(self.query('PULS:PER?')))
            return_val.update(duty=float(self.query('PULS:DCYC?')))
            return return_val

        # Out of bound values for other parameters don't cause errors, they just cause the setting to go to one of
        # it extreme values.

        if percent is not None and (percent < 0.0 or percent > 100.0):
            raise ValueError(f"Bad percent {percent}, should be 0 to 100.")

        if freq is not None and (freq < 1.0 or freq > 50e3):
            raise ValueError(f"Bad freq {freq}, should be 1 to 50,000 Hz.")

        if period is not None and (period < 1.0 or period > 1/50e3):
            raise ValueError(f"Bad period {period}, should be 1 to {1/50e3} sec.")

        if duty_cycle is not None and (duty_cycle < 5.0 or duty_cycle > 95):
            raise ValueError(f"Bad duty {duty_cycle}, should be 5 to 95 percent.")

        # Now write the data.
        if state is not None:  # also checks if the state param is valid. Needs to be first.
            self.write(f'PULS', self.on_off.to_inst(state))

        if level_low is not None and percent is None:
            self.write(f'PULS:LEV:{param} {level_low}')

        if percent is not None:
            self.write(f'PULS:LEV:PERC:{param} {percent}')

        if freq is not None and period is None:
            self.write(f'PULS:FREQ {freq}')

        if period is not None:
            self.write(f'PULS:PER {period}')

        if duty_cycle is not None:
            self.write(f'PULS:DCYC {duty_cycle}')

        self.log_inst_errors()

    def dynamics(self, cc_slew=None, cv_response=None, cr_response=None):
        """
        Queries or sets current slew rate and/or transient response speeds for CV and CR mode.

        :param cc_slew: Slew rate in Amps/uSec. Numeric value within the present current range
        :type cc_slew: int | float
        :param cv_response: "NORM" or "FAST"
        :type cv_response: str | enum_dynamics_response
        :param cr_response: "NORM" or "FAST"
        :type cr_response: str | enum_dynamics_response
        :return: Read Back current parameters if the method is called empty.
        :rtype: dict | None
        """

        # SCPI Commands:
        # [SOURce:]CURRent:SLEW {<numeric>|MINimum|MAXimum}
        # [SOURce:]FUNCtion:RESPonse:CV {NORMal|FAST}
        # [SOURce:]FUNCtion:RESPonse:CR {NORMal|FAST}

        if all(v is None for v in {cc_slew, cv_response, cr_response}):
            return_val = dict()
            return_val.update(cc_slew=float(self.query('CURR:SLEW?')))
            return_val.update(cv_response=self.query('FUNC:RESP:CV?').strip())
            return_val.update(cr_response=self.query('FUNC:RESP:CR?').strip())
            return return_val

        if cc_slew is not None:
            curr_range = self.range("CURR")
            min_val, max_val, units = self.ratings('SLEW', curr_range)
            if type(cc_slew) not in (int, float) or cc_slew < min_val or cc_slew > max_val:
                raise ValueError(
                    f"Bad cc_slew {cc_slew} for {curr_range} current range, should be {min_val} to {max_val} {units}.")

        # legal_responses = ('NORM', 'FAST')
        cv_resp_obj = check_enum_str('cv_response', cv_response, self.enum_dynamics_response)
        cr_resp_obj = check_enum_str('cr_response', cr_response, self.enum_dynamics_response)

        if cc_slew is not None:
            self.write(f'CURR:SLEW {cc_slew}')

        if cv_response is not None:
            self.write(f'FUNC:RESP:CV {cv_resp_obj.name}')

        if cr_response is not None:
            self.write(f'FUNC:RESP:CR {cr_resp_obj.name}')

        self.log_inst_errors()

    def ocp_value(self, ilimit=None, action=None):
        """
        Queries or sets Over Current Protection parameters.

        :param ilimit: When load current exceeds this number of Amps, the OCP either limits the current or changes the
                    state of the load to 'OFF'.
        :type ilimit: float
        :param action: Defines what the load does when the OCP ilimit is reached.

                * 'LIM'   - Current still flows but is prevented from exceeding the level set by ilimit.
                * 'TRIP'  - The state of the load is swicthed to 'OFF'.
        :type action: str | enum_ocp_action
        :return: Read Back current parameters if the method is called empty.
        :rtype: dict | None
        """

        # SCPI Commands:
        # [SOURce:]CURRent:PROTection[:LEVel][:OVER] {<value>|MINimum|MAXimum}
        # [SOURce:]CURRent:PROTection:ACTion {LIMit|TRIP}

        if all(v is None for v in {ilimit, action}):
            return_val = dict()
            return_val.update(ilimit=float(self.query('CURR:PROT?')))
            return_val.update(action=self.query('CURR:PROT:ACT?').strip())
            return return_val

        if ilimit is not None:
            if ilimit < 0 or ilimit > self._rating_curr_max:
                raise ValueError(f"Bad ilimit {ilimit}, should be 0 to {self._rating_curr_max} Amps.")

        action_obj = check_enum_str('action', action, self.enum_ocp_action)  # legal_actions = ('LIM', 'TRIP')

        if ilimit is not None:
            self.write(f'CURR:PROT {ilimit}')

        if action is not None:
            self.write(f'CURR:PROT:ACT {action_obj.name}')

        self.log_inst_errors()

    def ocp_clear(self):
        """
        Writes command to clear Over Current Protection trip.

        If the OCP action is set to 'TRIP', the load state is changed to 'OFF' by OCP current through the load exceeding
        the set level. Note that after clearing the trip state, the output will remain off until reactivated using the
        state method.
        """

        # SCPI Command: INPut:PROTection:CLEar
        self.write('INP:PROT:CLE')

    def opp_value(self, plimit=None, action=None):
        """
        Queries or sets Over Power Protection parameters.

        :param plimit: When load power exceeds this number of Watts, the OPP either limits the power or changes
                       the state of the load to 'OFF'.
        :type plimit: float
        :param action: Defines what the load does when the OPP plimit is reached.

                    * 'LIM': Current still flows but power is prevented from exceeding the level set by plimit.
                    * 'TRIP': The state of the load is switched to 'OFF'.
        :type action: str | enum_opp_action
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | None
        """

        # SCPI Commands:
        # [SOURce:]POWer:PROTection[:LEVel][:OVER] {<value>|MINimum|MAXimum}
        # [SOURce:]POWer:PROTection:ACTion?

        if all(v is None for v in {plimit, action}):
            return_val = dict()
            return_val.update(plimit=float(self.query('POW:PROT?')))
            return_val.update(action=self.query('POW:PROT:ACT?').strip())
            return return_val

        if plimit is not None:
            if plimit < 0 or plimit > self._rating_pow_max:
                raise ValueError(
                    f"Bad plimit {plimit}, should be 0 to {self._rating_pow_max}.")

        action_obj = check_enum_str('action', action, self.enum_opp_action)  # legal_actions = ('LIM', 'TRIP')

        if plimit is not None:
            self.write(f'POW:PROT {plimit}')

        if action is not None:
            self.write(f'POW:PROT:ACT {action_obj.name}')

        self.log_inst_errors()

    def opp_clear(self):
        """
        Writes command to clear Over Current Protection trip.

        If the OCP action is set to 'TRIP', the load state is
        changed to 'OFF' by OCP current through the load  the set level. Note that after clearing the trip state,
        the output will remain off until reactivated using the state method.
        """
        # SCPI Command: INPut:PROTection:CLEar
        self.write('INP:PROT:CLE')

    def status_reg_bits(self, regname):
        """
        Queries OPER or QUES status register and returns dictionary showing name-values of bits.

        Note that mode changes don't show up in the CSUM bits until the load state is switched back 'ON'.
        :param regname:  'OPER', 'CSUM' or 'QUES'. Not case sensitive.
        :type regname:  str
        :return: values of the selected status register
        :rtype: dict
        """
        # the enum has a second dictionary of conditions embedded as the value of the first dictionary.
        # The reg name acts as the key to find it within the enumeration.
        regname_obj = check_enum_str("regname", regname, self.enum_status_regs)
        value = self.query(f'STAT:{regname_obj.name}:COND?')
        value = int(value)

        # prepare the read out.
        result = dict()
        for name, bit in regname_obj.value.items():  # iterate through the items in the embedded dictionary
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})
        return result

    def _pgm_stepval_limits(self, mode, crange, vrange):
        """Helper function used to determine min/max limits, calculates power limit based on current and voltage ranges
        """
        cmin_val, cmax_val, _ = self.ratings('CURR', crange[0])  # Use first letter of range, allow 'L' or 'LOW'.
        vmin_val, vmax_val, _ = self.ratings('VOLT', vrange[0])

        # mode is (should be) checked against enum by the caller of this helper function.

        if mode in ('NCC', 'FCC'):
            min_val, max_val = cmin_val, cmax_val
            units = 'Amps'
        elif mode in 'NCV':
            min_val, max_val = vmin_val, vmax_val
            units = 'Volts'
        elif mode in 'NCP':
            # The manual is unclear on how this works...
            # I'm guessing we cannot exceed limits of the crange, vrange combo or the ratings of the instrument.
            min_val = 0  # Because all CURR ranges have a lower bound of 0.
            _, max_val, _ = self.ratings('POW', 'H')        # get max power rating of instrument.
            max_val = min(cmax_val * vmax_val, max_val)  # limited by lessor of top of range, instrument max
            units = 'Watts'
        elif mode in ('NCR', 'FCR'):
            # CONDmax is Imax/Vmin, but Vmin is 0.3 for all vranges, so crange is the controlling parameter.
            min_val, max_val, units = self.ratings('COND', crange[0])
        else:
            raise RuntimeError(f"Bad mode {mode}!")

        return min_val, max_val, units

    def _pgm_cfg_check_values(self, pgm_num, memo, mode, crange, vrange, loop, last_state, last_level):
        """Helper function used to check values passed into pgm_norm_cfg and pgm_fast_cfg methods."""
        if memo is not None and (not isinstance(memo, str) or len(memo) > 11):
            raise ValueError(f"Bad memo '{memo}, must be a character string 0 to 11 characters long.")

        if mode is None:
            mode_setting = self.query('PROG:MODE?').strip()
        else:
            enum_modes = self.enum_pgm_norm_modes if pgm_num < 11 else self.enum_pgm_fast_modes
            mode_obj = check_enum_str('mode', mode, enum_modes)
            mode_setting = mode_obj.name

        if crange is None:
            crange_setting = self.query('PROG:CRAN?').strip()[0]
        else:
            error_template = "Bad {name} '{value}' for a normal sequence. Should be one of {cls_name}: {keys}."
            crange_obj = check_enum_str('crange', crange, self.enum_curr_range, error_template)
            crange_setting = crange_obj.name

        if vrange is None:
            vrange_setting = self.query('PROG:VRAN?').strip()[0]
        else:
            error_template = "Bad {name} '{value}' for a normal sequence. Should be one of {cls_name}: {keys}."
            vrange_obj = check_enum_str('vrange', vrange, self.enum_volt_range, error_template)
            vrange_setting = vrange_obj.name

        if loop is not None:
            if (isinstance(loop, (int, float)) and (loop < 1 or loop > 9998)) or (
                    isinstance(loop, str) and loop.upper() != 'INF'):
                raise ValueError(f"Bad loop {loop}. Should be 1 to 9998 or 'INF'.")

        if last_state is not None and last_state not in self.on_off.api_values():
            msg = ", ".join([f"'{x}'" for x in self.on_off.api_values()])
            raise ValueError(f"Bad last_state '{last_state}. Should be one of {msg}.")

        if last_level is not None:
            min_val, max_val, units = self._pgm_stepval_limits(mode_setting, crange_setting, vrange_setting)
            if last_level < min_val or last_level > max_val:
                raise ValueError(f"Bad last_level {last_level}, should be {min_val} to {max_val} {units} " +
                                 f"for mode {mode}.")

    def pgm_norm_cfg(self, pgm_num, memo=None, mode=None, crange=None, vrange=None, loop=None,
                     last_state=None, last_level=None, chain=None):
        """
        Configure the parameters that are common to a Program that runs as a Normal Sequence.
        Use the methods pgm_norm_* to add, delete or edit steps that make up the sequence.

        :param pgm_num: Integer from 1 to 10 that identifies the program
        :type pgm_num: int
        :param memo: String of up to 11 characters that describes the program.
        :type memo: str
        :param mode: Identifies load operating mode for the sequence. One of 'CC', 'CR', 'CV', 'CP'.
        :type mode: str | enum_pgm_norm_modes
        :param crange: Current range" 'L", 'M', 'H'. Use method ratings to see the numerical values.
        :type crange: str | enum_curr_range
        :param vrange: Voltage range" 'L", 'H'. Use method ratings to see the numerical values.
        :type vrange: str | enum_volt_range
        :param loop: Repeat the program this many times: 1-9998. Value 'INF' gives infinite loop.
        :type loop:
        :param last_state: The state of the load, 'ON' or 'OFF' after the sequence ends.
        :type last_state: str
        :param last_level: The level after the sequence ends.
                        Depending on mode this is a conductance, current, voltage or
                        power number.
        :type last_level: int
        :param chain: The pgm_num of the program to execute next, 1-10 or 0. 0 ends sequence operation.
        :type chain: int
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | None
        """
        # SCPI Commands:
        # PROGram[:SELected]: NAME { < numeric > | MINimum | MAXimum} No Query?
        # PROGram[:SELected]: MEMO "<string>"
        # PROGram[:SELected]: MODE {NCC | NCR | NCV | NCP | FCC | FCR}
        # PROGram[:SELected]: CRANge {LOW | MEDium | HIGH}
        # PROGram[:SELected]: VRANge {LOW | HIGH}
        # PROGram: LOOP
        # PROGram[:SELected]: LINPut {ON | OFF | 1 | 0}
        # PROGram[:SELected]: LVALue { < numeric > | MINimum | MAXimum}
        # PROGram[:SELected]: CHAin < NR1 >
        self.log_inst_errors()

        if pgm_num < 1 or pgm_num > 10:
            raise ValueError(f'Bad pgm_num {pgm_num}, must be 1-10 for normal sequences.')

        # Determines which program subsequent commands operate upon.
        self.write(f'PROG:NAME {pgm_num}')

        # No Args, perform queries on all values and return as a dict.
        if all(v is None for v in {memo, mode, crange, vrange, loop, last_state, last_level, chain}):
            return_val = dict()
            tmp = self.query(f'PROG:MEMO?').rstrip('\n').strip('"').strip()
            return_val.update(memo='' if tmp.isspace() else tmp)
            return_val.update(mode=self.query('PROG:MODE?').strip())
            tmp = self.query('PROG:CRAN?', self.enum_volt_range).name
            return_val.update(crange=tmp)
            tmp = self.query('PROG:VRAN?', self.enum_volt_range).name
            return_val.update(vrange=tmp)
            tmp = int(float(self.query('PROG:LOOP?')))
            return_val.update(loop=tmp if tmp < 9999 else 'INF')
            tmp = self.query('PROG:LINP?')
            return_val.update(last_state=self.on_off.to_api(int(tmp)))
            return_val.update(last_level=float(self.query('PROG:LVAL?')))
            return_val.update(chain=int(float(self.query('PROG:CHAIN?'))))
            return return_val

        # Check all values before we write anything.
        self._pgm_cfg_check_values(pgm_num, memo, mode, crange, vrange, loop, last_state, last_level)
        # translate single letter to 'LOW', etc. Create object and call the value later.
        crange_obj = check_enum_str('crange', crange, self.enum_curr_range)
        vrange_obj = check_enum_str('vrange', vrange, self.enum_volt_range)
        mode_obj = check_enum_str('mode', mode, self.enum_pgm_norm_modes)

        if chain is not None and (chain < 0 or chain > 10):
            raise ValueError(f"Bad chain {chain}, should be 0 to 10. (0 ends sequence execution.)")

        # Now that all supplied values pass the checks, write to the instrument.

        if memo is not None:
            self.write(f'PROG:MEMO "{memo}"')
        if mode is not None:
            self.write(f'PROG:MODE {mode_obj.name}')
        if crange is not None:
            self.write(f'PROG:CRAN {crange_obj.value}')
        if vrange is not None:
            self.write(f'PROG:VRAN {vrange_obj.value}')
        if loop is not None:
            if isinstance(loop, str) and loop.upper() == 'INF':
                self.write(f'PROG:LOOP 9999')
            else:
                self.write(f'PROG:LOOP {loop}')
        if last_state is not None:
            self.write(f'PROG:LINP {last_state}')
        if last_level is not None:
            self.write(f'PROG:LVAL {last_level}')
        if chain is not None:
            self.write(f'PROG:CHAIN {chain}')

        self.log_inst_errors()

    def pgm_fast_cfg(self, memo=None, mode=None, crange=None, vrange=None, loop=None, last_state=None, last_level=None,
                     end_step=None, dwell_sec=None):
        """
        Configure the parameters that are common to a Program that runs as a Fast Sequence.
        Use the methods pgm_fast_edit to edit steps that make up the sequence.

        :param memo: String of up to 11 characters that describes the program.
        :type memo: str
        :param mode: Identifies load operating mode for the sequence. One of 'CC', 'CR', 'CV', 'CP'.
        :type mode: str | enum_pgm_fast_modes
        :param crange: Current range" 'L", 'M', 'H'. Use method ratings to see the numerical values.
        :type crange: str | enum_curr_range
        :param vrange: Voltage range" 'L", 'H'. Use method ratings to see the numerical values.
        :type vrange: str | enum_volt_range
        :param loop: Repeat the program this many times: 1-9998. Value 'INF' gives infinite loop.
        :type loop:
        :param last_state: The state of the load, 'ON' or 'OFF' after the sequence ends.
        :type last_state: str
        :param last_level: The level after the sequence ends.
                        Depending on mode this is a conductance, current, voltage or
                        power number.
        :type last_level: int
        :param end_step: The index (one based) of the final step in the sequence, max value 1024.
        :type end_step: int
        :param dwell_sec: The time interval between all points. Can be 25-6 sec to 100e-3 seconds.
        :type dwell_sec: float
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | None
        """
        # :return: If function is called without parameters, read back current parameter values. Otherwise None.
        # :rtype: dict | None

        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     PROGram[:SELected]:MEMO "<string>"
        #     PROGram[:SELected]:MODE {NCC|NCR|NCV|NCP|FCC|FCR}
        #     PROGram[:SELected]:CRANge {LOW|MEDium|HIGH}
        #     PROGram[:SELected]:VRANge {LOW|HIGH}
        #     PROGram:LOOP
        #     PROGram[:SELected]:LINPut {ON|OFF|1|0}
        #     PROGram[:SELected]:LVALue {<numeric>|MINimum|MAXimum}
        #     PROGram[:SELected]:FSPeed[:STEP]:END <NR1>
        #     PROGram[:SELected]:FSPeed:TIME {<numeric>|MINimum|MAXimum}
        #

        # Determines which program subsequent commands operate on.
        self.write('PROG:NAME 11')
        # No Args, perform queries on all values and return as a dict.
        if all(v is None for v in {memo, mode, crange, vrange, loop, last_state, last_level, end_step, dwell_sec}):
            return_val = dict()
            tmp = self.query(f'PROG:MEMO?').rstrip('\n').strip('"').strip()
            return_val.update(memo='' if tmp.isspace() else tmp)
            return_val.update(mode=self.query(f'PROG:MODE?').strip())
            tmp = self.query('PROG:CRAN?', self.enum_curr_range).name
            return_val.update(crange=tmp)
            tmp = self.query('PROG:VRAN?', self.enum_volt_range).name
            return_val.update(vrange=tmp)
            tmp = int(float(self.query('PROG:LOOP?')))
            return_val.update(loop=tmp if tmp < 9999 else 'INF')
            tmp = self.query(f'PROG:LINP?')
            return_val.update(last_state=self.on_off.to_api(int(tmp)))
            return_val.update(last_level=float(self.query(f'PROG:LVAL?')))
            return_val.update(end_step=int(float(self.query(f'PROG:FSP:END?'))))
            return_val.update(dwell_sec=float(self.query(f'PROG:FSP:TIME?')))
            return return_val

        # Check all values before we write anything.
        self.log_inst_errors()
        self._pgm_cfg_check_values(11, memo, mode, crange, vrange, loop, last_state, last_level)
        # translate single letter to 'LOW', etc. Create object and call the value later.
        crange_obj = check_enum_str('crange', crange, self.enum_curr_range)
        vrange_obj = check_enum_str('vrange', vrange, self.enum_volt_range)
        mode_obj = check_enum_str('mode', mode, self.enum_pgm_fast_modes)

        if end_step is not None and (end_step < 1 or end_step > 1024):
            raise ValueError(f"Bad end_step {end_step}, should be 1 to 1024.")

        if dwell_sec is not None and (dwell_sec < 25e-6 or dwell_sec > 100e-3):
            raise ValueError(f"Bad dwell_sec {dwell_sec}, should be 25e-6 to 100e-3 sec.")

        if memo is not None:
            self.write(f'PROG:MEMO "{memo}"')
        if mode is not None:
            self.write(f'PROG:MODE {mode_obj.name}')
        if crange is not None:
            self.write(f'PROG:CRAN {crange_obj.value}')
        if vrange is not None:
            self.write(f'PROG:VRAN {vrange_obj.value}')
        if loop is not None:
            if isinstance(loop, str) and loop.upper() == 'INF':
                self.write(f'PROG:LOOP 9999')
            else:
                self.write(f'PROG:LOOP {loop}')
        if last_state is not None:
            self.write(f'PROG:LINP {last_state}')
        if last_level is not None:
            self.write(f'PROG:LVAL {last_level}')
        if end_step is not None:
            self.write(f'PROG:FSP:END {end_step}')
        if dwell_sec is not None:
            self.write(f'PROG:FSP:TIME {dwell_sec}')

        self.log_inst_errors()

    def pgm_info(self, pgm_num):
        """
        Retrieves from the instrument all the programming information for the specified Program
        number including any steps that have been defined.

        :param pgm_num: 1-10 are Normal programs, 11 is reserved for Fast programs.
                    Normal programs are limited to a combined total of 256 steps, each with its own dwell_sec time.
                    Normal programs can be chained to together to execute one after another.
                    Fast programs may have up to 1024 steps, all sharing a common dwell_sec time. Fast programs cannot
                    be chained together.
        :type pgm_num: int
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict
        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     Call pgm_norm_cfg or pgm_fast_cfg
        #     PROGram[:SELected]: NSPeed[:STEP]:COUNt?
        #     Call pgm_norm_read

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')

        self.write(f'PROG:NAME {pgm_num}')

        steps = []
        if pgm_num > 10:
            pgm_cfg = self.pgm_fast_cfg()
            num_steps = int(self.query('PROG:FSP:END?'))
            for step_idx in range(1, num_steps + 1):
                tmp = self.query("PROG:FSP:EDIT", str, f"{step_idx}").split(',')
                steps.append([float(tmp[0]), int(tmp[1])])
        else:
            pgm_cfg = self.pgm_norm_cfg(pgm_num)
            num_steps = int(self.query('PROG:NSP:COUN?'))
            for step_idx in range(1, num_steps + 1):
                tmp = self.query("PROG:NSP:EDIT", str, f"{step_idx}").split(',')
                steps.append([float(tmp[0]), float(tmp[1]), int(tmp[2]), int(tmp[3]), int(tmp[4]), int(tmp[5])])

        return {'pgm_num': pgm_num, 'pgm_cfg': pgm_cfg, 'num_steps': num_steps, 'steps': steps}

    def pgm_save(self, pgm_num, filename, use_arrays=True):
        """
        Save the Program Sequence as a Python module that provides a function pgm_restore.

        When executed pgm_restore will write the cfg and step information into
        the specified Program Sequence location in the PLZ instrument.

        :param pgm_num: 1-10 are Normal programs, 11 is reserved for Fast programs.
                    Normal programs are limited to a combined total of 256 steps, each with its own dwell_sec time.
                    Normal programs can be chained to together to execute one after another.
                    Fast programs may have up to 1024 steps, all sharing a common dwell_sec time. Fast programs cannot
                    be chained together.
        :type pgm_num: int
        :param filename: desired Filename
        :type filename: str
        :param use_arrays: default true
        :type use_arrays: bool
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | none
        """

        fileobj = open(filename, mode='w')
        modulename = os.path.splitext(os.path.basename(filename))[0]

        info = self.pgm_info(pgm_num)
        cfg_args = [f"{k}={repr(v)}" for k, v in info['pgm_cfg'].items()]
        cfg_args = ', '.join(cfg_args)

        chain_warn_msg = ''

        if pgm_num < 11:
            # Determine if we have dependency on another program.
            if info['pgm_cfg']['chain'] != 0:
                chain_warn_msg = "This program chains to another program expected to be at " + \
                                 f"pgm_num={info['pgm_cfg']['chain']}!"
                print(chain_warn_msg)

            # Print module header docstring.
            print(f'"""', end='', file=fileobj)
            print(f"Saved PLZ Normal Program Sequence, memo=\"{info['pgm_cfg']['memo']}\".\n", file=fileobj)
            print("To recall this sequence into your PLZ instrument, do this:\n\n"
                  f"import {modulename}\n"
                  f"{modulename}.pgm_norm_recall(plz_obj, pgm_num)\n"
                  "\nwhere:\n"
                  "plz_obj is the instmngr PLZ object controlling your PLZ, and\n"
                  "pgm_num specifies the Program location within the instrument.\n", file=fileobj)
            if chain_warn_msg:
                print(f'{chain_warn_msg}\n', file=fileobj)

            print("If you make changes to this file after importing it, to have your changes take effect you\n"
                  "must reimport using the imp.reload function from Python's imp package.", file=fileobj)
            print(f'"""\n', file=fileobj)

            # Print start of function definition.
            print(f"\ndef pgm_norm_recall(plz_obj, pgm_num):", file=fileobj)

            # Print function docstring.
            print(f'    """', end='', file=fileobj)
            print(f'Recalls a saved PLZ Normal Sequence into the specified PLZ instrument and pgm_num.\n', file=fileobj)
            print('    Args:', file=fileobj)
            print('        plz_obj: An object of the Load_PLZ164WL or Load_PLZ334WL class corresponding to the\n'
                  '                  target machine to be programed with this sequence. Obtained from the instmngr\n'
                  '                  checkout method.', file=fileobj)
            print('        pgm_num: The program sequence number where these setting will be placed in the target \n'
                  '                 machine. Kikusui refers to the as the Seq No. on the front panel LCD and as \n'
                  '                 PROG:NAME in the SCPI commands.', file=fileobj)
            if chain_warn_msg:
                print(f'\n    {chain_warn_msg}', file=fileobj)
            print('    """\n', file=fileobj)

            # Put this in the function to remind user when they execute a recall.
            if chain_warn_msg:
                print(f'    print("{chain_warn_msg}")\n', file=fileobj)

            print(f"    plz_obj.pgm_norm_cfg(pgm_num, {cfg_args})\n", file=fileobj)

            print("    plz_obj.pgm_norm_del(pgm_num, 'ALL')\n", file=fileobj)

            step_keys = ('level', 'dwell_sec', 'state', 'ramp', 'trig', 'pause')
            print_width = 100
            for i, params in enumerate(info['steps']):
                args = [f"{k}={repr(v)}" for k, v in zip(step_keys, params)]
                args = ', '.join(args)
                text = f'    plz_obj.pgm_norm_add(pgm_num, {args})  '
                line_len = len(text)
                print_width = max(print_width, line_len)
                pad = " " * (print_width - line_len)
                print(f"{text}{pad}# {i+1}", file=fileobj)

        else:
            # Print module header docstring.
            print(f'"""', end='', file=fileobj)
            print(f"Saved PLZ Fast Program Sequence, memo=\"{info['pgm_cfg']['memo']}\".\n", file=fileobj)
            print(f"To recall this sequence into your PLZ instrument, do \n"
                  f"import {modulename}\n"
                  f"{modulename}.pgm_fast_recall(plz_obj)\n"
                  "\nwhere plz_obj is the instmngr PLZ object controlling your PLZ.", file=fileobj)

            print("\nIf you make changes to this file after importing it, to have your changes take effect you\n"
                  "must use the imp.reload function from the imp package.", file=fileobj)
            print(f'"""\n', file=fileobj)

            print('import numpy as np\n', file=fileobj)

            # Print start of function definition.
            print(f"def pgm_fast_recall(plz_obj):", file=fileobj)

            # Print function docstring.
            print(f'    """', end='', file=fileobj)
            print(f'Recalls a saved PLZ Fast Sequence into the specified PLZ instrument.\n',
                  file=fileobj)
            print('    Args:', file=fileobj)
            print('        plz_obj: An object of the Load_PLZ164WL or Load_PLZ334WL class corresponding to the\n'
                  '                  target machine to be programed with this sequence. Obtained from the instmngr\n'
                  '                  checkout method.', file=fileobj)
            print('    """\n', file=fileobj)

            print(f"    plz_obj.pgm_fast_cfg({cfg_args})", file=fileobj)

            data_dict = self.pgm_fast_arrays()

            if use_arrays:
                # Dump out as tuple of two element tuples, for ease of editing.
                print(f"    level_trig = (", file=fileobj)
                print('         # level   trig  Kikusui Step No.', file=fileobj)
                prev_end = ''
                for i, (level, trigger) in enumerate(zip(data_dict['levels'], data_dict['triggers'])):
                    print(f'{prev_end}', end='', file=fileobj)
                    print(f"{' '*8}({level:4f}, {trigger:1d})", end='', file=fileobj)
                    prev_end = f',   # {i+1}\n'
                print(f'{prev_end}    )', file=fileobj)

                print('\n    # Convert tuples to separate numpy arrays. ', file=fileobj)
                print(f'    levels = np.array([d[0] for d in level_trig])', file=fileobj)
                print(f'    triggers = np.array([d[1] for d in level_trig])', file=fileobj)

                print('', file=fileobj)
                print(f"    plz_obj.pgm_fast_cfg(end_step=len(level_trig))  # In case someone edits the array",
                      file=fileobj)
                print('    plz_obj.pgm_fast_arrays(levels, triggers)', file=fileobj)
            else:
                print('', file=fileobj)
                step_keys = ('level', 'trig')
                for i, params in enumerate(info['steps']):
                    args = [f"{k}={repr(v)}" for k, v in zip(step_keys, params)]
                    args = ', '.join(args)
                    print(f'    plz_obj.pgm_fast_edit(step_idx={i+1}, {args})', file=fileobj)

        fileobj.flush()
        fileobj.close()

    def pgm_ctrl(self, pgm_num, pgm_state):
        """
        Controls execution of the specified Program sequence.

        :param pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
        :type pgm_num: int
        :param pgm_state:
                * RUN - Execute the selected program.
                * STOP - Stop execution of the program.
                * PAUSE - Pause sequence execution.
                * CONT - Resume sequence execution.
                * TRUN - Set the program to execute using a trigger (valid only for Normal Sequences). Use GPIB bus
                  trigger command \*TRG.
        :type pgm_state: str | enum_pgm_status
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | none
        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     PROGram[:SELected]:EXECuting?
        #     PROGram[:SELected]:STATe {TRUN|RUN|STOP|PAUSe|CONTinue}

        # TODO: Figure out what happens if another pgm is already running.
        # See if there is already a program executing.
        # status = pgm_status(self)
        # if status['status'] in ('TRUN', 'RUN', 'PAUS'):

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')
        self.write(f'PROG:NAME {pgm_num}')

        if pgm_num == 11 and pgm_state == 'TRUN':
            raise ValueError('TRUN cannot be used with Fast Sequence.')

        pgm_state_obj = check_enum_str('pgm_state', pgm_state, self.enum_pgm_status)
        self.write(f'PROG:STAT {pgm_state_obj.name}')
        self.log_inst_errors()

    def pgm_status(self):
        """
        Queries status of the program sequence engine.

        :return: returns dictionary containing 'pgm_num', 'status',
            'exec_time', 'step_idx', 'loop_num'.
        :rtype: dict | str
        """
        tmp = self.query('PROG:EXEC?').strip().split(',')
        return {'pgm_num': tmp[4], 'status': tmp[0], 'exec_time': float(tmp[1]), 'step_idx': int(tmp[3]),
                'loop_num': int(tmp[2])}

    def pgm_clear(self, pgm_num):
        """
        Deletes the specified Program: all cfg parameters are reset to defaults and all steps are deleted.

        :param pgm_num:  Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
        :type pgm_num: int

        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     PROGram:CLEar

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')

        self.write(f'PROG:NAME {pgm_num}')
        self.write('PROG:CLE')

        self.log_inst_errors()

    def pgm_norm_read(self, pgm_num, step_idx):
        """
        Reads from the instrument the data associated with the specified Normal Sequence Program and step within the
        program.

        :param pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
        :type pgm_num: int
        :param step_idx: Index of the step within the program. First step is step_idx=1.
        :type step_idx: int
        :return: Returns data as a dictionary.
        :rtype: dict
        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     PROGram[:SELected]:NSPeed[:STEP]:EDIT? <step_NR1>

        if pgm_num < 1 or pgm_num > 11:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences, 11 for fast sequence.')

        self.write(f'PROG:NAME {pgm_num}')
        tmp = self.query("PROG:NSP:EDIT", str, f"{step_idx}").split(',')
        self.log_inst_errors()
        return_val = dict()
        return_val.update(value=float(tmp[0]))
        return_val.update(dwell=float(tmp[1]))
        return_val.update(state=self.on_off.to_api(int(tmp[2])))
        # return_val.update(state=self.legal_on_off_rev[int(tmp[2])]) #former method of working
        return_val.update(ramp=self.on_off.to_api(int(tmp[3])))
        return_val.update(trig=self.on_off.to_api(int(tmp[4])))
        return_val.update(pause=self.on_off.to_api(int(tmp[5])))
        return return_val

    def pgm_fast_read(self, step_idx):
        """
        Reads from the instrument the data associated with the specified Fast Sequence Program and the step within
        the program.

        :param step_idx:  Index of the step within the program. First step is step_idx=1.
        :type step_idx: int
        :return: Returns data as a dictionary.
        :rtype: dict
        """
        # PROGram[:SELected]: FSPeed[:STEP]:EDIT[:POINt]? < step_NR1 >
        tmp = self.query("PROG:FSP:EDIT", str, f"{step_idx}").split(',')
        self.log_inst_errors()
        return_val = dict()
        return_val.update(value=float(tmp[0]))
        return_val.update(trig=self.on_off.to_api(int(tmp[1])))
        return return_val

    def pgm_fast_edit(self, step_idx, level=None, trig=None):
        """
        Edits level or trig fields of a step in a Fast program sequence.

        :param step_idx: Index of the step within the program. First step is step_idx=1.
        :type step_idx:  int
        :param level: The level the step transitions to. What this represents (current, voltage,
                    conductance, or power) depends upon the mode defined in the pgm_cfg.
        :type level: int | float
        :param trig:  Output a pulse on the front panel BNC connector when this step is executed.
        :type trig:  int | str
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
                Step count as read from the instrument.
        :rtype: dict | none
        """
        # SCPI Commands:
        # PROGram[:SELected]: NAME { < numeric > | MINimum | MAXimum}   No Query?
        # PROGram[:SELected]: FSPeed[:STEP]:EDIT[:POINt] < step_NR1 >, < value_numeric > [, < trig_NR1 >]

        self.log_inst_errors()
        self.write('PROG:NAME 11')

        if step_idx < 1 or step_idx > 1024:
            # TODO: What happens if step_nums are not supplied sequentially? Jumps past the current end?
            raise ValueError(f"Bad step_idx {step_idx}, should be 1 to 1024.")

        if level is not None:
            mode = self.query('PROG:MODE?').strip()
            crange = self.query('PROG:CRAN?').strip()[0]
            vrange = self.query('PROG:VRAN?').strip()[0]

            min_val, max_val, units = self._pgm_stepval_limits(mode, crange, vrange)
            if level < min_val or level > max_val:
                raise ValueError(f"Bad level {level}, should be 0 to {max_val}.")

        if trig is not None:
            bool_msg = "0, 1, 'ON', 'OFF'"
            if trig not in (0, 1, 'ON', 'OFF'):
                raise ValueError(f"Bad state {trig}, should be one of {bool_msg}.")

        level_setting, trig_setting = level, trig
        if level is None or trig is None:
            # Same SCPI commamnd sets both so do read to get the other one..
            tmp = self.query("PROG:FSP:EDIT", str, f"{step_idx}").split(',')
            level_setting = float(tmp[0]) if level is None else level
            trig_setting = int(tmp[1]) if trig is None else trig

        self.write(f'PROG:FSP:EDIT {step_idx}, {level_setting}, {trig_setting}')

        self.log_inst_errors()

    def pgm_fast_arrays(self, levels=None, triggers=None):
        """
        Reads or writes entire arrays that define the levels and trigger locations of a fast program sequence.

        :param levels: A list or numpy array of values that make up the voltage, current, power or conductance sequence.
            triggers:
        :type levels: list | ndarray | array
        :param triggers: Elements of this array are in 1:1 correspondence with those of levels.
            A 1 in this array results in a trigger pulse being output when the corresponding sample is being output.
        :type triggers: list | ndarray | array
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | none
        """

        # SCPI Commands:
        #     PROGram[:SELected]:FSPeed[:STEP]:END <NR1>
        #     PROGram[:SELected]:FSPeed[:STEP]:EDIT[:POINt] <step_NR1>,<value_numeric>[,<trig_NR1>]

        self.log_inst_errors()

        if levels is None and triggers is None:
            num_steps = int(self.query('PROG:FSP:END?'))
            levels = np.empty(num_steps, float)
            triggers = np.empty(num_steps, int)
            for i in range(num_steps):
                tmp = self.query("PROG:FSP:EDIT", str, f"{i+1}").split(',')
                levels[i] = tmp[0]
                triggers[i] = tmp[1]
            return_val = dict()
            return_val.update(levels=levels)
            return_val.update(triggers=triggers)
            return return_val

        if levels is None or triggers is None:
            raise ValueError(f'Must specify both arrays:  levels and triggers.')

        levels_len = len(levels)
        triggers_len = len(triggers)
        if levels_len != triggers_len or levels_len < 1 or levels_len > 1024:
            raise ValueError(f'Arrays levels ({levels_len}) and triggers ({triggers_len}) must be same length, '
                             '1 to 1024 elements.')

        mode = self.query('PROG:MODE?').strip()
        crange = self.query('PROG:CRAN?').strip()[0]
        vrange = self.query('PROG:VRAN?').strip()[0]

        min_val, max_val, units = self._pgm_stepval_limits(mode, crange, vrange)
        msg = self._check_list_values('levels', levels, min_val, max_val, units, self.cfg_max_disp_list_errors)
        if msg:
            raise ValueError(msg)

        msg = self._check_list_values('triggers', triggers, 0, 1, '', self.cfg_max_disp_list_errors)
        if msg:
            raise ValueError(msg)

        for i in range(levels_len):
            self.write(f'PROG:FSP:EDIT {i+1}, {levels[i]}, {triggers[i]}')

        self.write(f'PROG:FSP:END {levels_len}')
        self.log_inst_errors()

    @staticmethod
    def _check_list_values(name, values, val_min, val_max, units, show_maxbad):
        """
        Check an entire list of values and create error message describing which elements are out of bounds.
        """
        bad_indicies = [i for i, val in enumerate(values) if (val < val_min or val > val_max)]
        num_bad = len(bad_indicies)
        msg = ''
        if num_bad > 0:
            show_bad = min(num_bad, show_maxbad)
            msg = f"{name} contains {num_bad} values outside range {val_min} to {val_max} {units}. "
            if num_bad > show_bad:
                msg += f"The first {show_bad} are:\n"
            else:
                msg += "They are:\n"
            msg += ",\n".join([f"    {name}[{bad_indicies[i]}]={values[bad_indicies[i]]}" for i in range(show_bad)])
        return msg

    def _pgm_norm_step_checks(self, pgm_num, level, dwell_sec, state, ramp, trig, pause):
        """
        Used to check the values associated with adding, inserting or editing a step in a Normal Program sequnece.
        """
        if pgm_num < 1 or pgm_num > 10:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences.')
        self.write(f'PROG:NAME {pgm_num}')

        if level is not None:
            mode = self.query('PROG:MODE?').strip()
            crange = self.query('PROG:CRAN?').strip()[0]
            vrange = self.query('PROG:VRAN?').strip()[0]

            min_val, max_val, units = self._pgm_stepval_limits(mode, crange, vrange)
            if level < min_val or level > max_val:
                raise ValueError(f"Bad level {level}, should be {min_val} to {max_val} {units} for" +
                                 f"crange='{crange}', vrange={vrange}")

        if dwell_sec is not None and (dwell_sec < 0.001 or dwell_sec > 3599940):
            raise ValueError(f"Bad dwell_sec {dwell_sec}, should be 0.001 to 3599940 sec.")

        bool_msg = "0, 1, 'ON', 'OFF'"
        if state is not None and state not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad state {state}, should be one of {bool_msg}.")
        if ramp is not None and ramp not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad ramp {ramp}, should be one of {bool_msg}.")
        if trig is not None and trig not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad trig {trig}, should be one of {bool_msg}.")
        if pause is not None and pause not in (0, 1, 'ON', 'OFF'):
            raise ValueError(f"Bad pause {pause}, should be one of {bool_msg}.")

    def pgm_norm_add(self, pgm_num, level, dwell_sec, state, ramp, trig, pause):
        """
        Appends a new step to the end of the specified Normal Program.

        :param pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence.
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
        :type pgm_num: int
        :param level: The level the step transitions to. What this represents (current, voltage,
                    conductance, or power) depends upon the mode defined in the pgm_cfg.
        :type level: int | float
        :param dwell_sec: Time duration of the step in seconds. 0.001 to 3599940 sec. (999h59min).
            state: The load state ('ON' or 'OFF' at the end of the dwell_sec time.
            ramp: Defines how the level transitions.
        :type dwell_sec: int | float
        :param state: (0, 1, 'ON', 'OFF')
        :type state: int | str
        :param ramp:
                * 0: load transitions instantly to the specified level which is sustained for the dwell_sec time..
                * 1: load transitions to the new level as a linear ramp over the dwell_sec time.
        :type ramp: (0, 1, 'ON', 'OFF')
        :param trig: Output a pulse on the front panel BNC connector when this step is executed.
        :type trig: int | str
        :param pause: Pause during execution of this step.
        :type pause: int | str
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | none
        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #   PROGram[:SELected]: NSPeed[:STEP]:ADD < value_numeric >, < time_numeric > [, < load_bool >][, < ramp_bool >]
        #       [, < trig_bool >][, < pause_bool >]

        if any(v is None for v in {pgm_num, level, dwell_sec, state, ramp, trig, pause}):
            raise ValueError("None values for parameters not permitted here.")

        self. _pgm_norm_step_checks(pgm_num, level, dwell_sec, state, ramp, trig, pause)
        self.write(f'PROG:NSP:ADD {level}, {dwell_sec}, {state}, {ramp}, {trig}, {pause}')
        self.log_inst_errors()
        return int(self.query('PROG:NSP:COUN?'))

    def pgm_norm_del(self, pgm_num, step_idx):
        """
        Deletes the step at step_Idx from the specified Normal Program.

        :param pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
        :type pgm_num: int
        :param step_idx: Index of the step within the program. First step is step_idx=1.
                      Use step_idx = 'ALL' to delete all the steps.
        :type step_idx: int | str
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | none
        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     PROGram[:SELected]:NSPeed[:STEP]:DELete[:STEP]
        #     PROGram[:SELected]:NSPeed[:STEP]:DELete:ALL

        if pgm_num < 1 or pgm_num > 10:
            raise ValueError(f'Bad pgm_num {pgm_num}, should be 1-10 for normal sequences.')
        self.write(f'PROG:NAME {pgm_num}')

        if isinstance(step_idx, int):
            num_steps = int(self.query('PROG:NSP:COUN?'))
            if step_idx > num_steps:
                raise ValueError(f"Bad step_idx {step_idx}, only {num_steps} are currently defined.")
            self.write(f'PROG:NSPeed:DEL {step_idx}')
        elif isinstance(step_idx, str) and step_idx.upper() == 'ALL':
            self.write('PROG:NSP:DEL:ALL')
        else:
            raise ValueError(f"Bad step_idx {step_idx}, should be a specific step 1 - 256, or 'ALL'.")

        return int(self.query('PROG:NSP:COUN?'))

    def pgm_norm_edit(self, pgm_num, step_idx, level=None, dwell_sec=None, state=None, ramp=None, trig=None,
                      pause=None):
        """
        Allow modification of any of the values of an existing step of the specified Normal Program.

        :param pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
        :type pgm_num: int
        :param step_idx: Index of the step within the program. First step is step_idx=1.
                      Use step_idx = 'ALL' to delete all the steps.
        :type step_idx: int
        :param level: The level the step transitions to. What this represents (current, voltage,
                   conductance, power) depends upon the mode in the pgm_cfg.
        :type level: int | float
        :param dwell_sec: Time duration of the step in seconds. 0.001 to 3599940 sec. (999h59min).
        :type dwell_sec: float
        :param state: int | str
        :type state: The load state ('ON' or 'OFF' at the end of the dwell_sec time.
        :param ramp:
                * 0: load transitions instantly to the specified level which is sustained for the dwell_sec time..
                * 1: load transitions to the new level as a linear ramp over the dwell_sec time.
        :type ramp: int | str
        :param trig: Output a pulse on the front panel BNC connector when this step is executed.
        :type trig: int | str
        :param pause: 'ON' = Pause during execution of this step.
        :type pause: int | str
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | none
        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     PROGram[:SELected]: NSPeed[:STEP]:EDIT < step_NR1 >, < value_numeric >, < time_numeric > [, < load_bool >]
        #       [, < ramp_bool >][, < trig_bool >][, < pause_bool >]

        # Note that None values are allowed in this case in order to support individual parameter modifications.
        self._pgm_norm_step_checks(pgm_num, level, dwell_sec, state, ramp, trig, pause)

        # Do a read-modify-write operation.
        tmp = self.query("PROG:NSP:EDIT", str, f"{step_idx}").split(',')

        if level is None:
            level = tmp[0]
        if dwell_sec is None:
            dwell_sec = tmp[1]
        if state is None:
            state = tmp[2]
        if ramp is None:
            ramp = tmp[3]
        if trig is None:
            trig = tmp[4]
        if pause is None:
            pause = tmp[5]

        self.write(f'PROG:NSP:EDIT {step_idx}, {level}, {dwell_sec}, {state}, {ramp}, {trig}, {pause}')
        self.log_inst_errors()

    def pgm_norm_insert(self, pgm_num, step_idx, level, dwell_sec, state, ramp, trig, pause):
        """
        Insert a new program step ahead of the existing step at step_idx in specified
        Normal Program.

        :param pgm_num: Identifying number("name" in Kikusui manual) of Program Sequence..
                     1-10 are "Normal Sequences",  11 is the only "Fast Sequence".
        :type pgm_num: int
        :param step_idx: Index of the step within the program. First step is step_idx=1.
                      Use step_idx = 'ALL' to delete all the steps.
        :type step_idx: int
        :param level: The level the step transitions to. What this represents (current, voltage,
                   conductance, power) depends upon the mode in the pgm_cfg.
        :type level: int | float
        :param dwell_sec: Time duration of the step in seconds. 0.001 to 3599940 sec. (999h59min).
        :type dwell_sec: float
        :param state: int | str
        :type state: The load state ('ON' or 'OFF' at the end of the dwell_sec time.
        :param ramp:
                * 0: load transitions instantly to the specified level which is sustained for the dwell_sec time..
                * 1: load transitions to the new level as a linear ramp over the dwell_sec time.
        :type ramp:  int | str
        :param trig: Output a pulse on the front panel BNC connector when this step is executed.
        :type trig: int | str
        :param pause: 'ON' = Pause during execution of this step.
        :type pause: int | str
        :return: If function is called without parameters, read back current parameter values. Otherwise None.
        :rtype: dict | none
        """
        # SCPI Commands:
        #     PROGram[:SELected]:NAME {<numeric>|MINimum|MAXimum}   No Query?
        #     PROGram[:SELected]:NSPeed[:STEP]:INSert <step_NR1>,<value_numeric>,<time_numeric>[,<load_bool>]
        #       [,<ramp_bool>][,<trig_bool>][,<pause_bool>]

        if any(v is None for v in {pgm_num, step_idx, level, dwell_sec, state, ramp, trig, pause}):
            raise ValueError("None values for parameters not permitted here.")

        self. _pgm_norm_step_checks(pgm_num, level, dwell_sec, state, ramp, trig, pause)
        self.write(f'PROG:NSP:INS {step_idx}, {level}, {dwell_sec}, {state}, {ramp}, {trig}, {pause}')
        self.log_inst_errors()

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.
        """

        value = int(self.query('*STB?').rstrip())
        conditions = {'CSUM': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPER': 7}
        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})
        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending \*CLS command. """
        self.write('*CLS')

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
