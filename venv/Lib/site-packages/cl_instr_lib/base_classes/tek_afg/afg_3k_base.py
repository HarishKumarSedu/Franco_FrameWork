from cl_instr_lib.base_classes.tek_afg.afg_thumbdrive import AfgThumbdrive
from cl_instr_lib.base_classes.tek_afg.afg_setup import AfgSetup
from cl_instr_lib.base_classes.tek_afg.afg_arbwfm import AfgArbWfm
from cl_instr_lib.base_classes.signal_generator import SignalGenerator
from cl_instr_lib.base_classes.sg_channel_ABC import SGChannel_ABC

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units

from collections import namedtuple
from enum import Enum
from re import match
from pathlib import PurePosixPath
from typing import Dict, Union
import math

ProgrammingBounds = namedtuple('ProgrammingBounds', ['load_z_min', 'load_z_max',
                                                     'ampl_pp_hiz_min', 'ampl_pp_hiz_max',  # TODO: ampl max depends on
                                                     # freq
                                                     'phase_min', 'phase_max',
                                                     'offset_hiz_min', 'offset_hiz_max',
                                                     'voltage_window_hiz_min', 'voltage_window_hiz_max',
                                                     'freq_min', 'freq_max',
                                                     'freq_sine_burst_min', 'freq_sine_burst_max',
                                                     'freq_arb_burst_min', 'freq_arb_burst_max',
                                                     'ramp_symmetry_min', 'ramp_symmetry_max',
                                                     'edge_min',
                                                     'duty_min', 'duty_max',
                                                     'noise_percent_max',
                                                     'am_depth_percent_max',
                                                     'fm_deviation_max',
                                                     'pm_deviation_max',
                                                     'mod_freq_internal_min', 'mod_freq_internal_max',  # AM,FM,PM,PWM
                                                     'fsk_keyrate_min', 'fsk_keyrate_max',
                                                     'hop_freq_hz_max',
                                                     'burst_ncycles_min', 'burst_ncycles_max',
                                                     'burst_tdelay_sec_max']
                               )

ProgrammingRange = namedtuple('ProgrammingRange', 'MIN MAX')


class Afg3kBase(SignalGenerator):
    """Base class for Driver class Tektronix AFG3k family."""

    def __init__(self, visa_resource_name, chan_pgm_bounds, logger=None, **kwargs):

        # Setup the simulation code inherited from Instrument.
        super().__init__(visa_resource_name, logger, **kwargs)

        # A couple parameters require unusual handling. Define some data for those and pass into the generic channel
        # objects.

        # Second, the two channels differ in that CH2 cannot sum with the EXT input.
        enum_combine_ch1 = Enum('enum_combine_ch1',
                                {'OFF': '""', 'NOISE': '"NOIS"', 'EXTERNAL': '"EXT"', 'BOTH': '"BOTH"'})
        enum_combine_ch2 = Enum('enum_combine_ch2', {'OFF': '""', 'NOISE': '"NOIS"'})

        # Create the channel objects. Pass signal generator self down to channel so he knows who his container is.

        #: Attribute containing object that controls the **thumbdrive** filesystem. See `thumbdrive class`_.
        self.thumbdrive = AfgThumbdrive(self)

        #: Attribute containing object that controls saving and recalling **AFG setups**. See `setup class`_.
        self.setup = AfgSetup(self)

        #: Attribute containing object that controls defining and manipulating **arbitrary waveforms**.
        #: See `arbwfm class`_.
        self.arb_waveforms = AfgArbWfm(self)

        #: Attribute containing object that controls **CH1**. See `channel class`_.
        self.CH1 = Channel(self, 'CH1', 1, chan_pgm_bounds, enum_combine_ch1)

        #: Attribute containing object that controls  **CH2**. See `channel class`_.
        self.CH2 = Channel(self, 'CH2', 2, chan_pgm_bounds, enum_combine_ch2)

        self._channel_names = ['CH1', 'CH2']

        # These items are controlled at the AFG level (not per channel):
        self.enum_trig_slope = Enum('enum_trig_slope', {'RISING': 'POS', 'FALLING': 'NEG'})
        self.enum_trig_source = Enum('enum_trig_source', {'EXTERNAL': 'EXT', 'TIMER': 'TIM'})
        self.bounds_timer_sec = ProgrammingRange(1e-6, 500.0)

    def trig_config(self, slope=None, source=None, timer_sec=None):
        """
        Configure AFG trigger source, either external input or internal timer. Typically used with Burst mode.

        :param slope: Select 'RISING' or 'FALLING' edge of external input signal (front panel BNC Input).
        :type slope: enum_trig_slope | str
        :param source: Select 'EXTERNAL' input (front panel BNC) or internal timer.
        :type source: enum_trig_source | str
        :param timer_sec: Set period of internal trigger source in seconds, range 1e-6 to 5e-3 seconds.
        :type timer_sec: float
        :return: Query form (no input parameters) returns dict of current settings. If any parameters are supplied,
            None is returned
        :rtype: dict | None
        """

        # TRIGger[:SEQuence]:SLOPe
        # TRIGger[:SEQuence]:SOURce
        # TRIGger[:SEQuence]:TIMer

        if all(v is None for v in {slope, source, timer_sec}):
            return_value = {}
            return_value.update(slope=self.query('TRIG:SLOP', self.enum_trig_slope).name)
            return_value.update(source=self.query('TRIG:SOUR', self.enum_trig_source).name)
            return_value.update(timer_sec=self.query('TRIG:TIM', float))
            return return_value

        slope = check_enum_str('slope', slope, self.enum_trig_slope)
        source = check_enum_str('source', source, self.enum_trig_source)

        if timer_sec is not None and not (
                self.bounds_timer_sec.MIN < timer_sec <= self.bounds_timer_sec.MAX):
            raise ValueError(f"Bad timer_sec {timer_sec}, should be {self.bounds_timer_sec.MIN} to "
                             f"{self.bounds_timer_sec.MAX} sec.")

        if slope is not None:
            self.write('TRIG:SLOP', slope.value)

        if source is not None:
            self.write('TRIG:SOUR', source.value)

        if timer_sec is not None:
            self.write('TRIG:TIM', timer_sec)

        self.log_inst_errors()

    def trig_force(self):
        """Forces a trigger event to occur."""

        # *TRG
        # TRIGger[:SEQuence] [:IMMediate]  # Seems to be a synonym for *TRG.

        self.write('*TRG', '')

    def trig_abort(self):
        """Resets any pending trigger sequences."""

        self.write('ABOR', '')


class Channel(SGChannel_ABC):
    """Implements the methods to control an output channel of AFG3252 signal generator."""

    enum_function_shapes = Enum('enum_function_shapes',
                                {'SINE': 'SIN', 'SQUARE': 'SQU', 'RAMP': 'RAMP', 'PULSE': 'PULS', 'SINC': 'SINC',
                                 'NOISE': 'PRN', 'DC': 'DC', 'GAUSSIAN': 'GAUS', 'LORENTZ': 'LOR', 'EXP_RISE': 'ERIS',
                                 'EXP_DECAY': 'EDEC', 'HAVERSINE': 'HAV',
                                 'USER1': 'USER1', 'USER2': 'USER2', 'USER3': 'USER3',  'USER4': 'USER4',
                                 'EDIT_MEM': 'EMEM', 'FILE': 'EFIL'})

    enum_run_modes = Enum('enum_run_modes',
                          {'CONTINUOUS': 'CONTINUOUS', 'MOD_AM': 'AM:STAT', 'MOD_FM': 'FM:STAT', 'MOD_PM': 'PM:STAT',
                           'MOD_FSK': 'FSK:STAT', 'MOD_PWM': 'PWM:STAT', 'SWEEP': 'SWE', 'BURST': 'BURS'}
                          )

    enum_amplitude_units = Enum('enum_amplitude_units', {'VPP': 'VPP', 'VRMS': 'VRMS', 'DBM': 'DBM'})
    enum_burst_mode = Enum('enum_burst_mode', {'TRIGGERED': 'TRIG', 'GATE': 'GAT'})

    enum_mod_source = Enum('enum_mod_source', {'INTERNAL': 'INT', 'EXTERNAL': 'EXT'})

    enum_mod_shapes = Enum('enum_mod_shapes', {
        'SINE': 'SIN', 'SQUARE': 'SQU', 'TRIANGLE': 'TRI', 'UP_RAMP': 'RAMP', 'DOWN_RAMP': 'NRAM', 'NOISE': 'PRN',
        'USER1': 'USER1', 'USER2': 'USER2', 'USER3': 'USER3', 'USER4': 'USER4',
        'EDIT_MEM': 'EMEM', 'FILE': 'EFIL'
    })

    enum_pulse_hold = Enum('enum_pulse_hold', {'WIDTH': 'WIDT', 'DUTY': 'DUTY'})

    enum_sweep_mode = Enum('enum_sweep_mode', {'AUTO': 'AUTO', 'MANUAL': 'MAN'})

    # Freq Sweep parameters
    bounds_freq_sweep_start_stop = min_max_units(1e-6, 1e8, 'Hz')

    enum_freq_sweep_spacing = Enum('enum_freq_sweep_spacing', {
        'LIN': 'LIN',
        'LOG': 'LOG'
    })
    enum_freq_sweep_mode = Enum('enum_freq_sweep_mode', {
        'TRIGGER': 'MAN',
        'REPEAT': 'AUTO'
    })
    bounds_freq_sweep_time = min_max_units(1e-3, 300, 'seconds')
    bounds_freq_hold_return_time = min_max_units(0, 300, 'seconds')

    def __init__(self, signal_generator, channel_name, channel_id, programming_bounds, enum_combine):
        super().__init__(signal_generator=signal_generator, channel_name=channel_name,
                         programming_bounds=programming_bounds)
        self.channel_id = channel_id

        # Define references to objects in the container object.
        self.log = signal_generator.log
        self.write = signal_generator.write
        self.query = signal_generator.query
        self.on_off = signal_generator.on_off
        self.log_inst_errors = signal_generator.log_inst_errors
        self.get_inst_errors = signal_generator.get_inst_errors
        self.arb_waveforms = signal_generator.arb_waveforms
        self.thumbdrive = signal_generator.thumbdrive

        self.enum_combine = enum_combine

        self.pulse_width_min = 4e-9

    def output_state(self, on_off=None):
        """Queries or sets the state (OFF or ON) of the AFG channel output.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """
        # OUTPut[1|2][:STATe] {ON|OFF|<NR1>}  set/query state of channel *if <NR1> != 0 then it enables the output*

        if on_off is None:
            return self.on_off.to_api(self.query(f'OUTP{self.channel_id}', int))

        self.write(f'OUTP{self.channel_id}', self.on_off.to_inst(on_off))

    def function_shape(self, shape=None, file_full_path=None):
        """
        Query or set shape of output waveform. Corresponds to front panel buttons in the Function group.

        :param shape: Select shape from the built-in functions: 'SINE', 'SQUARE', 'RAMP', 'PULSE', 'SINC', 'NOISE',
            'DC', 'GAUSSIAN', 'LORENTZ', 'EXP_RISE', 'EXP_DECAY', 'HAVERSINE'; or from the storage locations for
            user defined arbitrary waveforms: 'USER1', 'USER2', 'USER3', 'USER4', 'EDIT_MEM', 'FILE'.
        :type shape: enum_function_shapes | str
        :param file_full_path: When shape='FILE', this parameter specifies the full path from the root '/' of the
            thumb drive to the file to containing the waveform to be used. Use forward slashes or 'r' prefix to avoid
            misinterpretation of backslashes as escape characters. Typical waveform files have a .tfw extension.
        :type file_full_path: str
        :return: Query form (no input parameters) returns dict of current settings. If any parameters are supplied,
            None is returned.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:FUNCtion[:SHAPe] {SINusoid|SQUare|PULSe|RAMP|PRNoise|DC|SINC|GAUSsian|LORentz|ERISe|EDECay|
        #                                 HAVersine|USER[1]|USER2|USER3|USER4|EMEMory|EFILe}

        # Handle the pure query case.
        if all([v is None for v in (shape, file_full_path)]):
            return_values = {}
            return_values.update(shape=self.query(f'SOUR{self.channel_id}:FUNC', self.enum_function_shapes).name)
            # If thumbdrive is not inserted, file_full_path is read back as "". Special checking for this case below.
            return_values.update(file_full_path=self.query(f'SOUR{self.channel_id}:FUNC:EFIL', str).strip('"'))
            return return_values

        # Ok, we have some inputs to check...

        shape = check_enum_str('shape', shape, self.enum_function_shapes)
        if shape is None:
            shape_state = self.query(f'SOUR{self.channel_id}:FUNC', self.enum_function_shapes).name
        else:
            if match('USER\d?', shape.name) and shape.value in self.arb_waveforms.get_empty_locations():
                raise ValueError(f"Cannot choose arb_waveform location {shape.name}, it is empty.")
            shape_state = shape.name

        if file_full_path is not None:
            # User gave us a path, possibly a blank one from a readback without thumbdrive plugged in.
            if len(file_full_path) > 0:
                if not self.thumbdrive.file_exists(file_full_path):  # includes check for presence of thumb drive.
                    raise ValueError(f"File '{file_full_path}', not found in thumb_dir.")
                self.write(f'SOUR{self.channel_id}:FUNC:EFIL', f'"{PurePosixPath(file_full_path)}"')
            elif shape.name == 'FILE':
                raise ValueError("The file_full_path is blank, you must set it to use shape='FILE'.")
        else:
            file_full_path_state = self.query(f'SOUR{self.channel_id}:FUNC:EFIL', str).strip('"')
            # Can get a blank EFIL path if thumbdrive is unplugged.
            if shape_state == 'FILE' and len(file_full_path_state) == 0:
                raise ValueError("The file_full_path is blank, you must set it to use shape='FILE'.")

        if shape is not None:
            self.write(f'SOUR{self.channel_id}:FUNC', shape.value)

        self.signal_generator.log_inst_errors()

    def ramp_parameters(self, symmetry=None):
        """
        Query or set the symmetry parameters, applies only to the Ramp Function (waveform).

        :param symmetry: 0 to 100%. 0% is a negative going sawtooth wave, 50% is a triangel wave, 100% is positive
            going sawtooth wave.
        :type symmetry: float
        :return: Query returns a dict, setting returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:FUNCtion:RAMP:SYMMetry

        if symmetry is None:
            return_values = {}
            return_values.update(symmetry=self.query(f"SOUR{self.channel_id}:FUNC:RAMP:SYMM", float))
            return return_values

        if not(self.programming_bounds.ramp_symmetry_min <= symmetry <= self.programming_bounds.ramp_symmetry_max):
            raise ValueError(f"Bad symmetry {symmetry}, should be 0.0 to 100.0 %.")

        self.write(f"SOUR{self.channel_id}:FUNC:RAMP:SYMM", symmetry)

        self.log_inst_errors()

    def pulse_parameters(self, period=None, delay=None, duty=None, width=None, hold=None, leading_edge=None,
                         trailing_edge=None):
        """
        Query all or set any combination of the parameters that define the Pulse Function (waveform).

        Corresponds to the bezel button "Pulse Parameter Menu" that appears when the Pulse Function is selected.

        :param period: The number of seconds between pulse repetitions.
        :type period: float
        :param delay: Time offset (in seconds) of the leading edge of the pulse relative to the start of the period
            (CONTINUOUS mode) or from the Trigger/Gate signal (BURST mode). In Continuous value can be 0 to period. In
            BURST mode, upper limit is period - (width + 0.8 * (leading_edge + trailing_edge).
        :type delay: float
        :param duty: Duty cycle, the percent of the period occupied by the pulse. 0.001% to 99.999% also subject to
            same constraints as width.
        :type duty: float
        :param width: Width of pulse in seconds, subject to constraints:
            0.625 * ( leading_edge + trailing_edge) <= **width** <= period - 0.8 * (leading_edge + trailing_edge).
        :type width: float
        :param hold: Determines if 'WIDTH' or 'DUTY' cycle is held constant as period is changed.
        :type hold: enum_pulse_hold | str
        :param leading_edge: Transition time of leading edge in seconds.
        :type leading_edge: float
        :param trailing_edge: Transition time of trailing edge in seconds.
        :type trailing_edge: float
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:PULSe:DCYCle {<percent>|MINimum|MAXimum}
        # [SOURce[1|2]]:PULSe:DELay {<delay>|MINimum|MAXimum}
        # [SOURce[1|2]]:PULSe:HOLD {WIDTh|DUTY}
        # [SOURce[1|2]]:PULSe:PERiod {<period>|MINimum|MAXimum}
        # [SOURce[1|2]]:PULSe:TRANsition[:LEADing]
        # [SOURce[1|2]]:PULSe:TRANsition:TRAiling
        # [SOURce[1|2]]:PULSe:WIDTh {<seconds>|MINimum|MAXimum}

        if all([v is None for v in (period, delay, duty, width, hold, leading_edge, trailing_edge)]):
            return_values = {}
            return_values.update(period=self.query(f"SOUR{self.channel_id}:PULS:PER", float))
            return_values.update(delay=self.query(f"SOUR{self.channel_id}:PULS:DEL", float))
            return_values.update(duty=self.query(f"SOUR{self.channel_id}:PULS:DCYC", float))
            return_values.update(width=self.query(f"SOUR{self.channel_id}:PULS:WIDT", float))
            return_values.update(hold=self.query(f"SOUR{self.channel_id}:PULS:HOLD", self.enum_pulse_hold).name)
            return_values.update(leading_edge=self.query(f"SOUR{self.channel_id}:PULS:TRAN:LEAD", float))
            return_values.update(trailing_edge=self.query(f"SOUR{self.channel_id}:PULS:TRAN:TRA", float))
            return return_values

        period_state = period
        if period is not None:
            # Just a first order check, check later for compatibility of the period with other pulse parameters.
            period_min, period_max = 1.0 / self.programming_bounds.freq_max['PULSE'],\
                                     1.0 / self.programming_bounds.freq_min
            if not(period_min <= period <= period_max):
                raise ValueError(f"Bad period value, {period:.4E}, should be {period_min:.4E} to {period_max:.4E} sec.")
        else:
            period_state = self.query(f"SOUR{self.channel_id}:PULS:PER", float)

        leading_edge_state = leading_edge
        if leading_edge is not None:
            # Just a first order check, check later for compatibility of the edge with other pulse parameters.
            edge_min, edge_max = self.programming_bounds.edge_min, 0.625 * period_state
            if not(edge_min <= leading_edge <= edge_max):
                raise ValueError(f"Bad leading_edge {leading_edge:.4E}, should be {edge_min:.4E} to "
                                 f"{edge_max:.4E} sec. (Max is 0.625 * period.)")
        else:
            leading_edge_state = self.query(f"SOUR{self.channel_id}:PULS:TRAN:LEAD", float)

        trailing_edge_state = trailing_edge
        if trailing_edge is not None:
            # Just a first order check, check later for compatibility of the edge with other pulse parameters.
            edge_min, edge_max = self.programming_bounds.edge_min, 0.625 * period_state
            if not(edge_min <= trailing_edge <= edge_max):
                raise ValueError(f"Bad trailing_edge {trailing_edge:.4E}, should be {edge_min:.4E} to "
                                 f"{edge_max:.4E} sec. (Max is 0.625 * period.)")
        else:
            trailing_edge_state = self.query(f"SOUR{self.channel_id}:PULS:TRAN:TRA", float)

        # Width limits, see Programmer Manual, description of [SOURce[1|2]]:PULSe:WIDTh.
        width_min = 0.625 * (leading_edge_state + trailing_edge_state)
        width_max = period_state - 0.8 * (leading_edge_state + trailing_edge_state)

        # User can specify width or duty cycle.
        width_state = width
        if width is not None:
            if not(width_min <= width <= width_max):
                raise ValueError(f"Bad width {width:.4E}, should be {width_min:.4E} to {width_max:.4E} sec for period "
                                 f"and edge settings.")
        else:
            width_state = self.query(f"SOUR{self.channel_id}:PULS:WIDT", float)

        if duty is not None:
            duty_min = max(self.programming_bounds.duty_min, 100.0*width_min/period_state)
            duty_max = min(self.programming_bounds.duty_max, 100.0 * width_max / period_state)
            if not(duty_min <= duty <= duty_max):
                raise ValueError(f"Bad duty {duty:.4f} %, should be {duty_min:.3f} to {duty_max:.3f} % for current "
                                 f"period and edge settings.")
            width_state = (duty/100.0) * period_state

        # What if user didn't set width, but the combination of period, edges and existing width is illegal?
        if width_state < width_min:
            raise ValueError(f"Bad combination of leading and trailing edges and width. Width {width_state:.4E} "
                             f"< width_min {width_min:.4E} = 0.625 * (leading_edge + trailing_edge).")
        if width_state > width_max:
            raise ValueError(f"Bad combination of period, width and leading and trailing edges. Width "
                             f"{width_state:.4E} > width_max {width_max:.4E} = period -  0.8 * (leading_edge + "
                            "trailing_edge).")

        if width is not None and duty is not None:
            duty_calc = (width / period_state) * 100.0
            delta = abs(duty - duty_calc)
            if delta > 0.0005:
                raise ValueError(f"Conflicting values width {width} and duty {duty}. Must match within 0.001%.")

        hold = check_enum_str('hold', hold, self.enum_pulse_hold)

        delay_min = 0.0
        delay_max = period_state
        run_mode = self.run_mode()
        # CONTINUOUS means absence of modulation, sweep, or burst. Have to check enables for all of those,
        # so this kicks  off several queries.
        if run_mode != 'CONTINUOUS':
            delay_max -= width_state + 0.8 * (leading_edge_state + trailing_edge_state)

        delay_state = delay
        if delay is not None:
            if not(delay_min <= delay <= delay_max):
                raise ValueError(f"Bad delay {delay:.4E}, should be {delay_min:.4E} to {delay_max:.4E} sec for period, "
                "edge and width settings.")
        else:
            delay_state = self.query(f"SOUR{self.channel_id}:PULS:DEL", float)

        # What if user didn't set delay, but the combination of period, edges and existing delay is not allowed?
        if delay_state > delay_max:
            raise ValueError(f"Bad combination of period, leading and trailing edges and width. Delay "
                             f"{delay_state:.4E} > delay_max {delay_max:.4E} = period -  width 0.8 * (leading_edge + "
                             "trailing_edge).")

        if hold is not None:
            self.write(f"SOUR{self.channel_id}:PULS:HOLD", hold.value)
        if period is not None:
            self.write(f"SOUR{self.channel_id}:PULS:PER", period)
        if width is not None:
            self.write(f"SOUR{self.channel_id}:PULS:WIDT", width)
        if duty is not None:
            self.write(f"SOUR{self.channel_id}:PULS:DCYC", duty)
        if leading_edge is not None:
            self.write(f"SOUR{self.channel_id}:PULS:TRAN:LEAD", leading_edge)
        if trailing_edge is not None:
            self.write(f"SOUR{self.channel_id}:PULS:TRAN:TRA", trailing_edge)
        if delay is not None:
            self.write(f"SOUR{self.channel_id}:PULS:DEL", delay)

        self.log_inst_errors()

    def function_freq(self, freq_hz=None, concurrent=None, phase_deg=None):
        """
        Query or set the output frequency and phase.

        Corresponds to the bezel button "Frequency/Period/Phase Menu".

        :param freq_hz: Frequency of the generated waveform function in Hz.
        :type freq_hz: int | float
        :param concurrent: 'ON' means that the settings of this channel will be copied to the opposite channel.
        :type concurrent: Accepts any of the values defined as on or off, always returns 'ON' or 'OFF'.
        :param phase_deg: Adjusts output phase from -180 to +180 degrees.
        :type phase_deg: float
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:FREQuency[:CW|:FIXed]
        # [SOURce[1|2]]:FREQuency:CONCurrent[:STATe]
        # [SOURce[1|2]]:PHASe[:ADJust]

        if all([v is None for v in (freq_hz, concurrent, phase_deg)]):
            return_dict = {}
            tmp = self.query(f"SOUR{self.channel_id}:FREQ", float)
            return_dict.update(freq_hz=tmp)
            return_dict.update(concurrent=self.on_off.to_api(self.query(f"SOUR{self.channel_id}:FREQ:CONC", int)))
            tmp = self.query(f"SOUR{self.channel_id}:PHAS", float)
            return_dict.update(phase_deg=tmp*(180.0/math.pi))
            return return_dict

        if freq_hz is not None:
            freq_min = self.programming_bounds.freq_min
            shape = self.function_shape()['shape']
            arb_str = ''
            if match('USER\d?', shape) or shape in ('EDIT_MEM', 'FILE'):
                key = 'ARB'
                arb_str = 'ARB'
            elif shape not in self.programming_bounds.freq_max:
                key = 'OTHER'
            else:
                key = shape
            freq_max = self.programming_bounds.freq_max[key]
            if not (isinstance(freq_hz, (float, int)) and (freq_min <= freq_hz <= freq_max)):
                raise ValueError(f'Bad freq_hz {freq_hz} for {arb_str} function {shape}. Should be from {freq_min} Hz '
                                 f'to {freq_max} Hz.')

            if self.run_mode() == 'SWEEP':
                raise ValueError(f"Cannot program freq_hz while run_mode is 'SWEEP'.")
            elif self.run_mode() == 'BURST' and key == 'SINE':
                freq_min = self.programming_bounds.freq_sine_burst_min
                freq_max = self.programming_bounds.freq_sine_burst_max
                if not(freq_min <= freq_hz <= freq_max):
                    raise ValueError(f'Bad freq_hz {freq_hz} for function {key} in BURST mode. Should be from'
                                     f' {freq_min} Hz to {freq_max} Hz.')
            elif self.run_mode() == 'BURST' and key == 'ARB':
                freq_min = self.programming_bounds.freq_arb_burst_min
                freq_max = self.programming_bounds.freq_arb_burst_max
                if not(freq_min <= freq_hz <= freq_max):
                    raise ValueError(f'Bad freq_hz {freq_hz} for function {key} in BURST mode. Should be from'
                                     f' {freq_min} Hz to {freq_max} Hz.')

        concurrent = self.on_off.to_inst(concurrent)

        if phase_deg is not None:
            phase_min = self.programming_bounds.phase_min
            phase_max = self.programming_bounds.phase_max
            if not (isinstance(phase_deg, (float, int)) and (phase_min <= phase_deg <= phase_max)):
                raise ValueError(f'Bad phase_deg {phase_deg}. Should be from {phase_min} deg to {phase_max} deg.')

        if freq_hz is not None:
            self.write(f"SOUR{self.channel_id}:FREQ", freq_hz)

        if concurrent is not None:
            self.write(f"SOUR{self.channel_id}:FREQ:CONC", concurrent)

        if phase_deg is not None:
            self.write(f"SOUR{self.channel_id}:PHAS", phase_deg*math.pi/180.0)

        self.log_inst_errors()

    def phase_sync(self):
        """
        Synchronizes the phase of CH1 and CH2 output waveforms.

        Corresponds to the bezel button "Align Phase" when the "Frequency/Period/Phase Menu" is selected.

        :return: None

        """

        # [SOURce[1|2]]:PHASe:INITiate (No Query Form)

        self.write(f"SOUR{self.channel_id}:PHAS:INIT", "")

    def function_level(self, amplitude=None, offset=None, high_level=None, low_level=None, units=None, concurrent=None):
        """
        Query all or set any of the level related parameters of the generated function.

        Corresponds to the bezel button "Amplitude/Level Menu".

        :param amplitude: Output amplitude **at the load** in either the units presently selected in the AFG or passed
            in the units parameter. The value you program and what the AFG displays takes into account the voltage
            divider formed by the AFG output impedance (**always** 50 Ohms) in series with the load impedance you
            have programmed into the AFG. See method output, parameter load_z. The maximum amplitude that can
            be programmed depends on load_z: for the AFG3232 with load_z = 'INF' it is 10VPP (3.536VRMS for sine wave);
            for load_z=50 it is 5VPP (1.768VRMS for sine wave).
        :type amplitude: float
        :param offset: The DC offset voltage of the generated waveform. Not affected by choice of units.
        :type offset: float
        :param high_level: The waveform voltage maxima including offset. Not affected by choice of units.
        :type high_level: float
        :param low_level: The waveform voltage minima including offset. Not affected by choice of units.
        :type low_level: float
        :param units: Units of amplitude: 'VPP', 'VRMS', 'DBM'. Changing units does not modify the actual output,
            just how it is programmed and displayed. Does not effect offset, high_level or low_level. For example,
            if the output is presently a 1Vpp sine wave, changing units from 'VPP' to 'VRMS' to 'DBM' changes the AFG
            display from 1Vpp to 353.6mVrms to 3.979Bm without any change in the voltage across the load.  'DBM' is
            can only be selected for sine waves. Note that dBm also depends upon load_z and is referenced to 1mW.
        :type units: enum_amplitude_units | str
        :param concurrent: 'ON' means that the settings of this channel will be copied to the opposite channel.
        :type concurrent: Accepts any of the values defined as on or off, always returns 'ON' or 'OFF'.
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate][:AMPLitude]
        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate]:OFFSet
        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate]:HIGH
        # [SOURce[1|2]]:VOLTage[:LEVel][:IMMediate]:LOW
        # [SOURce[1|2]]:VOLTage:UNIT
        # [SOURce[1|2]]:VOLTage:CONCurrent[:STATe]

        if all([v is None for v in (amplitude, offset, high_level, low_level, units, concurrent)]):
            return_values = {}
            return_values.update(amplitude=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL", float))
            return_values.update(offset=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", float))
            return_values.update(high_level=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:HIGH", float))
            return_values.update(low_level=self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:LOW", float))
            return_values.update(units=self.query(f"SOUR{self.channel_id}:VOLT:UNIT", self.enum_amplitude_units).name)
            return_values.update(concurrent=self.on_off.to_api(self.query(f"SOUR{self.channel_id}:VOLT:CONC", int)))
            return return_values

        units = check_enum_str('units', units, self.enum_amplitude_units)

        if units is None:
            units_state = self.query(f"SOUR{self.channel_id}:VOLT:UNIT", self.enum_amplitude_units).name
        else:
            units_state = units.name

        shape_state = self.query(f'SOUR{self.channel_id}:FUNC', self.enum_function_shapes).name

        # Calculate voltage divider effect of load_z in combination with AFG output impedance which is always 50 Ohms.
        load_z = self.query(f"OUTP{self.channel_id}:IMP", float)
        ratio = 1.0 if load_z > 90e36 else (1.0 / (1.0 + 50.0 / load_z))
        load_z = 'INF' if load_z > 90e36 else load_z

        if units_state == 'DBM' and load_z == 'INF':
            raise ValueError(f"DBM units not allowed when load_z='INF'.")

        do_check = False
        if amplitude is not None:
            # Check amplitude vs. AFG amplitude bounds. Translate bounds into same units as instrument is using or
            # what the user is setting and scale for load impedance.
            do_check = True
            amplitude_min = amplitude_max = None  # Suppresses warning about uninitialized variable.
            if units_state == 'VPP':
                amplitude_min = self.programming_bounds.ampl_pp_hiz_min * ratio
                amplitude_max = self.programming_bounds.ampl_pp_hiz_max * ratio
            elif units_state == 'VRMS':
                if shape_state == 'SINE':
                    amplitude_min = self.programming_bounds.ampl_pp_hiz_min * ratio / (2.0 * math.sqrt(2.0))
                    amplitude_max = self.programming_bounds.ampl_pp_hiz_max * ratio / (2.0 * math.sqrt(2.0))
                elif shape_state == 'SQUARE':
                    amplitude_min = self.programming_bounds.ampl_pp_hiz_min * ratio / 2.0
                    amplitude_max = self.programming_bounds.ampl_pp_hiz_max * ratio / 2.0
                else:
                    do_check = False
                    self.log.warning(f"Driver cannot check amplitude VRMS for shape {shape_state}, only for 'SINE' and "
                                     f"'SQUARE'.")
            elif units_state == 'DBM':
                if shape_state != 'SINE':
                    raise ValueError(f"Units 'DBM' not allowed for function shape '{shape_state}'. 'SINE' only.")
                rms_min = self.programming_bounds.ampl_pp_hiz_min * ratio / (2.0 * math.sqrt(2.0))
                rms_max = self.programming_bounds.ampl_pp_hiz_max * ratio / (2.0 * math.sqrt(2.0))
                amplitude_min = 10.0 * math.log10((rms_min**2 / load_z) / 0.001)  # DBM is power relative to 1mW.
                amplitude_max = 10.0 * math.log10((rms_max**2 / load_z) / 0.001)

            if do_check and (amplitude_min is None or amplitude_max is None):
                raise RuntimeError("Program bug: amplitude_min or amplitude_max is None!")

            if do_check and not(amplitude_min <= amplitude <= amplitude_max):
                msg = f"Bad amplitude {amplitude:.3f} {units_state}, should be {amplitude_min:.3f} to "\
                      f" {amplitude_max:.3f} {units_state} into {load_z} Ohm load for {shape_state} wave."
                raise ValueError(msg)

        if offset is not None:
            # Check offset vs programming bounds.
            # Offset range is reduced by voltage divider effect of 50 Ohm output impedance and load_z.
            offset_max = self.programming_bounds.offset_hiz_max * ratio
            offset_min = self.programming_bounds.offset_hiz_min * ratio
            if not(offset_min <= offset <= offset_max):
                raise ValueError(f"Bad offset {offset:.3f}V, for load_z={load_z} Ohms, offset range is "
                                 f"{offset_min:.3f} to {offset_max:.3f}V.")

        do_check = False
        if amplitude is not None or offset is not None:
            amplitude_state = amplitude
            if amplitude_state is None:
                amplitude_state = self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL", float)

            offset_state = offset
            if offset_state is None:
                offset_state = self.query(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", float)

            amplitude_pk, do_check = self._calc_amplitude(amplitude_state, units_state, shape_state, load_z)

            if do_check:  # Could be false if amplitude_pk cannot be calculated for shape, units combination.
                v_pos_max = offset_state + amplitude_pk
                v_neg_min = offset_state - amplitude_pk

                msg = f"Bad combination of amplitude {amplitude_state:.3f} {units_state} and offset " \
                      f"{offset_state:.3f} V, will violate voltage "

                # Check vs programmed high,low limits set in output method.
                v_window_high = self.query(f"SOUR{self.channel_id}:VOLT:LIM:HIGH", float)
                v_window_low = self.query(f"SOUR{self.channel_id}:VOLT:LIM:LOW", float)
                if v_pos_max > v_window_high or v_neg_min < v_window_low:
                    raise ValueError(msg + f"limits {v_window_low:.3f} to {v_window_high:.3f} Vpk programed into AFG. "
                                           f"See output method.")

        if concurrent is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:CONC", self.on_off.to_inst(concurrent))
        if units is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:UNIT", units.value)

        if amplitude is not None and offset is not None:
            # Determine order of programming amplitude and offset so as to not violate the programmed output limits.
            # amplitude_pk is calculated above if amplitude is not None or offset is not None
            old_offset = self.query(f'SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS?', float)

            if do_check and ((old_offset + amplitude_pk) > v_window_high or (old_offset - amplitude_pk) < v_window_low):
                # Offset needs to be written first to avoid errors.
                self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", offset)
                self.write(f'SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL', amplitude)
            else:
                # Amplitude needs to be written first to avoid errors, it doesn't matter.
                self.write(f'SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL', amplitude)
                self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", offset)
        else:
            if amplitude is not None:
                self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:AMPL", amplitude)
            if offset is not None:
                self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:OFFS", offset)
        if high_level is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:HIGH", high_level)
        if low_level is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LEV:IMM:LOW", low_level)

        self.log_inst_errors()

    def _calc_amplitude(self, amplitude_state, units_state, shape_state, load_z):
        """Calculate the amplitude peak based off of what units are currently being used."""

        do_check = True

        # Convert amplitude to VPK
        if units_state == 'VPP':
            amplitude_pk = amplitude_state / 2.0
        elif units_state == 'VRMS':
            if shape_state == 'SINE':
                amplitude_pk = amplitude_state * math.sqrt(2.0)
            elif shape_state == 'SQUARE':
                amplitude_pk = amplitude_state
            else:
                do_check = False
                amplitude_pk = None
                self.log.warning(f"Driver cannot check voltage window with VRMS amplitude for shape"
                                 f" {shape_state}, only for 'SINE' and 'SQUARE'.")
        elif units_state == 'DBM':
            if shape_state != 'SINE':
                do_check = False
                self.log.warning(f"Driver cannot check voltage window with DBM amplitude for shape"
                                 f" {shape_state}, only for 'SINE' and 'SQUARE'.")

            amplitude_rms = math.sqrt(0.001 * load_z * 10 ** (amplitude_state / 10.0))
            amplitude_pk = amplitude_rms * math.sqrt(2.0)
        else:
            raise ValueError(f'Bad units_state: {units_state}. Should be "VPP", "VRMS", or "DBM"')

        return amplitude_pk, do_check

    def output(self, load_z=None, invert=None, high_limit=None, low_limit=None, combine=None, noise_percent=None):
        """
        Query all or set any of the parameters on the Output Menu of the AFG output channel.

        :param load_z: The impedance of your **LOAD**. The AFG uses this to display the amplitude, offset and
            high/low levels as they will appear at the load, taking into account the voltage divider formed by your load
            and the output impedance of the AFG which is **always** 50 Ohms. load_z can be 1 to 10,000 Ohms or 'INF'.
        :type load_z: (float | str)
        :param invert: If 'ON' waveform is inverted relative to the offset level. Query returns 'ON' or 'OFF'.
        :type invert: Can be any of the forms permitted by the OnOff class.
        :param high_limit: Setting an amplitude + offset value that would produce a positive going peak of the
            output more positive than this will cause an instrument error.
        :type high_limit: float
        :param low_limit: Setting an amplitude + offset value that would produce a negative going peak of the
            output more negative than this will cause an instrument error.
        :type low_limit: float
        :param combine: Controls if internally generated noise and/or external signal (Add Input BNC) are added to
            the output. Options are 'OFF', 'NOISE', 'EXTERNAL' and 'BOTH'. NOTE: 'EXTERNAL' and 'BOTH' are only valid on
            CH1.
        :type combine: str|enum_combine.
        :param noise_percent: The level of added noise as a percent of the current amplitude. Range is 0 to 50%.
        :type noise_percent: float
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # OUTPut[1|2]:IMPedance
        # OUTPut[1|2]:POLarity
        # [SOURce[1|2]]:VOLTage:LIMit:HIGH
        # [SOURce[1|2]]:VOLTage:LIMit:LOW
        # [SOURce[1|2]]:COMBine:FEED
        # SOURce<3|4>:POWer[:LEVel][:IMMediate][:AMPLitude]

        if all([v is None for v in (load_z, invert, high_limit, low_limit, combine, noise_percent)]):
            return_values = {}
            tmp = self.query(f"OUTP{self.channel_id}:IMP", float)
            return_values.update(load_z='INF' if tmp > 90e36 else tmp)
            tmp = {'NORM': '0', 'INV': '1'}[self.query(f"OUTP{self.channel_id}:POL", str)]  # See comment below.
            return_values.update(invert=self.on_off.to_api(tmp))
            return_values.update(high_limit=self.query(f"SOUR{self.channel_id}:VOLT:LIM:HIGH", float))
            return_values.update(low_limit=self.query(f"SOUR{self.channel_id}:VOLT:LIM:LOW", float))
            return_values.update(combine=self.query(f"SOUR{self.channel_id}:COMB:FEED", self.enum_combine).name)
            return_values.update(noise_percent=self.query(f"SOUR{self.channel_id+2}:POW:LEV:IMM:AMPL", float))
            return return_values

        if load_z is not None:
            if not(isinstance(load_z, (int, float)) and
                self.programming_bounds.load_z_min <= load_z <= self.programming_bounds.load_z_max
                    or load_z == 'INF'):
                raise ValueError(f"Bad load_z {load_z}, should be 1.0 to 10000.0 Ohms or 'INF'.")
            load_z_state = load_z
        else:
            load_z_state = self.query(f"OUTP{self.channel_id}:IMP", float)

        if load_z_state == 'INF' or load_z_state > 90e36:
            limit = self.programming_bounds.voltage_window_hiz_max
        else:
            limit = self.programming_bounds.voltage_window_hiz_max * load_z_state/(load_z_state+50.0)

        # This is weird because we want use ON/OFF values for two reasons. AFG GUI uses on/off and previous versions of
        # this driver did too. Problem is instrument API uses 'NORM' and 'INV'.
        invert = self.on_off.to_inst(invert)
        if invert is not None:
            invert = {'0': 'NORM', '1': 'INV'}[invert]

        if high_limit is not None:
            if not (-1.*limit <= high_limit <= limit):
                raise ValueError(f"Bad high_limit {high_limit}, must be {-1.0*limit} to {limit} V.")
            high_limit_state = high_limit
        else:
            high_limit_state = self.query(f"SOUR{self.channel_id}:VOLT:LIM:HIGH", float)

        if low_limit is not None:
            if not (-1.*limit <= low_limit <= limit):
                raise ValueError(f"Bad low_limit {low_limit}, must be {-1.0*limit} to {limit} V.")
            low_limit_state = low_limit
        else:
            low_limit_state = self.query(f"SOUR{self.channel_id}:VOLT:LIM:LOW", float)

        if not(low_limit_state < high_limit_state):
            raise ValueError(f"Bad limits. low_limit ({low_limit}) must be <= high_limit {high_limit}.")

        combine = check_enum_str('combine', combine, self.enum_combine)

        if noise_percent is not None:
            if not (0.0 <= noise_percent <= self.programming_bounds.noise_percent_max):
                raise ValueError(f"Bad noise_percent {noise_percent:.1f}, should be 0.0 to "
                                 f"{self.programming_bounds.noise_percent_max:.1f} %.")

        if load_z is not None:
            self.write(f"OUTP{self.channel_id}:IMP", load_z)
        if invert is not None:
            self.write(f"OUTP{self.channel_id}:POL", invert)
        if high_limit is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LIM:HIGH", high_limit)
        if low_limit is not None:
            self.write(f"SOUR{self.channel_id}:VOLT:LIM:LOW", low_limit)
        if combine is not None:
            self.write(f"SOUR{self.channel_id}:COMB:FEED", combine.value)
        if noise_percent is not None:
            self.write(f"SOUR{self.channel_id+2}:POW:LEV:IMM:AMPL", noise_percent)

        self.log_inst_errors()

    def run_mode(self, mode=None):
        """
        Query or set the AFG Run Mode.

        Corresponds to the "Run Mode buttons on AFG front panel, except it does not mimic the Modulation button which
        re-enables the last modulation that was in effect. This is due to limitations of the SCPI commands.

        :param mode: Choose 'CONTINUOUS', 'MOD_AM', 'MOD_FM', 'MOD_FSK', 'MOD_PM', 'MOD_PWM', 'SWEEP' or 'BURST. Note
            that the presently chosen Function define some restrictions
        :type mode: enum_run_modes | str
        :return: returns name of present mode.
        :rtype: str
        """

        # The AFG run mode related scpi commands work in a way that makes it not straight forward to implement an
        # API that mimics the front panel operation. On the front panel the 4 run mode buttons (Continuous, Modulation,
        # Sweep and Burst) operate in a mutually exclusive manner. Pressing modulation re-enables what ever kind of
        # modulation was last in effect.
        #
        # CONTINUOUS is not actually a mode, it is the absence of any Modulation, Sweep, or Burst.
        # Each modulation (AM, FM, PM, FSK, PWM) and Burst has it's own state bit, but only one can be set at a time.
        # Setting any one of those resets all the others. Sweep is setup through the FREQ:MODE command and setting it to
        # 'SWEep' also clears any modulation state bit or burst state bit that is set.

        if mode is None:
            # If any modulation or burst is active then one (and only one) of the STATE bits will be 1.
            for v in self.enum_run_modes.__members__.values():
                if v.name in ('CONTINUOUS', 'SWEEP'):
                    continue
                state = self.query(f'SOUR{self.channel_id}:{v.value}', int)
                if state:
                    return v.name

            # OK, there isn't any modulation or BURST active, let's check SWEEP
            state = self.query(f'SOUR{self.channel_id}:FREQ:MODE', str)
            if state == 'SWE':
                return 'SWEEP'
            else:  # state is either 'CW' or 'FIX'
                return 'CONTINUOUS'

        mode = check_enum_str('mode', mode, self.enum_run_modes)

        shape = self.function_shape()['shape']

        if shape == 'PULSE':
            if mode.name in ('SWEEP', 'MOD_AM', 'MOD_FM', 'MOD_FSK', 'MOD_PM'):
                raise ValueError(f"Run mode cannot be '{mode.name}' for present function {shape}. Choose mode "
                                 f"'CONTINUOUS', 'BURST', or 'MOD_PWM'.")

        if shape in ('NOISE', 'DC'):
            if mode.name != 'CONTINUOUS':
                raise ValueError(f"Run mode cannot be '{mode.name}' for present function '{shape}'. Only mode "
                                 f"'CONTINUOUS' is allowed.")

        if shape != 'PULSE' and mode.name == 'MOD_PWM':
            raise ValueError(f"Run mode cannot be '{mode.name}' for present function '{shape}'. 'MOD_PWM' only " 
                             f"allowed for function {shape}")

        if mode.name in ('CONTINUOUS', 'SWEEP'):
            mode_command = 'FREQ:MODE'
            if mode.name == 'SWEEP':
                mode_value = 'SWE'
            else:
                mode_value = 'CW'
        else:
            mode_command = mode.value
            mode_value = 1

        if mode is not None:
            self.write(f'SOUR{self.channel_id}:{mode_command}', f'{mode_value}')

        self.log_inst_errors()

    def config_am(self, freq_hz=None, shape=None, source=None, depth_percent=None, file_full_path=None):
        """
        Query or set the Amplitude Modulation (AM) parameters.

        :param freq_hz: The frequency in Hz of the modulating signal. Only applies if source = 'INTERNAL'
        :type freq_hz: float
        :param shape: The shape of the modulating signal. Only applies if source = 'INTERNAL'. Choices are:
            'SINE', 'SQUARE', 'TRIANGLE', 'RAMP', 'NRAMP', 'PRNOISE', 'USER1', 'USER2', 'USER3', 'USER4',
            'EDIT_MEM', 'FILE'.
        :type shape: enum_mod_shapes | str
        :param source: Where the modulating signal comes from. With 'INTERNAL' the freq_hz and shape parameters are in
            control; with 'EXTERNAL' selects the BNC on the rear panel corresponding to the channel. The freq_hz and
            shape parameters play no role.
        :type source: enum_mod_source | str
        :param depth_percent: Modulation depth, 0 % to 120.0 % with 0.1% resolution.
        :type depth_percent: float
        :param file_full_path: When shape='FILE', this parameter specifies the full path from the root '/' of the
            thumb drive to the file to containing the waveform to be used. Use forward slashes or 'r' prefix to avoid
            misinterpretation of backslashes as escape characters. Typical waveform files have a .tfw extension.
        :type file_full_path: str
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:AM:DEPTh]
        # [SOURce[1|2]]:AM:INTernal:FREQuency
        # [SOURce[1|2]]:AM:INTernal:FUNCtion
        # [SOURce[1|2]]:AM:INTernal:FUNCtion:EFILe
        # [SOURce[1|2]]:AM:SOURce

        tmp = self._config_mod('AM', self._check_am_depth, 'DEPT', freq_hz, shape, source, depth_percent,
                               file_full_path)

        # self.log_unused_args(args, kwargs)

        if tmp is not None:
            # Convert the dict key for mod_param while preserving the order.
            return dict(('depth_percent', value) if name == 'mod_param' else (name, value)
                        for name, value in tmp.items())

    def _check_am_depth(self, depth_percent):
        """Helper method for _config_mod in case of AM modulation"""

        if depth_percent is not None:
            if not(0.0 <= depth_percent <= self.programming_bounds.am_depth_percent_max):
                raise ValueError(f"Bad depth_percent {depth_percent}, must be 0 to "
                                 f"{self.programming_bounds.am_depth_percent_max}%.")

    def config_fm(self, freq_hz=None, shape=None, source=None, deviation=None, file_full_path=None):
        """
        Query or set the Frequency Modulation (FM) parameters.

        :param freq_hz: The frequency in Hz of the modulating signal. Only applies if source = 'INTERNAL'
        :type freq_hz: float
        :param shape: The shape of the modulating signal. Only applies if source = 'INTERNAL'. Choices are:
            'SINE', 'SQUARE', 'TRIANGLE', 'RAMP', 'NRAMP', 'PRNOISE', 'USER1', 'USER2', 'USER3', 'USER4',
            'EDIT_MEM', 'FILE'.
        :type shape: enum_mod_shapes | str
        :param source: Where the modulating signal comes from. With 'INTERNAL' the freq_hz and shape parameters are in
            control; with 'EXTERNAL' selects the BNC on the rear panel corresponding to the channel. The freq_hz and
            shape parameters play no role.
        :type source: enum_mod_source | str
        :param deviation: The peak frequency deviation of the FM modulation in Hz. 0 to 120e6 Hz.
        :type deviation: float
        :param file_full_path: When shape='FILE', this parameter specifies the full path from the root '/' of the
            thumb drive to the file to containing the waveform to be used. Use forward slashes or 'r' prefix to avoid
            misinterpretation of backslashes as escape characters. Typical waveform files have a .tfw extension.
        :type file_full_path: str
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:FM [:DEViation]
        # [SOURce[1|2]]:FM:INTernal:FREQuency
        # [SOURce[1|2]]:FM:INTernal:FUNCtion
        # [SOURce[1|2]]:FM:INTernal:FUNCtion:EFILe
        # [SOURce[1|2]]:FM:SOURce

        tmp = self._config_mod('FM', self._check_fm_deviation, 'DEV', freq_hz, shape, source, deviation, file_full_path)

        # self.log_unused_args(args, kwargs)

        if tmp is not None:
            # Convert the dict key for mod_param while preserving the order.
            return dict(('deviation', value) if name == 'mod_param' else (name, value) for name, value in tmp.items())

    def _check_fm_deviation(self, deviation):
        """Helper method for _config_mod in case of FM modulation"""

        if deviation is not None:
            carrier_freq = self.query(f"SOUR{self.channel_id}:FREQ", float)
            if not(0.0 <= deviation <= min(carrier_freq, self.programming_bounds.fm_deviation_max)):
                raise ValueError(f"Bad deviation {deviation}, must be 0 to carrier frequency {carrier_freq} Hz or "
                                 f"{self.programming_bounds.fm_deviation_max} Hz, whichever is less.")

    def config_pm(self, freq_hz=None, shape=None, source=None, deviation=None, file_full_path=None):
        """
        Query all or set any of the Phase Modulation (PM) parameters.

        :param freq_hz: The frequency in Hz of the modulating signal. Only applies if source = 'INTERNAL'
        :type freq_hz: float
        :param shape: The shape of the modulating signal. Only applies if source = 'INTERNAL'. Choices are:
            'SINE', 'SQUARE', 'TRIANGLE', 'RAMP', 'NRAMP', 'PRNOISE', 'USER1', 'USER2', 'USER3', 'USER4',
            'EDIT_MEM', 'FILE'.
        :type shape: enum_mod_shapes | str
        :param source: Where the modulating signal comes from. With 'INTERNAL' the freq_hz and shape parameters are in
            control; with 'EXTERNAL' selects the BNC on the rear panel corresponding to the channel. The freq_hz and
            shape parameters play no role.
        :type source: enum_mod_source | str
        :param deviation: The peak phase deviation of the PM modulation. 0 to +180 degree, 1 degree resolution.
        :type deviation: float
        :param file_full_path: When shape='FILE', this parameter specifies the full path from the root '/' of the
            thumb drive to the file to containing the waveform to be used. Use forward slashes or 'r' prefix to avoid
            misinterpretation of backslashes as escape characters. Typical waveform files have a .tfw extension.
        :type file_full_path: str
        :return: Query form returns a dict of all parameters and values. Setting form returns None.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:PM [:DEViation]
        # [SOURce[1|2]]:PM:INTernal:FREQuency
        # [SOURce[1|2]]:PM:INTernal:FUNCtion
        # [SOURce[1|2]]:PM:INTernal:FUNCtion:EFILe
        # [SOURce[1|2]]:PM:SOURce

        if deviation is not None:
            deviation = deviation * math.pi / 180.0  # AFG is programmed in radians but displays degrees!

        tmp = self._config_mod('PM', self._check_pm_deviation, 'DEV', freq_hz, shape, source, deviation,
                               file_full_path)

        # self.log_unused_args(args, kwargs)

        if tmp is not None:
            # Convert the dict key for mod_param while preserving the order.
            return dict(('deviation', round(value*180.0/math.pi, 2))
                if name == 'mod_param' else (name, value) for name, value in tmp.items())

    def _check_pm_deviation(self, deviation_rads):
        """Helper method for _config_mod in case of PM modulation"""

        # We want limit defined in degrees and error messages to display degrees to match AFG front panel.
        if deviation_rads is not None:
            deviation_deg = round(deviation_rads*180.0/math.pi, 2)
            if not (0.0 <= deviation_deg <= self.programming_bounds.pm_deviation_max):
                raise ValueError(f"Bad deviation {deviation_deg}, must be 0 to "
                                 f"{self.programming_bounds.pm_deviation_max} degrees.")

    def config_pwm(self, freq_hz=None, shape=None, source=None, deviation=None, file_full_path=None):
        """
        Query or set Pulse Width Modulation (PM) parameters. Can only be applied when Function selection is Pulse.

        :param freq_hz: The frequency in Hz of the modulating signal. Only applies if source = 'INTERNAL'
        :type freq_hz: float
        :param shape: The shape of the modulating signal. Only applies if source = 'INTERNAL'. Choices are:
            'SINE', 'SQUARE', 'TRIANGLE', 'RAMP', 'NRAMP', 'PRNOISE', 'USER1', 'USER2', 'USER3', 'USER4',
            'EDIT_MEM', 'FILE'.
        :type shape: enum_mod_shapes | str
        :param source: Where the modulating signal comes from. With 'INTERNAL' the freq_hz and shape parameters are in
            control; with 'EXTERNAL' selects the BNC on the rear panel corresponding to the channel. The freq_hz and
            shape parameters play no role.
        :type source: enum_mod_source | str
        :param deviation: The pulse width deviation as a % of the pulse period (aka duty cycle). 0.0 % to a
            maximum determined by a number of constraints the depend on the pulse parameters. See the description in
            the Programming Manual for the SCPI command "[SOURce[1|2]]:PWM[:DEViation]:DCYCle".
        :type deviation: float
        :param file_full_path: When shape='FILE', this parameter specifies the full path from the root '/' of the
            thumb drive to the file to containing the waveform to be used. Use forward slashes or 'r' prefix to avoid
            misinterpretation of backslashes as escape characters. Typical waveform files have a .tfw extension.
        :type file_full_path: str
        :return: Query form returns a dict of all parameters and values. Returns None if anything is set.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:PWM[:DEViation]:DCYCle {<percent>|MINimum|MAXimum}   # NOTE Complicated limits!
        # [SOURce[1|2]]:PWM:INTernal:FREQuency {<frequency>|MINimum|MAXimum}
        # [SOURce[1|2]]:PWM:INTernal:FUNCtion {SINusoid|SQUare|TRIangle|RAMP|NRAMp|PRNoise|
        #   USER[1]|USER2|USER3|USER4|EMEMory[1]|EMEMory2|EFILe}
        # [SOURce[1|2]]:PWM:INTernal:FUNCtion:EFILe <file_name>
        # [SOURce[1|2]]:PWM:SOURce [INTernal|EXTernal]

        tmp = self._config_mod('PWM', self._check_pwm_deviation, 'DCYC', freq_hz, shape, source, deviation,
                               file_full_path)

        # self.log_unused_args(args, kwargs)

        if tmp is not None:
            # Convert the dict key for mod_param while preserving the order.
            return dict(
                ('deviation', value) if name == 'mod_param' else (name, value) for name, value in tmp.items())

    def _check_pwm_deviation(self, deviation):
        if deviation is not None:
            # See Programming Manual description for SCPI command "[SOURce[1|2]]:PWM[:DEViation]:DCYCle".
            # Also, verified by experiment.
            width = self.query(f"SOUR{self.channel_id}:PULS:WIDT", float)
            period = self.query(f"SOUR{self.channel_id}:PULS:PER", float)
            edges_sum = self.query(f"SOUR{self.channel_id}:PULS:TRAN:LEAD", float)
            edges_sum += self.query(f"SOUR{self.channel_id}:PULS:TRAN:TRA", float)
            d1 = width - self.pulse_width_min
            d2 = period - width - self.pulse_width_min
            d3 = width - 0.8 * edges_sum
            d4 = period - width - 0.8 * edges_sum

            # If it seems weird that deviation is % of period, see spec sheet. Also, note that SCPI cmd is DCYC which
            # is duty cycle, which is as a % of period.
            dev_max = min(d1, d2, d3, d4) * 100 / period
            if not (0.0 <= deviation <= dev_max):
                raise ValueError(f"Bad deviation {deviation:.1f} %, must be 0 to {dev_max:.4f} % of pulse period, "
                                 f"considering present period, width, and edge transition times.")

    def _config_mod(self, mod_type, mod_param_checker, mod_param_scpi, freq_hz, shape, source, mod_param,
                    file_full_path):
        """
        Generic method to implement AM, FM, PM, PWM.

        :param freq_hz:
        :type freq_hz:
        :param shape:
        :type shape:
        :param source:
        :type source:
        :param mod_param:
        :type mod_param:
        :return: Query form returns a dict of all parameters and values. Returns None if anything is set.
        :rtype: dict | None
        """

        if all(v is None for v in {freq_hz, shape, source, mod_param, file_full_path}):
            return_value = {}
            return_value.update(freq_hz=self.query(f"SOUR{self.channel_id}:{mod_type}:INT:FREQ", float))
            return_value.update(shape=self.query(f"SOUR{self.channel_id}:{mod_type}:INT:FUNC",
                                                 self.enum_mod_shapes).name)
            return_value.update(source=self.query(f"SOUR{self.channel_id}:{mod_type}:SOUR", self.enum_mod_source).name)
            return_value.update(mod_param=self.query(f"SOUR{self.channel_id}:{mod_type}:{mod_param_scpi}", float))
            return_value.update(file_full_path=self.query(f'SOUR{self.channel_id}:{mod_type}:INT:FUNC:EFIL',
                                                          str).strip('"'))
            return return_value

        source = check_enum_str('source', source, self.enum_mod_source)
        source_state = source
        if source is None:
            source_state = self.query(f"SOUR{self.channel_id}:{mod_type}:SOUR", self.enum_mod_source)

        shape = check_enum_str('shape', shape, self.enum_mod_shapes)
        if shape is None:
            shape_state = self.query(f"SOUR{self.channel_id}:{mod_type}:INT:FUNC", self.enum_mod_shapes).name
        else:
            if source_state.name == 'EXTERNAL':
                raise ValueError(f"Cannot set shape '{shape.name}' when source is '{source_state.name}'. Must be "
                                 f"'INTERNAL' to set shape.")
            else:
                # If shape is one of the USER locations, it must not be an empty location.
                if match('USER\d?', shape.name) and shape.value in self.arb_waveforms.get_empty_locations():
                    raise ValueError(f"Cannot choose arb_waveform location {shape.name} for modulation shape, "
                                     f"it is empty.")
                shape_state = shape.name

        if file_full_path is not None:
            # User gave us a path, possibly a blank one from a read back without thumbdrive plugged in.
            if len(file_full_path) > 0:
                if not self.thumbdrive.file_exists(file_full_path):  # includes check for presence of thumb drive.
                    raise ValueError(f"File '{file_full_path}', not found in thumb_dir.")
            elif shape.name == 'FILE':
                raise ValueError("The file_full_path is blank, you must set it to use function='FILE'.")
        else:
            file_full_path_state = self.query(f'SOUR{self.channel_id}:{mod_type}:INT:FUNC:EFIL', str).strip('"')
            # Can get a blank EFIL path if thumbdrive is unplugged.
            if shape_state == 'FILE' and len(file_full_path_state) == 0:
                raise ValueError("The file_full_path is blank, you must set it to use function='FILE'.")

        if freq_hz is not None:
            if source_state.name == "EXTERNAL":
                raise ValueError(f"Cannot set freq_hz when source is {source_state.name}. Must be 'INTERNAL' to set "
                             f"freq_hz.")
            if not(self.programming_bounds.mod_freq_internal_min <= freq_hz <=
                   self.programming_bounds.mod_freq_internal_max):
                raise ValueError(f"Bad freq_hz {freq_hz}, must be {self.programming_bounds.mod_freq_internal_min } to "
                                 f"{self.programming_bounds.mod_freq_internal_max } Hz.")

        if mod_param_checker is not None:
            mod_param_checker(mod_param)

        if source is not None:
            self.write(f"SOUR{self.channel_id}:{mod_type}:SOUR", source.value)

        if freq_hz is not None:
            self.write(f"SOUR{self.channel_id}:{mod_type}:INT:FREQ", freq_hz)

        if file_full_path is not None and len(file_full_path) > 0:
            self.write(f'SOUR{self.channel_id}:{mod_type}:INT:FUNC:EFIL', f'"{PurePosixPath(file_full_path)}"')

        if shape is not None:
            self.write(f"SOUR{self.channel_id}:{mod_type}:INT:FUNC", shape.value)

        if mod_param is not None:
            self.write(f"SOUR{self.channel_id}:{mod_type}:{mod_param_scpi}", mod_param)

        self.log_inst_errors()

    def config_fsk(self, rate_hz=None, source=None, hop_freq_hz=None):
        """
        Query or set the Frequency Shift Keying (FSK) parameters.

        :param rate_hz: The rate of toggling between the two output frequencies. Can only be set if source is
            'INTERNAL'. This signal is output on the Trigger Output BNC on the front panel.
        :type rate_hz: float
        :param source: 'INTERNAL' rate_hz determines the rate of toggling between the usual output frequency and the
            hop_freq_z. If 'EXTERNAL' this selected, the rate of toggling is determined by the signal input on the
            External Modulation Input BNC on the rear panel.
        :type source: enum_mod_source | str
        :param hop_freq_hz: The output frequency when the Trigger signal is high.
        :type hop_freq_hz: float
        :return: Query form returns a dict of all parameters and values. Returns None if anything is set.
        :rtype: dict | None
        """

        # Note that FSK has several fundamental differences from AM, FM, PM, PWM that make it
        # not feasible to use the generic _config_mode method. There is no shape parameter because the INTERNAL
        # source is square wave only. This message signal toggles between 0 and 1 at a frequency set by the RATE cmd.
        # In the other modulations the message signal was controlled by the FREQ cmd. In FSK, the FREQ cmd sets the hop
        # frequency or the carrier frequency for a 1 vs a 0. This seems more akin to depth or deviation in the other
        # modulations.

        # [SOURce[1|2]]:FSKey[:FREQuency] {<frequency>|MINimum|MAXimum}  # The hop freq, not the rate!
        # [SOURce[1|2]]:FSKey:SOURce [INTernal|EXTernal]
        # [SOURce[1|2]]:FSKey:INTernal:RATE {<rate>|MINimum|MAXimum}

        if all(v is None for v in {rate_hz, source, hop_freq_hz}):
            return_value = {}
            return_value.update(rate_hz=self.query(f"SOUR{self.channel_id}:FSK:INT:RATE", float))
            return_value.update(source=self.query(f"SOUR{self.channel_id}:FSK:SOUR", self.enum_mod_source).name)
            return_value.update(hop_freq_hz=self.query(f"SOUR{self.channel_id}:FSK:FREQ", float))
            return return_value

        source = check_enum_str('source', source, self.enum_mod_source)
        source_state = source
        if source is None:
            source_state = self.query(f"SOUR{self.channel_id}:FSK:SOUR", self.enum_mod_source).name

        if rate_hz is not None:
            if source_state == "EXTERNAL":
                raise ValueError(f"Cannot set rate_hz when source is {source_state}. Must be 'INTERNAL' to set "
                                 f"rate_hz.")
            if not (self.programming_bounds.fsk_keyrate_min <= rate_hz <= self.programming_bounds.fsk_keyrate_max):
                raise ValueError(f"Bad rate_hz {rate_hz}, must be {self.programming_bounds.fsk_keyrate_min} to "
                                 f"{self.programming_bounds.fsk_keyrate_max} Hz.")

        if hop_freq_hz is not None:
            if not (0.0 <= hop_freq_hz <= self.programming_bounds.hop_freq_hz_max):
                raise ValueError(
                    f"Bad hop_freq_hz {hop_freq_hz}, must be 0 to {self.programming_bounds.hop_freq_hz_max} Hz.")

        if source is not None:
            self.write(f"SOUR{self.channel_id}:FSK:SOUR", source.value)

        if rate_hz is not None:
            self.write(f"SOUR{self.channel_id}:FSK:INT:RATE", rate_hz)

        if hop_freq_hz is not None:
            self.write(f"SOUR{self.channel_id}:FSK:FREQ", hop_freq_hz)

        self.log_inst_errors()

    def config_burst(self, mode=None, ncycles=None, tdelay_sec=None):
        """
        Query all or set any of the Burst Mode parameters.

        :param mode: 'TRIGGERED' generates burst when trigger edge occurs. Triggers can be internally, externally or
            manually generated. See trigger_config. 'GATE' outputs the burst while the trigger signal is in the
            active state.
        :type mode: enum_burst_mode | str
        :param ncycles: Number of cycles in the burst, 1 to 1,000,000 or 'INF'.
        :type ncycles: float | str
        :param tdelay_sec: Time in seconds to delay the start of the burst from the trigger edge.
        :type tdelay_sec: float
        :return: Query form returns a dict of all parameters and values. Returns None if anything is set.
        :rtype: dict | None
        """

        # [SOURce[1|2]]:BURSt:MODE
        # [SOURce[1|2]]:BURSt:NCYCles
        # [SOURce[1|2]]:BURSt:TDELay
        # [SOURce[1|2]]:BURSt [:STATe]

        if all(v is None for v in {mode, ncycles, tdelay_sec}):
            return_value = {}
            return_value.update(mode=self.query(f'SOUR{self.channel_id}:BURS:MODE', self.enum_burst_mode).name)
            tmp = int(self.query(f'SOUR{self.channel_id}:BURS:NCYC', float))
            return_value.update(ncycles='INF' if tmp > 90e36 else tmp)
            return_value.update(tdelay_sec=self.query(f'SOUR{self.channel_id}:BURS:TDEL', float))
            return return_value

        mode = check_enum_str('mode', mode, self.enum_burst_mode)

        if ncycles is not None:
            if not ((isinstance(ncycles, (float, int)) and
                     self.programming_bounds.burst_ncycles_min <= ncycles <= self.programming_bounds.burst_ncycles_max)
                    or ncycles == 'INF'):
                raise ValueError(f"Bad ncycles {ncycles}. Should be from {self.programming_bounds.burst_ncycles_min} "
                                 f"to {self.programming_bounds.burst_ncycles_max} or 'INF'.")

        if tdelay_sec is not None:
            if not (isinstance(tdelay_sec, (float, int)) and
                    (0 <= tdelay_sec <= self.programming_bounds.burst_tdelay_sec_max)):
                raise ValueError(f"Bad tdelay_sec {tdelay_sec}. Should be from 0 to "
                                 f"{self.programming_bounds.burst_tdelay_sec_max} sec.")

        if mode is not None:
            self.write(f'SOUR{self.channel_id}:BURS:MODE', mode.value)
        if ncycles is not None:
            self.write(f'SOUR{self.channel_id}:BURS:NCYC', int(ncycles))
        if tdelay_sec is not None:
            self.write(f'SOUR{self.channel_id}:BURS:TDEL', tdelay_sec)

    def config_sweep(self, start_freq: Union[int, float] = None, stop_freq: Union[int, float] = None,
                     sweep_spacing: Union[int, float] = None, mode: str = None, sweep_time: Union[int, float] = None,
                     hold_time: Union[int, float] = None, return_time: Union[int, float] = None):
        """
        Configure parameters for sweeping the frequency.

        Corresponds to selecting the Sweep button in the Run Mode section and all the display interactions in this mode.

        :param start_freq: Frequency to begin sweep at. Ranges from 1e-6Hz to 100MHz.
        :type start_freq: int|float
        :param stop_freq: Frequency to end sweep at. Ranges from 1e-6Hz to 100MHz.
        :type stop_freq: int|float
        :param sweep_spacing: Change frequency spacing between linear and logarithmic. Accepts:

            * 'LIN'
            * 'LOG'

        :type sweep_spacing: str|enum_freq_sweep_spacing
        :param mode: Change the mode in which the sweep operates between auto and manual. In auto mode, the sweep
            continuously repeat itself from beginning to end at the specified sweep time, hold time, and return time.
            Manual will allow single run through of a sweep caused by a trigger event. Trigger events can be internal
            or external depending on the configuration in the trig_config() method for instrument. Accepts:

            * 'TRIGGER' - Requires trigger event for sweep to initiate.
            * 'REPEAT' - Continuously repeat sweep.

        :type mode: str|enum_freq_sweep_mode
        :param sweep_time: How long it takes to complete a single sweep. Does not include hold or return time.
        :type sweep_time: int|float
        :param hold_time: Duration for sweep to remain on stop frequency. Ranges from 0 to 300 seconds.
        :type hold_time: int|float
        :param return_time: The duration it takes for sweep to return to start frequency from stop frequency. If return
            time is greater than 0, the sweep will traverse backwards through all the frequencies is swept through to
            reach the start frequency again. Ranges from 0 to 300 seconds.
        :type return_time: int|float
        :return: Query form returns a dict of all parameters and values. Returns None if anything is set.
        :rtype: dict
        """

        # [SOURce[1|2]]:FREQuency:STARt {<frequency>|MINimum|MAXimum}
        # [SOURce[1|2]]:FREQuency:STOP {<frequency>|MINimum|MAXimum}
        # [SOURce[1|2]]:FREQuency:SPAN {<frequency>|MINimum|MAXimum}
        # [SOURce[1|2]]:FREQuency:CENTer {<frequency>|MINimum|MAXimum}
        # [SOURce[1|2]]:SWEep:HTIMe {<seconds>|MINimum|MAXimum}
        # [SOURce[1|2]]:SWEep:MODE {AUTO|MANual}
        # [SOURce[1|2]]:SWEep:RTIMe {<seconds>|MINimum|MAXimum}
        # [SOURce[1|2]]:SWEep:SPACing {LINear|LOGarithmic}
        # [SOURce[1|2]]:SWEep:TIME
        # [SOURce[1|2]]:SWEep:TIME {<seconds>|MINimum|MAXimum}

        # enum_sweep_mode

        # Readback
        if all(v is None for v in {start_freq, stop_freq, sweep_spacing, mode, sweep_time, hold_time, return_time}):
            return_val = {}
            return_val.update(start_freq=self.query(f'SOUR{self.channel_id}:FREQ:STAR?', float))
            return_val.update(stop_freq=self.query(f'SOUR{self.channel_id}:FREQ:STOP?', float))
            return_val.update(sweep_spacing=self.query(f'SOUR{self.channel_id}:SWE:SPAC?',
                                                       self.enum_freq_sweep_spacing).name)
            return_val.update(mode=self.query(f'SOUR{self.channel_id}:SWE:MODE?', self.enum_freq_sweep_mode).name)
            return_val.update(sweep_time=self.query(f'SOUR{self.channel_id}:SWE:TIME?', float))
            return_val.update(hold_time=self.query(f'SOUR{self.channel_id}:SWE:HTIM?', float))
            return_val.update(return_time=self.query(f'SOUR{self.channel_id}:SWE:RTIM?', float))
            return return_val

        # Parameter Checking
        if self.run_mode() != 'SWEEP':
            raise ValueError(f"In order to program sweep parameters, run_mode needs to be in SWEEP mode. Current "
                             f"setting: {self.run_mode()}")
        check_range('start_freq', start_freq, self.bounds_freq_sweep_start_stop)
        check_range('stop_freq', stop_freq, self.bounds_freq_sweep_start_stop)
        sweep_spacing = check_enum_str('sweep_spacing', sweep_spacing, self.enum_freq_sweep_spacing)
        mode = check_enum_str('mode', mode, self.enum_freq_sweep_mode)
        check_range('sweep_time', sweep_time, self.bounds_freq_sweep_time)
        check_range('hold_time', hold_time, self.bounds_freq_hold_return_time)
        check_range('return_time', return_time, self.bounds_freq_hold_return_time)

        # Write Command to Instrument
        if start_freq is not None:
            self.write(f'SOUR{self.channel_id}:FREQ:STAR', start_freq)
        if stop_freq is not None:
            self.write(f'SOUR{self.channel_id}:FREQ:STOP', stop_freq)
        if sweep_spacing is not None:
            self.write(f'SOUR{self.channel_id}:SWE:SPAC', sweep_spacing.value)
        if mode is not None:
            self.write(f'SOUR{self.channel_id}:SWE:MODE', mode.value)
        if sweep_time is not None:
            self.write(f'SOUR{self.channel_id}:SWE:TIME', sweep_time)
        if hold_time is not None:
            self.write(f'SOUR{self.channel_id}:SWE:HTIM', hold_time)
        if return_time is not None:
            self.write(f'SOUR{self.channel_id}:SWE:RTIM', return_time)

if __name__ == '__main__':
    from cl_instr_lib.drivers.signal_generators.AFG3252C import AFG3252C

    afg3252c = AFG3252C('GPIB0::11::INSTR')  # Replace visa_resource_name with None for simulated hardware.
    afg3252c.debug_options(log_scpi=True, unused_args_handling='LOG_UNUSED', inst_error_handling='LOG_ALWAYS')
