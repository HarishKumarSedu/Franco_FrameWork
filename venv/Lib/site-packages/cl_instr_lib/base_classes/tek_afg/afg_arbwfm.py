from pathlib import PurePosixPath
from enum import Enum
from re import match
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.decode_ieee_header import decode_ieee_header
import struct

class AfgArbWfm:
    def __init__(self, instrument):
        self.log = instrument.log
        self.write = instrument.write
        self.query = instrument.query
        self.write_binary_values = instrument.write_binary_values
        # self.query_binary_values = instrument.query_binary_values
        self.read_raw = instrument.read_raw
        self.rm_handle = instrument.rm_handle
        self.log_inst_errors = instrument.log_inst_errors
        self.thumbdrive = instrument.thumbdrive

        # This allows redefining to work on a different instrument that uses different names or number of locations.
        self.enum_arbwfm_locations = Enum('enum_arbwfm_locations', {
            'USER1': 'USER1', 'USER2': 'USER2', 'USER3': 'USER3', 'USER4': 'USER4'
        })

        self.num_points_max = 131_072
        self.max_value = 16382
        self.max_error_vals = 10  # Limits number of errors reported when checking list values.

    def editmem_to_thumbdrive(self, thumb_dir, file_name, create_thumb_dir=False):
        """
        Save the AFG EditMemory to a file on the thumb drive.

        :param thumb_dir: Full path from the root '/' of the thumb drive to the directory where the file is to be
            written.  Use forward slashes or 'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type thumb_dir: str
        :param file_name: file name and suffix. Recommended suffix is '.TFW' for AFG waveform files.
        :type file_name: str
        :param create_thumb_dir: If True any directories on the thumb_dir path which don't exist will be created.
            If False, a non-existent  directory will raise an exception.
        :type create_thumb_dir: bool
        :return: None
        :rtype: None
        """

        # MMEMory:STORe:TRACe EMEMory[1]|EMEMory2,<file_name>

        path = PurePosixPath(thumb_dir)

        if not self.thumbdrive.is_dir(path):
            if not create_thumb_dir:
                raise ValueError(
                    f"Destination thumb_dir '{thumb_dir}' does not exist, set create_thumb_dir=True to "
                    "force creation of thumb_dir.")
            else:
                self.log.info(f"Specified thumb_dir '{thumb_dir}', did not exist, creating it per "
                              "create_thumb_dir==True.")
                self.thumbdrive.create_path(path)

        old_cwd = self.thumbdrive.cwd()
        self.thumbdrive.cwd(path)
        self.write(f"MMEM:STOR:TRAC EMEM,", f'"{file_name}"')

        self.thumbdrive.cwd(old_cwd)

        self.log_inst_errors()

    def thumbdrive_to_editmem(self, thumb_dir, file_name):
        """
        Load the AFG EditMemory from a thumb drive file.

        :param thumb_dir: Full path from the root '/' of the thumb drive to the directory where the file is located.
            Use forward slashes or 'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type thumb_dir: str
        :param file_name: file name and suffix. Suffix is typically '.TFW' for AFG waveform files.
        :type file_name: str
        :rtype: None
        """

        # MMEMory:LOAD:TRACe EMEMory|EMEMory[1]|EMEMory2,<file_name>

        path = PurePosixPath(thumb_dir)

        if not self.thumbdrive.is_dir(path):
            raise ValueError(f"Bad thumb_dir '{thumb_dir}', does not exist.")

        old_cwd = self.thumbdrive.cwd()
        self.thumbdrive.cwd(path)

        catalog = self.thumbdrive.catalog_cwd()
        file_names = [t[0] for t in catalog['files']]
        if file_name not in file_names:
            self.thumbdrive.cwd(old_cwd)
            raise ValueError(f"File '{file_name}', not found in thumb_dir '{path}'.")

        self.write(f'MMEM:LOAD:TRAC EMEM,', f'"{file_name}"')
        self.thumbdrive.cwd(old_cwd)

        self.log_inst_errors()

    def editmem_data_read(self):
        """
        Reads the contents of the AFG EditMemory and returns as a list of integer values. Values can range from 0 to
        full scale (see  attribute max_value).
        :return: List of waveform data points from the edit memory.
        :rtype: List[int]
        """

        # DATA? EMEM

        # Binary data looks like this: b'#42000\x1f\xff"\x01$\x01%\xfd\'\xf4)\xe2+\xc6....'
        # The #42000 is Tek header, in this example it says the next 4 digits are the number of bytes in decimal.
        # The data uses big-endian 2 byte unsigned integers. Values are 0 to 16382 (almost 14-bits).

        # pyvisa's query_binary_values takes care of all the above for us!
        # waveform = self.query_binary_values('DATA? EMEM', datatype='H', is_big_endian=True, header_fmt='ieee')
        self.write('DATA? EMEM')
        dataset = self.read_raw()
        data_length, data = decode_ieee_header(dataset[:len(dataset)-1])
        num_points = data_length//2
        waveform = struct.unpack(f">{num_points}H", data)

        self.log_inst_errors()

        # Scale and shift values so -FS to +FS becomes -1.0 to +1.0.
        # return [(y-8191)/8191 for y in data_ints]
        return waveform

    def editmem_data_write(self, waveform):
        """
        Writes list of integer data into the AFG EditMemory.

        :param waveform: List of integer representing waveform data points between 0 and Full Scale (see
            attribute max_value). Any element outside this range will cause a ValueError. See attribute
            num_points_max for maximum allowed length.
        :type waveform: List[int]
        :return: None
        """

        # Re-scale from -1.0 to +1.0 representation to 0 to num_points_max (16382).
        # afg_data_int = [int(8191*(x+1)) for x in waveform]

        num_points = len(waveform)
        if 2 < num_points > self.num_points_max:
            raise ValueError(f"Bad waveform length {num_points}, must be 2 to {self.num_points_max}")

        # Check for bogus data in the waveform list.
        flags = [i for i, x in enumerate(waveform) if not (isinstance(x, int) and 0 <= x <= self.max_value)]
        msg = ''
        count = 0
        for i in flags:
            if msg != '':
                msg += ' ' * 12
            msg += f"Bad value waveform[{i}]={waveform[i]}\n"
            count += 1
            if count == self.max_error_vals:
                msg += ' ' * 12 + f"and {len(flags)-count} additional bad values."
                break
        if len(flags) > 0:
            msg += ' ' * 12 + f"Values should be 0 to {self.max_value}."
            raise ValueError(f"{msg}")

        self.write_binary_values('DATA EMEM,', waveform, 'H', True)

        self.log_inst_errors()

    def copy_editmem_to_user(self, location, force_overwrite=False):
        """
        Copies the contents of the AFG EditMemory to the specified USER location.

        :param location: 'USER1', 'USER2', 'USER3', 'USER4'
        :type location: enum_arbwfm_locations | str
        :param force_overwrite: Defaults to False which causes an exception if you attempt to copy to a USER location
            that already contains waveform data. Set force_overwrite to True to clobber the occupied location.
        :type force_overwrite: bool
        :return: None
        """

        # TRACe|DATA:COPY <trace_name>,{EMEMory[1]|EMEMory2}
        # <trace_name>::={USER[1]|USER2|USER3|USER4}

        location = check_enum_str('location', location, self.enum_arbwfm_locations)

        if location.value not in self.get_empty_locations() and not force_overwrite:
            raise ValueError(f"Location {location.name} is occupied, set force_overwrite=True to overwrite.")

        # I know this looks backwards, but go look at the manual!
        self.write('DATA:COPY', f'{location.value},EMEM')

        self.log_inst_errors()

    def copy_user_to_editmem(self, location):
        """
        Copies the contents of the specified AFG USER location to the AFG Edit Memory, always overwrites Edit
        Memory.

        :param location: 'USER1', 'USER2', 'USER3', 'USER4'
        :type location: enum_arbwfm_locations | str
        :return: None
        """

        # TRACe|DATA:COPY {EMEMory[1]|EMEMory2},{USER[1]|USER2|USER3|USER4}

        location = check_enum_str('location', location, self.enum_arbwfm_locations)

        if location.value in self.get_empty_locations():
            raise ValueError(f"User index {location.name} is an empty location, cannot copy to EMEM!")

        # I know this looks backwards, but go look at the manual!
        self.write('DATA:COPY', f'EMEM,{location.value}')

        self.log_inst_errors()

    def delete_waveform(self, location):
        """
        Deletes the waveform data from the AFG location specified by location.

        :param location: 'USER1', 'USER2', 'USER3', 'USER4'
        :type location: enum_arbwfm_locations | str
        :return: None
        """

        # TRACe|DATA:DELete[:NAME] <trace_name>
        # <trace_name>::={USER[1]|USER2|USER3|USER4}

        location = check_enum_str('location', location, self.enum_arbwfm_locations)

        # Prevent instrument error that would be caused if USER location is already empty.
        if location.value not in self.get_empty_locations():
            self.write('DATA:DEL', f'{location.value}')

        self.log_inst_errors()

    def get_empty_locations(self):
        """
        Returns list of memory locations that contain no waveform data.

        :return: List of those locations that contain no waveform data.
        :rtype: List[str]
        """

        # TRACe|DATA:CATalog?

        tmp1 = self.query('DATA:CAT?', str).replace('"', '').split(',')

        # EMEM is always in tmp and is considered to always be occupied.
        # Other models may have multiple EditMemories, this handles that.
        tmp2 = [value for value in tmp1 if match(r'EMEM\d?', value) is None]
        empty = [location_obj.name for location_obj in self.enum_arbwfm_locations if location_obj.value not in tmp2]
        return empty

