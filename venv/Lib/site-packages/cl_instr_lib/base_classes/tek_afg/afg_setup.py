from pathlib import PurePosixPath

class AfgSetup:
    def __init__(self, instrument):
        self.log = instrument.log
        self.write = instrument.write
        self.query = instrument.query
        self.log_inst_errors = instrument.log_inst_errors
        self.thumbdrive = instrument.thumbdrive

    # TODO: Could not get MEMory:STATe:VALid? to work, times out. FW bug?

    def memlocation_to_thumbdrive(self, thumb_dir, file_name, mem_location, create_thumb_dir=False):
        """
        Save one of the internal setup memory locations to a file on the thumb drive.

        :param thumb_dir: Full path from the root '/' of the thumb drive to the directory where the file is to be
            written.  Use forward slashes or 'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type thumb_dir: str
        :param file_name: file name and suffix. Recommended suffix is '.TFS' for setup files.
        :type file_name: str
        :param mem_location: Identifier of the AFG setup memory location: 1 to 4.
        :type mem_location: int
        :param create_thumb_dir: If True any directories on the thumb_dir path which don't exist will be created.
            If False, a non-existent  directory will raise an exception.
        :type create_thumb_dir: bool
        :return: None
        :rtype: None
        """

        # MMEMory:STORe:STATe {0|1|2|3|4},<file_name>

        if mem_location not in range(1, 5):
            raise ValueError(f"Bad mem_location {mem_location}, must be int from 1 to 4.")

        path = PurePosixPath(thumb_dir)

        if not self.thumbdrive.is_dir(path):
            if not create_thumb_dir:
                raise ValueError(
                    f"Destination thumb_dir '{thumb_dir}' does not exist, set create_thumb_dir=True to "
                    "force creation of thumb_dir.")
            else:
                self.log.info(f"Specified thumb_dir '{thumb_dir}', did not exist, creating it per "
                              "create_thumb_dir==True.")
                self.thumbdrive.create_path(path)

        old_cwd = self.thumbdrive.cwd()
        self.thumbdrive.cwd(path)
        self.write(f"MMEM:STOR:STAT {mem_location},", f'"{file_name}"')
        self.thumbdrive.cwd(old_cwd)

        self.log_inst_errors()

    def thumbdrive_to_memlocation(self, thumb_dir, file_name, mem_location):
        """
        Load a setup from a thumb drive file into one of the AFG setup memory locations.

        :param thumb_dir: Full path from the root '/' of the thumb drive to the directory where the file is located.
            Use forward slashes or 'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type thumb_dir: str
        :param file_name: file name and suffix. Suffix is typically '.TFS' for AFG setup files.
        :type file_name: str
        :param mem_location: Identifier of the AFG setup memory location: 1 to 4.
        :type mem_location: int
        :return: None
        :rtype: None
        """

        # MMEMory:LOAD:STATe {0|1|2|3|4},<file_name>

        if mem_location not in range(1, 5):
            raise ValueError(f"Bad mem_location {mem_location}, must be int from 1 to 4.")

        path = PurePosixPath(thumb_dir)

        if not self.thumbdrive.is_dir(path):
            raise ValueError(f"Bad thumb_dir '{thumb_dir}', does not exist.")

        old_cwd = self.thumbdrive.cwd()
        self.thumbdrive.cwd(path)

        catalog = self.thumbdrive.catalog_cwd()
        file_names = [t[0] for t in catalog['files']]
        if file_name not in file_names:
            self.thumbdrive.cwd(old_cwd)
            raise ValueError(f"File '{file_name}', not found in thumb_dir '{path}'.")

        self.write(f'MMEM:LOAD:STAT {mem_location},', f'"{file_name}"')

        self.thumbdrive.cwd(old_cwd)

        self.log_inst_errors()

    def save_to_memlocation(self, mem_location):
        """
        Saves the current state of the instrument into one of the internal memory locations.

        :param mem_location: Identifier of the instrument memory location: 1 to 4.
        :type mem_location: int
        """

        # *SAV {0|1|2|3|4}

        if mem_location not in range(1, 5):
            raise ValueError(f"Bad mem_location {mem_location}, must be int from 1 to 4.")

        self.write('*SAV', mem_location)

        self.log_inst_errors()

    def recall_from_memlocation(self, mem_location):
        """
        Restores the instrument to the state obtained from one of the internal memory locations.

        :param mem_location: Identifier of the instrument memory location: 1 to 4.
        :type mem_location: int
        """

        # *RCL {0|1|2|3|4}

        if mem_location not in range(1, 5):
            raise ValueError(f"Bad mem_location {mem_location}, must be int from 1 to 4.")

        self.write('*RCL', mem_location)
        self.query('*OPC?', bool)
        self.log_inst_errors()
