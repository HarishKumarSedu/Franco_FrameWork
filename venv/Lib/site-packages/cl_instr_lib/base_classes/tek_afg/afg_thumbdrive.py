from pathlib import PurePosixPath
import visa   # Needed for exception handling to check for presence of thumb drive.

class AfgThumbdrive:
    def __init__(self, instrument):
        self.log = instrument.log
        self.write = instrument.write
        self.query = instrument.query
        self.on_off = instrument.on_off
        self.log_inst_errors = instrument.log_inst_errors
        self.get_inst_errors = instrument.get_inst_errors
        self.log_unused_args = instrument.log_unused_args

    def is_inserted(self):
        """Checks that the USB thumb drive is inserted into the instrument.

        :return: True if USB thumb drive is present, False if it is not.
        """

        # MMEMory:CATalog?

        self.get_inst_errors()   # clear any existing errors.
        try:
            cat_list = self.query('MMEM:CAT', str)
        except visa.VisaIOError:
            # Could be that AFG is not connected or that USB stick isn't present.
            error_list = self.get_inst_errors()  # This is going to raise another VisaIOError if not connected.
            if error_list[0].split(',')[0] == '-251':
                return False
            raise RuntimeError(error_list[0].split(',')[1])

        return True

    def cwd(self, dir_path=None, thumbdrive_check=True):
        """

        :param dir_path: Full path from the root '/' of the thumb drive to the desired directory. Must not end in a
            file name. Use forward slashes or 'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type dir_path: str
        :param thumbdrive_check: If True, the method is_inserted() will be called to confirm the thumbdrive is present.
            Set to False to suppress this checking in the event that thumbdrive presence has already been checked by
            some prior operation, for example cwd.
        :type thumbdrive_check: bool
        :return: If dir_path is None, thumbdrive cwd setting is read from the instrument and returned. Otherwise,
            None is returned.
        :rtype: str | None
        """
        # """Changes the instrument current working directory.
        # """

        # MMEMory:CDIRectory [<directory_name>]

        if thumbdrive_check and not self.is_inserted():
            raise RuntimeError("USB Memory stick not found!")

        if dir_path is None:
            return self.query('MMEM:CDIR').strip('"')
        else:
            dir_path = PurePosixPath(dir_path)
            self.get_inst_errors()  # Clear the error queue
            self.write('MMEM:CDIR', f'"{dir_path}"')
            error_list = self.get_inst_errors()   # Check for error caused by bad path.
            if len(error_list) > 0:
                raise RuntimeError(error_list[0].split(',')[1])

    def catalog_cwd(self, thumbdrive_check=True):
        """
        Returns a dictionary of information about the contents of the thumb drive current working directory.

        :param thumbdrive_check: If True, the method is_inserted() will be called to confirm the thumbdrive is present.
            Set to False to suppress this checking in the event that thumbdrive presence has already been checked by
            some prior operation, for example cwd.
        :type thumbdrive_check: bool
        :return: Dictionary with keys:

            bytes_used
                On the entire thumb drive
            bytes_free
                On the entire thumb drive
            subdirs
                A list of the names of the subdirectories fo the current working directory.
            files
                A list of files and their sizes found in the current working directory. Each entry is a tuple
                consisting of the file name (str) and a size (int) in bytes.
        """

        # MMEMory:CATalog?

        if thumbdrive_check and not self.is_inserted():
            raise RuntimeError("USB Memory stick not found!")

        cat_list = self.query('MMEM:CAT?', str).split(',')
        # print(cat_list)
        return_values = {}
        return_values.update(bytes_used=int(cat_list[0]))
        return_values.update(bytes_free=int(cat_list[1]))
        return_values.update(dir=self.cwd(thumbdrive_check=False))
        dirs = []
        files = []
        for name, entry_type, num_bytes in zip(cat_list[2::3], cat_list[3::3], cat_list[4::3]):
            name = name.strip('"')
            num_bytes = int(num_bytes.strip('"'))
            if entry_type == 'DIR':
                dirs.append(name)
            else:
                files.append((name, num_bytes))
        return_values.update(subdirs=dirs)
        return_values.update(files=files)
        return return_values

    def is_dir(self, dir_path):
        """
        Check if dir_path exists on the thumb drive. Instrument Current Working Directory (CWD) is restored to what it
        was before this method was called.

        :param dir_path:  Full path from the root '/' of the thumb drive to the desired directory. Must not end in a
            file name. Use forward slashes or 'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type dir_path: str
        :return: True if directory exists.
        :rtype: bool
        """

        # MMEMory:CDIRectory [<directory_name>]

        old_cwd = self.cwd()
        self.get_inst_errors()  # Clear the error queue

        # Try setting cwd to the entire path. If that succeeds, all elements are directories that already exist.
        new_path = PurePosixPath(dir_path)
        self.write('MMEM:CDIR', f'"{new_path}"')
        errors = self.get_inst_errors()  # This doesn't raise, so we are guaranteed to proceed to next statement which
        # puts cwd back.

        self.cwd(old_cwd)

        if len(errors) == 0:
            return True
        else:
            return False

    def create_path(self, dir_path):
        """
        Check if the given directory path exists on the thumb drive and if it does not create it. This creates all
        intermediate missing directories as well.

        :param dir_path:  Full path from the root '/' of the thumb drive to the desired directory. Must not end in a
            file name. Use forward slashes or 'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type dir_path: str
        :return: None
        :rtype: None
        """

        # MMEMory:CDIRectory [<directory_name>]
        # MMEMory:MDIRectory <directory_name>

        # We use PurePosixPath because we are working with paths of the instrument thumb drive as opposed to those of
        # the PC. PurePosixPath does no system calls so it cannot alter the PC filesystem.
        # To access the thumbdrive filesystem, we have to use SCPI commands.

        cwd_prev = self.cwd()

        path = PurePosixPath(dir_path)

        # OK, something is missing...try piece by piece..create the missing directories.
        self.get_inst_errors()   # Clear the error queue
        for i, part in enumerate(path.parts):
            self.write('MMEM:CDIR', f'"{str(part)}"')
            errors = self.get_inst_errors()
            if len(errors) > 0:
                if i == 0:
                    self.cwd(cwd_prev)
                    raise ValueError(f"Bad path '{dir_path}', could not CWD to the anchor portion '{part}'. "
                                     "Should be a '/'.")
                else:
                    self.write('MMEM:MDIR', f'"{str(part)}"')
                    errors = self.get_inst_errors()
                    if len(errors) > 0:
                        self.cwd(cwd_prev)
                        raise ValueError(f"Couldn't create directory '{part}', (element {i} in path '{dir_path})'. "
                                         f"There may already be a file of the same name in that location.")
                    self.write('MMEM:CDIR', f'"{str(part)}"')

        self.cwd(cwd_prev)

    def file_exists(self, file_full_path, thumbdrive_check=True):
        """
        Returns True if the file specified exists on the thumbdrive. Exception is raised if thumbdrive is not
        inserted.

        :param file_full_path: Full path from the root '/' of the thumb drive to the desired file.Use forward slashes or
            'r' prefix to avoid misinterpretation of backslashes as escape characters.
        :type file_full_path: str
        :param thumbdrive_check: If True, the method is_inserted() will be called to confirm the thumbdrive is present.
            Set to False to suppress this checking in the event that thumbdrive presence has already been checked by
            some prior operation, for example cwd.
        :type thumbdrive_check: bool
        :return: True if file exists, False otherwise.
        :rtype: bool
        """

        posix_path = PurePosixPath(file_full_path)
        file_name = PurePosixPath(file_full_path).name

        self.cwd(str(posix_path.parent))  # Does check for thumbdrive.

        catalog = self.catalog_cwd(thumbdrive_check)
        file_names = [t[0] for t in catalog['files']]
        if file_name in file_names:
            return True
        else:
            return False


    # Could not get the query to work. Developing on 'TEKTRONIX,AFG3252,C021277,SCPI:99.0 FV:3.2.4'
    # def usb_is_locked(self, path):
    #     tmp = self.query(f'MMEM:LOCK:STAT "{path}"')
    #     self.log_inst_errors()
    #     return tmp
