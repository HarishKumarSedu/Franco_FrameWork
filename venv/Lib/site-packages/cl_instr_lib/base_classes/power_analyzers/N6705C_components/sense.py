# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include python libraries
from enum import Enum
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


# noinspection PyProtectedMember
class Sense:
    """Class for controlling the Sense sub-system on the Keysight N6705C Modular DC Power Analyzer."""

    def __init__(self, pow_ana):
        self.write = pow_ana.write
        self.query = pow_ana.query
        self.read_raw = pow_ana.read_raw
        self.log = pow_ana.log
        self._check_channel = pow_ana._check_channel
        self._check_multi_channels = pow_ana._check_multi_channels
        self._check_module = pow_ana._check_module
        self._models_tuple = pow_ana._models_tuple
        self._channel_dict = pow_ana._channel_dict
        self._return_split = pow_ana._return_split
        self.log_inst_errors = pow_ana.log_inst_errors
        self.get_inst_errors = pow_ana.get_inst_errors
        self.on_off = pow_ana.on_off

        #: Object containing the `Sense.Datalog`_  methods.
        self.datalog = Datalog(self)

        #: Object containing the `External_dlog`_  methods.
        self.external_dlog = ExternalDlog(self)
        _models = self._models_tuple

    enum_time_resolution = Enum("enum_time_resolution", {"RES20": "RES20", "RES40": "RES40"})
    enum_window = Enum('enum_window', {"HANNING": "HANN", "RECTANGULAR": "RECT"})

    # Further implementation
    # sense subsystem
    # --------------------------

    # TODO Revisit for backwards compatibility
    # SENSe:FUNCtion
    #  :FUNCtion “VOLTage”|”CURRent” | “NONE”, (@chanlist) Enables the measurement function (for backward compatibility)
    #  SENSe:FUNCtion:INPut MAIN | AUXiliary, (@chanlist) Selects the voltage measurement input (only on N6781A, N6785A)

    # SENSe

    #  :HISTogram
    #  :CURRent
    #  [:DC]:BIN
    #   :GAIN? <binrange>, (@chanlist) Queries the LSB weight of the histogram (N6781A, N6782A, N6785A, and N6786A)
    #   :OFFSet? <binrange>, (@chanlist) Queries the weight of the histogram (N6781A, N6782A, N6785A, N6786A)
    #   :RANGes? (@chanlist) Queries the values of the bin ranges (N6781A, N6782A, N6785A, N6786A)

    #  [:DC]:RANGe
    #       [:UPPer] <NRf+>, (@chanlist) Sets the measurement range of the histogram (N6781A, N6782A, N6785A,N6786A)
    #        :AUTO <Bool>, (@chanlist) Enables/disables measurement autoranging (N6781A, N6782A, N6785A, N6786A)

    #  :FUNCtion
    #       :CURRent <Bool>, (@chanlist) Enables/disables current histogram (N6781A, N6782A, N6785A, N6786A)

    def setup_current(self, channel, compensate=None, crange=None, measure_enable=None):
        """
        Command and query parameters involving sensing current measurements.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param compensate: on_off value ('ON'/'OFF' preferred) that activates current measurement compensation on the
            given channel.
        :type compensate: str | int | bool
        :param crange: Selects a DC current measurement range on models that have multiple ranges.
            One of the following:
            * int - a value within channel.current_range
            * "AUTO" - autoranging available on following models (N6781A, N6782A, N6785A, N6786A)
        :type crange: int | str
        :param measure_enable: on_off value ('ON'/'OFF' preferred) that activates measurement on the given channel.
        :type measure_enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        # SENSe:CURRent:CCOMpensate <Bool>, (@chanlist) Enables/disables the capacitive current compensation
        # SENSe:CURRent[:DC]:RANGe [:UPPer] <NRf+>, (@chanlist) Selects the current measurement range
        # SENSe:CURRent[:DC]:RANGe :AUTO <Bool>, (@chanlist)
        # Enables/disables measurement autoranging (N6781A, N6782A, N6785A, N6786A)
        #  SENSe:FUNCtion:CURRent <Bool>, (@chanlist) Enables/disables current measurements (replaces FUNCtion)

        channel_str, channel_obj = self._check_channel(channel)
        special_modules = ('N6781A', 'N6782A', 'N6785A', 'N6786A')

        if all(param is None for param in [compensate, crange, measure_enable]):
            ret_value = {}
            ret_value.update(compensate=self.query("SENS:CURR:CCOM?", float, post_target_params=channel_str))

            if self._check_module(channel_obj.model, special_modules) is None:
                ret_value.update(crange=self.query("SENS:CURR:RANG?", float, post_target_params=channel_str))

            else:
                auto = self.on_off.to_api(self.query("SENS:CURR:RANG:AUTO?", post_target_params=channel_str))
                ret_value.update(crange="AUTO")

                if auto in self.on_off.off_vals.from_api:  # when the auto_range is off return the range value
                    ret_value.update(crange=self.query("SENS:CURR:RANG?", float, post_target_params=channel_str))

            ret_value.update(
                measure_enable=self.on_off.to_api(self.query('SENS:FUNC:CURR', post_target_params=channel_str)))

            return ret_value

        # check all parameters
        self.on_off.to_inst(compensate)
        self.on_off.to_inst(measure_enable)

        if channel_obj.model in special_modules:

            limit_msg = "Bad {name} {value}, Should be AUTO or a value from {min} to {max} {units}"
            if isinstance(crange, str) and crange == "AUTO":
                crange = self.on_off.to_inst(True)
            else:
                check_range('crange', crange, channel_obj.current_range, limit_msg)
        else:
            check_range('crange', crange, channel_obj.current_range)

        if compensate is not None:
            target = f"{self.on_off.to_inst(compensate)}," + channel_str
            self.write("SENS:CURR:CCOM", target)
        if crange is not None:
            target = f"{crange}," + channel_str
            self.write("SENS:CURR:RANG", target)
        if measure_enable is not None:
            target = f"{self.on_off.to_inst(measure_enable)}," + channel_str
            self.write("SENS:FUNC:CURR", target)

        self.log_inst_errors()

    def setup_voltage(self, channel, vrange=None, measure_enable=None):
        """
        Command and query parameters involving sensing voltage measurements.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param vrange: Selects a DC voltage measurement range on models that have multiple ranges. One of the following:
            * int - a value within channel.voltage_range
            * "AUTO" - auto-ranging available on following models (N6781A, N6782A, N6785A, N6786A)
        :type vrange: int | str
        :param measure_enable: on_off value ('ON'/'OFF' preferred) that activates measurement on the given channel.
        :type measure_enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        # SENSe:CURRent:CCOMpensate <Bool>, (@chanlist) Enables/disables the capacitive current compensation
        # SENSe:CURRent[:DC]:RANGe [:UPPer] <NRf+>, (@chanlist) Selects the current measurement range
        # SENSe:CURRent[:DC]:RANGe :AUTO <Bool>, (@chanlist)
        # Enables/disables measurement autoranging (N6781A, N6782A, N6785A, N6786A)
        #  SENSe:FUNCtion:VOLTage <Bool>, (@chanlist) Enables/disables voltage measurements (replaces FUNCtion)

        channel_str, channel_obj = self._check_channel(channel)
        special_modules = ('N6781A', 'N6782A')

        if all(param is None for param in [vrange, measure_enable]):
            ret_value = {}
            if self._check_module(channel_obj.model, special_modules) is None:
                ret_value.update(vrange=self.query("SENS:CURR:RANG?", float, post_target_params=channel_str))
            else:
                auto = self.on_off.to_api(self.query("SENS:CURR:RANG:AUTO?", post_target_params=channel_str))
                ret_value.update(vrange="AUTO")

                if auto in self.on_off.off_vals.from_api:  # when the auto_range is off return the range value
                    ret_value.update(vrange=self.query("SENS:CURR:RANG?", float, post_target_params=channel_str))

            ret_value.update(
                measure_enable=self.on_off.to_api(self.query("SNESL:FUNC:VOLT", post_target_params=channel_str)))

            return ret_value

        # check all parameters
        self.on_off.to_inst(measure_enable)

        if channel_obj.model in special_modules:

            limit_msg = "Bad {name} {value}, Should be AUTO or a value from {min} to {max} {units}"
            if isinstance(vrange, str) and vrange == "AUTO":
                vrange = self.on_off.to_inst(True)
            else:
                check_range('vrange', vrange, channel_obj.voltage_range, limit_msg)
        else:
            check_range('vrange', vrange, channel_obj.voltage_range)

        if vrange is not None:
            target = f"{vrange}," + channel_str
            self.write("SENS:CURR:RANG", target)
        if measure_enable is not None:
            target = f"{self.on_off.to_inst(measure_enable)}," + channel_str
            self.write("SENS:FUNC:VOLT", target)

        self.log_inst_errors()

    def sweep(self, channel, offset=None, points=None, time_interval=None, time_resolution=None):
        """
        Configure and query parameters relating to sweep measurements.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param offset: Offset in a data sweep when the measurement is triggered. Programmed values can range from
            (points setting –1) through 2E9
        :type offset: int
        :param points: This command defines the number of points in a measurement. The number of samples (points) that
            can be specified for 1 parameter is up to 512K points
        :type points: int
        :param time_interval: Time period between samples in seconds. Programmed values can range from 10.24
            microseconds to 40,000 seconds.
        :type time_interval: int | float
        :param time_resolution: This command sets the resolution used in setting the time interval between digitized
            measurements for time intervals above 20.48 microseconds. Only available on the following modules:
            (N676XA, N678XA, modules with option 054) One of the following:

            * RES20 - rounds all values above 20.48 microseconds to the nearest multiple of 20.48
            * RES40 - rounds all values above 20.48 microseconds to the nearest multiple of 40.96
        :type time_resolution: str | enum_time_resolution
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        # SENSe:SWEep:OFFSet:POINts <NRf+>, (@chanlist) Defines the trigger offset in the measurement sweep
        # SENSe:SWEep:POINts <NRf+>, (@chanlist) Defines the number of data points in the measurement
        # SENSe:SWEep:TINTerval <NRf+>, (@chanlist) Sets the measurement sample interval
        # SENSe:SWEep:TINT:RESolution RES20 | RES40 Sets the measurement sample interval

        channel_str, channel_obj = self._check_channel(channel)
        special_modules = r"N678\dA"
        used_special = self._check_module(channel_obj.model, special_modules)

        # read back
        if all(param is None for param in [offset, points, time_interval, time_resolution]):
            ret_value = {}
            ret_value.update(offset=self.query("SENS:SWE:OFFS:POIN?", int, post_target_params=channel_str))
            ret_value.update(points=self.query("SENS:SWE:POIN?", int,  post_target_params=channel_str))
            ret_value.update(time_interval=self.query("SENS:SWE:TINT", float, post_target_params=channel_str))
            if used_special is not None:
                ret_value.update(resolution=self.query("SENS:SWE:TINT:RES?", post_target_params=channel_str))

            return ret_value

        # check all parameters
        check_range('offset', offset, min_max_units(0, 2e9, 'Points'))
        check_range('points', points, min_max_units(0, 512000, 'Points'))
        check_range('time_interval', time_interval, min_max_units(10.24, 40000, 'Seconds'))
        if used_special is not None:
            time_resolution = check_enum_str("time_resolution", time_resolution, self.enum_time_resolution).value

        # write to instrument
        if offset is not None:
            target = f"{offset}," + channel_str
            self.write("SENS:SWE:OFFS:POIN", target)
        if points is not None:
            target = f"{points}," + channel_str
            self.write("SENS:SWE:POIN", target)
        if time_interval is not None:
            target = f"{time_interval}," + channel_str
            self.write("SENS:SWE:TINT", target)
        if time_resolution is not None and used_special is not None:
            target = f"{time_resolution}," + channel_str
            self.write("SENS:SWE::TINT:RES", target)

        # log errors
        self.log_inst_errors()

    def window(self, channel, window_type=None):
        """
        Configure and Query windowing-conditioning functions used in DC measurement calculations on models
        that have measurement controls.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param window_type: Windowing function used. One of the following:

            * HANNING - The Hanning window is a "raised cosine" function. It is a signal conditioning function that
              reduces errors in DC measurement calculations in the presence of periodic signals such as AC line ripple.
            * RECTANGULAR - A window that returns measurement calculations with no signal conditioning.
        :type window_type: str | enum_window
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: str | None
        """
        #  SENSe:WINDow[:TYPE] HANNing | RECTangular, (@chanlist) Selects the window type

        channel_str, channel_obj = self._check_channel(channel)
        # TODO: find what modules support this. This does not work on 6765A and 6792A.
        special_modules = ('N6765A', "N6792A")
        used_special = self._check_module(channel_obj.model, special_modules)

        # read back
        if window_type is None:
            if used_special is not None:
                raise ValueError(f'Bad channel {channel} for operation. Model {channel_obj.model} '
                                 f'does not support windowing.')
            return self.query("SENS:WIND", self.enum_window).name

        # check params
        window_type_obj = check_enum_str("window_type", window_type, self.enum_window)
        if used_special is not None:
            raise ValueError(f'Bad channel {channel} for operation. Model {channel_obj.model} '
                             f'does not support windowing.')

        # write to instrument
        target = f'{window_type_obj.value}, ' + channel_str
        self.write("SENS:WIND", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class Datalog:
    """Class for accessing features of the datalog system within the sense class"""
    def __init__(self, sense):
        self.write = sense.write
        self.query = sense.query
        self.read_raw = sense.read_raw
        self.log = sense.log
        self._check_channel = sense._check_channel
        self._check_multi_channels = sense._check_multi_channels
        self._check_module = sense._check_module
        self._models_tuple = sense._models_tuple
        self._channel_dict = sense._channel_dict
        self._return_split = sense._return_split
        self.log_inst_errors = sense.log_inst_errors
        self.get_inst_errors = sense.get_inst_errors
        self.on_off = sense.on_off
        _models = self._models_tuple

    def setup_current(self, channel, crange=None, measure_enable=None, min_max_enable=None):
        """
        Command and query parameters involving sensing current datalog measurements.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param crange: Selects a DC current measurement range on models that have multiple ranges.
            One of the following:
            * int - a value within channel.current_range
            * "AUTO" - auto-ranging available on following models (N6781A, N6782A, N6785A, N6786A)
        :type crange: int | str
        :param measure_enable: on_off value ('ON'/'OFF' preferred) that activates measurement on the given channel.
        :type measure_enable: str | int | bool
        :param min_max_enable: on_off value ('ON'/'OFF' preferred) that activates logging of min/max in datalog.
        :type min_max_enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  SENSe:DLOG:CURRent[:DC]:RANGe[:UPPer] <NRf+>, (@chanlist) Sets the internal data log current range
        #  SENSe:DLOG:CURRent[:DC]:RANGe:AUTO <Bool>, (@chanlist) Enables/disables measurement autoranging
        #  (N6781A, N6782A, N6785A, N6786A)
        #  SENSe:DLOG:FUNCtion:CURRent <Bool>, (@chanlist) Enables/disables current data logging
        #  SENSe:DLOG:FUNCtion:MINMax <Bool> Enables/disables min/max data logging

        channel_str, channel_obj = self._check_channel(channel)
        special_modules = ('N6781A', 'N6782A', 'N6785A', 'N6786A')

        if all(param is None for param in [crange, measure_enable, min_max_enable]):
            ret_value = {}
            if self._check_module(channel_obj.model, special_modules) is None:
                ret_value.update(crange=self.query("SENS:DLOG:CURR:RANG?", float, post_target_params=channel_str))

            else:
                auto = self.on_off.to_api(self.query("SENS:DLOG:CURR:RANG:AUTO?", post_target_params=channel_str))
                ret_value.update(crange="AUTO")

                if auto in self.on_off.off_vals.from_api:  # when the auto_range is off return the range value
                    ret_value.update(crange=self.query("SENS:DLOG:CURR:RANG?", float, channel_str))

            ret_value.update(measure_enable=self.on_off.to_api(
                self.query('SENS:DLOG:FUNC:CURR', post_target_params=channel_str)))
            ret_value.update(min_max_enable=self.on_off.to_api(self.query('SENS:DLOG:FUNC:MINM')))
            return ret_value

        # check all parameters
        self.on_off.to_inst(measure_enable)
        self.on_off.to_inst(min_max_enable)

        if channel_obj.model in special_modules:

            limit_msg = "Bad {name} {value}, Should be AUTO or a value from {min} to {max} {units}"
            if isinstance(crange, str) and crange == "AUTO":
                crange = self.on_off.to_inst(True)
            else:
                check_range('crange', crange, channel_obj.current_range, limit_msg)
        else:
            check_range('crange', crange, channel_obj.current_range)

        # write to instrument and log errors
        if crange is not None:
            target = f"{crange}," + channel_str
            self.write("SENS:DLOG:CURR:RANG", target)
        if measure_enable is not None:
            target = f"{self.on_off.to_inst(measure_enable)}," + channel_str
            self.write("SENS:DLOG:FUNC:CURR", target)
        if min_max_enable is not None:
            self.write("SENS:DLOG:FUNC:MINM", self.on_off.to_inst(min_max_enable))

        self.log_inst_errors()

    def setup_voltage(self, channel, vrange=None, measure_enable=None, min_max_enable=None):
        """
        Command and query parameters involving sensing voltage datalog measurements.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param vrange: Selects a DC voltage measurement range on models that have multiple ranges.
            One of the following:
            * int - a value within channel.voltage_range
            * "AUTO" - auto-ranging available on following models (N6781A, N6782A, N6785A, N6786A)
        :type vrange: int | str
        :param measure_enable: on_off value ('ON'/'OFF' preferred) that activates measurement on the given channel.
        :type measure_enable: str | int | bool
        :param min_max_enable: on_off value ('ON'/'OFF' preferred) that activates logging of min/max in datalog.
        :type min_max_enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  SENSe:DLOG:VOLTage[:DC]:RANGe
        #  SENSe:DLOG:VOLTage[:UPPer] <NRf+>, (@chanlist) Sets the internal data log voltage range
        #  SENSe:DLOG:VOLTage:AUTO <Bool>, (@chanlist) Enables/disables measurement autoranging (N6781A, N6782A)
        #  SENSe:DLOG:FUNCtion:VOLTage <Bool>, (@chanlist) Enables/disables voltage data logging
        #  SENSe:DLOG:FUNCtion:MINMax <Bool> Enables/disables min/max data logging

        channel_str, channel_obj = self._check_channel(channel)
        special_modules = ('N6781A', 'N6782A', 'N6785A', 'N6786A')

        if all(param is None for param in [vrange, measure_enable, min_max_enable]):
            ret_value = {}
            if self._check_module(channel_obj.model, special_modules) is None:
                ret_value.update(
                    vrange=self.query("SENS:DLOG:VOLT:RANG?", float, post_target_params=channel_str))

            else:
                auto = self.on_off.to_api(
                    self.query("SENS:DLOG:VOLT:RANG:AUTO?", post_target_params=channel_str))
                ret_value.update(vrange="AUTO")

                if auto in self.on_off.off_vals.from_api:  # when the auto_range is off return the range value
                    ret_value.update(vrange=self.query("SENS:DLOG:VOLT:RANG?", float, channel_str))

            ret_value.update(measure_enable=self.on_off.to_api(
                self.query('SENS:DLOG:FUNC:VOLT', post_target_params=channel_str)))

            ret_value.update(min_max_enable=self.on_off.to_api(self.query('SENS:DLOG:FUNC:MINM')))

            return ret_value

        # check all parameters
        self.on_off.to_inst(measure_enable)
        self.on_off.to_inst(min_max_enable)

        if channel_obj.model in special_modules:

            limit_msg = "Bad {name} {value}, Should be AUTO or a value from {min} to {max} {units}"
            if isinstance(vrange, str) and vrange == "AUTO":
                vrange = self.on_off.to_inst(True)
            else:
                check_range('vrange', vrange, channel_obj.voltage_range, limit_msg)
        else:
            check_range('vrange', vrange, channel_obj.voltage_range)

        # write to instrument and log errors
        if vrange is not None:
            target = f"{vrange}," + channel_str
            self.write("SENS:DLOG:VOLT:RANG", target)
        if measure_enable is not None:
            target = f"{self.on_off.to_inst(measure_enable)}," + channel_str
            self.write("SENS:DLOG:FUNC:VOLT", target)
        if min_max_enable is not None:
            self.write("SENS:DLOG:FUNC:MINM", self.on_off.to_inst(min_max_enable))

        self.log_inst_errors()

    def setup_acquisition(self, marker1=None, marker2=None, offset=None, period=None, time=None):
        """
        Command and query parameters involving configuring datalog measurement acquisition.

        :param marker1: This command set the position of the data logger marker 1. Positions are set in seconds
            relative to the trigger position. A negative time gives positions before the trigger. A real number
            between -3,599,964,000 and 3,599,964,000 seconds.
        :type marker1: int | float
        :param marker2: This command set the position of the data logger marker 2. Positions are set in seconds
            relative to the trigger position. A negative time gives positions before the trigger. A real number
            between -3,599,964,000 and 3,599,964,000 seconds.
        :type marker2: int | float
        :param offset: This command specifies the datalog trigger offset as a percent of the total datalog duration.
            Programming a trigger offset lets you specify the percent of pre-trigger data that will be logged to
            the datalog file.A percent of 0 means the trigger occurs at the beginning of the running datalog,
            while 100 means that the trigger occurs at the end of the running datalog.
            Any value between 0 and 100 can be set.
        :type offset: int | float
        :param period: This command specifies the period of the datalog samples in seconds. Although the absolute
            minimum logging period is 20.48 microseconds, the actual minimum varies as a function of the number
            of channels and readings that are being logged.Values are rounded to the nearest 20.48-microsecond
            increment.This function cannot be set to values less than 75 milliseconds when interleaved data logging
            is in effect. A value from 0.00002048 to 60.
        :type period: int | float
        :param time: This command specifies the duration of the datalog in seconds. Values from 1 second up to
            3,599,964,000 seconds (99,999 hours) can be specified. The resulting datalog file cannot exceed
            2E9 bytes (1.87 Gbytes in Microsoft Windows units). If the duration value causes the file to exceeds
            this size, the time interval will automatically be adjusted to a longer interval
            to reduce the file size.
        :type time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  SENSe:DLOG:MARKer<1,2>:POINt <NRf+> Positions the data log markers
        #  SENSe:DLOG:OFFSet <NR1> Sets trigger offset as a percent from start of data log duration
        #  SENSe:DLOG:PERiod <NRf+> Sets the interval between samples (replaces TINTerval)
        #  SENSe:DLOG:TIME <NRf+> Sets the duration of the data log in seconds
        #  SENSe:DLOG:TINTerval <NRf+> Sets the interval between samples (for backward compatibility)

        if all(param is None for param in [marker1, marker2, offset, period, time]):
            ret_value = {}
            ret_value.update(marker1=self.query('SENS:DLOG:MARK1:POIN', float))
            ret_value.update(marker2=self.query('SENS:DLOG:MARK2:POIN', float))
            ret_value.update(offset=self.query('SENS:DLOG:OFFS', float))
            ret_value.update(period=self.query('SENS:DLOG:MARK2:POIN', float))
            ret_value.update(time=self.query('SENS:DLOG:MARK2:POIN', float))
            return ret_value

        # check all parameters
        check_range('marker1', marker1, min_max_units(-3599964000, 3599964000, 'Seconds'))
        check_range('marker2', marker2, min_max_units(-3599964000, 3599964000, 'Seconds'))
        check_range('offset', offset, min_max_units(0, 100, 'percent offset'))
        check_range('period', period, min_max_units(0.00002048, 60, 'Seconds'))
        check_range('time', time, min_max_units(1, 3599964000, 'Seconds'))

        # write to instrument and log errors.
        if marker1 is not None:
            self.write('SENS:DLOG:MARK1:POIN', marker1)
        if marker2 is not None:
            self.write('SENS:DLOG:MARK2:POIN', marker2)
        if offset is not None:
            self.write('SENS:DLOG:OFFS', offset)
        if period is not None:
            self.write('SENS:DLOG:PER', period)
        if time is not None:
            self.write('SENS:DLOG:TIME', time)

        self.log_inst_errors()


# noinspection PyProtectedMember
class ExternalDlog:
    """Class for accessing features of the external datalog system within the sense class."""
    def __init__(self, sense):
        self.write = sense.write
        self.query = sense.query
        self.read_raw = sense.read_raw
        self.log = sense.log
        self._check_channel = sense._check_channel
        self._check_multi_channels = sense._check_multi_channels
        self._check_module = sense._check_module
        self._models_tuple = sense._models_tuple
        self._channel_dict = sense._channel_dict
        self._return_split = sense._return_split
        self.log_inst_errors = sense.log_inst_errors
        self.get_inst_errors = sense.get_inst_errors
        self.on_off = sense.on_off

    def setup_current(self, channel, crange=None, measure_enable=None, min_max_enable=None):
        """
        Command and query parameters involving sensing current measurements on the external datalog.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param crange: Selects a DC current measurement range on models that have multiple ranges.
            One of the following:
            * int - a value within channel.current_range
            * "AUTO" - auto-ranging available on following models (N6781A, N6782A, N6785A, N6786A)
        :type crange: int | str
        :param measure_enable: on_off value ('ON'/'OFF' preferred) that activates measurement on the given channel.
        :type measure_enable: str | int | bool
        :param min_max_enable: on_off value ('ON'/'OFF' preferred) that activates logging of min/max in datalog.
        :type min_max_enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  SENSe:ELOG:CURRent[:DC]:RANGe[:UPPer] <NRf+>, (@chanlist) Sets the external data log current range
        #  SENSe:ELOG:CURRent[:DC]:RANGe:AUTO <Bool>, (@chanlist) Enables/disables measurement autoranging
        #  (N6781A, N6782A, N6785A, N6786A)
        #  SENSe:ELOG:FUNCtion:CURRent <Bool>, (@chanlist) Enables/disables external current data logging
        #  SENSe:ELOG:FUNCtion:CURRent:MINMax <Bool>, (@chanlist)
        #  Enables/disables external min/max current data logging

        channel_str, channel_obj = self._check_channel(channel)
        special_modules = ('N6781A', 'N6782A', 'N6785A', 'N6786A')

        if all(param is None for param in [crange, measure_enable, min_max_enable]):
            ret_value = {}

            if self._check_module(channel_obj.model, special_modules) is None:
                ret_value.update(
                    crange=self.query("SENS:ELOG:CURR:RANG?", float, post_target_params=channel_str))
            else:
                auto = self.on_off.to_api(
                    self.query("SENS:ELOG:CURR:RANG:AUTO?", post_target_params=channel_str))
                ret_value.update(crange="AUTO")
                if auto in self.on_off.off_vals.from_api:  # when the auto_range is off return the range value
                    ret_value.update(crange=self.query("SENS:ELOG:CURR:RANG?", float, channel_str))

            ret_value.update(measure_enable=self.on_off.to_api(
                self.query('SENS:ELOG:FUNC:CURR', post_target_params=channel_str)))
            ret_value.update(min_max_enable=self.on_off.to_api(
                self.query('SENS:ELOG:FUNC:CURR:MINM', post_target_params=channel_str)))

            return ret_value

        # check all parameters
        self.on_off.to_inst(measure_enable)
        self.on_off.to_inst(min_max_enable)

        if channel_obj.model in special_modules:

            limit_msg = "Bad {name} {value}, Should be AUTO or a value from {min} to {max} {units}"
            if isinstance(crange, str) and crange == "AUTO":
                crange = self.on_off.to_inst(True)
            else:
                check_range('crange', crange, channel_obj.current_range, limit_msg)
        else:
            check_range('crange', crange, channel_obj.current_range)

        # write to instrument and log errors
        if crange is not None:
            target = f"{crange}," + channel_str
            self.write("SENS:ELOG:CURR:RANG", target)
        if measure_enable is not None:
            target = f"{self.on_off.to_inst(measure_enable)}," + channel_str
            self.write("SENS:ELOG:FUNC:CURR", target)
        if min_max_enable is not None:
            target = f"{self.on_off.to_inst(min_max_enable)}," + channel_str
            self.write("SENS:ELOG:FUNC:CURR:MINM", target)

        self.log_inst_errors()

    def setup_voltage(self, channel, vrange=None, measure_enable=None, min_max_enable=None):
        """
        Command and query parameters involving sensing voltage measurements on the external datalog.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param vrange: Selects a DC voltage measurement range on models that have multiple ranges.
            One of the following:
            * int - a value within channel.voltage_range
            * "AUTO" - auto-ranging available on following models (N6781A, N6782A, N6785A, N6786A)
        :type vrange: int | str
        :param measure_enable: on_off value ('ON'/'OFF' preferred) that activates measurement on the given channel.
        :type measure_enable: str | int | bool
        :param min_max_enable: on_off value ('ON'/'OFF' preferred) that activates logging of min/max in datalog.
        :type min_max_enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  SENSe:ELOG:VOLTage[:DC]:RANGe[:UPPer] <NRf+>, (@chanlist) Sets the external data log voltage range
        #  SENSe:ELOG:VOLTage[:DC]:RANGe:AUTO <Bool>, (@chanlist)
        #  Enables/disables measurement autoranging (N6781A, N6782A)
        #  SENSe:ELOG:FUNCtion:VOLTage <Bool>, (@chanlist) Enables/disables external voltage data logging
        #  SENSe:ELOG:FUNCtion:VOLTage:MINMax <Bool>, (@chanlist)
        #  Enables/disables external min/max voltage data logging

        channel_str, channel_obj = self._check_channel(channel)
        special_modules = ('N6781A', 'N6782A', 'N6785A', 'N6786A')

        if all(param is None for param in [vrange, measure_enable, min_max_enable]):
            ret_value = {}
            if self._check_module(channel_obj.model, special_modules) is None:
                ret_value.update(
                    vrange=self.query("SENS:ELOG:VOLT:RANG?", float, post_target_params=channel_str))

            else:
                auto = self.on_off.to_api(
                    self.query("SENS:ELOG:VOLT:RANG:AUTO?", post_target_params=channel_str))
                ret_value.update(vrange="AUTO")

                if auto in self.on_off.off_vals.from_api:  # when the auto_range is off return the range value
                    ret_value.update(vrange=self.query("SENS:ELOG:VOLT:RANG?", float, channel_str))

            ret_value.update(measure_enable=self.on_off.to_api(
                self.query('SENS:ELOG:FUNC:VOLT', post_target_params=channel_str)))
            ret_value.update(min_max_enable=self.on_off.to_api(
                self.query('SENS:ELOG:FUNC:VOLT:MINM', post_target_params=channel_str)))
            return ret_value

        # check all parameters
        self.on_off.to_inst(measure_enable)
        self.on_off.to_inst(min_max_enable)

        if channel_obj.model in special_modules:

            limit_msg = "Bad {name} {value}, Should be AUTO or a value from {min} to {max} {units}"
            if isinstance(vrange, str) and vrange == "AUTO":
                vrange = self.on_off.to_inst(True)
            else:
                check_range('vrange', vrange, channel_obj.voltage_range, limit_msg)
        else:
            check_range('vrange', vrange, channel_obj.voltage_range)

        # write to instrument and log errors
        if vrange is not None:
            target = f"{vrange}," + channel_str
            self.write("SENS:ELOG:VOLT:RANG", target)
        if measure_enable is not None:
            target = f"{self.on_off.to_inst(measure_enable)}," + channel_str
            self.write("SENS:ELOG:FUNC:VOLT", target)
        if min_max_enable is not None:
            target = f"{self.on_off.to_inst(min_max_enable)}," + channel_str
            self.write("SENS:ELOG:FUNC:VOLT:MINM", target)

        self.log_inst_errors()

    def setup_period(self, channel, period=None):
        """
        Command and query parameters external datalog period.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param period: This command sets the averaging (or integration) time of an external datalog measurement.
         Datalog measurement records are generated at the rate determined by this time interval. Although the
         absolute minimum logging period is 102.4 microseconds, the actual minimum varies as a function of
         the number of channels and readings that are being logged.  Values are rounded to the nearest
         20.48-microsecond increment.  A value from 0.0001024 to 60.
        :type period: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  SENSe:ELOG:PERiod <NR1>, (@chanlist) Sets the integration time of the external data logging
        channel_str, channel_obj = self._check_channel(channel)

        if period is None:
            return self.query('SENS:ELOG:PER', float, post_target_params=channel_str)
        check_range('period', period, min_max_units(0.0001024, 60, 'Seconds'))
        target = f"{period}," + channel_str
        self.write("SENS:ELOG:PER", target)
        self.log_inst_errors()

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
