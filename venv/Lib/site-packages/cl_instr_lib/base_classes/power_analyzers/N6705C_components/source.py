# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include python libraries
from enum import Enum
from abc import ABC
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.helpers.check_list_values import check_list_num, check_list_on_off

# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


# noinspection PyProtectedMember
class Source:
    """Class for controlling the Source sub-system on the Keysight N6705C Modular DC Power Analyzer."""

    def __init__(self, pow_ana):
        self.write = pow_ana.write
        self.query = pow_ana.query
        self.read_raw = pow_ana.read_raw
        self.log = pow_ana.log
        self._check_channel = pow_ana._check_channel
        self._check_multi_channels = pow_ana._check_multi_channels
        self._raise_error_check_all_channels = pow_ana._raise_error_check_all_channels
        self._check_module = pow_ana._check_module
        self._models_tuple = pow_ana._models_tuple
        self._channel_dict = pow_ana._channel_dict
        self.log_inst_errors = pow_ana.log_inst_errors
        self.get_inst_errors = pow_ana.get_inst_errors
        self.on_off = pow_ana.on_off

        #: Object containing the `Arb`_  methods.
        self.arb = Arb(self)

    # Class attributes
    # ------------------------
    enum_modes = Enum('enum_modes', {"FIXED": 'FIX', "STEP": 'STEP', "LIST": 'LIST', "ARB": 'ARB'})
    enum_bandwidth = Enum('enum_bandwidth', {"LOW": 'LOW', "HIGH1": 'HIGH1', "HIGH2": 'HIGH2', "HIGH3": 'HIGH1'})
    enum_location = Enum("enum_location", {"INTERNAL": "INT", "EXTERNAL": "EXT"})
    enum_ocp_start_func = Enum("enum_ocp_start_func", {'S_CHANGE': "SCH", 'CC_TRANS': "CCTR"})
    enum_priority_functions = Enum("enum_priority_functions", {'VOLTAGE': "VOLT", 'CURRENT': "CURR",
                                                               'POWER': "POW", 'RESISTANCE': "RES"})
    enum_doff_modes = Enum("enum_doff_modes", {'AUTO': 'AUTO', 'MANUAL': 'MAN'})
    enum_inhibit = Enum('enum_inhibit', {"LATCHING": 'LATC', "LIVE": 'LIVE', "OFF": "OFF"})
    enum_smu_preferred_mode = Enum('enum_smu_preferred_mode', {'VOLTAGE': 'VOLT', 'CURRENT': 'CURR'})
    enum_smu_impedance_mode = Enum('enum_smu_impedance_mode', {'HIGHZ': 'HIGHZ', 'LOWZ': 'LOWZ'})
    enum_polarity = Enum('enum_polarity', {'NORMAL': 'NORM', 'REVERSE': 'REV'})

    def output(self, channel, enable=None):
        """
        Command and query the output state of channels.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * [int(1-4)] - list of integer values representing multiple channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | list | channel_obj
        :type channel: int | channel_obj | list
        :param enable: on_off value (True/False Preferred) that determines if a output will be turned on or off.
        :type enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        # OUTPut[:STATe] <Bool> [,NORelay], (@chanlist) Enables/disables the specified output channel(s)
        channel_str, channel_objs = self._check_multi_channels(channel)

        if enable is None:
            enable_str = self.query("OUTP", str, channel_str)
            if len(channel_objs) == 1:
                return self.on_off.to_api(enable_str)
            else:
                enable_list = enable_str.split(",")
                temp_list = []
                index = 0
                for chan in channel_objs:
                    temp_list.append({chan.name: self.on_off.to_api(enable_list[index])})
                    index += 1
                return temp_list

        self.write(f"OUTP {self.on_off.to_inst(enable)}, {channel_str}")
        self.log_inst_errors()

    def output_coupling(self, channels=None, delay_offset=None, offset_mode=None, coupled_protection_en=None):
        """
        Command or query output coupling settings.

        :param channels: Channels to which the changes are taking place. One of the following:

            * [int(1-4)] - list of integer values representing multiple channels.
        :type channels: list
        :param delay_offset: Specifies a maximum delay offset to synchronize the output state changes. A value between
            0 and 1.02 seconds.
        :type delay_offset: int | float
        :param offset_mode: Offset mode that determines where the output coupling delay values are sourced. One of the
            following:

            * AUTO - The power system automatically calculates the maximum delay.
            * MANUAL - The power system use the delay_offset value.
        :type offset_mode: str | enum_doff_modes
        :param coupled_protection_en: on_off value ('ON'/'OFF' preferred) that enables protection on all coupled output
            channels. If one output is tripped, all channels are turned off.  When disabled, Only tripped outputs are
            turned off.
        :type coupled_protection_en: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  OUTPut:COUPle:CHANNel [<NR1> {,<NR1>}] Selects which channels are coupled
        #  OUTPut:COUPle:DOFFset <NRf> Specifies a maximum delay offset to synchronize output changes
        #  OUTPut:COUPle:DOFFset:MODE AUTO | MANual Specifies the output delay coupling mode
        #  OUTPut:PROTection:COUPle <Bool> Enables/disables channel coupling for protection faults

        if all(param is None for param in [channels, delay_offset, offset_mode, coupled_protection_en]):
            ret_val = {}
            ret_val.update(channels=self.query("OUTP:COUP:CHAN", str).split(','))
            ret_val.update(delay_offset=self.query("OUTP:COUP:DOFF", float))
            ret_val.update(offset_mode=self.query("OUTP:COUP:DOFF:MODE", self.enum_doff_modes).name)
            ret_val.update(coupled_protection_en=self.on_off.to_api(self.query("OUTP:PROT:COUP")))
            return ret_val

        # check all parameters
        self.on_off.to_inst(coupled_protection_en)
        check_range('delay_offset', delay_offset, min_max_units(0, 1.02, 'Seconds'))
        offset_mode_obj = check_enum_str('offset_mode', offset_mode, self.enum_doff_modes)
        channel_objs = None
        channel_str = None
        if channels is not None:
            channel_str, channel_objs = self._check_multi_channels(channels)
        # if the user passed in a single channel.
        if channel_objs is not None and not isinstance(channel_objs, (list, tuple)):
            raise ValueError(f"Bad Channels {channels}. Need multiple channels to couple.")

        if channels is not None:
            self.write("OUTP:COUP:CHAN", channel_str)
        if delay_offset is not None:
            self.write("OUTP:COUP:DOFF", delay_offset)
        if offset_mode_obj is not None:
            self.write("OUTP:COUP:DOFF:MODE", offset_mode_obj.value)
        if coupled_protection_en is not None:
            self.write("OUTP:PROT:COUP", self.on_off.to_inst(coupled_protection_en))

        self.log_inst_errors()

    def output_settings(self, channel, rise_time=None, fall_time=None, inhibit=None, watchdog=None, prot_delay=None,
                        watchdog_delay=None, prot_clear=None, smu_preferred_mode=None, smu_impedance_mode=None,
                        oscillation=None, relay_polarity=None):
        """
        Command or Query output settings.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :param rise_time: Specifies the delay in seconds that the instrument waits before enabling the specified output.
            Delay times can be programmed from 0 to 1023 seconds.
        :type rise_time: int | float
        :param fall_time: Specifies the delay in seconds that the instrument waits before disabling the specified
            output. Delay times can be programmed from 0 to 1023 seconds.
        :type fall_time: int | float
        :param inhibit: Specifies the inhibit input. The inhibit functions shuts down all output channels in response
            to a external signal. The following modes can be selected:

            * LATCHING - Causes a logic-true transition on the Inhibit input to disable all outputs. The outputs
              remain disabled until the Inhibit input is returned to logic-false and the latched INH status bit is
              cleared by sending the prot_clear command or a protection clear command from the front panel.
            * LIVE - Allows the enabled outputs to follow the state of the Inhibit input. When the Inhibit input
              is true, the outputs are disabled. When the Inhibit input is false, the outputs are re-enabled.
            * OFF - The Inhibit input is ignored.
        :type inhibit: str | enum_inhibit
        :param prot_delay: Specifies the over_current protection delay. The over-current protection function will
            not be triggered on the specified output channel during the delay time. A value from 0 to 0.255 Seconds.
        :type prot_delay: int | float
        :param watchdog: on_off value ("ON"/"OFF" preferred) that activates the output watchdog timer. When enabled,
            the watchdog timer causes all outputs to go into protection mode if there is no SCPI I/O activity on the
            remote interfaces (USB, LAN, GPIB) within the delay time specified by the watchdog_delay command.
        :type watchdog: str | int | bool
        :param watchdog_delay: Specifies s the output watchdog timer delay in seconds. The watchdog timer causes all
            outputs to go into protection mode if there is no SCPI I/O activity on the remote interfaces
            (USB, LAN, GPIB) within the specified delay time. A value between 0 and 3600 seconds.
        :type watchdog_delay: int | float
        :param prot_clear: on_off value ("ON"/"OFF" preferred) that clears the latched protection status that disables
            output when an over-voltage, over-current, over-temp, and power_limit conditions are detected.
        :type prot_clear: str | int | bool
        :param smu_preferred_mode: (only on N6781A/N6782A) This command sets the preferred mode for output on or output
            off transitions. It allows output state transitions to be optimized for either constant voltage or
            constant current operation. One of the following:

            * VOLTAGE - Minimizes output on/off voltage overshoots in constant voltage operation.
            * CURRENT - Minimizes output on/off current overshoots in constant current operation.
        :type smu_preferred_mode: str | enum_smu_preferred_mode
        :param smu_impedance_mode: This command specifies the output impedance mode at turn-off. (only on N678xA SMU's)
            One of the following:

            * HIGHZ - Sets the output to a high impedance mode at turn-off. In high impedance mode, the output relays
              are opened while the output remains at its set value.
            * LOWZ - Sets the output to a low impedance mode at turn-off. In low impedance mode, the output is
              first down-programmed to zero, after which the output relays are opened.
        :type smu_impedance_mode: str | enum_smu_impedance_mode
        :param oscillation: on_off value ("ON"/"OFF" preferred) that activates output oscillation for protection.
            (only on N678xA SMU's)
        :type oscillation: str | int | bool
        :param relay_polarity: This command sets the output polarity on power modules with polarity reversal relays
            installed (Option 760 required). Polarity reversal affects both the output and the sense terminals. One of
            the following:

            * NORMAL - Causes the output polarity to be the same as the output connector labeling.
            * REVERSE - Causes the output polarity to be the reverse of the output connector labeling.
              This command briefly turns the output off while the output and sense terminal polarities are switched.
        :type relay_polarity: str | enum_polarity
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  OUTPut:DELay:FALL <NRf+>, (@chanlist) Sets the output turn-off sequence delay
        #  OUTPut:DELay:RISE <NRf+>, (@chanlist) Sets the output turn-on sequence delay
        #  OUTPut:INHibit:MODE LATChing | LIVE | OFF Sets the remote inhibit input
        #  OUTPut:PROTection:CLEar (@chanlist) Resets latched protection
        #  OUTPut:PROTection:DELay <NRf+>, (@chanlist) Sets over-current protection programming delay
        #  OUTPut:PROTection:WDOG[:STATe] <Bool> Enables/disables the I/O watchdog timer
        #  OUTPut:PROTection:WDOG:DELay <NRf+> Sets the watchdog timer delay
        #  OUTPut:PMODe VOLTage | CURRent, (@chanlist) Sets the mode for turn on/off transitions (N6761A, N6762A)
        #  OUTPut:TMODe HIGHZ | LOWZ, (@chanlist) Specifies the turn-on/turn-off impedance (only on N678xA SMU)
        #  OUTPut:PROTection:OSCillation <Bool>, (@chanlist) Enables/disables output oscillation protection (N678xA SMU)
        #  OUTPut:RELay:POLarity NORMal | REVerse, (@chanlist) Sets the output relay polarity (Option 760)

        # check the channel
        channel_str, channel_obj = self._check_channel(channel)
        # some formatting for quality of life down below.
        all_keyword_parameters = [rise_time, fall_time, inhibit, watchdog, prot_delay, watchdog_delay, prot_clear,
                                  smu_preferred_mode, smu_impedance_mode, oscillation, relay_polarity]
        smu_parameters = [smu_impedance_mode, oscillation]
        smu_models = ('N6781A', 'N6782A', "N6783A-BAT", "N6784A", 'N6785A', 'N6786A')
        relay_polarity_option = '760'

        if all(param is None for param in all_keyword_parameters):
            ret_val = {}
            ret_val.update(rise_time=self.query("OUTP:DEL:FALL", float, channel_str))
            ret_val.update(fall_time=self.query("OUTP:DEL:RISE", float, channel_str))
            ret_val.update(inhibit=self.query("OUTP:INH:MODE", self.enum_inhibit).name)
            ret_val.update(watchdog=self.on_off.to_api(self.query("OUTP:PROT:WDOG")))
            ret_val.update(prot_delay=self.query("OUTP:PROT:DEL", float, channel_str))
            ret_val.update(watchdog_delay=self.query("OUTP:PROT:WDOG:DEL", float))

            # return more parameters depending on the model connected to the channel.
            if self._check_module(channel_obj.model, smu_models) is not None:
                if self._check_module(channel_obj.model, ['N6781A', 'N6782A']) is not None:
                    ret_val.update(
                        smu_preferred_mode=self.query("OUTP:PMOD", self.enum_smu_preferred_mode, channel_str).name)
                ret_val.update(
                    smu_impedance_mode=self.query("OUTP:TMOD", self.enum_smu_impedance_mode, channel_str).name)
                ret_val.update(oscillation=self.on_off.to_api(self.query("OUTP:PROT:OSC", str, channel_str)))

            if self._check_module(channel_obj.options, relay_polarity_option) is not None:
                ret_val.update(relay_polarity=self.query("OUTP:REL:POL", self.enum_polarity, channel_str).name)

            return ret_val

        # check all parameters
        check_range('rise_time', rise_time, min_max_units(0, 1023, "Seconds"))
        check_range('fall_time', fall_time, min_max_units(0, 1023, "Seconds"))
        inhibit_obj = check_enum_str("inhibit", inhibit, self.enum_inhibit)
        self.on_off.to_inst(watchdog)
        check_range('prot_delay', prot_delay, min_max_units(0, 0.255, 'Seconds'))
        check_range('watchdog_delay', watchdog_delay, min_max_units(0, 3600, 'Seconds'))
        self.on_off.to_inst(prot_clear)
        if prot_clear is not None and prot_clear not in self.on_off.on_vals.from_api:
            raise ValueError(f"Bad prot_clear {prot_clear}. prot_clear should be in {self.on_off.on_vals.from_api}")
        smu_preferred_mode_obj = check_enum_str('smu_preferred_mode', smu_preferred_mode, self.enum_smu_preferred_mode)
        smu_impedance_mode_obj = check_enum_str('smu_impedance_mode', smu_impedance_mode, self.enum_smu_impedance_mode)
        self.on_off.to_inst(oscillation)
        relay_polarity_obj = check_enum_str('relay_polarity', relay_polarity, self.enum_polarity)

        # make sure that if a special parameter is used, that we have the special module attached.
        if not all(param is None for param in smu_parameters):
            # if any of the smu parameters are being used, and none of the models correspond
            if self._check_module(channel_obj.model, smu_models) is None:  # not a valid model
                # cause the invalid channels to trigger the error message creation.
                self._raise_error_check_all_channels(smu_models)

        if smu_preferred_mode_obj is not None:
            # if any of the smu parameters are being used, and none of the models correspond
            if self._check_module(channel_obj.model, ['N6781A', 'N6782A']) is None:  # not a valid model
                # cause the invalid channels to trigger the error message creation.
                self._raise_error_check_all_channels(['N6781A', 'N6782A'])

        if relay_polarity is not None:
            if self._check_module(channel_obj.option, relay_polarity_option) is None:  # not a valid option
                # cause the invalid channels to trigger the error message creation.
                self._raise_error_check_all_channels(relay_polarity_option)

        if rise_time is not None:
            target = f'{rise_time}, {channel_str}'
            self.write("OUTP:DEL:FALL", target)
        if fall_time is not None:
            target = f'{fall_time}, {channel_str}'
            self.write("OUTP:DEL:RISE", target)
        if inhibit_obj is not None:
            self.write("OUTP:INH:MODE", inhibit_obj.value)
        if watchdog is not None:
            self.write("OUTP:PROT:WDOG", self.on_off.to_inst(watchdog))
        if prot_delay is not None:
            target = f'{prot_delay}, {channel_str}'
            self.write("OUTP:PROT:DEL", target)
        if watchdog_delay is not None:
            self.write("OUTP:PROT:WDOG:DEL", watchdog_delay)
        if prot_clear is not None:
            self.write("OUTP:PROT:CLR", channel_str)
        if smu_preferred_mode_obj is not None:
            target = f'{smu_preferred_mode_obj.value}, {channel_str}'
            self.write("OUTP:PMOD", target)
        if smu_impedance_mode_obj is not None:
            target = f'{smu_preferred_mode_obj.value}, {channel_str}'
            self.write("OUTP:TMOD", target)
        if oscillation is not None:
            target = f'{self.on_off.to_inst(oscillation)}, {channel_str}'
            self.write("OUTP:PROT:OSC", target)
        if relay_polarity_obj is not None:
            target = f'{relay_polarity_obj.value}, {channel_str}'
            self.write("OUTP:REL:POL", target)

        self.log_inst_errors()

    def current(self, channel, output=None, trigger_output=None,  trigger_mode=None, output_range=None, ocp_delay=None,
                ocp_start_func=None, ocp_enable=None, smu_slew=None, smu_slew_rate_override=None, smu_pos_limit=None,
                smu_limit_coupling=None, smu_neg_limit=None):
        """
        Command and Query parameters regarding sourcing current on a channel.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param output: An output current value within the boundary of N6705C.chx.current_range. Units are Amps.
        :type output: int | float
        :param trigger_output: The triggered current level of a specified output, stored value that is used when an
            output step is triggered. Within the boundary of N6705C.chx.current_range.
        :type trigger_output: int | float
        :param trigger_mode: Determines what happens to the output when the transient system is initiated and triggered.
            One of the following:

            * FIXED - The output current remains at the immediate value
            * STEP  - The output goes to the triggered level when a trigger occurs.
            * LIST  - The output follows the programmed list values when a trigger occurs.
            * ARB   - The output follows the arbitrary waveform values when a trigger occurs.
        :type trigger_mode: str | enum_modes
        :param output_range: This command sets the output current range on models that have multiple ranges. The value
            that you enter must be the highest value in volts that you expect to source. The instrument selects the
            range with the best resolution for the value entered. Within the boundary of N6705C.chx.current_range.
        :type output_range: int | float
        :param ocp_delay: This command sets the over-current protection delay. The over-current protection function
            will not be triggered on the specified output channel during the delay time. After the delay time has
            expired, the over-current protection function will be active. This prevents momentary changes in output
            status from triggering the over-current protection function. Programmed values can range from 60
            microseconds to 5 milliseconds with a resolution of 20.48 microseconds. (N6783A SMU model only)
        :type ocp_delay: int | float
        :param ocp_start_func: This command specifies the conditions under which the over-current protection delay timer
            starts:

            * SCHange Transitions into constant current mode are automatically ignored during a programmed settings
              change in voltage, current, or output state. At the end of the settings change, the delay timer is
              started, allowing for additional protection delay time. There is no protection delay outside of these
              time windows. This is how the ocp_delay command functioned prior to the availability of the CCTRans
              function.
            * CCTRans The over-current protection delay timer is started by any transition of the output into constant
              current mode.
        :type ocp_start_func: str | enum_ocp_start
        :param ocp_enable: on_off value (e.g "ON"/"OFF") that activates the over-current protection function.
        :type ocp_enable: str | int | bool
        :param smu_slew: This command sets the current slew rate in amps per second. The slew rate setting affects all
            programmed current changes, including those due to the output state turning on or off. The slew rate can
            be set to any value between 0 and 9.9E+37. (N678xA SMU models only)
        :type smu_slew: int | float
        :param smu_slew_rate_override: on_off value (e.g "ON"/"OFF") that activates the current slew rate maximum
            override. When enabled, the power module's slew rate is set to its maximum value. When disabled,
            the power module's slew rate is set to the immediate value of slew. (N678xA SMU models only)
        :type smu_slew_rate_override: str | int | bool
        :param smu_pos_limit: The positive current limit of the specified output. If limit_coupling is enabled,
            this value also sets the negative current limit. A value from 0 - 20.4. (N678xA SMU models only)
        :type smu_pos_limit: int | float
        :param smu_limit_coupling: on_off value (e.g "ON"/"OFF") that activates the coupling of the positive and
            negative limits. (N678xA SMU models only)
        :type smu_limit_coupling: str | int | bool
        :param smu_neg_limit: The negative current limit of the specified output. If limit_coupling is enabled,
            this value also sets the positive current limit. A value from -20.4 to 0. (N6784A SMU model only)
        :type smu_neg_limit: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]CURRent[:LEVel][:IMMediate][:AMPLitude] <NRf+>, (@chanlist) Sets the output current
        #  [SOURce:]CURRent[:LEVel]:TRIGgered [:AMPLitude] <NRf+>, (@chanlist) Sets the triggered output current
        #  [SOURce:]CURRent:MODE FIXed | STEP | LIST | ARB, (@chanlist) Sets the current trigger mode
        #  [SOURce:]CURRent:RANGe <NRf+>, (@chanlist) Sets the output current range
        #  [SOURce:]CURRent:PROTection:DELay[:TIME] <NRf+> (@chanlist) Sets the over-current protection programming
        #  delay
        #  [SOURce:]CURRent:PROTection:DELay:STARt SCHange | CCTRans, (@chanlist) Sets the over-current protection
        #  programming mode
        #  [SOURce:]CURRent:PROTection:STATe <Bool>, (@chanlist) Enables/disables over-current protection on the
        #  selected output
        #  [SOURce:]CURRent:SLEW[:IMMediate] <NRf+> | INFinity, (@chanlist) Sets the output current slew rate
        #  (N678xA SMU)
        #  [SOURce:]CURRent:SLEWMAXimum <Bool>, (@chanlist) Enables/disables the maximum slew rate override
        #  (N678xA SMU)
        #  [SOURce:]CURRent:LIMit[:POSitive][:IMMediate][:AMPLitude] <NRf+>, (@chanlist) Sets the positive
        #  current limit (only on N678xA SMU, N6783A)
        #  [SOURce:]CURRent:LIMit:COUPle <Bool>, (@chanlist) Sets the current limit tracking state (only on N678xA SMU)
        #  [SOURce:]CURRent:LIMit:NEGative[:IMMediate][:AMPLitude] <NRf+>, (@chanlist) Sets the negative current limit
        #  (only on N678xA SMU, N6783A-BAT)

        # check the channel
        channel_str, channel_obj = self._check_channel(channel)
        # some formatting for quality of life down below.
        all_keyword_parameters = [output, trigger_output, trigger_mode, output_range, ocp_delay, ocp_start_func,
                                  ocp_enable, smu_slew, smu_slew_rate_override, smu_pos_limit, smu_limit_coupling,
                                  smu_neg_limit]

        smu_parameters = [smu_slew, smu_slew_rate_override, smu_pos_limit, smu_limit_coupling, smu_neg_limit]
        smu_models = ('N6781A', 'N6782A', "N6783A-BAT", "N6784A", 'N6785A', 'N6786A')

        # read back all relevant parameters for a model
        if all(param is None for param in all_keyword_parameters):
            ret_val = {}
            ret_val.update(output=self.query("CURR", float, channel_str))
            ret_val.update(trigger_output=self.query("CURR:TRIG", float, channel_str))
            ret_val.update(trigger_mode=self.query("CURR:MODE", self.enum_modes, channel_str).name)
            ret_val.update(output_range=self.query("CURR:RANGE", float, channel_str))
            ret_val.update(ocp_delay=self.query("CURR:PROT:DEL", float, channel_str))
            ret_val.update(ocp_start_func=self.query("CURR:PROT:DEL:STAR", self.enum_ocp_start_func, channel_str).name)
            ret_val.update(ocp_enable=self.on_off.to_api(self.query("CURR:PROT:STAT", str, channel_str)))

            # return more parameters depending on the model connected to the channel.
            if self._check_module(channel_obj.model, smu_models) is not None:
                ret_val.update(smu_slew=self.query("CURR:SLEW", float, channel_str))
                ret_val.update(smu_slew_rate_override=self.on_off.to_api(self.query("CURR:SLEW:MAX", str, channel_str)))
                ret_val.update(smu_pos_limit=self.query("CURR:LIM", float, channel_str))
                ret_val.update(smu_limit_coupling=self.on_off.to_api(self.query("CURR:LIM:COUP", str, channel_str)))
                ret_val.update(smu_neg_limit=self.query("CURR:LIM:NEG", float, channel_str))
            return ret_val

        # check all parameters
        check_range('output', output, channel_obj.current_range)
        check_range('trigger_output', trigger_output, channel_obj.current_range)
        trigger_mode_obj = check_enum_str("trigger_mode", trigger_mode, self.enum_modes)
        check_range('output_range', output_range, channel_obj.current_range)
        check_range('ocp_delay', ocp_delay, min_max_units(0, 0.255, 'Seconds'))
        ocp_start_func_obj = check_enum_str('ocp_start_func', ocp_start_func, self.enum_ocp_start_func)
        self.on_off.to_inst(ocp_enable)
        check_range('smu_slew', smu_slew, min_max_units(0, 9.9e37, "slew rate"))
        self.on_off.to_inst(smu_slew_rate_override)
        check_range('smu_pos_limit', smu_pos_limit, min_max_units(0, 3.06, 'Amps'))
        self.on_off.to_inst(smu_limit_coupling)
        if channel_obj.model == 'N6783A-BAT':
            check_range('smu_neg_limit', smu_neg_limit, min_max_units(-2, 0, 'Amps'))
        check_range('smu_neg_limit', smu_neg_limit, min_max_units(-3.06, 0, 'Amps'))

        # make sure that if a special parameter is used, that we have the special module attached.
        if not all(param is None for param in smu_parameters):
            # if any of the smu parameters are being used, and none of the models correspond
            if self._check_module(channel_obj.model, smu_models) is None:  # not a valid model
                # cause the invalid channels to trigger the error message creation.
                self._raise_error_check_all_channels(smu_models)

        # write to the instrument and log errors
        if output is not None:
            target = f'{output}, {channel_str}'
            self.write("CURR", target)
        if trigger_output is not None:
            target = f'{trigger_output}, {channel_str}'
            self.write("CURR:TRIG", target)
        if trigger_mode_obj is not None:
            target = f'{trigger_mode_obj.value}, {channel_str}'
            self.write("CURR:MODE", target)
        if output_range is not None:
            target = f'{output_range}, {channel_str}'
            self.write("CURR:RANGE", target)
        if ocp_delay is not None:
            target = f'{ocp_delay}, {channel_str}'
            self.write("CURR:PROT:DEL", target)
        if ocp_start_func_obj is not None:
            target = f'{ocp_start_func_obj.value}, {channel_str}'
            self.write("CURR:PROT:DEL:STAR", target)
        if ocp_enable is not None:
            target = f'{self.on_off.to_inst(ocp_enable)}, {channel_str}'
            self.write("CURR:PROT:STAT", target)
        if smu_slew is not None:
            target = f'{smu_slew}, {channel_str}'
            self.write("CURR:SLEW", target)
        if smu_slew_rate_override is not None:
            target = f'{self.on_off.to_inst(smu_slew_rate_override)}, {channel_str}'
            self.write("CURR:SLEW:MAX", target)
        if smu_pos_limit is not None:
            target = f'{smu_pos_limit}, {channel_str}'
            self.write("CURR:LIM", target)
        if smu_limit_coupling is not None:
            target = f'{self.on_off.to_inst(smu_limit_coupling)}, {channel_str}'
            self.write("CURR:LIM:COUP", target)
        if smu_neg_limit is not None:
            target = f'{smu_neg_limit}, {channel_str}'
            self.write("CURR:LIM:NEG", target)

        self.log_inst_errors()

    def voltage(self, channel, output=None, trigger_output=None,  trigger_mode=None, ovp_level=None, output_range=None,
                sense_relay=None, slew=None, slew_rate_override=None, smu_pos_limit=None, smu_limit_coupling=None,
                smu_neg_limit=None, smu_bandwidth=None, smu_ovp_delay=None, smu_pos_ovp_lvl=None, smu_neg_ovp_lvl=None):
        """
        Command and Query parameters regarding sourcing Voltage on a channel.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param output: An output voltage value within the boundary of N6705C.chx.voltage_range. Units are Volts.
        :type output: int | float
        :param trigger_output: The triggered voltage level of a specified output, stored value that is used when an
            output step is triggered. Within the boundary of N6705C.chx.voltage_range.
        :type trigger_output: int | float
        :param trigger_mode: Determines what happens to the output when the transient system is initiated and triggered.
            One of the following:

            * FIXED - The output voltage remains at the immediate value
            * STEP  - The output goes to the triggered level when a trigger occurs.
            * LIST  - The output follows the programmed list values when a trigger occurs.
            * ARB   - The output follows the arbitrary waveform values when a trigger occurs.
        :type trigger_mode: str | enum_modes
        :param ovp_level: Command that sets over-voltage protection level on the output channel. If the output voltage
            exceeds the OVP level, the output is disabled and the Questionable Condition status register OV bit is set.
            Within the boundary of N6705C.chx.voltage_range. (Applies to all Non N678xA SMU models)
        :type ovp_level: int | float
        :param output_range: This command sets the output voltage range on models that have multiple ranges. The value
            that you enter must be the highest value in volts that you expect to source. The instrument selects the
            range with the best resolution for the value entered. Within the boundary of N6705C.chx.voltage_range.
        :type output_range: int | float
        :param sense_relay: This parameter sets the state of the remote sense relays. one of the following:

            * INTernal - Internal sets the remote sense relays to local sensing. The front panel remote sense terminals
              are internally connected to the output terminals. The 4 wire indicator is off.
            * EXTernal - External sets the remote sense relays to remote sensing. The front panel remote sense terminals
              are not internally connected to the output terminals and must be connected to the external load.
              The 4 wire indicator is on.
        :type sense_relay: str | enum_location
        :param slew: This command sets the voltage slew rate in volts per second. The slew rate setting affects all
            programmed voltage changes, including those due to the output state turning on or off. The slew rate can
            be set to any value between 0 and 9.9E+37.
        :type slew: int | float
        :param slew_rate_override: on_off value (e.g "ON"/"OFF") that activates the voltage slew rate maximum override.
            When enabled, the power module's slew rate is set to its maximum value. When disabled, the power module's
            slew rate is set to the immediate value of slew.
        :type slew_rate_override: str | int | bool
        :param smu_pos_limit: The positive voltage limit of the specified output. If limit_coupling is enabled,
            this value also sets the negative voltage limit. A value from 0 - 20.4. (N678xA SMU models only)
        :type smu_pos_limit: int | float
        :param smu_limit_coupling: on_off value (e.g "ON"/"OFF") that activates the coupling of the positive and
            negative limits. (N678xA SMU models only)
        :type smu_limit_coupling: str | int | bool
        :param smu_neg_limit: The negative voltage limit of the specified output. If limit_coupling is enabled,
            this value also sets the positive voltage limit. A value from -20.4 to 0. (N6784A SMU model only)
        :type smu_neg_limit: int | float
        :param smu_bandwidth: Specifies voltage bandwidth. Lets you optimize response time with capacitive loads.
            One of the following: (N678xA SMU models only)

            * LOW - 0-150 microfarads. Local or Remote.
            * HIGH1 -  0 1 microfarads. Remote only.
            * HIGH2 - 1-7 microfarads Remote only.
            * HIGH3 - 7-150 microfarads Remote only.
        :type smu_bandwidth: str | enum_bandwidth
        :param smu_ovp_delay: This command sets the over-voltage protection delay. The over-voltage protection function
            will not be triggered on the specified output channel during the delay time. After the delay time has
            expired, the over-voltage protection function will be active. This prevents momentary changes in output
            status from triggering the over-current protection function. Programmed values can range from 60
            microseconds to 5 milliseconds with a resolution of 20.48 microseconds. (N6783A SMU model only)
        :type smu_ovp_delay: int | float
        :param smu_pos_ovp_lvl: This command sets the remote positive over-voltage remote protection (OVP) level of
            the output channel. The values are programmed in volts. If the output voltage exceeds the OVP level,
            the output is disabled and the Questionable Condition status register OV bit is set.
            A value from 0 - 22. (N678xA SMU models only)
        :type smu_pos_ovp_lvl: int | float
        :param smu_neg_ovp_lvl: This command sets the remote negative over-voltage remote protection (OVP) level of
            the output channel. The values are programmed in volts. If the output voltage exceeds the OVP level,
            the output is disabled and the Questionable Condition status register OV bit is set.
            A value from -22 - 0. (N678xA SMU models only)
        :type smu_neg_ovp_lvl:
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        # [SOURce:]VOLTage
        #  [SOURce:]VOLTage[:LEVel][:IMMediate][:AMPLitude] <NRf+>, (@chanlist) Sets the output voltage
        #  [SOURce:]VOLTage[:LEVel]:TRIGgered [:AMPLitude] <NRf+>, (@chanlist) Sets the triggered output voltage
        #  [SOURce:]VOLTage:BWIDth DEFault | FAST1 | FAST2 | FAST3, (@chanlist) Sets the voltage bandwidth
        #  (only on N678xA SMU)
        #  [SOURce:]VOLTage:LIMit[:POSitive][:IMMediate][:AMPLitude] <NRf+>, (@chanlist) Sets the positive voltage limit
        #  (only on N678xA SMU)
        #  [SOURce:]VOLTage:LIMit:COUPle <Bool>, (@chanlist) Sets the voltage limit tracking state (only on N6784A)
        #  [SOURce:]VOLTage:LIMit:NEGative[:IMMediate][:AMPLitude] <NRf+>, (@chanlist) Sets the negative voltage limit
        #  (only on N6784A)
        #  [SOURce:]VOLTage:MODE FIXed | STEP | LIST | ARB, (@chanlist) Sets the voltage trigger mode
        #  [SOURce:]VOLTage:PROTection[:LEVel] <NRf+>, (@chanlist) Sets the over-voltage protection level
        #  (not on N678xA SMU)
        #  [SOURce:]VOLTage:PROTection:DELay[:TIME] <NRf+>, (@chanlist) Sets the over-voltage protection delay
        #  (only on N6783A)
        #  [SOURce:]VOLTage:PROTection:REMote[:POSitive][:LEVel] <NRf+>, (@chanlist) Sets the positive remote OV
        #  protection level (only on N678x ASMU)
        #  [SOURce:]VOLTage:PROTection:REMote:NEGative[:LEVel] <NRf+>, (@chanlist) Sets the negative remote OV
        #  protection level (only on N6784A)
        #  [SOURce:]VOLTage:RANGe <NRf+>, (@chanlist) Sets the output voltage range
        #  [SOURce:]VOLTage:SENSe:SOURce INTernal | EXTernal, (@chanlist) Sets the remote sense relays
        #  [SOURce:]VOLTage:SLEW[:IMMediate] <NRf+> | INFinity, (@chanlist) Sets the output voltage slew rate
        #  [SOURce:]VOLTage:SLEW:MAXimum <Bool>, (@chanlist) Enables/disables the maximum slew rate override

        # check the channel
        channel_str, channel_obj = self._check_channel(channel)

        # some formatting for quality of life down below.
        all_keyword_parameters = [output, trigger_output,  trigger_mode, ovp_level, output_range, sense_relay, slew,
                                  slew_rate_override, smu_pos_limit, smu_limit_coupling, smu_neg_limit, smu_bandwidth,
                                  smu_ovp_delay, smu_pos_ovp_lvl, smu_neg_ovp_lvl]
        smu_parameters = [smu_pos_limit, smu_limit_coupling, smu_bandwidth, smu_pos_ovp_lvl, smu_neg_ovp_lvl]
        smu_models = ('N6781A', 'N6782A', "N6783A-BAT", "N6784A", 'N6785A', 'N6786A')
        smu_ovp_delay_model = 'N6783A-BAT'
        smu_neg_limit_model = 'N6784A'

        non_smu_models = [param for param in channel_obj._all_model_names]  # Deep copy
        for model in smu_models:
            non_smu_models.remove(model)

        # read back all relevant parameters for a model
        if all(param is None for param in all_keyword_parameters):
            ret_val = {}
            ret_val.update(output=self.query("VOLT", float, channel_str))
            ret_val.update(trigger_output=self.query("VOLT:TRIG", float, channel_str))
            ret_val.update(trigger_mode=self.query("VOLT:MODE", self.enum_modes, channel_str).name)
            if self._check_module(channel_obj.model, non_smu_models) is not None:
                ret_val.update(ovp_level=self.query("VOLT:PROT", float, channel_str))
            ret_val.update(output_range=self.query("VOLT:RANGE", float, channel_str))
            ret_val.update(sense_relay=self.query("VOLT:SENS:SOUR", self.enum_location, channel_str).name)
            ret_val.update(slew=self.query("VOLT:SLEW", float, channel_str))
            ret_val.update(slew_rate_override=self.on_off.to_api(self.query("VOLT:SLEW:MAX", str, channel_str)))

            # return more parameters depending on the model connected to the channel.
            if self._check_module(channel_obj.model, smu_models) is not None:

                ret_val.update(smu_pos_limit=self.query("VOLT:LIM", float, channel_str))
                ret_val.update(smu_limit_coupling=self.on_off.to_api(self.query("VOLT:LIM:COUP", str, channel_str)))
                if self._check_module(channel_obj.model, smu_neg_limit_model) is not None:
                    ret_val.update(smu_neg_limit=self.query("VOLT:LIM:NEG", float, channel_str))
                ret_val.update(smu_bandwidth=self.query("VOLT:BWID", self.enum_bandwidth, channel_str).name)
                if self._check_module(channel_obj.model, smu_ovp_delay_model) is not None:
                    ret_val.update(smu_ovp_delay=self.query("VOLT:PROT:DEL", float, channel_str))
                ret_val.update(smu_pos_ovp_lvl=self.query("VOLT:PROT:REM", float, channel_str))
                ret_val.update(smu_neg_ovp_lvl=self.query("VOLT:PROT:REM:NEG", float, channel_str))
            return ret_val

        # check all parameters
        check_range('output', output, channel_obj.voltage_range)
        check_range('trigger_output', trigger_output, channel_obj.voltage_range)
        trigger_mode_obj = check_enum_str("trigger_mode", trigger_mode, self.enum_modes)
        check_range('ovp_level', ovp_level, channel_obj.voltage_range)
        check_range('output_range', output_range, channel_obj.voltage_range)
        sense_relay_obj = check_enum_str("sense_relay", sense_relay, self.enum_location)
        check_range('slew', slew, min_max_units(0, 9.9e37, "slew rate"))
        self.on_off.to_inst(slew_rate_override)
        check_range('smu_pos_limit', smu_pos_limit, min_max_units(0, 20.4, 'Volts'))
        self.on_off.to_inst(smu_limit_coupling)
        check_range('smu_neg_limit', smu_neg_limit, min_max_units(-20.4, 0, 'Volts'))
        smu_bandwidth_obj = check_enum_str("smu_bandwidth", smu_bandwidth, self.enum_bandwidth)
        check_range('smu_ovp_delay', smu_ovp_delay, min_max_units(0.000060, 0.005, 'Seconds'))
        check_range('smu_pos_ovp_lvl', smu_pos_ovp_lvl, min_max_units(0, 22, 'Volts'))
        check_range('smu_neg_ovp_lvl', smu_neg_ovp_lvl, min_max_units(-22, 0, 'Volts'))

        # make sure that if a special parameter is used, that we have the special module attached.
        # cause the invalid channels to trigger the error message creation.
        if ovp_level is not None and self._check_module(channel_obj.model, non_smu_models) is None:
            self._raise_error_check_all_channels(non_smu_models)

        if smu_neg_limit is not None and self._check_module(channel_obj.model, smu_neg_limit_model) is None:
            self._raise_error_check_all_channels(smu_neg_limit_model)

        if smu_ovp_delay is not None and self._check_module(channel_obj.model, smu_ovp_delay_model) is None:
            self._raise_error_check_all_channels(smu_ovp_delay)

        # if any of the smu parameters are being used, and none of the models correspond
        if not all(param is None for param in smu_parameters):
            if self._check_module(channel_obj.model, smu_models) is None:  # not a valid model
                self._raise_error_check_all_channels(smu_models)

        # write to the instrument and log errors
        if output is not None:
            target = f'{output}, {channel_str}'
            self.write("VOLT", target)
        if trigger_output is not None:
            target = f'{trigger_output}, {channel_str}'
            self.write("VOLT:TRIG", target)
        if trigger_mode_obj is not None:
            target = f'{trigger_mode_obj.value}, {channel_str}'
            self.write("VOLT:MODE", target)
        if ovp_level is not None:
            target = f'{ovp_level}, {channel_str}'
            self.write("VOLT:PROT", target)
        if output_range is not None:
            target = f'{output_range}, {channel_str}'
            self.write("VOLT:RANGE", target)
        if sense_relay_obj is not None:
            target = f'{sense_relay_obj.value}, {channel_str}'
            self.write("VOLT:SENS:SOUR", target)
        if slew is not None:
            target = f'{slew}, {channel_str}'
            self.write("VOLT:SLEW", target)
        if slew_rate_override is not None:
            target = f'{self.on_off.to_inst(slew_rate_override)}, {channel_str}'
            self.write("VOLT:SLEW:MAX", target)
        if smu_pos_limit is not None:
            target = f'{smu_pos_limit}, {channel_str}'
            self.write("VOLT:LIM", target)
        if smu_limit_coupling is not None:
            target = f'{self.on_off.to_inst(smu_limit_coupling)}, {channel_str}'
            self.write("VOLT:LIM:COUP", target)
        if smu_neg_limit is not None:
            target = f'{smu_neg_limit}, {channel_str}'
            self.write("VOLT:LIM:NEG", target)
        if smu_bandwidth_obj is not None:
            target = f'{smu_bandwidth_obj.value}, {channel_str}'
            self.write("VOLT:BWID", target)
        if smu_ovp_delay is not None:
            target = f'{smu_ovp_delay}, {channel_str}'
            self.write("VOLT:PROT:DEL", target)
        if smu_pos_ovp_lvl is not None:
            target = f'{smu_pos_ovp_lvl}, {channel_str}'
            self.write("VOLT:PROT:REM", target)
        if smu_neg_ovp_lvl is not None:
            target = f'{smu_neg_ovp_lvl}, {channel_str}'
            self.write("VOLT:PROT:REM:NEG", target)

        self.log_inst_errors()

    def resistance(self, channel, level=None, enable=None):
        """

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param level: Sets the output resistance level on the instrument, within the range of
            N6705C.ch<x>.resistance_range. **Note:** It is possible that a module supports programming resistance and
            does not have a resistance range. A warning will occur if the channel does not have a resistance_range, and
            an warning and instrument error will occur if out of range or unsupported.
        :type level: int | float
        :param enable: on_off value ('ON'/'OFF' preferred) that emables output resistance programming. Only applicable
            to models (N6781A, N6785A).
        :type enable: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]RESistance[:LEVel][:IMMediate][:AMPLitude] <NRf+>, (@chanlist) Sets the output resistance
        #  (only on N6781A, N6785A)
        #  [SOURce:]RESistance[:LEVel]:STATe <Bool>, (@chanlist) Enables/disables output resistance programming
        #  (N6781A, N6785A)
        channel_str, channel_obj = self._check_channel(channel)

        # TODO: resistance boundaries are unknown for many modules.
        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get("RES")
        if wave_boundaries is None:
            self.log.warning(f"Model does not have a resistance range usable for error checking.")
            wave_boundaries = min_max_units(0, 1e12, 'Ohms (No resistance_range found)')

        # read back
        if all(param is None for param in [level, enable]):
            ret_val = {}
            ret_val.update(level=self.query("RES", float, channel_str))
            if self._check_module(channel_obj.model, ['N6781A', 'N6785A']) is not None:
                ret_val.update(level=self.on_off.to_api(self.query("RES:STAT", str, channel_str)))
            return ret_val

        # check all parameters
        check_range('level', level, wave_boundaries)
        self.on_off.to_inst(enable)

        # write and log errors
        if level is not None:
            target = f'{level}, {channel_str}'
            self.write("RES", target)
        if enable is not None:
            target = f'{self.on_off.to_inst(enable)}, {channel_str}'
            self.write("RES:STAT", target)
        self.log_inst_errors()

    def power(self, channel, limit=None):
        """
        Command and query the power limit of an output channel.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param limit: Sets the power limit of the channel, Units are in Watts. Most modules are defaulted to their full
            power
        :type limit:
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: str | None
        """
        # [SOURce:]POWer:LIMit <NRf+>, (@chanlist) Sets the power limit on output channels
        channel_str, channel_obj = self._check_channel(channel)

        # read back
        if limit is None:
            limit = self.query("POW:LIM", float, channel_str)
            return limit

        # check all parameters
        check_range('limit', limit, channel_obj.power_range)

        # write and log errors
        target = f'{limit}, {channel_str}'
        self.write("POW:LIM", target)
        self.log_inst_errors()

    def priority_mode(self, channel, function_priority=None):
        """
        Command and query the priority mode of the channels output.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function_priority:
        :type function_priority:
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: str | None
        """
        # [SOURce:]FUNCtion CURRent | VOLTage, (@chanlist) Specifies current priority or voltage priority mode
        # (N678xA SMU)
        channel_str, channel_obj = self._check_channel(channel)

        # read back
        if function_priority is None:
            function_priority = self.query("FUNC", self.enum_priority_functions, channel_str).name
            return function_priority

        # check all parameters
        function_priority_obj = check_enum_str('function_priority', function_priority, self.enum_priority_functions)

        # write and log errors
        if function_priority_obj is not None:
            target = f'{function_priority_obj.value}, {channel_str}'
            self.write("FUNC", target)
        self.log_inst_errors()

    def step(self, channel, trigger_step=None):
        """
        Command and query the output channel to step to the trigger_output level

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param trigger_step:
        :type trigger_step:
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: str | None
        """
        #  [SOURce:]STEP:TOUTput <Bool>, (@chanlist) Generate a trigger output on the voltage or current step
        channel_str, channel_obj = self._check_channel(channel)

        # read back
        if trigger_step is None:
            trigger_step = self.on_off.to_api(self.query("STEP:TOUT", str, channel_str))
            return trigger_step

        # check all parameters
        # write and log errors
        if trigger_step is not None:
            target = f'{self.on_off.to_inst(trigger_step)}, {channel_str}'
            self.write("STEP:TOUT", target)
        self.log_inst_errors()

    # TODO future functionality that can be added.
    # def emulation(self, channel, emu_type=None):
    #     """
    #
    #     :param channel: Channel to which the changes are taking place. One of the following:
    #
    #         * 1-4 - integer value representing a single channel of the four possible channels.
    #         * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
    #     :type channel: int | channel_obj
    #     :param emu_type:
    #     :type emu_type:
    #     :return: If called empty, returns the method's parameters reflecting the state of the instrument.
    #     :rtype: str | None
    #     """
    #     # [SOURce:]EMULation <type>, (@chanlist) Specifies the emulation mode on N678xA <type> = PS4Q, PS2Q,
    #     # PS1Q, BATTery, CHARger, CCLoad, CVLoad, VMETer, AMETer
    #     pass

    # def digital(self):
    #     #  [SOURce:]DIGital:INPut:DATA? Reads the state of the digital port pins
    #     #  [SOURce:]DIGital:OUTPut:DATA <NRf> Sets the digital port
    #     #  [SOURce:]DIGital:PIN<1-7>:FUNCtion <function> Sets the selected pin’s
    #     #  function <function>= DIO, DINPut,TOUTput, TINPput, FAULt, INHibit, ONCouple, OFFCouple
    #     #  [SOURce:]DIGital:PIN<1-7>:POLarity POSitive | NEGative Sets the selected pin’s polarity
    #     #  [SOURce:]DIGital:TOUTput:BUS [:ENABle] <Bool> Enables/disables BUS-generated triggers on digital pins
    #     pass
    #
    # def list(self):
    #     #  [SOURce:]LIST:COUNt <NRf+> | INFinity, (@chanlist) Sets the list repeat count
    #     #  [SOURce:]LIST:CURRent[:LEVel] <NRf> {,<NRf>}, (@chanlist) Sets the current list
    #     #  [SOURce:]LIST:CURRent:POINts? (@chanlist) Returns the number of current list points
    #     #  [SOURce:]LIST:DWELl <NRf> {,<NRf>}, (@chanlist) Sets the list of dwell times
    #     #  [SOURce:]LIST:DWELl:POINts? (@chanlist) Returns the number of dwell list points
    #     #  [SOURce:]LIST:STEP ONCE | AUTO, (@chanlist) Specifies how the list responds to triggers
    #     #  [SOURce:]LIST:TERMinate:LAST <Bool>, (@chanlist) Sets the list termination mode
    #     # [SOURce:]LIST:TOUTput:BOSTep[:DATA] <Bool> {,<Bool>}, (@chanlist) Generate triggers at the Beginning Of STep
    #     #  [SOURce:]LIST:TOUTput:BOSTep:POINts? (@chanlist) Returns the number of BOST list points
    #     #  [SOURce:]LIST:TOUTput:EOSTep[:DATA] <Bool> {,<Bool>}, (@chanlist) Generate triggers at the End Of STep
    #     #  [SOURce:]LIST:TOUTput:EOSTep:POINts? (@chanlist) Returns the number of EOST list points
    #     #  [SOURce:]LIST:VOLTage[:LEVel] <NRf> {,<NRf>}, (@chanlist) Sets the voltage list
    #     #  [SOURce:]LIST:VOLTage:POINts? (@chanlist) Returns the number of voltage list points
    #     pass


# noinspection PyProtectedMember
class Arb:
    """
    Class for controlling arbitrary waveforms within the source sub-system on the Keysight N6705C Modular DC
    Power Analyzer.
    """

    def __init__(self, pow_ana):
        self.write = pow_ana.write
        self.query = pow_ana.query
        self.read_raw = pow_ana.read_raw
        self.log = pow_ana.log
        self._check_channel = pow_ana._check_channel
        self._check_multi_channels = pow_ana._check_multi_channels
        self._check_module = pow_ana._check_module
        self._models_tuple = pow_ana._models_tuple
        self._channel_dict = pow_ana._channel_dict
        self.log_inst_errors = pow_ana.log_inst_errors
        self.get_inst_errors = pow_ana.get_inst_errors
        self.on_off = pow_ana.on_off

        #: Object containing the `Step`_  methods.
        self.step = Step(self)

        #: Object containing the `Ramp`_  methods.
        self.ramp = Ramp(self)

        #: Object containing the `Staircase`_  methods.
        self.staircase = Staircase(self)

        #: Object containing the `Sinusoid`_  methods.
        self.sinusoid = Sinusoid(self)

        #: Object containing the `Pulse`_  methods.
        self.pulse = Pulse(self)

        #: Object containing the `Trapezoid`_  methods.
        self.trapezoid = Trapezoid(self)

        #: Object containing the `Exponential`_  methods.
        self.exponential = Exponential(self)

        #: Object containing the `User_defined`_  methods.
        self.user_defined = UserDefined(self)

        #: Object containing the `Constant_dwell`_  methods.
        self.constant_dwell = ConstantDwell(self)

        #: Object containing the `Sequence`_  methods.
        self.sequence = Sequence(self)

    enum_arb_functions = Enum('enum_arb_functions', {"VOLTAGE": 'VOLT',
                                                     "CURRENT": 'CURR',
                                                     "RESISTANCE": 'RES',
                                                     "POWER": 'POW', })

    enum_arb_shapes = Enum('enum_arb_shapes', {"STEP": 'STEP',
                                               "RAMP": 'RAMP',
                                               "STAIRCASE": 'STA',
                                               "SINUSOID": 'SIN',
                                               "PULSE": 'PULS',
                                               "TRAPEZOID": 'TRAP',
                                               "EXPONENTIAL": 'EXP',
                                               "USER_DEFINED": 'UDEF',
                                               "CONSTANT_DWELL": 'CDW',
                                               "SEQUENCE": 'SEQ',
                                               "NONE": 'NONE'})

    def setup(self, channel, function=None, shape=None, count=None, termination_en=None):
        """
        Configure and query the general settings of the arbitrary waveform system.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param shape: Specifies the possible arbitrary waveform shape. One of the following:

            * STEP - Specifies a step waveform.
            * RAMP - Specifies a ramp waveform.
            * STAIRCASE - Specifies a staircase waveform.
            * SINUSOID - Specifies a sine wave waveform.
            * PULSE - Specifies a pulse waveform.
            * TRAPEZOID - Specifies a trapezoidal waveform.
            * EXPONENTIAL - Specifies a exponential waveform.
            * USER_DEFINED - Specifies a user defined waveform.
            * CONSTANT_DWELL - Specifies a constant dwell waveform.
            * SEQUENCE - Specifies a sequence of arbitrary waveforms.
            * NONE - Specifies no arbitrary waveform.
        :type shape: str | enum_arb_shapes
        :param count: Amount that the arbitrary waveform repeats. A value between 1 and 16777216 or 'INF'
        :type count: int | str
        :param termination_en: on_off value ('ON'/'OFF' Preferred) that dertermines the output value when an arbitrary
             waveform terminates. When on, output stays at the last arb value and becomes an immediate value. When off,
             the output returns to the settings in effect before the arb started.
        :type termination_en: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:FUNCtion <function>, (@chanlist) Selects the Arb function (for backward compatibility)
        #  [SOURce:]ARB:FUNC:SHAPe <function>, (@chanlist) Selects the Arb function (replaces ARB:FUNCtion)
        #  [SOURce:]ARB:FUNC:TYPE CURRent | VOLTage, (@chanlist) Selects the Arb type (replaces ARB:FUNCtion)
        #  [SOURce:]ARB:COUNt <NRf+> | INFinity, (@chanlist) Sets the Arb repeat count
        #  [SOURce:]ARB:TERMinate:LAST <Bool>, (@chanlist) Sets the Arb termination mode

        channel_str, channel_obj = self._check_channel(channel)

        # read back
        if all(param is None for param in [function, shape, count]):
            ret_val = {}
            ret_val.update(function=self.query("ARB:FUNC:TYPE", self.enum_arb_functions, channel_str).name)
            ret_val.update(shape=self.query("ARB:FUNC:SHAP", self.enum_arb_shapes, channel_str).name)

            # instrument does not send back INF but a large number, accept either INF or a number outside of range.
            temp_count = self.query("ARB:COUN", str, channel_str)
            count = "INF" if (temp_count == 'INF' or float(temp_count) > 16777216) else float(temp_count)
            ret_val.update(count=count)
            ret_val.update(termination_en=self.on_off.to_api(self.query("ARB:TERM:LAST", str, channel_str)))
            return ret_val

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_arb_functions)
        shape_obj = check_enum_str('shape', shape, self.enum_arb_shapes)
        self.on_off.to_inst(termination_en)

        if count is not None:
            error_msg = "Bad {name} {value}, Should be a value between {min} and {max} or 'INF'."

            if isinstance(count, (int, float)):
                check_range('count', count, min_max_units(1, 16777216, 'waves'), error_msg)
            elif not (isinstance(count, str) and count == 'INF'):  # User either enters INF or errors out.
                raise ValueError(f"Bad count {count}, Should be a value between 1 and 16777216 or 'INF'.")

        # write and log errors
        if function is not None:
            target = f'{function_obj.value}, {channel_str}'
            self.write("ARB:FUNC:TYPE", target)
        if shape is not None:
            target = f'{shape_obj.value}, {channel_str}'
            self.write("ARB:FUNC:SHAP", target)
        if count is not None:
            target = f'{count}, {channel_str}'
            self.write("ARB:COUN", target)
        if termination_en is not None:
            target = f'{self.on_off.to_inst(termination_en)}, {channel_str}'
            self.write("ARB:TERM:LAST", target)

        self.log_inst_errors()


class ArbWaveABC(ABC):

    # noinspection PyProtectedMember
    def __init__(self, pow_ana):
        self.write = pow_ana.write
        self.query = pow_ana.query
        self.read_raw = pow_ana.read_raw
        self.log = pow_ana.log
        self._check_channel = pow_ana._check_channel
        self._check_multi_channels = pow_ana._check_multi_channels
        self._check_module = pow_ana._check_module
        self._models_tuple = pow_ana._models_tuple
        self._channel_dict = pow_ana._channel_dict
        self.log_inst_errors = pow_ana.log_inst_errors
        self.get_inst_errors = pow_ana.get_inst_errors
        self.on_off = pow_ana.on_off

    enum_arb_functions = Enum('enum_arb_functions', {"VOLTAGE": 'VOLT',
                                                     "CURRENT": 'CURR',
                                                     "RESISTANCE": 'RES',
                                                     "POWER": 'POW', })

    enum_arb_shapes = Enum('enum_arb_shapes', {"STEP": 'STEP',
                                               "RAMP": 'RAMP',
                                               "STAIRCASE": 'STA',
                                               "SINUSOID": 'SIN',
                                               "PULSE": 'PULS',
                                               "TRAPEZOID": 'TRAP',
                                               "EXPONENTIAL": 'EXP',
                                               "USER_DEFINED": 'UDEF',
                                               "CONSTANT_DWELL": 'CDW',
                                               "SEQUENCE": 'SEQ',
                                               "NONE": 'NONE'})

    step_range = min_max_units(0, 100, 'Steps')
    time_range = min_max_units(0, 262, 'Seconds')


# noinspection PyProtectedMember
class Step(ArbWaveABC):
    """Class for configuration of a step shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'STEP'

    def configure(self, channel, function, start_level=None, start_time=None, end_level=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary step waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:STEP:END[:LEVel] < NRf+>, (@chanlist) Sets the end level of the step
        #  [SOURce:]ARB:CURRent | :VOLTage:STEP:STARt[:LEVel] < NRf+>, (@chanlistl) Sets the initial level of the step
        #  [SOURce:]ARB:CURRent | :VOLTage:STEP:STARt:TIMe < NRf+>, (@chanlist)
        #  Sets the length of the start time or delay

        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [start_level, start_time, end_level]):
            ret_val = {}
            ret_val.update(start_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR", float, channel_str))
            ret_val.update(start_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", float, channel_str))
            ret_val.update(end_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END", float, channel_str))
            return ret_val

        # check parameters
        check_range('start_level', start_level, wave_boundaries)
        check_range('start_time', start_time, self.time_range)
        check_range('end_level', end_level, wave_boundaries)

        # write and log errors
        if start_level is not None:
            target = f'{start_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR", target)
        if start_time is not None:
            target = f'{start_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", target)
        if end_level is not None:
            target = f'{end_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class Ramp(ArbWaveABC):
    """Class for configuration of a ramp shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'RAMP'

    def configure(self, channel, function, start_level=None, start_time=None, end_level=None, end_time=None,
                  rise_time=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary ramp waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds.
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :param rise_time: Specifies the rise time of the wave in Seconds. A value from 0 to 262
        :type rise_time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:RAMP:END[:LEVel] < NRf+>, (@chanlist) Sets the end level of the ramp
        #  [SOURce:]ARB:CURRent | :VOLTage:RAMP:END:TIMe < NRf+>, (@chanlist) Sets the length of the end time
        #  [SOURce:]ARB:CURRent | :VOLTage:RAMP::RTIMe < NRf+>, (@chanlist) Sets the rise time of the ramp
        #  [SOURce:]ARB:CURRent | :VOLTage:RAMP::STARt[:LEVel] < NRf+>, (@chanlist) Sets the initial level of the ramp
        #  [SOURce:]ARB:CURRent | :VOLTage:RAMP::STARt:TIMe < NRf+>, (@chanlist)
        #  Sets the length of the start time or delay

        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [start_level, start_time, end_level, end_time, rise_time]):
            ret_val = {}
            ret_val.update(start_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR", float, channel_str))
            ret_val.update(start_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", float, channel_str))
            ret_val.update(end_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END", float, channel_str))
            ret_val.update(end_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", float, channel_str))
            ret_val.update(rise_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:RTIM", float, channel_str))
            return ret_val

        # check parameters
        check_range('start_level', start_level, wave_boundaries)
        check_range('start_time', start_time, self.time_range)
        check_range('end_level', end_level, wave_boundaries)
        check_range('end_time', end_time, self.time_range)
        check_range('rise_time', rise_time, wave_boundaries)

        # write and log errors
        if start_level is not None:
            target = f'{start_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR", target)
        if start_time is not None:
            target = f'{start_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", target)
        if end_level is not None:
            target = f'{end_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END", target)
        if end_time is not None:
            target = f'{end_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", target)
        if rise_time is not None:
            target = f'{rise_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:RTIM", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class Staircase(ArbWaveABC):
    """Class for configuration of a staircase shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'STA'

    def configure(self, channel, function, start_level=None, start_time=None, end_level=None, end_time=None,
                  rise_time=None, steps=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary staircase waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :param rise_time: Specifies the rise time of the wave in Seconds. A value from 0 to 262
        :type rise_time: int | float
        :param steps: The number of steps in a staircase
        :type steps: int
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:STAircase:END[:LEVel] < NRf+>, (@chanlist)
        #  Sets the end level of the staircase
        #  [SOURce:]ARB:CURRent | :VOLTage:STAircase:END :TIMe < NRf+>, (@chanlist) Sets the length of the end time
        #  [SOURce:]ARB:CURRent |:VOLTage:STAircase:NSTeps < NRf+>, (@chanlist)
        #  Sets the number of steps in the staircase
        #  [SOURce:]ARB:CURRent | :VOLTage:STAircase:STARt[:LEVel] < NRf+>, (@chanlist)
        #  Sets the initial level of the staircase
        #  [SOURce:]ARB:CURRent | :VOLTage:STAircase:STARt:TIMe < NRf+>, (@chanlist)
        #  Sets the length of the start time or delay
        #  [SOURce:]ARB:CURRent | :VOLTage:STAircase:TIMe <NRf+>, (@chanlist)
        #  Sets the length of the staircase

        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [start_level, start_time, end_level, end_time, rise_time, steps]):
            ret_val = {}
            ret_val.update(start_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR", float, channel_str))
            ret_val.update(start_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", float, channel_str))
            ret_val.update(end_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END", float, channel_str))
            ret_val.update(end_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", float, channel_str))
            ret_val.update(rise_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:TIM", float, channel_str))
            ret_val.update(steps=self.query(f"ARB:{seq_str}{fc_str}:{wave}:NST", float, channel_str))

            return ret_val

        # check parameters
        check_range('start_level', start_level, wave_boundaries)
        check_range('start_time', start_time, self.time_range)
        check_range('end_level', end_level, wave_boundaries)
        check_range('end_time', end_time, self.time_range)
        check_range('rise_time', rise_time, wave_boundaries)
        check_range('steps', steps, self.step_range)

        # write and log errors
        if start_level is not None:
            target = f'{start_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR", target)
        if start_time is not None:
            target = f'{start_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", target)
        if end_level is not None:
            target = f'{end_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END", target)
        if end_time is not None:
            target = f'{end_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", target)
        if rise_time is not None:
            target = f'{rise_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:TIM", target)
        if steps is not None:
            target = f'{steps}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:NST", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class Sinusoid(ArbWaveABC):
    """Class for configuration of a sinusoidal shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'SIN'

    def configure(self, channel, function, amplitude=None, frequency=None, offset=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary sinusoid waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param amplitude: Specifies the amplitude of the sine wave. Within N6705C.chx.<function>_range.
        :type amplitude: int | float
        :param frequency: Specifies the frequency of the sine wave in Hertz. A value from 3.8147e-5 to 1.0e4 Hz.
        :type frequency: int | float
        :param offset: Specifies the offset of the sine wave from zero. Within N6705C.chx.<function>_range.
        :type offset: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:SINusoid
        #  :AMPLitude < NRf+>, (@chanlist) Sets the amplitude of the sine wave
        #  :FREQuency < NRf+>, (@chanlist) Sets the frequency of the sine wave
        #  :OFFSet < NRf+>, (@chanlist) Sets the DC offset of the sine wave
        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [amplitude, frequency, offset]):
            ret_val = {}
            ret_val.update(amplitude=self.query(f"ARB:{seq_str}{fc_str}:{wave}:AMPL", float, channel_str))
            ret_val.update(frequency=self.query(f"ARB:{seq_str}{fc_str}:{wave}:FREQ", float, channel_str))
            ret_val.update(offset=self.query(f"ARB:{seq_str}{fc_str}:{wave}:OFFS", float, channel_str))
            return ret_val

        # check parameters
        check_range('amplitude', amplitude, wave_boundaries)
        check_range('frequency', frequency, min_max_units(3.8147e-5, 1.0e4, 'Hz'))
        check_range('offset', offset, wave_boundaries)

        # write and log errors
        if amplitude is not None:
            target = f'{amplitude}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:AMPL", target)
        if frequency is not None:
            target = f'{frequency}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:FREQ", target)
        if offset is not None:
            target = f'{offset}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:OFFS", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class Pulse(ArbWaveABC):
    """Class for configuration of a pulse shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'PULS'

    def configure(self, channel, function, start_level=None, start_time=None, end_time=None,
                  top_level=None, top_time=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary pulse waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :param top_level: Specifies the top level of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type top_level: int | float
        :param top_time: Specifies the time of persistence of the top level. A value from 0 to 262 seconds.
        :type top_time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #   [SOURce:]ARB:CURRent | :VOLTage:PULSe
        #    :END:TIMe < NRf+>, (@chanlist) Sets the length of the end time
        #    :STARt[:LEVel] < NRf+>, (@chanlist) Sets the initial level of the pulse
        #    :STARt:TIMe < NRf+>, (@chanlist) Sets the length of the start time or delay
        #    :TOP[:LEVel] < NRf+>, (@chanlist) Sets the top level of the pulse
        #    :TOP:TIMe < NRf+>, (@chanlist) Sets the length of the pulse

        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [start_level, start_time, end_time, top_level, top_time]):
            ret_val = {}
            ret_val.update(start_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR", float, channel_str))
            ret_val.update(start_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", float, channel_str))
            ret_val.update(end_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", float, channel_str))
            ret_val.update(top_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:TOP", float, channel_str))
            ret_val.update(top_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:TOP:TIM", float, channel_str))
            return ret_val

        # check parameters
        check_range('start_level', start_level, wave_boundaries)
        check_range('start_time', start_time, self.time_range)
        check_range('end_time', end_time, self.time_range)
        check_range('top_level', top_level, wave_boundaries)
        check_range('top_time', top_time, self.time_range)

        # write and log errors
        if start_level is not None:
            target = f'{start_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR", target)
        if start_time is not None:
            target = f'{start_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", target)
        if end_time is not None:
            target = f'{end_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", target)
        if top_level is not None:
            target = f'{top_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:TOP", target)
        if top_time is not None:
            target = f'{top_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:TOP:TIM", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class Trapezoid(ArbWaveABC):
    """Class for configuration of a trapezoidal shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'TRAP'

    def configure(self, channel, function, start_level=None, start_time=None, top_level=None, top_time=None,
                  rise_time=None, fall_time=None, end_time=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary trapezoid waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param top_level: Specifies the top level of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type top_level: int | float
        :param top_time: Specifies the time of persistence of the top level. A value from 0 to 262 seconds.
        :type top_time: int | float
        :param rise_time: Specifies the rise time of the wave in Seconds. A value from 0 to 262 seconds.
        :type rise_time: int | float
        :param fall_time: Specifies the fall time of the wave in Seconds. A value from 0 to 262 seconds.
        :type fall_time: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:TRAPezoid
        #  :END:TIMe < NRf+>, (@chanlist) Sets the length of the end time
        #  :FTIMe < NRf+>, (@chanlist) Sets the length of the fall time
        #  :RTIMe < NRf+>, (@chanlist) Sets the length of the rise time
        #  :STARt[:LEVel] < NRf+>, (@chanlist) Sets the initial level of the trapezoid
        #  :STARt:TIMe < NRf+>, (@chanlist) Sets the length of the start time or delay
        #  :TOP[:LEVel] < NRf+>, (@chanlist) Sets the top level of the trapezoid
        #  :TOP:TIMe < NRf+>, (@chanlist) Sets the length of the top of the trapezoid

        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [start_level, start_time, top_level,
                                           top_time, rise_time, fall_time, end_time]):
            ret_val = {}
            ret_val.update(start_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR", float, channel_str))
            ret_val.update(start_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", float, channel_str))
            ret_val.update(top_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:TOP", float, channel_str))
            ret_val.update(top_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:TOP:TIM", float, channel_str))
            ret_val.update(rise_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:RTIM", float, channel_str))
            ret_val.update(fall_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:FTIM", float, channel_str))
            ret_val.update(end_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", float, channel_str))
            return ret_val

        # check parameters
        check_range('start_level', start_level, wave_boundaries)
        check_range('start_time', start_time, self.time_range)
        check_range('top_level', top_level, wave_boundaries)
        check_range('top_time', top_time, self.time_range)
        check_range('rise_time', rise_time, self.time_range)
        check_range('fall_time', fall_time, self.time_range)
        check_range('end_time', end_time, self.time_range)

        # write and log errors
        if start_level is not None:
            target = f'{start_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR", target)
        if start_time is not None:
            target = f'{start_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", target)
        if top_level is not None:
            target = f'{top_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:TOP", target)
        if top_time is not None:
            target = f'{top_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:TOP:TIM", target)
        if rise_time is not None:
            target = f'{rise_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:RTIM", target)
        if fall_time is not None:
            target = f'{fall_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:FTIM", target)
        if end_time is not None:
            target = f'{end_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END:TIM", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class Exponential(ArbWaveABC):
    """Class for configuration of an exponential shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'EXP'

    def configure(self, channel, function, start_level=None, start_time=None,  end_level=None,
                  overall_time=None, time_constant=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary exponential waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :param overall_time: Specifies the total time for the wave to go from the starting level to teh ending level.
            A value from 0 to 262 seconds
        :type overall_time: int | float
        :param time_constant: Specifies the time constant of the exponential curve.
        :type time_constant: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:EXPonential:END[:LEVel] < NRf+>, (@chanlist)
        #  Sets the end level of the exponential Arb
        #  [SOURce:]ARB:CURRent | :VOLTage:EXPonential:STARt[:LEVel] < NRf+>, (@chanlist)
        #  Sets the initial level of the exponential Arb
        #  [SOURce:]ARB:CURRent | :VOLTage:EXPonential:STARt:TIMe < NRf+>, (@chanlist)
        #  Sets the length of the start time or delay
        #  [SOURce:]ARB:CURRent | :VOLTage:EXPonential:TCONstant < NRf+>, (@chanlist)
        #  Sets the time constant of the exponential Arb
        #  [SOURce:]ARB:CURRent | :VOLTage:EXPonential:TIMe < NRf+>, (@chanlist)
        #  Sets the time of the exponential Arb
        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [start_level, start_time, end_level, overall_time, time_constant]):
            ret_val = {}
            ret_val.update(start_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR", float, channel_str))
            ret_val.update(start_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", float, channel_str))
            ret_val.update(end_level=self.query(f"ARB:{seq_str}{fc_str}:{wave}:END", float, channel_str))
            ret_val.update(overall_time=self.query(f"ARB:{seq_str}{fc_str}:{wave}:TIM", float, channel_str))
            ret_val.update(time_constant=self.query(f"ARB:{seq_str}{fc_str}:{wave}:TCON", float, channel_str))
            return ret_val

        # check parameters
        check_range('start_level', start_level, wave_boundaries)
        check_range('start_time', start_time, self.time_range)
        check_range('end_level', end_level, wave_boundaries)
        check_range('overall_time', overall_time, self.time_range)
        check_range('time_constant', time_constant, self.time_range)

        # write and log errors
        if start_level is not None:
            target = f'{start_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR", target)
        if start_time is not None:
            target = f'{start_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:STAR:TIM", target)
        if end_level is not None:
            target = f'{end_level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:END", target)
        if overall_time is not None:
            target = f'{overall_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:TIM", target)
        if time_constant is not None:
            target = f'{time_constant}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:TCON", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class UserDefined(ArbWaveABC):
    """Class for configuration of a user defined arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'UDEF'

    def configure(self, channel, function, begin_of_step=None, dwell=None, level=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary user-defined waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param begin_of_step: A list of on_off values that specifies which user-defined ARB points or steps will
            generate a trigger-out signal at the beginning of the step (BOSTep). A list of up to 511 steps may be
            programmed.
        :type begin_of_step: list[str|int|bool]
        :param dwell: A list of dwell times for each arb point. 511 points may be programmed, each value being within
            0 and 262 Seconds.
        :type dwell: list[int|float]
        :param level: A list of arb levels for each arb point. 511 points may be programmed, each value being within
            N6705C.ch<x>.<function>_range
        :type level: list[int|float]
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:UDEFined:BOSTep[:DATA] <Bool> {,<Bool>}, (@chanlist)
        #  Generate triggers at the Beginning Of STep
        #  [SOURce:]ARB:CURRent | :VOLTage:UDEFined:BOSTep:POINts? (@chanlist) Returns the number of BOST points
        #  [SOURce:]ARB:CURRent | :VOLTage:UDEFined:DWELl <NRf> {,<NRf>}, (@chanlist) Sets the user-defined dwell values
        #  [SOURce:]ARB:CURRent | :VOLTage:UDEFined:DWELl:POINts? (@chanlist) Returns the number of dwell points
        #  [SOURce:]ARB:CURRent | :VOLTage:UDEFined:LEVel <NRf> {,<NRf>}, (@chanlist) Sets the user-defined level values
        #  [SOURce:]ARB:CURRent | :VOLTage:UDEFined:LEVel:POINts? (@chanlist) Returns the number of points

        # check mandatory arguments
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type
        wb = wave_boundaries

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [begin_of_step, dwell, level]):
            ret_val = {}
            begin_of_step = self.query(f"ARB:{seq_str}{fc_str}:{wave}:BOST", str, channel_str)
            ret_val.update(begin_of_step=[self.on_off.to_inst(element) for element in begin_of_step.split(',')])
            dwell = self.query(f"ARB:{seq_str}{fc_str}:{wave}:DWEL", str, channel_str)
            ret_val.update(dwell=[float(element) for element in dwell.split(',')])
            level = self.query(f"ARB:{seq_str}{fc_str}:{wave}:LEV", str, channel_str)
            ret_val.update(level=[float(element) for element in level.split(',')])
            ret_val.update(
                begin_of_step_points=self.query(f"ARB:{seq_str}{fc_str}:{wave}:BOST:POIN", float, channel_str))
            ret_val.update(dwell_points=self.query(f"ARB:{seq_str}{fc_str}:{wave}:DWEL:POIN", float, channel_str))
            ret_val.update(level_points=self.query(f"ARB:{seq_str}{fc_str}:{wave}:LEV:POIN", float, channel_str))

            return ret_val

        # check parameters
        check_list_on_off('begin_of_step', begin_of_step, self.on_off.api_values())
        check_list_num('dwell', dwell, 0, 262, 'Seconds', self.on_off.api_values())
        check_list_num('level', level, wb.min, wb.max, wb.units, self.on_off.api_values())

        # write and log errors
        if begin_of_step is not None:
            begin_of_step = ','.join([str(self.on_off.to_inst(element)) for element in begin_of_step])
            target = f'{begin_of_step}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:BOST", target)
        if dwell is not None:
            dwell = ','.join([str(element) for element in dwell])
            target = f'{dwell}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:DWEL", target)
        if level is not None:
            level = ','.join([str(element) for element in level])
            target = f'{level}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:LEV", target)

        self.log_inst_errors()


# noinspection PyProtectedMember
class ConstantDwell(ArbWaveABC):
    """Class for configuration of a constant dwell shaped arbitrary waveform within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'CDW'

    def configure(self, channel, function, data_points=None, dwell_time=None, **kwargs):
        """
        Configure or query parameters creating the arbitrary constant dwell waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param data_points: This command specifies the level of each point of a constant-dwell ARB.
            Can be a list of values within N6705C.chx.<function>_range.
        :type data_points: int | float | list[float]
        :param dwell_time: This command specifies the dwell time for each point of a constant-dwell ARB. A value ranging
            from 10.24 microseconds to 0.30 seconds
        :type dwell_time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:CDWell
        #  [:LEVel] < NRf+> {,<NRf>}, (@chanlist) Sets the list of the constant dwell Arb
        #  :DWELl < NRf+>, (@chanlist) Sets the dwell time for the constant dwell Arb
        #  :POINts? (@<chanlist>) Returns the number of constant-dwell Arb points

        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        # augment values if method was called for use in a sequence.
        seq_str = ''
        step = kwargs.get('sequence_step_index')
        if step is not None:
            seq_str = 'SEQ:STEP:'
            channel_str = f'{step}, {channel_str}'

        # read back
        if all(param is None for param in [data_points, dwell_time]):
            ret_val = {}
            ret_val.update(level=self.query(f"ARB:{seq_str}{fc_str}:{wave}", float, channel_str))
            ret_val.update(data_points=self.query(f"ARB:{seq_str}{fc_str}:{wave}:DWEL", float, channel_str))
            ret_val.update(points=self.query(f"ARB:{seq_str}{fc_str}:{wave}:POIN", float, channel_str))
            return ret_val

        # check parameters
        if isinstance(data_points, list):
            check_list_num('data_points', data_points, wave_boundaries.min, wave_boundaries.max, wave_boundaries.units)
            data_points = ', '.join(str(element) for element in data_points)
        else:
            check_range('data_points', data_points, wave_boundaries)

        check_range('dwell_time', dwell_time, min_max_units(0.00001024, 0.30, 'Seconds'))

        # write and log errors
        if data_points is not None:
            target = f'{data_points}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}", target)
        if dwell_time is not None:
            target = f'{dwell_time}, {channel_str}'
            self.write(f"ARB:{seq_str}{fc_str}:{wave}:DWEL", target)

        self.log_inst_errors()

    def convert_to_user_def(self, channel, function):
        """
        Converts the constant dwell waveform into a user defined waveform.

        :return:
        :rtype:
        """
        # [SOURce:]ARB:CURRent | :VOLTage:CDWell:CONVert (@chanlist) Converts the selected Arb to a user-defined list
        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # returns the channels boundaries for the given functions
        wave_boundaries = channel_obj._model_boundaries.get(function_obj.value)
        if wave_boundaries is None:
            raise ValueError(f"Bad function {function_obj.name}, Model does not support this.")

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        self.write(f"ARB:{fc_str}:{wave}:CONV", channel_str)
        self.log_inst_errors()


class Sequence(ArbWaveABC):
    """Class for configuration of a sequence of arbitrary waveforms within the source.arb sub-system."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana)
        self.wave_type = 'SEQ'
        self._step = Step(self)
        self._ramp = Ramp(self)
        self._staircase = Staircase(self)
        self._sinusoid = Sinusoid(self)
        self._pulse = Pulse(self)
        self._trapezoid = Trapezoid(self)
        self._exponential = Exponential(self)
        self._user_defined = UserDefined(self)
        self._constant_dwell = ConstantDwell(self)

    enum_pacing = Enum('enum_pacing', {"DWELL": 'DWEL', "TRIGGER": 'TRIG'})

    def settings(self, channel, sequence_step_index, seq_count=None, step_count=None, shape=None, pacing=None,
                 terminate_en=None):
        """
        Command or query settings for the sequence of arbitrary waveforms.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param seq_count: Set the number of times that the entire sequence will be repeated. A value from 1 - 4096 or
            'INF' for infinite repeating.
        :type seq_count: int | str
        :param step_count: Set the number of times that a specific waveform within a sequence will be repeated.
            A value from 1 - 16777216 or 'INF' for infinite repeating.
        :type step_count: int | str
        :param shape: Creates a new ARB sequence_step_index and or changes an existing sequence_step_index to the
            waveform shape.
        :type shape: str | enum_arb_shapes
        :param pacing: Specifics the type of pacing for the specified step number. One of the following:

            * DWELL - Step moves to the next step when the dwell time is finished
            * TRIGGER - Step waits at the last value of the step until the trigger is recieved.
        :type pacing: str | enum_pacing
        :param terminate_en: on_off value ('ON'/'OFF' preferred) that determines how a sequence terminates. When on,
            the output of the last ARB becomes the immediate value. When off, the output returns to settings in effect
            before the sequence was started.
        :type terminate_en: str | int | bool
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:SEQuence:COUNt <NRf+> | INFinity, (@chanlist)
        #  Sets the number of times the sequence is repeated
        #  [SOURce:]ARB:SEQuence:LENgth? (@chanlist)
        #  Returns the number of steps in the sequence
        #  [SOURce:]ARB:SEQuence:QUALity? (@chanlist)
        #  Returns the quality of the waveforms in the sequence
        #  [SOURce:]ARB:SEQuence:STEP:COUNt <NRf+> | INFinity, <step#>, (@chanlist)
        #  Sets the number of times the sequence step is repeated
        #  [SOURce:]ARB:SEQuence:STEP:FUNCtion:SHAPe <function>, <step#>, (@chanlist)
        #  Creates a new sequence step
        #  [SOURce:]ARB:SEQuence:STEP:PACing DWELl | TRIGger, <step#>, (@chanlist)
        #  Specifies the type of pacing for the step
        #  [SOURce:]ARB:SEQuence:TERMinate :LAST <Bool>, (@chanlist)
        #  Sets the sequence termination mode

        channel_str, channel_obj = self._check_channel(channel)
        check_range('sequence_step_index', sequence_step_index, self.step_range)

        # read back
        if all(param is None for param in [seq_count, step_count, shape, pacing, terminate_en]):
            ret_val = {}
            # instrument does not send back INF but a large number, accept either INF or a number outside of range.
            temp_seq_count = self.query("ARB:SEQ:COUN", str, channel_str)
            count = "INF" if (temp_seq_count == 'INF' or float(temp_seq_count) > 4096) else float(temp_seq_count)
            ret_val.update(seq_count=count)

            # need sequence step index to identify what waveform we are returning.
            step_channel_str = f'{sequence_step_index}, {channel_str}'

            temp_step_count = self.query("ARB:SEQ:STEP:COUN", str, step_channel_str)
            count = "INF" if (temp_step_count == 'INF' or float(temp_step_count) > 16777216) else float(temp_step_count)
            ret_val.update(step_count=count)

            ret_val.update(shape=self.query("ARB:SEQ:STEP:FUNC:SHAP", self.enum_arb_shapes, step_channel_str).name)
            ret_val.update(pacing=self.query("ARB:SEQ:STEP:PAC", self.enum_pacing, step_channel_str).name)
            ret_val.update(terminate_en=self.on_off.to_api(self.query("ARB:SEQ:TERM:LAST", str, channel_str)))

            # extra query only
            ret_val.update(seq_length=self.query("ARB:SEQ:LENGTH?", float, channel_str))
            ret_val.update(quality=self.query("ARB:SEQ:QUAL", float, channel_str))
            return ret_val

        # check all parameters
        shape_obj = check_enum_str('shape', shape, self.enum_arb_shapes)
        pacing_obj = check_enum_str('pacing', pacing, self.enum_pacing)
        self.on_off.to_inst(terminate_en)

        if seq_count is not None:
            error_msg = "Bad {name} {value}, Should be a value between {min} and {max} or 'INF'."

            if isinstance(seq_count, (int, float)):
                check_range('count', seq_count, min_max_units(1, 4096, 'waves'), error_msg)
            elif not (isinstance(seq_count, str) and seq_count == 'INF'):  # User either enters INF or errors out.
                raise ValueError(f"Bad count {seq_count}, Should be a value between 1 and 16777216 or 'INF'.")

        if step_count is not None:
            error_msg = "Bad {name} {value}, Should be a value between {min} and {max} or 'INF'."

            if isinstance(step_count, (int, float)):
                check_range('count', step_count, min_max_units(1, 16777216, 'waves'), error_msg)
            elif not (isinstance(step_count, str) and step_count == 'INF'):  # User either enters INF or errors out.
                raise ValueError(f"Bad count {step_count}, Should be a value between 1 and 16777216 or 'INF'.")

        # need sequence step index to identify what waveform we are returning.
        step_channel_str = f'{sequence_step_index}, {channel_str}'

        # write and log errors
        if seq_count is not None:
            target = f'{seq_count}, {channel_str}'
            self.write(f"ARB:SEQ:COUN", target)
        if step_count is not None:
            target = f'{step_count}, {step_channel_str}'
            self.write(f"ARB:SEQ:STEP:COUN", target)
        if shape_obj is not None:
            target = f'{shape_obj.value}, {step_channel_str}'
            self.write(f"ARB:SEQ:STEP:FUNC:SHAP", target)
        if pacing_obj is not None:
            target = f'{pacing_obj.value}, {step_channel_str}'
            self.write(f"ARB:SEQ:STEP:PAC", target)
        if terminate_en is not None:
            target = f'{self.on_off.to_inst(terminate_en)}, {channel_str}'
            self.write(f"ARB:SEQ:TERM:LAST", target)

        self.log_inst_errors()
    
    def reset(self, channel, function):
        """
        Resets the sequence to the power on default settings.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  [SOURce:]ARB:CURRent | :VOLTage:SEQuence:RESet (@chanlist)
        #  Resets the sequence to its power-on default setting

        channel_str, channel_obj = self._check_channel(channel)
        function_obj = check_enum_str('function', function, self.enum_arb_functions)

        # smaller names for values frequently used in functions. Reduces clutter.
        fc_str = function_obj.value
        wave = self.wave_type

        self.write(f"ARB:{fc_str}:{wave}:RES", channel_str)
        self.log_inst_errors()

    def configure_step(self, channel, function, sequence_step_index, start_level=None, start_time=None, end_level=None):
        """
        Configure or query parameters creating the arbitrary step waveform for a sequence index.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._step.configure(channel, function, start_level, start_time, end_level,
                                    sequence_step_index=sequence_step_index)

    def configure_ramp(self, channel, function, sequence_step_index, start_level=None, start_time=None, end_level=None,
                       end_time=None, rise_time=None):
        """
        Configure or query parameters creating the arbitrary ramp waveform for a sequence index.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds.
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :param rise_time: Specifies the rise time of the wave in Seconds. A value from 0 to 262
        :type rise_time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._ramp.configure(channel, function, start_level, start_time, end_level, end_time, rise_time,
                                    sequence_step_index=sequence_step_index)

    def configure_staircase(self, channel, function, sequence_step_index, start_level=None, start_time=None,
                            end_level=None, end_time=None, rise_time=None, steps=None):
        """
        Configure or query parameters creating the arbitrary staircase waveform for a sequence index.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :param rise_time: Specifies the rise time of the wave in Seconds. A value from 0 to 262
        :type rise_time: int | float
        :param steps: The number of steps in a staircase
        :type steps: int
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._staircase.configure(channel, function, start_level, start_time, end_level, end_time, rise_time,
                                         steps, sequence_step_index=sequence_step_index)

    def configure_sinusoid(self, channel, function, sequence_step_index, amplitude=None, frequency=None, offset=None):
        """
        Configure or query parameters creating the arbitrary sinusoid waveform for a sequence index.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param amplitude: Specifies the amplitude of the sine wave. Within N6705C.chx.<function>_range.
        :type amplitude: int | float
        :param frequency: Specifies the frequency of the sine wave in Hertz. A value from 3.8147e-5 to 1.0e4 Hz.
        :type frequency: int | float
        :param offset: Specifies the offset of the sine wave from zero. Within N6705C.chx.<function>_range.
        :type offset: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._sinusoid.configure(channel, function, amplitude, frequency, offset,
                                        sequence_step_index=sequence_step_index)

    def configure_pulse(self, channel, function, sequence_step_index, start_level=None, start_time=None, end_time=None,
                        top_level=None, top_time=None):
        """
        Configure or query parameters creating the arbitrary pulse waveform for a sequence index.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :param top_level: Specifies the top level of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type top_level: int | float
        :param top_time: Specifies the time of persistence of the top level. A value from 0 to 262 seconds.
        :type top_time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._pulse.configure(channel, function, start_level, start_time, end_time, top_level,
                                     top_time, sequence_step_index=sequence_step_index)

    def configure_trapezoid(self, channel, function, sequence_step_index, start_level=None, start_time=None,
                            top_level=None, top_time=None, rise_time=None, fall_time=None, end_time=None):
        """
        Configure or query parameters creating the arbitrary trapezoid waveform for a sequence index.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param top_level: Specifies the top level of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type top_level: int | float
        :param top_time: Specifies the time of persistence of the top level. A value from 0 to 262 seconds.
        :type top_time: int | float
        :param rise_time: Specifies the rise time of the wave in Seconds. A value from 0 to 262 seconds.
        :type rise_time: int | float
        :param fall_time: Specifies the fall time of the wave in Seconds. A value from 0 to 262 seconds.
        :type fall_time: int | float
        :param end_time: The time in seconds that the waveform persists after completion A value from 0 to 262 seconds.
        :type end_time: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._trapezoid.configure(channel, function, start_level, start_time, top_level, top_time, rise_time,
                                         fall_time, end_time, sequence_step_index=sequence_step_index)

    def configure_exponential(self, channel, function, sequence_step_index, start_level=None, start_time=None,
                              end_level=None, overall_time=None, time_constant=None):
        """
        Configure or query parameters creating the arbitrary exponential waveform for a sequence index.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param start_level: Specify the beginning of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type start_level: int | float
        :param start_time: The delay in seconds after the trigger is received before the step occurs. A value from
            0 to 262 seconds
        :type start_time: int | float
        :param end_level: Specify the end of the waveform. The range of values depend on
            N6705C.chx.<function>_range.
        :type end_level: int | float
        :param overall_time: Specifies the total time for the wave to go from the starting level to teh ending level.
            A value from 0 to 262 seconds
        :type overall_time: int | float
        :param time_constant: Specifies the time constant of the exponential curve.
        :type time_constant: int | float
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._exponential.configure(channel, function, start_level, start_time, end_level, overall_time,
                                           time_constant, sequence_step_index=sequence_step_index)

    def configure_user_def(self, channel, function, sequence_step_index, begin_of_step=None, dwell=None, level=None):
        """
        Configure or query parameters creating the arbitrary user-defined waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param begin_of_step: A list of on_off values that specifies which user-defined ARB points or steps will
            generate a trigger-out signal at the beginning of the step (BOSTep). A list of up to 511 steps may be
            programmed.
        :type begin_of_step: list[str|int|bool]
        :param dwell: A list of dwell times for each arb point. 511 points may be programmed, each value being within
            0 and 262 Seconds.
        :type dwell: list[int|float]
        :param level: A list of arb levels for each arb point. 511 points may be programmed, each value being within
            N6705C.ch<x>.<function>_range
        :type level: list[int|float]
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._user_defined.configure(channel, function, begin_of_step, dwell, level,
                                            sequence_step_index=sequence_step_index)

    def configure_constant_dwell(self, channel, function, sequence_step_index, data_points=None, dwell_time=None):
        """
        Configure or query parameters creating the arbitrary constant dwell waveform.

        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param function: Function specifying the mode of possible arbitrary waveforms. One of the following:

            * VOLTAGE - Select voltage as the arbitrary waveform.
            * CURRENT - Select current as the arbitrary waveform.
            * RESISTANCE - Select resistance as the arbitrary waveform. Only works on specific models.
            * POWER - Select power as the arbitrary waveform. Only works on specific models.
        :type function: str | enum_arb_functions
        :param sequence_step_index: Index of the arbitrary waveform in the sequence. A value from 1 to 100.
        :type sequence_step_index: int
        :param data_points: This command specifies the level of each point of a constant-dwell ARB.
            Can be a list of values within N6705C.chx.<function>_range.
        :type data_points: int | float | list[float]
        :param dwell_time: This command specifies the dwell time for each point of a constant-dwell ARB. A value ranging
            from 10.24 microseconds to 0.30 seconds
        :type dwell_time:
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        check_range('sequence_step_index', sequence_step_index, self.step_range)
        return self._constant_dwell.configure(channel, function, data_points, dwell_time,
                                              sequence_step_index=sequence_step_index)

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
