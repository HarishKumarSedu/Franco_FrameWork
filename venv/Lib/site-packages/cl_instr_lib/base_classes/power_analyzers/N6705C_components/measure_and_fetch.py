# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include python libraries
from enum import Enum
from abc import ABC
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units

# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


# noinspection PyProtectedMember
class MeasureFetchABC(ABC):
    """Class for controlling the Measure and Fetch sub-system on the Keysight N6705C Modular DC Power Analyzer."""

    def __init__(self, pow_ana, meas_or_fetch):
        self.write = pow_ana.write
        self.query = pow_ana.query
        self.read_raw = pow_ana.read_raw
        self.log = pow_ana.log
        self._check_channel = pow_ana._check_channel
        self._check_multi_channels = pow_ana._check_multi_channels
        self._check_module = pow_ana._check_module
        self._models_tuple = pow_ana._models_tuple
        self._channel_dict = pow_ana._channel_dict
        self._return_split = pow_ana._return_split
        self._raise_error_check_all_channels = pow_ana._raise_error_check_all_channels
        self.log_inst_errors = pow_ana.log_inst_errors
        self.get_inst_errors = pow_ana.get_inst_errors
        self.on_off = pow_ana.on_off
        self._meas_or_fetch = meas_or_fetch
        self._formatting = pow_ana._formatting

    # class attributes
    # -------------------
    enum_func_current = Enum("enum_func_current", {"DC": "", "RMS": ":ACDC", "HIGH": ":HIGH", "LOW": ":LOW",
                                                   "MAX": ":MAX", "MIN": ":MIN"})
    enum_func_voltage = enum_func_current
    enum_func_arr = Enum("enum_func_arr", {"CURRENT": ":CURR", "VOLTAGE": ":VOLT", "POWER": ":POW"})

    def current(self, channel, function):
        """
        Query Command that returns a current measurement in Amperes.

        Method used for fetching or measuring depending on the class from which it is called.
        In the Measure class, the instrument initiates a measurement and returns data.
        In the Fetch class, the instrument returns data from last trigger acquisition or measurement.

        :param function: function specifying the measurement. One of the following:

            * DC - Normal measurement.
            * RMS - RMS measurement.
            * HIGH -  High level measurement of a  pulse waveform. The High level calculation generates a
              histogram of the waveform using 16 bins between the maximum and minimum data points. The bin
              containing the most data points above the 50% point is the high bin. The average of all the data
              points in the high bin is returned as the High level.
            * LOW -  Low level measurement of a pulse waveform.The Low level calculation generates a
              histogram of the waveform using 16  bins between the maximum and minimum data points. The bin
              containing the most data points below the 50% point is the low bin. The average of all the data
              points in the low bin is returned as the Low level.
            * MAX - Maximum measurement in time period.
            * MIN - Minimum measurement in time period.
        :type function: str | enum_func_current
        :param channel: Channel to which the measurement is taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * [int(1-4)] - list of integer values representing multiple channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | list | channel_obj
        :return: If called in Measure class, a float value or list of floats is returned. If called in the Fetch class,
            A float, list of floats, or byte data can be returned depending on fetch.format()
        :rtype: float | list[float] | bytes
        """
        # MEASure[:SCALar]:CURRent
        # FETCh [:SCALar]:CURRent
        #  [:DC]? (@chanlist) Takes a measurement; returns the average current
        #  :ACDC? (@chanlist) Takes a measurement; returns the total rms current (AC + DC)
        #  :HIGH? (@chanlist) Takes a measurement; returns the high level of a current pulse
        #  :LOW? (@chanlist) Takes a measurement; returns the low level of a current pulse
        #  :MAXimum? (@chanlist) Takes a measurement, returns the maximum current
        #  :MINimum? (@chanlist) Takes a measurement, returns the minimum current

        # check all parameters
        channel_str, channel_objs = self._check_multi_channels(channel)
        function_obj = check_enum_str('function', function, self.enum_func_current)

        # assemble the SCPI command header
        method_arg = "CURR"
        cmd_header = self._meas_or_fetch + method_arg + function_obj.value

        # query data from the instrument
        if self._meas_or_fetch == "FETC:":
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)
        else:
            # Measure will bring back ASCII data
            ret_data = self.query(cmd_header,  pre_target_params=channel_str)

        # if bytes are returned, return the raw data.
        if isinstance(ret_data, bytes):
            return ret_data

        # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
        return self._return_split(ret_data, float)

    def power(self, channel):
        """
        Query Command that returns a power measurement in Watts.

        Method used for fetching or measuring depending on the class from which it is called.
        In the Measure class, the instrument initiates a measurement and returns data.
        In the Fetch class, the instrument returns data from last trigger acquisition or measurement.

        :param channel: Channel to which the measurement is taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * [int(1-4)] - list of integer values representing multiple channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | list | channel_obj
        :return: If called in Measure class, a float value or list of floats is returned. If called in the Fetch class,
            A float, list of floats, or byte data can be returned depending on fetch.format()
        :rtype: float | list[float] | bytes
        """
        #  MEASure[:SCALar]:POWer [:DC]? (@chanlist) Takes a measurement; returns the average output power
        #  FETCh[:SCALar]:POWer [:DC]? (@chanlist) Takes a measurement; returns the average output power

        # check all parameters
        channel_str, channel_objs = self._check_multi_channels(channel)

        # assemble the SCPI command header
        method_arg = "POW"
        cmd_header = self._meas_or_fetch + method_arg

        # query data from the instrument
        if self._meas_or_fetch == "FETC:":
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)
        else:
            # Measure will bring back ASCII data
            ret_data = self.query(cmd_header,  pre_target_params=channel_str)

        # if bytes are returned, return the raw data.
        if isinstance(ret_data, bytes):
            return ret_data

        # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
        return self._return_split(ret_data, float)

    def voltage(self, channel, function):
        """
        Query Command that returns a voltage measurement in Volts.

        Method used for fetching or measuring depending on the class from which it is called.
        In the Measure class, the instrument initiates a measurement and returns data.
        In the Fetch class, the instrument returns data from last trigger acquisition or measurement.

        :param function: function specifying the measurement. One of the following:

            * DC - Normal measurement.
            * RMS - RMS measurement.
            * HIGH -  High level measurement of a  pulse waveform. The High level calculation generates a
              histogram of the waveform using 16 bins between the maximum and minimum data points. The bin
              containing the most data points above the 50% point is the high bin. The average of all the data
              points in the high bin is returned as the High level.
            * LOW -  Low level measurement of a pulse waveform.The Low level calculation generates a
              histogram of the waveform using 16  bins between the maximum and minimum data points. The bin
              containing the most data points below the 50% point is the low bin. The average of all the data
              points in the low bin is returned as the Low level.
            * MAX - Maximum measurement in time period.
            * MIN - Minimum measurement in time period.
        :type function: str | enum_func_voltage
        :param channel: Channel to which the measurement is taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * [int(1-4)] - list of integer values representing multiple channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | list | channel_obj
        :return: If called in Measure class, a float value or list of floats is returned. If called in the Fetch class,
            A float, list of floats, or byte data can be returned depending on fetch.format()
        :rtype: float | list[float] | bytes
        """
        # MEASure[:SCALar]:VOLTage
        # FETCh [:SCALar]:VOLTage
        #  [:DC]? (@chanlist) Takes a measurement; returns the average voltage
        #  :ACDC? (@chanlist) Takes a measurement; returns the total rms voltage (AC + DC)
        #  :HIGH? (@chanlist) Takes a measurement; returns the high level of a voltage pulse
        #  :LOW? (@chanlist) Takes a measurement; returns the low level of a voltage pulse
        #  :MAXimum? (@chanlist) Takes a measurement, returns the maximum voltage
        #  :MINimum? (@chanlist) Takes a measurement, returns the minimum voltage

        # check all parameters
        channel_str, channel_objs = self._check_multi_channels(channel)
        function_obj = check_enum_str('function', function, self.enum_func_voltage)

        # assemble the SCPI command header
        method_arg = "VOLT"
        cmd_header = self._meas_or_fetch + method_arg + function_obj.value

        # query data from the instrument
        if self._meas_or_fetch == "FETC:":
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)
        else:
            # Measure will bring back ASCII data
            ret_data = self.query(cmd_header,  pre_target_params=channel_str)

        # if bytes are returned, return the raw data.
        if isinstance(ret_data, bytes):
            return ret_data

        # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
        return self._return_split(ret_data, float)

    def array(self, channel, function):
        """
        Query Command that returns an array of measurements.

        Change the sampling rate, trigger level, and number of data points returned using N6705C.sense.sweep()

        **Note:** Method only available for following module models: ( N676xA, N678xA SMU and Option 054)

        Method used for fetching or measuring depending on the class from which it is called.
        In the Measure class, the instrument initiates a measurement and returns data.
        In the Fetch class, the instrument returns data from last trigger acquisition or measurement.

        :param function: function specifying the measurement. One of the following:

            * CURRENT - Normal Current measurement.
            * VOLTAGE - Normal Voltage measurement.
            * POWER -  Normal Power measurement.

        :type function: str | enum_func_current
        :param channel: Channel to which the measurement is taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * [int(1-4)] - list of integer values representing multiple channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | list | channel_obj
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: str | None
        """
        # MEASure[:SCALar]:
        # FETCh [:SCALar]:
        #  :ARRay (Array commands only on N676xA, N678xA SMU and Option 054)
        #  :CURRent [:DC]? (@chanlist) Takes a measurement; returns the instantaneous output current
        #  :POWer [:DC]? (@chanlist) Takes a measurement, returns the instantaneous output power
        #  :VOLTage [:DC]? (@chanlist) Takes a measurement; returns the instantaneous output voltage

        # check all parameters
        channel_str, channel_objs = self._check_multi_channels(channel)
        function_obj = check_enum_str('function', function, self.enum_func_arr)

        required_models = (r'N676\dA', r'N678\dA')
        # Cause invalid channels to trigger the error message creation below.
        for module in channel_objs:
            if self._check_module(module.model, required_models) is None:  # not a valid model
                if self._check_module(module.options, '054') is None:      # not a valid option
                    self._raise_error_check_all_channels(required_models, '054')

        # assemble the SCPI command header
        method_arg = "ARR"
        cmd_header = self._meas_or_fetch + method_arg + function_obj.value

        # query data from the instrument
        if self._meas_or_fetch == "FETC:":
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)
        else:
            # Measure will bring back ASCII data
            ret_data = self.query(cmd_header,  pre_target_params=channel_str)

        # if bytes are returned, return the raw data.
        if isinstance(ret_data, bytes):
            return ret_data

        # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
        return self._return_split(ret_data, float)

    def _query_helper(self, query_msg, rtn_type=None, pre_target_params=None, target=None):
        """Helper to avoid format errors of the query data coming back. """

        if self._formatting == 'ASCII':
            return self.query(query_msg, rtn_type, pre_target_params, target)

        else:  # REAL MODE

            # handle the parsing of the query statement exactly like query does in instrument class
            query_msg = query_msg.rstrip("?") + '?'
            if pre_target_params is not None:
                query_msg += ' ' + pre_target_params
            if target is not None:
                if query_msg[-1] != '?':
                    query_msg += ','
                query_msg += ' ' + target

            # write the query instead so we may read_raw ex post facto
            self.write(query_msg)
            raw_data = self.read_raw()
            return raw_data[:len(raw_data) - 1]  # strip the newline on the return.


#                       MEASURE CLASS
# -----------------------------------------------------------
class Measure(MeasureFetchABC):
    """Class for controlling the Measure sub-system on the Keysight N6705C Modular DC Power Analyzer."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana, meas_or_fetch="MEAS:")


#                        FETCH CLASS
# -----------------------------------------------------------
class Fetch(MeasureFetchABC):
    """Class for controlling the Fetch sub-system on the Keysight N6705C Modular DC Power Analyzer."""

    def __init__(self, pow_ana):
        super().__init__(pow_ana, meas_or_fetch="FETC:")

        #: Object containing the `Fetch.Datalog`_  methods.
        self.datalog = self.Datalog(self)

    enum_data_format = Enum("enum_data_format", {'ASCII': "ASC", 'REAL': "REAL"})
    enum_byte_order = Enum("enum_byte_order", {'NORMAL': "NORM", 'SWAPPED': "SWAP"})

    def format(self, data_format=None, byte_order=None):
        """
        Specify the formatting of data and byte_order when fetching from the instrument.

        :param data_format: Sets the format in which the result is sent when fetching data.

            * ASCII - Numeric data is transferred as ASCII bytes, values are comma separated.
            * REAL - Data is returned in binary IEEE single precision floating point.
        :type data_format: str | enum_text_format
        :param byte_order: Sets the order in which response data bytes formatted as REAL when fetching data.

            * NORMAL - Response data is sent with the MSB first and the LSB last (big-endian order)
            * SWAPPED -  Response data is sent with the LSB first and the MSB last (little-endian order)
        :type byte_order: str | enum_border
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: dict | None
        """
        #  FORMat[:DATA] ASCII | REAL Returns data as ASCII or binary
        #  FORMat:BORDer NORMal | SWAPped Sets the byte order of the external data log data
        if all(param is None for param in [data_format, byte_order]):
            return_value = {}
            self._formatting = self.query("FORM", self.enum_data_format).name
            return_value.update(data_format=self._formatting)
            return_value.update(byte_order=self.query("FORM:BORD", self.enum_byte_order).name)
            self.log_inst_errors()
            return return_value

        # check all parameters.
        data_format_obj = check_enum_str("data_format", data_format, self.enum_data_format)
        byte_order_obj = check_enum_str("byte_order", byte_order, self.enum_byte_order)

        # write to machine
        if data_format is not None:
            self.write(f'FORM', data_format_obj.value)
            self._formatting = data_format_obj.name
        if byte_order is not None:
            self.write(f'FORM:BORD', byte_order_obj.value)

        # log errors
        self.log_inst_errors()

    def histogram(self, channel):
        """
        Query command that fetches the histogram current bin data. There are two bin ranges,
        with 4096 bins in each of the ranges.

        **Note:** Method only available for following module models: (N6781A, N6782A, N6785A, N6786A that have the Data
        Logger function installed.)

        bins
        8 | 0.0078 (for N6781A/N6782A)
        16 | 0.0156 (for N6785A/N6786A)

        :param channel: Channel to which the measurement is taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * [int(1-4)] - list of integer values representing multiple channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | list | channel_obj
        :return: A float, list of floats, or byte data can be returned depending on fetch.format()
        :rtype: float | list[float] | bytes
        """
        #  FETCh [:SCALar]:HISTogram:CURRent? <binrange>,
        # ['N6781A', 'N6782A', 'N6785A', 'N6786A']
        # check all parameters
        required_models = ['N6781A', 'N6782A', 'N6785A', 'N6786A']
        channel_str, channel_objs = self._check_multi_channels(channel)

        # Cause invalid channels to trigger the error message creation below.
        for module in channel_objs:
            if self._check_module(module.model, required_models) is None:  # not a valid model
                self._raise_error_check_all_channels(required_models)

        # have the use of models restricted based on bins
        bin_choice = []
        for module in channel_objs:
            if module.model in ['N6781A', 'N6782A']:
                bin_choice.append(8)
            else:
                bin_choice.append(16)

        if bin_choice.count(8) > 0 and bin_choice.count(16) > 0:
            raise ValueError("Bad choice of multiple channels for bin selection. Bin selection requires models "
                             "N6781A/N6782A for 8 bins and N6781A/N6786A for 16 bins.\n "
                             "Cannot use 8 and 16 bin models at the same time.")

        # assemble the SCPI command header
        method_arg = "HIST:CURR"
        cmd_header = self._meas_or_fetch + method_arg
        pre_target = f'{bin_choice[0]}, ' + channel_str  # bin choice should be the same for all of list, choose first.

        # query data from the instrument
        # fetch can bring back byte data, check saved state _formatting.
        ret_data = self._query_helper(cmd_header, pre_target_params=pre_target)

        # if bytes are returned, return the raw data.
        if isinstance(ret_data, bytes):
            return ret_data

        # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
        return self._return_split(ret_data, float)

    # noinspection PyProtectedMember
    class Datalog:
        def __init__(self, fetch):
            self.write = fetch.write
            self.query = fetch.query
            self.read_raw = fetch.read_raw
            self.log = fetch.log
            self._check_channel = fetch._check_channel
            self._check_multi_channels = fetch._check_multi_channels
            self._query_helper = fetch._query_helper
            self._return_split = fetch._return_split
            self.log_inst_errors = fetch.log_inst_errors
            self.get_inst_errors = fetch.get_inst_errors
            self.on_off = fetch.on_off
            self._meas_or_fetch = "FETC:"

        enum_func_datalog = Enum("enum_func_datalog_curr", {"DC": "", "PEAK2PEAK": ":PTP",
                                                            "MAX": ":MAX", "MIN": ":MIN", })

        def amp_hours(self, channel):
            """
            Query command that returns amp-hours delineated by the front panel markers  on the selected data log
            trace that appears in the instrument's Data Logger view.

            :param channel: Channel to which the measurement is taking place. One of the following:

                * 1-4 - integer value representing a single channel of the four possible channels.
                * [int(1-4)] - list of integer values representing multiple channels.
                * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
            :type channel: int | list | channel_obj
            :return: A float, list of floats, or byte data can be returned depending on fetch.format()
            :rtype: float | list[float] | bytes
            """
            # FETCh [:SCALar]:DLOG:AHOur? (@chanlist) Returns the amp-hours between markers

            # check all parameters
            channel_str, channel_objs = self._check_multi_channels(channel)

            # assemble the SCPI command header
            method_arg = "DLOG:AHO"
            cmd_header = self._meas_or_fetch + method_arg

            # query data from the instrument
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)

            # if bytes are returned, return the raw data.
            if isinstance(ret_data, bytes):
                return ret_data

            # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
            return self._return_split(ret_data, float)

        def watt_hours(self, channel):
            """
            Query command that returns the watt-hours delineated by the front panel markers on the selected data log
            trace that appears in the instrument's Data Logger view.

            :param channel: Channel to which the measurement is taking place. One of the following:

                * 1-4 - integer value representing a single channel of the four possible channels.
                * [int(1-4)] - list of integer values representing multiple channels.
                * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
            :type channel: int | list | channel_obj
            :return: A float, list of floats, or byte data can be returned depending on fetch.format()
            :rtype: float | list[float] | bytes
            """
            # FETCh:DLOG:WHOur?
            # check all parameters
            channel_str, channel_objs = self._check_multi_channels(channel)

            # assemble the SCPI command header
            method_arg = "DLOG:WHO"
            cmd_header = self._meas_or_fetch + method_arg

            # query data from the instrument
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)

            # if bytes are returned, return the raw data.
            if isinstance(ret_data, bytes):
                return ret_data

            # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
            return self._return_split(ret_data, float)

        def external(self, channel, max_records):
            """
            Query command that returns external datalog data from the instrumentâ€™s buffer.

            The instrument has a buffer for each channel that holds 10 seconds of accumulated data.
            Data accumulates in the buffer at the rate determined by sense.external_dlog.setup_period(period).
            Data must be read from the buffer periodically to avoid the buffer overflowing.

            :param max_records: The maximum number of records of external datalog data that the controller will
                return for each channel. A record is one set of voltage and current readings for one time interval.
            :type max_records: int
            :param channel: Channel to which the measurement is taking place. One of the following:

                * 1-4 - integer value representing a single channel of the four possible channels.
                * [int(1-4)] - list of integer values representing multiple channels.
                * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
            :type channel: int | list | channel_obj
            :return: A float, list of floats, or byte data can be returned depending on fetch.format()
            :rtype: float | list[float] | bytes
            """
            #  FETCh [:SCALar]:ELOG <NR1>, (@chanlist) Returns the most recent external data log records
            # check all parameters
            channel_str, channel_objs = self._check_multi_channels(channel)
            check_range('max_records', max_records, min_max_units(1, 16384, 'Records'))
            if max_records is None:
                # throw a value error for
                raise ValueError(f'Bad max_records {max_records}. Should be int between 1 and 16384.')

            # assemble the SCPI command header
            method_arg = "ELOG"
            cmd_header = self._meas_or_fetch + method_arg
            pre_target = str(max_records) + ", " + channel_str

            # query data from the instrument
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=pre_target)

            # if bytes are returned, return the raw data.
            if isinstance(ret_data, bytes):
                return ret_data

            # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
            return self._return_split(ret_data, float)

        def current(self, channel, function):
            """
            Query command that returns the current that is delineated by the front panel markers
            on the selected data log trace that appears in the instrument's Data Logger view.

            :param function: function specifying the measurement. One of the following:

                * DC - Normal measurement.
                * PEAK2PEAK - Peak to Peak measurement.
                * MAX - Maximum measurement in time period.
                * MIN - Minimum measurement in time period.
            :type function: str | enum_func_datalog
            :param channel: Channel to which the measurement is taking place. One of the following:

                * 1-4 - integer value representing a single channel of the four possible channels.
                * [int(1-4)] - list of integer values representing multiple channels.
                * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
            :type channel: int | list | channel_obj
            :return: A float, list of floats, or byte data can be returned depending on fetch.format()
            :rtype: float | list[float] | bytes
            """
            #  FETCh[:SCALar]:DLOG:CURRent
            #  [:DC]? (@chanlist) Returns the average current between markers
            #  :MAXimum? (@chanlist) Returns the maximum current between markers
            #  :MINimum? (@chanlist) Returns the minimum current between markers
            #  :PTPeak? (@chanlist) Returns the peak-to-peak current between markers

            # check all parameters
            channel_str, channel_objs = self._check_multi_channels(channel)
            function_obj = check_enum_str('function', function, self.enum_func_datalog)

            # assemble the SCPI command header
            method_arg = "DLOG:CURR"
            cmd_header = self._meas_or_fetch + method_arg + function_obj.value

            # query data from the instrument
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)

            # if bytes are returned, return the raw data.
            if isinstance(ret_data, bytes):
                return ret_data

            # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
            return self._return_split(ret_data, float)

        def voltage(self, channel, function):
            """
            Query command that returns the voltage that is delineated by the front panel markers
            on the selected data log trace that appears in the instrument's Data Logger view.

            :param function: function specifying the measurement. One of the following:

                * DC - Normal measurement.
                * PEAK2PEAK - Peak to Peak measurement.
                * MAX - Maximum measurement in time period.
                * MIN - Minimum measurement in time period.
            :type function: str | enum_func_datalog
            :param channel: Channel to which the measurement is taking place. One of the following:

                * 1-4 - integer value representing a single channel of the four possible channels.
                * [int(1-4)] - list of integer values representing multiple channels.
                * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
            :type channel: int | list | channel_obj
            :return: A float, list of floats, or byte data can be returned depending on fetch.format()
            :rtype: float | list[float] | bytes
            """
            #  FETCh [:SCALar]:DLOG:VOLTage
            #  [:DC]? (@chanlist) Returns the average voltage between markers
            #  :MAXimum? (@chanlist) Returns the maximum voltage between markers
            #  :MINimum? (@chanlist) Returns the minimum voltage between markers
            #  :PTPeak? (@chanlist) Returns the peak-to-peak voltage between markers
            #  :WHOur? (@chanlist) Returns the watt-hours between markers

            # check all parameters
            channel_str, channel_objs = self._check_multi_channels(channel)
            function_obj = check_enum_str('function', function, self.enum_func_datalog)

            # assemble the SCPI command header
            method_arg = "DLOG:VOLT"
            cmd_header = self._meas_or_fetch + method_arg + function_obj.value

            # query data from the instrument
            # fetch can bring back byte data, check saved state _formatting.
            ret_data = self._query_helper(cmd_header, pre_target_params=channel_str)

            # if bytes are returned, return the raw data.
            if isinstance(ret_data, bytes):
                return ret_data

            # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
            return self._return_split(ret_data, float)

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
