# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include python libraries
from enum import Enum
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.file_io import check_filename
from cl_instr_lib.helpers.user_delay import wait_visualizer
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


# noinspection PyProtectedMember
class System:
    """Class for controlling the System sub-system on the Keysight N6705C Modular DC Power Analyzer."""

    def __init__(self, pow_ana):
        self.write = pow_ana.write
        self.query = pow_ana.query
        self.read_raw = pow_ana.read_raw
        self.log = pow_ana.log
        self._check_channel = pow_ana._check_channel
        self.log_inst_errors = pow_ana.log_inst_errors
        self.get_inst_errors = pow_ana.get_inst_errors
        self.on_off = pow_ana.on_off
        self.get_idn = pow_ana.get_idn
        self.get_model = pow_ana.get_model

    # Class attributes
    enum_location = Enum("enum_location", {"INTERNAL": "internal:", "EXTERNAL": "external:"})

    # FURTHER IMPLEMENTATION

    # system subsystem
    # --------------------------
    # SYSTem
    #  :COMMunicate
    #  :RLSTate LOCal | REMote | RWLock Specifies the Remote/Local state of the instrument
    #  :TCPip
    #  :PASSword
    #  :FPANel:RESet Resets the front panel lock password to zero

    # status subsystem
    # --------------------------
    # STATus
    #  :OPERation
    #  [:EVENt]? (@chanlist) Returns the value of the operation event register
    #  :CONDition? (@chanlist) Returns the value of the operation condition register
    #  :ENABle <NRf>, (@chanlist) Enables specific bits in the Event register
    #  :NTRansition <NRf>, (@chanlist) Sets the Negative transition filter
    #  :PTRansition <NRf>, (@chanlist) Sets the Positive transition filter
    #  :PRESet Presets all enable and transition registers to power-on
    #  :QUEStionable
    #  [:EVENt]? (@chanlist) Returns the value of the questionable event register
    #  :CONDition? (@chanlist) Returns the value of the questionable condition register
    #  :ENABle <NRf>, (@chanlist) Enables specific bits in the Event register
    #  :NTRansition <NRf>, (@chanlist) Sets the Negative transition filter
    #  :PTRansition <NRf>, (@chanlist) Sets the Positive transition filter

    # TODO see if channel groups would be needed. This may require a channel class refactor
    # def group_catalog(self):
    #     #  :GROup (Group commands do NOT apply to N678xA SMU)
    #     #   :CATalog? Returns the groups that have been defined
    #     #   :DEFine (@chanlist) Group multiple channels to create a single output
    #     #   :DELete <channel> Removes the specified channel from a group
    #     #    :ALL Ungroups all channels
    #     pass

    # TODO: for this to work I think the driver must be restarted or at least the resource
    # def recall_default_state(self):
    #     """Returns the unit to its power-on state"""
    #     #  SYST:REBoot Returns the unit to its power-on state
    #     self.write("SYST:REB")
    #     wait_visualizer(20)
    #     self.log_inst_errors()

    def instr_information(self):
        """
        :return: returns the time, date, system version, and TCP port.
        :rtype: dict | None
        """
        #  SYSTem:TIME Sets the time of the system clock
        #  SYSTem:DATE Sets the date of the system clock
        #  SYSTem:VERSion? Returns the SCPI version number
        #  SYSTem:COMMunicate:TCPip:CONTrol? Returns the control connection port number
        return_value = {}

        time = self.query("SYST:TIME")
        time = time.strip('+').split(',+')
        time_str = f"{time[0]}:{time[1]}:{time[2]}"
        date = self.query("SYST:DATE")
        date = date.strip('+').split(',+')
        date_str = f"{date[1]}/{date[2]}/{date[0]}"

        return_value.update(idn=self.get_idn())
        return_value.update(time=time_str)
        return_value.update(date=date_str)
        tcp_port = self.query("SYST:COMM:TCP:CONT", float)
        if tcp_port == 0:
            tcp_port = 'Disconnected'
        return_value.update(tcp_port=tcp_port)

        self.log_inst_errors()
        return return_value

    def load_sequence(self, location, file_name, channel, directory=None):
        r"""
        This command loads an ARB sequence from a file. The filename should be
        the full path and filename. All ARB sequence data is saved in a proprietary
        format (.seq) which is not editable.

        :param location: memory location, Either 'INTERNAL' instrument memory or an 'EXTERNAL' USB drive
        :type location: str | enum_location
        :param file_name: A valid file name. Exclude file extension. 'sample.seq' should be 'sample'.
        :type file_name: str
        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :type channel: str | int | list
        :param directory: Directory where the file is being stored. Only specify for "EXTERNAL" drives.
            Defaults to root directory. **Note** Directory is not checked. example: directory = "\\folder\\subfolder\\"
        :type directory: str | None
        """
        # MMEMory:LOAD:ARB:SEQuence <“filename”>, (@chanlist) Loads an Arb sequence
        # TODO Test this with actual files
        # check all parameters
        location_obj = check_enum_str('location', location, self.enum_location)
        check_filename(file_name)
        channel_str, channel_obj = self._check_channel(channel)

        if location_obj.name == "INTERNAL":
            path = rf'{location_obj.value}\{file_name}.seq'
        else:
            if directory is not None:
                path = rf'{location_obj.value}{directory}{file_name}.seq'
            else:
                path = rf'{location_obj.value}\{file_name}.seq'

        self.write(f'MMEM:LOAD:ARB:SEQ "{path}", {channel_str}')
        self.log_inst_errors()

    def store_sequence(self, location, file_name, channel, directory=None):
        r"""
        This command stores an ARB sequence to a file. The filename should be
        the full path and filename. All ARB sequence data is saved in a proprietary
        format (.seq) which is not editable.

        :param location: memory location, Either 'INTERNAL' instrument memory or an 'EXTERNAL' USB drive
        :type location: str | enum_location
        :param file_name: A valid file name. Exclude file extension. 'sample.seq' should be 'sample'.
        :type file_name: str
        :param channel: Channel to which the changes are taking place. One of the following:

            * 1-4 - integer value representing a single channel of the four possible channels.
            * N6705C.ch[1-4] - channel object representing a single channel of the four possible channels.
        :type channel: int | channel_obj
        :param directory: Directory where the file is being stored. Only specify for "EXTERNAL" drives.
            Defaults to root directory. **Note** Directory is not checked. example: directory = "\\folder\\subfolder\\"
        :type directory: str | None
        """
        # MMEMory:STORe:ARB:SEQuence <“filename”>, (@chanlist) Stores an Arb sequence
        # check all parameters
        location_obj = check_enum_str('location', location, self.enum_location)
        check_filename(file_name)
        channel_str, channel_obj = self._check_channel(channel)

        if location_obj.name == "INTERNAL":
            path = rf'"{location_obj.value}\{file_name}.seq"'
        else:
            if directory is not None:
                path = rf'"{location_obj.value}{directory}{file_name}.seq"'
            else:
                path = rf'"{location_obj.value}\{file_name}.seq"'

        self.write(f'MMEM:STOR:ARB:SEQ "{path}", {channel_str}')
        self.log_inst_errors()

    def delete_file(self, file_name):
        """
        This command deletes the specified file in internal memory.

        :param file_name: A valid file name. Include file extension. extensions can be .seq or .dlog.
        :type file_name: str

        """
        #  MMEMory:DELete <“filename”> Deletes a file
        check_filename(file_name)
        self.write(f'MMEM:DEL {file_name}')
        self.log_inst_errors()

    def export_datalog(self, file_name, directory=None):
        """
        Exports data from the instruments datalog to external memory. Exported data is in a .csv file format

        :param directory: Directory where the file is being stored. Only specify for "EXTERNAL" drives.
            Defaults to root directory. **Note** Directory is not checked. example: directory = "\\folder\\subfolder\\"
        :type directory: str | None
        :param file_name: A valid file name. Exclude file extension. 'sample.csv' should be 'sample'.
        :type file_name: str
        :return: File exported to external memory.
        :rtype: None
        """
        # MMEMory:EXPort:DLOG <“filename”> Exports a data log from the display to a file
        check_filename(file_name)
        if directory is not None:
            path = rf'"external:{directory}{file_name}.csv"'
        else:
            path = rf'"external:\{file_name}.csv"'

        self.write(f'MMEM:EXP:DLOG {path}')
        wait_visualizer(2)
        self.log_inst_errors()

    def drive_free_space(self, location):
        """
        Query the free space of a internal or external storage.

        :param location: memory location, Either 'INTERNAL' instrument memory or an 'EXTERNAL' USB drive
        :type location: str | enum_location
        :return: A space in bytes
        :rtype: float
        """
        # MMEMory:ATTRibute? <“object”>, <“attribute”> Gets the attributes of a file system object
        location_obj = check_enum_str('location', location, self.enum_location)
        pre_target = f'"{location_obj.value}", "DriveFreeSpace"'
        ret_data = float(self.query("MMEM:ATTR", pre_target_params=pre_target).strip('"'))
        self.log_inst_errors()
        return ret_data

    def drive_capacity(self, location):
        """
        Query the capacity of a internal or external storage.

        :param location: memory location, Either 'INTERNAL' instrument memory or an 'EXTERNAL' USB drive
        :type location: str | enum_location
        :return: A space in bytes
        :rtype: float
        """
        # MMEMory:ATTRibute? <“object”>, <“attribute”> Gets the attributes of a file system object
        location_obj = check_enum_str('location', location, self.enum_location)
        pre_target = f'"{location_obj.value}", "DriveCapacity"'
        ret_data = float(self.query("MMEM:ATTR", pre_target_params=pre_target).strip('"'))
        self.log_inst_errors()
        return ret_data

    def file_size(self, location, file_name, directory=None):
        r"""
        Get the size of a file.

        :param location: memory location, Either 'INTERNAL' instrument memory or an 'EXTERNAL' USB drive
        :type location: str | enum_location
        :param file_name: A valid file name. Include file extension. Extension can be .seq or .dlog
        :type file_name: str
        :param directory: Directory where the file is being stored. Only specify for "EXTERNAL" drives.
            Defaults to root directory. **Note** Directory is not checked. example: directory = "\\folder\\subfolder\\"
        :type directory: str | None
        :return: A file's size in bytes
        :rtype: float
        """
        # MMEMory:ATTRibute? <“object”>, <“attribute”> Gets the attributes of a file system object
        # check all parameters
        location_obj = check_enum_str('location', location, self.enum_location)
        check_filename(file_name)

        if location_obj.name == "INTERNAL":
            path = rf'"{location_obj.value}\{file_name}.seq"'
        else:
            if directory is not None:
                path = rf'"{location_obj.value}{directory}{file_name}.seq"'
            else:
                path = rf'"{location_obj.value}\{file_name}.seq"'

        pre_target = f'"{path}", "FileSize"'

        ret_data = self.query(f'MMEM:ATTR', pre_target_params=pre_target)
        self.log_inst_errors()
        return ret_data

    def file_data(self, file_name, binary_data=None):
        """
        Copies binary data block to the specified file on the internal memory. Alternatively recall data from specified
        file by only specifying the file_name

        :param file_name: A valid file name. Exclude file extension. 'Sample.bin' would be 'Sample'.
        :type file_name: str
        :param binary_data: data block of bytes to be written to the instrument's file.
        :type binary_data: bytes
        :return: if binary_data is empty, recalls binary data from the specified file.
        :rtype: None | bytes
        """
        # MMEMory:DATA [:DEFinite]? <“filename”> Copies file contents; response is a definite length binary block
        check_filename(file_name)
        path = rf"internal:\{file_name}.bin"

        if binary_data is None:
            self.write("MMEM:DATA?", path)
            raw_data = self.read_raw()
            self.log_inst_errors()
            return raw_data[:len(raw_data)-1]

        target = f"{path}, {binary_data}"
        self.write('MMEM:DATA', target)
        self.log_inst_errors()

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
