from cl_instr_lib.base_classes.dmm_basic_ABC import DmmBasic_ABC
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import *
from enum import Enum

idn_model = 'MODEL 2000'


# noinspection PyPep8Naming
class DMM2000_base(DmmBasic_ABC, InstrumentVisa):

    #: These Enum objects or keys (strings) can be used in method calls that take the **function** parameter.
    #: Keys are 'DCV', 'ACV', 'DCI', 'ACI', 'OHMS2', 'OHMS4', 'FREQ', 'PER'. Roughly corresponds to the top row
    #: of buttons on the instrument.
    enum_functions = Enum('enum_functions', {'DCV': 'VOLT:DC', 'ACV': 'VOLT:AC', 'DCI': 'CURR:DC', 'ACI': 'CURR:AC',
                                             'OHMS2': 'RES', 'OHMS4': 'FRES', 'FREQ': 'FREQ', 'PER': 'PER'})

    #: These Enum objects or keys (strings) can be used in setup method calls that take the **ave_modes** parameter.
    #: Keys are 'REP', 'MOV', 'OFF'.
    enum_ave_modes = Enum('enum_ave_modes', {'REP': 'REP', 'MOV': 'MOV', 'OFF': 0})

    def __init__(self, visa_resource_name, logger=None, **kwargs):
        super().__init__(visa_resource_name, logger, **kwargs)

    def measure(self, function=None):
        """
        One-shot measurement, using default (post-\*RST) configurations for function.

        ATTENTION: Any previously programed non-default configuration for the named function is lost and
        replaced by the \*RST values!

        Equivalent to this sequence of SCPI cmds: "ABORt;CONFIGure<function>; READ?".
        Note that READ? itself is equivalent to ABORt; INITiate; FETCh?

        :param function: Identifies DMM measurement function:'DCV', 'ACV', 'DCI', 'ACI', 'OHMS2', 'OHMS4', 'FREQ', 'PER'
            If None, instrument function presently selected in the instrument is used.
        :type: str | enum_functions | None:
        :return: the value measured
        :rtype: float
        """

        # :MEASure[:<function>]?
        function_obj = check_enum_str("function", function, self.enum_functions)

        if function is None:
            tmp = self.query('MEAS', float)
        else:
            tmp = self.query(f"MEAS:{function_obj.value}", float)

        self.log_inst_errors()
        return tmp

    def _setup_dc(self, scpi_prefix, range_max, unit,
                  dc_range=None, npl_cycles=None, ave_mode=None, ave_count=None, digits=None):
        """
        Helper function for DC measurements. Query all or set any combination.

        A DC function in the DMM does not have to be selected to program these parameters. These configuration
        settings for DCV are remembered by the DMM when other functions are selected using the select_function method.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param scpi_prefix: SCPI command prefix (CURR:DC, VOLT:DC, RES, FRES)
        :type scpi_prefix: str
        :param range_max: Upper limit of range for corresponding command
        :type range_max: float
        :param unit: Unit for output (A, V DC, Ohms2w, Ohms4w)
        :type unit: str
        :param dc_range: 'AUTO' or float near expected voltage (0 to 1010).
        :type dc_range: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float
        :param ave_mode: 'OFF' or 'MOV' or REP'.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        reading returned over bus.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        if all(v is None for v in {dc_range, npl_cycles, ave_mode, ave_count, digits}):
            return_value = {}
            if self.query(f'{scpi_prefix}:RANG:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'{scpi_prefix}:RANG', float)
            return_value.update(dc_range=value1)

            return_value.update(npl_cycles=self.query(f'{scpi_prefix}:NPLC', float))

            if self.query(f'{scpi_prefix}:AVER:STAT', bool):
                value2 = self.query(f'{scpi_prefix}:AVER:TCON', str)
            else:
                value2 = self.enum_ave_modes.OFF.name
            return_value.update(ave_mode=value2)

            return_value.update(ave_count=self.query(f'{scpi_prefix}:AVER:COUN', int))
            return_value.update(digits=self.query(f'{scpi_prefix}:DIG', int))
            return return_value

        if dc_range is not None:
            if dc_range != 'AUTO' and not (isinstance(dc_range, (float, int)) and (0 <= dc_range <= range_max)):
                raise ValueError(f"Bad dc_range {dc_range}. "
                                 f"Should be 'AUTO' or float value from 0 to {range_max} {unit}.")

        check_range('npl_cycles', npl_cycles, min_max_units(0.01, 10, ""))
        ave_mode_obj = check_enum_str("ave_mode", ave_mode, self.enum_ave_modes)
        check_range('ave_count', ave_count, min_max_units(1, 100, ""))
        check_range('digits', digits, min_max_units(4, 7, "Digits"), val_type=int)
        # If reached all input values are good

        if dc_range is not None:
            if dc_range == 'AUTO':
                self.write(f'{scpi_prefix}:RANG:AUTO', 1)
            else:
                self.write(f'{scpi_prefix}:RANG', dc_range)

        if npl_cycles is not None:
            self.write(f'{scpi_prefix}:NPLC', npl_cycles)

        if ave_mode_obj is not None:
            if ave_mode_obj.value == 0:
                self.write(f'{scpi_prefix}:AVER:STAT', ave_mode_obj.value)
            else:
                self.write(f'{scpi_prefix}:AVER:STAT', 1)
                self.write(f'{scpi_prefix}:AVER:TCON', ave_mode_obj.value)

        if ave_count is not None:
            self.write(f'{scpi_prefix}:AVER:COUN', ave_count)

        if digits is not None:
            self.write(f'{scpi_prefix}:DIG', digits)

        self.log_inst_errors()

    def _setup_ac(self, scpi_prefix, range_max, unit,
                  ac_range=None, npl_cycles=None, bandwidth=None, ave_mode=None, ave_count=None, digits=None):
        """
        Helper function for AC measurements. Query all or set any combination.

        A AC function in the DMM does not have to be selected to program these parameters. These configuration
        settings for ACV are remembered by the DMM when other functions are selected using the select_function method.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param scpi_prefix: SCPI command prefix (CURR:AC, VOLT:AC, RES, FRES)
        :type scpi_prefix: str
        :param range_max: Upper limit of range for corresponding command
        :type range_max: float
        :param unit: Unit for output (A, V AC)
        :type unit: str
        :param ac_range: 'AUTO' or float near expected voltage (0 to 757.5).
        :type ac_range: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float
        :param bandwidth: The frequency of the input signal (3Hz to 300e3 Hz)
        :type bandwidth: float
        :param ave_mode: 'OFF' or 'MOV' or REP'.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        if all(v is None for v in {ac_range, npl_cycles, bandwidth, ave_mode, ave_count, digits}):
            return_value = {}
            if self.query(f'{scpi_prefix}:RANG:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'{scpi_prefix}:RANG', float)
            return_value.update(ac_range=value1)

            return_value.update(npl_cycles=self.query(f'{scpi_prefix}:NPLC', float))
            return_value.update(bandwidth=self.query(f'{scpi_prefix}:DET:BAND', float))

            if self.query(f'{scpi_prefix}:AVER:STAT', bool):
                value2 = self.query(f'{scpi_prefix}:AVER:TCON', str)
            else:
                value2 = self.enum_ave_modes.OFF.name
            return_value.update(ave_mode=value2)

            return_value.update(ave_count=self.query(f'{scpi_prefix}:AVER:COUN', int))
            return_value.update(digits=self.query(f'{scpi_prefix}:DIG', int))
            return return_value

        check_range('npl_cycles', npl_cycles, min_max_units(0.01, 10, ""))
        check_range('bandwidth', bandwidth, min_max_units(3, 300e3, ""))
        check_range('ave_count', ave_count, min_max_units(1, 100, ""))
        check_range('digits', digits, min_max_units(4, 7, "Digits"), val_type=int)
        ave_mode_obj = check_enum_str("ave_mode", ave_mode, self.enum_ave_modes)

        if ac_range is not None:
            if ac_range != 'AUTO' and not (isinstance(ac_range, (float, int)) and (0 <= ac_range <= range_max)):
                raise ValueError(f"Bad ac_range {ac_range}. "
                                 f"Should be 'AUTO' or float value from 0 to {range_max} {unit}.")

        tmp = bandwidth
        if bandwidth is None:
            tmp = self.query(f'{scpi_prefix}:DET:BAND', float)
        if tmp < 300 and npl_cycles is not None:
            raise ValueError(f'Set bandwidth to 300Hz or greater to change npl_cycles.')

        # If reached all input values are good

        if ac_range is not None:
            if ac_range == 'AUTO':
                self.write(f'{scpi_prefix}:RANG:AUTO', 1)
            else:
                self.write(f'{scpi_prefix}:RANG', ac_range)

        if bandwidth is not None:
            self.write(f'{scpi_prefix}:DET:BAND', bandwidth)

        if npl_cycles is not None:
            self.write(f'{scpi_prefix}:NPLC', npl_cycles)

        if ave_mode_obj is not None:
            if ave_mode_obj.value == 0:
                self.write(f'{scpi_prefix}:AVER:STAT', ave_mode_obj.value)
            else:
                self.write(f'{scpi_prefix}:AVER:STAT', 1)
                self.write(f'{scpi_prefix}:AVER:TCON', ave_mode_obj.value)

        if ave_count is not None:
            self.write(f'{scpi_prefix}:AVER:COUN', ave_count)

        if digits is not None:
            self.write(f'{scpi_prefix}:DIG', digits)

        self.log_inst_errors()

    def setup_aci(self, irange=None, npl_cycles=None, bandwidth=None, ave_mode=None, ave_count=None, digits=None,
                  *args, **kwargs):
        """
        Query all or set any combination of parameters relating to AC CURRENT measurements.

        The ACI function in the DMM does not have to selected to program these parameters. These configuration settings
        for ACI are remembered by the DMM when other functions are selected using the select_function method. Be aware
        that using the measure method will reset all of these settings to their defaults.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param irange: 'AUTO' or float near expected current (0 to 3.1 Arms).
        :type irange: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float 0.01 to 10
        :param bandwidth: The frequency of the input signal (3Hz to 300e3 Hz)
        :type bandwidth: float
        :param ave_mode: 'OFF' or 'MOV' or REP'. 'MOV' uses a FIFO of size ave_count that is averaged once full and then
            each time a new measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count
            measurements and then averages them; then, all measurements are cleared and the accumulation and
            averaging starts over. With relay switching, 'REP' should be used to avoid averaging together measurements
            from different channels.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # :SENSe[1]]:CURRent:AC:RANGe[:UPPer] <n> = 0 to 3.1 A
        # [:SENSe[1]]:CURRent:AC:RANGe:AUTO <b>
        # [:SENSe[1]]:CURRent:AC:NPLCycles <n>
        # [:SENSe[1]]:CURRent:AC:DIGits <n>
        # [:SENSe[1]]:CURRent:AC:AVERage:STATe <b>
        # :SENSe[1]]:CURRent:AC:AVERage:TCONtrol <name>
        # [:SENSe[1]]:CURRent:AC:AVERage:COUNt <n>
        # [:SENSe[1]]:CURRent:AC:DETector:BANDwidth <n> = 3 to 300e3

        self.log_unused_args(args, kwargs)

        tmp = self._setup_ac(self.enum_functions.ACI.value, 3.1, 'A', irange, npl_cycles, bandwidth, ave_mode,
                             ave_count, digits)

        if tmp is not None:
            # Convert the dict key for range while preserving the order.
            return dict(('irange', value) if name == 'ac_range' else (name, value) for name, value in tmp.items())

    def setup_dci(self, irange=None, npl_cycles=None, ave_mode=None, ave_count=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to DC CURRENT measurements.

        The DCI function in the DMM does not have to selected to program these parameters. These configuration settings
        for DCI are remembered by the DMM when other functions are selected using the select_function method.  Be aware
        that using the measure method will reset all of these settings to their defaults.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param irange: 'AUTO' or float near expected current (0 to 3.1).
        :type irange: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float 0.01 to 10
        :param ave_mode: 'OFF' or 'MOV' or REP'. 'MOV' uses a FIFO of size ave_count that is averaged once full and then
            each time a new measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count
            measurements and then averages them; then, all measurements are cleared and the accumulation and
            averaging starts over. With relay switching, 'REP' should be used to avoid averaging together measurements
            from different channels.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # [:SENSe[1]]:CURRent[:DC]:RANGe[:UPPer] <n> = 0 to 3.1 A
        # [:SENSe[1]]:CURRent[:DC]:RANGe:AUTO <b>
        # [:SENSe[1]]:CURRen[:DC]:NPLCycles <n>
        # [:SENSe[1]]:CURRent[:DC]:AVERage:STATe <b>
        # [:SENSe[1]]:CURRent[:DC]:AVERage:TCONtrol <name>
        # [:SENSe[1]]:CURRent[:DC]:AVERage:COUNt <n>
        # [:SENSe[1]]:CURRent:DC:DIGits <n>

        self.log_unused_args(args, kwargs)

        tmp = self._setup_dc(self.enum_functions.DCI.value, 3.1, 'A', irange, npl_cycles, ave_mode, ave_count, digits)

        if tmp is not None:
            # Convert the dict key for range while preserving the order.
            return dict(('irange', value) if name == 'dc_range' else (name, value) for name, value in tmp.items())

    def setup_dcv(self, vrange=None, npl_cycles=None, ave_mode=None, ave_count=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to DC VOLTAGE measurements.

        The DCV function in the DMM does not have to be selected to program these parameters. These configuration
        settings for DCV are remembered by the DMM when other functions are selected using the select_function method.
        Be aware that using the measure method will reset all of these settings to their defaults.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param vrange: 'AUTO' or float near expected voltage (0 to 1010 V).
        :type vrange: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float
        :param ave_mode: 'OFF' or 'MOV' or REP'.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # [:SENSe[1]]:VOLTage[:DC]:RANGe[:UPPer] <n>             0 to 1010, 'def' = 1000, 'min' = 0, 'max' = 1000
        # [:SENSe[1]]:VOLTage[:DC]:RANGe:AUTO <b>                0 or 1
        # [:SENSe[1]]:VOLTage[:DC]:NPLCycles <n>                 0.01 to 10, 'def'=1, 'min'=0.01, 'max'=10
        # [:SENSe[1]]:VOLTage[:DC]:AVERage:STATe <b>             0 or 1
        # [:SENSe[1]]:VOLTage[:DC]:AVERage:TCONtrol <name>       REPeat or MOVing
        # [:SENSe[1]]:VOLTage[:DC]:AVERage:COUNt <n>             1...100, 'def'= 10, 'min'= 1, 'max' = 100,
        # [:SENSe[1]]:VOLTage:DC:DIGits <n>                      4...7, 'def'(6),  'min'(3), 'max'(6)

        self.log_unused_args(args, kwargs)

        tmp = self._setup_dc(self.enum_functions.DCV.value, 1010, 'V DC', vrange, npl_cycles, ave_mode, ave_count,
                             digits)

        if tmp is not None:
            # Convert the dict key for range while preserving the order.
            return dict(('vrange', value) if name == 'dc_range' else (name, value) for name, value in tmp.items())

    def setup_acv(self, vrange=None, npl_cycles=None, bandwidth=None, ave_mode=None, ave_count=None, digits=None,
                  *args, **kwargs):
        """
        Query all or set any combination of parameters relating to AC VOLTAGE measurements.

        The ACV function in the DMM does not have to be selected to program these parameters. These configuration
        settings for ACV are remembered by the DMM when other functions are selected using the select_function method.
        Be aware that using the measure method will reset all of these settings to their defaults.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param vrange: 'AUTO' or float near expected voltage (0 to 757.5 Vrms).
        :type vrange: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float
         :param bandwidth: The frequency of the input signal (3Hz to 300e3 Hz)
        :type bandwidth: float
        :param ave_mode: 'OFF' or 'MOV' or REP'.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # [: SENSe[1]]:VOLTage: AC:RANGe[:UPPer] < n >  <n> = 0 to 757.5 V
        # [:SENSe[1]]:VOLTage:AC:RANGe:AUTO <b>
        # [:SENSe[1]]:VOLTage:AC:NPLCycles <n>
        # [:SENSe[1]]:VOLTage:AC:AVERage:STATe <b>
        # [:SENSe[1]]:VOLTage:AC:AVERage:TCONtrol <name>
        # [:SENSe[1]]:VOLTage:AC:AVERage:COUNt <n>
        # [:SENSe[1]]:VOLTage:AC:DIGits <n>
        # [:SENSe[1]]:VOLTage:AC:DETector:BANDwidth <n> = 3 to 300e3

        self.log_unused_args(args, kwargs)

        tmp = self._setup_ac(self.enum_functions.ACV.value, 757.5, 'V AC', vrange, npl_cycles, bandwidth, ave_mode,
                             ave_count, digits)

        if tmp is not None:
            # Convert the dict key for range while preserving the order.
            return dict(('vrange', value) if name == 'ac_range' else (name, value) for name, value in tmp.items())

    def setup_ohms2w(self, rrange=None, npl_cycles=None, ave_mode=None, ave_count=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to Two-Wire RESISTANCE measurements.

        The OHMS2 function in the DMM does not have to selected to program these parameters.
        These configuration settings for OHMS2 are remembered by the DMM when other functions are selected using
        the select_function method.  Be aware that using the measure method will reset all of these settings to their
        defaults.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param rrange: 'AUTO' or float near expected resistance (0 to 120e6).
        :type rrange: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float
        :param ave_mode: 'OFF' or 'MOV' or REP'. 'MOV' uses a FIFO of size ave_count that is averaged once full and then
            each time a new measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count
            measurements and then averages them; then, all measurements are cleared and the accumulation and
            averaging starts over. With relay switching, 'REP' should be used to avoid averaging together measurements
            from different channels.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # [:SENSe[1]]:RESistance:RANGe[:UPPer] <n> = 0 to 120e6
        # [:SENSe[1]]:RESistance:RANGe:AUTO <b>
        # [:SENSe[1]]:RESistance:NPLCycles <n>
        # [:SENSe[1]]:RESistance:AVERage:STATe <b>
        # [:SENSe[1]]:RESistance:AVERage:TCONtrol <name>
        # [:SENSe[1]]:RESistance:AVERage:COUNt <n>
        # [:SENSe[1]]:RESistance:DIGits <n>

        tmp = self._setup_dc(self.enum_functions.OHMS2.value, 120e6, 'Ohms2w', rrange, npl_cycles, ave_mode, ave_count,
                             digits)

        self.log_unused_args(args, kwargs)

        if tmp is not None:
            # Convert the dict key for range while preserving the order.
            return dict(('rrange', value) if name == 'dc_range' else (name, value) for name, value in tmp.items())

    def setup_ohms4w(self, rrange=None, npl_cycles=None, ave_mode=None, ave_count=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to Four-Wire RESISTANCE measurements.

        The OHMS4 function in the DMM does not have to selected to program these parameters.
        These configuration settings for OHMS4 are remembered by the DMM when other functions are selected using
        the select_function method.  Be aware that using the measure method will reset all of these settings to their
        defaults.

        About averaging: 'MOV' uses a FIFO of size ave_count that is averaged once full and then each time a new
        measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count measurements and
        then averages them; then, all measurements are cleared and the accumulation and averaging starts over. With
        relay switching, 'REP' should be used to avoid averaging together measurements
        from different channels.

        :param rrange: 'AUTO' or float near expected resistance (0 to 120e6).
        :type rrange: str or float
        :param npl_cycles: Integration rate in power line cycles 0.01 to 10.
        :type npl_cycles: float 0.01 to 10
        :param ave_mode: 'OFF' or 'MOV' or REP'. 'MOV' uses a FIFO of size ave_count that is averaged once full and then
            each time a new measurement pushes out an old measurement. The 'REP' or repeating mode accumulates ave_count
            measurements and then averages them; then, all measurements are cleared and the accumulation and
            averaging starts over. With relay switching, 'REP' should be used to avoid averaging together measurements
            from different channels.
        :type ave_mode: str, enum_ave_modes
        :param ave_count: number of readings to average, 1 to 100
        :type ave_count: int
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # [:SENSe[1]]:FRESistance:RANGe[:UPPer] <n> = 0 to 120e6
        # [:SENSe[1]]:FRESistance:RANGe:AUTO <b>
        # [:SENSe[1]]:FRESistance:NPLCycles <n>
        # [:SENSe[1]]:FRESistance:AVERage:STATe <b>
        # [:SENSe[1]]:FRESistance:AVERage:TCONtrol <name>
        # [:SENSe[1]]:FRESistance:AVERage:COUNt <n>
        # [:SENSe[1]]:FRESistance:DIGits <n>

        self.log_unused_args(args, kwargs)

        tmp = self._setup_dc(self.enum_functions.OHMS4.value, 120e6, 'Ohms4w', rrange, npl_cycles, ave_mode, ave_count,
                             digits)

        if tmp is not None:
            # Convert the dict key for range while preserving the order.
            return dict(('rrange', value) if name == 'dc_range' else (name, value) for name, value in tmp.items())

    def setup_freq(self, threshold=None, digits=None,  *args, **kwargs):
        """
        Queries all or sets parameters relating to measuring input frequency.

        :param threshold: Threshold is used to specify the expected input level. The instrument will then automatically
                select the most sensitive current or voltage threshold range.
        :type threshold: float
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # [:SENSe[1]]:FREQuency:THReshold:VOLTage:RANGe <n>  <n> = 0...1010
        # [: SENSe[1]]:FREQuency: DIGits < n >

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {threshold, digits}):
            return_value = {}
            return_value.update(threshold=self.query(f'FREQ:THR:VOLT:RANG', float))
            return_value.update(digits=self.query(f'FREQ:DIG', int))
            return return_value

        check_range('threshold', threshold, min_max_units(0, 1010, "Volts"))
        check_range('digits', digits, min_max_units(4, 7, "Digits"), val_type=int)

        if threshold is not None:
            self.write(f'FREQ:THR:VOLT:RANG', threshold)

        if digits is not None:
            self.write(f'FREQ:DIG', digits)

        self.log_inst_errors()

    def setup_period(self, threshold=None, digits=None,  *args, **kwargs):
        """
        Queries all or sets parameters relating to measuring input period.

        :param threshold: Threshold is used to specify the expected input level. The instrument will then automatically
                select the most sensitive current or voltage threshold range.
        :type threshold: float
        :param digits: Values 4 through 7 correspond to a display resolution of 3.5 to 6.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # [:SENSe[1]]:PERiod:THReshold:VOLTage:RANGe <n>
        # [:SENSe[1]]:PERiod:DIGits <n>

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {threshold, digits}):
            return_value = {}
            return_value.update(threshold=self.query(f'PER:THR:VOLT:RANG', float))
            return_value.update(digits=self.query(f'PER:DIG', int))
            return return_value

        check_range('threshold', threshold, min_max_units(0, 1010, "Volts"))
        check_range('digits', digits, min_max_units(4, 7, "Digits"), val_type=int)

        if threshold is not None:
            self.write(f'PER:THR:VOLT:RANG', threshold)

        if digits is not None:
            self.write(f'PER:DIG', digits)

        self.log_inst_errors()

    def select_function(self, function=None):
        """
        Query or select the measurement function of the instrument. Note that each measurement function in the DMM
        remembers its unique setup configuration such as range, npl_cycles, etc. that you may have previously setup
        using the setup_<function> methods. select_function allows for rapid switching between functions without
        re-programming the configurations. Use the read method to trigger a measurement and obtain the result.

        :param function: Identifies measurement function: 'DCV', 'ACV', 'DCI', 'ACI', 'OHMS2', 'OHMS4', 'FREQ', 'PER'.
            If None, instrument function is queried.
        :type function: str, enum_functions
        :return: The function mnemonic corresponding to the return value of the query.
        :rtype: str
        """

        # function = suffix of config. Use enum to map to names needed by instrument, see p 168
        # [:SENSe[1]]:FUNCtion <name>

        if function is None:
            tmp = self.query('FUNC', str).strip('"')
            return self.enum_functions(tmp).name

        function_obj = check_enum_str("function", function, self.enum_functions)

        if function_obj is not None:
            self.write('FUNC', f'"{function_obj.value}"')

        self.log_inst_errors()

    def initiate(self):
        """
        Transitions DMM from the Idle state into Event Detection which waits for a trigger event from the event_source
        selected by the setup_trigger method. When the trigger event is received, execution proceeds,
        after a programmable delay, to the "Device Actions" required to generate a measurement. This cycle is repeated
        as many times as dictated by the programmed value of trig_count, thereby generating as many measurements.

        The DMM then returns to the Idle state.
        """

        # :INITiate[:IMMediate]

        self.write('INIT:CONT', 0)

        self.write('INIT:IMM', '')

        self.log_inst_errors()

    def initiate_continuous(self, init_type=None):
        """
        Transitions DMM from the Idle state into Event Detection which waits for a trigger event from the event_source
        selected by the setup_trigger method. When the trigger event is received, execution proceeds,
        after a programmable delay, to the "Device Actions" required to generate a measurement. This cycle is repeated
        as many times as dictated by the programmed value of trig_count, thereby generating as many measurements.

        The DMM then returns to Event Detection where the arrival of another trigger event starts the whole cycle
        again.

        :param init_type: 'ON' or 'OFF' or 1 or 0
        :return: If init_type is None, present setting of *init_type* is read and returned.
        :rtype: str
        """

        # :INITiate:CONTinuous <b>

        if init_type is None:
            return self.on_off.to_api(self.query('INIT:CONT', int))

        self.write('INIT:CONT', self.on_off.to_inst(init_type))

        self.log_inst_errors()

    def abort(self):
        """
        Aborts operation in progress and returns to top of trigger model. If initiate_continuous is OFF, instrument goes
        into idle state. If initiate_continuous is ON, current Device Action is terminated and operation continues from
        the top of the trigger model.

        :return: None
        """

        # :ABORt

        self.write('ABOR', '')

    def setup_trigger(self, event_source=None, delay_sec=None, sample_count=None, trig_count=None):
        """
        Query all or set any combination parameters related to the trigger model.  This allows for measurements to be
        made when a trigger is received.

        :param event_source: 'IMM', 'EXT', 'TIM', 'MAN', 'BUS'. 'IMM' is the default.
        :type event_source: str
        :param delay_sec:  Delay between detection of an event and the the start of a "Device Action".
            0 to 999999.999 seconds. A Device Action is primarily a measurement, but may include: Filtering or Hold
            operations,  which involve acquiring multiple readings to produce a measurement result.
        :type delay_sec: float, str
        :param sample_count: Readings performed per trigger.
        :type sample_count: int
        :param trig_count: Number of triggers that must occur before returning to the Idle state (init_type='IMM') or to
            repeating the entire sequence automatically (init_type='CONT'). See the initiate method. trig_count can be
            1...9999 or 'INF'.
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # :TRIGger[:SEQuence[1]]:SOURce <name>
        # :TRIGger[:SEQuence[1]]:DELay <n>
        # :TRIGger[:SEQuence[1]]:COUNt <n>
        # :SAMPle:COUNt <NRf>

        if all(v is None for v in {event_source, delay_sec, sample_count, trig_count}):
            return_value = {}
            return_value.update(event_source=self.query('TRIG:SOUR', str))

            if self.query(f'TRIG:DEL:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'TRIG:DEL', float)
            return_value.update(delay_sec=value1)

            return_value.update(sample_count=self.query('SAMP:COUN', int))
            return_value.update(trig_count=self.query('TRIG:COUN', int))
            return return_value

        # TODO: Change event source to use enum
        if event_source is not None:
            event_source_tup = ('IMM', 'EXT', 'TIM', 'MAN', 'BUS')
            if event_source in event_source_tup:
                self.write('TRIG:SOUR', event_source)
            else:
                raise ValueError(f'Bad event_source {event_source}. Should be one of {event_source_tup}.')

        if delay_sec is not None:
            if delay_sec != 'AUTO' and not (isinstance(delay_sec, (float, int)) and (0 <= delay_sec <= 999999.999)):
                raise ValueError(f"Bad delay_sec {delay_sec}. "
                                 f"Should be 'AUTO' or float value from 0 to 999999.999 seconds.")

        check_range('trig_count', trig_count, min_max_units(1, 9999, ""), val_type=int)
        check_range('sample_count', sample_count, min_max_units(1, 1024, "Samples"))

        if sample_count is not None:
            if self.query('INIT:CONT', int) == 1 and sample_count > 1:
                raise ValueError('Cannot set sample_count > 1 if initiate_continuous is ON.')

        # If reached all input values are good

        if event_source is not None:
            self.write('TRIG:SOUR', event_source)

        if delay_sec is not None:
            if delay_sec == 'AUTO':
                self.write(f'TRIG:DEL:AUTO', 1)
            else:
                self.write(f'TRIG:DEL', delay_sec)

        if sample_count is not None:
            self.write('SAMP:COUN', sample_count)

        if trig_count is not None:
            self.write('TRIG:COUN', trig_count)

        self.log_inst_errors()

    def fetch(self):
        """
        Executes the DMM FETCH? query which retrieves the most recent measurement result. Does not trigger a
        measurement, assumes that has already occurred via some other triggering event.

        :return: The result of the measurement that has already been performed.
        :rtype: float
        """

        # FETCH?
        return self.query('FETCH', float)

    def read(self):
        """
        Executes the DMM READ? query which is equivalent to the sequence ABORT; INIT; FETCH. Note that this aborts any
        measurement currently in progress and initiates a new measurement and returns the result.

        :return: The result of a new measurement
        :rtype: float
        """

        # READ?

        self.write('INIT:CONT', 0)

        return self.query('READ', float)

    def get_fr_switch(self):
        """
        Returns whether front or rear inputs are selected.

        :return: 'FRONT', 'REAR'
        :rtype: str
        """

        if self.query('SYST:FRSW', bool):
            return "FRONT"
        else:
            return "REAR"


if __name__ == '__main__':
    dmm2000 = DMM2000_base('GPIB0::16')   # Replace visa_resource_name with None for simulated hardware.
    dmm2000.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
