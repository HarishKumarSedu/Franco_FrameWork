# -----------------------------------------------------------
#                        CONFIG LIST
# -----------------------------------------------------------

from abc import ABC

class ConfigListABC(ABC):
    def __init__(self, smu, source_or_sense):
        self.smu = smu
        self.write = smu.write
        self.query = smu.query
        self.rm_query = smu.rm_handle.query
        self.log_inst_errors = smu.log_inst_errors

        self.source_or_sense = source_or_sense   # Derived class sets to 'SOUR' or 'SENS'.

    def catalog(self):
        """
        Returns the names of the config_lists defined in the sub-system (Source or Measure).

        :return: A list of Config list names.
        :rtype: List[str]
        """

        # :SOURce[1]:CONFiguration:LIST:CATalog?
        # [:SENSe[1]]:CONFiguration:LIST:CATalog?

        config_list_names = []
        for index in range(200):  # have it break eventually just in case
            list_name = self.query(f":{self.source_or_sense}:CONF:LIST:CAT")
            if list_name == '':
                break
            config_list_names.append(list_name)

        self.log_inst_errors()
        return config_list_names

    def create(self, name):
        """
        Creates an empty configuration list.

        Works for both Source or Measure depending on the class it is called in.

        **NOTE:** Names must be unique across both source and measure config lists.

        :param name: name of the list to create.
        :type name: str
        """

        # :SOURce[1]:CONFiguration:LIST:CREate "<name>"
        # [:SENSe[1]]:CONFiguration:LIST:CREate "<name>"

        if not isinstance(name, str):
            raise ValueError(f"List name {name} is not of type str.")

        # Names must be unique across both source and measure config lists.
        if name in self.smu.source.config_list.catalog():
            raise ValueError(f"List of name '{name}' already exists in Source. Must be unique across Source and "
                             f"Measure.")

        if name in self.smu.measure.config_list.catalog():
            raise ValueError(f"List of name '{name}' already exists in Measure. Must be unique across Source and "
                             f"Measure.")

        self.write(f':{self.source_or_sense}:CONF:LIST:CRE "{name}"')
        self.log_inst_errors()

    def delete(self, name, index=None):
        """
        Deletes a configuration list or a specific index. If index is None, the entire list is deleted.

        If the index is specified, only the specified configuration index in the list is deleted. Indices are
        automatically renumbered. Because of this, if you want to delete several nonconsecutive indexes, it is best to
        delete the higher numbered index first, then the next lower index, and so on.

        If the index deleted contained setup information (such as range) that information is automatically becomes
        part of the new entry at index.

        :param name: name of configuration list
        :type name: str
        :param index: index of data point to be deleted
        :type index: int | None
        """

        # :SOURce[1]:CONFiguration:LIST:DELete "<name>"
        # :SOURce[1]:CONFiguration:LIST:DELete "<name>", <index>
        # [:SENSe[1]]:CONFiguration:LIST:DELete "<name>"
        # [:SENSe[1]]:CONFiguration:LIST:DELete "<name>", <index>

        self._list_name_check(name)  # check that raises errors for invalid names

        command = f':{self.source_or_sense}:CONF:LIST:DEL "{name}"'
        if index is not None:
            self._list_index_check(name, index)  # check that raises errors for invalid indexes
            command += f", {index}"

        self.write(command)
        self.log_inst_errors()

    def recall(self, name, index):
        """
        This command recalls a specific configuration index in a specific configuration list.

        The available lists are relative to the class (Source or Measure) this method is called in.

        :param name: A string that represents the name of a config list.
        :type name: str
        :param index: A number that defines a specific index in the config list
        :type index: int
        """

        # :SOURce[1]:CONFiguration:LIST:RECall "<name>"
        # :SOURce[1]:CONFiguration:LIST:RECall "<name>", <index>
        # [:SENSe[1]]:CONFiguration:LIST:RECall "<name>"
        # [:SENSe[1]]:CONFiguration:LIST:RECall "<name>", <index>

        command = self._recall_helper(name, index)
        self.write(command)
        self.log_inst_errors()

    def get_size(self, name):
        """
        This command returns the number of configuration indexes of a source configuration list.

        :param name: A string that represents the name of a configuration list
        :type name: str
        :return: the size of the list
        :rtype: int
        """

        self._list_name_check(name)  # check that raises errors for invalid names
        return self.query(f':{self.source_or_sense}:CONF:LIST:SIZE', int, target=f'"{name}"')

    def store(self, name, index=None):
        """
        This command stores the present source or measure settings into the named configuration list.

        If the index is not defined, the setting are appended to the end of the list. This is the only way to add
        entries to the list, there being no insert functionality. Specifying an index causes the existing contents
        of that index to be overwritten with the present settings. For an empty list, index must be None.

        :param name: A string that represents the name of a configuration list
        :type name: str
        :param index:
        :type index: int | None
        :return: None
        :rtype: None
        """

        # :SOURce[1]:CONFiguration:LIST:STORe "<name>", <index>
        # [:SENSe[1]]:CONFiguration:LIST:STORe "<name>"
        # [:SENSe[1]]:CONFiguration:LIST:STORe "<name>", <index>

        # check that both the name and the index are valid
        self._list_name_check(name)

        command = f':{self.source_or_sense}:CONF:LIST:STOR "{name}"'
        if index is not None:
            self._list_index_check(name, index)
            command += f', {index}'

        self.write(command)
        self.log_inst_errors()

    def get_cmds(self, name, index):
        """
        A function that returns a list of parameter settings stored in a specified config index.

        **Note:** The return values of this method are TSP commands. they will not work with our driver framework. This
        method serves to aid the users in giving description of the params of a config index.

        :param name: A string that represents the name of a configuration list
        :type name: str
        :param index: An integer that represents the index of a list
        :type index: int | None
        :return: parameters of the config index
        :rtype: dict
        """

        # :SOURce[1]:CONFiguration:LIST:QUERy? "<name>", <point>
        # :SOURce[1]:CONFiguration:LIST:QUERy? "<name>", <point>, <fieldSeparator>
        # [:SENSe[1]]:CONFiguration:LIST:QUERy? "<name>", <index>
        # [:SENSe[1]]:CONFiguration:LIST:QUERy? "<name>", <index>, <fieldSeparator>

        # check that the values are sound
        self._list_name_check(name)
        self._list_index_check(name, index)

        # retrieve the values from the index and parse into a list
        data_list = self.rm_query(f':{self.source_or_sense}:CONF:LIST:QUER? "{name}", {index}').split(',')
        self.log_inst_errors()

        data_list.remove('\n')
        return_dict = {}
        for parameter in data_list:
            dummy_list = parameter.split(" = ")
            return_dict[dummy_list[0]] = str(dummy_list[-1])

        return return_dict

#   Helper Methods
# -----------------------------------------------------------

    def _list_name_check(self, name):
        """Helper that raises errors if the cfg_list name is not in the catalogs"""

        joined_catalog = self.smu.source.config_list.catalog() + self.smu.measure.config_list.catalog()

        if not isinstance(name, str):
            raise ValueError(f"List name {name} of type {type(name)} is not of type str.")

        if name not in joined_catalog:
            raise ValueError(f"List of name {name} does not exist in Source or Measure. Possible Lists are:\n"
                             f"Source: {self.smu.source.config_list.catalog()}\n"
                             f"Measure: {self.smu.measure.config_list.catalog()}")
        elif name not in self.catalog():
            raise ValueError(f"List named '{name}' does not exist in the class {self.__class__.__name__}.\n"
                             f"Possible lists are: {self.catalog()}")

    def _list_index_check(self, name, index):
        """Helper that raises errors if the index is out of bounds for the config list"""

        if not isinstance(index, int):
            raise ValueError(f"Index {index} of type {type(index)} is not an integer.")

        size = self.get_size(name)
        if size == 0:
            raise ValueError(f"Bad index {index} for list '{name}', list is empty.")
        if not (1 <= index <= size):
            raise ValueError(f"Bad index {index} for list '{name}', should be between 1 and {size}.")

    # def _source_or_sense_check(self, source_or_sense=None):
    #     """Helper that checks the source or sense parameter, or defaults to the classes selection"""
    #
    #     if source_or_sense is None:
    #         source_or_sense = self.source_or_sense
    #     if source_or_sense not in ["SOUR", "SENS"]:
    #         raise ValueError(f"Bad source_or_sense {source_or_sense}. Should be one of: None, 'SOUR', or 'SENS'")
    #     return source_or_sense

    def _recall_helper(self, name, index):

        """Helper to recall the settings stored in a configuration index in a measure config list."""
        # :SOURce[1]:CONFiguration:LIST:RECall "<name>"
        # :SOURce[1]:CONFiguration:LIST:RECall "<name>", <index>
        # [:SENSe[1]]:CONFiguration:LIST:RECall "<name>"
        # [:SENSe[1]]:CONFiguration:LIST:RECall "<name>", <index>

        self._list_name_check(name)
        self._list_index_check(name, index)
        command = f':{self.source_or_sense}:CONF:LIST:REC "{name}", {index}'
        return command

# -----------------------------------------------------------

class ConfigListMeasure(ConfigListABC):
    """
    Class for controlling the creation, editing, and recall of ConfigLists where each index stores a set of **Measure**
    configuration settings.
    """

    def __init__(self, smu):
        super().__init__(smu, 'SENS')


class ConfigListSource(ConfigListABC):
    """
    Class for controlling the creation, editing, and recall of ConfigLists where each index stores a set of **Source**
    configuration settings.

    Also, provides method recall_src_and_meas for coordinated recall of Source and Measure settings from their
    respective ConfigLists.
    """

    def __init__(self, smu):
        super().__init__(smu, 'SOUR')

    def recall_src_and_meas(self, src_list, src_index, meas_list, meas_index=None):
        """
        Recall source settings and measurement settings from their respective config lists in a coordinated fashion
        that properly handles the dependencies between source and measurement settings.

        :param src_list: The name of a source config list.
        :type src_list: str
        :param src_index: The index in the source config list from which Source settings are to be recalled.
        :type src_index: int
        :param meas_list:  The name of a measure configuration list.
        :type meas_list: str
        :param meas_index: The index in the measure config list from which Measure settings are to be recalled. If None,
            src_index is used to retrieve from meas_list. This will raise exception if src_index is outside the size of
            meas_list.
        :type meas_index: int|None
        """

        # :SOURce[1]:CONFiguration:LIST:RECall "<name>", <index>, "<measureListName>"
        # :SOURce[1]:CONFiguration:LIST:RECall? "<name>", <index>, "<measureListName>", <measureIndex>
        # command = f'{source_or_sense}:CONF:LIST:REC "{name}", {index}'

        # the normal helper takes care of the source list/index checks
        command = self._recall_helper(src_list, src_index)

        # Check measure list name.
        self.smu.measure.config_list._list_name_check(meas_list)  # check the meas_list against the catalog of meas

        # Check  measure list index.
        if meas_index is None:
            meas_index = src_index
        self.smu.measure.config_list._list_index_check(meas_list, meas_index)

        # if all has gone well thus far then we can add the commands on and write to the instrument.
        command += f', "{meas_list}", {meas_index}'
        self.write(command)
        self.log_inst_errors()
