# -----------------------------------------------------------
#                       INCLUDES
# -----------------------------------------------------------
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC
from cl_instr_lib.base_classes.SMUs.smu2460_components.config_list import ConfigListSource
from cl_instr_lib.base_classes.SMUs.smu2460_components.sweep import Sweep

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.find_range import find_range_below
from enum import Enum
from collections import namedtuple
from math import isclose
# -----------------------------------------------------------
#                         NOTES
# -----------------------------------------------------------

min_max_units = namedtuple('min_max_units', ['min', 'max', 'units'])
# -----------------------------------------------------------
#                         SOURCE
# -----------------------------------------------------------

ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])


class Source(PSChannel_ABC):
    """
    Class for controlling the Source sub-system of the Keithley 2460 SMU.

    The following attributes contain objects that correspond to sub-systems of the Source functionality.
    """

    enum_function_mode = Enum("enum_meas_functions", {'CURR': 'CURR', 'VOLT': 'VOLT'})
    enum_output_off_mode = Enum('enum_output_off_mode', {
        'HIMP': 'HIMP',
        'NORM': 'NORM',
        'ZERO': 'ZERO',
        'GUAR': 'GUAR'
    })

    def __init__(self, smu):

        # Just adding for compatibility with previous power supply implementations.
        programming_bounds = [smu.voltage_bounds.min, smu.voltage_bounds.max, smu.current_bounds.min,
                              smu.current_bounds.max]

        super().__init__(power_supply=smu, channel_name='source', programming_bounds=programming_bounds)
        self.smu = smu
        self.write = smu.write
        self.query = smu.query
        self.on_off = smu.on_off
        self.log_inst_errors = smu.log_inst_errors
        self.log = smu.log
        self.warning = smu.log.warning

        #: Object containing the `Sweep`_ methods.
        self.sweep = Sweep(self.smu, self)

        #: Object containing the methods for the `ConfigListSource`_ functionality.
        self.config_list = ConfigListSource(self.smu)

        self.voltage_ranges = ['AUTO', 0.2, 2.0, 7.0, 10.0, 20.0, 100.0]
        self.current_ranges = ['AUTO', 1e-6, 10e-6, 100e-6, 1e-3, 10e-3, 100e-3, 1.0, 4.0, 5.0, 7.0]
        self.ovp_values = [2, 5, 10, 20, 40, 60, 80]

    def function(self, mode=None):
        """
        Query or select the operating mode of the source: 'VOLT' or 'CURR'.

        NOTE: Regardless of the output_state ('ON' or OFF), calling this method, will cause a transition to the IDLE
        state, even if the call only performs a query operation. Furthermore,  attempting to change the mode while the
        output_state is ON will raise an exception.

        :param mode: Sets the source to the specified mode: 'VOLT' or 'CURR'.
        :type mode: str|enum_function_mode
        :return: If mode=None instrument is queried and present setting is returned as a dict.
        :rtype: dict | None
        """

        # Like selecting the column from the FUnction Menu.
        # :SOURce[1]:FUNCtion[:MODE] <function>

        present_mode = self.query(':SOUR:FUNC', self.enum_function_mode)

        if mode is None:
            return_values = {}
            return_values.update(mode=present_mode.name)
            return return_values

        mode = check_enum_str('mode', mode, self.enum_function_mode)

        if self.output_state() == 'ON':
            if mode.name != present_mode.name:
                raise ValueError(f"Cannot change source mode from '{present_mode.name}' to '{mode.name}' while output "
                                 f"is 'ON'. Use source.output_state('OFF') to turn output OFF first.")
        else:
            self.write(':SOUR:FUNC', mode.name)

        self.log_inst_errors()

    def source_voltage(self, voltage=None, current_limit=None, forcing_range=None):
        """
        Queries or sets **voltage** source parameters.

        These parameters correspond to the values displayed on the three buttons across the bottom of HOME screen
        SOURCE V section.

        This API mimics that used in drivers for various power supplies to allow for using the SMU in place of a
        supply.

        Calling this method with a parameter value will change the source to VOLT mode provided the output_state is OFF.
        If the source is in current mode and output_state is ON, an exception is raised and no voltage parameters are
        programmed.

        Setting a parameter value while the output_state is ON also sends a MEAS command to update the large displays in
        the HOME screen of the SMU. The measurement is sent to the scratch buffer to avoid over-writing any contents of
        any default or user defined buffers.

        :param voltage: The voltage to source in Volts.
        :type voltage: float
        :param current_limit: The output current compliance limit in Amps. If the load impedance decreases,
            the current flowing through the load will not exceed this value.
        :type current_limit: float
        :param forcing_range: One of 'AUTO', 0.2, 2.0, 7.0, 10.0, 20.0, 100.0. Values are Volts.
        :type forcing_range: str | float
        :return: If all input parameters are None, dict of present settings. Otherwise None.
        :rtype: dict | None
        """

        # :SOURce[1]:VOLTage[:LEVel][:IMMediate][:AMPLitude] <value>
        # :SOURce[1]:VOLTage:ILIMit[:LEVel] <value>
        # :SOURce[1]:<function>:RANGe <value>
        # :SOURce[1]:VOLTage:RANGe:AUTO <state>

        if all([x is None for x in (voltage, current_limit, forcing_range)]):
            return_values = {}
            return_values.update(voltage=self.query(':SOUR:VOLT', float))
            return_values.update(current_limit=self.query(':SOUR:VOLT:ILIMit', float))
            is_auto = self.query(':SOUR:VOLT:RANG:AUTO', bool)
            if is_auto:
                return_values.update(forcing_range='AUTO')
            else:
                return_values.update(forcing_range=self.query(':SOUR:VOLT:RANG', float))
            return return_values

        if voltage is not None:
            ovp_limit = self.ovp_value()
            if abs(voltage) >= self.ovp_value():
                self.log.warn(f"Bad voltage {voltage} V, will trip OVP limit which is set to {ovp_limit} V.")

        if forcing_range is not None:
            range_list = self.voltage_ranges
            if forcing_range not in range_list:
                raise ValueError(f'Bad forcing range {forcing_range}, should be one of {range_list} V.')

        # TODO: Need more checking that voltage, current, range combo is legal. Order of writes must avoid errors.

        # Set to voltage souring mode.
        self.function('VOLT')  # Will raise exception if in CURR mode and output_state is ON.

        if current_limit is not None:
            self.write(':SOUR:VOLT:ILIMit', current_limit)

        if forcing_range is not None:
            if forcing_range == 'AUTO':
                self.write(':SOUR:VOLT:RANG:AUTO', 1)
            else:
                self.write(':SOUR:VOLT:RANG', forcing_range)
                self.write(':SOUR:VOLT:RANG:AUTO', 0)

        if voltage is not None:
            self.write(':SOUR:VOLT', voltage)

        # MEAS to update HOME screen display values, as users would expect a power supply to do.
        # Scratch Buffer is used to avoid overwriting the default defbuffer1 which may have user data.
        if self.smu.source.output_state() == 'ON':
            self.query('MEAS', target='"scratch"')

        self.log_inst_errors()  # This will show out-of-range errors.

    def source_current(self, current=None, voltage_limit=None, forcing_range=None):
        """
        Queries or sets **current** source parameters.

        These parameters correspond to the values displayed on the three buttons across the bottom of HOME screen
        SOURCE I section.

        Calling this method with a parameter value will change the source to CURR mode provided the output_state is OFF.
        If the source is in voltage mode and output_state is ON, an exception is raised and no current parameters are
        programmed.

        Setting a parameter value while the output_state is ON also sends a MEAS command to update the large displays in
        the Home screen of the SMU. The measurement is sent to a scratch buffer to avoid over-writing any contents of
        any default or user defined buffers.

        :param current: The current to source in Amps.
        :type current: float
        :param voltage_limit: The output voltage compliance limit in Volts. If the load impedance increases, the voltage
            across it will not exceed this value.
        :type voltage_limit: float
        :param forcing_range: One of 'AUTO', 1e-6, 10e-6, 100e-6, 1e-3, 10e-3, 100e-3, 1.0, 4.0, 5. 0, 7.0. Values
            are Amps.
        :type forcing_range: str | float
        :return: If all input parameters are None, dict of present settings. Otherwise None.
        :rtype: dict | None
        """

        # :SOURce[1]:CURRent:LEVel][:IMMediate][:AMPLitude] <value>
        # :SOURce[1]:CURRent:VLIMit[:LEVel] <value>
        # :SOURce[1]:<function>:RANGe
        # :SOURce[1]:CURRent:RANGe:AUTO <state>

        if all([x is None for x in (current, voltage_limit, forcing_range)]):
            return_values = {}
            return_values.update(current=self.query(':SOUR:CURR:LEV:IMM:AMPL', float))
            return_values.update(voltage_limit=self.query(':SOUR:CURR:VLIM:LEV', float))
            is_auto = self.query(':SOUR:CURR:RANG:AUTO', bool)
            if is_auto:
                return_values.update(forcing_range='AUTO')
            else:
                return_values.update(forcing_range=self.query(':SOUR:CURR:RANG', float))
            return return_values

        if forcing_range is not None:
            range_list = self.current_ranges
            if forcing_range not in range_list:
                raise ValueError(f'Bad forcing range {forcing_range}, should be one of {range_list} A.')

        # TODO: Need more checking that voltage, current, range combo is legal. Order of writes must avoid errors.

        # Set to current souring mode.
        self.function('CURR')  # Will raise exception if in VOLT mode and output_state is ON.

        if voltage_limit is not None:
            self.write(':SOUR:CURR:VLIM:LEV', voltage_limit)

        if forcing_range is not None:
            self.write(':SOUR:CURR:RANG', forcing_range)

        if current is not None:
            self.write(':SOUR:CURR:LEV:IMM:AMPL', current)
            ovp_limit = self.ovp_value()
            if self.ovp_tripped():  # Even when the OVP light comes on, the ovp_value query returns False.
                # So this code never runs. Instrument bug?
                self.log.warn(f"Requested current {current} A, has tripped the OVP limit which is {ovp_limit} V.")

        # MEAS to update HOME screen display values, as users would expect a power supply to do.
        # Scratch Buffer is used to avoid overwriting the default defbuffer1 which may have user data.
        if self.smu.source.output_state() == 'ON':
            self.query('MEAS', target='"scratch"')

        self.log_inst_errors()  # This will show out-of-range errors.

    def measure_voltage(self):
        """Provides API that mimics that of power supply drivers for measuring output voltage.

        NOTE: Changes the measurement function and units to 'VOLT', 'VOLT'.

        :return: The measured output voltage in Volts DC.
        :rrtype: float

        """

        self.smu.measure.function('VOLT', 'VOLT')
        return self.smu.measure.get_measurement(buffer_name='scratch')

    def measure_current(self):
        """Provides API that mimics that of power supply drivers for measuring output current.

        NOTE: Changes the measurement function and units to 'CURR' and 'AMP'

        :return: The measured output current in Amps DC.
        :rrtype: float

        """
        self.smu.measure.function('CURR', 'AMP')
        return self.smu.measure.get_measurement(buffer_name='scratch')

    def measure_power(self):
        """Provides API that mimics that of some power supply drivers for measuring output power.

        NOTE: Changes the measurement function to the opposite of the source mode and changes measurement units to WATT.

        :return: The measured output power in Watts..
        :rrtype: float

        """
        if self.function()['mode'] == 'VOLT':
            self.smu.measure.function('CURR', 'WATT')
        else:
            self.smu.measure.function('VOLT', 'WATT')

        return self.smu.measure.get_measurement(buffer_name='scratch')

    def source_limit_tripped(self):
        """
        Returns True if the source_limit (the compliance) limit for the present operating mode of the source was
        reached. Note that the trip state is not sticky, it resets if the load conditions or the limit is changed
        such that the source is no longer in a compliance limited state.

        :return: True if output voltage or current is being limited by the compliance limit.
        :rtype: bool
        """
        # :SOURce[1]:FUNCtion[:MODE]?
        # :SOURce[1]:CURRent:VLIMit[:LEVel]:TRIPped?
        # :SOURce[1]:VOLTage:ILIMit[:LEVel]:TRIPped?

        mode = self.function()['mode']

        if mode == 'VOLT':
            cmd = ':SOUR:VOLT:ILIM:LEV:TRIP'
        else:
            cmd = ':SOUR:CURR:VLIM:LEV:TRIP'
        return self.query(cmd, bool)

    def settings(self, output_off_mode=None, high_cap=None, readback=None, source_delay=None, interlock=None):
        """
        Queries or sets parameters that customize source behavior.

        Applies to whichever source mode ('VOLT' or 'CURR') is presently in effect.

        Use source.function() to set mode, or use source.source_voltage() or source.source_current() to set mode and
        value, limits and range of the source. Use method source.ovp_value to set over voltage protection level.

        :param output_off_mode: Determines the characteristics of the output terminals when the source is OFF.

            * NORMAL -
                - The measurement sense is set to 2-wire
                - The voltage source is selected and set to 0 V
                - The current limit is set to 10% of the full scale of the present measurement function
                  autorange value
                - If source readback is off, Output Off is displayed in the home screen Source area
                - If source readback is on, the actual measurement is displayed in the home screen Source area
                - If measurement is set to resistance, dashes (--.----) are shown in the home screen Source area
                - The Source button on the home screen shows the value that will be sourced when the output is
                  turned on again.
            * HIMP -
                - The measurement sense is set to 2-wire
                - The output relay opens, disconnecting the instrument as a load
            * ZERO -
                - The measurement sense is changed to 2-wire
                - The voltage source is selected and set to 0 V
                - The range is set to the presently selected range (turn off autorange)
                - If the source is voltage, the current limit is not changed
                - If the source is current, the current limit is set to the programmed source current value or to 10%
                  full scale of the present current range, whichever is greater
            * GUARD -
                - The measurement sense is changed to 2-wire
                - The current source is selected and set to 0 A if the source is set to current (amps); otherwise, the
                  output remains a voltage source when the output is turned off
                - The voltage limit is set to 10% full scale of the present voltage range
        :type output_off_mode: str | enum_output_off_mode
        :param high_cap: Accepts any of 'ON", 'OFF' , 1, 0, True, False. Returns 'ON'.

            * 'ON' - When measuring low current with a capacitive load, this can minimize overshoot,
              ringing and instability issues.
        :type high_cap: str|int|bool
        :param readback: Accepts any of 'ON", 'OFF' , 1, 0, True, False. Returns 'ON'.

            * 'OFF' - The programmed source setting is displayed and recorded. Faster measurements, less accurate.
            * 'ON' - Actual source value is measured and recorded along with measurement. Slower but more accurate.
        :type readback: str|int|bool
        :param source_delay: The delay in seconds between source turn on or changing value and performing the
                measurement. 0 to 10,000 seconds or 'AUTO'.  'AUTO' selects delay value based on range.
        :type source_delay: str|int|float
        :param interlock: Determines what is allowed when safety interlock signal (rear panel) is NOT asserted.

            * 'OFF' -  Output voltage is limited to less than +/- 42V.
            * 'ON' - Source output cannot be turned on for any value of source voltage.
        :type interlock: str|int|bool
        :return: If all inputs parameter are None, dict of present settings. Otherwise None.
        :rtype: dict | None
        """

        # :OUTPut[1]:<function>:SMODe    # HIGHZ, NORM, ZERO, GUARD
        # :SOURce[1]:<function>:HIGH:CAPacitance <state>   # ON, OFF
        # :SOURce[1]:<function>:READ:BACK <state>  # ON, OFF
        # :SOURce[1]:<function>:DELay <value>
        # :SOURce[1]:<function>:DELay:AUTO <state>
        # :OUTPut[1]:INTerlock:STATe

        mode = self.function()['mode']
        if all([x is None for x in (output_off_mode, high_cap, readback, source_delay, interlock)]):
            return_values = {}
            return_values.update(output_off_state=self.query(f':OUTP:{mode}:SMOD', self.enum_output_off_mode).name)
            return_values.update(high_cap=self.on_off.to_api(self.query(f':SOUR:{mode}:HIGH:CAP')))
            return_values.update(readback=self.on_off.to_api(self.query(f':SOUR:{mode}:READ:BACK')))

            is_auto = self.query(f':SOUR:{mode}:DEL:AUTO', bool)
            if is_auto:
                return_values.update(source_delay='AUTO')
            else:
                return_values.update(source_delay=self.query(f':SOUR:{mode}:DEL', float))

            return_values.update(interlock=self.on_off.to_api(self.query(':OUTP:INT:STAT')))
            return return_values

        # None is passed through check_enum_str().
        output_off_mode = check_enum_str('output_off_mode', output_off_mode, self.enum_output_off_mode)

        # None is passed through on_off.to_inst()
        high_cap = self.on_off.to_inst(high_cap)
        readback = self.on_off.to_inst(readback)

        if source_delay is not None:
            if not(isinstance(source_delay, str) and source_delay == 'AUTO' or
                    isinstance(source_delay, (int, float)) and (0 <= source_delay <= 10000)):
                raise ValueError(f'Bad source delay {source_delay}, input value between 0 and 10,000 sec (or AUTO)')

        interlock = self.on_off.to_inst(interlock)

        if output_off_mode is not None:
            self.write(f':OUTP:{mode}:SMOD', output_off_mode.value)

        if high_cap is not None:
            self.write(f':SOUR:{mode}:HIGH:CAP', high_cap)

        if readback is not None:
            self.write(f':SOUR:{mode}:READ:BACK', readback)

        if source_delay is not None:
            if source_delay == 'AUTO':
                self.write(f':SOUR:{mode}:DEL:AUTO', 1)
            else:
                self.write(f':SOUR:{mode}:DEL', source_delay)
                self.write(f':SOUR:{mode}:DEL:AUTO', 0)

        if interlock is not None:
            self.write(':OUTP:INT:STAT', interlock)

        self.log_inst_errors()

    def ovp_value(self, vlimit=None):
        """
        Queries or sets over the voltage protection limit for the present sourcing function ('CURR' or 'VOLT').

        For consistency with API of other power supply drivers, this method is not part of the settings method and it
        takes a float volue rather than the discrete OVP levels of the SMU.

        :param vlimit: Desired voltage limit value in volts. SMU has discrete OVP levels, so if requested
            vlimit is between two of those discrete levels, the lower level is chosen in the interest of protecting the
            DUT. If vlimit is less than the lowest available setting, an exception will be raised. If vlimit is above
            the maximum available setting, a warning is issued and the protection level is set to NONE. This means the
            output voltage can go to the maximum the SMU is capable of generating.
        :type vlimit: float
        :return: Protection level value within the voltage limit list, or 'NONE'.
        :rtype: float|str
        """

        # :SOURce[1]:VOLTage:PROTection[:LEVel] <n> # 'PROT2', 'PROT5' ,'PROT10', 'PROT20', 'PROT40' ,'PROT60',
        #   'PROT80', 'NONE'

        if vlimit is None:
            temp = self.query('SOUR:VOLT:PROT:LEV', str)
            if temp == 'NONE':
                return self.smu.voltage_bounds.max    # The max the SMU is capable of.
            return float(temp.replace('PROT', ''))

        # Find largest setting that is equal to or smaller than the user input. But what is equal to for a float?
        rel_tol = 0.005
        write_val = find_range_below(vlimit, self.ovp_values, rel_tol=rel_tol)

        # Handle extreme cases.
        if isclose(write_val, vlimit, rel_tol=rel_tol):
            val_str = f"PROT{write_val}"
        else:
            if vlimit < write_val:
                raise ValueError(f"Requested vlimit {vlimit}V less than lowest value ovp limitavailable {write_val}V. ")
            if vlimit > max(self.ovp_values):
                self.log.warn(f"Requested vlimit {vlimit}V greater than maximum ovp limit available "
                              f"{max(self.ovp_values)} V. Instead setting to 'None'.")
                val_str = 'NONE'
            else:
                self.log.warn(f"Requested vlimit {vlimit}V not available, instead setting to {write_val}V. "
                              f"Available choices are: {self.ovp_values}.")
                val_str = f"PROT{write_val}"

        self.write(':SOUR:VOLT:PROT', f'{val_str}')

        self.log_inst_errors()

    def ovp_state(self, on_off=None):
        """
        Queries OVP PROT value and returns 'OFF' if OVP is disabled, returns 'ON' if OVP is set to a voltage value.

        This method is provided for some degress of consistency with other power supply drivers. However, SMU does not
        have an OVP  on/off SCPI cmd that is separate from setting the level as those supplies do.

        Consequently, this method can only be used to set OVP to 'OFF', but will raise exception if you attempt to set
        it to 'ON'. To enable OVP, use <smu>.source.ovp_value and select a voltage value.

        :param on_off: If None, OVP PROT value is read and if 'NONE' is
        """

        # :SOURce[1]:VOLTage:PROTection[:LEVel] <n>

        if on_off is None:
            temp = self.query(':SOUR:VOLT:PROT', str)
            if temp == 'NONE':
                return 'OFF'
            else:
                return 'ON'

        self.on_off.to_inst(on_off)  # This will raise if not a valid on_off value.

        # We can turn OVP off on SMU
        if on_off in self.on_off.api_off_values:
            self.write(':SOUR:VOLT:PROT', 'NONE')
            self.log.warn('You have turned SMU OVP off using ovp_state(), you must use ovp_value to set a value to '
                          'turn it on.')
            return

        # But SMU doesn't have a command to turn it on without setting the value.
        raise ValueError('To turn OVP state ON, you must select a value using <smu>.source.ovp_value().')

    def ovp_tripped(self):
        """
        Returns True if the OVP is active and limiting the output voltage to the OVP value (OVP indicator is lit on
        front panel.)

        Note: The return value is as described when source function is 'VOLT' and the source value is set above
        the OVP value. However, False is always returned when source function is 'CURR' even when the voltage drop
        across the load exceeds the OVP value, which does light the OVP indicator. Instrument bug?

        :return:  True if output voltage is exceeding OVP value in voltage sourcing mode. Otherwise False.
        :rtype: bool
        """

        # :SOURce[1]:VOLTage:PROTection[:LEVel]:TRIPped?

        # NOTE: In current forcing mode, if the load voltage exceeds the OVP value, the current is gets clamped and the
        # OVP light comes on. But this command returns False! There is no command in the ref manual like:
        # :SOURce[1]:CURRent:PROTection[:LEVel]:TRIPped?. Trying that cause timeout. Instrument bug?

        return self.query(':SOUR:VOLT:PROT:TRIP', bool)

    def output_state(self, on_off=None):
        """Queries or sets the power supply output state: 'OFF' or 'ON'.

        Note that if setting the output to the 'ON' state, a throw-away measurement is made (to the scratch buffer)
        to force a screen update.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """

        # :OUTPut[1][:STATe]

        if on_off is None:
            return self.on_off.to_api(self.query('OUTP', int))  # Supply will return 0 for off, 1 for on.

        self.write('OUTP', self.on_off.to_inst(on_off))  # Works because supply can use 0 for OFF, 1 for ON.

        if on_off in self.on_off.api_on_values():
            # MEAS to update HOME screen display values, as users would expect a power supply to do.
            # Scratch Buffer is used to avoid overwriting the default defbuffer1 which may have user data.
            self.query('MEAS', target='"scratch"')

        self.log_inst_errors()

    # def user_delays(self, delay_id, seconds):
    #     # :SOURce[1]:<function>:DELay:USER<n>
    #     pass
# -----------------------------------------------------------
