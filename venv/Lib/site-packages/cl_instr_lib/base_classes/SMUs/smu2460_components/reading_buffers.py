# -----------------------------------------------------------
#                       INCLUDES
# -----------------------------------------------------------
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from enum import Enum
from collections import namedtuple
import re
# -----------------------------------------------------------
#                         NOTES
# -----------------------------------------------------------

min_max_units = namedtuple('min_max_units', ['min', 'max', 'units'])
shortname_type = namedtuple('shortname_type', ['shortname', 'type'])

# -----------------------------------------------------------
#                 READING BUFFERS
# -----------------------------------------------------------


class ReadingBuffers:
    """
    Provides methods for creating, configuring, deleting, clearing, saving, and retrieving data from measurement
    Reading Buffers in the SMU.
    """

    element_names_types = {
        'DATE': shortname_type('DATE', str),
        'FORMATTED': shortname_type('FORM', str),
        'FRACTIONAL': shortname_type('FRAC', float),
        'READING': shortname_type('READ', float),
        'RELATIVE': shortname_type('REL', float),
        'SECONDS': shortname_type('SEC', int),
        'SOURCE': shortname_type('SOUR', float),
        'SOURFORMATTED': shortname_type('SOURFORM', str),
        'SOURSTATUS': shortname_type('SOURSTAT', int),
        'SOURUNIT': shortname_type('SOURUNIT', str),
        'STATUS': shortname_type('STAT', int),
        'TIME': shortname_type('TIME', str),
        'TSTAMP': shortname_type('TST', str),
        'UNIT': shortname_type('UNIT', str)
    }

    enum_element_names = Enum("enum_element_names",
                              {'DATE': "DATE", 'FORMATTED': "FORM", 'FRACTIONAL': "FRAC", 'READING': "READ",
                               'RELATIVE': "REL", 'SECONDS': "SEC", 'SOURCE': "SOUR", 'SOURFORMATTED': "SOURFORM",
                               'SOURSTATUS': "SOURSTAT", 'SOURUNIT': "SOURUNIT", 'STATUS': "STAT", 'TIME': "TIME",
                               'TSTAMP': "TST", 'UNIT': "UNIT"}
                              )

    enum_time_format = Enum("enum_time_format",
                            {'ALL': 'ALL', 'FORMAT': 'FORM', 'RELATIVE': 'REL', 'RAW': 'RAW',
                             'STAMP': 'STAM', 'STANDARD': 'STAN', 'BRIEF': 'BRIEF', 'EXTRA': 'EXTR'})

    enum_write_or_append = Enum("enum_write_or_append", {'WRITE': '', "APPEND": ":APP"})

    def __init__(self, smu):
        self.smu = smu
        self.write = smu.write
        self.query = smu.query
        self.on_off = smu.on_off
        self.log_inst_errors = smu.log_inst_errors
        self.log = smu.log
        self.get_instrument_errors = smu.get_inst_errors
        self.source = smu.source

        self.enum_make_style = Enum('enum_make_style', {
            'COMPACT': 'COMP',
            'STANDARD': 'STAN',
            'FULL': 'FULL'
        })
        self.enum_fill_mode = Enum('enum_fill_mode', {
            'CONTINUOUS': 'CONT',
            'ONCE': 'ONCE'
        })

        # Create string of all element names, space separated.
        tmp = ''
        for key in self.element_names_types.keys():
            tmp += ' ' + key
        self.element_names_all = tmp.lstrip(' ')

    def make_buffer(self, buffer_name, capacity=100000, style='STANDARD', fill_mode=None, log_events=None):
        """
        Create a user defined buffer to store measurement readings.

        :param buffer_name: Cannot be one of built-in default buffers: "defbuffer1" or "defbuffer2". If buffer of same
            name already exists, the existing buffer will be deleted, a new buffer created and a warning log message
            is generated. If Popups in the Event Log Settings of the SMU are enabled, an error dialog will appear on
            the SMU screen.
        :type buffer_name: str
        :param capacity: Number of readings buffer can hold or 'MAX'. Minimum of 10. 'MAX' will create the largest
            buffer possible based on available memory. Can be changed later using config method.
        :type capacity: int|str
        :param style: Type of reading buffer to create (once created cannot be changed):

            * COMPACT - reading stored with reduced accuracy (6.5 digits), 1us accurate timestamp.
            * STANDARD - Full accuracy with formatting.
            * FULL - Same as STANDARD, plus additional info.
        :type style: str | enum_make_style
        :param fill_mode: Determines what happens to additional reading once capacity is reached. Can be changed later
            using config method.

            * ONCE - No existing data is overwritten, new readings get discarded.
            * CONTINUOUS -  Oldest existing data is overwritten by new data. Circular buffer behavior.
        :type fill_mode: str|enum_fill_mode
        :param log_events: If 'ON', an event is logged in the SMU Event log when the buffer is clear or reaches 100%
            full. Accepts any of the forms: 'ON', 1, '1', True, 'OFF', 0, '0', False. Always returns 'ON', 'OFF'.
        :type log_events: str|int|bool
        :return: None
        :rtype: None
        """
        # :TRACe:MAKE
        # :TRACe:FILL:MODE
        # :TRACe:LOG:STATe
        # :TRACe:POINts
        # :TRACe:MATH   # Didn't implement because there is no query form, would be very error prone.

        if buffer_name in ('defbuffer1', 'defbuffer2'):
            raise ValueError(f"Bad buffer name '{buffer_name}', cannot use the name of a default buffer.")

        if self.buffer_exists(buffer_name):
            self.log.warning(f"reading_buffers.make: Buffer_name '{buffer_name}' already exists, deleting and creating "
                             f"a new buffer.")
            self.delete_buffer(buffer_name)

        if capacity == 'MAX':
            capacity = 0  # Gives as much as available memory will allow.
        else:
            if not(isinstance(capacity, (int, float))):
                raise ValueError(f"Bad capacity must be 'MAX' or an integer value 10 or greater.")
            capacity = int(capacity)

        style = check_enum_str('style', style, self.enum_make_style)

        self.write(':TRACe:MAKE', f'"{buffer_name}", {capacity}, {style.value}')

        if any([x is not None for x in (fill_mode, log_events)]):
            self.config(buffer_name, fill_mode=fill_mode, log_events=log_events)

    def clear_data(self, buffer_name):
        """
        Clears all readings and statistics from the named buffer.

        :param buffer_name: Name of an existing reading buffer.
        :type buffer_name: str
        :return: None
        :rtype: None
        """

        # :TRACe:CLEar

        if type(buffer_name) is not str or not self.buffer_exists(buffer_name):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers.")

        self.write(':TRAC:CLE', target=f'"{buffer_name}"')
        self.log_inst_errors()

    def delete_buffer(self, buffer_name, force=False):
        """
        Deletes a user defined reading buffer.

        :param buffer_name: Name of an existing reading buffer.
        :type buffer_name: str
        :param force: Set to True to force deletion of scratch buffer. Defaults to False. NOTE: Deleting scratch buffer
            will interfere with the display updating when source values are changed.
        :type force: bool
        :return: None
        :rtype: None
        """

        # cannot delete defbuffer1 or defbuffer2
        # :TRACe:DELete

        if buffer_name in ('defbuffer1', 'defbuffer2'):
            raise ValueError(f"Bad buffer name '{buffer_name}', cannot use the name of a default buffer.")

        if buffer_name == 'scratch' and not force:
            raise ValueError(f"Attempt to delete scratch buffer. Would interfere with display updating when source "
                             f"values are changed. If you really want to do this, set force=True.")

        if type(buffer_name) is not str:
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers.")

        if not self.buffer_exists(buffer_name):
            self.log.warning(f"Attempt to delete buffer '{buffer_name}' which does not exist in SMU.")

        self.get_instrument_errors()
        self.write(':TRAC:DEL', target=f'"{buffer_name}"')
        self.get_instrument_errors()

    def config(self, buffer_name, capacity=None, fill_mode=None, log_events=None):
        """
        Query all or set any of modifiable parameters of an existing reading buffer.

        :param buffer_name: Name of an existing reading buffer.
        :type buffer_name: str
        :param capacity: Number of readings buffer can hold or 'MAX'. Minimum of 10. 'MAX' will create the largest
            buffer possible based on available memory. Can be changed later using config method.
        :type capacity: int|str
        :param fill_mode: Determines what happens to additional reading one capacity is reached. Can be changed later
            using config method.

            * ONCE - No existing data is overwritten, new readings get discarded.
            * CONTINUOUS -  Oldest existing data is overwritten by new data. Circular buffer behavior.
        :type fill_mode: str|enum_fill_mode
        :param log_events: If 'ON', an event is logged in the SMU Event log when the buffer is clear or reaches 100%
            full. Accepts any of the forms: 'ON', 1, '1', True, 'OFF', 0, '0', False. Always returns 'ON', 'OFF'.
        :type log_events: str|int|bool
        :return: Query returns dict of present settings. Setting any value return None.
        :rtype: dict|None
        """

        # :TRACe:POINts
        # :TRACe:FILL:MODE
        # :TRACe:LOG:STATe
        # :TRACe:MATH
        # If there is data in the buffer, you cannot change style, p12-124.

        if type(buffer_name) is not str or not self.buffer_exists(buffer_name):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers.")

        if all([x is None for x in (capacity, fill_mode, log_events)]):
            return_values = {}
            return_values.update(capacity=self.query(
                ':TRAC:POIN', int, target=f'"{buffer_name}"'))
            return_values.update(fill_mode=self.query(
                ':TRAC:FILL:MODE', self.enum_fill_mode, target=f'"{buffer_name}"').name)
            return_values.update(log_events=self.on_off.to_api(self.query(
                ':TRAC:LOG:STAT', int, target=f'"{buffer_name}"')))
            return return_values

        if capacity is not None:
            if capacity == 'MAX':
                capacity = 0  # Gives as much as available memory will allow.
            else:
                if not(isinstance(capacity, (int, float))):
                    raise ValueError(f"Bad capacity must be 'MAX' or an integer value.")
                capacity = int(capacity)

        fill_mode = check_enum_str('fill_mode', fill_mode, self.enum_fill_mode)

        log_events = self.on_off.to_inst(log_events)

        if capacity is not None:
            self.write(':TRAC:POIN', capacity, target=f'"{buffer_name}"')

        if fill_mode is not None:
            self.write(':TRAC:FILL:MODE', fill_mode.value, target=f'"{buffer_name}"')

        if log_events is not None:
            self.write(':TRAC:LOG:STAT', log_events, target=f'"{buffer_name}"')

        self.log_inst_errors()

    def save_to_usb_drive(self, filename, write_or_append, buffer_name="defbuffer1", time_format="ALL"):
        """
        Saves data from the specified reading buffer to a USB flash drive.

        **Note: If the file already exists and the append_or_write = "WRITE" then the file will be overwritten**

        :param filename: A string that indicates the name of the file on the USB flash drive in which to save the
            reading buffer. The file name must specify the full path (including /usb1/). If included, the file extension
            must be set to .csv. If no file extension is specified, .csv is added.
        :type filename: str
        :param write_or_append: A string that indicates if the operation will write or append to the selected file

            * WRITE - writes normally to the file named. If the file already exists, overwrite.
            * APPEND - appends a buffer to an existing file.
        :type write_or_append: str | enum_write_or_append
        :param buffer_name: A string that indicates the reading buffer, defaults to defbuffer1
        :type buffer_name: str
        :param time_format: Indicates how date and time information from the buffer is saved in the file on the
            USB flash drive; The values are:

            * ALL - all info; the default value
            * FORMAT -  Dates, times, and fractional seconds are saved
            * RELATIVE - relative timestamps saved
            * RAW - seconds and fractional seconds
            * STAMP - Time Stamps is saved, in addiion to
            * STANDARD - just Reading, Value, Relative Time
            * BRIEF - brief set of data: only Reading, Relative Time
            * EXTRA - just the buffer meta data (which is included in all other formats in the first 8 rows.)
        :type time_format: str | enum_time_format
        """
        # :TRACe:SAVE
        # :TRACE:SAVE:APPend

        if type(filename) is not str:
            raise ValueError(f"Bad filename {filename} of type {type(filename)}. Should be a string.")

        if type(buffer_name) is not str or self.buffer_exists(buffer_name) is False:
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers, or use"
                              f"defbuffer1 or defbuffer2.")

        time_format_obj = check_enum_str('time_format', time_format, self.enum_time_format)
        append_obj = check_enum_str('write_or_append', write_or_append, self.enum_write_or_append)

        if append_obj.name == 'WRITE':
            cmd_header = ':TRAC:SAVE'
        else:
            cmd_header = ':TRAC:SAVE:APP'

        self.write(f'{cmd_header} "{filename}", "{buffer_name}", {time_format_obj.value}')
        self.log_inst_errors()

    def get_num_readings(self, buffer_name):
        """
        Returns the number of readings the specified reading buffer.

        :param buffer_name: Name of an existing reading buffer.
        :type buffer_name: str
        :return: Number of readings.
        :rtype: int
        """

        # :TRACe:ACTual?

        if type(buffer_name) is not str or not self.buffer_exists(buffer_name):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers.")

        tmp = self.query(':TRAC:ACT', int, f'"{buffer_name}"')
        self.log_inst_errors()
        return tmp

    def get_start_end(self, buffer_name):
        """
        Returns the starting and ending indices of the readings in the specified reading buffer.

        :param buffer_name: Name of an existing reading buffer.
        :type buffer_name: str
        :return: Dict with keys 'start', 'end'. Values are int.
        :rtype: dict
        """

        # :TRACe:ACTual:END?
        # :TRACe:ACTual:STARt?

        if type(buffer_name) is not str or not self.buffer_exists(buffer_name):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers.")

        return_values = {}
        return_values.update(start=self.query(':TRAC:ACT:STAR', int, target=f'"{buffer_name}"'))
        return_values.update(end=self.query(':TRAC:ACT:END', int, target=f'"{buffer_name}"'))
        return return_values

    def get_data(self, buffer_name='defbuffer1', start=None, end=None, elements=None):
        """
        This command returns specified data elements from a specified reading buffer.

        :param buffer_name: Name of an existing reading buffer.
        :type buffer_name: str
        :param start: Index into the buffer where the first measurement result is to be obtained. Must be 1 or greater.
        :type start: int
        :param end:  Index into the buffer where the last measurement result is to be obtained. Must be >= start.
        :type end: int
        :param elements: A string that specifies the names of the data elements to be retrieved. Any combination,
            in any order, of the names shown here separated by spaces is allowed. Repeated names are allowed but the
            total number of names in elements must be 14 or less. Alternatively, elements is None has the same effect as
            specifying the single value READING; elements='ALL' has the same effect as specifying all of the names
            in the order shown here.

            * DATE - The date when the data point was measured.
            * FORMATTED - The measured value as it appears on the front pane.
            * FRACTIONAL - The fractional seconds for the data point when the data point was measured.
            * READING - The measurement reading based on the function setting. **Note: if no elements is None \
              are defined, only this element is returned.**
            * RELATIVE - The relative time when the data point was measured.
            * SECONDS - The seconds in UTC (Coordinated Universal Time) format when the data point was measured.
            * SOURCE - The source value; if readback is ON, then it is the readback value, otherwise it is the \
                programmed source value
            * SOURFORMATTED- The source value as it appears on the display.
            * SOURSTATUS - The status information associated with sourcing.
            * SOURUNIT - The unit of value associated with the source value.
            * STATUS - The status information associated with the measurement.
            * TIME - The time for the data point
            * TSTAMP - The timestamp for the data point
            * UNIT - The unit of measure associated with the measurement
        :type elements: Returns a list of measurement results. If *elements* specified a single value for each
            measurement, then each list element consists of that single value. If *elements* specified multiple
            values for each measurement, then each list entry consists of a list enclosing the multiple values. In
            either case, the value returned are casted to appropriate types as defined by the attribute
            element_names_types.
        :rtype: List[various] | List[List[various]]
        :rtype:

        """
        # :TRACe:DATA?
        self.get_instrument_errors()

        if not(isinstance(buffer_name, str) and self.buffer_exists(buffer_name)):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers, or use the "
                              f"built-in default buffers 'defbuffer1' or 'defbuffer2'.")

        # TODO: How to get data in time order from CONTINUOUS buffer that has wrapped.

        start_end_dict = self.get_start_end(buffer_name)

        if start is None and end is None:
            start = start_end_dict['start']
            end = start_end_dict['end']
        else:
            if start is None:
                start = 1
            if end is None:
                end = start_end_dict['end']

            if not (0 < start <= (start_end_dict['end'])):
                raise ValueError(f"Bad start index {start}. should be from 1 to {start_end_dict['end']}")
            if not (start <= end <= (start_end_dict['end'])):
                raise ValueError(f"Bad end index {end}. should be from {start} to {start_end_dict['end']}")

        data_format = self.query(':FORM')
        if data_format != 'ASC':
            self.log.warning(f"Non-ASCII data format '{data_format}', not supported, switching to ASCII format.")
            self.write(':FORM', 'ASC')

        if elements is None:
            elements = 'READING'
        elif elements == 'ALL':
            elements = self.element_names_all

        elements = re.sub(' +', ' ', elements).strip(' ')  # Prevents errors caused by extra spaces.
        elements_list = elements.split(' ')

        invalid = [index for index, value in enumerate(elements_list) if value not in self.element_names_types]
        if len(invalid) > 0:
            msg = ', '.join([f"'{elements_list[i]}'" for i in invalid])
            raise ValueError(f"Bad elements: {msg}.")

        response_str = self.query(':TRAC:DATA', pre_target_params=f"{start}, {end}", target=f'"{buffer_name}"',
                                  post_target_params=f'{",".join(elements_list)}')

        return_list = []
        response_list = response_str.split(',')
        num_elements = len(elements_list)
        for index in range(0, len(response_list), num_elements):
            formatted = self._response_casting(elements_list, response_list[index: index+num_elements])
            return_list.append(formatted)

        return return_list

    def _response_casting(self, elements_list, response_list):
        result_list = []

        flag_single = len(elements_list) == 1

        for i, name in enumerate(elements_list):
            _, rtn_type = self.element_names_types[name]
            result_list.append(rtn_type(response_list[i]))

        if flag_single:
            return result_list[0]
        else:
            return result_list

    def get_stats(self, buffer_name):
        """
        command that returns a variety of statistic on a reading buffer.

        Statistics returned are average, minimum, maximum, peak to peak, and standard deviation.

        :param buffer_name: Name of an existing buffer
        :type buffer_name: str
        :return: Dict of statistical values, keys are: ave, max, min, pk2pk, stddev.
        :rtype: dict
        """
        # :TRACe:STATistics:AVERage?
        # :TRACe:STATistics:MAXimum?
        # :TRACe:STATistics:MINimum?
        # :TRACe:STATistics:PK2Pk?
        # :TRACe:STATistics:STDDev?

        if type(buffer_name) is not str or not self.buffer_exists(buffer_name):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers.")

        return_values = {}
        return_values.update(ave=self.query(':TRAC:STAT:AVER', float, target=f'"{buffer_name}"'))
        return_values.update(max=self.query(':TRAC:STAT:MAX',  float, target=f'"{buffer_name}"'))
        return_values.update(min=self.query(':TRAC:STAT:MIN',  float, target=f'"{buffer_name}"'))
        return_values.update(pk2pk=self.query(':TRAC:STAT:PK2P', float, target=f'"{buffer_name}"'))
        return_values.update(stddev=self.query(':TRAC:STAT:STDD', float, target=f'"{buffer_name}"'))
        return return_values

    def stats_clear(self, buffer_name):
        """
        This command clears the statistical information associated with the specified buffer.

        :param buffer_name: Name of an existing buffer
        :type buffer_name: str
        """
        # :TRACe:STATistics:CLEar

        if type(buffer_name) is not str or not self.buffer_exists(buffer_name):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers.")

        self.write(':TRAC:STAT:CLE', target=f'"{buffer_name}"')
        self.log_inst_errors()

    def buffer_exists(self, buffer_name):
        """
        Checks the existence of a specified buffer

        :param buffer_name: Name of a buffer
        :type buffer_name: str
        :return: True or False on a buffers existence
        :rtype: bool
        """
        # NOTE: This may not be the best way to do this because if the buffer already exists, a dialog box pops up on
        # the instrument screen. There doesn't seem to be any programmatic way to suppress that.

        if buffer_name in ['defbuffer1', 'defbuffer2']:
            return True

        # No SCPI cmd to check existence, so try to create buffer and see if that causes an error.
        self.get_instrument_errors()
        self.write(':TRAC:MAKE', f'"{buffer_name}", 10')
        errors = self.get_instrument_errors()

        if len(errors) == 0:
            created = True   # We just created it, so no error means it did not previously exist.
        elif errors[0].startswith('1115'):
            created = False
        else:
            raise RuntimeError(f"{errors[0]}")

        if created:
            self.write(':TRAC:DEL', f'"{buffer_name}"')
            return False   # buffer did not previously exist, we created test case, now delete it.
        else:
            return True

    # def active(self, buffer_name=None):
    #     # :DISPlay:BUFFer:ACTive     # Gives bad header error on instrument, seems to be a bug!
    #     if buffer_name is None:
    #         return self.query(':DISP:BUFF:ACT')
    #
    #     self.write(':DISP:BUFF:ACT', f'"{buffer_name}"')
    #
    #     self.log_inst_errors()

# -----------------------------------------------------------
