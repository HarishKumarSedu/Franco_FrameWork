# -----------------------------------------------------------
#                       INCLUDES
# -----------------------------------------------------------
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_list_values import check_list_num
from enum import Enum
from collections import namedtuple
# -----------------------------------------------------------
#                         NOTES
# -----------------------------------------------------------

min_max_units = namedtuple('min_max_units', ['min', 'max', 'units'])


# -----------------------------------------------------------
#                         SWEEP
# -----------------------------------------------------------


class Sweep:
    """
    Class for defining trigger models for performing various types of source sweeps that step through a series of
    source values and takes a measurement at point of the sweep.

    .. attention:: Once the trigger model is installed using one of the methods provided here: **linear_by_points**,
        **linear_by_step_size**,  **log_by_points** or **by_list**; executing the sweep requires calling
        <smu_ref>.trigger.initiate(). After the sweep is executed, use <smu_ref>.reading_buffers.get_data() to retrieve
        the data.
    """

    enum_delay = Enum('enum_delay', {'NONE': 0, 'AUTO': -1})
    enum_range_type = Enum('enum_range_type', ['AUTO', 'BEST', 'FIXED'])

    def __init__(self, smu, source):
        self.smu = smu
        self.write = smu.write
        self.query = smu.query
        self.on_off = smu.on_off
        self.log_inst_errors = smu.log_inst_errors
        self.get_inst_errors = smu.get_inst_errors
        self.log = smu.log
        self.source = source

        self.enum_source_functions = source.enum_function_mode

    def custom_list(self, function, value_list=None):
        """
        Creates either a VoltCustomSweepList or a CurrCustomSweepList within the SMU that can be used with the
        **by_list** method to install a trigger model that will step through the list and perform a measurement at each
        source value.

        If there is an existing list for the value of *function*, it is replaced by the new list.

        When this method is called, the created CustomSweepList captures the present state of source settings.
        At the time the trigger model is initiated these source settings are then restored in the SMU and used to
        execute the sweep. Therefore, before creating the custom list, you must configure the source settings such as
        range, current/voltage limits etc. to be compatible with the values in the value_list and the applied load.

        :param function: 'VOLT' for creating VoltCustomSweepList or 'CURR' for creating CurrCustomSweepList.
        :type function: str | enum_source_functions
        :param value_list: A list of up to 2500 values. All values must be within +/-105% of the present range
            setting for the source function ('CURR' or 'VOLT'). If present range setting is 'AUTO', then values must
            be within the full voltage or current sourcing capability of the SMU.
        :type value_list: list[float]
        :return: If value_list=None, then the corresponding custom list is queried for its values which are returned.
        :rtype: List[float]
        """

        # :SOURce[1]:LIST:CURRent
        # :SOURce[1]: LIST:CURRent:APPend
        # :SOURce[1]:LIST:VOLTage
        # :SOURce[1]: LIST:VOLTage:APPend

        # Param type checking
        function_obj = check_enum_str("function", function, self.enum_source_functions)

        if value_list is None:  # read back
            returned_list_str = self.query(f"SOUR:LIST:{function_obj.value}")
            if len(returned_list_str) == 0:
                return []
            else:
                return [float(values) for values in returned_list_str.split(',')]

        if not isinstance(value_list, list):  # if the value list is not the correct type.
            raise ValueError(f"Bad value list of type: {type(value_list)}. Should be type list[float].")

        if len(value_list) > 2500:
            raise ValueError("Total values in list exceed the maximum list size of 2500")

        # Set boundary for list. Either VOLT or CURR from above enum check.
        # Determine present source range, note that result could be 'AUTO' or the numeric range value.
        if function_obj.name == 'VOLT':
            present_range = self.smu.source.source_voltage()['forcing_range']
        else:
            present_range = self.smu.source.source_current()['forcing_range']

        # Use the bounds if 'AUTO' bounds are already +/- 105%. Also gets us the units.
        l_range = {'VOLT': self.smu.voltage_bounds, 'CURR': self.smu.current_bounds}[function_obj.name]

        if present_range != 'AUTO':
            # Scale the range because each range can actually go to =/-105%.
            l_range = min_max_units(-1.05 * present_range, +1.05 * present_range, l_range.units)

        # Check using the helper function if all list parameters are in range & Error logging.
        check_list_num('value_list', value_list, l_range.min, l_range.max, l_range.units)

        chunk_size = 100
        for index in range(0, len(value_list), chunk_size):
            # create the comma separated list to send to the instrument
            list_str = ', '.join([f"{value}" for value in value_list[index: index+chunk_size]])
            if index == 0:
                # write to the instrument
                self.write(f"SOUR:LIST:{function_obj.name} ", list_str)
            else:
                self.write(f"SOUR:LIST:{function_obj.name}:APP ", list_str)

        # log errors
        self.log_inst_errors()

    def _check_sweep_params(self, function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name):
        """Helper function for checking input parameters common to the various sweep types."""

        function = check_enum_str('function', function, self.enum_source_functions)
        function = function.name

        if function == 'CURR':
            min_val, max_val, units = self.smu.current_bounds.min, self.smu.current_bounds.max, \
                                      self.smu.current_bounds.units
        elif function == 'VOLT':
            min_val, max_val, units = self.smu.voltage_bounds.min, self.smu.voltage_bounds.max, \
                self.smu.voltage_bounds.units
        else:
            # Some kind of programmer error, should never happen.
            raise RuntimeError(f"Unexpected name '{function}' from enum_function_mode.")

        if not(isinstance(start, (int, float)) and (min_val <= start <= max_val)):
            raise ValueError(f"Bad start {start}, should be {min_val} to {max_val} {units}.")

        if not(isinstance(stop, (int, float)) and (min_val <= stop <= max_val)):
            raise ValueError(f"Bad stop {stop}, should be {min_val} to {max_val} {units}.")

        if delay is None:
            raise ValueError(f"Delay cannot be None type, should be 50e-6 to 10e3 seconds, or 'AUTO' or 'NONE'.")

        if isinstance(delay, (int, float)):
            if not(50e-6 <= delay <= 10e3):
                raise ValueError(f"Bad delay {delay}, should be 50e-6 to 10e3 seconds, or 'AUTO' or 'NONE'.")
        else:
            delay_obj = check_enum_str('delay', delay, self.enum_delay)  # Will raise ValueError is not 'AUTO' or 'NONE'
            delay = delay_obj.value   # Gives the encoding the instrument uses.

        if count is None:
            raise ValueError(f"Bad count (None type), should be 1 to 268_435_455, or 'INF'.")
        if not((isinstance(count, int) and (1 <= count <= 268_435_455)) or count == 'INF'):
            raise ValueError(f"Bad count {count}, should be 1 to 268_435_455, or 'INF'.")
        if count == 'INF':
            count = 0

        if range_type is None:
            range_type = 'None'
        range_type = check_enum_str('range_type', range_type, self.enum_range_type)
        range_type = range_type.name

        abort_on_limit = self.on_off.to_inst(abort_on_limit)

        dual = self.on_off.to_inst(dual)

        # return modified values as a tuple
        return function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name

    def linear_by_points(self, function, num_points, start, stop,
                         delay='AUTO', count=1, range_type='BEST', abort_on_limit='ON', dual='OFF',
                         buffer_name='defbuffer1'):
        """
        Creates a trigger model within the instrument that performs a source sweep of current or voltage defined as a
        specified number of points linearly spaced between specified start and stop values. A measurement is made at
        each source point.

        To run the trigger model and execute the sweep and measurements, call <smu>.trigger.initiate(). The resulting
        data can be retrieved from the buffer specified using the <smu>.reading_buffers.get_data() method.

        :param function: The source function:

            * 'CURR' - sourcing current.
            * 'VOLT' - sourcing voltage.
        :type function: str | enum_source_functions
        :param num_points: Number of steps in the sweep, including the start and stop values. The resulting step size is
            (stop - start) / (num_points - 1).
        :type num_points: int
        :param start: First source value, included in num_points.
        :type start: float
        :param stop: Last source value, included in num_points.
        :type stop: float
        :param delay: Delay between measurement points. Can be 'NONE', 'AUTO' or a numeric value. When you specify a
            delay, a delay block is added to the sweep trigger model. This delay is added to any source delay you may
            have set.
        :type delay: str|enum_delay|int|float
        :param count: Number of times to run the sweep. Can be 1 to 268_435_455 or 'INF' which repeats until trigger
            model is aborted, see smu.trigger.abort().
        :type count: int|str
        :param range_type:  Source range used for the sweep:

            * 'AUTO' - Most sensitive source range for each source level in the sweep.
            * 'BEST' - Best fixed range.
            * 'FIXED' - present source range is use dfor entire sweep.
        :type range_type: str|enum_range_type
        :param abort_on_limit: 'ON' aborts sweep if source limit is exceeded. (Accepts any of the ON / OFF values.)
        :type abort_on_limit: str|int|bool
        :param dual: 'ON' - sweep runs from start to stop, then stop to start. 'OFF' - sweep from start to stop only.
        :type dual: str|int|bool
        :param buffer_name: Either of the default buffers (defbuffer1 or defbuffer2) or name of a user defined buffer.
        :type buffer_name: str
        :return: Dict of the input settings in a form that may be used with ** syntax as input to this method to
            reproduce the sweep trigger model.
        :rtype: dict
        """

        # This command is "command only" (no query).
        # Used for specifying fixed number of points, including the start and stop values.
        # :SOURce[1]:SWEep:<function>:LINear <start>, <stop>, <points>, <delay>, <count>, <rangeType>, <failAbort>,
        #   <dual>, "<bufferName>"

        # Save the actual inputs from the user API.
        inputs = locals()
        inputs.pop('self')

        # Validate number of points.
        if not(isinstance(num_points, int) and (2 <= num_points <= 268_435_455)):
            raise ValueError(f"Bad num_points {num_points}, should be 2 to 268_435_455.")

        # Validate all other parameters, translate to encoded values used by the instrument. e.g
        # delay='AUTO' becomes -1, count='INF' becomes 0.
        function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name =\
            self._check_sweep_params(function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name)

        cmd = f':SOUR:SWE:{function}:LIN {start}, {stop}, {num_points}, {delay}, {count}, {range_type}, '
        cmd += f'{abort_on_limit}, {dual}, "{buffer_name}"'

        # Could find no SCPI cmd to determine if buffer already exists, so clear any existing errors, then see if cmd
        # causes a new errors, possibly because buffer doesn't exist.
        self.get_inst_errors()
        self.write(cmd)
        errors = self.get_inst_errors()
        if len(errors) > 0:
            if errors[0].startswith('4909'):
                raise ValueError(f"Non-default buffer_name '{buffer_name}', does not exist. You must make the buffer "
                                 f"first using the method reading_buffers.make.")
            else:
                raise ValueError(f"{errors[0]}")

        step_size = (stop - start) / (num_points - 1)
        units = 'A' if function == "CURR" else 'V'

        self.log.info(f"Created trigger flow model for LINEAR sweep with {num_points} steps, "
                      f"{step_size:3G} {units} per step.\n"
                      f"Call trigger.initiate() to run the sweep. Retrieve data using reading_buffer.get_data("
                      f"'{buffer_name}'")

        # return dict of input args, user can save these use to replay.
        return inputs

    def linear_by_step_size(self, function, step_size, start, stop,
                            delay='AUTO', count=1, range_type='BEST', abort_on_limit='ON', dual='OFF',
                            buffer_name='defbuffer1'):
        """
        Creates a trigger model within the instrument that performs a source sweep of current or voltage defined as a
        fixed specified step_size between specified start and stop values. A measurement is made at each source point.

        To run the trigger model and execute the sweep and measurements, call <smu>.trigger.initiate().  The resulting
        data can be retrieved from the buffer specified using the <smu>.reading_buffers.get_data() method.

        :param function: The source function:

            * 'CURR' - sourcing current.
            * 'VOLT' - sourcing voltage.
        :type function: str | enum_source_functions
        :param step_size: The size of the steps taken between the start and stop value. The resulting number of points
            is [(stop - start) / step_size] + 1.
        :type step_size: float
        :param start: First source value, included in num_points.
        :type start: float
        :param stop: Last source value, included in num_points.
        :type stop: float
        :param delay: Delay between measurement points. Can be 'NONE', 'AUTO' or a numeric value. When you specify a
            delay, a delay block is added to the sweep trigger model. This delay is added to any source delay you may
            have set.
        :type delay: str|enum_delay|int|float
        :param count: Number of times to run the sweep. Can be 1 to 268_435_455 or 'INF' which repeats until trigger
            model is aborted, see smu.trigger.abort().
        :type count: int|str
        :param range_type:  Source range used for the sweep:

            * 'AUTO' - Most sensitive source range for each source level in the sweep.
            * 'BEST' - Best fixed range.
            * 'FIXED' - present source range is use dfor entire sweep.
        :type range_type: str|enum_range_type
        :param abort_on_limit: 'ON' aborts sweep if source limit is exceeded. (Accepts any of the ON / OFF values.)
        :type abort_on_limit: str|int|bool
        :param dual: 'ON' - sweep runs from start to stop, then stop to start. 'OFF' - sweep from start to stop only.
        :type dual: str|int|bool
        :param buffer_name: Either of the default buffers (defbuffer1 or defbuffer2) or name of a user defined buffer.
        :type buffer_name: str
        :return: Dict of the input settings in a form that may be used with ** syntax as input to this method to
            reproduce the sweep trigger model.
        :rtype: dict
        """

        # This command is "command only" (no query).
        # Used for specifying a step size to be used between start and stop. <steps> really is step size.
        # :SOURce[1]:SWEep:<function>:LINear:STEP <start>, <stop>, <steps>, <delay>, <count>, <rangeType>, <failAbort>,
        #   <dual>, "<bufferName>"

        # Save the actual inputs form the user API.
        inputs = locals()
        inputs.pop('self')

        # Validate number of step size.
        if not(isinstance(step_size, (int, float))):
            raise ValueError(f"Bad step_size {step_size}, must be numeric and must be > start value and < stop value.")

        # Validate all other parameters, translate to encoded values used by the instrument. e.g
        # delay='AUTO' becomes -1, count='INF' becomes 0.
        function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name = \
            self._check_sweep_params(function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name)

        # Plug the values into the SCPI cmd
        cmd = f':SOUR:SWE:{function}:LIN:STEP  {start}, {stop}, {step_size}, {delay}, {count}, {range_type}, '
        cmd += f'{abort_on_limit}, {dual}, "{buffer_name}"'

        # Could find no SCPI cmd to determine if buffer already exists, so clear any existing errors, then see if cmd
        # causes a new errors, possibly because buffer doesn't exist.
        self.get_inst_errors()
        self.write(cmd)
        errors = self.get_inst_errors()
        if len(errors) > 0:
            if errors[0].startswith('4909'):
                raise ValueError(f"Non-default buffer_name '{buffer_name}', does not exist. You must make the buffer "
                                 f"first using the method reading_buffers.make.")
            else:
                raise ValueError(f"{errors[0]}")

        num_points = ((stop - start) / step_size) + 1
        units = 'A' if function == "CURR" else 'V'

        self.log.info(f"Created trigger flow model for LINEAR sweep with {num_points} steps, "
                      f"{step_size:3G} {units} per step.\n"
                      f"Call trigger.initiate() to run the sweep. Retrieve data using reading_buffer.get_data("
                      f"'{buffer_name}'")

        # return dict of input args, user can save these use to replay.
        return inputs

    def log_by_points(self, function, num_points, start, stop,
                      delay='AUTO', count=1, range_type='BEST', abort_on_limit='ON', dual='OFF',
                      buffer_name='defbuffer1', asymptote=0):
        """
        Creates a trigger model within the instrument that performs a source sweep of current or voltage defined as a
        specified number of logarithmically spaced steps between specified start and stop values. A measurement is
        made at each source point.

        To run the trigger model and execute the sweep and measurements, call <smu>.trigger.initiate().  The resulting
        data can be retrieved from the buffer specified using the <smu>.reading_buffers.get_data() method.

        :param function: 'CURR' for sourcing current, 'VOLT' for sourcing voltage.
        :type function: str | enum_source_functions
        :param num_points: Number of steps in the sweep, including the start and stop values.
        :type num_points: int
        :param start: First source value, included in num_points.
        :type start: float
        :param stop: Last source value, included in num_points.
        :type stop: float
        :param delay: Delay between measurement points. Can be 'NONE', 'AUTO' or a numeric value. When you specify a
            delay, a delay block is added to the sweep trigger model. This delay is added to any source delay you may
            have set.
        :type delay: str|enum_delay|int|float
        :param count: Number of times to run the sweep. Can be 1 to 268_435_455 or 'INF' which repeats until trigger
            model is aborted, see smu.trigger.abort().
        :type count: int|str
        :param range_type:  Source range used for the sweep:

            * 'AUTO' - Most sensitive source range for each source level in the sweep.
            * 'BEST' - Best fixed range.
            * 'FIXED' - present source range is use dfor entire sweep.
        :type range_type: str|enum_range_type
        :param abort_on_limit: 'ON' aborts sweep if source limit is exceeded. (Accepts any of the ON / OFF values.)
        :type abort_on_limit: str|int|bool
        :param dual: 'ON' - sweep runs from start to stop, then stop to start. 'OFF' - sweep from start to stop only.
        :type dual: str|int|bool
        :param buffer_name: Either of the defaualt buffers (defbuffer1 or defbuffer2) or name of a user defined buffer.
        :type buffer_name: str
        :param asymptote: The asymptote changes the inflection of the sweep curve and allows it to sweep through
            zero. Value of 0 gives conventional logarithmic sweep. See Keithley reference Manual for details.
        :type asymptote: float
        :return: Dict of the input settings in a form that may be used with ** syntax as input to this method to
            reproduce the sweep trigger model.
        :rtype: dict
        """

        # This command is "command only" (no query).
        # Used for set number of step, logarithmically sized.
        # :SOURce[1]:SWEep:<function>:LOG <start>, <stop>, <points>, <delay>, <count>, <rangeType>, <failAbort>, <dual>,
        #   "<bufferName>", <asymptote>

        # Save the actual inputs form the user API.
        inputs = locals()
        inputs.pop('self')

        if not(isinstance(num_points, int) and (2 <= num_points <= 268_435_455)):
            raise ValueError(f"Bad num_points {num_points}, should be 2 to 268_435_455.")

        function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name = \
            self._check_sweep_params(function, start, stop, delay, count, range_type, abort_on_limit, dual, buffer_name)

        cmd = f':SOUR:SWE:{function}:LOG {start}, {stop}, {num_points}, {delay}, {count}, {range_type}, '
        cmd += f'{abort_on_limit}, {dual}, "{buffer_name}", {asymptote}'

        # Could find no SCPI cmd to determine if buffer already exists, so clear any existing errors, then see if cmd
        # causes a new errors, possibly because buffer doesn't exist.
        self.get_inst_errors()
        self.write(cmd)
        errors = self.get_inst_errors()
        if len(errors) > 0:
            if errors[0].startswith('4909'):
                raise ValueError(f"Non-default buffer_name '{buffer_name}', does not exist. You must make the buffer "
                                 f"first using the method reading_buffers.make.")
            else:
                raise ValueError(f"{errors[0]}")

        self.log.info(f"Created trigger flow model for LOG sweep with {num_points} steps, "
                      f"Call trigger.initiate() to run the sweep. Retrieve data using reading_buffer.get_data("
                      f"'{buffer_name}'")

        # return dict of input args, user can save these use to replay.
        return inputs

    def by_list(self, function, start_index=1, delay='NONE', count=1, abort_on_limit='ON', buffer_name='defbuffer1',
                config_list_name=None):
        """
        Creates a trigger model within the instrument that performs a source sweep of current or voltage defined by a
        configuration list. A measurement is made at each source point.

        To run the trigger model and execute the sweep and measurements, call <smu>.trigger.initiate(). The resulting
        data can be retrieved from the buffer specified using the <smu>.reading_buffers.get_data() method.

        :param function: The source function:

            * 'CURR' - sourcing current
            * 'VOLT' - sourcing voltage.
        :type function: str | enum_source_functions
        :param start_index: The index in the configuration list where the sweep starts. default is 1
        :type start_index: int
        :param delay: Delay between measurement points. Can be 'NONE', 'AUTO' or a numeric value. When you specify a
            delay, a delay block is added to the sweep trigger model. This delay is added to any source delay you may
            have set.
        :type delay: int | float
        :param count: Number of times to run the sweep. Can be 1 to 268_435_455 or 'INF' which repeats until trigger
            model is aborted, see smu.trigger.abort().
        :type count: str | int
        :param abort_on_limit: Determines if the sweep is stopped immediately if a limit is exceeded.  Accepts any of
            'ON", 'OFF' , 1, 0, True, False.

            * 'ON' -  Abort the sweep if a limit is exceeded.
            * 'OFF' - Complete the sweep even if a limit is exceeded.
        :type abort_on_limit: str | bool | int
        :param buffer_name: Either of the default buffers (defbuffer1 or defbuffer2) or name of a user defined buffer.
        :type buffer_name: str
        :param config_list_name: The name of the source configuration list that the sweep uses. If None the default is
            used that matches the function parameter: 'VOLT' -> 'VoltCustomSweepList', 'CURR" -> 'CurrCustomSweepList'.
            These lists can be created using the method <smu>.source.sweep.custom_list.
        :type config_list_name: str|None
        :return: Dict of the input settings in a form that may be used with ** syntax as input to this method to
            reproduce the sweep trigger model.
        :rtype: dict
        """

        # This command is "command only" (no query).
        # :SOURce[1]:SWEep:<function>:LIST <startIndex>, <delay>, <count>, <failAbort>, "<bufferName>",
        #   "<configListName>"

        # Save the actual inputs from the user API.
        inputs = locals()
        inputs.pop('self')

        argument_list = [function, start_index, delay, count, abort_on_limit, buffer_name, config_list_name]
        # *argument_list unpacks the arguments into the checker
        function, start_index, delay, count, abort_on_limit, buffer_name, config_list_name, num_points\
            = self._check_list_params(*argument_list)

        cmd = f':SOUR:SWE:{function}:LIST {start_index}, {delay}, {count}, {abort_on_limit}, "{buffer_name}", ' \
              f'"{config_list_name}"'
        self.write(cmd)
        self.log_inst_errors()

        self.log.info(f"Created trigger flow model for CUSTOM sweep with {num_points} steps, defined by "
                      f"config_list_name='{config_list_name}'."
                      f"Call trigger.initiate() to run the sweep. Retrieve data using reading_buffer.get_data"
                      f"({buffer_name})")

        # return dict of input args, user can save these and use to replay.
        return inputs

    def _check_list_params(self, function, start_index, delay, count, abort_on_limit, buffer_name, config_list_name):
        """helper function for checking input parameters to the list sweep type."""

        function = check_enum_str('function', function, self.enum_source_functions)
        function = function.name

        if delay is None:
            raise ValueError(f"Delay cannot be None type, should be 50e-6 to 10e3 seconds, or 'AUTO' or 'NONE'.")

        if isinstance(delay, (int, float)):
            if not(50e-6 <= delay <= 10e3):
                raise ValueError(f"Bad delay {delay}, should be 50e-6 to 10e3 seconds, or 'AUTO' or 'NONE'.")
        else:
            delay_obj = check_enum_str('delay', delay, self.enum_delay)  # Will raise ValueError is not 'AUTO' or 'NONE'
            delay = delay_obj.value   # Gives the encoding the instrument uses.

        if count is None:
            raise ValueError(f"Bad count (None type), should be 1 to 268_435_455, or 'INF'.")
        if not((isinstance(count, int) and (1 <= count <= 268_435_455)) or count == 'INF'):
            raise ValueError(f"Bad count {count}, should be 1 to 268_435_455, or 'INF'.")
        if count == 'INF':
            count = 0

        abort_on_limit = self.on_off.to_inst(abort_on_limit)

        if config_list_name is None:
            # check the current function
            config_list_name = {'VOLT': 'VoltCustomSweepList', 'CURR': 'CurrCustomSweepList'}[function]
            self.log.info(f"List defaulted to '{config_list_name}' from function {function}")

        catalog = self.source.config_list.catalog()
        if config_list_name not in catalog:
            raise ValueError(f"Bad config_list_name '{config_list_name}'. Should be one of existing config_lists:"
                             f"\n{catalog}")

        custom_lists = ['VoltCustomSweepList', 'CurrCustomSweepList']
        if config_list_name in custom_lists and function != config_list_name[:4].upper():
            raise ValueError(f"{config_list_name} cannot be used with function input '{function}'.")

        num_points = self.query(f':SOUR:CONF:LIST:SIZE?', int, target=f'"{config_list_name}"')
        self.source.config_list.get_size(config_list_name)

        if not(isinstance(start_index, int) and (1 <= start_index <= num_points)):
            raise ValueError(f"Bad start_index {start_index}, should be between 1 and {num_points} (the length of "
                             f" {config_list_name}.")

        # TODO: fix buffer name check....
        # Could find no SCPI cmd to determine if buffer already exists. But this approach is also problematic, it causes
        # error dialog to pop up on instrument screen, when buffer already exists.
        # if not self.smu.measure.reading_buffers.buffer_exists(buffer_name):
        #    raise ValueError(f"Buffer '{buffer_name}' does not exist, you must create it before using it for a sweep.")

        # return as a tuple
        return function, start_index, delay, count, abort_on_limit, buffer_name, config_list_name, num_points

# -----------------------------------------------------------
