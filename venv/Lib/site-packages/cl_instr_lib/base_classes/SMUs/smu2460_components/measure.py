# -----------------------------------------------------------
#                       INCLUDES
# -----------------------------------------------------------
from cl_instr_lib.base_classes.SMUs.smu2460_components.config_list import ConfigListMeasure
from cl_instr_lib.base_classes.SMUs.smu2460_components.calculations import Calculations

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from enum import Enum
from collections import namedtuple
import re
# -----------------------------------------------------------
#                         NOTES
# -----------------------------------------------------------

min_max_units = namedtuple('min_max_units', ['min', 'max', 'units'])

# -----------------------------------------------------------
#                       MEASURE
# -----------------------------------------------------------


class Measure:
    """
    Class for controlling the Measure sub-system of the Keithley 2460 SMU.

    The following attribute contains an object that corresponds to a sub-system of the Measure functionality.
    """

    llim_bounds = {
        'CURR': min_max_units(1e-6, 5.0, 'Amps'),
        'VOLT': min_max_units(200e-3, 20.0, 'Volts'),
        'RES': min_max_units(2.0, 20e6, 'Ohms')
    }

    ulim_bounds = {
        'CURR': min_max_units(1e-6, 7.0, 'Amps'),
        'VOLT': min_max_units(0.2, 100, 'Volts'),
        'RES': min_max_units(2.0, 200e6, 'Ohms')
    }
    meas_ranges = ulim_bounds

    enum_meas_functions = Enum("enum_meas_functions", {'CURR': 'CURR:DC', 'VOLT': 'VOLT:DC', 'RES': 'RES'})
    enum_curr_unit = Enum('enum_curr_unit', {'OHM': 'OHM', 'WATT': 'WATT', 'AMP': 'AMP'})
    enum_volt_unit = Enum('enum_volt_unit', {'OHM': 'OHM', 'WATT': 'WATT', 'VOLT': 'VOLT'})
    enum_res_unit = Enum('enum_res_unit', {'OHM': 'OHM'})
    _dict_unit_enums = {'CURR': enum_curr_unit, 'VOLT': enum_volt_unit, 'RES': enum_res_unit}

    enum_sensing = Enum('enum_sensing', {"SENSE2W": '0', "SENSE4W": '1'})
    enum_ave_modes = Enum('enum_ave_modes', {'OFF': 'OFF', 'REP': "REP", 'MOV': 'MOV'})

    def __init__(self, smu):
        self.smu = smu
        self.write = smu.write
        self.query = smu.query
        self.log = smu.log
        self.log_inst_errors = smu.log_inst_errors
        self.get_inst_errors = smu.get_inst_errors
        self.on_off = smu.on_off
        self.calculations = Calculations(self.smu)

        #: Object containing methods for the the `ConfigListMeasure`_ functionality.
        self.config_list = ConfigListMeasure(self.smu)

        self.reading_buffers = smu.reading_buffers
        self.element_names_types = smu.reading_buffers.element_names_types

    def function(self, meas_function=None, meas_units=None):
        """
        Queries or sets the measurement function and measurement units.

        If the source.output_state is 'ON', and a parameter is successfully programmed, a single measurement is made
        with the result going into the scratch buffer. This forces the display to update so the effect of programming
        the parameter can be seen.

        :param meas_function: Selects the measurement function and constrains the meas_units choices as follows:

            * CURR - Measure current. Allows for meas_units to be AMP, but meas_units of OHM or WATT may be chosen \
                chosen if <smu>.source.function is VOLT.
            * VOLT - Measure voltage. Allows for meas_units to be VOLT, but meas_units of OHM or WATT may be \
                chosen if <smu>.source.function is CURR.
            * RES - The instrument sets the source current and source limit automatically.
        :type meas_function: str|enum_meas_functions
        :param meas_units: Determines units of measurement displayed and stored in the reading buffer. Options depend
            on meas_function (either specified or existing instrument state) and <smu>.source.function.

            * AMP  - Available when meas_function is CURR.
            * VOLT - Available when meas_function is VOLT.
            * WATT  - Available when meas_function is VOLT and <smu>.source.function is CURR or with meas_function \
                VOLT when <smu>.source.function is CURR.
            * OHM  - Available when meas_function is 'VOLT' and <smu>.source.function isCURR or with meas_function \
                VOLT when source.function is CURR or with meas_function is RES. Note meas_function RES changes \
                source.function to CURR automatically within the instrument.
        :type meas_units: str|enum_curr_unit|enum_volt_unit|enum_res_unit
        :return: If all parameters are None, present settings are queried returned as a dict. Otherwise None.
        :rtype: dict|None
        """

        # [:SENSe[1]]:FUNCtion[:ON]
        # [:SENSe[1]]:<function>:UNIT

        if all([x is None for x in (meas_function, meas_units)]):
            return_values = {}
            meas_function_state = self.query(':SENS:FUNC', str)
            meas_function_state = self.enum_meas_functions(meas_function_state.strip('"'))
            return_values.update(meas_function=meas_function_state.name)

            if meas_function_state.name == 'RES':
                return_values.update(meas_units='OHM')  # Doing UNIT query in RES mode would cause an error.
            else:
                units = self.query(f':SENS:{meas_function_state.name}:UNIT')
                enum_units = self._dict_unit_enums[meas_function_state.name]
                return_values.update(meas_units=enum_units(units).name)
            return return_values

        meas_function = check_enum_str('meas_function', meas_function, self.enum_meas_functions)
        meas_function_state = meas_function
        if meas_function_state is None:
            meas_function_state = self.query(':SENS:FUNC', str)
            meas_function_state = self.enum_meas_functions(meas_function_state.strip('"'))

        # Allowed meas units depends on function. If meas_funct was input then use that, otherwise present instrument
        # state.
        enum_units = self._dict_unit_enums[meas_function_state.name]

        # Customize the error message to include the meas_function_state.
        error_template = "Bad {name} '{value}', "
        error_template += f"for meas_function '{meas_function_state.name}' should be one of "
        error_template += "{cls_name}: {keys}."

        meas_units = check_enum_str('meas_units', meas_units, enum_units, error_template)

        # More checking of the combination of function and units. If units was input, use that. Otherwise present
        # instrument state.
        meas_units_state = meas_units
        if meas_units_state is None:
            if meas_function_state.name != 'RES':
                # So read present units setting.
                response = self.query(f':SENS:{meas_function_state.name}:UNIT')
                meas_units_state = enum_units(response)
            else:
                # But trying to read it in RES mode will cause an instrument error.
                meas_units_state = enum_units.OHM

        # if units is OHM or WATT, and meas_funct == source_funct, instrument gives Overflow indication !
        if meas_units_state.name in ['OHM', 'WATT']:
            src_mode = self.smu.source.function()['mode']
            if meas_function_state.name == src_mode:
                new_meas_mode = 'VOLT' if src_mode == 'CURR' else 'CURR'
                raise ValueError(f"For '{meas_units_state.name}' measurement, source function and measurement functions"
                                 f" cannot both be '{src_mode}', change measurement mode to '{new_meas_mode}'")

        if meas_function is not None:
            self.write(':SENS:FUNC', f'"{meas_function.value}"')

        if meas_units is not None:
            if meas_function_state.name != 'RES':
                # IN RES mode avoid writing units, causes error. Apparently SMU sets unit automatically to OHM.
                self.write(f':SENS:{meas_function_state.value}:UNIT', f'{meas_units.name}')

        # Forces the display to update, as users might expect.
        if self.smu.source.output_state() == 'ON':
            self.query('MEAS', target='"scratch"')

        self.log_inst_errors()

    def get_measurement(self, elements=None, count=1, buffer_name='scratch'):
        """
        Performs the measurement as defined by <smu>.measurement.function() and <smu>.measurement.settings() and
        returns the values of the specified result elements.

        Note that if settings defines a measurement count > 1, multiple measurements will be made and placed in the
        specified buffer; however, only the results of most recent measurement are returned by this method. To retrieve
        all or a subset of the measurements, use <smu>.reading_buffers.get_data().

        :param elements: A string that specifies the names of the data elements to be retrieved. Any combination,
            in any order, of the names shown here separated by spaces is allowed. Repeated names are allowed but the
            total number of names in elements must be 14 or less. Alternatively, elements is None has the same effect as
            specifying the single value READING; elements='ALL' has the same effect as specifying all of the names
            in the order shown here.

            * DATE - The date when the data point was measured.
            * FORMATTED - The measured value as it appears on the front pane.
            * FRACTIONAL - The fractional seconds for the data point when the data point was measured.
            * READING - The measurement reading based on the function setting. **Note: if no elements is None \
              are defined, only this element is returned.**
            * RELATIVE - The relative time when the data point was measured.
            * SECONDS - The seconds in UTC (Coordinated Universal Time) format when the data point was measured.
            * SOURCE - The source value; if readback is ON, then it is the readback value, otherwise it is the \
                programmed source value
            * SOURFORMATTED- The source value as it appears on the display.
            * SOURSTATUS - The status information associated with sourcing.
            * SOURUNIT - The unit of value associated with the source value.
            * STATUS - The status information associated with the measurement.
            * TIME - The time for the data point
            * TSTAMP - The timestamp for the data point
            * UNIT - The unit of measure associated with the measurement
        :type elements: str | None
        :param count: The measurement will be repeated count times and results stored in the buffer. Note that the
            buffer must be long enough to hold all the data or be a continuous (circular) buffer. This method
            returns only the last measurement, the full set can be retrieved from the buffer using
            \<smu>.reading_buffers.get_data().
        :type count: int
        :param buffer_name: Name of an existing reading buffer. This is defaulted to 'scratch' which is a buffer created
            when this driver is instantiated. The 'scratch' buffer allows for measurements to be made without
            disturbing any existing measurements that may be in user defined buffers or the SMU default buffers. Note
            that the the scratch buffer is only 10 measurements deep and is a continuous (circular) buffer.
        :type buffer_name: str
        :return: The element values are cast to appropriate types as defined by \
            <smu>.reading_buffers.element_names_types. If elements specified a single value, that cast value is
            returned directly. If elements specified multiple values, then a list of the cast values is returned.
        :rtype: various | List[various]
        """

        # :MEASure? "<bufferName>", < bufferElements >

        self.get_inst_errors()

        # Only handle ASCII transfers at this time.
        data_format = self.query(':FORM')
        if data_format != 'ASC':
            self.log.warning(f"Non-ASCII data format '{data_format}', not supported, switching to ASCII format.")
            self.write(':FORM', 'ASC')

        # Handle elements string. Convert to list, check element names.
        if elements is None:
            elements = 'READING'
        elif elements == 'ALL':
            elements = self.reading_buffers.element_names_all

        elements = re.sub(' +', ' ', elements).strip(' ')  # Prevents errors caused by extra spaces.
        elements_list = elements.split(' ')

        invalid = [index for index, value in enumerate(elements_list) if value not in self.element_names_types]
        if len(invalid) > 0:
            msg = ', '.join([f"'{elements_list[i]}'" for i in invalid])
            raise ValueError(f"Bad elements: {msg}.")

        # Check that buffer name exists.
        if not(isinstance(buffer_name, str) and self.reading_buffers.buffer_exists(buffer_name)):
            raise ValueError(f"Bad buffer_name '{buffer_name}'. Inspect instrument for available buffers, or use the "
                              f"built-in default buffers 'defbuffer1' or 'defbuffer2'.")

        # Check count vs. available space in buffer.
        if not(1 <= count <= 300_000):
            raise ValueError(f"Bad count {count}, should be 1 to 300_000.")

        buffer_config = self.reading_buffers.config(buffer_name)

        if buffer_config['fill_mode'] == 'CONTINUOUS':
            if buffer_config['capacity'] < count:
                self.log.warning(f"Measurement count {count} exceeds capacity {buffer_config['capacity']} of "
                                 f"CONTINUOUS mode buffer '{buffer_name}', buffer will wrap and oldest measurements "
                                 f"will be lost!")
        else:
            end = self.reading_buffers.get_start_end(buffer_name)['end']
            available = buffer_config['capacity'] - end
            if available < count:
                raise RuntimeError(f"Measurement count {count} exceeds available space {available} in fill ONCE "
                                   f"buffer '{buffer_name}', reduce count or clear buffer to avoid bus timeout.")

        # program the count.
        self.write(':SENS:COUN', count)

        # kick off the measurement, get that last reading.
        response_str = self.query('MEAS?', str, pre_target_params=f'"{buffer_name}", {", ".join(elements_list)}')

        # Convert the field values from strings to their respective data types and return.
        return self.reading_buffers._response_casting(elements_list, response_str.split(','))

    def ranging(self, meas_range=None, auto_lower=None, auto_upper=None, auto_rebound=None):
        """
        Query or set parameters related to measurement range or auto-ranging configuration.

        :param meas_range: 'AUTO' or an expected measurement value.
        :type meas_range: str|float
        :param auto_lower: If meas_range is 'AUTO', prevents instrument from selecting a range below this value. This
            value can be anything, but the instrument selects a range value that is the smallest above this value.
        :type auto_lower: float
        :param auto_upper: If meas_range is 'AUTO', prevents instrument from selecting a RES range above this value.
            Can only be set when meas_function is 'RES'; when function is 'CURR' or 'VOLT' upper range is set by
            source compliance.
        :type auto_upper: float
        :param auto_rebound: If 'ON', measure range is automatically restored to match source limit after each auto
            ranged measurement.
        :type auto_rebound: str|int|bool
        :return: If all parameters are None, present settings are queried returned as a dict. Otherwise None.
        :rtype: dict|None
        """

        # [:SENSe[1]]:<function>:RANGe:AUTO
        # [:SENSe[1]]:<function>:RANGe[:UPPer]
        # [:SENSe[1]]:<function>:RANGe:AUTO:LLIMit
        # [:SENSe[1]]:<function>:RANGe:AUTO:ULIMit
        # [:SENSe[1]]:<function>:RANGe:AUTO:REBound

        function = self.function()['meas_function']

        if all([x is None for x in (meas_range, auto_lower, auto_upper, auto_rebound)]):
            return_values = {}

            is_auto = self.query(f':SENS:{function}:RANG:AUTO', bool)
            if is_auto:
                return_values.update(meas_range='AUTO')
            else:
                return_values.update(meas_range=self.query(f':SENS:{function}:RANG', float))

            return_values.update(auto_lower=self.query(f':SENS:{function}:RANG:AUTO:LLIM', float))
            return_values.update(auto_upper=self.query(f':SENS:{function}:RANG:AUTO:ULIM', float))

            if function == 'RES':
                return_values.update(auto_rebound=None)
            else:
                return_values.update(auto_rebound=self.on_off.to_api(self.query(f':SENS:{function}:RANG:AUTO:REB')))
            return return_values

        if meas_range is not None:
            min_range, max_range, units = self.meas_ranges[function].min, self.meas_ranges[function].max, \
                                   self.meas_ranges[function].units
            if (isinstance(meas_range, (int, float)) and not(min_range <= meas_range <= max_range)) or \
                    isinstance(meas_range, str) and meas_range != 'AUTO':
                raise ValueError(f"Bad meas_range {meas_range} for {function}, should be 'AUTO' or number from "
                                 f"{min_range} to {max_range} {units}.")

        # auto_lower can be set for any function: 'CURR', "VOLT', 'RES'.
        # TODO: auto_lower must be < auto_upper.
        if auto_lower is not None:
            bounds = self.llim_bounds[function]
            if not (bounds.min <= auto_lower <= bounds.max):
                raise ValueError(f'Bad auto_lower {auto_lower}, should be {bounds.min} to {bounds.max} {bounds.units}.')

        # auto_upper can only be written to in RES mode not in CURR or VOLT
        if auto_upper is not None:
            if function != 'RES':
                raise ValueError(f'Bad auto upper {auto_upper}, cannot be written to in mode {function}')
            bounds = self.ulim_bounds[function]
            if not (bounds.min <= auto_upper <= bounds.max):
                raise ValueError(f'Bad auto_upper {auto_upper}, should be {bounds.min} to {bounds.max} {bounds.units}.')

        # AUTO_REBOUND CHECKS
        if auto_rebound is not None:
            if function is 'RES':
                raise ValueError(f'Bad auto_rebound {auto_rebound}, cannot be set in mode {function}')
        auto_rebound = self.on_off.to_inst(auto_rebound)

        if meas_range is not None:
            if meas_range == 'AUTO':
                self.write(f':SENS:{function}:RANG:AUTO', 1)
            else:
                self.write(f':SENS:{function}:RANG', meas_range)
                self.write(f':SENS:{function}:RANG:AUTO', 0)

        if auto_lower is not None:
            self.write(f':SENS:{function}:RANG:AUTO:LLIM', auto_lower)

        if auto_upper is not None:
            self.write(f':SENS:{function}:RANG:AUTO:ULIM', auto_upper)

        if auto_rebound is not None:
            self.write(f':SENS:{function}:RANG:AUTO:REB', auto_rebound)

        self.log_inst_errors()

    # def relative(self, function, state, value):
    #     # [:SENSe[1]]:<function>:RELative:STATe
    #     # [:SENSe[1]]:<function>:RELative
    #     pass
    #
    # def relative_acquire(self):
    #     # [:SENSe[1]]:<function>:RELative:ACQuire
    #     pass

    def auto_zero_once(self):
        """
        Forces a refresh of the reference and zero measurements that are used for the present aperture setting for
        the selected function.

        If you have auto_zero_state 'OFF', calling auto_zero_once immediately before a test sequence will help minimize
        drift.

        """

        self.write(':SENS:AZER:ONCE')

    # TODO: Implement user delays, not needed until creating trigger model is implemented.
    # def user_delays(self, delay_id, seconds):
    #     # [:SENSe[1]]:<function>:DELay:USER<n>
    #     pass

    def settings(self, sensing=None, digits=None, nplc=None, ave_mode=None, ave_count=None, auto_zero_state=None):
        """
        Query or set parameters that control measurements.

        :param sensing: Selects 2 or 4 wire sensing.

            * 'SENSE2W' - 2 wire sensing
            * 'SENSE4W' - 4 wire sensing
        :type sensing: str | int | enum_sensing
        :param digits: Determines the number of digits displayed on front panel. Takes an integer value from 3 to 6,
            these correspond to 3.5 to 6.5 digits.
        :type digits: int | float
        :param nplc: Measurement integration time in power line cycles. Value from  0.01 to 10.
        :type nplc: int | float
        :param ave_mode: Disable or select type of averaging filter.

            * 'OFF' - No averaging filtering.
            * 'REP' - Repeating filter, a set of measurements are made and then averaged to produce the reading. Then \
                the set is discarded and an entirely new set acquired to repeat the process. This is the slower \
                filter since ave_count measurements must be acquired to produce each average.
            * 'MOV' - Moving filter, each new measurement replaces the oldest previous measurement in the filter \
                in a  first-in, first-out manner, then the average is calculated. This produces an new \
                averaged value on every measurement. This is the faster filter, a new average is produced on \
                every measurement.
        :type ave_mode: str | enum_ave_mode
        :param ave_count: Sets the number of measurements that are averaged when filtering is enabled. Value from
            1 to 100.
        :type ave_count: int
        :param auto_zero_state: This command enables ('ON') or disables ('OFF') automatic updates to the internal
            reference measurements (autozero) of the instrument.

            * 'ON' - Internal ground and reference voltage is checked on every measurement. Adds to measurement time.
            * 'OFF' - Disables checking of the internal levels, speeding up measurements. Instrument may drift out of \
                spec. Use <smu>.measure.auto_zero_once() to force the refrence levels to be updated before starting a \
                test sequence.
        :type auto_zero_state: str | int | bool
        :return: A dictionary called return_values is read back with each parameter and its corresponding value.
        :rtype: Dict | None
        """

        # [:SENSe[1]]:<function>:RSENse
        # :DISPlay:<function>:DIGits
        # [:SENSe[1]]:<function>:NPLCycles
        # [:SENSe[1]]:<function>:AVERage[:STATe]
        # [:SENSe[1]]:<function>:AVERage:TCONtrol
        # [:SENSe[1]]:<function>:AVERage:COUNt
        # [:SENSe[1]]:<function>:AZERo[:STATe]

        function = self.function()['meas_function']

        if all([x is None for x in (sensing, digits, nplc, ave_mode, ave_count, auto_zero_state)]):
            return_values = {}
            return_values.update(sensing=self.query(f':SENS:{function}:RSEN', self.enum_sensing).name)
            return_values.update(digits=self.query(f':DISP:{function}:DIG', int))
            return_values.update(nplc=self.query(f'SENS:{function}:NPLC', float))

            if self.query(f':SENS:{function}:AVER:STAT', bool):
                temp = self.query(f':SENS:{function}:AVER:TCON', self.enum_ave_modes).name
            else:
                temp = self.enum_ave_modes.OFF.name

            return_values.update(ave_mode=temp)
            return_values.update(ave_count=self.query(f'SENS:{function}:AVER:COUN', int))
            return_values.update(auto_zero_state=self.on_off.to_api(self.query(f'SENS:{function}:AZER:STAT')))

            return return_values

        # Do validity checks on inputs that are not None.
        sensing = check_enum_str('sensing', sensing, self.enum_sensing)
        ave_mode = check_enum_str('ave_mode', ave_mode, self.enum_ave_modes)
        auto_zero_state = self.on_off.to_inst(auto_zero_state)

        if digits is not None:
            if not(isinstance(digits, (int, float)) and 3 <= int(digits) <= 6):
                raise ValueError(f'Bad digits {digits}, should be between 3 to 6.')
            digits = int(digits)

        if nplc is not None:
            if not(isinstance(nplc, (int, float)) and 0.01 <= nplc <= 10):
                raise ValueError(f'Bad nplc {nplc}, should be between 0.01 to 10.')

        if ave_count is not None:
            if not(isinstance(ave_count, int) and 1 <= ave_count <= 100):
                raise ValueError(f'Bad ave_count {ave_count}, should be between 1 to 100.')

        # If we got here, all checks OK (no exceptions have been raised).
        # Now write the values that are not None to the instrument.

        if sensing is not None:
            self.write(f':SENS:{function}:RSEN', sensing.value)

        if digits is not None:
            self.write(f':DISP:{function}:DIG', digits)

        if nplc is not None:
            self.write(f'SENS:{function}:NPLC', nplc)

        if ave_mode is not None:
            if ave_mode.name == 'OFF':
                self.write(f':SENS:{function}:AVER:STAT', 'OFF')
            else:
                self.write(f':SENS:{function}:AVER:TCON', ave_mode.value)
                self.write(f':SENS:{function}:AVER:STAT', 'ON')

        if ave_count is not None:
            self.write(f'SENS:{function}:AVER:COUN', ave_count)

        if auto_zero_state is not None:
            self.write(f'SENS:{function}:AZER:STAT', auto_zero_state)

        self.log_inst_errors()

# -----------------------------------------------------------
