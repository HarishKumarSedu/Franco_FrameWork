from collections import namedtuple

from nidcpower.session import Session
from nidcpower.enums import *

from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC
from cl_instr_lib.helpers.check_enum_str_aliased import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units

ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max',
                                                     'sink_watts_max', 'source_watts_max'])

CompensationBounds = namedtuple('CompensationBounds', ['gain_bandwidth_voltage', 'gain_bandwidth_current',
                                                       'compensation_frequency', 'pole_zero_ratio'])


class NiSmuChannel(PSChannel_ABC):
    """Implements the methods to control an output channel of a NI PXI / PXIe SMU. Provides for operating as a
    voltage source or as a current source.

    Intended to be composed within a container object that implements the driver for a specific model of NI PXI / PXIe
    SMU. The container object must contain attributes names voltage_ranges, current_limit_ranges, current_ranges and
    voltage_limit_ranges which contain objects of class InstrumentRanges initialized with data for the specific model of
    SMU.

    """

    def __init__(self, smu_obj, channel_name, channel_id, programming_bounds):
        super().__init__(power_supply=smu_obj, channel_name=channel_name, programming_bounds=programming_bounds)
        self.session = smu_obj.session
        self.on_off = smu_obj.on_off
        self.log_unused_args = smu_obj.log_unused_args
        self.log = smu_obj.log

        self.vsource_sink_current_limit = smu_obj.vsource_sink_current_limit  # current as a function of voltage.
        self.isource_sink_voltage_limit = smu_obj.isource_sink_voltage_limit  # voltage as a function of current.

        self.voltage_ranges = smu_obj.voltage_ranges
        self.current_limit_ranges = smu_obj.current_limit_ranges

        self.current_ranges = smu_obj.current_ranges
        self.voltage_limit_ranges = smu_obj.voltage_limit_ranges

        self.compensation_bounds = smu_obj.compensation_bounds

        self.channel_id = channel_id

        self.session.channels[self.channel_id].source_mode = SourceMode.SINGLE_POINT

        self.session.channels[self.channel_id].voltage_level_autorange = True
        self.session.channels[self.channel_id].current_limit_autorange = True

        self.session.channels[self.channel_id].current_level_autorange = True
        self.session.channels[self.channel_id].voltage_limit_autorange = True

        self.session.channels[self.channel_id].commit()
        self.session.channels[self.channel_id].initiate()

    def source_voltage(self, voltage=None, current_limit=None, voltage_range=None, current_limit_range=None,
                       transient_response=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **VOLTAGE** source.

        For 4-Quadrant SMUs, the sink power/current capabilities may be less than the sourcing capability. See the
        quadrant diagram in the spec for your SMU. In these cases a warning is generated if the current_limit setting
        (which applies to both souring and sinking current) is high enough that the sinking capability could be
        violated if the SMU transitions from sourcing to sinking current as a result of external sources being
        connected.

        :param voltage: Output voltage in Volts. Can be negative for bipolar SMUs.
        :type voltage: float
        :param current_limit: Compliance limit for output current in Amps. Always a positive value for both sourcing and
            sinking current.
        :type current_limit: float
        :param voltage_range: Either 'AUTO' or one of the float values returned by voltage_range.get_ranges(). 'AUTO'
            allows voltage to be set across the full range of the SMU. Attempting to set a fixed range value that
            is not a standard value results in the range being coerced up to the next larger range. Is always a positive
            value even for bipolar SMUs.
        :type voltage_range: str|float
        :param current_limit_range: Either 'AUTO' or one of the float values returned by
            current_limit_ranges.get_ranges(). 'AUTO' allows current_limit to be set across the full range of the SMU.
            Attempting to set a fixed range value that is not a standard value results in the range being coerced up to
            the next larger range. Note that current limit ranges impose a minimum as well as a maximum on current_limit
            settings.
        :type current_limit_range: str|float
        :param transient_response: Selects a set of compensation parameter values for various types of loads. Choices
            are:

            * SLOW  Increases stability while decreasing the speed of the response. Select SLOW if connecting a load \
                causes the SMU channel to exhibit symptoms of instability, such as unstable readings or excessive noise.
            * NORMAL Balances stability and the speed of the response. It is the default transient response setting \
                and is appropriate for most situations.
            * FAST Increases the speed of the response for improved transient response with benign loads. Select FAST \
                if you need faster response and if doing so does not cause the SMU channel to exhibit symptoms of \
                instability, such as unstable readings or excessive noise.
            * CUSTOM Allows freedom to adjust compensation for specific loads. Select CUSTOM if you need to optimize \
                the speed/stability tradeoff. Refer to method set_custom_compensation_values for detailed information.
        :type transient_response: str|nidcpower.enum.TransientResponse
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit, voltage_range, current_limit_range, transient_response}):
            return_values = {}
            return_values.update(voltage=self.session.channels[self.channel_id].voltage_level)
            return_values.update(current_limit=self.session.channels[self.channel_id].current_limit)
            return_values.update(voltage_range=self._get_voltage_range())
            return_values.update(current_limit_range=self._get_current_limit_range())
            return_values.update(transient_response=self.session.channels[self.channel_id].transient_response.name)
            return return_values

        # Check input parameter values.
        # IMPORTANT: Also check interdependencies between parameters. These can involve a new value being supplied and
        # its compatibility with an existing instrument setting, or it could involve two new values being supplied.
        # The variables ending in _state facilitate this checking.

        # voltage_state is future value, either we set it or leave it unchanged from what is in instrument.
        voltage_state = voltage
        if voltage is None:
            voltage_state = self.session.channels[self.channel_id].voltage_level

        # current_limit_state is future value, either we set it or leave it unchanged from what is in instrument.
        current_limit_state = current_limit
        if current_limit is None:
            current_limit_state = self.session.channels[self.channel_id].current_limit

        # voltage_range_state is future value, either we set it or leave it unchanged from what is in instrument.
        if voltage_range is None:
            voltage_range_state = self._get_voltage_range()
        else:
            # Ensures programing a valid range, even though voltage_range (a float) may not be an exact match.
            voltage_range = self.voltage_ranges.coerced_range(voltage_range)
            voltage_range_state = voltage_range

        # current_limit_range_state is future value, either we set it or leave it unchanged from what is in instrument.
        if current_limit_range is None:
            current_limit_range_state = self._get_current_limit_range()
        else:
            # Ensures programing a valid range, even though current_limit_range (a float) may not be an exact match.
            current_limit_range = self.current_limit_ranges.coerced_range(current_limit_range)
            current_limit_range_state = current_limit_range

        # Check validity of values and associated range combinations. Either one or both may be changing, so we use the
        # _state variables.
        self.voltage_ranges.error_on_out_of_range(voltage_state, voltage_range_state)

        # Assumes compliance_limit_symmetry is SYMMETRIC, so limit is set by a single property with positive value
        # that defines the maximum absolute value of the actual current.

        self.current_limit_ranges.error_on_out_of_range(current_limit_state, current_limit_range_state)

        # Check that combination of voltage and current_limit won't exceed power sourcing limits.
        # Using the _state variables covers changes made to either one or both.
        # query_max_current_limit comprehends chassis cooling limits.
        # Caution: query_max_current_limit returns negative current for negative voltage, yet current limits can only be
        # set with positive numbers. Also, the returned values are a little bit outside the quadrant diagram.
        max_current_limit = self.session.channels[self.channel_id].query_max_current_limit(voltage_state)

        if abs(voltage_state)*current_limit_state > min(abs(voltage_state*max_current_limit),
                                                        self.programming_bounds.source_watts_max):
            raise ValueError(f"Power sourcing capability of {self.programming_bounds.source_watts_max} W "
                             f"would be exceeded by setting voltage={voltage_state}V and "
                             f"current_limit={current_limit_state}A.")

        # Warn about sinking current/power limitations that are more restrictive than the sourcing limits.
        # This isn't necessarily prevented by the current_limit which is a single number that applies to both sourcing
        # and sinking, because the current limit may be set to a value allowed for souring but high enough to allow the
        # sinking limits to be violated if the external circuitry starts providing current.

        # Calculation done in parent SMU obj, could be based on power (4139) or current (4163) and on chassis cooling.
        sink_current_limit = self.vsource_sink_current_limit(voltage_state)  # returns + or - depending on quadrant.

        if current_limit_state > abs(sink_current_limit):
            # voltage_limit is not low enough to prevent exceeding sink power/current limits, so caution user.
            if voltage_state > 0.0:
                # Current from an external source could push us from Quad 1 (+V, +I) into Quad 4 (+V,-I) (sinking).
                pos_neg = 'negative'
            else:
                # Current from an external source could push us from Quad 3 (-V,-I) into Quad 2: (-V,+I) (sinking).
                pos_neg = 'positive'

            msg = f"For voltage={voltage_state}V, external current more {pos_neg} than {sink_current_limit:3.3g}A"
            if abs(voltage_state*current_limit_state) > abs(self.programming_bounds.sink_watts_max):
                self.log.warn(f"{msg}\nwill violate sink power limitation of "
                              f"{self.programming_bounds.sink_watts_max}W.\nSee quadrant diagram in SMU specs.")
            else:
                # Boundaries in 4163 are defined in quad diagram as current rather than power.
                self.log.warn(f"{msg}\nwill violate sink current limitation of "
                              f"{sink_current_limit:3.3g}A.\nSee quadrant diagram in SMU specs.")

        transient_response = check_enum_str('transient_response', transient_response, TransientResponse)

        # If we got here all inputs are valid, now write them to the instrument.

        # Go to Uncommitted state so we don't have to worry about the order in which we program new values.
        # This doesn't interrupt power delivery in progress.
        self.session.channels[self.channel_id].abort()

        self.session.channels[self.channel_id].output_function = OutputFunction.DC_VOLTAGE

        if voltage is not None:
            self.session.channels[self.channel_id].voltage_level = voltage
        if current_limit is not None:
            self.session.channels[self.channel_id].current_limit = current_limit
        if voltage_range is not None:
            self._set_voltage_range(voltage_range)
        if current_limit_range is not None:
            self._set_current_limit_range(current_limit_range)
        if transient_response is not None:
            self.session.channels[self.channel_id].transient_response = transient_response

        self.session.channels[self.channel_id].commit()
        self.session.channels[self.channel_id].initiate()

        if isinstance(self.session, Session):
            # This hack is because wait_for_event method is not accessible through Pyro, but is needed in standalone.
            # Get errors without this if we immediately try to do a measurement.
            # Seem to get away with not having it in framework, possibly just lucky amount of delay?
            self.session.channels[self.channel_id].wait_for_event(Event.SOURCE_COMPLETE)

        self.compliance_warning()

    def _get_voltage_range(self):
        """Returns 'AUTO' or a float value depending on SMU values of voltage_level_autorange and voltage_level_range.
        """

        if self.session.channels[self.channel_id].voltage_level_autorange:
            return 'AUTO'
        else:
            return self.session.channels[self.channel_id].voltage_level_range

    def _set_voltage_range(self, voltage_range):
        """
        Sets SMU voltage_level_autorange and voltage_level_range as specified by voltage_range.

        These parameters must be set in the Uncommitted state, perform an abort before calling this method.
        """

        if voltage_range == 'AUTO':
            self.session.channels[self.channel_id].voltage_level_autorange = True
        else:
            self.session.channels[self.channel_id].voltage_level_range = voltage_range
            self.session.channels[self.channel_id].voltage_level_autorange = False

    def _get_current_limit_range(self):
        """Returns 'AUTO' or a float value depending on SMU values of current_limit_autorange and current_limit_range.
        """

        if self.session.channels[self.channel_id].current_limit_autorange:
            return 'AUTO'
        else:
            return self.session.channels[self.channel_id].current_limit_range

    def _set_current_limit_range(self, current_limit_range):
        """
        Sets SMU current_limit_autorange and current_limit_range as specified by current_limit_range.

        These parameters must be set in the Uncommitted state, perform an abort before calling this method.
        """

        if current_limit_range == 'AUTO':
            self.session.channels[self.channel_id].current_limit_autorange = True
        else:
            self.session.channels[self.channel_id].current_limit_range = current_limit_range
            self.session.channels[self.channel_id].current_limit_autorange = False

    def source_current(self, current=None, voltage_limit=None, current_range=None, voltage_limit_range=None,
                       transient_response=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **CURRENT** source.

        For 4-Quadrant SMUs, the sink power/current capabilities may be less than the sourcing capability. See the
        quadrant diagram in the spec for your SMU. In these cases a warning is generated if the voltage_limit setting
        (which applies to both souring and sinking current) is high enough that the sinking capability could be
        violated if the SMU transitions from sourcing to sinking current as a result of external sources being
        connected.

        :param current: Output current in Amps. Can be negative for bipolar SMUs.
        :type current: float
        :param voltage_limit: Compliance limit for output voltage in Volts. Always set as positive value regardless of
            current direction.
        :type voltage_limit: float
        :param current_range:  Either 'AUTO' or one of the float values returned by current_range.get_ranges(). 'AUTO'
            allows current to be set across the full range of the SMU. Attempting to set a fixed range value that
            is not a standard value results in the range being coerced up to the next larger range. Is always a positive
            value even for bipolar SMUs.
        :type current_range: str|float
        :param voltage_limit_range: Either 'AUTO' or one of the float values returned by
            voltage_limit_ranges.get_ranges(). 'AUTO' allows voltage_limit to be set across the full range of the SMU.
            Attempting to set a fixed range value that is not a standard value results in the range being coerced up to
            the next larger range.
        :type voltage_limit_range: str|float
        :param transient_response: Selects a set of compensation parameter values for various types of loads. Choices
            are:

            * SLOW  Increases stability while decreasing the speed of the response. Select SLOW if connecting a load \
                causes the SMU channel to exhibit symptoms of instability, such as unstable readings or excessive noise.
            * NORMAL Balances stability and the speed of the response. It is the default transient response setting \
                and is appropriate for most situations.
            * FAST Increases the speed of the response for improved transient response with benign loads. Select FAST \
                if you need faster response and if doing so does not cause the SMU channel to exhibit symptoms of \
                instability, such as unstable readings or excessive noise.
            * CUSTOM Allows freedom to adjust compensation for specific loads. Select CUSTOM if you need to optimize \
                the speed/stability tradeoff. Refer to method set_custom_compensation_values for detailed information.
        :type transient_response: str|nidcpower.enum.TransientResponse

        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {current, voltage_limit, current_range, voltage_limit_range, transient_response}):
            return_values = {}
            return_values.update(current=self.session.channels[self.channel_id].current_level)
            return_values.update(voltage_limit=self.session.channels[self.channel_id].voltage_limit)
            return_values.update(current_range=self._get_current_range())
            return_values.update(voltage_limit_range=self._get_voltage_limit_range())
            return_values.update(transient_response=self.session.channels[self.channel_id].transient_response.name)
            return return_values

        # Check input parameter values.
        # IMPORTANT: Also check interdependencies between parameters. These can involve a new value being supplied and
        # its compatibility with an existing instrument setting, or it could involve two new values being supplied.
        # The variables ending in _state facilitate this checking.

        # current_state is future value, either we set it or leave it unchanged from what is in instrument.
        current_state = current
        if current is None:
            current_state = self.session.channels[self.channel_id].current_level

        # voltage_limit_state is future value, either we set it or leave it unchanged from what is in instrument.
        voltage_limit_state = voltage_limit
        if voltage_limit is None:
            voltage_limit_state = self.session.channels[self.channel_id].voltage_limit

        # current_range_state is future value, either we set it or leave it unchanged from what is in instrument.
        if current_range is None:
            current_range_state = self._get_current_range()
        else:
            # Ensures programing a valid range, even though current_range (a float) may not be an exact match.
            current_range = self.current_ranges.coerced_range(current_range)
            current_range_state = current_range

        # voltage_limit_range_state is future value, either we set it or leave it unchanged from what is in instrument.
        if voltage_limit_range is None:
            voltage_limit_range_state = self._get_voltage_limit_range()
        else:
            # Ensures programing a valid range, even though voltage_limit_range (a float) may not be an exact match.
            voltage_limit_range = self.voltage_ranges.coerced_range(voltage_limit_range)
            voltage_limit_range_state = voltage_limit_range

        # Check validity of values and associated range combinations. Either one or both may be changing so we use the
        # _state variables.
        self.current_ranges.error_on_out_of_range(current_state, current_range_state)

        # Assumes compliance_limit_symmetry is SYMMETRIC, so limit is set by a single property with positive value
        # that defines the maximum absolute value of the actual voltage.
        self.voltage_limit_ranges.error_on_out_of_range(voltage_limit_state, voltage_limit_range_state)

        # Check that combination of current and voltage_limit won't exceed sourcing power limits.
        # Using the _state variables covers changes made to either one or both.
        # Note nidcpower does not provide a query_max_voltage_limit method. Using query_max_current_limit seems work.
        # query_max_current_limit comprehends chassis cooling limits.

        max_current = self.session.channels[self.channel_id].query_max_current_limit(voltage_limit_state)
        # Above query returns negative for negative voltages, yet current limits can only be set with positive numbers.
        # Added min with source_watts_max because returned limits at extreme are not consistent with quadrant specs.
        # Maybe float rounding issue in nidcpower?
        if abs(current_state)*voltage_limit_state > min(abs(voltage_limit_state*max_current),
                                                        self.programming_bounds.source_watts_max):
            raise ValueError(f"Power sourcing capability of {self.programming_bounds.source_watts_max} W "
                             f"would be exceeded by setting current={current_state}A and "
                             f"voltage_limit={voltage_limit_state}A.")

        # Warn user in those situations where voltage_limit will not be adequate to prohibit external circuit from
        # violating quadrant 2 and 4 power sinking limits.

        # Calculation done in parent SMU obj, chassis cooling capability may be baked into the calculation.
        sink_voltage_limit = self.isource_sink_voltage_limit(current_state)   # Can be pos or neg.

        if voltage_limit_state > abs(sink_voltage_limit):
            # voltage_limit is not low enough to prevent exceeding sink power/current limits, so caution user.
            if current_state > 0.0:
                # Voltage from an external source could push us from Quad 1 (+V,+I) into Quad 2 (-V,+I) (sinking).
                pos_neg = 'negative'
            else:
                # Voltage from an external source could push us from Quad 3 (-V,-I) into Quad 4 (+V,-I) (sinking).
                pos_neg = 'positive'

            msg = f"For current={current_state}A, external voltage more {pos_neg} than {sink_voltage_limit:3.3g}V"
            if abs(current_state*voltage_limit_state) > abs(self.programming_bounds.sink_watts_max):
                self.log.warn(f"{msg}\nwill violate sink power limitation of "
                              f"{self.programming_bounds.sink_watts_max}W.\nSee quadrant diagram in SMU specs.")
            else:
                self.log.warn(f"{msg}\nwill violate sink voltage limitation of "
                              f"{sink_voltage_limit:3.3g}V.\nSee quadrant diagram in SMU specs.")

        transient_response = check_enum_str('transient_response', transient_response, TransientResponse)

        # If we got here all inputs are valid, now write them to the instrument.

        # Go to Uncommitted state so we don't have to worry about the order in which we program new values.
        # this doesn't interrupt power delivery in progress.
        self.session.channels[self.channel_id].abort()

        self.session.channels[self.channel_id].output_function = OutputFunction.DC_CURRENT

        if current is not None:
            self.session.channels[self.channel_id].current_level = current
        if voltage_limit is not None:
            self.session.channels[self.channel_id].voltage_limit = voltage_limit
        if current_range is not None:
            self._set_current_range(current_range)
        if voltage_limit_range is not None:
            self._set_voltage_limit_range(voltage_limit_range)
        if transient_response is not None:
            self.session.channels[self.channel_id].transient_response = transient_response

        self.session.channels[self.channel_id].commit()
        self.session.channels[self.channel_id].initiate()

        if isinstance(self.session, Session):
            # This hack is because wait_for_event method is not accessible through Pyro, but is needed in standalone.
            # Get errors without this if we immediately try to do a measurement.
            # Seem to get away with not having it in framework, possibly just lucky amount of delay?
            self.session.channels[self.channel_id].wait_for_event(Event.SOURCE_COMPLETE)

        self.compliance_warning()

    def _get_current_range(self):
        """Returns 'AUTO' or a float value depending on SMU values of current_level_autorange and current_level_range.
        """

        if self.session.channels[self.channel_id].current_level_autorange:
            return 'AUTO'
        else:
            return self.session.channels[self.channel_id].current_level_range

    def _set_current_range(self, current_range):
        """
        Sets SMU current_level_autorange and current_level_range as specified by current_range.

        These parameters must be set in the Uncommitted state, perform an abort before calling this method.
        """

        if current_range == 'AUTO':
            self.session.channels[self.channel_id].current_level_autorange = True
        else:
            self.session.channels[self.channel_id].current_level_range = current_range
            self.session.channels[self.channel_id].current_level_autorange = False

    def _get_voltage_limit_range(self):
        """Returns 'AUTO' or a float value depending on SMU values of voltage_limit_autorange and voltage_limit_range.
        """

        if self.session.channels[self.channel_id].voltage_limit_autorange:
            return 'AUTO'
        else:
            return self.session.channels[self.channel_id].voltage_limit_range

    def _set_voltage_limit_range(self, voltage_limit_range):
        """
        Sets SMU voltage_limit_autorange and voltage_limit_range as specified by voltage_limit_range.

        These parameters must be set in the Uncommitted state, perform an abort before calling this method.
        """

        if voltage_limit_range == 'AUTO':
            self.session.channels[self.channel_id].voltage_limit_autorange = True
        else:
            self.session.channels[self.channel_id].voltage_limit_range = voltage_limit_range
            self.session.channels[self.channel_id].voltage_limit_autorange = False

    def in_compliance(self):
        """Returns True if output is being limited by reaching its compliance limit, False other wise.

        When sourcing voltage, True is returned if the output current_limit is reached before the desired voltage level.
        When sourcing current, True is returned if the output voltage_limit is reached before the desired current level.
        """

        # TODO: Check for compatibility with other supplies/SMUs
        return self.session.channels[self.channel_id].query_in_compliance()

    def compliance_warning(self):
        """If source output is being limited by the compliance setting, prints a warning message to the log. Otherwise,
        does nothing.

        Note: this method is called by source_voltage and source_current whenever those methods are used to write
        any of the voltage or current source parameters.
        """

        if self.in_compliance():
            mode = self.session.channels[self.channel_id].output_function
            if mode.name == 'DC_VOLTAGE':
                self.log.warn(f"CHANNEL{self.channel_id} sourcing voltage is in CURRENT compliance at limit "
                              f"{self.session.channels[self.channel_id].current_limit} A.")
            elif mode.name == 'DC_CURRENT':
                self.log.warn(f"CHANNEL{self.channel_id} sourcing current is in VOLTAGE compliance at limit "
                              f"{self.session.channels[self.channel_id].voltage_limit} V.")

    def get_voltage_source_ranges(self):
        """Returns the results of querying the instrument voltage_level_range and current_limit_range.  These pertain to
        operating the SMU channel as a **voltage** source.

        This can be used to obtain the values the instrument has chosen while AUTO ranging is enabled.

        :return: A dict of parameter names-values is returned, with keys 'voltage_range' and 'current_limit_range'.
        """

        return_values = {}
        return_values.update(voltage_range=self.session.channels[self.channel_id].voltage_level_range)
        return_values.update(current_limit_range=self.session.channels[self.channel_id].current_limit_range)
        return return_values

    def get_current_source_ranges(self):
        """Returns the results of querying the instrument current_level_range and voltage_limit_range. These pertain to
        operating the SMU channel as a **current** source.

        This can be used to obtain the values the instrument has chosen while AUTO ranging is enabled.

        :return: A dict of parameter names-values is returned, with keys 'current_range' and 'voltage_limit_range'.
        """

        return_values = {}
        return_values.update(current_range=self.session.channels[self.channel_id].current_level_range)
        return_values.update(voltage_limit_range=self.session.channels[self.channel_id].voltage_limit_range)
        return return_values

    def measure_voltage(self):
        """Returns the measured value at the output in Volts."""

        return self.session.channels[self.channel_id].measure(MeasurementTypes.VOLTAGE)

    def measure_current(self):
        """Returns the measured value at the output in Amperes."""

        return self.session.channels[self.channel_id].measure(MeasurementTypes.CURRENT)

    def measure_power(self):
        """Returns the measured power at the output in Watts.

        Note that if the SMU supports 4-quadrant operation, power values will be negative in Quadrant 2
        (-voltage, +current), and Quadrant 4 (+voltage, -current). Positive current flows out of the SMU to the load.
        """

        data = self.session.channels[self.channel_id].measure_multiple()[0]
        # Named tuple gets converted by Pyro to ordinary tuple.
        # return data.voltage * data.current
        return data[0] * data[1]

    def output_state(self, on_off=None):
        """Queries or sets the output state of the channel.

        Note that when setting the output_state to on, the instrument is queried to see if output is being limited by
        compliance, if so a warning is logged.

        :param on_off: Can be any of the values representing 'ON' ('ON', 1, True), or any of the values representing
            'OFF': ('OFF', 0, False).
        :type on_off: str|int|bool
        :return: If on_off=None instrument is queried and present setting is returned as 'ON' or 'OFF'.
        """

        if on_off is None:
            return self.on_off.to_api(self.session.channels[self.channel_id].output_enabled)

        on_off = self.on_off.to_inst(on_off)

        self.session.channels[self.channel_id].output_enabled = on_off

        if self.on_off.to_api(on_off) == 'ON':
            self.compliance_warning()

    def function(self, mode=None):
        """
        Query or select the operating mode of the source: 'DC_VOLTAGE' or 'DC_CURRENT'.

        Note: the output mode is automatically selected when you use the source_voltage or source_current method to set
        a parameter.

        :param mode: Sets the source to the specified mode: 'VOLT' or 'CURR'.

            * 'DC_VOLTAGE' - Operate as a voltage source. May also use 'VOLT' for compatibility with Keithley SMUs.
            * 'DC_CURRENT' - Operate as a current source. May also use 'CURR' for compatibility with Keithley SMUs.
        :type mode: str|nidcpower.enums.OutputFunction
        :return: If mode=None instrument is queried and present setting is returned as a dict. Note return values are
            always either 'DC_VOLTAGE' or 'DC_CURRENT'.
        :rtype: dict | None
        """

        present_mode = self.session.channels[self.channel_id].output_function

        if mode is None:
            return_values = {}
            return_values.update(mode=present_mode.name)  # TODO: How should this work with the alias feature?
            return return_values

        mode = check_enum_str('mode', mode, OutputFunction,
                              altkeys_enum_cls=Enum('alias', {'VOLT': 'DC_VOLTAGE', 'CURR': 'DC_CURRENT'}))

        if mode.name != present_mode.name:
            self.session.abort()
            self.session.channels[self.channel_id].output_function = mode
            self.session.commit()
            self.session.initiate()

    def settings(self, sensing=None):
        """
        Query or set parameters that control measurements.

        :param sensing: Selects 2 or 4 wire sensing.

            * 'LOCAL' - 2 wire sensing, may also use 'SENSE2W' for compatibility with Keithley SMUs.
            * 'REMOTE' - 4 wire sensing. may also use 'SENSE4W' for compatibility with Keithley SMUs.
        :type sensing: str | nidcpower.enums.Sense
        :return: If sensing=None instrument is queried and present setting is returned as a dict. Note return values are
            always either 'LOCAL' or 'REMOTE'.
        :rtype: Dict | None
        """

        if sensing is None:
            return_values = {}
            # TODO: How should this work with the alias feature?
            return_values.update(sensing=self.session.channels[self.channel_id].sense.name)
            return return_values

        # Gives back the NI Enum regardless if input was NI Enum or its keys or Keithley keys.
        sensing = check_enum_str('sensing', sensing, Sense,
                                 altkeys_enum_cls=Enum('alias', {'SENSE2W': 'LOCAL', 'SENSE4W': 'REMOTE'}))

        self.session.abort()

        if sensing is not None:
            self.session.channels[self.channel_id].sense = sensing

        self.session.commit()
        self.session.initiate()

    def get_active_compensation_values(self):
        """
        Returns the values of the transient_response properties that are in effect based on the present output_function
        selected (DC_VOLTAGE or DC_CURRENT) and the corresponding transient_response selection.

        :return: Dict with keys 'output_function', 'transient_response', 'compensation_frequency', 'gain_bandwidth',
            and 'pole_zero_ratio'. For explanation of these, see method set_custom_compensation_values().
        :rtype: dict[str: float]
        """

        output_function = self.session.channels[self.channel_id].output_function.name
        if output_function not in ('DC_VOLTAGE', 'PULSE_VOLTAGE', 'DC_CURRENT', 'PULSE_CURRENT'):
            raise RuntimeError(f'SMU channel {self.channel_id} returned unexpected output_function={output_function}.')

        return_values = {}
        return_values.update(output_function=output_function)
        return_values.update(transient_response=self.session.channels[self.channel_id].transient_response.name)

        if output_function in ('DC_VOLTAGE', 'PULSE_VOLTAGE'):
            return_values.update(compensation_frequency=
                                 self.session.channels[self.channel_id].voltage_compensation_frequency)
            return_values.update(gain_bandwidth=self.session.channels[self.channel_id].voltage_gain_bandwidth)
            return_values.update(pole_zero_ratio=self.session.channels[self.channel_id].voltage_pole_zero_ratio)
        elif output_function in ('DC_CURRENT', 'PULSE_CURRENT'):
            return_values.update(compensation_frequency=
                                 self.session.channels[self.channel_id].current_compensation_frequency)
            return_values.update(gain_bandwidth=self.session.channels[self.channel_id].current_gain_bandwidth)
            return_values.update(pole_zero_ratio=self.session.channels[self.channel_id].current_pole_zero_ratio)
        return return_values

    def set_custom_compensation_values(self, compensation_frequency=None, gain_bandwidth=None, pole_zero_ratio=None,
                                       *args, **kwargs):
        """
        Sets one or more of the compensation values that would be used if the present operating mode (DC_VOLTAGE or
        DC_CURRENT) has selected transient_response='CUSTOM'.

        Note that calling with no parameters does not invoke reading back all values as is typical of other methods.
        Use the method get_active_compensation_values() instead.

        get_active_compensation_values() is a separate method because the underlying nidcpower API returns property
        values that may change depending on the setting of transient_response. If transient_response is other than
        'CUSTOM', the return values would not correspond to the values you programmed through this method.

        :param compensation_frequency: The geometric mean of the pole frequency and the zero frequency in Hz. It is the
            frequency of maximum phase shift caused by the pole-zero pair.
        :type compensation_frequency: float
        :param gain_bandwidth: The gain-bandwidth of the SMU channel in Hz.
        :type gain_bandwidth: float
        :param pole_zero_ratio: Sets the ratio of the pole frequency to the zero frequency. A lag compensator has a
            pole-zero ratio set to a value less than 1.0, and a lead compensator has a pole-zero ratio set to a value
            greater than 1.0. If the pole-zero ratio is set to exactly 1.0, the pole and zero cancel each other and have
            no effect. You can set the pole-zero ratio to any value between 0.125 and 8.0.
        :type pole_zero_ratio: float
        :return: None
        """

        self.log_unused_args(args, kwargs)

        output_function = self.session.channels[self.channel_id].output_function.name
        if output_function not in ('DC_VOLTAGE', 'PULSE_VOLTAGE', 'DC_CURRENT', 'PULSE_CURRENT'):
            raise RuntimeError(f'SMU channel {self.channel_id} returned unexpected output_function={output_function}.')

        check_range('compensation_frequency', compensation_frequency, self.compensation_bounds.compensation_frequency)

        if output_function in ('DC_VOLTAGE', 'PULSE_VOLTAGE'):
            check_range('gain_bandwidth', gain_bandwidth, self.compensation_bounds.gain_bandwidth_voltage)
        else:
            check_range('gain_bandwidth', gain_bandwidth, self.compensation_bounds.gain_bandwidth_current)

        check_range('pole_zero_ratio', pole_zero_ratio, self.compensation_bounds.pole_zero_ratio)

        # If we got here, then all provided parameter values are in bounds. Now write them to the instrument.

        self.session.channels[self.channel_id].abort() # Must go to Uncommitted state to program new values.

        if compensation_frequency is not None:
            if output_function in ('DC_VOLTAGE', 'PULSE_VOLTAGE'):
                self.session.channels[self.channel_id].voltage_compensation_frequency = compensation_frequency
            else:
                self.session.channels[self.channel_id].current_compensation_frequency = compensation_frequency

        if gain_bandwidth is not None:
            if output_function in ('DC_VOLTAGE', 'PULSE_VOLTAGE'):
                self.session.channels[self.channel_id].voltage_gain_bandwidth = gain_bandwidth
            else:
                self.session.channels[self.channel_id].current_gain_bandwidth = gain_bandwidth

        if pole_zero_ratio is not None:
            if output_function in ('DC_VOLTAGE', 'PULSE_VOLTAGE'):
                self.session.channels[self.channel_id].voltage_pole_zero_ratio = pole_zero_ratio
            else:
                self.session.channels[self.channel_id].current_pole_zero_ratio = pole_zero_ratio

        self.session.channels[self.channel_id].commit()
        self.session.channels[self.channel_id].initiate()
