from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa


class InstrumentChanList(InstrumentVisa):
    """Extends Instrument class to support instruments whose SCPI commands can include channel lists of the form
        (@1,2,3)
    """

    def __init__(self, visa_resource_name, chan_id_max=None, chan_count_cmd=None, **kwargs):
        """
        Initialize superclass Instrument and setup chan_id_max.

        :param visa_resource_name:  Address in form 'GPIB0::5' or ''USB0::0x0957::0x0907::MY54005712'.
        :type visa_resource_name: str
        :param chan_id_max: Supply value here if instrument has no SCPI query command to obtain number of channels.
        :type chan_id_max: int
        :param chan_count_cmd: Supply SCPI query command to obtain number of channels if instrument has such a command.
            Note that this query could not be done prior to the call to this init because the PyVISA resource to
            communicate with the instrument is not set up until the super call in this init.
        :type chan_count_cmd: str
        :param kwargs: Keyword arguments that are just passed through to the __init__ of the superclass Instrument.
        :type kwargs: various
        """

        super().__init__(visa_resource_name, **kwargs)

        if chan_id_max is not None and chan_count_cmd is None:
            # User can give us an int if channel count is fixed, instr does not support a SCPI query to get chan count.
            if not isinstance(chan_id_max, int) or chan_id_max < 1:
                raise ValueError(f"Bad chan_id_max {chan_id_max}, must be an int > 0.")
            self.channel_id_max = chan_id_max
        elif chan_id_max is None and chan_count_cmd is not None:
            # If instr support SCPI query to get chan count, the caller supplies the cmd string and we do query here.
            # NOTE: Caller can't do the query because PyVisa handle wasn't setup before calling this __init__!
            self.channel_id_max = super().query(chan_count_cmd, int)
        else:
            raise ValueError("Specify either chan_id_max (int) OR chan_id_max_cmd (SCPI cmd str). "
                             "Both cannot be None and you cannot specify both.")

    def query(self, scpi_cmd, rtn_type=None, channels=None):
        """
        Wrapper around pyvisa query to support return type conversion, logging, and instrument simulation. Actually is
        an override of the Instrument class implementation to support multi-channel reads.

        :param scpi_cmd: Command string, you may omit the '?' character on the end
        :type scpi_cmd: str
        :param rtn_type: a Python type to cast the return value, e.g. str, int, float, bool, an enum.
        :type rtn_type: a Python type object
        :param channels: Identifies target channel(s) within the instrument. If cmd is not channel specific,
            use value None.
        :type channels:  None, an int or a List of ints.
        :return: The value(s) returned from the instrument converted (cast) to the specified type. Single values are
            returned as such, multiple values are returned in a List.
        """

        # Needed to do this because types are not serializable through Pyro server.
        # TODO: Solution for passing type from client. VALTECH-493.
        if rtn_type is None:
            rtn_type = str

        if channels is None:
            # Not channel specific, just call the parent class version.
            return super().query(scpi_cmd, rtn_type)

        if not isinstance(channels, list):
            channels = [channels]

        if not (all([isinstance(x, int) and 1 <= x <= self.channel_id_max for x in channels])):
            raise ValueError(f"Bad channels {channels}, should be int values 1 to "
                             f"{self.channel_id_max}. Single value or a list.")

        # Protects against caller omitting '?'. Lot's of code now exists that doesn't provide the '?'.
        scpi_cmd = scpi_cmd.rstrip('?')  # Creates key used for simulation dict.

        cmd_str = f"{scpi_cmd}? {'(@' + f'{channels}'.strip('[]') + ')'}"

        value_str = None  # Can't use '' here, first value read could be '' !
        origins = []  # Indicates if each simulated value came from a prior write or a defaulted value.

        if self.simulated_inst:
            # Build response based on previous writes stored on per channel basis.
            default_rtn_val = str(self.lookup_rtn_default.get(rtn_type, self.lookup_rtn_default[str]))
            for channel in channels:
                if value_str is None:
                    value_str = ''
                else:
                    value_str += ','
                key = f"{channel};" + scpi_cmd
                value_str += self.simbuffer.get(key, default_rtn_val)  # Note this value could be ''.
                if key in self.simbuffer:
                    origins.append('Prior Write')
                else:
                    origins.append('Default')
        else:
            value_str = self.rm_handle.query(cmd_str).strip()   # Remove newline in response.

        if rtn_type is bool:
            rtn_list = [int(v) for v in value_str.split(',')]
        else:
            rtn_list = value_str.split(',')
        rtn_list = [rtn_type(v) for v in rtn_list]

        if len(rtn_list) == 1:
            rtn_list = rtn_list[0]

        if self.log_scpi:
            log_string = f"'{cmd_str}' -> '{value_str}'"
            if self.simulated_inst:
                log_string = f"simulated_inst: {log_string} {origins}"
            self.log.info(log_string)

        return rtn_list

    def write(self, scpi_cmd, value='', channels=None):
        """
        Wrapper around pyvisa query to support return type conversion, logging, and instrument simulation. Actually an
        override of the Instrument class implementation to support broadcasting a write to multiple channels.

        :param scpi_cmd: Command string, you may omit the '?' character on the end
        :type scpi_cmd: str
        :param value: a single value to be written by the command to the instrument.
        :type value: str, int, float
        :param channels: Identifies target channel(s) within the instrument. If cmd is not channel specific,
            use value None.
        :type channels:  None, int, or List of ints.
        :return: None
        """

        if channels is None:
            return super().write(scpi_cmd, value)

        if not isinstance(channels, list):
            channels = [channels]

        if not (all([isinstance(x, int) and 1 <= x <= self.channel_id_max for x in channels])):
            raise ValueError(f"Bad channels {channels}, should be int values 1 to"
                      f" {self.channel_id_max}.")


        #cmd_str = f"{scpi_cmd} {value}, {'(@' + f'{channels}'.strip('[]') + ')'}".rstrip()
        cmd_str = f'{scpi_cmd} {value}'.strip() + f', (@{str(channels).strip("[]")})'.rstrip()

        if self.simulated_inst:
            # Store each channel individually - allows assembling response to future queries which may specify a
            # different channel combination.
            for channel in channels:
                key_prefix = f"{channel};"
                self.simbuffer[key_prefix + scpi_cmd] = f"{value}"
        else:
            self.rm_handle.write(cmd_str)

        if self.log_scpi:
            log_string = f"'{cmd_str}'"
            if self.simulated_inst:
                log_string = 'simulated_inst: ' + log_string
            self.log.info(log_string)


if __name__ == '__main__':
    from cl_instr_lib.helpers.get_rm_handle import get_rm_handle

    inst = InstrumentChanList((1, 2), get_rm_handle('MY54005712'))   # 'MY54005712'
    inst.log_scpi = True
