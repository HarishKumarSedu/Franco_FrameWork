from collections import namedtuple
import time

from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa

namedtuple_min_max = namedtuple('min_max', ['min', 'max'])


class OscopeTekBase(InstrumentVisa):
    """Base class providing functions methods shared by all Tek oscopes: both 5000/7000, MSO4x, MSO5x. """

    def __init__(self, visa_resource_name, logger, **kwargs):
        super().__init__(visa_resource_name, logger, **kwargs)

    # TODO: Display persistence, etc.

    # def cursors(self, kind, source, direction, linked, cursor_units, *args, **kwargs):
    #
    #     # TODO: Not sure if there is any universal way to specify some basic cursor operations.
    #     pass
    #

    def get_inst_errors(self, time_max_sec=2):
        """
        Reads all messages from the oscilloscope error queue. This is an override of the implementation in class
        Instrument because Tek scopes error queue works differently.

        :param time_max_sec: Time limit on loop to empty error queue, in seconds. Defaults to 2 seconds. Precaution
            that we never get stuck in this loop.
        :type time_max_sec: numeric
        :return: Error messages read from instrument error queue.
        :rtype: List[str]
        :raises RuntimeError: If time in loop exceeds time_max_sec without the instrument responding or the buffer
            becoming empty.
        """

        err_list = []
        # time_start = time.monotonic()
        # while (time.monotonic() - time_start) < time_max_sec:
        #     if self.query('*ESR?', bool) is False:  # In sim this will return False if that is sim default for bool.
        #         break
        #     time.sleep(0.10)
        #     err_msg = self.query('EVM?', str)
        #     err_list.append(err_msg)
        # else:
        #     raise RuntimeError(f"Error queue not emptied after {time_max_sec} seconds.")

        # Above is the old code, what we been using for a long time.

        # This is code containing the suggestions from Tek, who allege the above code contains a race condition.

        if self.query('*ESR?', bool):  # In sim this will return False if that is sim default for bool.
            error_msgs = self.query('ALLE?', str).split(',')  # returns all errors in 1 cmd, comma separated
            if self.rm_handle.lock_state:
                self.rm_handle.unlock()

            # Combine the alternating err_codes and descriptions into 1 string per error.
            n = len(error_msgs)
            error_codes = error_msgs[0:n:2]
            error_descriptions = error_msgs[1:n:2]
            for error_code, error_description in zip(error_codes, error_descriptions):
                # MSO[456] puts a '\r' which breaks log_instr_errors.
                error_description = error_description.replace('\r', '').replace('\\0D', '')
                err_list.append(f"{error_code}, {error_description}")

        return err_list

    def wait_for_operation_complete(self, time_max_ms: float):
        """
        Waits for a previously issued command to complete, based on polling BUSY, up to a timeout limit.

        Note that this only works if the previously issued command is one that generates an OPC message, such as
        ACQuire:STATE on, etc. See programmers Manual Table 2-49 (OPC command).

        :param time_max_ms: The maximum length of time to poll in milliseconds.
        :type time_max_ms: int|float
        :return: True if operation completed. False if time_max_seconds has elapsed and the BUSY query is still
            returning 1.
        :rtype: bool

        """

        time_start = time.monotonic()
        while 1000 * (time.monotonic() - time_start) < time_max_ms:
            busy_bit = self.query('BUSY', int)
            if not busy_bit:
                return True
            time.sleep(0.2)
        return False


if __name__ == '__main__':
    # oscope_obj = OscopeTekBase(None)
    # oscope_obj = OscopeTekBase('USB0::0x0699::0x0503::C052180')    # DPO5104B
    oscope_obj = OscopeTekBase('USB0::0x0699::0x374::C010264')   # DPO2024
    oscope_obj.logging = True
