from enum import Enum

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max


class Acquire:

    def __init__(self, scope, **kwargs):
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args

        self.enum_state = Enum('enum_state', {
            'RUN': '1',
            'STOP': '0'
        })
        self.enum_stop_after = Enum('enum_stop_after', {
            'CONTINUOUS': 'RUNSTOP',
            'SINGLE': 'SEQUENCE'
        })
        self.enum_acq_modes = Enum('enum_acq_modes', {
            'SAMPLE': 'SAM',  # Note that inst values are different from newer models.
            'AVERAGE': 'AVE'
        })
        self.bounds_ave_num_wfms = namedtuple_min_max(2, 512)

    # TODO: Docstring might not list correct set of enum values for all models. Look in to redefining dcostring in
    # derived classes.

    def setup(self, state=None, stop_after=None, acq_mode=None, ave_num_wfms=None, *args, **kwargs):
        """
        Query all or set any combination of scope acquisition related parameters.
    
        :param state: 'RUN' or 'STOP"
        :type state: str|enum_state
        :param stop_after: 'CONTINUOUS' or 'SEQUENCE'
        :type stop_after: str|enum_stop_after
        :param acq_mode: 'SAMPLE', 'AVERAGE', 'PEAKDETECT', 'HIRES', 'ENVELOPE'
        :type acq_mode: str|enum_acq_modes
        :param ave_num_wfms: 2 to 10240. Applies only when acq_mode='AVERAGE'.
        :type ave_num_wfms: int
        :return: Query is returned as a dict of parameter name-value pairs.
        """

        # ACQuire:STATE {OFF|ON|RUN|STOP|<NR1>}
        # ACQuire:STOPAfter {RUNSTop|SEQuence}
        # ACQuire:MODe {SAMple|AVErage}
        # ACQuire:NUMAVg <NR1>             # pertains only to AVE mode

        # ACQuire:NUMACq?                  # Query only # TODO: Add separate method for this.

        skip_write = kwargs.pop('skip_write', False)
        self.log_unused_args(args, kwargs)

        if all(v is None for v in (state, stop_after, acq_mode, ave_num_wfms)):
            return_values = {}
            return_values.update(state=self.query("ACQ:STATE?", self.enum_state).name)
            return_values.update(stop_after=self.query("ACQ:STOPA?", self.enum_stop_after).name)
            return_values.update(acq_mode=self.query("ACQ:MOD?", self.enum_acq_modes).name)
            return_values.update(ave_num_wfms=self.query("ACQ:NUMAV?", int))
            return return_values
    
        state = check_enum_str('state', state, self.enum_state)
        stop_after = check_enum_str('stop_after', stop_after, self.enum_stop_after)

        if acq_mode is None:
            acq_mode_state = self.query("ACQ:MOD?", self.enum_acq_modes).name
        else:
            acq_mode = check_enum_str('acq_mode', acq_mode, self.enum_acq_modes)
            acq_mode_state = acq_mode.name
    
        if ave_num_wfms is not None:
            if not(self.bounds_ave_num_wfms.min <= ave_num_wfms <= self.bounds_ave_num_wfms.max):
                raise ValueError(f"Bad ave_num_wfms {ave_num_wfms}, should be {self.bounds_ave_num_wfms.min} to "
                                 f"{self.bounds_ave_num_wfms.max}.")
            if acq_mode_state != self.enum_acq_modes.AVERAGE.name:
                self.log.warning(f"For new ave_num_wfms {ave_num_wfms} to take effect, you must set acq_mode to "
                              f"'{self.enum_acq_modes.AVERAGE.name}'. "
                              f"Present mode is {acq_mode_state}.")

        # A derived class might be using us just for some input checking...
        if skip_write:
            return state, stop_after, acq_mode, ave_num_wfms  # Return to derived class so it can finish check
            # the rest of its parameters.

        if state is not None:
            self.write("ACQ:STATE", state.value)
        if stop_after is not None:
            self.write("ACQ:STOPA", stop_after.value)
        if acq_mode is not None:
            self.write("ACQ:MOD", acq_mode.value)

        if ave_num_wfms is not None:
            self.write("ACQ:NUMAV", ave_num_wfms)
            actual_ave_num_wfms = self.query("ACQ:NUMAV", int)  # Deals with DPO2024 rounding to powers of 2.
            if ave_num_wfms != actual_ave_num_wfms:
                self.log.warning(f"Scope substituted requested ave_num_wfms {ave_num_wfms} with {actual_ave_num_wfms}.")

        self.scope.log_inst_errors()

    def btn_single(self):
        """Equivalent of pushing the Single button on the front panel. Invokes SINGLE acquisition mode and enters
            the RUN state."""

        # ACQuire:STATE {OFF|ON|RUN|STOP|<NR1>}
        # ACQuire:STOPAfter {RUNSTop|SEQuence}
        self.write("ACQ:STOPA", self.enum_stop_after.SINGLE.value)
        self.write("ACQ:STATE", self.enum_state.RUN.value)

    def btn_runstop(self):
        """Equivalent of pushing the Run / Stop button on the front panel. Invokes CONTINUOUS acquisition mode and
            *toggles* the acquisition state."""

        self.write("ACQ:STOPA", self.enum_stop_after.CONTINUOUS.value)
        state = self.query("ACQ:STATE", self.enum_state)
        if state == self.enum_state.RUN:
            self.write("ACQ:STATE", self.enum_state.STOP.value)
        else:
            self.write("ACQ:STATE", self.enum_state.RUN.value)
