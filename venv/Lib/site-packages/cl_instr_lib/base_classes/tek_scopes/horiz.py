from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max


class Horiz:
    def __init__(self, scope, **kwargs):
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.on_off = scope.on_off
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args

        self.bounds_scale = namedtuple_min_max(2e-9, 100)
        self.bounds_delay = namedtuple_min_max(0, 5000)  # sec.
        self._record_lengths = (int(125e3), int(1e6))  # TODO: Replace with namedtuple

    def setup(self, scale=None, delay_mode=None, position_pcnt=None, delay_time=None, record_length=None, *args,
              **kwargs):
        """
        Queries all or sets any combination of horizontal parameters.

        :param scale: seconds per horizontal division
        :param delay_mode: 'OFF' is horiz position as % of record length. 'ON' is delay time from trigger.
        :param position_pcnt: Shifts view of the captured record from 0 to 100 % point. Takes effect when delay_mode is
            'OFF'.
        :param delay_time: Delay in seconds from trigger point. Takes effect when delay_mode is 'ON'.
        :param record_length:
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # HORizontal:MODE:SCAle <NR3>
        # HORizontal:DELay:MODe {OFF|ON|<NR1>}
        # HORizontal:POSition <NR3>
        # HORizontal:DELay:TIMe <NR3>
        # HORizontal:RECOrdlength <NR1>

        # :param record_length: Number of sample points captured per acquisition. Can only be set in MANual mode.

        self.log_unused_args(args, kwargs)

        if all(v is None for v in (scale, delay_mode, position_pcnt, delay_time, record_length)):
            return_values = {}
            return_values.update(scale=self.query("HOR:SCA?", float))
            return_values.update(delay_mode=self.on_off.to_api(self.query("HOR:DEL:MOD", int)))
            return_values.update(position_pcnt=self.query("HOR:POS", float))
            return_values.update(delay_time=self.query("HOR:DEL:TIM", float))
            return_values.update(record_length=self.query("HOR:RECO?", int))
            return return_values

        if scale is not None:
            if not isinstance(scale, (int, float)) or not(self.bounds_scale.min <= scale <= self.bounds_scale.max):
                scale_tmp = min(max(scale, self.bounds_scale.min), self.bounds_scale.max)
                self.log.warning(f"Requested scale {scale} outside range {self.bounds_scale.min} to "
                              f"{self.bounds_scale.max}. Setting to {scale_tmp}.")
                scale = scale_tmp

        if delay_mode is not None and delay_mode not in self.on_off.api_values():
            msg = ", ".join([f"'{x}'" for x in self.on_off.api_values()])
            raise ValueError(f"Bad delay_mode {delay_mode}, should be one of {msg}.")

        if position_pcnt is not None:
            if delay_mode is None:
                delay_mode_state = self.on_off.to_api(self.query('HOR:DEL:MOD?', int))
            else:
                delay_mode_state = delay_mode
            if 'ON' == delay_mode_state:
                self.log.warning(f"Must change delay_mode setting to 'OFF' for position_pcnt to take effect.")
            if not isinstance(position_pcnt, (int, float)) or position_pcnt < 0 or position_pcnt > 100:
                position_pcnt_tmp = min(max(position_pcnt, 0.0), 100.0)
                self.log.warning(f"Bad position_pcnt value {position_pcnt}, setting to {position_pcnt_tmp} percent.")

        if delay_time is not None:
            if delay_mode is None:
                delay_mode_state = self.on_off.to_api(self.query('HOR:DEL:MOD?', int))
            else:
                delay_mode_state = delay_mode
            if 'OFF' == delay_mode_state:
                raise ValueError(f"Cannot set delay time while delay_mode is 'OFF'.")
            if scale is None:
                horiz_delay_min = -10 * self.query("HOR:SCA", float)
            else:
                horiz_delay_min = -10 * scale
            if not isinstance(delay_time, (int, float)) or not(horiz_delay_min <= delay_time <= self.bounds_delay.max):
                delay_time_tmp = min(max(delay_time, horiz_delay_min), self.bounds_delay.max)
                self.log.warning(f"delay_time {delay_time}, outside range {horiz_delay_min:4.1G} (-10 divisions) to "
                              f"{self.bounds_delay.max} sec. Setting to {delay_time_tmp:4.1G}.")
                delay_time = delay_time_tmp

        if record_length is not None:
            if isinstance(self._record_lengths, tuple) and record_length not in self._record_lengths:
                msg = ", ".join([f"{x}" for x in self._record_lengths])
                raise ValueError(f"Bad record_length {record_length}, should be one of {msg}.")
            elif isinstance(self._record_lengths, namedtuple_min_max) and not (
                    self._record_lengths[0] <= record_length <= self._record_lengths[1]):
                raise ValueError(f"Bad record_length {record_length}, should be {self._record_lengths[0]} to "
                                 f"{self._record_lengths[1]}.")

        # If we got here all new values are good, write them to instrument:

        if scale is not None:
            self.write("HOR:SCA", scale)
        if delay_mode is not None:  # Order is important here!
            self.write("HOR:DEL:MOD", self.on_off.to_inst(delay_mode))
        if position_pcnt is not None:
            self.write("HOR:POS", position_pcnt)
        if delay_time is not None:
            self.write("HOR:DEL:TIM", delay_time)
        if record_length is not None:
            self.write("HOR:RECO", int(record_length))

        self.log_inst_errors()
