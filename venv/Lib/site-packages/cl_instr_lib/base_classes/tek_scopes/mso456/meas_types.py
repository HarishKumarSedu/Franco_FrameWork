from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import *

from cl_instr_lib.base_classes.tek_scopes.mso456.meas_types_ABC import MeasTypesABC, RefLevelsSingle, RefLevelsDual

from enum import Enum
from collections import namedtuple
meas_name_pair = namedtuple('meas_name_pair', ['user', 'scpi'])

# ======================================================================================================================
# Derived classes each supporting a group of measurements having a common set of configuration parameters.


class MeasTypePerCycle(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: AMPLITUDE, MAXIMUM, MINIMUM, PK2PK, MEAN, RMS, ACRMS, TOP, BASE,
     AREA, TIMETOMAX, TIMETOMIN.
     """

    enum_meas_per = Enum('enum_meas_per', {'RECORD': 'RECORD', 'CYCLE': 'CYCLE'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        """Called by measurements (our container) to update enum when set of available sources changes.."""

        # Override the superclass version that by default includes digital channels.
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None, meas_per=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.'.
        :type source1: str | enum_meas_sources
        :param meas_per: 'RECORD' or 'CYCLE'.
        :type meas_per: str|enum_meas_per
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:CYCLemode

        if all([v is None for v in (source1, meas_per)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(meas_per=self.query(f"MEASU:MEAS{self._meas_num}:CYCL", self.enum_meas_per).name)
            return return_values

        # User is writing one or more new settings.
        source1 = self.check_source('source1', source1)
        meas_per = check_enum_str('meas_per', meas_per, self.enum_meas_per)

        # All checks passed, now write new settings to scope.
        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if meas_per is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:PERFREQ:EDGE", meas_per.value)

        self.log_inst_errors()


# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeOvershoot(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: POVERSHOOT, NOVERSHOOT.
    """

    enum_meas_per = Enum('enum_meas_per', {'RECORD': 'RECORD', 'CYCLE': 'CYCLE'})
    enum_ref_mode = Enum('enum_ref_mode', {'AUTO': 'AUTO', 'MANUAL': 'MANUAL'})

    bounds_ref_level = min_max_units(-100.0, 100.0, "Volts")

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        """Called by measurements (our container) to push changes to sources."""

        # Override the superclass version that by default includes digital channels.
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None, meas_per=None, ref_mode=None, ref_level=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.'.
        :type source1: str | enum_meas_sources
        :param meas_per: 'RECORD' or 'CYCLE'.
        :type meas_per: str|enum_meas_per
        :param ref_mode: 'AUTO' or 'MANUAL'.
        :type ref_mode: str|enum_ref_mode
        :param ref_level: When ref_mode is 'MANUAL' this voltage is used to determine overshoot.
        :type ref_level: float
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:CYCLemode
        # MEASUrement:MEAS<x>:REFMode
        # MEASUrement:MEAS<x>:REFVoltage

        if all([v is None for v in (source1, meas_per, ref_mode, ref_level)]):
            return_values = {}
            return_values.update(source1=self.query(f'MEASU:MEAS{self._meas_num}:SOU1', self.enum_meas_sources).name)
            return_values.update(meas_per=self.query(f'MEASU:MEAS{self._meas_num}:CYCL', self.enum_meas_per).name)
            return_values.update(ref_mode=self.query(f'MEASU:MEAS{self._meas_num}:REFMODE', self.enum_ref_mode).name)
            return_values.update(ref_level=self.query(f'MEASU:MEAS{self._meas_num}:REFV', float))
            return return_values

        # User is writing one or more new settings.

        source1 = self.check_source('source1', source1)
        meas_per = check_enum_str('meas_per', meas_per, self.enum_meas_per)
        ref_mode = check_enum_str('ref_mode', ref_mode, self.enum_ref_mode)
        check_range('ref_level', ref_level, self.bounds_ref_level)

        # All checks passed, now write new settings to scope.

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if meas_per is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:PERFREQ:EDGE", meas_per.value)

        if ref_mode is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:REFMODE", ref_mode.value)

        if ref_level is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:REFV", ref_level)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypePeriodFreq(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: PERIOD, FREQUENCY.
    """

    enum_edge = Enum('enum_edge', {'FIRST': 'FIRST', 'RISING': 'RISE', 'FALLING': 'FALL'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def configure(self, source1=None, edge=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :param edge: 'FIRST', 'RISING' or 'FALLING'.
        :type edge: str|enum_edge
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:PERFREQ:EDGE

        if all([v is None for v in (source1, edge)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(edge=self.query(f"MEASU:MEAS{self._meas_num}:PERFREQ:EDGE", self.enum_edge).name)
            return return_values

        # User is writing one or more new settings.

        source1 = self.check_source('source1', source1)
        edge = check_enum_str('edge', edge, self.enum_edge)

        # All checks passed, now write new settings to scope.

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:PERFREQ:EDGE", edge.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeBasic(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: UNITINTERVAL, DATARATE, PWIDTH, NWIDTH.

    The configuration for these measurements only has one parameter: source1.
    """

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def configure(self, source1=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<y>, 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :return: Query returns dict containing present setting. Writing returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>

        if source1 is None:
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return return_values

        # User is writing new setting.

        source1 = self.check_source('source1', source1)

        # All checks passed, now write new settings to scope.

        self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeLowHighTime(MeasTypeBasic, RefLevelsSingle):
    """MeasType providing config method for meas_types: LOWTIME, HIGHTIME.

    The configuration for these measurements only has one parameter: source1.
    """

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :type source1: str | enum_meas_sources
        :return: Query returns dict containing present setting. Writing returns None.
        :rtype: dict|None
        """

        # Implementation is same except digital inputs are not allowed.
        return super().configure(source1)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSkewPhase(MeasTypesABC, RefLevelsDual):
    """MeasType providing config method for meas_types: SKEW, PHASE
    """

    enum_from_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})
    enum_to_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH',
                                      'SAME_AS_FROM': 'SAMEAS', 'OPPOSITE_AS_FROM': 'OPPOSITEAS'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def get_badge_info(self):
        """Returns dict of badge info for two source measurements SKEW and PHASE.
        """

        rtn_dict = super().get_badge_info()
        rtn_dict.update(source2=self.query(f'MEASU:MEAS{self._meas_num}:SOUR2'))
        return rtn_dict

    def configure(self, source1=None, source2=None, from_edge=None, to_edge=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :param source2: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source2: str | enum_meas_sources
        :param from_edge: Edge on source1. Choices depend on to_edge, either specified in the same call to this
            method or present oscope state.  If to_edge is one of 'SAME_AS_FROM' or 'OPPOSITE_AS_FROM', then from_edge
            can  only be 'BOTH'. Otherwise, from_edge can be 'RISING' or 'FALLING'.
        :type from_edge: str|enum_from_edge
        :param to_edge: Edge on source2. Choices depend on from_edge, either specified in the same call to this
            method or present oscope state.  If from_edge is one of 'RISING' or  'FALLING' then to_edge can be:
            'RISING', 'FALLING', or 'BOTH'. However, if from_edge is 'BOTH', to_edge must be either 'SAME_AS_FROM' or
            'OPPOSITE_AS_FROM'.
        :type to_edge: str|enum_to_edge
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:FROMedge
        # MEASUrement:MEAS<x>:TOEdge

        if all([v is None for v in (source1, source2, from_edge, to_edge)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(source2=self.query(f"MEASU:MEAS{self._meas_num}:SOU2", self.enum_meas_sources).name)
            return_values.update(from_edge=self.query(f"MEASU:MEAS{self._meas_num}:FROM", self.enum_from_edge).name)
            return_values.update(to_edge=self.query(f"MEASU:MEAS{self._meas_num}:TOE", self.enum_to_edge).name)
            return return_values

        # User is writing one or more new settings.

        #source1 = check_enum_str('source1', source1, self.enum_meas_sources)
        source1 = self.check_source('source1', source1)
        source2 = self.check_source('source2', source2)

        from_edge = check_enum_str('from_edge', from_edge, self.enum_from_edge)
        to_edge = check_enum_str('to_edge', to_edge, self.enum_to_edge)

        from_edge_state = from_edge
        if from_edge is None:
            from_edge_state = self.query(f"MEASU:MEAS{self._meas_num}:FROM", self.enum_from_edge)

        to_edge_state = to_edge
        if to_edge is None:
            to_edge_state = self.query(f"MEASU:MEAS{self._meas_num}:TOE", self.enum_to_edge)

        if from_edge is not None:
            msg = f"Cannot set from_edge='{from_edge.name}' with to_edge='{to_edge_state.name}'. "
            if to_edge_state.name in ('SAME_AS_FROM', 'OPPOSITE_AS_FROM'):
                if from_edge.name != 'BOTH':
                    raise ValueError(msg + " Also set to_edge to 'RISING' or 'FALLING'.")
            else:
                if from_edge.name == 'BOTH':
                    raise ValueError(msg + " Also set to_edge to 'SAME_AS_FROM' or 'OPPOSITE_AS_FROM'.")

        if to_edge is not None:
            msg = f"Cannot set to_edge='{to_edge.name}' with from_edge='{from_edge_state.name}'. "
            if from_edge_state.name != 'BOTH':
                if to_edge.name in ('SAME_AS_FROM', 'OPPOSITE_AS_FROM'):
                    raise ValueError(msg + " Also set from_edge to 'BOTH'.")
            else:
                if to_edge.name not in ('SAME_AS_FROM', 'OPPOSITE_AS_FROM'):
                    raise ValueError(msg + " Also set from_edge to 'RISING' or 'FALLING'.")

        # All checks passed, now write new settings to scope.

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if source2 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU2", source2.value)

        if from_edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:FROM", from_edge.value)

        if to_edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:TOE", to_edge.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeDelay(MeasTypesABC, RefLevelsDual):
    """MeasType providing config method for meas_types: DELAY.
    """
    enum_plot_types = Enum('enum_plot_types', {'HISTOGRAM': 'HISTOGRAM'})

    enum_from_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})
    enum_to_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH',
                                      'SAME_AS_FROM': 'SAMEAS', 'OPPOSITE_AS_FROM': 'OPPOSITEAS'})
    enum_search_dir = Enum('enum_search_dir', {'FORWARD': 'FORWARD', 'BACKWARD': 'BACKWARD'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def get_badge_info(self):
        rtn_dict = super().get_badge_info()
        rtn_dict.update(source2=self.query(f'MEASU:MEAS{self._meas_num}:SOUR2'))
        return rtn_dict

    def configure(self, source1=None, source2=None, from_edge=None, to_edge=None, search_dir=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :param source2: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source2: str | enum_meas_sources
        :param from_edge: Edge on source1. Choices depend on to_edge, either specified in the same call to this
            method or present oscope state.  If to_edge is one of 'SAME_AS_FROM' or 'OPPOSITE_AS_FROM', then from_edge
            can  only be 'BOTH'. Otherwise, from_edge can be 'RISING' or 'FALLING'.
        :type from_edge: str|enum_from_edge
        :param to_edge: Edge on source2. Choices depend on from_edge, either specified in the same call to this
            method or present oscope state.  If from_edge is one of 'RISING' or  'FALLING' then to_edge can be:
            'RISING', 'FALLING', or 'BOTH'. However, if from_edge is 'BOTH', to_edge must be either 'SAME_AS_FROM' or
            'OPPOSITE_AS_FROM'.
        :type to_edge: str|enum_to_edge
        :param search_dir: 'FORWARD' or 'BACKWARD'.
        :type search_dir: str|enum_search_dir
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:FROMedge
        # MEASUrement:MEAS<x>:TOEdge
        # MEASUrement:MEAS<x>:TOEDGESEARCHDIRect

        if all([v is None for v in (source1, source2, from_edge, to_edge, search_dir)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(source2=self.query(f"MEASU:MEAS{self._meas_num}:SOU2", self.enum_meas_sources).name)
            return_values.update(from_edge=self.query(f"MEASU:MEAS{self._meas_num}:FROM", self.enum_from_edge).name)
            return_values.update(to_edge=self.query(f"MEASU:MEAS{self._meas_num}:TOE", self.enum_to_edge).name)
            return_values.update(search_dir=self.query(f"MEASU:MEAS{self._meas_num}:TOEDGESEARCHDIR",
                                                       self.enum_search_dir).name)
            return return_values

        # User is writing one or more new settings.

        source1 = self.check_source('source1', source1)
        source2 = self.check_source('source2', source2)
        search_dir = check_enum_str('search_dir', search_dir, self.enum_search_dir)
        from_edge = check_enum_str('from_edge', from_edge, self.enum_from_edge)
        to_edge = check_enum_str('to_edge', to_edge, self.enum_to_edge)

        from_edge_state = from_edge
        if from_edge is None:
            from_edge_state = self.query(f"MEASU:MEAS{self._meas_num}:FROM", self.enum_from_edge)

        to_edge_state = to_edge
        if to_edge is None:
            to_edge_state = self.query(f"MEASU:MEAS{self._meas_num}:TOE", self.enum_from_edge)

        if from_edge is not None:
            msg = f"Cannot set from_edge='{from_edge.name}' with to_edge='{to_edge_state.name}'. "
            if to_edge_state.name in ('SAME_AS_FROM', 'OPPOSITE_AS_FROM'):
                if from_edge.name != 'BOTH':
                    raise ValueError(msg + " from_edge should be 'BOTH'.")
            else:
                if from_edge.name == 'BOTH':
                    raise ValueError(msg + " from_edge should be 'RISING' or 'FALLING'.")

        if to_edge is not None:
            msg = f"Cannot set to_edge='{to_edge.name}' with from_edge='{from_edge_state.name}'. "
            if from_edge_state.name != 'BOTH':
                if to_edge.name in ('SAME_AS_FROM', 'OPPOSITE_AS_FROM'):
                    raise ValueError(msg + " to_edge should be 'RISING', 'FALLING' or 'BOTH'.")
            else:
                if to_edge.name not in ('SAME_AS_FROM', 'OPPOSITE_AS_FROM'):
                    raise ValueError(msg + " to_edge should be 'SAME_AS_FROM' or 'OPPOSITE_AS_FROM'.")

        # All checks passed, now write new settings to scope.

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if source2 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU2", source2.value)

        if from_edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:FROM", from_edge.value)

        if to_edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:TOE", to_edge.value)

        if search_dir is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:TOEDGESEARCHDIR", search_dir.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------


class MeasTypeRiseFall(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: RISETIME, FALLTIME.
    """

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None, use_clk_recovery=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :type source1: str | enum_meas_sources
        :param use_clk_recovery: Any of the forms: 'ON'/'OFF', 1/0, True/False. query always returns 'ON' / 'OFF'.
        :type use_clk_recovery: str|int|bool
        :return: Query returns dict containing present setting. Writing return None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:TRANSition

        if all([v is None for v in (source1, use_clk_recovery)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            tmp = self.query(f"MEASU:MEAS{self._meas_num}:TRANS", str)
            return_values.update(use_clk_recovery=self.on_off.to_api(tmp))
            return return_values

        # User is writing new setting.

        source1 = self.check_source('source1', source1)
        use_clk_recovery = self.on_off.to_inst(use_clk_recovery)

        # All checks passed, now write new settings to scope.

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if use_clk_recovery is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:TRANS", use_clk_recovery)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeRiseSlew(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: RISESLEWRATE, FALLSLEWRATE.
    """

    enum_from_levels = Enum('enum_from_levels', {'LOW': 'LOW', 'MID': 'MID'})
    enum_to_levels = Enum('enum_to_levels', {'MID': 'MID', 'HIGH': 'HIGH'})
    enum_methods = Enum('enum_methods', {'NOMINAL': 'NOMINAL', 'DDR': 'DDR'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None, from_level=None, to_level=None, method=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :param from_level:  Choices depend on to_level, either specified in the same call to this method or present
            oscope state. 'LOW' or 'MID' may be selected if to_level is 'HIGH', otherwise 'LOW' must be selected if
            to_level is 'MID'.
        :type from_level: str|enum_from_levels
        :param to_level: Choices depend on from_level, either specified in the same call to this method or present
            oscope state. 'MID' or 'HIGH' may be selected if from_level is 'LOW', otherwise 'HIGH' must be selected if
            from_level is 'MID'.
        :type to_level: str|enum_to_levels
        :param method: Aka "Slew Rate Technique": 'NOMINAL' or 'DDR'.
        :type method: str|enum_methods
        :return:
        :rtype:
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:EDGES:FROMLevel
        # MEASUrement:MEAS<x>:EDGES:TOLevel
        # MEASUrement:MEAS<x>:EDGES:SLEWRATEMethod

        if all([v is None for v in (source1, from_level, to_level, method)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(from_level=self.query(f"MEASU:MEAS{self._meas_num}:EDGES:FROML",
                                                       self.enum_from_levels).name)
            return_values.update(to_level=self.query(f"MEASU:MEAS{self._meas_num}:EDGES:TOL",
                                                     self.enum_to_levels).name)
            return_values.update(method=self.query(f"MEASU:MEAS{self._meas_num}:EDGES:SLEWRATEM",
                                                   self.enum_methods).name)

            return return_values

        # User is writing new setting.

        source1 = self.check_source('source1', source1)

        from_level = check_enum_str('from_level', from_level, self.enum_from_levels)
        to_level = check_enum_str('to_level', to_level, self.enum_to_levels)

        from_level_state = from_level
        if from_level_state is None:
            from_level_state = self.query(f"MEASU:MEAS{self._meas_num}:EDGES:FROML", self.enum_from_levels)

        to_level_state = to_level
        if to_level_state is None:
            to_level_state = self.query(f"MEASU:MEAS{self._meas_num}:EDGES:TOL", self.enum_to_levels)

        if to_level_state.name == from_level_state.name:
            if from_level is not None:
                raise ValueError(f"Bad from_level '{from_level.name}', cannot be chosen with to_level "
                                 f"'{to_level_state.name}'. ")
            elif to_level is not None:
                raise ValueError(f"Bad to_level '{to_level.name}', cannot be chosen with from_level "
                                 f"'{from_level_state.name}'. ")

        method = check_enum_str('method', method, self.enum_methods)

        # All checks passed, now write new settings to scope.

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if from_level is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGES:FROML", from_level.value)

        if to_level is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGES:TOL", to_level.value)

        if method is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGES:SLEWRATEM", method.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeFallSlew(MeasTypeRiseSlew, RefLevelsSingle):
    """MeasType providing config method for meas_types: RISESLEWRATE, FALLSLEWRATE.
    """

    enum_from_levels = Enum('enum_to_levels', {'MID': 'MID', 'HIGH': 'HIGH'})
    enum_to_levels = Enum('enum_from_levels', {'LOW': 'LOW', 'MID': 'MID'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def configure(self, source1=None, from_level=None, to_level=None, method=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :param from_level:  Choices depend on to_level, either specified in the same call to this method or present
            oscope state. 'HIGH' or 'MID' may be selected if to_level is 'LOW'; 'HIGH' must be selected if to_level is
            'MID'.
        :type from_level: str|enum_from_levels
        :param to_level: Choices depend on from_level, either specified in the same call to this method or present
            oscope state. 'MID' or 'LOW' may be selected if from_level is 'HIGH', otherwise 'LOW' must be selected if
            from_level is 'MID'.
        :type to_level: str|enum_to_levels
        :param method: Aka "Slew Rate Technique": 'NOMINAL' or 'DDR'.
        :type method: str|enum_methods
        :return:
        :rtype:
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:EDGES:FROMLevel
        # MEASUrement:MEAS<x>:EDGES:TOLevel
        # MEASUrement:MEAS<x>:EDGES:SLEWRATEMethod

        return super().configure(source1, from_level, to_level, method)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeBurstWidth(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: BURSTWIDTH.
    """

    enum_polarity = Enum('enum_polarity', {'NORMAL': 'NORMAL', 'INVERTED': 'INVERTED'})
    bounds_idle_time = min_max_units(0, 1000, 'Seconds')

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def configure(self, source1=None, idle_time=None, polarity=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :param idle_time: Time (in sec) between bursts.
        :type idle_time: float
        :param polarity: Signal level between bursts. 'NORMAL' (low during idle time), 'INVERTED' (high during
            idle_time).
        :type polarity: str|enum_polarity
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:IDLETime
        # MEASUrement:MEAS<x>:POLarity

        if all([v is None for v in (source1, idle_time, polarity)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(idle_time=self.query(f"MEASU:MEAS{self._meas_num}:IDLET", float))
            return_values.update(polarity=self.query(f"MEASU:MEAS{self._meas_num}:POL", self.enum_polarity).name)
            return return_values

        # User is writing new setting.

        source1 = self.check_source('source1', source1)
        polarity = check_enum_str('polarity', polarity, self.enum_polarity)
        check_range('idle_time', idle_time, self.bounds_idle_time)

        if source1 is not None:
            self.write(f'MEASU:MEAS{self._meas_num}:SOU1', source1.value)

        if idle_time is not None:
            self.write(f'MEASU:MEAS{self._meas_num}:IDLET', idle_time)

        if polarity is not None:
            self.write(f'MEASU:MEAS{self._meas_num}:POL', polarity.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------


class MeasTypeDuty(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: PDUTY, NDUTY.
    """
    enum_clk_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def configure(self, source1=None, clk_edge=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :param clk_edge: 'FIRST', 'RISING' or 'FALLING'.
        :type clk_edge: str|enum_edge
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce<x>
        # MEASUrement:MEAS<x>:EDGE<x>

        if all([v is None for v in (source1, clk_edge)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(edge=self.query(f"MEASU:MEAS{self._meas_num}:EDGE1", self.enum_clk_edge).name)
            return return_values

        # User is writing one or more new settings.

        source1 = self.check_source('source1', source1)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)

        # All checks passed, now write new settings to scope.

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)

        if clk_edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGE1", clk_edge.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------


class MeasTypeTimeOutsideLevel(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: TIMEOUTSIDELEVEL
    """

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    enum_mode = Enum('enum_mode', {'ABOVE': 'HIGH', 'BELOW': 'LOW', 'BOTH': 'BOTH'})
    ref_voltage_range = min_max_units(-100.0, 100.0, 'Volts')

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None, mode=None, upper_threshold=None, lower_threshold=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :param mode: Specifies behavior of signal when measurement is to be taken:
            * 'ABOVE' - Time signal spends above upper_threshold value.
            * 'BELOW' - Time signal spends below lower_threshold value.
            * 'BOTH' - Time signal spends above upper_threshold value and below lower_threshold value.
        :type mode: str|enum_mode
        :param upper_threshold: Value in volts.
        :type upper_threshold: float
        :param lower_threshold: Value in volts.
        :type lower_threshold: float
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce1         # Exclude Digital
        # MEASUrement:MEAS<x>:EDGES:LEVel     # Values are HIGH, LOW, BOTH
        # MEASUrement:MEAS<x>:HIGHREFVoltage  # -100V to 100V, scope caps value, no error.
        # MEASUrement:MEAS<x>:LOWREFVoltage   # -100V to 100V, scope caps value, no error.

        if all([v is None for v in (source1, mode, upper_threshold, lower_threshold)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(mode=self.query(f"MEASU:MEAS{self._meas_num}:EDGES:LEV", self.enum_mode).name)
            return_values.update(upper_threshold=self.query(f"MEASU:MEAS{self._meas_num}:HIGHREFV", float))
            return_values.update(lower_threshold=self.query(f"MEASU:MEAS{self._meas_num}:LOWREFV", float))
            return return_values

        source1 = self.check_source('source1', source1)
        mode = check_enum_str('mode', mode, self.enum_mode)
        check_range('lower_threshold', lower_threshold, self.ref_voltage_range)
        check_range('upper_threshold', upper_threshold, self.ref_voltage_range)

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)
        if mode is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGES:LEV", mode.value)
        if upper_threshold is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:HIGHREFV", upper_threshold)
        if lower_threshold is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:LOWREFV", lower_threshold)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSetupHold(MeasTypesABC, RefLevelsDual):
    """MeasType providing config method for meas_types: SETUP, HOLD.
    """

    enum_clk_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})
    enum_data_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def configure(self, source1=None, source2=None, clk_edge=None, data_edge=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :param source2: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source2: str | enum_meas_sources
        :param clk_edge: 'RISING', 'FALLING', 'BOTH'.
        :type clk_edge: str|enum_edge
        :param data_edge:  'RISING', 'FALLING', 'BOTH'.
        :type data_edge: str|enum_edge
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce1
        # MEASUrement:MEAS<x>:SOUrce2
        # MEASUrement:MEAS<x>:EDGE1    # clk_edge
        # MEASUrement:MEAS<x>:EDGE2    # data edge

        if all([v is None for v in (source1, source2, clk_edge, data_edge)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(source2=self.query(f"MEASU:MEAS{self._meas_num}:SOU2", self.enum_meas_sources).name)
            return_values.update(clk_edge=self.query(f"MEASU:MEAS{self._meas_num}:EDGE1", self.enum_clk_edge).name)
            return_values.update(data_edge=self.query(f"MEASU:MEAS{self._meas_num}:EDGE2", self.enum_data_edge).name)
            return return_values

        source1 = self.check_source('source1', source1)
        source2 = self.check_source('source2', source2)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)
        data_edge = check_enum_str('data_edge', data_edge, self.enum_data_edge)

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)
        if source2 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU2", source2.value)
        if clk_edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGE1", clk_edge.value)
        if data_edge is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGE2", data_edge.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeNPeriods(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: NPERIOD.
    """

    enum_sig_type = Enum('enum_signal_type', {'CLOCK': 'CLOCK', 'DATA': 'DATA', 'AUTO': 'AUTO'})
    enum_clk_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})
    num_periods_range = min_max_units(1, 1000000, 'Units')
    edge_increment_range = min_max_units(1, 10000, 'Units')

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    def configure(self, source1=None, signal_type=None, clk_edge=None, num_periods=None, edge_increment=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'CH<x>_D<bit>', 'MATH<x>' or
            'REF<x>'.
        :type source1: str | enum_meas_sources
        :param signal_type: 'CLOCK', 'DATA' or 'AUTO'
        :type signal_type: str|enum_sig_type
        :param clk_edge: To be applicable signal_type, either specified in the same call to this method or the
            present oscope state, must be 'CLOCK' or 'AUTO'. If so, then clk_edge can be: 'RISING', 'FALLING',
            or 'BOTH'.
        :type clk_edge: str|enum_clk_edge
        :param num_periods: Number of periods (cycles) over which to measure the time interval. 1 to 1_000_000.
        :type num_periods: int
        :param edge_increment: 1 to 10_000.
        :type edge_increment: int
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce1
        # MEASUrement:MEAS<x>:SIGNALType  # CLOCK, DATA, AUTO
        # MEASUrement:MEAS<x>:EDGE1       # clk_edge  but only valid when signal_type is CLOCK or AUTO.
        # MEASUrement:MEAS<x>:EDGES:N     # 1 to 1_000_000
        # MEASUrement:MEAS<x>:EDGEIncre   # 1 to 10_000

        if all([v is None for v in (source1, signal_type, clk_edge, num_periods, edge_increment)]):
            return_values = {}
            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(signal_type=self.query(f"MEASU:MEAS{self._meas_num}:SIGNALT", self.enum_sig_type).name)
            return_values.update(clk_edge=self.query(f"MEASU:MEAS{self._meas_num}:EDGE1", self.enum_clk_edge).name)
            return_values.update(num_periods=self.query(f"MEASU:MEAS{self._meas_num}:EDGES:N", float))
            return_values.update(edge_increment=self.query(f"MEASU:MEAS{self._meas_num}:EDGEI", float))
            return return_values

        source1 = self.check_source('source1', source1)
        signal_type = check_enum_str('signal_type', signal_type, self.enum_sig_type)
        clk_edge = check_enum_str('clock_edge', clk_edge, self.enum_clk_edge)
        check_range('num_periods', num_periods, self.num_periods_range)
        check_range('edge_increment', edge_increment, self.edge_increment_range)

        # clk_edge  but only valid when signal_type is CLOCK or AUTO.
        prev_signal_type = self.query(f"MEASU:MEAS{self._meas_num}:SIGNALT", self.enum_sig_type).name

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)
        if signal_type is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SIGNALT", signal_type.value)
        if num_periods is not None:
            self.write(f"MEASU:MEAS{self._meas_num}::EDGES:N", num_periods)
        if edge_increment is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGEI", edge_increment)
        if clk_edge is not None:
            # Only write to the machine if the current or prev signal type is in clock or auto
            if prev_signal_type in ["CLOCK", 'AUTO'] or signal_type.name in ["CLOCK", 'AUTO']:
                self.write(f"MEASU:MEAS{self._meas_num}:EDGE1", clk_edge.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeTie(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: TIE.
    """

    enum_plot_types = Enum('enum_plot_types', {
        'HISTOGRAM': 'HISTOGRAM', 'TIMETREND': 'TIMETREND', 'SPECTRUM': 'SPECTRUM', 'EYEDIAGRAM': 'EYEDIAGRAM',
    })

    enum_sig_type = Enum('enum_signal_type', {'CLOCK': 'CLOCK', 'DATA': 'DATA', 'AUTO': 'AUTO'})
    enum_clk_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None, signal_type=None, clk_edge=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :type source1: str | enum_meas_sources
        :param signal_type: 'CLOCK', 'DATA' or 'AUTO'
        :type signal_type: str|enum_sig_type
        :param clk_edge: To be applicable signal_type, either specified in the same call to this method or the
            present oscope state, must be 'CLOCK' or 'AUTO'. If so, then clk_edge can be: 'RISING', 'FALLING',
            or 'BOTH'.
        :type clk_edge: str|enum_clk_edge
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # MEASUrement:MEAS<x>:SOUrce1    # Exclude Digital
        # MEASUrement:MEAS<x>:SIGNALType # CLOCK, DATA, AUTO
        # MEASUrement:MEAS<x>:EDGE1      # clk_edge  but only valid when signal_type is CLOCK or AUTO.

        if all([v is None for v in (source1, signal_type, clk_edge)]):
            return_values = {}

            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(signal_type=self.query(f"MEASU:MEAS{self._meas_num}:SIGNALT", self.enum_sig_type).name)
            return_values.update(clk_edge=self.query(f"MEASU:MEAS{self._meas_num}:EDGE1", self.enum_clk_edge).name)
            return return_values

        source1 = self.check_source('source1', source1)

        signal_type = check_enum_str('signal_type', signal_type, self.enum_sig_type)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)

        # clk_edge  but only valid when signal_type is CLOCK or AUTO.
        prev_signal_type = self.query(f"MEASU:MEAS{self._meas_num}:SIGNALT", self.enum_sig_type).name

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)
        if signal_type is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SIGNALT", signal_type.value)
        if clk_edge is not None:
            # Only write to the machine if the current or prev signal type is in clock or auto
            if prev_signal_type in ["CLOCK", 'AUTO'] or signal_type.name in ["CLOCK", 'AUTO']:
                self.write(f"MEASU:MEAS{self._meas_num}:EDGE1", clk_edge.value)

        self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypePnoise(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: PHASENOISE.
    """

    enum_plot_types = Enum('enum_plot_types', {
        'HISTOGRAM': 'HISTOGRAM', 'PHASENOISE': 'PHASENOISE',
    })

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        super()._update_meas_source_enum(sources_list, include_digital=False)

    freq_range = min_max_units(0, 1e12, 'Hz')

    def configure(self, source1=None, upper_integ_limit=None, lower_integ_limit=None, smoothing_filter=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :param upper_integ_limit: Upper noise integration limit, in Hz.
        :type upper_integ_limit: float
        :param lower_integ_limit: Lower noise integration limit, in Hz.
        :type lower_integ_limit: float
        :param smoothing_filter: Any of the forms: 'ON'/'OFF', 1/0, True/False. query always returns 'ON' / 'OFF'.
        :type smoothing_filter: str|int|bool
        :return:
        :rtype:
        """

        # MEASUrement:MEAS<x>:SOUrce1    # Exclude Digital
        # MEASUrement:MEAS<x>:EDGES:UPPERFREQuency   # 0 to 1E12, scope caps value at 1E12 no error.
        # MEASUrement:MEAS<x>:EDGES:LOWERFREQuency   # 0 to 1E12, scope caps value at 1E12 no error.
        # MEASURement:MEAS<x>:SMOOTHINGFILTER   # ON/OFF

        if all([v is None for v in (source1, upper_integ_limit, lower_integ_limit, smoothing_filter)]):
            return_values = {}

            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(upper_integ_limit=self.query(f"MEASU:MEAS{self._meas_num}:EDGES:UPPERFREQ", float))
            return_values.update(lower_integ_limit=self.query(f"MEASU:MEAS{self._meas_num}:EDGES:LOWERFREQ", float))
            return_values.update(
                smoothing_filter=self.on_off.to_api(self.query(f"MEASU:MEAS{self._meas_num}:SMOOTHINGFILTER")))
            return return_values

        source1 = self.check_source('source1', source1)
        check_range("lower_integ_limit", lower_integ_limit, self.freq_range)
        check_range("upper_integ_limit", upper_integ_limit, self.freq_range)
        self.on_off.to_inst(smoothing_filter)

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)
        if lower_integ_limit is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGES:LOWERFREQ", lower_integ_limit)
        if upper_integ_limit is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:EDGES:UPPERFREQ", upper_integ_limit)
        if smoothing_filter is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SMOOTHINGFILTER", smoothing_filter)

        self.log_inst_errors()


class MeasTypePJ(MeasTypesABC, RefLevelsSingle):
    """MeasType providing config method for meas_types: PJ.
    """

    enum_plot_types = Enum('enum_plot_types', {
        'HISTOGRAM': 'HISTOGRAM', 'EYEDIAGRAM': 'EYEDIAGRAM',
    })

    enum_sig_type = Enum('enum_signal_type', {'CLOCK': 'CLOCK', 'DATA': 'DATA', 'AUTO': 'AUTO'})
    enum_clk_edge = Enum('enum_edge', {'RISING': 'RISE', 'FALLING': 'FALL', 'BOTH': 'BOTH'})

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        super().__init__(container, attr_name, meas_num, meas_type, **kwargs)

    # noinspection PyMethodOverriding
    def _update_meas_source_enum(self, sources_list):
        super()._update_meas_source_enum(sources_list, include_digital=False)

    def configure(self, source1=None, signal_type=None, clk_edge=None):
        """
        Query or write the configuration parameters for the measurement. Corresponds in the oscope GUI to the CONFIGURE
        panel for this measurement.

        :param source1: Can be any of the currently available signal sources: 'CH<x>', 'MATH<x>' or 'REF<x>'. Note:
            digital probe input not allowed.
        :type source1: str | enum_meas_sources
        :param signal_type: 'CLOCK', 'DATA' or 'AUTO'
        :type signal_type: str|enum_sig_type
        :param clk_edge: To be applicable signal_type, either specified in the same call to this method or the
            present oscope state, must be 'CLOCK' or 'AUTO'. If so, then clk_edge can be: 'RISING', 'FALLING',
            or 'BOTH'.
        :type clk_edge: str|enum_clk_edge
        :return: Query returns dict containing present settings. Writing any value returns None.
        :rtype: dict|None
        """

        # TODO: Pattern detection buttons.

        # MEASUrement:MEAS<x>:SOUrce1    # Exclude Digital
        # MEASUrement:MEAS<x>:SIGNALType # CLOCK, DATA, AUTO
        # MEASUrement:MEAS<x>:EDGE1      # clk_edge  but only valid when signal_type is CLOCK or AUTO.

        if all([v is None for v in (source1, signal_type, clk_edge)]):
            return_values = {}

            return_values.update(source1=self.query(f"MEASU:MEAS{self._meas_num}:SOU1", self.enum_meas_sources).name)
            return_values.update(signal_type=self.query(f"MEASU:MEAS{self._meas_num}:SIGNALT", self.enum_sig_type).name)
            return_values.update(clk_edge=self.query(f"MEASU:MEAS{self._meas_num}:EDGE1", self.enum_clk_edge).name)
            return return_values

        source1 = self.check_source('source1', source1)

        signal_type = check_enum_str('signal_type', signal_type, self.enum_sig_type)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)

        # clk_edge  but only valid when signal_type is CLOCK or AUTO.
        prev_signal_type = self.query(f"MEASU:MEAS{self._meas_num}:SIGNALT", self.enum_sig_type).name

        if source1 is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SOU1", source1.value)
        if signal_type is not None:
            self.write(f"MEASU:MEAS{self._meas_num}:SIGNALT", signal_type.value)
        if clk_edge is not None:
            # Only write to the machine if the current or prev signal type is in clock or auto
            if prev_signal_type in ["CLOCK", 'AUTO'] or signal_type.name in ["CLOCK", 'AUTO']:
                self.write(f"MEASU:MEAS{self._meas_num}:EDGE1", clk_edge.value)

        self.log_inst_errors()
