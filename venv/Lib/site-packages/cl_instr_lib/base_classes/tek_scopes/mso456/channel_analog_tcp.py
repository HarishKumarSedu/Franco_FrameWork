import re
import time

from cl_instr_lib.base_classes.tek_scopes.mso456.channel_analog import ChannelAnalog


class ChannelAnalogTcp(ChannelAnalog):
    """Class providing the controls for an input FlexChannel of a Tektronix MSO[456] series oscilloscope with a
    TCP0030 or TCP0030A probe."""

    def __init__(self, scope, channel_number, **kwargs):
        super().__init__(scope.scope, channel_number, **kwargs)

    def probe_setup(self, probe_range=None, degauss_autozero=None, autozero=None):
        """
        Query range and degauss state or set range and/or execute a degauss on a **current** probe.

        :param probe_range: 'AUTO' or 5 or 30. Units are Amps. A numeric value also sets manual ranging.
        :type probe_range: str|int|float
        :param degauss_autozero: True causes a degauss autozero operation to start. This takes about 26 seconds to
            complete. The start and end of the operation are logged as info messages. An degauss autozero operation
            that does not return a PASSED result raises a RuntimeError.
        :type degauss_autozero: bool
        :param autozero: If True an Auto Zero EXECUTE command is sent to the probe. There does not appear to be any
            SCPI command to return autozero status.
        :type autozero: bool
        :return: Dict with keys 'probe_range', 'degauss_state' reflecting present conditions.
        :rtype: dict
        """

        # CH<x>:PRObe:FORCEDRange <dynamicRangeNR3>
        # CH<x>:PRObe:AUTOZero EXECute
        # CH<x>:PRObe:DEGAUSS EXECute
        # CH<x>:PRObe:DEGAUSS:STATE?

        probe_type = self.query(f'CH{self.channel_number}:PRO:ID:TYP').strip('"')
        if re.match('^TCP0030A{0,1}$', probe_type) is None:
            raise ValueError(f"Invalid probe '{probe_type}' on CH{self.channel_number}. Expected TCP0030, TCP0030A.")

        return_values = {}
        if probe_range is not None:
            if probe_range == 'AUTO':
                self.write(f'CH{self.channel_number}:PROBECO', 'AUTO')
            elif probe_range in (5, 30):
                self.write(f'CH{self.channel_number}:PROBECO', 'MAN')
                self.write(f'CH{self.channel_number}:PRO:FORCEDR', probe_range)
            else:
                raise ValueError(f"Bad probe_range {probe_range}, should be 'AUTO', or numeric 5 or 30 Amps.")

        range_mode = self.query(f'CH{self.channel_number}:PROBECO')
        if range_mode == 'AUTO':
            return_values.update(probe_range='AUTO')
        else:
            return_values.update(probe_range=self.query(f'CH{self.channel_number}:PRO:FORCEDR', float))

        if degauss_autozero:
            pyvisa_timeout = self.scope.rm_handle.timeout
            msg_prefix = f"Degauss operation on channel CH{self.channel_number} TCP0030 probe"
            self.log.info(msg_prefix + ', starting.')
            self.write(f"CH{self.channel_number}:PRO:DEGAUSS", 'EXECUTE')
            degauss_timeout = 40.0
            time_start = time.monotonic()
            self.scope.rm_handle.timeout = 1000 * degauss_timeout
            while (time.monotonic() - time_start) < degauss_timeout:
                # This polling doesn't seem to work as expected because query doesn't return until degauss is done.
                # So pyvisa timeout has to be long enough query doesn't timeout. Gross.
                cmd = f'CH{self.channel_number}:PRO:DEGAUSS:STATE'
                degauss_state = self.query(
                    cmd)  # Seems to block here while degauss, so pyvisa timeout has to be long.
                if degauss_state != 'RUNNING':
                    break
                time.sleep(1)
            else:
                self.scope.rm_handle.timeout = pyvisa_timeout
                raise RuntimeError(f"{msg_prefix},  still running after {degauss_timeout:.2f} sec.")
            if degauss_state == 'PASSED':
                self.log.info(f"{msg_prefix}, state 'PASSED' after {(time.monotonic() - time_start):.2f} sec.")
            else:
                self.scope.rm_handle.timeout = pyvisa_timeout
                raise RuntimeError(f"{msg_prefix}, state '{degauss_state}' after {degauss_timeout:.2f} sec.")

            self.scope.rm_handle.timeout = pyvisa_timeout  # Put back the way it was.

        return_values.update(degauss_state=self.query(f'CH{self.channel_number}:PRO:DEGAUSS:STATE'))

        if autozero is not None:
            self.write(f'CH{self.channel_number}:PRO:AUTOZ', 'EXECUTE')

        self.log_inst_errors()
        return return_values

