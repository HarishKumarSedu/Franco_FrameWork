from enum import Enum
import re
import struct

import numpy as np  # https://numpy.org/
import visa    # For exception definitions

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.decode_ieee_header import decode_ieee_header


class TransferFormatError(Exception):
    def __init__(self, source, encoding, data_width_bytes):
        self.source = source
        self.encoding = encoding
        self.data_width_bytes = data_width_bytes


class WaveformData:

    def __init__(self, scope, **kwargs):
        self.scope = scope

        # Some local attributes that lets us access these more easily and naturally.
        self.log = self.scope.log
        self.write = self.scope.write
        self.query = self.scope.query
        self.log_inst_errors = self.scope.log_inst_errors
        self.log_unused_args = self.scope.log_unused_args

        self._update_waveform_source_enum()

    def _update_waveform_source_enum(self):
        """Creates the enum listing all the possible meas sources based on the current channel, math, ref."""

        sources_list = self.scope.vertical.get_expanded_input_list()

        response = self.query('MATH:LIST')
        if response not in ('NONE', ''):     # oscope may return 'NONE', sim returns ''
            sources_list.extend(response.split(','))

        response = self.query('REF:LIST')
        if response  not in ('NONE', ''):    # oscope may return 'NONE', sim returns ''
            sources_list.extend(response.split(','))

        # Someday, we might enhance this code to handle TLP058 digital inputs.
        include_digital = False
        if include_digital:
            src_dict = dict((src, src) for src in sources_list)
        else:
            pattern = r'CH\d_D\d$'
            src_dict = dict((src, src) for src in sources_list if re.match(pattern, src) is None)

        self.enum_waveform_sources = Enum('enum_waveform_sources', src_dict)

    def _fetch_waveform(self, source, ref_width=None):

        self.scope.write("HEADER 0")
        self.scope.write("DATA:SOUR", f"{source.value}")
        encoding, data_width_bytes, datatype = self._get_data_format_parameters(source, ref_width)

        self.scope.write("DAT:ENC", encoding)
        self.scope.write("WFMO:BYT_N",  f"{data_width_bytes}")
        self.scope.write("DAT:START 1")
        self.scope.write("DAT:STOP 1e10")  # Set data stop to max
        record_length = int(self.scope.query("WFMO:NR_P"))  # Query how many points are actually available
        self.scope.write("DAT:STOP",  f"{record_length}")  # Set data stop to match points available

        # Fetch horizontal scaling factors
        delta_t = float(self.scope.query("WFMO:XINCR"))
        xzero = float(self.scope.query("WFMO:XZERO"))
        pt_off = int(self.scope.query("WFMO:PT_OFF"))
        xunits = self.query('WFMO:XUNI').strip('"')

        # Fetch vertical scaling factors
        ymult = float(self.scope.query("WFMO:YMULT"))
        yzero = float(self.scope.query("WFMO:YZERO"))
        yoff = float(self.scope.query("WFMO:YOFF"))
        yunits = self.query('WFMO:YUNI').strip('"')

        # Fetch waveform data
        self.scope.write("curve?")

        # Data is sent back with ieee defined header.  ie. #41000<binary data bytes>\n

        # This is the simplest way to decode the bytes, but pyro server doesn't like container.
        # PyVISA read_binary_values() method automatically reads and parses the ieee block header for you.
        # unscaled_data = self.scope.rm_handle.read_binary_values(datatype=datatype, is_big_endian=is_big_endian,
        #                                                    container=np.ndarray, header_fmt='ieee',
        #                                                    expect_termination=True)

        # Here's an alternative method

        # Work around lack of a means to determine correct size to use for REF transfer.
        try:
            raw_data = self.scope.read_raw()
        except visa.VisaIOError:
            if source.name.startswith('REF'):
                raise TransferFormatError(source, encoding, data_width_bytes)
            else:
                raise

        num_bytes, data = decode_ieee_header(raw_data[:len(raw_data)-1])
        num_points = num_bytes//data_width_bytes
        fmt = f"<{num_points}{datatype}"
        unscaled_data = struct.unpack(fmt, data)

        data_len = len(unscaled_data)
        # print(f"data_len={data_len}")

        # Create numpy arrays of floating point values for the X and Y axis
        xvalues = np.ndarray(data_len, np.float)
        yvalues = np.ndarray(data_len, np.float)

        t0 = (-pt_off * delta_t) + xzero
        for i in range(0, data_len):
            xvalues[i] = t0 + delta_t * i  # Create timestamp for the data point
            yvalues[i] = float(unscaled_data[i] - yoff) * ymult + yzero  # Convert raw ADC value into a floating point value

        # if display_was_off:
        #     self.write(f"DIS:GLO:{source.value}:STATE", 0)

        return t0, delta_t, xvalues, yvalues, xunits, yunits

    def _get_data_format_parameters(self, source, ref_width=1):
        source_name = source.name
        encoding = 'SRI'
        if source_name.startswith('CH'):
            acq_mode = self.query('ACQ:MOD')
            if acq_mode.startswith(('HIRES', 'AVE')):
                width = 2
            else:
                width = 1
        elif source_name.startswith('MATH'):
            width = 4
        elif source_name.startswith('REF'):
            # REF waveform data points that come from a MATH<x> are 4 bytes (float).
            # But, REF from a CH<x> seem to always be 1 byte, even if they are HIRES or AVE.
            #raise ValueError(f"REF waveform transfer not supported. Scope bug(?) prevents determination of sample size.")

            # This doesn't seem to work, see https://my.tek.com/tektalk/oscilloscopes/7456e2c9-ecb2-ed11-a81b-000d3a598c87
            width = self.query('DATA:WID', int)

            # For testing purposes, this is what it should return.
            #width = 1  # If REF came from a non HIRES or AVE acq.
            # width = 2  # If REF came from a HIRES or AVE acq.
            # width = 4  # If REF came from a MATH
            width = ref_width
        else:
            # This should never happen as caller has already checked this.
            check_enum_str('source', source, self.enum_waveform_sources)  # This will raise the exception.

        if width == 1:
            datatype = 'b'   # aka 'signed char' 1 byte
        elif width == 2:
            datatype = 'h'   # aka 'short' 2 byte signed int
        elif width == 4:
            datatype = 'f'  # aka 32-bit float
            encoding = 'RFB'

        # print(f"source={source_name} {encoding} {width} {datatype}")

        return encoding, width, datatype

    def read_waveforms(self, sources, max_acq_time_ms=2000):
        """
        Starts a new acquisition, and when complete, reads one or more waveforms from the oscope and returns a dict
        containing the xvalues and yvalues for each of the specified waveform sources.

        Note that if sources includes input channels (CH<x>) that are off, these are turned on and then returned to the
        off state after the waveform is acquired. This will cause the oscope screen to flash.

        If multiple sources are specified, the output contains a separate pair of xvalues, yvalues for
        each source. This is done despite the fact that CH<x> sources share a common timescale, because the x-axis for
        MATH<x> or REF<x> sources may be different. Consider a MATH operation that generates a frequency spectrum or a
        REF waveform that was captured using a timescale different from the current setting.

        :param sources: Either a single source specifier, e.g. 'CH1', or a list of sources, e.g.
            ['CH1', 'CH4', 'MATH1', 'REF1']. The set of allowed source specifiers may differ depending on scope model.
            To display the list, do read_waveforms.enum_waveform_sources.<tab> in the Console. Note that the content
            of the enum changes depending on channels, math and ref waveforms configured within in theo scope.
        :type sources: str|enum_waveform_sources
        :param max_acq_time_ms: Time limit on polling the oscope BUSY status to determine when the acquisition
            is complete. An exception is raised if acquisition does not complete before this time limit expires.
            Defaults to 2000ms, but you may need to set this longer when using slow sample rates and/or large record
            sizes.
        :type max_acq_time_ms: int|float
        :return: A dict of dicts, the outer set of keys being the specified sources. The value associated with each
            source key is in turn a dict containing the keys 'xvalues' and 'yvalues'. The values associated with these
            are 1D numpy ndarrays. Pass these to the python list method to obtain an ordinary python list.
        :rtype: Dict[str, Dict[str, ndarray]]
        """

        # Allow for source to be a single source (str or enum) or a list of sources (str or enum).
        was_list = True
        if not isinstance(sources, list):
            sources = [sources]  # Turn a single source into a list.
            was_list = False

        # These scope settings limit what is possible.
        fastacq_enb = self.query('FASTA:STATE', int)
        acq_mode = self.query('ACQ:MOD')
        env_mode_enb = True if acq_mode.startswith('ENV') else False
        wfdb_mode_enb = True if acq_mode.startswith('WFM') else False

        # Updates the enum because we might have new CH<x>, MATH or REF waveforms.
        self._update_waveform_source_enum()

        # Check input for invalid sources, including undefined MATH or REF. Converts any str to enum.
        off_channels = []
        element_name = 'sources'
        for i, source in enumerate(sources):
            if was_list:
                element_name = f"sources[{i}]"  # Makes error message more descriptive.
            sources[i] = check_enum_str(element_name, sources[i], self.enum_waveform_sources)
            if sources[i].name.startswith('CH'):
                if fastacq_enb:
                    raise ValueError(f"Waveform time series data cannot be captured with FastAcq mode enabled.\n"
                                     f"FastAcq produces a pixel map which this code is not written to handle.")
                if wfdb_mode_enb:
                    raise ValueError(f"Waveform time series data cannot be captured using acquisition mode WFMDB.\n"
                                     f"WFMDB produces a pixel map which this code is not written to handle.")
                if env_mode_enb:
                    raise ValueError(f"Waveform time series data cannot be captured using acquisition mode Envelope.\n"
                                     f"Envelope produces min-max pairs this code is not written to handle.")

                if not self.query(f"DIS:GLO:{sources[i].value}:STATE", int):
                    # If channels are specified that are turned off, turn them on.
                    off_channels.append(i)
                    self.write(f"DIS:GLO:{sources[i].value}:STATE", 1)

        # Run the acquisition and wait for it to complete.
        self.write('ACQ:STATE', 'ON')
        complete = self.scope.wait_for_operation_complete(max_acq_time_ms)
        if not complete:
            raise ValueError(f"Acquisition still not complete after {max_acq_time_ms}ms. Try increasing the "
                             f"wait_time_ms parameter or check the oscope acquisition and triggering setups.")

        # Fetch each waveform in turn, build return dict keyed by source names.
        return_dict = {}
        for source in sources:
            if source.name.startswith('REF'):
                # This should not be necessary except for the fact that different samples widths apply depending on
                # how the REF waveform was created: from a CH<x> or from a MATH<x>. There is a bug in the Tek FW
                # that prevents finding out, so this work around.
                # https://my.tek.com/tektalk/oscilloscopes/7456e2c9-ecb2-ed11-a81b-000d3a598c87#1c99d3b4-bdb3-ed11-83fe-000d3a31409d
                ref_widths = [1, 4, 2]
                for i in range(3):
                    try:
                        _, _, xvalues, yvalues, xunits, yunits = self._fetch_waveform(source, ref_widths[i])
                        break
                    except TransferFormatError as err:
                        # print(f"{err.source.name} transfer timed out with ref_width={err.data_width_bytes} bytes.")
                        if i == len(ref_widths)-1:
                            raise
                    except Exception:
                        raise
            else:
                _, _, xvalues, yvalues, xunits, yunits = self._fetch_waveform(source)

            return_dict.update({source.name: {'xvalues': xvalues, 'xunits': xunits, 'yvalues': yvalues,
                                              'yunits': yunits}})

        for i in off_channels:
            # Turn any channels we turned ON back OFF.
            self.write(f"DIS:GLO:{sources[i].value}:STATE", 0)

        return return_dict
