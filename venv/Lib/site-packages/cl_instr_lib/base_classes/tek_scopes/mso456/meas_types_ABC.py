from cl_instr_lib.helpers.check_enum_str import check_enum_str

from abc import ABC, abstractmethod
import re

from enum import Enum
from collections import namedtuple
from urllib.parse import unquote
meas_name_pair = namedtuple('meas_name_pair', ['user', 'scpi'])


class MeasTypesABC(ABC):
    """
    Base class for all of the measurements the user may define in the oscope. This class provides methods common to all
    of the MeasType* classes derived from it.

    Those subclasses provide the configure and other methods that are particular to a specific group of measurement
    types.
    """

    enum_acquisitions = Enum('enum_acquisitions', {'ALL': 'ALLA', 'CURRENT': 'CURR'})
    enum_ref_definitions = Enum('enum_ref_definitions', {'GLOBAL': 'GLOBAL', 'PER_SOURCE': 'PERSOURCE',
                                                         'LOCAL': 'LOCAL'})

    enum_plot_types = Enum('enum_plot_types', {
        'HISTOGRAM': 'HISTOGRAM', 'TIMETREND': 'TIMETREND', 'SPECTRUM': 'SPECTRUM'
    })

    def __init__(self, container, attr_name, meas_num, meas_type, **kwargs):
        self.container = container
        self.scope = container.scope
        self.attr_name = attr_name

        # Some local attributes that lets us access these more easily and naturally.
        self.log = container.scope.log
        self.write = container.scope.write
        self.query = container.scope.query
        self.on_off = container.scope.on_off
        self.log_inst_errors = container.scope.log_inst_errors
        self.log_unused_args = container.scope.log_unused_args
        self.get_inst_errors = container.scope.get_inst_errors

        self._meas_num = meas_num
        self._meas_type = meas_type

        # NOTE: Measurement object will dynamically create attribute enum_meas_sources in here. This allows for
        # redefinition of source choices when TLP058 digital probes is used.

    # Defining as properties to make these read only. If user were to assign to these - big problems!
    @property
    def meas_num(self):
        return self._meas_num

    @property
    def meas_type(self):
        return self._meas_type

    def _update_meas_source_enum(self, sources_list, include_digital=True):
        """Creates the enum listing all the possible meas sources based on the current probe setup."""

        if include_digital:
            src_dict = dict((src, src) for src in sources_list)
        else:
            pattern = r'CH\d_D\d$'
            src_dict = dict((src, src) for src in sources_list if re.match(pattern, src) is None)

        self.enum_meas_sources = Enum('enum_meas_sources', src_dict)

    def check_source(self, name, value):
            self.container._update_source_enums()
            error_template = "Bad {name} '{value}', should be one of: {keys}."
            # If value is an actual enum rather than a string key, the check will fail because the automatic updating
            # modified the enum_meas_sources. Disable displaying the enum in the error message to avoid confusion.
            return check_enum_str(name, value, self.enum_meas_sources, error_template)

    def _reflevels(self, source_id=None, ref_definitions=None, ref_units=None, ref_type=None, high=None, mid=None,
                   low=None, fall_high=None, fall_mid=None, fall_low=None, base_top_from=None, hysteresis=None):
        """
        Helper method used to implement the various possible reflevel scenarios: see the classes RefLevelsSingle and
        RefLevelsDual.
        """

        # LOCAL SETTINGS
        # -----------------

        # Pertains to REFLevels being set in the measurement - independent of sources.
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:FALLHigh  #Manual error here REFLevels<x> omitted. <x> is for 2 src
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:FALLLow
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:FALLMid
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:HYSTeresis
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:RISEHigh
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:RISELow
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:RISEMid
        # MEASUrement:MEAS<x>:REFLevels<x>:ABSolute:TYPE      {SAME|UNIQue}
        # MEASUrement:MEAS<x>:REFLevels<x>:BASETop            {AUTO|MINMax|MEANhistogram| MODEhistogram|EYEhistogram}}
        # MEASUrement:MEAS<x>:REFLevels<x>:METHod             {PERCent|ABSolute}

        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:FALLHigh
        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:FALLLow
        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:FALLMid
        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:HYSTeresis
        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:RISEHigh
        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:RISELow
        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:RISEMid
        # MEASUrement:MEAS<x>:REFLevels<x>:PERCent:TYPE      {TENNinety|TWENtyeighty|CUSTom}

        # MEASUrement:MEAS<x>:REFMode                         {AUTO|MANual}  What is this?

        # MEASUrement:MEAS<x>:GLOBalref    {OFF|ON|0|1}

        return_values = {}

        share_type = self.query('MEASU:REFL:TYPE', self.container.enum_pref_ref_sharing).name  # In user preferences.

        if ref_definitions is None:
            is_shared = self.query(f'MEASU:MEAS{self._meas_num}:GLOB', bool)
            if is_shared:
                share_type = getattr(self.enum_ref_definitions, share_type).name
            else:
                share_type = self.enum_ref_definitions.LOCAL.name
        else:
            ref_definitions = check_enum_str('ref_definitions', ref_definitions, self.enum_ref_definitions)
            if ref_definitions.name != 'LOCAL' and ref_definitions.name != share_type:
                raise ValueError(f"Bad ref_definitions '{ref_definitions.name}', not compatible with present "
                                 f"user_preferences setting '{share_type}'. ")
            share_type = ref_definitions.name

        if ref_definitions is not None:
            # If scope GUI is open to REFERENCE LEVELS for this measurement, this will force display of the reflevels
            # pointed to by ref_definitions.
            if ref_definitions.name in ('GLOBAL', 'PER_SOURCE'):
                self.write(f'MEASU:MEAS{self._meas_num}:GLOB', 1)
            else:
                self.write(f'MEASU:MEAS{self._meas_num}:GLOB', 0)

        if share_type == 'GLOBAL':
            tmp = self.container.reflevels_global(ref_units, ref_type, high, mid, low, fall_high, fall_mid,
                                                  fall_low, base_top_from, hysteresis)
        elif share_type == 'PER_SOURCE':
            owner = self.query(f"MEASU:MEAS{self._meas_num}:SOU{source_id}", self.enum_meas_sources).name
            tmp = self.container.reflevels_per_source(owner, ref_units, ref_type, high, mid, low, fall_high,
                                                     fall_mid, fall_low, base_top_from, hysteresis)
        elif share_type == 'LOCAL':
            owner = f"MEAS{self._meas_num}"
            if all([v is None for v in
                    (ref_units, ref_type, high, mid, low, fall_high, fall_mid, fall_low, base_top_from,
                     hysteresis)]):
                # noinspection PyProtectedMember
                tmp = self.container._reflevels_query(owner, source_id)
            else:
                # noinspection PyProtectedMember
                tmp = self.container._reflevels_write(owner, source_id, ref_units, ref_type, high, mid, low, fall_high,
                                            fall_mid, fall_low, base_top_from, hysteresis)
        else:
            raise RuntimeError(f"Unknown share_type '{share_type}'.")

        if tmp is not None:
            return_values.update(ref_definitions=share_type)
            return_values.update(tmp)
            return return_values

        return return_values

    # TODO: Implement gating
    def gating(self, sharing=None, gating_type=None):
        pass

    # def filter_limit_results(self, high_pass=None, low_pass=None, limit=None, limit_population=None):
    #     pass
    #
    # def pass_fail_testing(self):
    #     pass

    def exists_in_scope(self):
        """Queries the scope and returns True if there is a measurement badge number that corresponds this object.
        This is indicated by to the badge number being the same as the meas_num attribute of this object.

        Returns False if the scope GUI has been used to delete the badge thereby destroying the correspondence
        to this object. Attempts to use this object will then result in a warning and the deletion of this object.
        """

        # print("Checking exists_in_scope")
        meas_list = self.query('MEASU:LIST').split(',')
        rtn_val = f'MEAS{self._meas_num}' in meas_list
        return rtn_val

    def same_type_in_scope(self):
        """Queries the scope and returns True if the measurement badge in the scope identified by this objects meas_num
        attribute is for the type of measurement identified by this objects meas_type attribute.

        Returns False if the scope GUI has been used to re-define the badge measurement type thereby breaking the
        correspondence between the type of this object and the measurement in the scope. Attempts to use this object
        will then result in a warning and the replacement of this object with one of the appropriate class type.
        """

        # print(f"Checking same_type_in_scope")
        meas_type = self.query(f'MEASU:MEAS{self._meas_num}:TYP')
        if meas_type == self.meas_type:
            return True

        return False

    def delete(self):
        """Deletes the measurement badge from the scope that corresponds to this object along with any plots associated
        with it and deletes this object from its containing class.
        """

        self.container.delete_meas(self._meas_num)

    def stats_display(self, on_off=None):
        """
        Query or set the enable for the display of statistics in the measurement badge on the scope GUI.

        :param on_off: Any of the representations: 'ON'/'OFF' (recommended), 1/0, '1'/'0', True/False.
        :type on_off: various
        :return: 'ON' or 'OFF'
        :rtype: str|None
        """

        # MEASUrement:MEAS<x>:DISPlaystat:ENABle

        if on_off is None:
            tmp = self.query(f'MEASU:MEAS{self._meas_num}:DISP:ENAB')
            return self.on_off.to_api(tmp)

        self.write(f'MEASU:MEAS{self._meas_num}:DISP:ENAB', self.on_off.to_inst(on_off))

    def get_plot_nums(self):
        """Returns a list of the plot numbers belonging to this particular particular measurement instance (badge).

        NOTE: All measurements share the same plot number space, so plot numbers are unique across the set of all
        measurements that are active (have badges). Any new plot will be assigned a number 1 greater than the highest
        existing plot number. If a plot is deleted, its number is not reused if any higher numbered plots exist.
        """

        # 'PLOT:LIST'
        # PLOT:LIST?
        # PLOT:PLOT<x>:SOUR
        # PLOT:PLOT<x>:TYPe

        # NOTE: All measurements share the same plot number space. So query is done at container level.
        plot_nums = self.container.get_plot_nums()

        plot_nums_this_meas = []
        src = f'MEAS{self._meas_num}'
        for plot_num in plot_nums:
            # Look through all plots for those whose source is MEAS<meas_num>
            if self.query(f'PLOT:PLOT{plot_num}:SOUR') == src:
                plot_nums_this_meas.append(plot_num)

        return plot_nums_this_meas

    def plot_add(self, plot_type):
        """
        Adds a new plot to the set of plots (if) for this particular measurement instance.

        NOTE: All measurements share the same plot number space and plot numbers are unique across the set of all
        measurements that are active (have badges). The  new plot will be assigned a number 1 greater than the highest
        existing plot number.

        :param plot_type: Identifies the type of plot to be added, the availables types vary depending upon the type of
            measurement. Most basic measurements support 'HISTOGRAM', 'TIMETREND' and "SPECTRUM'. The enum_plot_types
            belonging to the particular measurement class is initialized with the set of allowed plot type names; this
            corresponds to the set of types shown in Configure pop-up of the measurement badge.
        :return: str|enum_plot_types
        """

        # NOTE: All measurements share the same plot number space. So query is done at container level.
        plot_num = self.container.get_next_plot_num()

        plot_type = check_enum_str('plot_type', plot_type, self.enum_plot_types)

        self.write('PLOT:ADDN', f'"PLOT{plot_num}"')
        self.write(f'PLOT:PLOT{plot_num}:TYPE', plot_type.value)
        self.write(f'PLOT:PLOT{plot_num}:SOUR1', f'MEAS{self._meas_num}')

        return plot_num

    def plot_del(self, plot_num):
        """
        Deletes from the oscope display a single plot or 'ALL' of the plots associated with this measurement object.

        :param plot_num: An integer corresponding to one of the plots or the string 'ALL'.
        :type plot_num: int|str
        :return: None
        """

        plot_nums_this_meas = self.get_plot_nums()
        if isinstance(plot_num, str) and plot_num == 'ALL':
            plot_list = plot_nums_this_meas
        elif isinstance(plot_num, int) and plot_num in plot_nums_this_meas:
            plot_list = [plot_num]
        else:
            msg = ', '.join(str(x) for x in plot_nums_this_meas)
            raise ValueError(f"Bad plot_num {plot_num}, should be an int corresponding to one of the plots belonging to"
                             f" MEAS{self._meas_num}: {msg} or 'ALL'.")

        for plot_num in plot_list:
            self.write('PLOT:DEL', f'"PLOT{plot_num}"')

    def label(self, label_str=None):
        """
        Query or set the measurement label of this measurement.

        :param label_str: String to write the oscope.
        :type label_str: str
        :return: Calling with no arguments queries current values from the oscope and returns values as a dict. Dict
            keys are the argument names of this method. Supply one or more input arguments to write value(s) to the
            oscope, in which case this method returns None.
        :rtype: dict|None
        """

        if label_str is None:
            tmp = self.query(f'MEASU:MEAS{self._meas_num}:LAB').strip('"')  # Percent encoded (urlencoded) string.
            return unquote(tmp)

        self.write(f'MEASU:MEAS{self._meas_num}:LAB', f'"{label_str}"')

    def get_badge_info(self):
        """
        Returns basic identifying info that is displayed in the measurement badge: meas_type, label, source1.

        Some measurements may add additional data by implementing an override that calls this method,  appending
        additional keys-values to the return dict. For example, most measurements have one source, but some have two
        sources.

        :return: Dict with keys: meas_type, label, source1
        :rtype: dict
        """

        rtn_dict = {}
        rtn_dict.update(meas_type=self.meas_type)
        rtn_dict.update(label=self.label())
        rtn_dict.update(source1=self.query(f'MEASU:MEAS{self._meas_num}:SOUR1'))
        return rtn_dict

    def get_data(self, acquisitions='ALL'):
        """
        Retrieve data from the periodic measurement system, for specified slot if a measurement has been defined for
        that slot.

        Note that the periodic measurements are performed on an ongoing basis and accumulate statistics over time if
        they are enabled (see meas_display). The periodic measurements are distinct from the immediate measurement
        capability.

        :return: Dictionary containing value and units returned form the scope. The full set of keys are: 'value',
            'mean', 'minimum', 'maximum', 'stddev', 'count'. This complete set of keys-values is returned and is
            valid regardless of the setting of the mode parameter of the statistics_controls method.
        :rtype: dict
        """

        # MEASUrement:MEAS<x>:RESUlts:ALLAcqs:POPUlation?
        # MEASUrement:MEAS<x>:RESUlts:ALLAcqs:MAXimum?
        # MEASUrement:MEAS<x>:RESUlts:ALLAcqs:MEAN?
        # MEASUrement:MEAS<x>:RESUlts:ALLAcqs:MINimum?
        # MEASUrement:MEAS<x>:RESUlts:ALLAcqs:PK2PK?
        # MEASUrement:MEAS<x>:RESUlts:ALLAcqs:STDDev?

        # MEASUrement:MEAS<x>:RESUlts:CURRentacq:POPUlation?
        # MEASUrement:MEAS<x>:RESUlts:CURRentacq:MAXimum?
        # MEASUrement:MEAS<x>:RESUlts:CURRentacq:MEAN?
        # MEASUrement:MEAS<x>:RESUlts:CURRentacq:MINimum?
        # MEASUrement:MEAS<x>:RESUlts:CURRentacq:PK2PK?
        # MEASUrement:MEAS<x>:RESUlts:CURRentacq:STDDev?

        # MEASUrement:MEAS<x>:XUNIT?
        # MEASUrement:MEAS<x>:YUNIT?

        # From 5000
        # MEASUrement:MEAS<x>:UNIts?
        # MEASUrement:MEAS<x>:VALue?

        acquisitions = check_enum_str('acquisitions', acquisitions, self.enum_acquisitions)

        return_values = {}
        return_values.update(mean=self.query(f"MEASU:MEAS{self._meas_num}:RESU:{acquisitions.value}:MEAN", float))
        return_values.update(minimum=self.query(f"MEASU:MEAS{self._meas_num}:RESU:{acquisitions.value}:MIN", float))
        return_values.update(maximum=self.query(f"MEASU:MEAS{self._meas_num}:RESU:{acquisitions.value}:MAX", float))
        return_values.update(pk2pk=self.query(f"MEASU:MEAS{self._meas_num}:RESU:{acquisitions.value}:PK2PK", float))
        return_values.update(stddev=self.query(f"MEASU:MEAS{self._meas_num}:RESU:{acquisitions.value}:STDD", float))
        return_values.update(count=self.query(f"MEASU:MEAS{self._meas_num}:RESU:{acquisitions.value}:POPU", float))

        # In phase measurement, scope returns a degree symbol that crashes the standard query that uses ascii encoding.
        # # TODO: Breaks in simulation where rm_handle is None.
        tmp = self.query(f'MEASU:MEAS{self._meas_num}:YUNIT?', str).strip().strip('"')
        return_values.update(units='' if tmp.isspace() else tmp)

        return return_values

    @abstractmethod
    def configure(self):
        """Each MeasType derived class override this with it particular implementation."""
        pass

# ----------------------------------------------------------------------------------------------------------------------

# Mix-in classes to add reflevel functionality into subclasses derive from meas_types_ABC.
# Some measurements have a single source they operate on: e.g. 'AMPLITUDE' etc.
# Other measurements have two sources they operate on: e.g. 'DELAY', 'PHASE', etc.

class RefLevelsSingle:

    def reflevels(self, ref_definitions=None, ref_units=None, ref_type=None, high=None, mid=None,
                  low=None, fall_high=None, fall_mid=None, fall_low=None, base_top_from=None, hysteresis=None):
        """
        Queries all or sets any of the 10 reference level parameters for a measurement having a single signal source:
        source1.

        *Note that if ref_definitions is selected to be 'GLOBAL' or 'PER_SOURCE', changes made here may propagate into
        other measurements!*

        :param ref_definitions: Selects if reflevels are defined for this particular measurement badge ('LOCAL') or are
            shared. For sharing the options are 'GLOBAL' or 'PER_SOURCE', but must be consistent with
            the ref_sharing value chosen in the user_preferences method of the measurements object (the container of
            this object). Selecting 'GLOBAL' causes any reflevel changes to be propagated to all other
            measurement badges also configured to use 'GLOBAL'. Similarly, selecting 'PER_SOURCE'
            causes reflevel changes to be propagated to all other measurement badges also configured to use 'PER_SOURCE'
            and using the the same source1 input (CH<x>, MATH<x>, or REF<x>).
        :type ref_definitions: str | enum_ref_definitions
        :param ref_units: Determines units used to specify the ref level values:

            * PERCENT - As percentages of the difference between the top and base of the waveform as determined by
              the selected base_top_from algorithm.
            * ABSOLUTE - As voltages.
        :type ref_units: str|enum_ref_units
        :param ref_type: Determines options for defining ref_levels. Allowed choices depend on ref_units as they \
            currently are defined in the instrument or as they are being redefined in the same call to this method.

            * ABS_SAME - Both rising and falling edge thresholds set by voltages high, mid and low. Parameters \
             fall_high, fall_mid, fall_low cannot be used to specify values.
            * ABS_UNIQUE - Rising edge thresholds are voltages high, mid and low. Falling edge thresholds are \
              voltages fall_high, fall_mid and fall_low.
            * PCNT_10_90 - Both rising and falling edge thresholds are the 10%, 50% and 90% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_20_80 - Both rising and falling edge thresholds are the 20%, 50% and 80% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_CUSTOM - Rising and falling edge thresholds can be independently set as percentages of the top to \
             base difference.
        :type ref_type: str|enum_ref_type
        :param high: The high threshold specified in the units defined by ref_units. Applies to rising or both edges
            depending on ref_type.
        :type high: float
        :param mid: The mid threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type mid: float
        :param low: The low threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type low: float
        :param fall_high: The falling edge high threshold specified in the units defined by ref_units. Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_high: float
        :param fall_mid: The falling edge mid threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_mid: float
        :param fall_low: The falling edge low threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_low: float
        :param base_top_from: The method used with PERCENT units to determine the top and base of the waveform

            * AUTO - automatically chooses a reference level method.
            * MINMAX - reference levels are relative to the measurement MIN and MAX.
            * HISTO_MEAN - reference levels are relative to the histogram mean BASE and TOP.
            * HISTO_MODE - reverence levels are relative to the eye histogram BASE and TOP
        :type base_top_from: str|enum_base_top_from
        :param hysteresis: Sets the hysteresis of the ref levels using the same units as ref_units. Percent of top
            base or volts in the case of absolute units.
        :type hysteresis: float
        :return: None
        """

        source_id = 1
        # noinspection PyUnresolvedReferences
        return self._reflevels(source_id, ref_definitions, ref_units, ref_type, high, mid, low, fall_high, fall_mid,
            fall_low, base_top_from, hysteresis)


class RefLevelsDual:

    def reflevels(self, source_id, ref_definitions=None, ref_units=None, ref_type=None, high=None, mid=None,
                  low=None, fall_high=None, fall_mid=None, fall_low=None, base_top_from=None, hysteresis=None):
        """
        Queries all or sets any of the 10 reference level parameters for the specified signal source of a measurement
        having two signal sources: source1 or source2.

        *Note that if ref_definitions is selected to be 'GLOBAL' or 'PER_SOURCE', changes made here may propagate into
        other measurements!*

        :param source_id: 1 for "1st edge" (source1) of the measurement, 2 for "2nd Edge" (source2). Note: In the
            oscope GUI reference levels panel, the highlighting of the "1st Edge"/"2nd Edge" buttons doesn't shift with
            this value, but the values read back or written do correspond to source_id.
        :type source_id: int
        :param ref_definitions: Selects if reflevels for the selected source are defined for this particular
            measurement badge ('LOCAL') or are
            shared. For sharing the options are 'GLOBAL' or 'PER_SOURCE', but must be consistent with
            the ref_sharing value chosen in the user_preferences method of the measurements object (the container of
            this object). Selecting 'GLOBAL' causes any reflevel changes to be propagated to all other
            measurement badges also configured to use 'GLOBAL'. Similarly, selecting 'PER_SOURCE'
            causes reflevel changes to be propagated to all other measurement badges also configured to use 'PER_SOURCE'
            and using the same source input (CH<x>, MATH<x>, or REF<x>).
        :type ref_definitions: str | enum_ref_definitions
        :param ref_units: Determines units used to specify the ref level values:

            * PERCENT - As percentages of the difference between the top and base of the waveform as determined by
              the selected base_top_from algorithm.
            * ABSOLUTE - As voltages.
        :type ref_units: str|enum_ref_units
        :param ref_type: Determines options for defining ref_levels. Allowed choices depend on ref_units as they \
            currently are defined in the instrument or as they are being redefined in the same call to this method.

            * ABS_SAME - Both rising and falling edge thresholds set by voltages high, mid and low. Parameters \
             fall_high, fall_mid, fall_low cannot be used to specify values.
            * ABS_UNIQUE - Rising edge thresholds are voltages high, mid and low. Falling edge thresholds are \
              voltages fall_high, fall_mid and fall_low.
            * PCNT_10_90 - Both rising and falling edge thresholds are the 10%, 50% and 90% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_20_80 - Both rising and falling edge thresholds are the 20%, 50% and 80% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_CUSTOM - Rising and falling edge thresholds can be independently set as percentages of the top to \
             base difference.
        :type ref_type: str|enum_ref_type
        :param high: The high threshold specified in the units defined by ref_units. Applies to rising or both edges
            depending on ref_type.
        :type high: float
        :param mid: The mid threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type mid: float
        :param low: The low threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type low: float
        :param fall_high: The falling edge high threshold specified in the units defined by ref_units. Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_high: float
        :param fall_mid: The falling edge mid threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_mid: float
        :param fall_low: The falling edge low threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_low: float
        :param base_top_from: The method used with PERCENT units to determine the top and base of the waveform

            * AUTO - automatically chooses a reference level method.
            * MINMAX - reference levels are relative to the measurement MIN and MAX.
            * HISTO_MEAN - reference levels are relative to the histogram mean BASE and TOP.
            * HISTO_MODE - reverence levels are relative to the eye histogram BASE and TOP
        :type base_top_from: str|enum_base_top_from
        :param hysteresis: Sets the hysteresis of the ref levels using the same units as ref_units. Percent of top
            base or volts in the case of absolute units.
        :type hysteresis: float
        :return: None
        """

        if source_id not in (1, 2):
            raise ValueError(f"Bad source_id {source_id}, should be 1 or 2.")

        return self._reflevels(source_id, ref_definitions, ref_units, ref_type, high, mid, low, fall_high,
            fall_mid, fall_low, base_top_from, hysteresis)
