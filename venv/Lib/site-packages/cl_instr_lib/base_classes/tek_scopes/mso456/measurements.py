import re
from cl_instr_lib.base_classes.tek_scopes.mso456.meas_types import *

min_max_units = namedtuple('min_max_units', ['min', 'max', 'units'])

# meas_dict mirrors the structure of the ADD MEASUREMENTS dialog in the scope. Also, we could pull this in from a yml
# file or from some query on options installed in the scope.
# Key name must match what is returned from 'MEASU:MEAS<x>:TYPE?'
# Note these are the measurements that are standard on MSO4x.
# If we have an MSO[56]x, we later append TIE and PHASENOISE since those are standard om MSO[56]x.
# If the MSO[56]x has LIC5-DJA license, we also append the contents of meas_dict_dja.
meas_dict = {
    'amplitude': {
        'AMPLITUDE': MeasTypePerCycle,
        'MAXIMUM': MeasTypePerCycle,
        'MINIMUM': MeasTypePerCycle,
        'PK2PK':  MeasTypePerCycle,
        'POVERSHOOT': MeasTypeOvershoot,
        'NOVERSHOOT': MeasTypeOvershoot,
        'MEAN':  MeasTypePerCycle,
        'RMS':  MeasTypePerCycle,
        'ACRMS':  MeasTypePerCycle,
        'TOP':  MeasTypePerCycle,
        'BASE':  MeasTypePerCycle,
        'AREA': MeasTypePerCycle,
    },
    'time': {
        'PERIOD': MeasTypePeriodFreq,
        'FREQUENCY': MeasTypePeriodFreq,
        'UNITINTERVAL': MeasTypeBasic,
        'DATARATE': MeasTypeBasic,
        'PWIDTH':  MeasTypeBasic,
        'NWIDTH':  MeasTypeBasic,
        'SKEW': MeasTypeSkewPhase,
        'PHASE': MeasTypeSkewPhase,
        'DELAY': MeasTypeDelay,
        "RISETIME": MeasTypeRiseFall,
        "FALLTIME": MeasTypeRiseFall,
        "RISESLEWRATE": MeasTypeRiseSlew,
        "FALLSLEWRATE": MeasTypeFallSlew,
        "BURSTWIDTH": MeasTypeBurstWidth,
        "PDUTY": MeasTypeDuty,
        "NDUTY": MeasTypeDuty,
        "TIMEOUTSIDELEVEL": MeasTypeTimeOutsideLevel,
        "SETUP": MeasTypeSetupHold,
        "HOLD": MeasTypeSetupHold,
        "NPERIOD": MeasTypeNPeriods,
        "LOWTIME": MeasTypeLowHighTime,
        "HIGHTIME": MeasTypeLowHighTime,
        "TIMETOMAX": MeasTypePerCycle,
        "TIMETOMIN": MeasTypePerCycle,
    },
}

meas_dict_dja = {
    'jitter': {
        'TIE': MeasTypeTie,
        'PHASENOISE': MeasTypePnoise,
        'PJ': MeasTypePJ
    }
}

class Measurements:
    """Provides methods to configure measurements and retrieve measurement data. This class in intended to be
    composed inside a MSO456 driver."""

    enum_pref_ref_sharing = Enum('enum_pref_ref_sharing', {'GLOBAL': 'GLOBAL', 'PER_SOURCE': 'PERSOURCE'})
    enum_pref_calc_ref = Enum('enum_pref_calc_ref', {'EVERY_ACQ': 'CONTINUOUS', 'FIRST_ACQ': 'LATCH'})
    enum_pref_interp = Enum('enum_pref_interp', {'AUTO': 'AUTO', 'SINX': 'SINX', 'LINEAR': 'LINEAR'})
    enum_pref_annotate = Enum('enum_pref_annotate', {'AUTO': 'AUTO', 'OFF': 'OFF'})

    enum_ref_units = Enum('enum_ref_units', {'PERCENT': 'PERCENT', 'ABSOLUTE': 'ABSOLUTE'})
    enum_ref_type = Enum('enum_ref_type', {'ABS_SAME': 'SAME', 'ABS_UNIQUE': 'UNIQUE',   # Used with ABSOLUTE.
                                           'PCNT_10_90': 'TENNINETY', 'PCNT_20_80': 'TWENTYEIGHTY',
                                           'PCNT_CUSTOM': 'CUSTOM'})
    enum_base_top_from = Enum('enum_base_top_from', {'AUTO': 'AUTO', 'MINMAX': 'MINMAX',
                                                     'HISTO_MEAN': 'MEANHISTOGRAM', 'HISTO_MODE': 'MODEHISTOGRAM'})

    def __init__(self, scope, **kwargs):
        """
        Initializes references to objects in the enclosing scope object, creates enums for the measurement categories
        defined in meas_dict. Creates attributes corresponding to any existing measurement badges in the connected
        oscope.
        """

        # Some local attributes that lets us access these more easily and naturally.
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.on_off = scope.on_off
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args
        self.get_inst_errors = scope.get_inst_errors

        # Process the meas_dict to create a all-in-one dict for easy meas_type to class look-up.
        # Also, create enums for keys of each category. Store these in attributes.
        self._meas_class_dict = {}  # Categories are merged together, to simplify meas_type -> class lookup.
        self._meas_enums = []       # List containing the enums for each category.

        # Logic for MSO[56]x series adds TIE and PHASENOISE as these are standard on those scopes.
        # If we have a MSO4x, this is skipped.
        if re.match(r'MSO[56]\dB?', self.scope.get_model()):
            meas_dict.update({
                'jitter': {
                    'TIE': MeasTypeTie,
                    'PHASENOISE': MeasTypePnoise,
                }
            })
            if 'LIC5-DJA' in self.scope.get_options_dict():
                meas_dict['jitter'].update(meas_dict_dja['jitter'])

        for category_name, category_values in meas_dict.items():
            # Add the meas_type,
            for meas_type, cls in category_values.items():
                self._meas_class_dict.update({meas_type: cls})

            enum_name = f"enum_{category_name}_measurements"
            self.__setattr__(enum_name, Enum(enum_name, list(category_values.keys())))
            self._meas_enums.append(self.__getattribute__(enum_name))

        self._meas_obj_dict = {}  # dict of meas objects, keyed by meas_num. Gets updated as user adds and deletes meas.

        self.update_meas_objs()   # Scans scope for measurement badges, creates composed MeasType objects.

    def __getattribute__(self, item):
        """When an attribute containing a measurement object is accessed, checks if corresponding badge in oscope
        exists and is of the same type.
        """

        item_obj = super().__getattribute__(item)
        if isinstance(item_obj, MeasTypesABC):
            meas_num = item_obj.meas_num
            attr_name = self._make_attr_name(meas_num)

            if not item_obj.exists_in_scope():
                self.log.warn(f"Badge 'Meas {meas_num}' no longer exists in the scope! Deleting driver attribute "
                              f"'{attr_name}'.")
                self.delete_meas(meas_num)
                return None

            if not item_obj.same_type_in_scope():
                meas_type = self.query(f'MEASU:MEAS{meas_num}:TYP')
                self.log.warn(f"Badge 'Meas {meas_num}' appears to have been changed in the scope GUI from measurement "
                              f"type '{item_obj.meas_type}' to '{meas_type}'. Creating new object for driver attribute "
                              f"'{attr_name}'.")
                return self._add_meas_obj(meas_num, meas_type)

        return item_obj

    def _update_source_enums(self):
        """
        Updates the enum_meas_source enum of all MEAS<x> attributes (objects subclasses from MeasTypeABC).

        Intended to be called from other oscope driver subsystems responsible for changes to vertical input channels
        / probes, MATH functions and REF waveforms.  If some of these don't apply to the particular MeasType subclass,
        it's up to the subclass update_meas_sources_enum methods to filter out any non-applicable sources.

        :return: None
        """

        sources_list = self._get_sources_list()

        for meas_num, obj in self._meas_obj_dict.items():
            # noinspection PyProtectedMember
            obj._update_meas_source_enum(sources_list)

    @staticmethod
    def _make_attr_name(meas_num):
        """Centralized creation of attribute name, one place to change format."""
        return f"MEAS{meas_num}"

    def update_meas_objs(self):
        """
        Deletes all MEAS<x> attributes and recreates them based on the measurement badges that currently exist in the
        scope.

        Call this method if you have interacted with the scope GUI to delete or add measurement badges or change the
        measurement type of any existing badges. Also performs a call to vertical.reinit_probes_chans() which updates
        input channel objects based on connected probes and pushes updated source lists in every MEAS<x> object.

        :return: None
        """

        # Clean up the old attributes - because through scope GUI badge may have been deleted or assigned to new type
        # of measurement.
        for meas_nums in self._meas_obj_dict:   # Dict is keyed by numbers.
            delattr(self, self._make_attr_name(meas_nums))
        self._meas_obj_dict = {}

        # For each existing badge, create an object and save as an attribute. Class type depends on type info read from
        # the scope. Setup the enum_meas_sources as appropriate (include digital or not) for meas_tyep.

        # get sources_list once so we don't generate extra bus transactions on every badge.
        sources_list = self._get_sources_list()

        for meas_num in self.get_scope_meas_nums():
            meas_type = self.query(f'MEASU:MEAS{meas_num}:TYP')
            self._add_meas_obj(meas_num, meas_type, sources_list)  # Updates _meas_obj_dict and enum_meas_sources

    def _add_meas_obj(self, meas_num, meas_type, sources_list=None):
        """Create driver MeasType object that is appropriate for meas_type and add that object as an attribute of this
        driver object. Update the dictionary that maps meas_num to the object.

        :return: The name of the newly created attribute.
        :type return: str
        """

        if meas_type in self._meas_class_dict:
            if sources_list is None:
                sources_list = self._get_sources_list()

            cls = self._meas_class_dict[meas_type]           # Get the class type for meas_type
            attr_name = self._make_attr_name(meas_num)       # Get the attribute name
            obj = cls(self, attr_name, meas_num, meas_type)  # Instantiate the child object
            # noinspection PyProtectedMember
            obj._update_meas_source_enum(sources_list)       # Create sources enum in obj, filtered for meas type.
            self._meas_obj_dict[meas_num] = obj              # Add it to the dict, integer meas_num serves as key.
            self.__setattr__(attr_name, obj)                 # Add attribute to hold obj reference.

            return attr_name
        else:
            self.log.warn(f"Skipping MEAS{meas_num} as its type '{meas_type}' is not supported by the driver.")


    def _get_sources_list(self):
        """

        :return: List of all possible measurement sources: input channels (including digital bits), MATH and REF
            waveforms.
        :rtype: List[str]
        """

        sources_list = self.scope.vertical.get_expanded_input_list()

        response = self.query('MATH:LIST')
        if response != 'NONE':
            sources_list.extend(response.split(','))

        response = self.query('REF:LIST')
        if response != 'NONE':
            sources_list.extend(response.split(','))

        return sources_list

    def delete_meas(self, meas_num):
        """
        Delete a measurement(s) and their badge(s) from the scope and delete the corresponding attributes
        ('MEAS<meas_num>') from this driver.

        If one or the other doesn't exist, no error occurs.

        :param meas_num: A int corresponding a a presently defined measurement/badge or the string 'ALL'. The latter
            deletes all presently defined measurements/badges, be careful!
        :type meas_num: int|str
        :return: None
        """

        scope_meas_nums = self.get_scope_meas_nums()

        if isinstance(meas_num, int):
            if meas_num < 1:
                raise ValueError(f"Bad meas_num {meas_num}, should be integer >= 1, or 'ALL'.")
            meas_nums = {meas_num}
        else:
            if meas_num != 'ALL':
                raise ValueError(f"Bad meas_num {meas_num}, should be integer >= 1, or 'ALL'.")
            # Clear out attributes from both this driver and badges from the scope.
            # Form union of the two sets to ensure both are made clean.
            meas_nums = set(scope_meas_nums).union(set(self._meas_obj_dict.keys()))

        for meas_num in meas_nums:
            # On the scope delete the badge if it exists.
            if meas_num in scope_meas_nums:
                self.write('MEASU:DEL', f'"MEAS{meas_num}"')

            # In this driver, remove the entry from the meas_num to obj dict.
            obj = self._meas_obj_dict.pop(meas_num, None)

            if obj is not None:
                # If there was an object, delete the attribute.
                # Note: test this way rather than using hasattr which would trigger code we have in __getattribute__.
                # That would cause recursion.
                attr_name = self._make_attr_name(meas_num)
                delattr(self, attr_name)   # Does not error if attribute does not exist.

    def get_scope_meas_nums(self):
        """
        Queries the scope to see what measurements it has defined, returns list of badge numbers.

        :return: List of badge numbers presently defined in the oscope.
        :rtype: List[int]
        """

        meas_response = self.query('MEASU:LIST')
        if meas_response in ('NONE', ''):    # When simulated inst, '' is returned.
            return []
        else:
            return [int(m[4:]) for m in meas_response.split(',')]

    def get_all_badges_info(self):
        """
        Returns the label and source assignments for all measurement badges that are currently instantiated in the
        oscope.

        :return: Dict with integer keys (the badge numbers) and values which are themselves dictionaries. The second
            level dictionary contains information about the badge, keyed by 'label', 'source1',
            and if applicable 'source2'.
        :rtype: dict
        """

        rtn_dict = {}
        for meas_num, obj in self._meas_obj_dict.items():
            rtn_dict[meas_num] = obj.get_badge_info()

        return rtn_dict

    def add_meas(self, meas_type, meas_num=None, force_delete=False):
        """
        Add a new measurement of the specified type to the oscope (create the badge) and create the appropriate
        attribute / object in this driver to configure it.

        :param meas_type: One of the measurement names defined by the enums enum_<category>_measurements.
            <category> corresponds to the sub-panels of the the scope Measure->ADD MEASUREMENTS dialog, e.g amplitude,
            time, jitter, etc. Accepts enum element or name as a string.
        :type meas_type: str|enum_<category>_measurements
        :param meas_num: If None, oscope assigns new badge a number 1 greater than any existing badge. Otherwise,
            specified badge number is used. If specified meas_num corresponds to an existing badge, badge will be
            overwritten if force_delete is True. meas_num must be > 0.
        :type meas_num: int
        :param force_delete: Defaults to False which protects against overwriting an existing badge when you specify
            meas_num. Set to True to overwrite any existing badge at meas_num.
        :type force_delete: bool
        :return: The name of the attribute corresponding to the badge.
        :rtype: str
        """

        meas_type = self._check_meas_type(meas_type)  # Checks in all categories, returns matching enum element.

        meas_nums = self.get_scope_meas_nums()  # Is empty list if no measurements are defined in the scope.

        if meas_num is None:
            # Add new badge, number is 1 more than the highest existing badge.
            self.write('MEASU:ADDMEAS', meas_type.name)
            meas_num = max(meas_nums) + 1 if len(meas_nums) else 1  # Start at 1 if empty list.
            return self._add_meas_obj(meas_num, meas_type.name)  # Adds attribute / object to this driver.

        # Adding or overwriting a specific badge number.
        if not(isinstance(meas_num, int) and meas_num > 0):
            raise ValueError(f"Bad meas_num {meas_num}, should be int > 0.")

        if meas_num in meas_nums:
            # Badge already exists.
            current_type = self.query(f'MEASU:MEAS{meas_num}:TYP')
            if force_delete:
                self.log.warn(f"Meas {meas_num} for meas_type '{current_type}', being redefined to '{meas_type.name}'.")
                self.delete_meas(meas_num)  # Deletes both the badge on scope and the attribute from this driver.
            else:
                raise ValueError(f"Meas {meas_num} is already defined in scope for meas_type '{current_type}'. "
                                 f"To overwrite it, use force_delete=True.")

        # Make new entry with meas_num the user wants.
        self.write('MEASU:ADDNEW', f'"MEAS{meas_num}"')
        self.write(f'MEASU:MEAS{meas_num}:TYP', meas_type.name)
        return self._add_meas_obj(meas_num, meas_type.name)  # Adds attribute / object to this driver.

    def get_plot_nums(self):
        """
        Returns list of plot numbers in use across the entire set of measurements currently active (have badges in the
        oscope GUI).

        :return: List of plot numbers in use.
        :rtype: List[int]
        """

        # 'PLOT:LIST'
        # PLOT:LIST?

        plot_response = self.query('PLOT:LIST')

        if plot_response == 'NONE':
            return []

        return [int(p[4:]) for p in plot_response.split(',')]

    def get_next_plot_num(self):
        """
        Returns the plot number to be used for the next plot to be created.

        :return: An int 1 greater than the highest value in the list returned by get_plot_nums.
        :rtype: int
        """

        plot_nums = self.get_plot_nums()
        return max(plot_nums) + 1 if len(plot_nums) else 1

    def get_meas_plot_nums(self, meas_num=None):
        """
        Returns a dict showing for each measurement the plot numbers currently belonging to that measurement.

        :param meas_num:
        :type meas_num:
        :return:
        :rtype:
        """

        plot_nums = {}
        if meas_num is None:
            src_re = 'MEAS(\d+)'
        else:
            src_re = f'MEAS({meas_num})'

        for plot_num in self.get_plot_nums():
            plot_src = self.query(f'PLOT:PLOT{plot_num}:SOUR')
            m = re.match(src_re, plot_src)
            if m:
                key = int(m[1])  # The measurement number.
                plot_list = plot_nums.get(key, [])
                plot_list.append(plot_num)
                plot_nums[key] = plot_list

        return plot_nums

    def get_table_nums(self):
        """
        Returns list of table numbers currently visible in the oscope GUI.

        :return: list of table numbers in use.
        :rtype: List[int]
        """

        table_response = self.query('MEASTABle:LIST')

        if table_response == 'NONE':
            return []

        return [int(t[5:]) for t in table_response.split(',')]

    def get_next_table_num(self):
        """
        Return the table number to be used for the next table to be created.

        :return: An int 1 greater than the highest value in the list returned by get_table_nums.
        :rtype: int
        """

        table_nums = self.get_table_nums()
        return max(table_nums) + 1 if len(table_nums) else 1

    def table_add(self):
        """
        Adds a new table to the current set of tables

        :return: table_num
        :rtype: int
        """

        table_num = self.get_next_table_num()

        self.write('MEASTABle:ADDNew', f'"TABLE{table_num}"')

        return table_num

    def table_del(self, table_num):
        """
        Deletes from the oscope display a single table or 'ALL' of the tables

        :param table_num: An integer corresponding to one of the tables or the string 'ALL'.
        :type table_num: int|str
        :return: None
        """

        table_nums = self.get_table_nums()
        if isinstance(table_num, str) and table_num == 'ALL':
            table_list = table_nums
        elif isinstance(table_num, int) and table_num in table_nums:
            table_list = [table_num]
        else:
            msg = ', '.join(str(x) for x in table_nums)
            raise ValueError(f"Bad table_num {table_num}, should be an int corresponding to one of the tables available"
                             f": {msg} or 'ALL'.")

        for table_num in table_list:
            self.write('MEASTABle:DEL', f'"TABLE{table_num}"')

    def _check_meas_type(self, meas_type):
        """
        Checks user input meas_type to see if it corresponds to an element of one of the multiple enums that define the
        various categories of measurements - returns matching enum element if any.

        None type input is just passed through. String input or enum elements are checked against the list of enums and
        the first matching enum element is returned. If no match, then an exception is raise explaining the available
        options.

        :param meas_type: String name or enum element to be checked. May also be None type which is just passed
            through.
        :type meas_type: None|str|enum element
        :return: None|enum element
        """

        if meas_type is None:
            return None

        # For other, we have split into multiple enums to match GUI organization. Have to look in all of them, so
        # can't use check_enum_str because that would raise exception if not in first enum we tried.
        for category in self._meas_enums:
            keys = category.__members__.keys()
            if meas_type in keys:
                return getattr(category, meas_type)  # Input was a string name.
            if meas_type in category:                # Input was an enum element.
                return meas_type

        # Nothing matched. Create error reporting text.

        msg = ''
        for category in self._meas_enums:
            keys = category.__members__.keys()
            key_str = ', '.join([f"'{k}'" for k in keys])
            if len(msg) > 0:
                msg += ';\n'
            msg += f"{category.__name__}: {key_str}"

        if isinstance(meas_type, Enum):
            meas_type = meas_type.name
        raise ValueError(f"Bad meas_type '{meas_type}', can be one of:\n{msg}. ")

    def user_preferences(self, ref_sharing=None, calc_ref=None, interp=None, annotate=None):
        """
        Query all or set any of the items in the MEASUREMENTS section of the oscope USER PREFERENCES dialog.

        :param ref_sharing: Selects how ref level may be shared between measurements, either 'GLOBAL' or
            'PER_SOURCE'. Note that changing this propagates into any currently defined measurement that is not using
            locally defined reference levels.
        :type ref_sharing: str|enum_pref_ref_sharing
        :param calc_ref: When using reference levels defined as a percent of the waveform base-top, this determines
            when that calculation is done. Either 'FIRST_ACQ' or 'EVERY_ACQ'.
        :type calc_ref: str|enum_pref_calc_ref
        :param interp: How the waveform is drawn between data points of the waveform record.

            * AUTO - Selects best interpolation method.
            * SINX - Uses curve fit between points
            * LINEAR - Uses straight line fit between points.
        :type interp: str|enum_pref_interp
        :param annotate: Annotations show the portion of the waveform where the measurement is being performed.
            'AUTO' displays annotations if appropriate for a particular measurement. 'OFF' turns off display of
            annotations.
        :type annotate: str|enum_pref_annotate
        :return: Calling with no arguments queries current values from the oscope and returns values as a dict. Dict
            keys are the argument names of this method. Supply one or more input arguments to write value(s) to the
            oscope, in which case this method returns None.
        :rtype: dict|None
        """

        # Buttons located in USER PREFERENCES->MEASUREMENTS
        # MEASUrement:REFLevels:TYPE     {GLOBal|PERSource}  Changes Global button to Per Source.
        # MEASUrement:REFLevels:MODE   {LATCh|CONTinuous}
        # MEASUrement:INTERp            {AUTO|SINX|LINear}
        # MEASUrement:ANNOTate          {OFF|AUTO}

        if all([v is None for v in (ref_sharing, calc_ref, interp, annotate)]):
            return_values = {}
            return_values.update(ref_sharing=self.query('MEASU:REFL:TYPE', self.enum_pref_ref_sharing).name)
            return_values.update(calc_ref=self.query('MEASU:REFL:MODE', self.enum_pref_calc_ref).name)
            return_values.update(interp=self.query('MEASU:INTER', self.enum_pref_interp).name)
            return_values.update(annotate=self.query('MEASU:ANNOT', self.enum_pref_annotate).name)
            return return_values

        ref_sharing = check_enum_str('ref_sharing', ref_sharing, self. enum_pref_ref_sharing)
        calc_ref = check_enum_str('calc_ref', calc_ref, self.enum_pref_calc_ref)
        interp = check_enum_str('interp', interp, self.enum_pref_interp)
        annotate = check_enum_str('annotate', annotate, self.enum_pref_annotate)

        if ref_sharing is not None:
            self.write('MEASU:REFL:TYPE', ref_sharing.value)
        if calc_ref is not None:
            self.write('MEASU:REFL:MODE', calc_ref.value)
        if interp is not None:
            self.write('MEASU:INTER', interp.value)
        if annotate is not None:
            self.write('MEASU:ANNOT', annotate.value)

    # noinspection PyTypeChecker
    def reflevels_global(self, ref_units=None, ref_type=None, high=None, mid=None, low=None, fall_high=None,
                         fall_mid=None, fall_low=None, base_top_from=None, hysteresis=None):
        """
        Queries all or sets any of the 10 reference level parameters that are shared **Globally**.

        Changes made to Global reference levels propagate into all currently defined measurements in the oscope that
        have Global selected.

        Note that Global reference levels can be accessed within a measurement only when ref_sharing='GLOBAL' is
        selected in user_preferences. This corresponds in the oscope GUI to Utility->USER PREFERENCES->MEASUREMENTS->
        Shared Reference Levels->Global.

        :param ref_units: Determines units used to specify the ref level values:

            * PERCENT - As percentages of the difference between the top and base of the waveform as determined by
              the selected base_top_from algorithm.
            * ABSOLUTE - As voltages.
        :type ref_units: str|enum_ref_units
        :param ref_type: Determines options for defining ref_levels. Allowed choices depend on ref_units as they \
            currently are defined in the instrument or as they are being redefined in the same call to this method.

            * ABS_SAME - Both rising and falling edge thresholds set by voltages high, mid and low. Parameters \
             fall_high, fall_mid, fall_low cannot be used to specify values.
            * ABS_UNIQUE - Rising edge thresholds are voltages high, mid and low. Falling edge thresholds are \
              voltages fall_high, fall_mid and fall_low.
            * PCNT_10_90 - Both rising and falling edge thresholds are the 10%, 50% and 90% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_20_80 - Both rising and falling edge thresholds are the 20%, 50% and 80% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_CUSTOM - Rising and falling edge thresholds can be independently set as percentages of the top to \
             base difference.
        :type ref_type: str|enum_ref_type
        :param high: The high threshold specified in the units defined by ref_units. Applies to rising or both edges
            depending on ref_type.
        :type high: float
        :param mid: The mid threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type mid: float
        :param low: The low threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type low: float
        :param fall_high: The falling edge high threshold specified in the units defined by ref_units. Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_high: float
        :param fall_mid: The falling edge mid threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_mid: float
        :param fall_low: The falling edge low threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_low: float
        :param base_top_from: The method used with PERCENT units to determine the top and base of the waveform

            * AUTO - automatically chooses a reference level method.
            * MINMAX - reference levels are relative to the measurement MIN and MAX.
            * HISTO_MEAN - reference levels are relative to the histogram mean BASE and TOP.
            * HISTO_MODE - reverence levels are relative to the eye histogram BASE and TOP
        :type base_top_from: str|enum_base_top_from
        :param hysteresis: Sets the hysteresis of the ref levels using the same units as ref_units. Percent of top
            base or volts in the case of absolute units.
        :type hysteresis: float
        :return: Calling with no arguments queries current values from the oscope and returns values as a dict. Dict
            keys are the argument names of this method. Supply one or more input arguments to write value(s) to the
            oscope, in which case this method returns None.
        :rtype: dict|None
        """

        # GLOBAL SETTINGS
        # -----------------
        # MEASUrement:REFLevels:ABSolute:FALLHigh
        # MEASUrement:REFLevels:ABSolute:FALLLow
        # MEASUrement:REFLevels:ABSolute:FALLMid
        # MEASUrement:REFLevels:ABSolute:HYSTeresis
        # MEASUrement:REFLevels:ABSolute:RISEHigh
        # MEASUrement:REFLevels:ABSolute:RISELow
        # MEASUrement:REFLevels:ABSolute:RISEMid
        # MEASUrement:REFLevels:ABSolute:TYPE        {SAME|UNIQue}
        # MEASUrement:REFLevels:BASETop
        # MEASUrement:REFLevels:METHod
        # MEASUrement:REFLevels:PERCent:FALLHigh
        # MEASUrement:REFLevels:PERCent:FALLLow
        # MEASUrement:REFLevels:PERCent:FALLMid
        # MEASUrement:REFLevels:PERCent:HYSTeresis
        # MEASUrement:REFLevels:PERCent:RISEHigh
        # MEASUrement:REFLevels:PERCent:RISELow
        # MEASUrement:REFLevels:PERCent:RISEMid
        # MEASUrement:REFLevels:PERCent:TYPE         {TENNinety|TWENtyeighty|CUSTom}

        owner = None
        source_id = None

        if all([v is None for v in (ref_units, ref_type, high, mid, low, fall_high, fall_mid, fall_low, base_top_from,
              hysteresis)]):
            return self._reflevels_query(owner, source_id)

        self._reflevels_write(owner, source_id, ref_units, ref_type, high, mid, low, fall_high, fall_mid, fall_low,
                              base_top_from, hysteresis)

    def reflevels_per_source(self, source, ref_units=None, ref_type=None, high=None, mid=None, low=None, fall_high=None,
                         fall_mid=None, fall_low=None, base_top_from=None, hysteresis=None):
        """
        Queries all or sets any of the 10 reference level parameters of the **specified signal source**.

        Changes made to Per Source reference levels propagate into all currently defined measurements in the oscope that
        have Per Source selected and are using the specific source.

        Note that Per Source reference levels can only be accessed within measurements when the ref_sharing='PER_SOURCE'
        is selected in user_preferences. This corresponds in the oscope GUI to Utility->USER PREFERENCES->MEASUREMENTS->
        Shared Reference Levels->Per Source.

        :param source: A string identifying the source. Required parameter for both query and writing. Can have any of
            the forms:

            * CH<x> - Any of the scope analog input channels, where <x> is input channel number.
            * MATH<x> - Any of the user defined MATH waveforms, where <x> is the MATH id.
            * REF<x>  - Any of the REF waveforms loaded into the oscope, where <x> is the REF id.
        :type source: str
        :param ref_units: Determines units used to specify the ref level values:

            * PERCENT - As percentages of the difference between the top and base of the waveform as determined by
              the selected base_top_from algorithm.
            * ABSOLUTE - As voltages.
        :type ref_units: str|enum_ref_units
        :param ref_type: Determines options for defining ref_levels. Allowed choices depend on ref_units as they \
            currently are defined in the instrument or as they are being redefined in the same call to this method.

            * ABS_SAME - Both rising and falling edge thresholds set by voltages high, mid and low. Parameters \
             fall_high, fall_mid, fall_low cannot be used to specify values.
            * ABS_UNIQUE - Rising edge thresholds are voltages high, mid and low. Falling edge thresholds are \
              voltages fall_high, fall_mid and fall_low.
            * PCNT_10_90 - Both rising and falling edge thresholds are the 10%, 50% and 90% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_20_80 - Both rising and falling edge thresholds are the 20%, 50% and 80% points of the \
                waveform top base difference. Parameters high, mid, low cannot be used to specify values.
            * PCNT_CUSTOM - Rising and falling edge thresholds can be independently set as percentages of the top to \
             base difference.
        :type ref_type: str|enum_ref_type
        :param high: The high threshold specified in the units defined by ref_units. Applies to rising or both edges
            depending on ref_type.
        :type high: float
        :param mid: The mid threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type mid: float
        :param low: The low threshold specified in the units defined by ref_units.  Applies to rising or both edges
            depending on ref_type.
        :type low: float
        :param fall_high: The falling edge high threshold specified in the units defined by ref_units. Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_high: float
        :param fall_mid: The falling edge mid threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_mid: float
        :param fall_low: The falling edge low threshold specified in the units defined by ref_units.  Applies when
            ref_type is ABS_UNIQUE or PCNT_CUSTOM.
        :type fall_low: float
        :param base_top_from: The method used with PERCENT units to determine the top and base of the waveform

            * AUTO - automatically chooses a reference level method.
            * MINMAX - reference levels are relative to the measurement MIN and MAX.
            * HISTO_MEAN - reference levels are relative to the histogram mean BASE and TOP.
            * HISTO_MODE - reverence levels are relative to the eye histogram BASE and TOP
        :type base_top_from: str|enum_base_top_from
        :param hysteresis: Sets the hysteresis of the ref levels using the same units as ref_units. Percent of top
            base or volts in the case of absolute units.
        :type hysteresis: float
        :return: Calling with only the source argument queries current values from the oscope and returns values as a
            dict. Dict keys are the remaining argument names of this method. Supply one or more input arguments to
            write value(s) to the oscope, in which case this method returns None.
        :rtype: dict|None
        """

        owner = source
        source_id = None

        if all([v is None for v in (ref_units, ref_type, high, mid, low, fall_high, fall_mid, fall_low, base_top_from,
              hysteresis)]):
            return self._reflevels_query(owner, source_id)

        self._reflevels_write(owner, source_id, ref_units, ref_type, high, mid, low, fall_high, fall_mid, fall_low,
                              base_top_from, hysteresis)
        # SOURCE SETTINGS
        # ----------------

        # Pertains to source being a particular channel.
        # MEASUrement:CH<x>:REFLevels:ABSolute:FALLHigh
        # MEASUrement:CH<x>:REFLevels:ABSolute:FALLLow
        # MEASUrement:CH<x>:REFLevels:ABSolute:FALLMid
        # MEASUrement:CH<x>:REFLevels:ABSolute:HYSTeresis
        # MEASUrement:CH<x>:REFLevels:ABSolute:RISEHigh
        # MEASUrement:CH<x>:REFLevels:ABSolute:RISELow
        # MEASUrement:CH<x>:REFLevels:ABSolute:RISEMid
        # MEASUrement:CH<x>:REFLevels:ABSolute:TYPE        {SAME|UNIQue}
        # MEASUrement:CH<x>:REFLevels:BASETop              {AUTO|MINMax|MEANhistogram| MODEhistogram|EYEhistogram}}
        # MEASUrement:CH<x>:REFLevels:METHod               {PERCent|ABSolute}
        # MEASUrement:CH<x>:REFLevels:PERCent:FALLHigh
        # MEASUrement:CH<x>:REFLevels:PERCent:FALLLow
        # MEASUrement:CH<x>:REFLevels:PERCent:FALLMid
        # MEASUrement:CH<x>:REFLevels:PERCent:HYSTeresis
        # MEASUrement:CH<x>:REFLevels:PERCent:RISEHigh
        # MEASUrement:CH<x>:REFLevels:PERCent:RISELow
        # MEASUrement:CH<x>:REFLevels:PERCent:RISEMid
        # MEASUrement:CH<x>:REFLevels:PERCent:TYPE         {TENNinety|TWENtyeighty|CUSTom}

        # Pertains to source being result of a math operation on waveforms.
        # MEASUrement:MATH<x>:REFLevels:ABSolute:FALLHigh
        # MEASUrement:MATH<x>:REFLevels:ABSolute:FALLLow
        # MEASUrement:MATH<x>:REFLevels:ABSolute:FALLMid
        # MEASUrement:MATH<x>:REFLevels:ABSolute:HYSTeresis
        # MEASUrement:MATH<x>:REFLevels:ABSolute:RISEHigh
        # MEASUrement:MATH<x>:REFLevels:ABSolute:RISELow
        # MEASUrement:MATH<x>:REFLevels:ABSolute:RISEMid
        # MEASUrement:MATH<x>:REFLevels:ABSolute:TYPE        {SAME|UNIQue}
        # MEASUrement:MATH<x>:REFLevels:BASETop              {AUTO|MINMax|MEANhistogram| MODEhistogram|EYEhistogram}}
        # MEASUrement:MATH<x>:REFLevels:METHod               {PERCent|ABSolute}
        # MEASUrement:MATH<x>:REFLevels:PERCent:FALLHigh
        # MEASUrement:MATH<x>:REFLevels:PERCent:FALLLow
        # MEASUrement:MATH<x>:REFLevels:PERCent:FALLMid
        # MEASUrement:MATH<x>:REFLevels:PERCent:HYSTeresis
        # MEASUrement:MATH<x>:REFLevels:PERCent:RISEHigh
        # MEASUrement:MATH<x>:REFLevels:PERCent:RISELow
        # MEASUrement:MATH<x>:REFLevels:PERCent:RISEMid
        # MEASUrement:MATH<x>:REFLevels:PERCent:TYPE         {TENNinety|TWENtyeighty|CUSTom}

        # Pertains to source being a reference waveform.
        # MEASUrement:REF<x>:REFLevels:ABSolute:FALLHigh
        # MEASUrement:REF<x>:REFLevels:ABSolute:FALLLow
        # MEASUrement:REF<x>:REFLevels:ABSolute:FALLMid
        # MEASUrement:REF<x>:REFLevels:ABSolute:HYSTeresis
        # MEASUrement:REF<x>:REFLevels:ABSolute:RISEHigh
        # MEASUrement:REF<x>:REFLevels:ABSolute:RISELow
        # MEASUrement:REF<x>:REFLevels:ABSolute:RISEMid
        # MEASUrement:REF<x>:REFLevels:ABSolute:TYPE        {SAME|UNIQue}
        # MEASUrement:REF<x>:REFLevels:BASETop              {AUTO|MINMax|MEANhistogram| MODEhistogram|EYEhistogram}}
        # MEASUrement:REF<x>:REFLevels:METHod               {PERCent|ABSolute}
        # MEASUrement:REF<x>:REFLevels:PERCent:FALLHigh
        # MEASUrement:REF<x>:REFLevels:PERCent:FALLLow
        # MEASUrement:REF<x>:REFLevels:PERCent:FALLMid
        # MEASUrement:REF<x>:REFLevels:PERCent:HYSTeresis
        # MEASUrement:REF<x>:REFLevels:PERCent:RISEHigh
        # MEASUrement:REF<x>:REFLevels:PERCent:RISELow
        # MEASUrement:REF<x>:REFLevels:PERCent:RISEMid
        # MEASUrement:REF<x>:REFLevels:PERCent:TYPE         {TENNinety|TWENtyeighty|CUSTom}

    def _reflevels_query(self, owner_id=None, source_id=None):
        """
        Helper function that queries the 10 reference level parameters belonging to the specified owner of the ref
        level, and in the case of measurement locally defined reference levels the 1 or 2 input source signals for the
        measurement.

        Through the use of f-strings, this method supports in excess of 90 different SCPI commands.

        :param owner_id: Defines what appears in the SCPI command after 'MEASU:'. Can be one of

            * None  - Use for the Globally defined thresholds, such SCPI cmds look like 'MEASU:REFL:ABS:FALLH'.
            * CH<x> - Channel specific thresholds, <x> is input channel number, e.g. 'MEASU:CH<x>:REF:ABS:FALLH'.
            * MATH<x> - MATH waveform specific threshold. <x> is the MATH id, e.g. MEASU:MATH<x>:REFL:ABS:FALLH'.
            * REF<x>  - REF waveform specific threshold. <x> is the REF id, e.g. 'MEASU:REF<x>:REFL:ABS:FALLH'.
            * MEASU<x> - Measurement specific threshold. <x> is the measurement badge id, e.g.
                'MEASU:MEAS<x>:REFL<y>:ABS:FALLH'. Here y is value of source_id.
        :type owner_id: str
        :param source_id: Valid only for owner MEASU<x>, specifies source input for those cases where the measurement
            uses multiple sources. Example, DELAY. Typically 1 or 2.
        :type source_id: None|int
        :return: dict with key-value pairs for keys: 'ref_units', 'ref_type', 'high', 'mid', 'low', 'fall_high',
            'fall_mid', 'fall_low', 'base_top_from', 'hysteresis'.
        :rtype: dict
        """

        if owner_id is not None:
            owner = f"{owner_id}:"    # Use for Source or Measurement specific.
        else:
            owner = ""

        if source_id is None:
            source = f"REFL"           # For Global and Source specific.
        else:
            source = f"REFL{source_id}"   # Some measurements (e.g. DELAY, PHASE) have two source signals .

        return_values = {}

        # Used the name "units" for consistency with 5000 series driver, values are 'PERCENT', 'ABSOLUTE'.
        # Determines which SCPI cmds to use for thresholds etc.
        cmd = f'MEASU:{owner}{source}:METHod'
        ref_units = self.query(cmd, self.enum_ref_units).name
        return_values.update(ref_units=ref_units)

        # ref_type defines if we have independent threshold definitions for rising vs falling edges. Depends on
        # 'ref_units'.
        # IF ABSOLUTE, TYPE is: {SAME|UNIQue}. Rising and falling edges share 'SAME' thresholds or are 'ABS_UNIQUE'.
        # If PERCENT, TYPE is: {TENNinety|TWENtyeighty|CUSTom}. Both edges share same preset values or 'CUSTOM' allows
        # for separately defined rising and falling edge thresholds.
        ref_type = self.query(f'MEASU:{owner}{source}:{ref_units}:TYPE', self.enum_ref_type).name
        return_values.update(ref_type=ref_type)

        if ref_units == 'ABSOLUTE' or (ref_units == 'PERCENT' and ref_type == 'PCNT_CUSTOM'):
            # Will be either both edges or just the rising edge.
            return_values.update(high=self.query(f'MEASU:{owner}{source}:{ref_units}:RISEH', float))
            return_values.update(mid=self.query(f'MEASU:{owner}{source}:{ref_units}:RISEM', float))
            return_values.update(low=self.query(f'MEASU:{owner}{source}:{ref_units}:RISEL', float))

            if (ref_units == 'ABSOLUTE' and ref_type == 'ABS_UNIQUE') or \
                    (ref_units == 'PERCENT' and ref_type == 'PCNT_CUSTOM'):
                # falling edge thresholds independent ('ABS_UNIQUE' or 'PCNT_CUSTOM').
                return_values.update(fall_high=self.query(f'MEASU:{owner}{source}:{ref_units}:FALLH', float))
                return_values.update(fall_mid=self.query(f'MEASU:{owner}{source}:{ref_units}:FALLM', float))
                return_values.update(fall_low=self.query(f'MEASU:{owner}{source}:{ref_units}:FALLL', float))

        if ref_units == 'PERCENT':
            return_values.update(base_top_from=self.query(f'MEASU:{owner}{source}:BASET'))

        return_values.update(hysteresis=self.query(f'MEASU:{owner}{source}:{ref_units}:HYST', float))

        return return_values

    def _reflevels_write(self, owner_id=None, source_id=None, ref_units=None, ref_type=None, high=None, mid=None,
                         low=None, fall_high=None, fall_mid=None, fall_low=None, base_top_from=None, hysteresis=None):
        """
        Helper function that writes any combination of the 10 reference level parameters belonging to the specified
        owner of the ref level, and in the case of measurement locally defined reference levels the 1 or 2 input
        source signals for the
        measurement.

        This method supports in excess of 90 different SCPI commands through the use of f-sting substitution.

        :param owner_id: Defines what appears in the SCPI command after 'MEASU:'. Can be one of

            * None  - Use for the Globally defined thresholds, such SCPI cmds look like 'MEASU:REFL:ABS:FALLH'
            * CH<x> - Channel specific thresholds, <x> is input channel number.
            * MATH<x> - MATH waveform specific threshold. <x> is the MATH id.
            * REF<x>  - REF waveform specific threshold. <x> is the REF id.
            * MEASU<x> - Measurement specific threshold.  <x> is the measurement badge id.
        :type owner_id: str
        :param source_id: Valid only for owner MEASU<x>, specifies source input for those cases where the measurement
            uses multiple sources. Example, DELAY. Typically 1 or 2.
        :type source_id: None|int
        :param ref_units: Determines units of ref level values:

            * 'PERCENT' - As a percentage of the difference between the top and base of the waveform. The
                base_top_from parameter chooses one of several methods of determining the top and base.
            * 'ABSOLUTE' - As a voltage value.
        :type ref_units: str|enum_ref_units
        :param ref_type: Determines options for defining ref_levels and is dependent on ref_units:

            * ABS_SAME - With ABSOLUTE units, both rising and falling edge thresholds are set by high, mid and low.
            * ABS_UNIQUE - With ABSOLUTE units,rising edge thresholds are set by high, mid and low; falling edge
                thresholds are set by fall_high, fall_mid and fall_low.
            * PCNT_10_90 - With PERCENT units, both rising and falling edges the 10%, 50% and 90% points of the
                waveform top base difference as the thresholds.
            * PCNT_20_80 - With PERCENT units, both rising and falling edges use 10%, 50% and 90% of top base
                difference as the thresholds.
            * PCNT_CUSTOM - With PERCENT units, rising and falling edge thresholds can be independently set.
        :type ref_type: str|enum_ref_type
        :param high: The high threshold specified in the units defined by ref_units.
        :type high: float
        :param mid: The mid threshold specified in the units defined by ref_units.
        :type mid: float
        :param low: The low threshold specified in the units defined by ref_units.
        :type low: float
        :param fall_high: The high threshold specified in the units defined by ref_units.
        :type fall_high: float
        :param fall_mid: The mid threshold specified in the units defined by ref_units.
        :type fall_mid: float
        :param fall_low: The low threshold specified in the units defined by ref_units.
        :type fall_low: float
        :param base_top_from: The method used with PERCENT units to determine the top and base of the waveform:

            * AUTO - automatically chooses a reference level method.
            * MINMAX - reference levels are relative to the measurement MIN and MAX.
            * HISTO_MEAN - reference levels are relative to the histogram mean BASE and TOP.
            * HISTO_MODE - reverence levels are relative to the eye histogram BASE and TOP
        :type base_top_from: str|enum_base_top_from
        :param hysteresis: Sets the hysteresis of the ref levels using the same units as ref_units. Percent of top
            base or volts in the case of absolute units.
        :type hysteresis: float
        :return: None
        """

        if owner_id is not None:
            owner = f"{owner_id}:"    # Use for Source or Measurement specific.
        else:
            owner = ""

        if source_id is None:
            source = f"REFL"           # For Global and Source specific.
        else:
            source = f"REFL{source_id}"   # Some measurements (e.g. DELAY, PHASE) have two source signals .

        # ref_units choose 'PERCENT' or 'ABSOLUTE' ref levels.
        ref_units_obj = check_enum_str('ref_units', ref_units, self.enum_ref_units)
        ref_units_state = ref_units_obj
        if ref_units_state is None:
            ref_units_state = self.query(f'MEASU:{owner}{source}:METH', self.enum_ref_units)

        # ref_type defines if we have independent threshold definitions for rising vs falling edges.
        # Depends on 'ref_units'.
        # IF ABSOLUTE, TYPE is: {SAME|UNIQue}. Rising and falling edges share 'SAME' thresholds or are 'ABS_UNIQUE'.
        # If PERCENT, TYPE is: {TENNinety|TWENtyeighty|CUSTom}. Both edges share same preset values or 'CUSTOM' allows

        ref_type_obj = check_enum_str('ref_type', ref_type, self.enum_ref_type)
        ref_type_state = ref_type_obj
        if ref_type_state is None:
            ref_type_state = self.query(f'MEASU:{owner}{source}:{ref_units_state.value}:TYPE', self.enum_ref_type)

        # Check for conflicts in user input.
        if ref_type_obj is not None:
            # IF ABSOLUTE, TYPE is: {SAME|UNIQue}. Rising and falling edges share 'SAME' thresholds or are 'ABS_UNIQUE'.
            # If PERCENT, TYPE is: {TENNinety|TWENtyeighty|CUSTom}. Both edges share same preset values or 'CUSTOM'
            # allows for separately defined rising and falling edge thresholds.
            if ref_units_state.name == 'ABSOLUTE':
                valid_options = ('ABS_SAME', 'ABS_UNIQUE')
            else:
                valid_options = ('PCNT_10_90', 'PCNT_20_80', 'CUSTOM')
            if ref_type_obj.name not in valid_options:
                msg = ', '.join(valid_options)
                raise ValueError(f"Bad ref_type '{ref_type_obj.name}. For ref_units '{ref_units_state.name}' valid "
                                 f"ref_types are: {msg}.")

        scope = locals()
        # Check for appropriate use of ref level inputs for the rising edge and also for the falling edge
        # if ref_type='SAME'.
        names = ('high', 'mid', 'low')
        indices = [i for i, name in enumerate(names) if eval(name, scope) is not None]
        if len(indices) > 0:
            if ref_units_state.name == 'PERCENT':
                if ref_type_state.name != 'PCNT_CUSTOM':
                    # Check that user hasn't chosen both numeric value(s) AND preset ref levels.
                    msg = ', '.join([f"{names[i]}={eval(names[i], scope):0.3f}" for i in indices])
                    raise ValueError(f"Ref level(s) ({msg}) cannot be used with preset ref_type "
                                     f"'{ref_type_state.name}'. Change ref_type to 'PCNT_CUSTOM' to enter your own "
                                     f"ref levels.")
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(0, 100, '%'))
            else:
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(-100, 100, 'V'))

        # These are used in the scope for the falling edge if ref_type='ABS_UNIQUE' or 'PCNT_CUSTOM'.
        names = ('fall_high', 'fall_mid', 'fall_low')
        indices = [i for i, name in enumerate(names) if eval(name, scope) is not None]
        if len(indices) > 0:
            if ref_type_state.name not in ('ABS_UNIQUE', 'PCNT_CUSTOM'):
                msg = ', '.join([f"{names[i]}={eval(names[i], scope):0.3f}" for i in indices])
                new_type = 'ABS_UNIQUE' if ref_units_state.name == 'ABSOLUTE' else 'PCNT_CUSTOM'
                raise ValueError(f"Ref level(s) ({msg}) cannot be used with ref_type '{ref_type_state.name}'. "
                                 f"Change ref_type to '{new_type}' to configure falling edge ref levels.")

            if ref_units_state.name == 'PERCENT':
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(0, 100, '%'))
            else:
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(-100, 100, 'V'))

        base_top_from_obj = check_enum_str('base_top_from', base_top_from, self.enum_base_top_from)
        if base_top_from_obj is not None:
            if ref_units_state.name != 'PERCENT':
                raise ValueError(f"base_top_from is not a choice with ref_units '{ref_units_obj.name}', "
                                 f"only 'PERCENT'.")

        if ref_units_state.name == 'PERCENT':
            check_range('hysteresis', hysteresis, min_max_units(0, 100, '%'))
        else:
            check_range('hysteresis', hysteresis, min_max_units(-100, 100, 'V'))

        # End of input validation checks - now write to the scope.

        # if ref_shared is not None:
        #     if ref_shared_obj.name == 'LOCAL':
        #         self.write(f'MEASU:{owner}:GLOB', 0)
        #     else:
        #         self.write(f'MEASU:{owner}:GLOB', 1)  # GLOBAL or PER_SOURCE depending on current user preference

        if ref_units is not None:
            self.write(f'MEASU:{owner}{source}:METHod', ref_units_obj.value)

        if ref_type is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:TYPE', ref_type_obj.value)

        if high is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:RISEH', high)
        if mid is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:RISEM', mid)
        if low is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:RISEL', low)

        if fall_high is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:FALLH', fall_high)
        if fall_mid is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:FALLM', fall_mid)
        if fall_low is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:FALLL', fall_low)

        if base_top_from is not None:
            self.write(f'MEASU:{owner}{source}:BASET', base_top_from_obj.value)

        if hysteresis is not None:
            self.write(f'MEASU:{owner}{source}:{ref_units_state.value}:HYST', hysteresis)

        self.log_inst_errors()
