from cl_instr_lib.base_classes.tek_scopes.mso456.oscope_channel import OscopeChannel

class ChannelTlp058(OscopeChannel):
    """Class providing the controls for an input FlexChannel of a Tektronix MSO[456] series oscilloscope with a
    TLP058 Logic Probe connected.

    Provides a config method for the overall channel. In addition, provides 8 attributes D0..D7 representing each
    individual bit input of the probe. These objects are of the class `BitTlp058`_.
    """

    num_bits = 8

    def __init__(self, scope, channel_number, **kwargs):
        super().__init__(scope, channel_number, **kwargs)

        self.view_number = 1

        # Create bit objects. Explicitly create attribute names rather than dynamically so stub files can be created
        # in the validation framework enabling autocomplete in the pycharm editor.
        self.D0 = BitTlp058(self, 0)
        self.D1 = BitTlp058(self, 1)
        self.D2 = BitTlp058(self, 2)
        self.D3 = BitTlp058(self, 3)
        self.D4 = BitTlp058(self, 4)
        self.D5 = BitTlp058(self, 5)
        self.D6 = BitTlp058(self, 6)
        self.D7 = BitTlp058(self, 7)

    def config(self, display=None, label=None, state_all_bits=None, set_all_thresholds=None):
        """
        Queries or sets the configuration options of the entire channel.

        :param display: Turn on or off the display of all 8 bits of the probe. Accepts 'ON', 1, or True; 'OFF', 0,
            False. Returns 'ON' or 'OFF'.
        :type display: str|int|bool
        :param label: Text describing the channel (group of 8 bits).
        :type label: str
        :param state_all_bits: Turn 'ON' or 'OFF' all of the individual bits. Accepts 'ON', 1, or True; 'OFF', 0,
            False. A query returns 'ON' or 'OFF' only if all bits are in the same state, otherwise returns None. This
            allows restoring state by calling config with the keyword dict returned from a previous query.
        :type state_all_bits: str|None
        :param set_all_thresholds: Sets all the bits to the specified threshold value, -40 to +40V. A query returns a
            float only if all 8 bits share the same threshold value. This allows restoring state by calling config with
            the keyword dict returned from a previous query.
        :type set_all_thresholds: float|None
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        # DISplay:GLObal:CH<x>:STATE {<NR1>|OFF|ON}   # turn on or off entire channel (top display btn)
        # CH<x>_DALL:LABel:NAMe
        # DISplay:WAVEView<x>:CH<x>_D<x>:STATE
        # DIGGRP<x>:D<x>:THReshold

        # TODO: Find SCPI cmd for controlling height of display.

        if all([v is None for v in (display, label, state_all_bits, set_all_thresholds)]):
            return_values = {}
            return_values.update(display=self.on_off.to_api(self.query(f"DIS:GLO:CH{self.channel_number}:STATE", int)))
            tmp = self.query(f"CH{self.channel_number}_DALL:LAB:NAM", str).strip('"').strip()
            return_values.update(label='' if tmp.isspace() else tmp)

            states = 0
            thresholds = []
            for bit in range(self.num_bits):
                states += self.query(f"DIS:WAVEV{self.view_number}:CH{self.channel_number}_D{bit}:STATE",
                                    int)
                thresholds.append(self.query(f"DIGGRP{self.channel_number}:D{bit}:THR", str))

            if states == 0:
                return_values.update(state_all_bits=self.on_off.to_api(0))
            elif states == self.num_bits:
                return_values.update(state_all_bits=self.on_off.to_api(1))
            else:
                return_values.update(state_all_bits=None)

            if all([v == thresholds[0] for v in thresholds[1:]]):
                return_values.update(set_all_thresholds=float(thresholds[0]))
            else:
                return_values.update(set_all_thresholds=None)

            return return_values

        display = self.on_off.to_inst(display)
        state_all_bits = self.on_off.to_inst(state_all_bits)

        if set_all_thresholds is not None:
            if not(isinstance(set_all_thresholds, (int, float))) or not(-40 <= set_all_thresholds <= 40):
                raise ValueError(f"Bad set_all_thresholds {set_all_thresholds} V, should be -40 to +40 V.")

        if display is not None:
            self.write(f"DIS:GLO:CH{self.channel_number}:STATE", display)
        if label is not None:
            self.write(f"CH{self.channel_number}_DALL:LAB:NAM", f'"{label}"')
        if state_all_bits is not None:
            for bit in range(self.num_bits):
                self.write(f"DIS:WAVEV{self.view_number}:CH{self.channel_number}_D{bit}:STATE", state_all_bits)
        if set_all_thresholds is not None:
            for bit in range(self.num_bits):
                self.write(f"DIGGRP{self.channel_number}:D{bit}:THR", set_all_thresholds)

        self.log_inst_errors()

class BitTlp058:
    """Class representing an individual bit of a TLP058 Logic probe.

    This is the class of the 8 bit attributes (D0...D8) composed within a ChannelTlp058 object.
    """

    def __init__(self, channel, bit_number):
        self.channel = channel
        self.log = channel.log
        self.write = channel.write
        self.query = channel.query
        self.on_off = channel.on_off
        self.log_inst_errors = channel.log_inst_errors
        self.log_unused_args = channel.log_unused_args

        self.view_number = channel.view_number
        self.channel_number = channel.channel_number
        self.bit_number = bit_number
        self.bit_name = f"D{bit_number}"

    def config(self, state=None, threshold=None, label=None):
        """
        Queries or sets the parameters associated with one of the individual bits of the TLP058 digital probe.

        :param state: Turn on or off the display of the bit. Accepts 'ON', 1, or True; 'OFF', 0, False. Returns 'ON'
            or 'OFF'.
        :type state: str|int|bool
        :param threshold: Sets the logic threshold, -40 to +40V.
        :type threshold: float
        :param label: Text describing the bit.
        :type label: str
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict | None
        """

        # DISplay:WAVEView<x>:CH<x>_DALL:STATE {<NR1>|OFF|ON}
        # DIGGRP<x>:D<x>:THReshold <NR3>
        # CH<x>_D<x>:LABel:NAMe <QString>

        if all([v is None for v in (state, threshold, label)]):
            return_values = {}
            cmd = f"DIS:WAVEV{self.view_number}:CH{self.channel_number}_D{self.bit_number}:STATE"
            return_values.update(state=self.on_off.to_api(self.query(cmd, int)))

            cmd = f"DIGGRP{self.channel_number}:D{self.bit_number}:THR"
            return_values.update(threshold=self.query(cmd, float))

            cmd = f"CH{self.channel_number}_D{self.bit_number}:LAB:NAM"
            tmp = self.query(cmd, str).strip('"').strip()
            return_values.update(label='' if tmp.isspace() else tmp)

            return return_values

        state = self.on_off.to_inst(state)

        if threshold is not None:
            if not(isinstance(threshold, (int, float))) or not(-40 <= threshold <= 40):
                raise ValueError(f"Bad threshold {threshold} V, should be -40 to +40 V.")

        if state is not None:
            cmd = f"DIS:WAVEV{self.view_number}:CH{self.channel_number}_D{self.bit_number}:STATE"
            self.write(cmd, state)

        if threshold is not None:
            cmd = f"DIGGRP{self.channel_number}:D{self.bit_number}:THR"
            self.write(cmd, threshold)

        if label is not None:
            cmd = f"CH{self.channel_number}_D{self.bit_number}:LAB:NAM"
            self.write(cmd, f'"{label}"')

        self.log_inst_errors()
