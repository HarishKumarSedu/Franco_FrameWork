from enum import Enum
from collections import namedtuple
import re

from cl_instr_lib.base_classes.tek_scopes.horiz import Horiz
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max
from cl_instr_lib.helpers.check_enum_str import check_enum_str

is_writable_in_mode = namedtuple('is_writable', ['min_samp_rate', 'scale_overrides_min_sr', 'sample_rate',
                                                 'record_length', 'samp_rate_changes'])

class Horiz(Horiz):
    """Class providing the **Horizontal** controls of a Tektronix MSO[456] series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        self.bounds_scale = namedtuple_min_max(200e-12, 1000)
        self.bounds_delay = namedtuple_min_max(0, 1000)  # sec.
        self.enum_mode = Enum('enum_mode', {
            'AUTO': 'AUTO',
            'CONSTANT': 'CONSTANT',
            'MANUAL': 'MANUAL'
        })
        self._record_length_min = 1000  # See method get_record_length_max

        self._writable_params_in_mode = {
            # ['min_samp_rate', 'scale_overrides_min_sr', 'sample_rate', 'record_length', 'samp_rate_changes']
            'AUTO':     is_writable_in_mode(True, True, False, False, False),
            'MANUAL':   is_writable_in_mode(False, False, True, True, True),
        }
        self._sample_rate_min = 1.5625   # per sec.
        self.bounds_min_samp_rate = namedtuple_min_max(1.5625, 3.125e9)  # Samp/sec.

        self.enum_samp_rate_changes = Enum('samp_rate_changes', {
            'HORIZ_SCALE': 'HORIZONTALSCALE',
            'REC_LEN': 'RECORDLENGTH'
        })

    def get_sample_rate_max(self):
        """Returns maximum sample rate considering scope model."""

        if re.match('^MSO[45]\d$', self.scope.model):
            return 6.25e9
        elif re.match('^MSO6\d$', self.scope.model):
            return 25e9
        else:
            raise ValueError(f"Cannot determine _sample_rate_max for oscope model {self.scope.model}.")

    def get_record_length_max(self):
        """Return maximum record length considering scope installed options."""

        model = self.scope.model
        options_installed = self.scope.options_installed

        if re.match('^MSO4\d$', model):
            if '4-RL-1' in options_installed:
                return 62.5e6
            else:
                return 31.25e6
        elif re.match('^MSO5\d$', model):
            if '5-RL-125' in options_installed:
                return 125e6
            elif '5-RL-250' in options_installed:
                return 250e6
            elif '5-RL-500' in options_installed:
                return 500e6
            else:
                return 62.5e6
        elif re.match('^MSO6\d$', model):
            if '6-RL-1' in options_installed:
                return 125e6
            elif '6-RL-2' in options_installed:
                return 250e6
            elif '6-RL-3' in options_installed:
                return 500e6
            elif '6-RL-4' in options_installed:
                return 1e9
            else:
                return 62.5e6

        self.log.warning("Could not determine record_length max for model '{model}'. Will try 1e9, "
                         "scope may limit to less!")

        return int(1e9)   # Return biggest possible, scope will limit to its actual max with no error.

    def setup(self, scale=None, delay_mode=None, position_pcnt=None, delay_time=None, record_length=None,
              mode=None, sample_rate=None, min_samp_rate=None, scale_overrides_min_sr=None,
              samp_rate_changes=None, *args, **kwargs):
        """
        Queries all or sets any combination of horizontal parameters.

        :param scale: seconds per horizontal division
        :type scale: float|int
        :param delay_mode: 'OFF' is horizontal position as % of record length. 'ON' is delay time from trigger.
        :type delay_mode: 'ON' or 'OFF", 1 or 0, True or False.
        :param position_pcnt: Shifts view of the captured record from 0 to 100 % point. Takes effect when delay_mode is
            'OFF'.
        :type position_pcnt: float | int
        :param delay_time: Delay in seconds from trigger point. Takes effect when delay_mode is 'ON'.
        :type delay_time: float | int
        :param record_length: Length of acquisition. Only in effect when mode is 'MANUAL'. Maximum depends
            on which RL option is installed. See method _record_length_max.
        :type record_length: int
        :param mode: Element of enum_mode: 'AUTO' or 'MANUAL'.

            'AUTO'
                You may program **scale** and **min_samp_rate** but not record_length.
            'MANUAL'
                You may program  **sample_rate** and **record_length**, scope calculates scale from sample_rate and
                record_length.

        :param sample_rate: 1.5625 samp/sec to a maximum determined by scope model. See method _sample_rate_max.
        :type sample_rate: float
        :param min_samp_rate: Available only when mode='AUTO'. Changing scale will not reduce sample rate below this
            value unless scale_overrides_min_sr='ON'.
        :type min_samp_rate: float
        :param scale_overrides_min_sr: Available only when mode='AUTO'. If 'ON', 1, or True changing scale can cause
            scope to reduce sample rate to below the value of min_samp_rate.
        :type scale_overrides_min_sr: str|bool|int
        :param samp_rate_changes: Available only when mode='MANUAL'. Determines if altering the sample_rate changes
            horizontal scale ('HORIZ_SCALE') or recordlength ('REC_LEN').
        :type samp_rate_changes: enum_samp_rate_changes | str

        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. Note that the set of keywords returned correspond to those that can be set in the current mode.
        """

        # HORizontal:MODE:SCAle <NR3>
        # HORizontal:DELay:MODe {OFF|ON|<NR1>}
        # HORizontal:POSition <NR3>
        # HORizontal:DELay:TIMe <NR3>

        # HORizontal:MODE:RECOrdlength <NR1>     # In manual mode
        # HORizontal:MODE {AUTO|CONStant|MANual}

        # HORizontal:MODE:SAMPLERate <NR1>       # In manual mode

        # New MSO456 stuff
        # HORizontal:SAMPLERate:ANALYZemode:MINimum:VALue {AUTOmatic|<NR3>}   # When horiz mode is AUTO
        # HORizontal:SAMPLERate:ANALYZemode:MINimum:OVERRide {OFF|ON|0|1}     # When horiz mode is AUTO
        # HORizontal:MODe:MANual:CONFIGure {HORIZontalscale|RECORDLength}     # When mode is MANUAL

        # HORizontal:ACQDURATION? # TODO: Separate function for this?

        self.log_unused_args(args, kwargs)

        mode_state = self.query("HOR:MODE", self.enum_mode)

        if all(v is None for v in (scale, delay_mode, position_pcnt, delay_time, mode, record_length,
                                   sample_rate, min_samp_rate, scale_overrides_min_sr, samp_rate_changes)):
            return_values = {}
            return_values.update(scale=self.query("HOR:MODE:SCA?", float))
            return_values.update(delay_mode=self.on_off.to_api(self.query("HOR:DEL:MOD", int)))
            return_values.update(position_pcnt=self.query("HOR:POS", float))
            return_values.update(delay_time=self.query("HOR:DEL:TIM", float))
            return_values.update(mode=mode_state.name)
            if mode_state.name == 'AUTO':
                tmp = self.query('HOR:SAMPLER:ANALYZ:MIN:VAL', str)
                if tmp.startswith('AUTO'):
                    tmp = 'AUTO'
                else:
                    tmp = float(tmp)
                return_values.update(min_samp_rate=tmp)
                tmp = self.query('HOR:SAMPLER:ANALYZ:MIN:OVERR', int)
                return_values.update(scale_overrides_min_sr=self.on_off.to_api(tmp))
            else:
                return_values.update(samp_rate_changes=self.query('HOR:MOD:MAN:CONFIG',
                                                                  self.enum_samp_rate_changes).name)
                return_values.update(sample_rate=self.query("HOR:MODE:SAMPLERate", float))
                return_values.update(record_length=self.query("HOR:MODE:RECO", int))
            return return_values

        mode = check_enum_str('mode', mode, self.enum_mode)
        if mode is not None:
            mode_state = mode
        is_writable = self._writable_params_in_mode[mode_state.name]

        if scale is not None:
            if not isinstance(scale, (int, float)):
                raise ValueError(f"Bad scale {scale}, should be {self.bounds_scale.min} to {self.bounds_scale.max} "
                                 f"sec.")
            # TODO: Horiz scale limits actually depend on sample Rate and record length.
            if not(self.bounds_scale.min <= scale <= self.bounds_scale.max):
                scale_tmp = min(max(scale, self.bounds_scale.min), self.bounds_scale.max)
                self.log.warning(f"Requested scale {scale} outside range {self.bounds_scale.min} to "
                              f"{self.bounds_scale.max}. Setting to {scale_tmp}.")
                scale = scale_tmp

        if delay_mode is not None and delay_mode not in self.on_off.api_values():
            msg = ", ".join([f"'{x}'" for x in self.on_off.api_values()])
            raise ValueError(f"Bad delay_mode {delay_mode}, should be one of {msg}.")

        if position_pcnt is not None:
            if delay_mode is None:
                delay_mode_state = self.on_off.to_api(self.query('HOR:DEL:MOD?', int))
            else:
                delay_mode_state = delay_mode
            if 'ON' == delay_mode_state:
                self.log.warning(f"Must change delay_mode setting to 'OFF' for position_pcnt to take effect.")
            if not isinstance(position_pcnt, (int, float)) or position_pcnt < 0 or position_pcnt > 100:
                position_pcnt_tmp = min(max(position_pcnt, 0.0), 100.0)
                self.log.warning(f"Bad position_pcnt value {position_pcnt}, setting to {position_pcnt_tmp} percent.")

        if delay_time is not None:
            if delay_mode is None:
                delay_mode_state = self.on_off.to_api(self.query('HOR:DEL:MOD?', int))
            else:
                delay_mode_state = delay_mode
            if 'OFF' == delay_mode_state:
                self.log.warning(f"delay_mode is 'OFF', set to 'ON' for new delay time to take effect.")
            if scale is None:
                horiz_delay_min = -10 * self.query("HOR:MODE:SCA", float)
            else:
                horiz_delay_min = -10 * scale
            if not isinstance(delay_time, (int, float)) or not(horiz_delay_min <= delay_time <= self.bounds_delay.max):
                delay_time_tmp = min(max(delay_time, horiz_delay_min), self.bounds_delay.max)
                self.log.warning(f"delay_time {delay_time}, outside range {horiz_delay_min:4.1G} (-10 divisions) to "
                              f"{self.bounds_delay.max} sec. Setting to {delay_time_tmp:4.1G}.")
                delay_time = delay_time_tmp

        if record_length is not None:
            record_length_max = self.get_record_length_max()
            if not is_writable.record_length:
                raise ValueError(f"record_length cannot be set in mode '{mode_state.name}'.")
            else:
                record_length = int(record_length)
                if not (self._record_length_min <= record_length <= record_length_max):
                    raise ValueError(f"Bad record_length {record_length}, should be {self._record_length_min} to "
                                     f"{record_length_max}.")

        if sample_rate is not None:
            if not is_writable.record_length:
                raise ValueError(f"sample_rate cannot be set in mode '{mode_state.name}'.")
            if not (self._sample_rate_min <= sample_rate <= self.get_sample_rate_max()):
                raise ValueError(f"Bad sample_rate {sample_rate}, should be {self._sample_rate_min} to "
                                 f"{self.get_sample_rate_max()}")

        if min_samp_rate is not None:
            if not is_writable.min_samp_rate:
                raise ValueError(f"min_samp_rate cannot be set in mode '{mode_state.name}'.")
            if min_samp_rate == 'AUTO':
                min_samp_rate = 'AUTOMATIC'
            elif not isinstance(min_samp_rate, (int, float)) or \
                    not(self.bounds_min_samp_rate.min <= min_samp_rate <= self.bounds_min_samp_rate.max):
                raise ValueError(f"Bad min_samp_rate {min_samp_rate:1.5G}, must 'AUTO' or numeric value from"
                                 f" {self.bounds_min_samp_rate.min:1.5G} to {self.bounds_min_samp_rate.max:1.5G} "
                                 f"Samps/sec.")

        if scale_overrides_min_sr is not None:
            if not is_writable.scale_overrides_min_sr:
                raise ValueError(f"scale_overrides_min_sr cannot be set in mode '{mode_state.name}'.")
            scale_overrides_min_sr = self.on_off.to_inst(scale_overrides_min_sr)

        if samp_rate_changes is not None:
            if not is_writable.samp_rate_changes:
                raise ValueError(f"samp_rate_changes cannot be set in mode '{mode_state.name}'.")
            samp_rate_changes = check_enum_str('samp_rate_changes', samp_rate_changes, self.enum_samp_rate_changes)

        # If we got here all new values are good, write them to instrument:

        if mode is not None:
            self.write("HOR:MODE", mode_state.value)
        if scale is not None:
            self.write("HOR:MODE:SCA", scale)
        if delay_mode is not None:  # Order is important here!
            self.write("HOR:DEL:MOD", self.on_off.to_inst(delay_mode))
        if position_pcnt is not None:
            self.write("HOR:POS", position_pcnt)
        if delay_time is not None:
            self.write("HOR:DEL:TIM", delay_time)
        if record_length is not None:
            self.write("HOR:MODE:RECO", int(record_length))
        if sample_rate is not None:
            self.write("HOR:MODE:SAMPLER", sample_rate)  # Long form used for readability in log,
        if min_samp_rate is not None:
            self.write('HOR:SAMPLER:ANALYZ:MIN:VAL', min_samp_rate)
            tmp = self.query('HOR:SAMPLER:ANALYZ:MIN:VAL', str)
            if tmp != 'AUTO':
                actual = float(tmp)
                if abs(actual - min_samp_rate)/min_samp_rate > 0.01:
                    self.log.warning(f"Requested min_samp_rate {min_samp_rate:1.5G} set by scope to closest "
                                     f"supported value {actual:1.5G} Samps/sec.")
        if scale_overrides_min_sr is not None:
            self.write('HOR:SAMPLER:ANALYZ:MIN:OVERR', scale_overrides_min_sr)
        if samp_rate_changes is not None:
            self.write('HOR:MOD:MAN:CONFIG', samp_rate_changes.value)

        self.log_inst_errors()

    def get_readonly_parameters(self):
        """
        Reads and returns the horizontal mode and those parameters that are readonly in the present mode.

        The keys in the returned dict depend on mode:

            AUTO
                resolution, duration, record_length, interp_ratio
            MANUAL
               resolution, duration, scale, interp_ratio

        In the scope GUI, resolution and duration are always greyed out; record_length and scale are greyed out
        depending on the mode. The GUI does not display interp_ratio.
        """

        return_values = {}
        mode_state = self.query("HOR:MODE", self.enum_mode)
        return_values.update(mode=mode_state.name)

        # Could not find a SCPI command to read this.
        sample_rate = self.query("HOR:MODE:SAMPLERate", float)
        return_values.update(resolution=1.0/sample_rate)

        return_values.update(duration=self.query('HOR:ACQDURATION', float))

        if mode_state == self.enum_mode.AUTO or mode_state == self.enum_mode.CONSTANT:
            return_values.update(record_length=self.query("HOR:MODE:RECO", int))
        else:
            return_values.update(scale=self.query("HOR:MODE:SCA?", float))

        return_values.update(interp_ratio=self.query('HOR:MAI:INTERPR', float))

        return return_values
