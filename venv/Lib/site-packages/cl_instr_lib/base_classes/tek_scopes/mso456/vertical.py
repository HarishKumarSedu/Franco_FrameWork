from cl_instr_lib.base_classes.tek_scopes.mso456.channel_analog import ChannelAnalog
from cl_instr_lib.base_classes.tek_scopes.mso456.channel_analog_tdp import ChannelAnalogTdp
from cl_instr_lib.base_classes.tek_scopes.mso456.channel_analog_tcp import ChannelAnalogTcp
from cl_instr_lib.base_classes.tek_scopes.mso456.channel_tlp058 import ChannelTlp058

from enum import Enum
from collections import namedtuple
import re

probe_chan_config = namedtuple('probe_chan_config', ['probe', 'cls_correct', 'cls_actual', 'class_ok'])

class Vertical:
    """Provides methods for creating and managing the overall set of vertical channels.

    Composes channel objects for each channel named CH1...CH<num_channels>. The class of each channel object depends on
    the type of probe connected to channel at time of construction or upon re-running method reconfig_probes_chans().

    * Class `ChannelAnalog`_ is used for channels with: no probe, a basic 10X probe, TPP0500B (preferred) or \
        TPP1000.
    * Class `ChannelTlp058`_ is used for channels with TLP058 digital probe.
    """

    def __init__(self, scope, num_channels, **kwargs):
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.on_off = scope.on_off
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args
        self._num_channels = num_channels

        self._channel_numbers = list(range(1, self._num_channels + 1))
        chan_names = [f'CH{x}' for x in self._channel_numbers]
        self.enum_ch_names = Enum('enum_ch_names', chan_names)

        # dict of probe types to channel classes
        self._probe_to_chan_class = {

            '1X': ChannelAnalog,           # No probe, using BNC connector directly.
            '10X': ChannelAnalog,          # Random probe without TekVPI interface, tested with P6139B
            'TPP0500': ChannelAnalog,      # Tested with actual probe. 5k and MSO[456] only, cannot be plugged into 7k.
            'TPP0500B': ChannelAnalog,     # Tested with actual probe. 5k and MSO[456] only, cannot be plugged into 7k.
            'TPP1000': ChannelAnalog,      # Tested with actual probe. 5k and MSO[456] only, cannot be plugged into 7k.
            'TAP1500': ChannelAnalog,      # 5k, 7k , MSO[456] compatible. Not tested with actual probe.
            'TAP2500': ChannelAnalog,      # 5k, 7k , MSO[456] compatible. Not tested with actual probe.
            'TAP3500': ChannelAnalog,      # 5k, 7k , MSO[456] compatible. Tested with actual probe
            'TDP0500': ChannelAnalogTdp,   # 5k, 7k , MSO[456] compatible. Not tested with actual probe
            'TDP1000': ChannelAnalogTdp,   # 5k, 7k , MSO[456] compatible. Tested with actual probe
            'TDP1500': ChannelAnalogTdp,   # 5k, 7k , MSO[456] compatible. Not tested with actual probe
            'TDP3500': ChannelAnalogTdp,   # 5k, 7k , MSO[456] compatible. Not tested with actual probe
            'TDP4000': ChannelAnalogTdp,   # 5k, 7k , MSO[456] compatible. Not tested with actual probe
            'TCP0030': ChannelAnalogTcp,   # Uses TekVPI. Tested with actual probe.
            'TCP0030A': ChannelAnalogTcp,  # Uses TekVPI. Not tested with actual probe.
            'TLP058': ChannelTlp058        # Uses Tek FlexChannel interface, MSO[456] only. Tested with actual probe.
        }
        # The 7000 series scopes lack a notch on the right side of probe socket necessary to accept a TPP series probe.

        # Create the set of channel objects based on current probe connections.
        for name in chan_names:
            self.__setattr__(name, self.channel_factory(name))

    def get_probe_chan_configs(self):
        """
        Scans scope vertical input channels and checks channel classes instantiated, flags mismatches.

        :return: Two items. *all_match* is True if all channels have correct object for the connected probe type.
            *details* is dictionary keyed by channel attribute names, values are named tuple probe_chan_config
            containing:

            * 'probe': the string returned by SCPI cmd PROBE:ID:TYP,
            * 'cls_correct': the correct class definition for the probe.
            * 'cls_actual': the class definition for the actual channel object instantiated.
            * 'class_ok': True is cls_actual is cls_actual.
        :rtype: bool, dict
        """

        chan_info = {}
        all_match = True
        for chan_num in range(1, self._num_channels + 1):
            name = f"CH{chan_num}"
            obj = self.scope.vertical.__getattribute__(name)
            probe = obj.get_probe_type()
            cls = self._probe_to_chan_class.get(probe, ChannelAnalog)
            cls_actual = type(obj)
            match = cls is cls_actual
            chan_info.update({name: probe_chan_config(probe, cls, cls_actual, match)})
            all_match = all_match and match
        return all_match, chan_info

    def reinit_probes_chans(self):
        """
        Performs a channel scan and instantiates the correct class of channel object for channels with object/ probe
        mismatch.

        Calls method in trigger subsystem to redefine trig_source_enum to match the de-defined channels.

        **Call this method whenever you change probe / channel connections after the driver is instantiated!**
        """

        self._reinit_probes_chans()

    def _reinit_probes_chans(self):
        """
        Performs a channel scan and instantiates the correct class of channel object for channels with object/ probe
        mismatch.

        Calls method in trigger subsystem to redefine trig_source_enum to match the de-defined channels.

        **Call this method whenever you change probe / channel connections after the driver is instantiated!**
        """

        all_match, chan_info = self.get_probe_chan_configs()
        if all_match:
            return all_match, chan_info

        # Reconfigure broken channel attributes (wrong object class for probe).
        for chan_name in chan_info:
            if not chan_info[chan_name].class_ok:
                self.log.warn(f"{chan_name} being reconfigured from {chan_info[chan_name].cls_actual} to"
                              f" {chan_info[chan_name].cls_correct}.")
                self.scope.vertical.__setattr__(chan_name, self.channel_factory(chan_name))

                tmp = chan_info[chan_name]
                chan_info[chan_name] = probe_chan_config(probe=tmp.probe, cls_correct=tmp.cls_correct,
                                                         cls_actual=tmp.cls_correct, class_ok=True)

        # Execute call backs to update subsystems. Be careful you don't create loops.

        # noinspection PyProtectedMember
        self.scope.trigger._init_trig_source_enum()
        # noinspection PyProtectedMember
        self.scope.measurements._update_source_enums()
        # noinspection PyProtectedMember
        self.scope.wavefrom_data._update_waveform_source_enum()

        return True, chan_info

    def get_expanded_input_list(self):
        """
        Creates a set of channel names that include the individual bits of any connected logic probes, i.e. CH1_D0
        ... CH1_D7 if CH1 has a TLP058 logic probe plugged into it.

        :return: List of expanded channel names.
        :rtype: List[str]
        """

        _, chan_info = self._reinit_probes_chans()

        name_list = []
        for chan_name, info in chan_info.items():
            chan_number = re.match(r'^\w+(\d+)$', chan_name)[1]
            if info.cls_actual is ChannelTlp058:
                for bit in range(ChannelTlp058.num_bits):
                    name_list.append(f"CH{chan_number}_D{bit}")
            else:
                name_list.append(f"CH{chan_number}")

        return name_list

    def channel_factory(self, chan_name):
        """
        Instantiates a channel object of the class appropriate for the type of probe found to be connected.

        :param chan_name: Any name we want to use for the channel, provided it ends in a digit that corresponds to
            one of the oscope channel as Tek numbers them.
        :type chan_name: str
        :return: channel object
        :rtype: derived from OscopeChannelMso456
        """

        chan_number = re.match(r'^\w+(\d+)$', chan_name)[1]
        probe = self.query(f"CH{chan_number}:PRO:ID:TYP?").strip('"').strip()
        cls = self._probe_to_chan_class.get(probe)
        if cls is None:
            self.log.warn(f"Unknown probe type '{probe}' on '{chan_name}', defaulting to ChannelAnalog class "
                          f"for channel object, may or may not function correctly with this probe!")
            cls = ChannelAnalog
        return cls(self, chan_number)

    def channel_display(self, on_list=None, off_list=None):
        """
        Query or specify which channels are displayed and which are not.

        :param on_list: List of channel numbers to display.
        :type on_list: List[int]
        :param off_list: List of channel numbers to not display. Takes precedence if a number also appears in on_list
        :type off_list: List[int]
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # SELect:CH<x> {ON|OFF|1|0}

        if all([on_list is None, off_list is None]):
            on_list = []
            off_list = []
            for c in self._channel_numbers:
                name = f"CH{c}"
                ch_obj = self.__getattribute__(name)
                v = 1 if ch_obj.display() == 'ON' else 0
                if v:
                    on_list.append(c)
                else:
                    off_list.append(c)
            return {'on_list': on_list, 'off_list': off_list}

        msg = ", ".join([f"{c}" for c in self._channel_numbers])
        if on_list is not None:
            bad = [c for c in on_list if c not in self._channel_numbers]
            if bad:
                raise ValueError(f"on_list: bad channels {bad}, should be from set {msg}.")

        if off_list is not None:
            bad = [c for c in off_list if c not in self._channel_numbers]
            if bad:
                raise ValueError(f"off_list: bad channels {bad}, should be from set {msg}.")

        if on_list is not None:
            for c in on_list:
                name = f"CH{c}"
                ch_obj = self.__getattribute__(name)
                ch_obj.display('ON')

        if off_list is not None:
            for c in off_list:
                name = f"CH{c}"
                ch_obj = self.__getattribute__(name)
                ch_obj.display('OFF')

        self.log_inst_errors()
