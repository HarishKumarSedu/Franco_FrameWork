from enum import Enum
import re

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max

class Trigger:
    """Class providing the **Trigger** controls of a Tektronix MSO 4,5,6 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args

        # TODO: Does aliasing of trig_types work?
        trig_type_dict = {
            'EDGE': 'EDGE',
            'WIDTH': 'WIDTH',
            'TIMEOUT': 'TIMEOUT',
            'RUNT': 'RUNT',
            'WINDOW': 'WINDOW',
            'LOGIC':  'LOGIC',
            # 'PATTERN': 'PATTERN',   # 5000 series name. Is logic with clock.
            # 'STATE': 'STATE',       # 5000 series name. Is logic with w/o clock.
            'SETUP_HOLD': 'SETHOLD',
            'RISE_FALL': 'TRANSITION',
            # 'TRANSITION': 'TRANSITION',  # 5000 series name. Is rise_fall.
            'BUS': 'BUS',
            'SEQUENCE': 'SEQUENCE'
        }
        # 5K series has
        #     'BUS1':           ('BUS', 'TRIG:A:BUS:SOU', 'B1'),
        #     'BUS2':           ('BUS', 'TRIG:A:BUS:SOU', 'B2'),

        self.enum_trig_types = Enum('enum_trigger_types', trig_type_dict)
        trig_type_dict.pop('SEQUENCE')
        self.enum_Atrig_events = Enum('enum_Atrig_events', trig_type_dict)
        self.enum_Btrig_events = self.enum_Atrig_events

        self.enum_holdoff_by = Enum('enum_holdoff_by', {
            'TIME': 'TIME',
            'RANDOM': 'RANDOM'
        })
        self.bounds_holdoff_sec = namedtuple_min_max(0, 10.0)

        self.enum_edge_slopes = Enum('enum_edge_slopes', {
            'FALL': 'FALL',
            'RISE': 'RISE',
            'EITHER': 'EITHER'
        })
        self.enum_edge_coupling = Enum('enum_edge_coupling', {
            'DC': 'DC',
            'HFREJ': 'HFREJ',
            'LFREJ': 'LFREJ',
            'NOISEREJ': 'NOISEREJ'
        })
        self.enum_trig_modes = Enum('enum_trig_modes', {
            'AUTO': 'AUTO',
            'NORMAL': 'NORMAL'
        })

        self.enum_AB_seq_types = Enum('enum_AB_seq_types', ['A_only', 'AB_time', 'AB_events'])
        self.bounds_Btrig_events = namedtuple_min_max(1, 65471)
        self.bounds_Btrig_time = namedtuple_min_max(160e-12, 20.0)

        self.trig_level_divs = 5
        self.trig_level_aux_volts = {'1X': 8.0, '10X': 80.0}

        self.enum_trig_sources = None
        self._init_trig_source_enum()

    def _init_trig_source_enum(self):
        """Creates the enum listing all the possible trigger sources based on the current probe setup."""

        trig_src_list = self.scope.vertical.get_expanded_input_list()
        d = dict((k, k) for k in trig_src_list)
        d.update(ACLINE='LINE')
        self.enum_trig_sources = Enum('enum_trig_sources', d)

    def type_of_trigger(self, trig_type=None):
        """
        Select the trigger type. Corresponds to the Trigger Type drop down in the Trigger Settings dialog.

        :param trig_type: Selects the trigger mode for the A trigger or select the Sequence trigger. After
            selecting Sequence trigger is selected, use the A_event and B_event methods to select trigger types.
            Choices: 'EDGE', 'WIDTH', 'TIMEOUT', 'RUNT', 'WINDOW', 'LOGIC', 'SETUP_HOLD', 'RISE_FALL', 'BUS',
            'SEQUENCE'.
        :type trig_type: str|enum_trig_types
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        if trig_type is None:
            sequence = self.query('TRIG:B:STATE', bool)
            if sequence:
                return {'trig_type': 'SEQUENCE'}
            else:
                return self._trig_type('A', self.enum_trig_types, trig_type)

        trig_type = check_enum_str('trig_type', trig_type, self.enum_trig_types)

        if trig_type == self.enum_trig_types.SEQUENCE:
            self.write('TRIG:B:STATE', 'ON')
        else:
            self.write('TRIG:B:STATE', 'OFF')
            self.query('*OPC')
            self._trig_type('A', self.enum_trig_types, trig_type)

        self.log_inst_errors()

    def A_event(self, trig_type=None):
        """
        Query or set the event type for the A trigger.

        :param trig_type: Choose the trigger type for A trigger system. Choices are: 'EDGE', 'WIDTH', 'TIMEOUT', 'RUNT',
            'WINDOW', 'LOGIC', 'SETUP_HOLD', 'RISE_FALL', 'BUS'.
        :type trig_type: str|enum_Atrig_events
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Value read from scope.
        :rtype: dict|None
        """

        return self._trig_type('A', self.enum_Atrig_events, trig_type)

    def B_event(self, trig_type=None):
        """Query or set the event type for the B (sequence) trigger.

        :param trig_type: Choose the trigger type for A trigger system. Choices are: 'EDGE', 'WIDTH', 'TIMEOUT', 'RUNT',
            'WINDOW', 'LOGIC', 'SETUP_HOLD', 'RISE_FALL', 'BUS'.
        :type trig_type: str|enum_Btrig_events
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict|None
        """

        return self._trig_type('B', self.enum_Btrig_events, trig_type)

    def _trig_type(self, AorB, trig_enum, trig_type=None):
        """
        Helper function for trigger type selection, parameterized to leverage fact that on MSO[456] scopes,
        A and B triggers support the same set of trigger types.
        """

        if trig_type is None:
            return_values = {}
            result = self.query(f"TRIG:{AorB}:TYP", trig_enum).name
            return_values.update(trig_type=result)
            return return_values

        trig_type = check_enum_str('trig_type', trig_type, trig_enum)

        if trig_type is not None:
            self.write(f"TRIG:{AorB}:TYP", trig_type.value)

    def level_50pcnt(self, AorB='A'):
        """
        Sets A or B trigger level to 50% of the peak-to-peak amplitude of the waveform. The default ('A')
        gives the equivalent of pushing the trigger level knob.

        :param AorB: Defaults to 'A'.
        :type AorB: str
        :return:
        :rtype:
        """

        # TRIGGER:{A|B} command

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger name '{AorB}', should be 'A' or 'B'.")

        self.write(f'TRIG:{AorB}', 'SETL')

        self.log_inst_errors()

    def sequence_settings(self, seq_type=None, event_count=None, time_sec=None):
        """
        Query or set parameters that determine when the B trigger fires after the A trigger occurs.

        :param seq_type:

            * 'AB_time' trigger on 1 B event following A event after a delay.
            * 'AB_event' trigger after event_count B events following the A event.
            * 'A_only' disables sequence triggering (backwards compatibility with 5000 series).
        :type seq_type: str|enum_AB_seq_types
        :param event_count: After A event occurs, trigger after this number of B events. See bounds_Btrig_events.max.
        :type event_count: int
        :param time_sec: After A event and 1st B event, wait this many seconds before triggering.
        :type time_sec: float
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        # A_only
        # AB_time
        # AB_events

        # TRIGger:B:STATE {ON|OFF|<NR1>}
        # TRIGger:B:BY {EVENTS|TIMe|ARMAtrigb}
        # TRIGger:B:TIMe <NR3>
        # TRIGger:B:EVENTS:COUNt <NR1>   1 to 10e6

        if all([v is None for v in (seq_type, time_sec, event_count)]):
            return_values = {}
            sequence = self.query('TRIG:B:STATE', bool)
            if not sequence:
                return_values.update(seq_type='A_only')
            else:
                tmp = self.query('TRIG:B:BY', str)
                if tmp == 'EVENTS':
                    return_values.update(seq_type='AB_events')
                elif tmp == 'TIME':
                    return_values.update(seq_type='AB_time')
                else:
                    self.log.warning(f"'TRIG:B:STATE query returned response '{tmp}' which does not correspond to "
                                     f"seq_types 'A_only', 'AB_events', or 'AB_time'.")
            return_values.update(events_count=self.query('TRIG:B:EVENTS:COUN', int))
            return_values.update(time_sec=self.query('TRIG:B:TIME', float))
            return return_values

        seq_type = check_enum_str('seq_type', seq_type, self.enum_AB_seq_types)

        if event_count is not None:
            if not isinstance(event_count, (int, float)) or \
                                    not(self.bounds_Btrig_events.min <= event_count <= self.bounds_Btrig_events.max):
                raise ValueError(f"Bad event_count {event_count}, should be {self.bounds_Btrig_events.min} to "
                                 f"{self.bounds_Btrig_events.max}.")

        if time_sec is not None:
            if not isinstance(time_sec, (int, float)) or \
                                    not(self.bounds_Btrig_time.min <= time_sec <= self.bounds_Btrig_time.max):
                raise ValueError(f"Bad time_sec {time_sec}, should be {self.bounds_Btrig_time.min} "
                                 f"to {self.bounds_Btrig_time.max} sec.")

        if seq_type is not None:
            if seq_type.name == 'A_only':
                self.write('TRIG:B:STATE', 'OFF')
            elif seq_type.name == 'AB_time':
                self.write('TRIG:B:STATE', 'ON')
                self.write('TRIG:B:BY', 'TIME')
            elif seq_type.name == 'AB_events':
                self.write('TRIG:B:STATE', 'ON')
                self.write('TRIG:B:BY', 'EVENTS')
        if event_count is not None:
            self.write('TRIG:B:EVENTS:COUN', int(event_count))
        if time_sec is not None:
            self.write('TRIG:B:TIME', time_sec)

        self.log_inst_errors()

    def options(self, trig_mode=None, holdoff_sec=None, holdoff_by=None, *args, **kwargs):
        """
        Triggering parameters common to all the triggering types.

        :param trig_mode: Element of enum_trig_modes or str: 'NORMAL', 'AUTO'.
        :param holdoff_by: Element of enum_holdoff_by or str: 'RANDOM', "TIME'.
        :param holdoff_sec: After a trigger event subsequent events are ignored during holdoff.
            Note that scope holdoff_type must be 'TIME' for this to take effect.
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        # TRIGger:A:MODe {AUTO|NORMal}
        # TRIGger:A:HOLDoff:BY {TIMe|DEFAult|RANDom|AUTO}
        # TRIGger:A:HOLDoff:TIMe <NR3>

        # Not implemented
        # TRIGger:ENHanced {<NR1>|OFF|ON}
        # TRIGger:SENSITivity {<NR1>|OFF|ON}

        self.log_unused_args(args, kwargs)

        if all(v is None for v in (trig_mode, holdoff_by, holdoff_sec)):
            return_values = {}
            return_values.update(trig_mode=self.query("TRIG:A:MOD?", self.enum_trig_modes).name)
            return_values.update(holdoff_by=self.query('TRIG:A:HOLDoff:BY', self.enum_holdoff_by).name)
            return_values.update(holdoff_sec=self.query("TRIG:A:HOLD:TIM?", float))
            return return_values

        trig_mode = check_enum_str('trig_mode', trig_mode, self.enum_trig_modes)

        if holdoff_sec is not None:
            if not isinstance(holdoff_sec, (int, float)) \
                    or not(self.bounds_holdoff_sec.min <= holdoff_sec <= self.bounds_holdoff_sec.max):
                raise ValueError(f"Bad holdoff {holdoff_sec}, should be {self.bounds_holdoff_sec.min} to"
                                 f" {self.bounds_holdoff_sec.max} sec.")

        holdoff_by = check_enum_str('holdoff_by', holdoff_by, self.enum_holdoff_by)
        if holdoff_by is None:
            holdoff_type_state = self.query('TRIGger:A:HOLDoff:BY', self.enum_holdoff_by)
        else:
            holdoff_type_state = holdoff_by

        if holdoff_sec is not None and holdoff_type_state != self.enum_holdoff_by.TIME:
            raise ValueError(f"Setting holdoff_sec has no effect for holdoff_by '{holdoff_type_state.name}'")

        # If we got here, all's good to write.

        if trig_mode is not None:
            self.write("TRIG:A:MOD", trig_mode.value)

        if holdoff_by is not None:
            self.write("TRIG:A:HOLDoff:BY", holdoff_by.value)

        if holdoff_sec is not None:
            self.write("TRIG:A:HOLD:TIM",  holdoff_sec)

        self.log_inst_errors()

    def force(self):
        """Cause a trigger event. """
        self.write('TRIG', 'FORC')

    def state(self):
        """
        Returns scope trigger state: 'ARMED', 'AUTO', 'READY', 'SAVE', 'TRIGGER'.

        :return: Possible values -

            * ARMED indicates that the instrument is acquiring pretrigger information.
            * AUTO indicates that the instrument is in the automatic mode and acquires data
              even in the absence of a trigger.
            * READY indicates that all pretrigger information is acquired and that the instrument
              is ready to accept a trigger.
            * SAVE indicates that the instrument is in save mode and is not acquiring data.
            * TRIGGER indicates that the instrument triggered and is acquiring the post trigger
              information.
        :rtype: str
        """

        return self.query('TRIG:STATE', str)  # TODO: Make agnostic to VERBOSE mode.

    def edge_config(self, AorB, source=None, level=None, slope=None, coupling=None, *args, **kwargs):
        """
        Query all or set any combination of parameters for **edge** trigger.

        Note that any parameters set here are specific to edge mode and come into effect when you select EDGE as the
        trigger type using method trigger_type or A_event or B_event. This allows for quickly switching between
        trigger types without reconfiguring.

        Each trigger type will have its own config method, so far edge is the only one implemented.

        :param AorB: Chooses which trigger system to configure 'A' or 'B'. Defaults to 'A' which is the standard
            trigger system for all trigger Types except 'SEQUENCE' which enables the 'B' trigger system.
        :param source: Specifies source of the trigger signal. Channels with TLP058 digital probe use the designations
            CH<x>_D<bit> where bit is 0 to 7. Channels with analog or no probes are designated CH<x>. In both cases x is
            is 1 to num_channels. Note that when probes are re-located you must execute the method
            <scope>.vertical.reconfig_probes_chans(). This ensures the correct channel objects are instantiated and
            initializes the enum_trig_sources. In addition to the input channels, 'ACLINE' is another triger source.
        :type source: enum_trig_sources | str
        :param level: Voltage level in Volts.
        :param level: float
        :param slope: 'RISE', 'FALL'
        :param coupling: 'AC', 'DC', 'HFR', 'LFR' as applicable
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad AorB '{AorB}', should be 'A' or 'B'. ")

        self.write(f"TRIG:{AorB}:TYP", 'EDGE')

        if all(v is None for v in (source, level, slope, coupling)):
            return_values = {}
            source_chan = self.query(f"TRIG:{AorB}:EDGE:SOU?", self.enum_trig_sources)
            return_values.update(source=source_chan.name)
            m = re.match('CH(\d)_D(\d)', source_chan.value)
            if m:
                chan, bit = m[1], m[2]
                cmd = f"DIGGRP{chan}:D{bit}:THR"
            else:
                cmd = f"TRIG:{AorB}:LEV:{source_chan.value}"
            return_values.update(level=self.query(cmd, float))
            return_values.update(slope=self.query(f"TRIG:{AorB}:EDGE:SLO?", self.enum_edge_slopes).name)
            return_values.update(coupling=self.query(f"TRIG:{AorB}:EDGE:COUP?", self.enum_edge_coupling).name)
            return return_values

        source = check_enum_str('source', source, self.enum_trig_sources)
        if source is None:
            source_state = self.query(f"TRIG:{AorB}:EDGE:SOU", self.enum_trig_sources)
        else:
            source_state = source

        coupling = check_enum_str('coupling', coupling, self.enum_edge_coupling)
        if coupling is None:
            coupling_state = self.query(f"TRIG:{AorB}:EDGE:COUP", self.enum_edge_coupling)
        else:
            coupling_state = coupling
            if re.match('CH(\d)_D(\d)', source_state.name):
                self.log.warning(f"Edge trigger coupling cannot be set to '{coupling.name}' for source "
                                 f"'{source_state.name}' because it is a digital input.")
                coupling = None
            elif source_state.name == 'ACLINE':
                # Scope coerces coupling to DC for AUX and ACLINE.
                if coupling != self.enum_edge_coupling.DC:
                    self.log.warning(f"Edge trigger coupling cannot be set to '{coupling.name}' for source "
                                     f"'{source_state.name}'. Defaults to 'DC'.")
                    coupling = None

        if level is not None:
            # See trigger Level ranges in scope data sheet.
            if source_state == self.enum_trig_sources.ACLINE:
                self.log.warning(f"Cannot set trigger level for source '{source_state.name}'. 0V only.")
                level = None
            else:
                if re.match('CH(\d)_D(\d)', source_state.name):
                    level_min, level_max = -40, +40
                else:
                    level_min, level_max = self._calc_trig_level_range(source_state, coupling_state)
                if not isinstance(level, (int, float)) or not (level_min <= level <= level_max):
                    # Sending out of bounds level via command doesn't cause error, it just sets level to min or max,
                    # so we just warn.
                    level_actual = min(max(level, level_min), level_max)
                    self.log.warning(f"Requested level {level} out of range {level_min} to {level_max} for source "
                                  f"{source_state}. Defaulting to {level_actual}.")

        slope = check_enum_str('slope', slope, self.enum_edge_slopes)

        # If we got here all new values are good, write them to instrument:

        if source is not None:
            self.write(f"TRIG:{AorB}:EDGE:SOU", source.value)
        if slope is not None:
            self.write(f"TRIG:{AorB}:EDGE:SLO", slope.value)
        if coupling is not None:
            self.write(f"TRIG:{AorB}:EDGE:COUP", coupling.value)
        if level is not None:
            m = re.match('CH(\d)_D(\d)', source_state.value)
            if m:
                chan, bit = m[1], m[2]
                cmd = f"DIGGRP{chan}:D{bit}:THR"
            else:
                cmd = f"TRIG:{AorB}:LEV:{source_state.value}"
            self.write(cmd, level)  # Sets current source value.

        self.log_inst_errors()

    def _calc_trig_level_range(self, source, coupling):
        # See trigger Level ranges in scope data sheet.

        if re.match('^CH(\d)_D(\d)$', source.name):
            return -40, 40        # TODO: Confirm this on MSO scope.
        elif re.match('^CH(\d)$', source.name):
            # Scale include the effect of 1X vs 10X probes so we don't need to get the probe gain here.
            scale = self.query(f"{source.value}:SCA?", float)
            if coupling.name == 'LFREJ':
                return -1.0 * self.trig_level_divs * scale, self.trig_level_divs * scale
            else:
                offset = self.query(f"{source.value}:OFFS?", float)
                position = self.query(f"{source.value}:POS?", float)
                return -1.0 * scale * (self.trig_level_divs + position) + offset,\
                    scale * (self.trig_level_divs - position) + offset
        elif source.name == 'ACLINE':
            return 0, 0
        else:
            self.log.warning(f"Level range check not implemented for source {source.name}.")
            return float('-inf'), float('+inf')
