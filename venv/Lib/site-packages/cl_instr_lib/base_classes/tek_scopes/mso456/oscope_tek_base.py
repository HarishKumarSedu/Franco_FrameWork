from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import OscopeTekBase
from cl_instr_lib.helpers.check_enum_str import check_enum_str

from enum import Enum
import re


class OscopeTekBaseMso456(OscopeTekBase):

    def __init__(self, visa_resource_name, logger, **kwargs):
        super().__init__(visa_resource_name, logger, **kwargs)

        self.enum_autoset_actions = Enum('enum_autoset_actions', {
            'EXECUTE': 'EXEC',
            'UNDO': 'UNDO'
        })

    def menu_off(self):
        """In previous scopes turned off any menu presently displayed. Equivalent of front panel button Menu Off.

        In MSO 4,5, 6 scope this functionality doesn't exist, this over-ride prevents error should client code call
        menu_off.
        """

        self.log.info(f"Scope {self.model()}, does not have Menu Off button.")

    def autoset(self, action):
        """Similar to the Autoset front panel button.

        Note: 5000 series had 'UNDO', but that doesn't seem to be supported on MSO 4,5,6 series.

        :param action: a value from enum_autoset_actions: 'EXECUTE'. Must be provided, serves as "are you
            sure" precaution.
        :type action: (str|enum_autoset_actions)
        """

        action = check_enum_str('action', action, self.enum_autoset_actions)

        if action.name == "UNDO":
            raise ValueError(f"Scope {self.model()}, does not have autoset UNDO capability! Sorry.")

        if action is not None:
            self.write('AUTOSet', action.value)
            timeout = self.rm_handle.timeout
            self.rm_handle.timeout = 20000
            self.query('*OPC')
            self.rm_handle.timeout = timeout

        self.log_inst_errors()

    def get_options_dict(self):
        """
        Returns dictionary of option name-description pairs. Performs '\*OPT?' query.

        An override of the the superclass method, this method handles the different formatting used in the MSO456
        series.

        """

        opt_result = self.query('*OPT', str).rstrip(', ')
        if opt_result == 'UNKNOWN':
            return {}

        remaining = opt_result
        return_dict = {}
        while True:
            m = re.match('([^;]+);([^;]+);([^,]+,*)', remaining)
            if m is None:
                break
            key = m[1].split(':')[0].strip()
            val = m[2].strip()
            return_dict.update({key: val})
            remaining = remaining[len(m[0]):].strip()
            if len(remaining) == 0:
                break
        return return_dict

