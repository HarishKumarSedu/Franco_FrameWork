from enum import Enum
import re
import time

from cl_instr_lib.base_classes.tek_scopes.mso456.channel_analog import ChannelAnalog
from cl_instr_lib.helpers.check_numeric_vs_list import check_numeric_vs_list
from cl_instr_lib.helpers.check_enum_str import check_enum_str


class ChannelAnalogTdp(ChannelAnalog):
    """Class providing the controls for an input FlexChannel of a Tektronix MSO[456] series oscilloscope with a
    TDP series probe."""

    def __init__(self, scope, channel_number, **kwargs):
        super().__init__(scope.scope, channel_number, **kwargs)

        self.enum_coupling = Enum('enum_coupling', {'DC': 'DC', 'DCREJ': 'DCREJ'})

    def probe_setup(self, probe_range=None, bandwidth=None, coupling=None, autozero=None):
        """
        Query or set range, bandwidth and coupling and/or execute an autozero operation on a **differential voltage**
        probe.

        :param probe_range: 'AUTO' or numeric value 4.25 or 42.5. Units are Volts.
        :type probe_range: str|int|float
        :param bandwidth: On TDP1000 this will be 'FULL', 1e6, 10e3 or 100Hz. The latter three values correspond to the
            BW limit LEDs on the probe. With 'FULL' the bandwidth is controlled by the oscope vertical channel settings
            up to the limit of the probe.
        :type bandwidth: float
        :param coupling: Is 'DC' or 'DCREJ'.  Is identical to the coupling setting of the vertical channel the probe is
            plugged into.
        :type coupling: str|enum_coupling
        :param autozero: True causes a autozero operation to start. Requires about 20 seconds to complete.
        :type autozero: None|bool
        :return: Dict with keys 'probe_range', 'bandwidth', 'coupling'.
        :rtype: dict
        """

        # CH<x>:PRObe:FORCEDRange <dynamicRangeNR3>
        # CH<x>:PRObe:AUTOZero EXECute
        # CH<x>:PRObe:DEGAUSS EXECute
        # CH<x>:PRObe:DEGAUSS:STATE?

        probe_type = self.query(f'CH{self.channel_number}:PRO:ID:TYP').strip('"')
        if re.match('^TDP\d{4}$', probe_type) is None:
            raise ValueError(f"Invalid probe '{probe_type}' on CH{self.channel_number}. Expected TDP series "
                             f"(differential voltage) probe'.")

        if all([v is None for v in (probe_range, bandwidth, coupling, autozero)]):
            return_values = {}
            range_mode = self.query(f'CH{self.channel_number}:PROBECO')
            if range_mode == 'AUTO':
                return_values.update(probe_range='AUTO')
            else:
                return_values.update(probe_range=self.query(f'CH{self.channel_number}:PRO:FORCEDR', float))
            return_values.update(bandwidth=self.query(f'CH{self.channel_number}:BANDWIDTH', float))
            return_values.update(coupling=self.query(f'CH{self.channel_number}:COUPLING', self.enum_coupling).name)
            return return_values

        if probe_range is not None:
            if probe_range == 'AUTO':
                pass
            else:
                probe_range = check_numeric_vs_list('probe_range', probe_range, [4.25, 42.5])

        bw_list = ['FULL', 1e6, 10e3, 100.0]
        if bandwidth is not None and bandwidth not in bw_list:
            msg = ', '.join([f"'{v}'" if isinstance(v, str) else f"{v:g}" for v in bw_list])
            raise ValueError(f"Bad bandwidth {bandwidth}, should be one of {msg}.")

        coupling=check_enum_str('coupling', coupling, self.enum_coupling)

        if autozero is not None:
            if autozero not in (True, False):
                raise ValueError(f"Bad autozero {autozero}, should be None, True or False.")

        if probe_range is not None:
            if probe_range == 'AUTO':
                self.write(f'CH{self.channel_number}:PROBECO', 'AUTO')
            else:
                self.write(f'CH{self.channel_number}:PROBECO', 'MAN')
                self.write(f'CH{self.channel_number}:PRO:FORCEDR', probe_range)
        if bandwidth is not None:
            self.write(f'CH{self.channel_number}:BANDWIDTH', bandwidth)
        if coupling is not None:
            self.write(f'CH{self.channel_number}:COUPLING', coupling.value)

        if autozero is not None:
            az_delay = 25
            self.log.info(f"Starting autozero operation on CH{self.channel_number} {probe_type}. Takes about "
                          f"{az_delay} seconds.")
            self.write(f'CH{self.channel_number}:PROBE:AUTOZ EXECUTE')
            # If another command is issued before AUTOZ is complete, we get a pyvisa timeout. Unlike the TCP degauss,
            # there is no status query we can poll to see when AUTOZ is complete.
            time.sleep(25)
            self.log.info(f"Autozero operation on CH{self.channel_number} {probe_type}, should be complete now.")

        self.log_inst_errors()
