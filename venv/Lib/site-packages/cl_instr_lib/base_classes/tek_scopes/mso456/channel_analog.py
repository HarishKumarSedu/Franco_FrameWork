from enum import Enum
import math

from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.base_classes.tek_scopes.mso456.oscope_channel import OscopeChannel


class ChannelAnalog(OscopeChannel):
    """Class providing the controls for an input FlexChannel of a Tektronix MSO[456] series oscilloscope with either no
    probe connected or an analog voltage probe connected."""

    def __init__(self, scope, channel_number, **kwargs):
        super().__init__(scope, channel_number, **kwargs)

        self.enum_coupling = Enum('enum_coupling', {'AC': 'AC', 'DC': 'DC'})

        self._probes_setting_termination = ['TPP0500', 'TPP0500B', 'TPP1000',   # compatible with 5k series only
                                            'TAP1500', 'TAP2500', 'TAP3500',    # compatible with 5k and 7k
                                            'TDP0500', 'TDP1000', 'TDP1500', 'TDP3500', 'TDP4000',
                                            'TCP0030', 'TCP0030A']

        self._input_termination = [1e6, 50.0]

        self._analog_input_ranges = (
            (1e6, namedtuple_min_max(500e-6, 10.0)),
            (250e3, namedtuple_min_max(500e-6, 10.0)),  # With TPP0500B termination reads back as 250K rather than 1M.
            (50.0, namedtuple_min_max(500e-6, 1.0)),
        )

        self._offset_range = namedtuple_min_max(-300, +300)  # Upper limits with TPP0500B probe (10X).
        self._position = namedtuple_min_max(-5, +5)

    def config(self, scale=None, position=None, coupling=None, invert=None, bandwidth=None, label=None,
           offset=None,  termination=None, *args, **kwargs):
        """
        Query all or set any combination of oscope vertical parameters for a specified channel.

        :param scale: volts per division
        :type scale: float
        :param position: -5 to +5 divisions.
        :type position: float
        :param coupling: Typically 'AC', 'DC'. But options may vary depending on connected probe, see enum_coupling.
        :type coupling: str|enum_coupling
        :param invert: Accepts any of the values defined as on or off, always returns 'ON' or 'OFF'.
        :type invert: str|int|bool
        :param bandwidth: 20e6, 250e6, and 'FULL'.
        :type bandwidth: float|'FULL'
        :param label: Up to 30 characters.
        :type label: str
        :param offset: voltage, range depends on scale and coupling. Will warn on out-of-bounds, but scope will set to
            min/max allowed.
        :type offset: float
        :param termination: 1e6 or 50.0
        :type termination: float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # CH<x>:SCAle <NR3>
        # CH<x>:POSition <NR3>
        # CH<x>:COUPling {AC | DC | DCREJect}  # Actually has GND not DCREJ
        # CH<x>:TERmination {FIFty|MEG|<NR3>}
        # CH<x>:INVert {ON|OFF}
        # CH<x>:BANdwidth {FULl|<NR3>}
        # CH<x>:LABel:NAMe <Qstring>
        # CH<x>:OFFSet <NR3>

        # CH<x>:PRObe:GAIN?
        # CH<x>:BANdwidth:ENHanced

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {scale, position, coupling, invert, bandwidth, label, offset, termination}):
            return_vals = {}
            return_vals.update(scale=self.query(f"CH{self.channel_number}:SCA?", float))
            return_vals.update(position=self.query(f"CH{self.channel_number}:POS?", float))
            return_vals.update(coupling=self.query(f"CH{self.channel_number}:COUP?", self.enum_coupling).name)
            return_vals.update(invert=self.on_off.to_api(self.query(f"CH{self.channel_number}:INV?", int)))
            return_vals.update(bandwidth=self.query(f"CH{self.channel_number}:BAN?", float))
            tmp = self.query(f"CH{self.channel_number}:LABEL:NAME", str).strip('"').strip()
            return_vals.update(label='' if tmp.isspace() else tmp)
            return_vals.update(offset=self.query(f"CH{self.channel_number}:OFFS?", float))
            return_vals.update(termination=self.query(f"CH{self.channel_number}:TERM?", float))
            return return_vals

        # Check all settings before applying.

        probe_type = self.query(f"CH{self.channel_number}:PROBE:ID:TYPE", str).strip('"')
        termination_state = self.query(f"CH{self.channel_number}:TERM?", float)

        if termination is not None:
            if termination not in [50, 1e6]:
                raise ValueError(f"Bad termination value: {termination}, should be 50 or 1e6.")
            if probe_type in self._probes_setting_termination:
                self.log.warning(f"Requested termination {termination} ignored. Termination is set by probe "
                              f"'{probe_type}'.")
                termination = None   # Prevent subsequent write.
            else:
                self.log.warning(f"You are setting termination to {termination} Ohms for unknown probe type "
                                 f"'{probe_type}'.")
                termination_state = termination

        probe_gain = self.query(f"CH{self.channel_number}:PROBE:GAIN", float)
        input_range = self._get_input_range_1x(termination_state)
        scale_min, scale_max = [v / probe_gain for v in input_range]

        if scale is not None:
            if not isinstance(scale, (int, float)) or scale < scale_min or scale > scale_max:
                msg = f"for probe_type {probe_type}"
                if probe_type in ['1X', '10X'] and termination_state in [50, 1e6]:
                    msg += f", termination={termination_state} Ohms."
                else:
                    msg += f", termination set by probe."
                raise ValueError(f"Bad scale value {scale}, should be {scale_min:4.3f} to {scale_max} Volts / Div "
                                 f"{msg}")

        coupling = check_enum_str('coupling', coupling, self.enum_coupling)
        if isinstance(termination_state, (int, float)) and math.isclose(termination_state, 50.0) and coupling == 'AC':
            self.log.warning(f"AC coupling is not allowed with 50 Ohm termination. Defaulting to DC.")

        invert = self.on_off.to_inst(invert)

        if bandwidth is not None:
            # Scope does round up to nearest supported BW, we exploit this to allow instrument substitution,
            # that's why there is not a numeric range check here.
            if bandwidth != 'FULL' and not isinstance(bandwidth, (int, float)):
                raise ValueError(f"Bad bandwidth {bandwidth}, should be 'FULL' or a numeric value.")

        if label is not None and (not isinstance(label, str) or len(label) > 30):
            raise ValueError(f"Bad label {label}, should be string not longer than 30 characters.")

        if offset is not None:
            if not(isinstance(offset, (int, float)) and (self._offset_range.min <= offset <= self._offset_range.max)):
                raise ValueError(f"Bad offset {offset} V, outside maximum limits of {self._offset_range.min} V "
                                 f"to {self._offset_range.max} V.")

        # Offsets larger than datasheet limit seem to cause no errors and result in scope clamping offset to it's
        # extreme for the volts/div range. In addition, the extreme it clamps to is sometimes less than the datasheet
        # value. For these reasons I gave up on trying to pre-check the offset for the scale.

        if position is not None:
            if not (self._position.min <= position <= self._position.max):
                position_actual = min(max(position, self._position.min), self._position.max)
                self.log.warning(f"Requested position {position} outside range {self._position.min} to "
                                 f"{self._position.max}. Setting to {position_actual}.")
                # position = position_actual

        # If we got here all new values are good, write them to instrument:

        if termination is not None:
            # Scale max and coupling depend on this, order matters!
            self.write(f"CH{self.channel_number}:TER", termination)
            actual_termination = self.query(f"CH{self.channel_number}:TER", float)
            if not math.isclose(termination, actual_termination):
                self.log.warning(f"Scope replaced requested termination {termination} with {actual_termination}.")
        if scale is not None:
            self.write(f"CH{self.channel_number}:SCA", scale)
        if coupling is not None:
            self.write(f"CH{self.channel_number}:COUP", coupling.value)
            actual_coupling = self.query(f"CH{self.channel_number}:COUP", self.enum_coupling)
            if coupling != actual_coupling:
                self.log.warning(f"Scope replaced requested coupling {coupling.name} with {actual_coupling.name}.")
        if invert is not None:
            self.write(f"CH{self.channel_number}:INV", self.on_off.to_inst(invert))
        if bandwidth is not None:
            self.write(f"CH{self.channel_number}:BAN", bandwidth)
            actual_bandwidth = self.query(f"CH{self.channel_number}:BAN?", float)
            if bandwidth == 'FULL' or not math.isclose(bandwidth, actual_bandwidth):
                tmp1 = f"'{bandwidth}'" if isinstance(bandwidth, str) else f"{bandwidth:1.5G} Hz"
                tmp2 = f"'{termination_state}'" if isinstance(termination_state, str) else f"{termination_state:1.5G}" \
                                                                                           f" Ohms"
                self.log.warning(f"Bandwidth {tmp1} replaced with {actual_bandwidth:1.5G} Hz for termination={tmp2}.")
        if label is not None:
            self.write(f"CH{self.channel_number}:LABEL:NAME", f'"{label}"')
        if offset is not None:
            # Since offset bounds vary with volts/div settings, inform the user when the scope clamps the offset to a
            # value other than what they asked for.
            self.write(f"CH{self.channel_number}:OFFS", offset)
            actual_offset = self.query(f"CH{self.channel_number}:OFFS", float)
            if not math.isclose(offset, actual_offset):
                self.log.warning(f"Requested offset {offset} V replaced by scope with {actual_offset} V. ")

        if position is not None:
            self.write(f"CH{self.channel_number}:POS", position)

        self.log_inst_errors()

    def _get_input_range_1x(self, termination):
        for term, min_max in self._analog_input_ranges:
            if term == termination:
                return min_max
            elif isinstance(term, (int, float)) and isinstance(termination, (int, float)) and \
                    math.isclose(termination, term):
                return min_max
        raise ValueError(f"No entry in _analog_input_ranges for termination {termination}.")
