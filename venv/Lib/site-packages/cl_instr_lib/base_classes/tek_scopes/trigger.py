from enum import Enum
import re

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max


class Trigger:
    def __init__(self, scope, **kwargs):
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args

        # # Trigger setup is determined by 2 SCPI cmds together, yet on front panel its a selection from
        # # a single menu. Make the enum elements correspond to the items in that menu.

        self.enum_trigA_types = Enum('enum_trigA_types',  {
            'EDGE':           ('EDG',   None,              None),
            'WIDTH':          ('PULS', 'TRIG:A:PULS:CLA', 'WID'),
            'RUNT':           ('PULS', 'TRIG:A:PULS:CLA', 'RUN'),
            'LOGIC':          ('LOG',  'TRIG:A:LOGI:CLA', 'LOGIC'),
            'SETUP_HOLD':     ('LOG',  'TRIG:A:LOGI:CLA', 'SETH'),
            'TRANSITION':     ('PULS', 'TRIG:A:PULS:CLA', 'TRAN'),
            'VIDEO':          ('VID',   None,              None),
        })

        self.enum_edge_sources = Enum('enum_edge_source', {
            'CH1': 'CH1',
            'CH2': 'CH2',
            'CH3': 'CH3',
            'CH4': 'CH4',
            'AUX': 'AUX',
            'ACLINE': 'LINE'
        })
        self.enum_edge_slopes = Enum('enum_edge_slopes', {
            'FALL': 'FALL',
            'RISE': 'RIS'
        })
        self.enum_edge_coupling = Enum('enum_edge_coupling', {
            'DC': 'DC',
            'HFREJ': 'HFR',
            'LFREJ': 'LFR',
            'NOISEREJ': 'NOISE'
        })

        self.trig_level_divs = 4.92
        self.trig_level_aux_volts = {'1X': 6.25, '10X': 12.5}

        self.enum_trig_modes = Enum('enum_trig_modes', {
            'AUTO': 'AUTO',
            'NORMAL': 'NORM'
        })
        self.bounds_holdoff_sec = namedtuple_min_max(20e-9, 8.0)

    @staticmethod
    def _trig_types_reverse(enum_trig_types):
        # Reverse the enum so we can convert the instrument responses back into the enum (menu choice).

        trig_types_rev = {}
        for element in enum_trig_types:
            name, value = element.name, element.value
            scpi_type, scpi_cmd, scpi_class = value
            tmp = trig_types_rev.get(scpi_type)
            if tmp is None:
                if scpi_cmd is None:
                    tmp = (None, name)
                else:
                    tmp = (scpi_cmd, {scpi_class: name})
            else:
                if scpi_cmd is not None:
                    tmp[1].update({scpi_class: name})
                else:
                    raise RuntimeError(f"scpi_type {scpi_type} appears twice with no scpi_cmd.")
            trig_types_rev[scpi_type] = tmp

        return trig_types_rev

    # Note that each trigger type can be configured independently and those configurations are sticky. In other
    # words, choosing a different trigger type brings into effect the settings you previously configured for that type.
    # This is the reason for separating trig_type from the various trig_config* methods.

    def A_event(self, trig_type=None):
        return self._trig_type('A', self.enum_trigA_types, trig_type)

    def _trig_type(self, AorB, trig_enum, trig_type=None):
        """
        Select the type of A event trigger, recalls all settings associated with the selected type.

        :param trig_type:
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # TODO: mode definition.
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:LOGIc:CLAss {LOGIC|SETHold}

        if trig_type is None:
            return_values = {}
            # This weirdness is because the selection in the on-screen menu is determined by 2 SCPI cmds working
            # together. The first determines what the second command is.
            scpi_type = self.query(f"TRIG:{AorB}:TYP?", str)
            scpi_cmd, name_lookup = self._trig_types_reverse(trig_enum)[scpi_type]
            if scpi_cmd is None:
                return_values.update(trig_type=name_lookup)
            else:
                scpi_class = self.query(f"{scpi_cmd}?".replace('{AorB}', AorB), str)
                return_values.update(trig_type=name_lookup[scpi_class])

            return return_values

        # if type_class is not None and type_class.upper() not in self._trig_types:
        #     msg = ", ".join([f'{x}' for x in self._trig_types])
        #     raise ValueError(f"Bad type_class {type_class}, should be one of {msg}.")
        #
        trig_type = check_enum_str('trig_type', trig_type, trig_enum)

        if trig_type is not None:
            # A typical value of the trig_type enum looks like this:
            #     'b_trigger':      ('EDG',  'TRIG:B:STATE', '1'),
            scpi_type, scpi_cmd, scpi_class = trig_type.value
            self.write(f"TRIG:{AorB}:TYP", scpi_type)
            if scpi_cmd is not None:
                scpi_cmd = scpi_cmd.format(AorB=AorB)
                self.write(scpi_cmd, scpi_class)

        self.log_inst_errors()

    def level_50pcnt(self):
        """Defaults to equivalent of pushing the trigger level knob."""

        # TRIGGER:{A|B} command

        self.write(f'TRIG:A', 'SETL')

        self.log_inst_errors()

    def options(self, trig_mode=None, holdoff_sec=None, *args, **kwargs):
        """
        Triggering parameters common to all the triggering types. Select triggering mode.

        :param trig_mode:
        :param holdoff_sec:
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # TRIGger:A:MODe {AUTO|NORMal}
        # TRIGger:A:HOLDoff:TIMe <NR3>

        skip_write = kwargs.pop('skip_write', False)
        self.log_unused_args(args, kwargs)

        if all(v is None for v in (trig_mode, holdoff_sec)):
            return_values = {}
            return_values.update(trig_mode=self.query("TRIG:A:MOD?", self.enum_trig_modes).name)
            return_values.update(holdoff_sec=self.query("TRIG:A:HOLD:TIM?", float))
            return return_values

        trig_mode = check_enum_str('trig_mode', trig_mode, self.enum_trig_modes)

        if holdoff_sec is not None:
            if not isinstance(holdoff_sec, (int, float)) \
                    or not(self.bounds_holdoff_sec.min <= holdoff_sec <= self.bounds_holdoff_sec.max):
                raise ValueError(f"Bad holdoff {holdoff_sec}, should be {self.bounds_holdoff_sec.min} to"
                                 f" {self.bounds_holdoff_sec.max} sec.")

        # A derived class might be using us just for some input checking...
        if skip_write:
            return trig_mode, holdoff_sec  # Return to derived class so it can finish check the rest of its
            # parameters.

        if trig_mode is not None:
            self.write("TRIG:A:MOD", trig_mode.value)

        if holdoff_sec is not None:
            self.write("TRIG:A:HOLD:TIM",  holdoff_sec)

        self.log_inst_errors()

    def edge_config(self, source=None, level=None, slope=None, coupling=None, *args, **kwargs):
        """
        Query all or set any combination of parameters for edge trigger.

        :param source: 'CH1', 'CH2', 'CH3', 'CH4', 'AUX', 'ACLINE'.
        :param level: Voltage level in Volts.
        :param slope: 'RISE', 'FALL'
        :param coupling: 'AC', 'DC', 'HFR', 'LFR' as applicable
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.

        """

        # TRIGger:A:EDGE:SOUrce {AUX|CH1|CH2|CH3|CH4|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|LINE|RF}
        # TRIGger:A:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:A:LEVel:CH<x> {<NR3>|ECL|TTL}
        # TRIGger:A:LEVel:AUXin {<NR3>|ECL|TTL}    # TODO: Set trig level on AUX in?
        # TRIGger:A:EDGE:SLOpe {RISe|FALL|EITHer}
        # TRIGger:A:EDGE:COUPling {AC|DC|HFRej|LFRej|NOISErej}

        # TRIGger:A:LEVel:D<x> {<NR3>|ECL|TTL}  # TODO: Only needed for MSO instruments.

        skip_write = kwargs.pop('skip_write', False)
        self.log_unused_args(args, kwargs)

        self.write("TRIG:A:TYP", self.enum_trigA_types.EDGE.value[0])

        if all(v is None for v in (source, level, slope, coupling)):
            return_values = {}
            return_values.update(source=self.query("TRIG:A:EDGE:SOU?", self.enum_edge_sources).name)
            return_values.update(level=self.query("TRIG:A:LEV", float))  # Reads current source value.
            return_values.update(slope=self.query("TRIG:A:EDGE:SLO?", self.enum_edge_slopes).name)  # current source val
            return_values.update(coupling=self.query("TRIG:A:EDGE:COUP?", self.enum_edge_coupling).name)
            return return_values

        source = check_enum_str('source', source, self.enum_edge_sources)
        if source is None:
            source_state = self.query("TRIG:A:EDGE:SOU", self.enum_edge_sources)
        else:
            source_state = source

        coupling = check_enum_str('coupling', coupling, self.enum_edge_coupling)
        if coupling is None:
            coupling_state = self.query("TRIG:A:EDGE:COUP?", self.enum_edge_coupling)
        else:
            coupling_state = coupling

        if re.match('^CH[1-4]$', source_state.name) is None:
            # Scope coerces coupling to DC for AUX and ACLINE.
            if coupling is not None and coupling != self.enum_edge_coupling.DC:
                self.log.warning(f"Edge trigger coupling cannot be set to '{coupling.name}' for source "
                                 f"'{source_state.name}'. Defaults to 'DC'.")
                coupling = None

        if level is not None:
            # See trigger Level ranges in scope data sheet.
            if source_state == self.enum_edge_sources.ACLINE:
                raise ValueError(f"Cannot set trigger level for source '{source_state.name}'. 0V only.")

            level_min, level_max = self._calc_trig_level_range(source_state, coupling_state)

            if not isinstance(level, (int, float)) or not (level_min <= level <= level_max):
                # Sending out of bounds level via command doesn't cause error, it just sets level to min or max,
                # so we just warn.
                level_actual = min(max(level, level_min), level_max)
                self.log.warning(f"Requested level {level} out of range {level_min} to {level_max} for source "
                                 f"{source_state}. Defaulting to {level_actual}.")

        slope = check_enum_str('slope', slope, self.enum_edge_slopes)

        # A derived class might be using us just for some input checking...
        if skip_write:
            return source, level, slope, coupling  # Return to derived class so it can finish check
            # the rest of its parameters.

        # If we got here all new values are good, write them to instrument:

        if source is not None:
            self.write("TRIG:A:EDGE:SOU", source.value)
        if slope is not None:
            self.write("TRIG:A:EDGE:SLO", slope.value)
        if coupling is not None:
            self.write("TRIG:A:EDGE:COUP", coupling.value)
        if level is not None:
            self.write(f"TRIG:A:LEV", level)  # Sets current source value.

        self.log_inst_errors()

    def _calc_trig_level_range(self, source, coupling=None):
        # See trigger Level ranges in scope data sheet.

        if source.name == 'AUX':
            attenuation = int(1.0 / self.query(f"AUXin:PROBE:GAIN", float))   # 5k/7k insists on 'AUXin' not 'AUX' !

            volts = self.trig_level_aux_volts[f"{attenuation}X"]
            return -1*volts, volts
        elif source.name.startswith('D'):
            return -40, 40        # TODO: Confirm this on MSO scope.
        elif source.name.startswith('CH'):
            # Scale include the effect of 1X vs 10X probes so we don't need to get the probe gain here.
            scale = self.query(f"{source.value}:SCA?", float)
            if coupling is not None:
                if coupling == 'LFREJ':
                    return -1.0 * self.trig_level_divs * scale, self.trig_level_divs * scale
            offset = self.query(f"{source.value}:OFFS?", float)
            position = self.query(f"{source.value}:POS?", float)

            return -1.0 * scale * (self.trig_level_divs + position) + offset,\
                scale * (self.trig_level_divs - position) + offset

        elif source.name == 'ACLINE':
            return 0, 0
        else:
            self.log.warning(f"Level range check not implemented for source {source.name}.")
            return float('-inf'), float('+inf')

    def force(self):
        """Cause a trigger event. """
        self.write('TRIG', 'FORC')

    def state(self):
        """Returns scope trigger state: 'READY' or 'TRIGGER"""

        return self.query('TRIG:STATE', str)  # TODO: Make agnostic to VERBOSE mode.

    # TODO: Research which other trig modes are common to all scope models (and makes?) we have want to be able to
    #  interchange.

    # def logic_clked_config(self, function=None, pattern=None, thresholds=None, clk_source=None, clk_edge=None,
    #                      *args, **kwargs):
    #     """
    #
    #     :param function:
    #     :param pattern:
    #     :param thresholds:
    #     :param clk_source:
    #     :param clk_edge:
    #     :return:
    #     """
    #     pass
    #
    # def logic_pattern_config(self, function=None, pattern=None, thresholds=None, when=None, delta_time=None,
    #                        *args, **kwargs):
    #     pass
    #
    # def setup_hold_config(self, sources=None, thresholds=None, clk_source=None, clk_edge=None, time_setup=None,
    #                     time_hold=None, *args, **kwargs):
    #     pass
    #
    # def pulse_width_config(self, source=None, polarity=None, when=None, width=None, threshold=None,
    #                      *args, **kwargs):
    #     pass
    #
    # def runt_config(self, source=None, polarity=None, when=None, width=None, threshold_lower=None,
    #                 threshold_upper=None, *args, **kwargs):
    #     pass
    #
    # def timeout_config(self, source=None, polarity=None, timeout_sec=None, *args, **kwargs):
    #     pass
    #
    # def slew_config(self, source=None, polarity=None, when=None, delta_time=None, *args, **kwargs):
    #     pass
    #
    # def bus_i2c_config(self, bus_num=None, addr_mode=None, addr_type=None, trig_condition=None, data_direction=None,
    #                    address=None, data_size=None, data_value=None, *args, **kwargs):
    #     pass
    #
    # def bus_spi_config(self, bus_num=None, trig_condition=None, data_size=None, miso_data=None, mosi_data=None,
    #                  *args, **kwargs):
    #     pass
