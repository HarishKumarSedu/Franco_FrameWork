from enum import Enum

from cl_instr_lib.base_classes.tek_scopes.acquire import Acquire
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max
from cl_instr_lib.helpers.check_enum_str import check_enum_str


class Acquire_5k_7k(Acquire):
    """Class providing the **Acquisition** controls of a Tektronix 5000 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        # Redefine parameters used in the parent class.

        self.enum_acq_modes = Enum('enum_acq_modes', {
            'SAMPLE': 'SAMPLE',
            'AVERAGE': 'AVERAGE',
            'PEAKDETECT': 'PEAKDETECT',
            'HIRES': 'HIRES',
            'ENVELOPE': 'ENVELOPE'
        })   # WFMDB not implemented.

        self.enum_roll_mode = Enum('enum_roll_mode', {'AUTO': 'AUTO', 'OFF': 'OFF', 'ON': 'ON'})
        self.enum_sampling_mode = Enum('enum_sampling_modes', {'RT': 'RT', 'ET': 'ET', 'IT': 'IT'})

        self.bounds_ave_num_wfms = namedtuple_min_max(2, 10000)

    def setup(self, state=None, stop_after=None, acq_mode=None, ave_num_wfms=None,
              env_num_wfms=None, roll_mode=None, sampling_mode=None, *args, **kwargs):
        """
        Query all or set any combination of scope acquisition related parameters.

        :param state: 'RUN' or 'STOP'.
        :type state: str|enum_state
        :param stop_after: 'CONTINUOUS' or 'SINGLE'.
        :type stop_after: str|enum_stop_after
        :param acq_mode: 'SAMPLE', 'PEAKDETECT', 'HIRES', 'AVERAGE, or 'ENVELOPE'.
        :type acq_mode: str|enum_acq_modes
        :param ave_num_wfms: 2 to 10000, takes effect only in AVERAGE mode.
        :type ave_num_wfms: int
        :param ave_num_wfms: 2 to 10000, takes effect only in ENVELOPE mode.
        :type ave_num_wfms: int
        :param roll_mode: Use roll mode to observe data at very low sweep speeds, this allows data samples to be
            observed on screen as they occur.

            * 'AUTO' - enables Roll Mode, if the time/division is set appropriately.
            * 'OFF' -  disables Roll Mode.
            * 'ON' - enables Roll Mode, if the time/division is set appropriately.

        :type roll_mode: str|enum_roll_mode
        :param sampling_mode:

            * 'RT' - In Real-Time sampling the instrument samples fast enough to completely fill a waveform record \
                from a single trigger event. Use real-time sampling to capture single-shot or transient events.
            * 'ET' - In Equivalent-Time sampling, the the instrument acquires signals over many repetitions of the \
                event. This instrument uses a type of equivalent time sampling called random equivalent time \
                sampling. An internal clock runs asynchronously with respect to the input signal and the signal \
                trigger. The instrument takes samples continuously, independent of the trigger position, and \
                displays them based on the time difference between the sample and the trigger. Although the samples \
                are taken sequentially in time, they are random with respect to the trigger.
            * 'IT' - Interpolation is allowed.
        :type sampling_mode: str|enum_sampling_modes
        :return: Query is returned as a dict of parameter name-value pairs.
        """

        # TODO: Add fast_acq
        # TODO: Add ENOB

        # ACQuire:STATE {OFF|ON|RUN|STOP|<NR1>}
        # ACQuire:STOPAfter {RUNSTop|SEQuence}
        # ACQuire:MODe {SAMple|AVErage}
        # ACQuire:NUMACq?                  # Query only
        # ACQuire:NUMAVg <NR1>             # pertains only to AVE mode
        # ACQuire:NUMEnv {<NR1>|INFInite} # pertains only to ENV mode
        # ACQuire:NUMSAMples <NR1>
        # ACQuire:SAMPlingmode {RT|ET|IT}
        # HORizontal:ROLL {AUTO|OFF|ON}

        self.log_unused_args(args, kwargs)

        if all(v is None for v in (state, stop_after, acq_mode, ave_num_wfms, env_num_wfms, roll_mode, sampling_mode)):
            return_values = super().setup()
            return_values.update(env_num_wfms=self.query('ACQ:NUME', int))
            return_values.update(roll_mode=self.query('HOR:ROLL', self.enum_roll_mode).name)
            return_values.update(sampling_mode=self.query('ACQ:SAMP', self.enum_sampling_mode).name)
            # return_values.update(wfmdb_samples=self.query('ACQ:NUMSAM', int))
            return return_values

        # Delegate some of the checking to the super class.
        if any(v is not None for v in (state, stop_after, acq_mode, ave_num_wfms)):
            state, stop_after, acq_mode, ave_num_wfms = \
                super().setup(state=state, stop_after=stop_after, acq_mode=acq_mode,
                              ave_num_wfms=ave_num_wfms, skip_write=True)

        if acq_mode is None:
            acq_mode_state = self.query("ACQ:MOD?", self.enum_acq_modes)
        else:
            acq_mode_state = acq_mode  # super class converts to enum

        if env_num_wfms is not None:
            if isinstance(env_num_wfms, str) and env_num_wfms.upper().startswith('INFI'):
                env_num_wfms = 'INFI'
                self.log.warning(f"env_num_wfms value {env_num_wfms}, this is interpreted by the scope as 2e9.")
            elif isinstance(env_num_wfms, (int, float)) and (2 <= env_num_wfms <= 2e9):
                env_num_wfms = int(env_num_wfms)
            else:
                raise ValueError(f"Bad env_num_wfms {env_num_wfms}, should be 1 to 2e9 or 'INFINITE.")
            if acq_mode_state != self.enum_acq_modes.ENVELOPE:
                self.log.warning(f"For new env_num_wfms '{env_num_wfms}' to take effect, you must set acq_mode to "
                                 f"'ENVELOPE'. Present mode is '{acq_mode_state.name}'.")

        sampling_mode = check_enum_str('sampling_mode', sampling_mode, self.enum_sampling_mode)
        roll_mode = check_enum_str('roll_mode', roll_mode, self.enum_roll_mode)

        if state is not None:
            self.write("ACQ:STATE", state.value)
        if stop_after is not None:
            self.write("ACQ:STOPA", stop_after.value)
        if acq_mode is not None:
            self.write("ACQ:MOD", acq_mode.value)
        if ave_num_wfms is not None:
            self.write("ACQ:NUMAV", ave_num_wfms)
        if env_num_wfms is not None:
            self.write("ACQ:NUME", env_num_wfms)
        if roll_mode is not None:
            self.write('HOR:ROLL', roll_mode.value)
        if sampling_mode is not None:
            self.write('ACQ:SAMP', sampling_mode.value)

        self.scope.log_inst_errors()
