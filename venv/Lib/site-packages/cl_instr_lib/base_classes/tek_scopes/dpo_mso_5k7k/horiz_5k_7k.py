from enum import Enum
from collections import namedtuple
import re

from cl_instr_lib.base_classes.tek_scopes.horiz import Horiz
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max
from cl_instr_lib.helpers.check_enum_str import check_enum_str

is_writable_in_mode = namedtuple('is_writable', ['scale', 'record_length', 'record_length_limit'])


class Horiz_5k_7k(Horiz):
    """Class providing the **Horizontal** controls of a Tektronix 5000 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        self.bounds_delay = namedtuple_min_max(0, 1000)  # sec.
        self.enum_mode = Enum('enum_mode', {
            'AUTO': 'AUTO',
            'CONSTANT': 'CONSTANT',
            'MANUAL': 'MANUAL'
        })
        self._record_length_min = 50  # See method record_length_max

        self._writable_params_in_mode = {
            #                        ['scale', 'record_length', 'record_length_limit']
            'AUTO':     is_writable_in_mode(True,  False, True),
            'CONSTANT': is_writable_in_mode(True,  False, False),
            'MANUAL':   is_writable_in_mode(False, True,  False)
         }
        self._sample_rate_min = 2.5   # per sec. See method sample_rate_max

    def get_sample_rate_max(self, num_channels_active):
        """Returns maximum sample rate considering scope model and number of channels currently active."""

        model = self.scope.model
        options_installed = self.scope.options_installed

        if re.match('^(MSO|DPO)(5034)B?$', model) or re.match('^(MSO|DPO)(5054)B?$', model):
            return {1: 5e9, 2: 5e9, 3: 5e9, 4: 5e9}[num_channels_active]
        elif re.match('^(MSO|DPO)(5104)B?', model) or re.match('^(MSO|DPO)(5204)B?$', model):
            return {1: 10e9, 2: 10e9, 3: 5e9, 4: 5e9}[num_channels_active]
        elif re.match('^DPO7054$', model):
            if '2SR' not in options_installed:
                return {1: 10e9, 2: 5e9, 3: 2.5e9, 4: 2.5e9}[num_channels_active]
            else:
                return {1: 20e9, 2: 10e9, 3: 5e9, 4: 5e9}[num_channels_active]
        elif re.match('^DPO7104$', model):
            if '2SR' not in options_installed:
                return {1: 20e9, 2: 10e9, 3: 5e9, 4: 5e9}[num_channels_active]
            else:
                return {1: 40e9, 2: 20e9, 3: 10e9, 4: 10e9}[num_channels_active]
        elif re.match('^DPO7254$', model):
            return {1: 40e9, 2: 20e9, 3: 10e9, 4: 10e9}[num_channels_active]
        elif re.match('^DPO7054C$', model):
            return {1: 20e9, 2: 10e9, 3: 5e9, 4: 5e9}[num_channels_active]
        elif re.match('^DPO7104C$', model):
            if '2SR' not in options_installed:
                return {1: 20e9, 2: 10e9, 3: 5e9, 4: 5e9}[num_channels_active]
            else:
                return {1: 40e9, 2: 20e9, 3: 10e9, 4: 10e9}[num_channels_active]
        elif re.match('^DPO7[23]54C?$', model):
            return {1: 40e9, 2: 20e9, 3: 10e9, 4: 10e9}[num_channels_active]
        else:
            raise ValueError(f"Cannot determine _sample_rate_max for oscope model {model}.")

    def get_record_length_max(self, num_channels_active):
        """Return maximum record length considering scope options installed and number of channels currently active."""

        model = self.scope.model
        options_installed = self.scope.options_installed

        # Check the possible options
        if '2RL' in options_installed:
            if re.match('^(MSO|DPO)(50[35]4)$', model):
                return int(25e6)
            elif re.match('^(MSO|DPO)(5[12]04)$', model):
                return int({1: 50e6, 2: 50e6, 3: 25e6, 4: 25e6}[num_channels_active])
            elif re.match('^DPO7(05|10|25|35)4$', model):
                return int({1: 80e6, 2: 40e6, 3: 20e6, 4: 20e6}[num_channels_active])

        if '5RL' in options_installed:
            if re.match('^(MSO|DPO)(50[35]4)B?$', model):
                return int(50e6)
            elif re.match('^(MSO|DPO)(5[12]04)B?$', model):
                return int({1: 125e6, 2: 125e6, 3: 50e6, 4: 50e6}[num_channels_active])
            elif re.match('^DPO7(05|10|25|35)4$', model):
                return int({1: 200e6, 2: 100e6, 3: 50e6, 4: 50e6}[num_channels_active])
            elif re.match('^DPO7(05|10|25|35)4C$', model):
                return int({1: 250e6, 2: 125e6, 3: 50e6, 4: 50e6}[num_channels_active])

        if '10RL' in options_installed:
            if re.match('^(MSO|DPO)(50[35]4)B?$', model):
                return int(125e6)
            elif re.match('^(MSO|DPO)(5[12]04)B?$', model):
                return int({1: 250e6, 2: 250e6, 3: 125e6, 4: 125e6}[num_channels_active])
            elif re.match('^DPO7[23]54$', model):
                return int({1: 400e6, 2: 200e6, 3: 100e6, 4: 100e6}[num_channels_active])
            elif re.match('^DPO7(25|35)4C$', model):
                return int({1: 500e6, 2: 250e6, 3: 125e6, 4: 125e6}[num_channels_active])

        # No more possible RL options, so use the Standard Configuration.
        if re.match('^(MSO|DPO)(50[35]4)$', model):
            return int(12.5e6)

        if re.match('^(MSO|DPO)(5[12]04)$', model):
            return int({1: 25e6, 2: 25e6, 3: 12.5e6, 4: 12.5e6}[num_channels_active])

        if re.match('^(MSO|DPO)(50[35]4)B$', model):
            return int(25e6)

        if re.match('^(MSO|DPO)(5[12]04)B$', model):
            return int({1: 50e6, 2: 50e6, 3: 25e6, 4: 25e6}[num_channels_active])

        if re.match('^DPO7(05|10|25|35)4$', model):
            return int({1: 40e6, 2: 20e6, 3: 10e6, 4: 10e6}[num_channels_active])

        if re.match('^DPO7(05|10|25|35)4C$', model):
            return int({1: 125e6, 2: 50e6, 3: 25e6, 4: 25e6}[num_channels_active])

        rl_max = int(500e6)
        self.log.warning(f"Could not determine record_length max for model '{model}'. Will try {rl_max/1e6}M, "
                         "scope may limit to less!")

        return int(250e6)   # Return biggest possible, scope will limit to its actual max with no error.

    def get_scale_bounds(self, mode):
        """Return min/max for scale in sec/div (time base range) considering scope model and options installed."""

        model = self.scope.model
        options_installed = self.scope.options_installed

        if re.match('^(MSO|DPO)(5(03|05|10|20)4)$', model):
            scale_min = 12.5e-12 if mode == 'MANUAL' else 250e-12
            return namedtuple_min_max(scale_min, 1e3)
        elif re.match('^(MSO|DPO)(5(03|05|10|20)4)B$', model):
            scale_min = 12.5e-12 if mode == 'MANUAL' else 250e-12
            return namedtuple_min_max(scale_min, 8e6)
        # DPO7054/DPO7104/DPO7254/DPO7354 based on Tek html page, (no pdf's available).
        # PDFs found on resellers sites don't agree.
        elif re.match('^DPO7054$', model):
            if '2SR' not in options_installed:
                scale_min = 50e-12 if mode == 'MANUAL' else 1e-9
            else:
                # Not in datasheet, but this is what oscope S/N C130422 appears to do.
                scale_min = 25e-12 if mode == 'MANUAL' else 500e-12
            return namedtuple_min_max(scale_min, 1e3)
        elif re.match('^DPO7104$', model):
            if '2SR' not in options_installed:
                scale_min = 50e-12 if mode == 'MANUAL' else 1e-9
            else:
                scale_min = 25e-12 if mode == 'MANUAL' else 500e-12
            return namedtuple_min_max(scale_min, 1e3)
        elif re.match('^DPO7[23]54$', model):
            scale_min = 25e-12 if mode == 'MANUAL' else 500e-12
            return namedtuple_min_max(scale_min, 1e3)
        elif re.match('^DPO7054C$', model):
            scale_min = 1.25e-12 if mode == 'MANUAL' else 25e-12
            return namedtuple_min_max(scale_min, 8e6)
        elif re.match('^DPO7104C$', model):
            scale_min = 1.25e-12 if mode == 'MANUAL' else 25e-12
            if '2SR' not in options_installed:
                return namedtuple_min_max(scale_min, 8e6)
            else:
                return namedtuple_min_max(scale_min, 8.19e6)
        elif re.match('^DPO7(25|35)4C$', model):
            scale_min = 1.25e-12 if mode == 'MANUAL' else 25e-12
            return namedtuple_min_max(scale_min, 8.19e6)

        scale_min = 1.25e-12
        scale_max = 8.19e6
        self.log.warning(f"Could not determine scale bounds for '{model}' in mode {mode}. Will use scale_min= "
                         f"{scale_min/1e-12}ps, scale_max={scale_max} s. Scope may impose different bounds!")

        return namedtuple_min_max(1.25e-12, 8.19e6)   # Scope will limit to its actual min/max with no error.

    def get_horiz_divisions(self):
        """
        Returns the number of graticule divisions over which the waveform is displayed. Query only.
        """

        # HORizontal:DIVisions?
        return self.query('HOR:DIV', float)

    def setup(self, scale=None, delay_mode=None, position_pcnt=None, delay_time=None, record_length=None,
              mode=None, sample_rate=None, record_length_limit=None, *args, **kwargs):
        """
        Queries all or sets any combination of horizontal parameters.

        :param scale: seconds per horizontal division
        :param delay_mode: 'OFF' is horizontal position as % of record length. 'ON' is delay time from trigger.
        :param position_pcnt: Shifts view of the captured record from 0 to 100 % point. Takes effect when delay_mode is
            'OFF'.
        :param delay_time: Delay in seconds from trigger point. Takes effect when delay_mode is 'ON'.
        :param record_length: Length of acquisition. Only in effect when mode is 'MANUAL'. Maximum depends
            on which RL option is installed and number of channels operating. See method _record_length_max.
        :param mode: Element of enum_mode: 'AUTO', 'CONSTANT', or 'MANUAL'.

            'AUTO'
                You may program **scale** and **sample_rate** but not record_length.
            'CONSTANT'
                You may program **scale** and **sample_rate** but not record_length or record_length_limit.
            'MANUAL'
                You may program **sample_rate** and **record_length** but not scale or record_length_limit.

        :param record_length_limit: Limits record_length chosen by mode 'AUTO'.
        :param sample_rate: 2.5 samp/sec to a maximum determined by scope model and number of channels operating. See
            method _sample_rate_max.
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. Note that the set of keywords returned correspond to those that can be set in the current mode.
        """

        # HORizontal:MODE:SCAle <NR3>
        # HORizontal:DELay:MODe {OFF|ON|<NR1>}
        # HORizontal:POSition <NR3>
        # HORizontal:DELay:TIMe <NR3>

        # HORizontal:MODE {AUTO|CONStant|MANual}
        # HORizontal:MODE:RECOrdlength <NR1>
        # HORizontal:MODE:SAMPLERate
        # HORizontal:MODE:AUTO:LIMITrecordlen

        # HORizontal:ACQDURATION? # TODO: Separate function for this?

        self.log_unused_args(args, kwargs)

        mode_state = self.query("HOR:MODE", self.enum_mode)

        if all(v is None for v in (scale, delay_mode, position_pcnt, delay_time, record_length,
                                   mode, sample_rate, record_length_limit)):
            return_values = {}
            return_values.update(scale=self.query("HOR:SCA?", float))
            return_values.update(delay_mode=self.on_off.to_api(self.query("HOR:DEL:MOD", int)))
            return_values.update(position_pcnt=self.query("HOR:POS", float))
            return_values.update(delay_time=self.query("HOR:DEL:TIM", float))
            return_values.update(record_length=self.query("HOR:MODE:RECO", int))
            return_values.update(mode=mode_state.name)
            return_values.update(sample_rate=self.query("HOR:MODE:SAMPLERate", float))
            return_values.update(record_length_limit=self.query("HOR:MODE:AUTO:LIMIT", int))

            # Ensure we can use the dict in call to this method. These parms are settable in some modes only.
            # TODO: Make a separate method to read back the parameters that are read only. VALTECH-500
            if mode_state == self.enum_mode.AUTO:
                return_values.pop('record_length')
            elif mode_state == self.enum_mode.CONSTANT:
                return_values.pop('record_length')
                return_values.pop('record_length_limit')
            elif mode_state == self.enum_mode.MANUAL:
                return_values.pop('scale')
                return_values.pop('record_length_limit')

            return return_values

        mode = check_enum_str('mode', mode, self.enum_mode)
        if mode is not None:
            mode_state = mode
        is_writable = self._writable_params_in_mode[mode_state.name]

        if scale is not None:
            if not is_writable.scale:
                raise ValueError(f"Scale cannot be set in mode '{mode_state.name}'.")

            scale_bounds = self.get_scale_bounds(mode_state.name)
            if not isinstance(scale, (int, float)) or not(scale_bounds.min <= scale <= scale_bounds.max):
                scale_tmp = min(max(scale, scale_bounds.min), scale_bounds.max)
                self.log.warning(f"Requested scale {scale} outside range {scale_bounds.min} to "
                              f"{scale_bounds.max}. Setting to {scale_tmp}.")
                scale = scale_tmp

        num_channels_active = len(self.scope.vertical.channel_display()['on_list'])
        record_length_max = self.get_record_length_max(num_channels_active)

        if record_length is not None:
            if not is_writable.record_length:
                raise ValueError(f"record_length cannot be set in mode '{mode_state.name}'.")
            else:
                record_length = int(record_length)
                if not (self._record_length_min <= record_length <= record_length_max):
                    raise ValueError(f"Bad record_length {record_length}, should be {self._record_length_min} to "
                                     f"{record_length_max} for operation with "
                                     f"{num_channels_active} active channels.")

        if record_length_limit is not None:
            if not is_writable.record_length_limit:
                raise ValueError(f"record_length_limit cannot be set in mode '{mode_state.name}'.")
            else:
                record_length_limit = int(record_length_limit)
                if not (self._record_length_min <= record_length_limit <= record_length_max):
                    raise ValueError(f"Bad record_length_limit {record_length_limit}, should be "
                                     f"{self._record_length_min} to {record_length_max} "
                                     f"for operation with {num_channels_active} channels.")

        if delay_mode is not None and delay_mode not in self.on_off.api_values():
            msg = ", ".join([f"'{x}'" for x in self.on_off.api_values()])
            raise ValueError(f"Bad delay_mode {delay_mode}, should be one of {msg}.")

        if position_pcnt is not None:
            if delay_mode is None:
                delay_mode_state = self.on_off.to_api(self.query('HOR:DEL:MOD?', int))
            else:
                delay_mode_state = delay_mode
            if 'ON' == delay_mode_state:
                self.log.warning(f"Must change delay_mode setting to 'OFF' for position_pcnt to take effect.")
            if not isinstance(position_pcnt, (int, float)) or position_pcnt < 0 or position_pcnt > 100:
                position_pcnt_tmp = min(max(position_pcnt, 0.0), 100.0)
                self.log.warning(f"Bad position_pcnt value {position_pcnt}, setting to {position_pcnt_tmp} percent.")

        if delay_time is not None:
            if delay_mode is None:
                delay_mode_state = self.on_off.to_api(self.query('HOR:DEL:MOD?', int))
            else:
                delay_mode_state = delay_mode
            if 'OFF' == delay_mode_state:
                self.log.warning(f"delay_mode is 'OFF', set to 'ON' for new delay time to take effect.")
            if scale is None:
                horiz_delay_min = -10 * self.query("HOR:SCA", float)
            else:
                horiz_delay_min = -10 * scale
            if not isinstance(delay_time, (int, float)) or not(horiz_delay_min <= delay_time <= self.bounds_delay.max):
                delay_time_tmp = min(max(delay_time, horiz_delay_min), self.bounds_delay.max)
                self.log.warning(f"delay_time {delay_time}, outside range {horiz_delay_min:4.1G} (-10 divisions) to "
                              f"{self.bounds_delay.max} sec. Setting to {delay_time_tmp:4.1G}.")
                delay_time = delay_time_tmp

        if sample_rate is not None:
            if not (self._sample_rate_min <= sample_rate <= self.get_sample_rate_max(num_channels_active)):
                raise ValueError(f"Bad sample_rate {sample_rate}, should be {self._sample_rate_min} to "
                                 f"{self.get_sample_rate_max(num_channels_active)}")

        # If we got here all new values are good, write them to instrument:

        if mode is not None:
            self.write("HOR:MODE", mode_state.value)
        if scale is not None:
            self.write("HOR:MODE:SCA", scale)
        if delay_mode is not None:  # Order is important here!
            self.write("HOR:DEL:MOD", self.on_off.to_inst(delay_mode))
        if position_pcnt is not None:
            self.write("HOR:POS", position_pcnt)
        if delay_time is not None:
            self.write("HOR:DEL:TIM", delay_time)
        if record_length is not None:
            self.write("HOR:MODE:RECO", int(record_length))
        if record_length_limit is not None:
            self.write("HOR:MODE:AUTO:LIMIT", record_length_limit)
        if sample_rate is not None:
            self.write("HOR:MODE:SAMPLERate", sample_rate)  # Long form used for readability in log,

        # TODO: Setting record_length_limit doesn't seem to affect record lengths that are being chosen by AUTO mode.
        #  Scope FW bug? 'TEKTRONIX,DPO5104B,C052180,CF:91.1CT FV:10.8.3 Build 3'

        # TODO: Setting large record_length with slow sample_rate can cause bus timeout.

        self.log_inst_errors()

    def get_readonly_parameters(self):
        """
        Reads and returns the horizontal mode and those parameters that are readonly in the present mode.

        The keys in the returned dict depend on mode:

            AUTO
                resolution, duration, record_length, interp_ratio
            CONSTANT
                resolution, duration, record_length, interp_ratio
            MANUAL
               resolution, duration, scale, interp_ratio

        In the scope GUI, resolution and duration are always greyed out; record_length and scale are greyed out
        depending on the mode. The GUI does not display interp_ratio.
        """

        return_values = {}
        mode_state = self.query("HOR:MODE", self.enum_mode)
        return_values.update(mode=mode_state.name)

        # Could not find a SCPI command to read this.
        sample_rate = self.query("HOR:MODE:SAMPLERate", float)
        return_values.update(resolution=1.0/sample_rate)

        return_values.update(duration=self.query('HOR:ACQDURATION', float))

        if mode_state == self.enum_mode.AUTO or mode_state == self.enum_mode.CONSTANT:
            return_values.update(record_length=self.query("HOR:MODE:RECO", int))
        else:
            return_values.update(scale=self.query("HOR:SCA?", float))

        return_values.update(interp_ratio=self.query('HOR:MAI:INTERPR', float))

        return return_values
