from enum import Enum
import time

from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import OscopeTekBase
from cl_instr_lib.base_classes.tek_scopes.dpojet.dpojet import Dpojet

from cl_instr_lib.helpers.check_enum_str import check_enum_str


class OscopeTekBase5k7k(OscopeTekBase):

    def __init__(self, visa_resource_name, logger, **kwargs):
        super().__init__(visa_resource_name, logger, **kwargs)

        self.model = self.get_model()
        self.options_installed = self.get_options_dict()

        self.enum_autoset_actions = Enum('enum_autoset_actions', {
            'EXECUTE': 'EXEC',
            'UNDO': 'UNDO'
        })

        #: To use the :ref:`DPOJET Application <dpojet>`, call
        #: :meth:`~cl_instr_lib.base_classes.tek_scopes.oscope_tek_base.activate_dpojet` to initialize this attribute
        #: with a driver object.
        self.dpojet = None

        scope_options = self.get_options_dict()
        if not('DJA' in scope_options or 'DJE' in scope_options):
            self.log.info("Oscope is NOT equipped with DPOJET edition 'DJE' or 'DJA'. Deleting attribute 'dpojet'.")
            delattr(self, 'dpojet')
        else:
            self.log.info("Oscope IS equipped with DPOJET. Call method activate_dpojet to populate the attribute "
                          "dpojet with the appropriate driver object.")

    def get_options_dict(self):
        """Returns dictionary of option name-description pairs. Performs '\*OPT?' query. """

        opt_result = self.query('*OPT', str).rstrip(', ')
        if opt_result == 'UNKNOWN':
            return {}
        tmp = [x.split(':') for x in opt_result.split(',')]
        return dict((k.strip(), v.strip()) for k, v in tmp)

    # TODO: Display persistence, etc.

    # def cursors(self, kind, source, direction, linked, cursor_units, *args, **kwargs):
    #
    #     # TODO: Not sure if there is any universal way to specify some basic cursor operations.
    #     pass
    #

    def menu_off(self):
        """Turns off any menu presently displayed. Equivalent of front panel button Menu Off."""

        self.write('FPANel:PRESS', "menuoff")

    # TODO: Work out wait till complete.
    def autoset(self, action):
        """Similar to the Autoset front panel button, but also providing UNDO.

        :param action: a value from enum_autoset_actions: 'EXECUTE', 'UNDO'. Must be provided, serves a "are you
            sure" precaution.
        :type action: (str|enum_autoset_actions)
        """

        action = check_enum_str('action', action, self.enum_autoset_actions)
        if action is not None:
            self.write('AUTOSet', action.value)
            time.sleep(5)
            # self.write('*WAI', "")

        self.log_inst_errors()

    def activate_dpojet(self):
        """Call this method to populate the attribute dpojet with a driver object
        (:class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.dpojet.Dpojet`) that provides the methods to
        operate the :ref:`DPOJET Application <dpojet>`.

        This will open the DPOJET GUI on the oscope. (On MSO/DPO 5000 series, calling the method menu_off will
        remove the DPOJET GUI from the screen but you can still operate DPOJET. There is no comparable command I
        could find for 7000 series.)

        Does nothing if DPOJET is not installed in your oscope.
        """

        scope_options = self.get_options_dict()

        if not hasattr(self, 'dpojet'):
            raise ValueError('DPOJET option is not installed!')

        if 'DJA' in scope_options:
            self.dpojet = Dpojet(self, 'DJA')
        elif 'DJE' in scope_options:
            self.dpojet = Dpojet(self, 'DJE')
        else:
            raise ValueError("Could not find DPOJET edition 'DJE' or 'DJA' in oscope options.")

if __name__ == '__main__':
    # oscope_obj = OscopeTekBase(None)
    # oscope_obj = OscopeTekBase('USB0::0x0699::0x0503::C052180')    # DPO5104B
    oscope_obj = OscopeTekBase('USB0::0x0699::0x374::C010264')   # DPO2024
    oscope_obj.logging = True
