import time
from enum import Enum
from typing import Dict, Union

from cl_instr_lib.base_classes.tek_scopes.dpo_mso_5k7k.trigger_5k_7k.trigger_5k_7k import Trigger_5k_7k
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.helpers.check_str_chars import check_str_chars

class Trigger_MSO_5k(Trigger_5k_7k):
    """Class providing the **Trigger** controls of a Tektronix MSO5000 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        trig_dict = {
                'EDGE':       ('EDGE',  None,              None),
                'GLITCH':     ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'GLITCH'),
                'WIDTH':      ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'WIDTH'),
                'RUNT':       ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'RUNT'),
                'TIMEOUT':    ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'TIMEOUT'),
                'PATTERN':    ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'PATTERN'),
                'STATE':      ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'STATE'),
                'SETUP_HOLD': ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'SETHOLD'),
                'TRANSITION': ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'TRANSITION'),
                'VIDEO':      ('VIDEO', None,               None),
                'BUS':        ('BUS', None, 'BUS')
        }
        self.enum_trigA_types = Enum('enum_trigA_types', trig_dict)
        trig_dict.pop('BUS')
        self.enum_trigB_types = Enum('enum_trigB_types', trig_dict)

        # MSO analog and digital sources
        self._sources_analog_and_digital = {}
        for num in range(1, 5):
            self._sources_analog_and_digital[f'CH{num}'] = f'CH{num}'

        sources_edge = {m.name: m.value for m in self.enum_edge_sources}  # dict from parent class enum, has ACLINE, AUX

        for num in range(16):
            self._sources_analog_and_digital[f'D{num}'] = f'D{num}'
            sources_edge[f'D{num}'] = f'D{num}'

        # Attributes specific to MSO5000 series
        self.enum_edge_sources = Enum('enum_edge_sources', sources_edge)
        self.enum_glitch_sources = Enum('enum_glitch_sources', self._sources_analog_and_digital)
        self.enum_width_sources = Enum('enum_width_sources', self._sources_analog_and_digital)
        self.enum_timeout_sources = Enum('enum_timeout_sources', self._sources_analog_and_digital)
        self.enum_setup_hold_sources = Enum('enum_setup_hold_sources', self._sources_analog_and_digital)

    def pattern_config(self, AorB, pattern_type: str = None, digital_pattern: Union[str, int] = None,
                       analog_pattern: Union[str, int] = None, trig_if: Union[str, bool] = None,
                       timer: Union[int, float] = None, gui_format: str = None, *args,
                       **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for the logic pattern trigger.

        Something important to note with the pattern config is setting a digital pattern, the pattern
        should be MSB->LSB. If pattern config is setting an analog pattern, the parameter goes from
        smallest channel to largest channel e.g. Ch1 -> CH4. More information on individual parameters below.

        This method will not set thresholds for digital bits or analog channels. To set digital thresholds,
        use the digital API. To set analog thresholds use thresholds_analog_channels in this module.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param pattern_type: Query or set logical combination of input channels for pattern to trigger.
            Valid entries: 'AND', 'NAND', 'OR', 'NOR'
        :type pattern_type: str
        :param digital_pattern: Defines the state of the digital inputs that must be present
            for triggering to occur. String is interpreted as **binary** and may be any combination of up to 16 of the
            characters '0', '1' or 'X' (don't care). Alternatively, digital_pattern may be specified as an int from 0 to
            65525. Any of the most significant bits not specified by the str or that would be a 0 in the int are
            replaced by 'X'. (Specifying digital_pattern=1 is equivalent to the binary pattern 'XXXXXXXXXXXXXXX1'.)
            Note that if the oscope is displaying in hex, (see param gui_format), any groups of 4 bits containing 1 to 3
            don't cares are displayed as '$'; if all 4 bits are don't care, the hex display is 'X'.  This display
            behavior does not effect the pattern matching. In a query response digital_pattern is always returned as
            the full 16 character string.
        :type digital_pattern: str|int
        :param analog_pattern: Defines the state of analog channels CH1-CH4 that must be present
            for triggering to occur. String is interpreted as **binary** and must be a combination of 4 of the
            characters '0', '1' or 'X' (don't care). Alternatively, analog_pattern may be specified as an int from 0 to
            15. Any of the most significant bits not specified by the str or that would be a 0 in the int are replaced
            by 'X'. (Specifying analog_pattern=1 is equivalent to the binary pattern 'XXX1'.) Note that if
            the oscope is displaying in hex, (see param gui_format), the character displayed for CH1-CH4 will be '$',
            unless all 4 bits are don't care, the hex display is 'X'. This display behavior does not effect the pattern
            matching. In a query response analog_pattern is always returned as the full 4 character string.
        :type analog_pattern: str|int
        :param trig_if: Set or query condition for generating a pattern trigger with respect to defined
            input pattern. Accepts the following inputs:
            True|'TRUE': Trigger when boolean input is true.
            False|'FALSE': Trigger when boolean input is false.
            'GREATERTHAN': Trigger when boolean input is true for more than x time (x is defined by the time parameter).
            'LESSTHAN': Trigger when boolean input is true for less than x time (x is defined by the time parameter).
        :type trig_if: str|bool
        :param timer: Set or query time requirement for generating a pattern trigger with respect to defined
            input pattern.
        :type timer: int|float
        :param gui_format: Defines whether patterns are displayed on the scope as HEX or BINARY. Accepts:
            'HEX', 'BINARY'. If binary representation includes 'X', switching to 'HEX' results in 4-bit grouping
            being displayed as '$' inplace of a hex digit.
        :type gui_format: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut:ALL <QString>
        # TRIGger:{A|B}:LOGIc:PATtern:WHEn
        # TRIGger:{A|B}:LOGIc:PATtern:WHEn:MORELimit <NR3>
        # TRIGger:{a|B}:LOGIc:PATtern:WHEn:LESSLimit <NR3>
        # TRIGger:{A|B}:LOGIc:INPut:FORMat {HEXadecimal|BINary}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"PATTERN trigger is not available for the 'B' trigger on {self.scope.model}.")

        curr_gui_format = self.query(f'TRIG:{AorB}:LOGI:INP:FORM?', self.enum_logic_gui_format)
        curr_trig_if = self.query(f'TRIG:{AorB}:LOGI:PAT:WHE?', self.enum_pattern_trig_if)

        # Readback
        if all(v is None for v in {pattern_type, digital_pattern, analog_pattern, trig_if,
                                   timer, gui_format}):
            return self._pattern_config_readback(AorB, curr_trig_if, curr_gui_format)

        # Parameter Checking
        pattern_type = check_enum_str('pattern_type', pattern_type, self.enum_logic_pattern_type)
        gui_format = check_enum_str('gui_format', gui_format, self.enum_logic_gui_format)

        # Check digital pattern
        if digital_pattern is not None:
            if isinstance(digital_pattern, int):
                check_range('digital_pattern', digital_pattern, min_max_units(0, 2**16-1, ''), val_type=int)
                digital_pattern = bin(digital_pattern).replace('0b', '')
            else:
                check_str_chars('digital_pattern', digital_pattern, 16, '01X')
            for i in range(16-len(digital_pattern)):
                # Default unspecified more significant bits to don't care
                digital_pattern = 'X' + digital_pattern

        # Check analog pattern
        if analog_pattern is not None:
            if isinstance(analog_pattern, int):
                check_range('analog_pattern', analog_pattern, min_max_units(0, 2**4-1, ''), val_type=int)
                analog_pattern = bin(analog_pattern).replace('0b', '')
            else:
                check_str_chars('analog_pattern', analog_pattern, 4, self._valid_chars_binary)
            for i in range(4-len(analog_pattern)):
                # Default unspecified more significant bits to don't care.
                analog_pattern = 'X' + analog_pattern

        # Construct combined digital and analog pattern to write.
        write_pattern = None
        if (digital_pattern is None and analog_pattern is not None) or \
                digital_pattern is not None and analog_pattern is None:
            curr_pattern = self._get_curr_pattern_bin(AorB, curr_gui_format.name)
            if digital_pattern is None:
                write_pattern = curr_pattern[:16] + analog_pattern
            if analog_pattern is None:
                write_pattern = digital_pattern + curr_pattern[16:]
        elif digital_pattern is not None and analog_pattern is not None:
            write_pattern = digital_pattern + analog_pattern

        # Allow user to specify as str or bool
        if trig_if is True:
            trig_if = 'TRUE'
        elif trig_if is False:
            trig_if = 'FALSE'
        trig_if = check_enum_str('trig_if', trig_if, self.enum_pattern_trig_if)
        if trig_if is not None:
            curr_trig_if = trig_if
        if timer is not None:
            if curr_trig_if.name not in self.list_time_valid_trig_if_settings:
                raise ValueError(f'Incorrect trig_if config for time settings: {curr_trig_if.name}. Change trig_if to'
                                 f'"GREATERTHAN" OR "LESSTHAN" if timer configs are required.')
            check_range('timer', timer, self.bounds_trig_logic_pat_time)

        # Write commands to instrument
        if pattern_type is not None:
            self.write(f'TRIG:{AorB}:LOGI:FUNC', pattern_type.value)
        if write_pattern is not None:
            if curr_gui_format.name == 'HEX':
                self.write(f'TRIG:{AorB}:LOGI:INP:FORM', self.enum_logic_gui_format.BINARY.value)
                time.sleep(0.025)
            self.write(f'TRIG:{AorB}:LOGI:INP:ALL', f'"{write_pattern}"')
        if gui_format is not None:
            if gui_format.name == 'BINARY' and write_pattern is not None:
                pass  # We already configured BINARY to write the pattern
            else:
                self.write(f'TRIG:{AorB}:LOGI:INP:FORM', gui_format.value)
        elif curr_gui_format.name == 'HEX':   # Put gui_format back the way we found it.
            self.write(f'TRIG:{AorB}:LOGI:INP:FORM', self.enum_logic_gui_format.HEX.value)
        if trig_if is not None:
            self.write(f'TRIG:{AorB}:LOGI:PAT:WHE', trig_if.value)
        if timer is not None:
            if curr_trig_if.name == 'GREATERTHAN':
                self.write(f'TRIG:{AorB}:LOGI:PAT:WHE:MOREL', timer)
            elif curr_trig_if.name == 'LESSTHAN':
                self.write(f'TRIG:{AorB}:LOGI:PAT:WHE:LESSL', timer)

        self.log_inst_errors()

    def _pattern_config_readback(self, AorB, curr_trig_if, curr_gui_format):
        return_val = {}
        return_val.update(pattern_type=self.query(f'TRIG:{AorB}:LOGI:FUNC?', self.enum_logic_pattern_type).name)
        return_val.update(gui_format=curr_gui_format.name)
        curr_pattern = self._get_curr_pattern_bin(AorB, curr_gui_format.name)
        return_val.update(digital_pattern=curr_pattern[:16])
        return_val.update(analog_pattern=curr_pattern[16:])
        return_val.update(trig_if=curr_trig_if.name)
        if curr_trig_if.name == 'GREATERTHAN':
            return_val.update(timer=self.query(f'TRIG:{AorB}:LOGI:PAT:WHE:MOREL?', float))
        elif curr_trig_if.name == 'LESSTHAN':
            return_val.update(timer=self.query(f'TRIG:{AorB}:LOGI:PAT:WHE:LESSL?', float))
        return return_val

    def state_config(self, AorB, pattern_type: str = None, digital_pattern: str = None,
                     analog_pattern: str = None, trig_if: Union[str, bool] = None, gui_format: str = None,
                     clock_source: str = None, clock_level: Union[int, float] = None, when_clock: str = None, *args,
                     **kwargs) -> Dict[str, Union[int, float]]:
        """
        Query all or set any combination of parameters for logic state trigger. When clock transition occurs, scope
        will compare oscope inputs to set logic pattern and determine whether or not it meets the criteria for
        a trigger to occur.

        Note when setting a digital pattern, the pattern should be MSB->LSB. When setting an analog pattern,
        the parameter goes from smallest channel to largest channel e.g. CH1 -> CH3. More information below.

        This method will not set thresholds for digital bits or analog channels. To set digital thresholds,
        use the digital API. To set analog thresholds use thresholds_analog_channels in this module.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger. On 5000 series state trigger is only available on the 'A" trigger. On 7000 series it is
            available on both 'A' and 'B' triggers.
        :type AorB: str
        :param pattern_type: Query or set logical combination of input channels for pattern to trigger.
            Valid entries: 'AND', 'NAND', 'OR', 'NOR'.
        :type pattern_type: str|enum_logic_pattern_type
        :param digital_pattern: Defines the state of the digital inputs that must be present at the clock edge
            for triggering to occur. String is interpreted as **binary** and may be any combination of up to 16 of the
            characters '0', '1' or 'X' (don't care). Alternatively, digital_pattern may be specified as an int from 0 to
            65525. Any of the most significant bits not specified by the str or that would be a 0 in the int are
            replaced by 'X'. (Specifying digital_pattern=1 is equivalent to the binary pattern 'XXXXXXXXXXXXXXX1'.)
            Note that if the oscope is displaying in hex, (see param gui_format), any groups of 4 bits containing 1 to 3
            don't cares are displayed as '$'; if all 4 bits are don't care, the hex display is 'X'.  This display
            behavior does not effect the pattern matching. In a query response digital_pattern is always returned as
            the full 16 character string.
        :type digital_pattern: str|int
        :param analog_pattern: Defines the state of analog channels CH1-CH3 that must be present at the clock
            edge for triggering to occur.  String is interpreted as **binary** and must be a combination of 3 of the
            characters '0', '1' or 'X' (don't care). Alternatively, analog_pattern may be specified as an int from 0 to
            7. Any of the most significant bits not specified by the str or that would be a 0 in the int are replaced by
            'X'. (Specifying digital_pattern=1 is equivalent to the binary pattern 'XX1'.) Note that if
            the oscope is displaying in hex, (see param gui_format), the character displayed for CH1-CH4 will be '$',
            unless all 4 bits are don't care, the hex display is 'X'. (CH4 is forced to be 'X' as it is the
            clock input.) This display behavior does not effect the pattern matching. In a query response
            analog_pattern is always returned as the full 3 character string.
        :type analog_pattern: str|int
        :param trig_if: Condition for generating a pattern trigger with respect to defined input pattern. Accepts:

            True|'TRUE': Trigger when boolean input is true.
            False|'FALSE': Trigger when boolean input is false.
            Note that 'TRUE' is the only acceptable value to MSO/DPO 5000 series
        :type trig_if: str|bool
        :param gui_format: Defines whether patterns are displayed on the oscope as HEX or BINARY. Accepts 'HEX',
            'BINARY'. If the
            binary representation of the pattern contains an 'X', switching to 'HEX' results in the 4-bit grouping
            being displayed as '$' inplace of a hex digit.
        :type gui_format: str
        :param clock_source: Defines which channel is clock source. For MSO/DPO 5000 series, this can only be
            CH4. For DPO 7000 series, it can be either CH4 or clock qualifier CQ.
        :type clock_source: str
        :param clock_level: Set or query logic threshold for clock.
        :type clock_level: int|float
        :param when_clock: Set or query what edge of the clock a trigger can occur on. Accepts 'POS' or 'NEG'
        :type when_clock: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut:ALL <QString>
        # TRIGger:{A|B}:LOGIc:STATE:WHEn {TRUe|FALSe}
        # TRIGger:{A|B}:LOGIc:INPut:FORMat {HEXadecimal|BINary}
        # TRIGger:{A|B}:LOGIc:STATE:CLOck:SOUrce {CH4|CQ}
        # TRIGger:{A|B}:LOGIc:THReshold:CH<x> <NR3>
        # TRIGger:{A|B}:LOGIc:STATE:INPut:CH<x> {FALL|RISe}
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"STATE trigger is not available for the 'B' trigger on {self.scope.model}.")

        curr_gui_format = self.query(f'TRIG:{AorB}:LOGI:INP:FORM?', self.enum_logic_gui_format)

        # Readback
        if all(v is None for v in {pattern_type, digital_pattern, analog_pattern, trig_if, gui_format,
                                   clock_source, clock_level, when_clock}):
            return_val = {}
            return_val.update(pattern_type=self.query(f'TRIG:{AorB}:LOGI:FUNC?', self.enum_logic_pattern_type).name)

            return_val.update(gui_format=curr_gui_format.name)

            curr_pattern = self._get_curr_pattern_bin(AorB, curr_gui_format.name)

            return_val.update(digital_pattern=curr_pattern[:16])
            return_val.update(analog_pattern=curr_pattern[16:19])   # Skip the rightmost bit, CH4 is always the clock.

            return_val.update(trig_if=self.query(f'TRIG:{AorB}:LOGI:STATE:WHE?', self.enum_state_trig_if).name)

            curr_clock_source = self.query(f'TRIG:{AorB}:LOGI:STATE:CLO:SOU?', self.enum_state_clock_source)
            return_val.update(clock_source=curr_clock_source.name)
            return_val.update(clock_level=self.query(f'TRIG:{AorB}:LOGI:THR:{curr_clock_source.value}?', float))
            return_val.update(when_clock=self.query(f'TRIG:{AorB}:LOGI:STATE:INP:{curr_clock_source.value}?',
                                                    self.enum_state_when_clock).name)
            return return_val

        # Parameter Checking

        pattern_type = check_enum_str('pattern_type', pattern_type, self.enum_logic_pattern_type)
        gui_format = check_enum_str('gui_format', gui_format, self.enum_logic_gui_format)

        # Check digital pattern
        if digital_pattern is not None:
            if isinstance(digital_pattern, int):
                check_range('digital_pattern', digital_pattern, min_max_units(0, 2**16-1, ''), val_type=int)
                digital_pattern = bin(digital_pattern).replace('0b', '')
            else:
                check_str_chars('digital_pattern', digital_pattern, 16, '01X')
            for i in range(16-len(digital_pattern)):
                # Default unspecified more significant bits to don't care.
                digital_pattern = 'X' + digital_pattern

        # Check analog pattern
        if analog_pattern is not None:
            if isinstance(analog_pattern, int):
                check_range('analog_pattern', analog_pattern, min_max_units(0, 2**3-1, ''), val_type=int)
                analog_pattern = bin(analog_pattern).replace('0b', '')
            else:
                check_str_chars('analog_pattern', analog_pattern, 3, self._valid_chars_binary)
            for i in range(3-len(analog_pattern)):
                # Default unspecified more significant bits to don't care.
                analog_pattern = 'X' + analog_pattern
            analog_pattern = analog_pattern + 'X'  # Append CH4, always X because it's the clock.

        # Construct combined digital and analog pattern to write using the SCPI cmd.
        write_pattern = None
        if (digital_pattern is None and analog_pattern is not None) or \
                (digital_pattern is not None and analog_pattern is None):
            curr_pattern = self._get_curr_pattern_bin(AorB, curr_gui_format.name)
            if digital_pattern is None:
                write_pattern = curr_pattern[:16] + analog_pattern
            if analog_pattern is None:
                write_pattern = digital_pattern + curr_pattern[16:]
            if curr_gui_format.name == 'HEX':  # Put gui_format back the way we found it.
                self.write(f'TRIG:{AorB}:LOGI:INP:FORM', self.enum_logic_gui_format.HEX.value)
        elif digital_pattern is not None and analog_pattern is not None:
            write_pattern = digital_pattern + analog_pattern

        # Allow user to specify as str or bool.
        if trig_if is True:
            trig_if = 'TRUE'
        elif trig_if is False:
            trig_if = 'FALSE'
        trig_if = check_enum_str('trig_if', trig_if, self.enum_state_trig_if)
        if self.trig_logic_state_trig_if == 'ONLY_TRUE' and trig_if is not None:
            if trig_if.value != 'TRUE':
                raise ValueError(f'Scope {self.scope.model} can only have trig_if parameter set as True. '
                                 f'Currently attempting to set to {trig_if.value}')

        clock_source = check_enum_str('clock_source', clock_source, self.enum_state_clock_source)
        if self.trig_logic_state_clock_source == 'ONLY_CH4' and clock_source is not None:
            if clock_source.value != 'CH4':
                raise ValueError(f'Scope {self.scope.model} can only have CH4 as it clock source.'
                                 f' Currently attempting to set to {clock_source.name}')
        curr_clock_source = clock_source
        if curr_clock_source is None:
            curr_clock_source = self.query(f'TRIG:{AorB}:LOGI:STATE:CLO:SOU?', self.enum_state_clock_source)

        if clock_level is not None:
            level_min, level_max = self._calc_trig_level_range(curr_clock_source)  # _calc_trig_level_range needs enum
            check_range('clock_level', clock_level, min_max_units(level_min, level_max, 'volts'))

        when_clock = check_enum_str('when_clock', when_clock, self.enum_state_when_clock)

        # Input value checks complete...now a few things unique to this state/pattern trigger.

        # Write commands to instrument

        if pattern_type is not None:
            self.write(f'TRIG:{AorB}:LOGI:FUNC', pattern_type.value)

        if write_pattern is not None:
            if curr_gui_format.name == 'HEX':  # Need to switch to binary to write pattern.
                self.write(f'TRIG:{AorB}:LOGI:INP:FORM', self.enum_logic_gui_format.BINARY.value)
                time.sleep(0.025)
            self.write(f'TRIG:{AorB}:LOGI:INP:ALL', f'"{write_pattern}"')

        if gui_format is not None:
            if gui_format.name == 'BINARY' and write_pattern is not None:
                pass   # We already configured BINARY to write the pattern.
            else:
                self.write(f'TRIG:{AorB}:LOGI:INP:FORM', gui_format.value)
        elif curr_gui_format.name == 'HEX':   # Put gui_format back the way we found it.
            self.write(f'TRIG:{AorB}:LOGI:INP:FORM', self.enum_logic_gui_format.HEX.value)

        if trig_if is not None:
            self.write(f'TRIG:{AorB}:LOGI:PAT:WHE', trig_if.value)
        if clock_source is not None:
            self.write(f'TRIG:{AorB}:LOGI:STATE:CLO:SOU', clock_source.value)

        if clock_level is not None:
            self.write(f'TRIG:{AorB}:LOGI:THR:{curr_clock_source.value}', clock_level)

        if when_clock is not None:
            self.write(f'TRIG:{AorB}:LOGI:STATE:INP:{curr_clock_source.value}', when_clock.value)

        self.log_inst_errors()

    def _get_curr_pattern_bin(self, AorB, curr_format_name):
        if curr_format_name == 'HEX':
            self.write(f'TRIG:{AorB}:LOGI:INP:FORM', self.enum_logic_gui_format.BINARY.value)
            time.sleep(0.025)
        curr_pattern_bin = self.query(f'TRIG:{AorB}:LOGI:INP:ALL?').strip('"')
        if curr_format_name == 'HEX':
            self.write(f'TRIG:{AorB}:LOGI:INP:FORM', self.enum_logic_gui_format.HEX.value)
            time.sleep(0.025)
        return curr_pattern_bin

    def bus_config(self):
        raise RuntimeError('BUS trigger not implemented in CL Instrument Library. Contact PLATDEV team if this is '
                           'needed.')
