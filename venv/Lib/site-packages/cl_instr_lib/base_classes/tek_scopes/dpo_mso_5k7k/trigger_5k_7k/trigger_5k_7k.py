from enum import Enum
import re
from abc import abstractmethod

from cl_instr_lib.base_classes.tek_scopes.trigger import Trigger
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max
from typing import Dict, Union

class Trigger_5k_7k(Trigger):
    """Class providing the **Trigger** controls of a Tektronix 5000/7000 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        model = self.scope.model

        # # Trigger setup is determined by 2 SCPI cmds together, yet on front panel its a selection from
        # # a single menu. Make the enum elements correspond to the items in that menu.
        trig_dict = {
                'EDGE':       ('EDGE',  None,              None),
                'GLITCH':     ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'GLITCH'),
                'WIDTH':      ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'WIDTH'),
                'RUNT':       ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'RUNT'),
                'TIMEOUT':    ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'TIMEOUT'),
                'PATTERN':    ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'PATTERN'),
                'STATE':      ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'STATE'),
                'SETUP_HOLD': ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'SETHOLD'),
                'TRANSITION': ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'TRANSITION'),
                'VIDEO':      ('VIDEO', None,               None),
        }

        self.enum_trigA_types = Enum('enum_trigA_types', trig_dict)
        self.enum_trigB_types = Enum('enum_trigB_types', {'EDGE': ['EDGE', None, None]})

        # Attributes shared across multiple trigger configs
        self._sources_analog = {}
        for num in range(1, 5):
            self._sources_analog[f'CH{num}'] = f'CH{num}'

        # Edge attributes
        self.enum_edge_sources = Enum('enum_edge_source', {
            'CH1': 'CH1',
            'CH2': 'CH2',
            'CH3': 'CH3',
            'CH4': 'CH4',
            'AUX': 'AUXILIARY',  # TODO: Fix this by turning VERBOSE mode OFF, then you will have to fix other things...
            'ACLINE': 'LINE'
        })

        self.enum_holdoff_by = Enum('enum_holdoff_by', {
            'AUTO': 'AUTO',
            'TIME': 'TIME',
            'RANDOM': 'RANDOM'
        })
        self.enum_settings = Enum('enum_settings', {
          'SHARED': 'SRCDEPENDENT',
          'INDEPENDENT':  'SRCINDEPENDENT'
        })
        self.enum_edge_slopes = Enum('enum_edge_slopes', {
            'FALL': 'FALL',
            'RISE': 'RISE',
            'EITHER': 'EITHER'
        })
        self.enum_edge_coupling = Enum('enum_edge_coupling', {
            'AC': 'AC',
            'DC': 'DC',
            'HFREJ': 'HFREJ',
            'LFREJ': 'LFREJ',
            'NOISEREJ': 'NOISEREJ'
        })

        # Pulse attributes
        self.pulse_triggers = Enum('pulse_triggers', {
            'GLITCH': 'GLI',
            'WIDTH': 'WID',
            'RUNT': 'RUNT',
            'TIMEOUT': 'TIMEO',
            'SETUP_HOLD': 'SETH',
            'TRANSITION': 'TRAN'
        })
        self.bounds_trig_pulse_width_time = min_max_units(4e-9, 8.0, 'seconds')

        # Glitch attributes
        self.enum_glitch_sources = Enum('enum_glitch_sources', self._sources_analog)
        self.bounds_glitch_width_time = self.bounds_trig_pulse_width_time
        self.enum_glitch_when_width = Enum('enum_glitch_when_width', {
            'LESS_THAN': 'ACCEPT',
            'GREATER_THAN': 'REJECT',
        })
        self.enum_glitch_polarity = Enum('enum_glitch_polarity', {
            'POSITIVE': 'POSITIVE',
            'NEGATIVE': 'NEGATIVE'
        })

        # Width attributes
        self.enum_width_sources = Enum('enum_width_sources', self._sources_analog)
        self.bounds_width_upper_lower_limit_time = self.bounds_trig_pulse_width_time
        self.enum_width_when_width = Enum('enum_width_when_width', {
            'INSIDE': 'WITHIN',
            'OUTSIDE': 'OUTSIDE'
        })
        self.enum_width_polarity = Enum('enum_width_polarity', {
            'POSITIVE': 'POSITIVE',
            'NEGATIVE': 'NEGATIVE'
        })
        self.enum_trig_modes = Enum('enum_trig_modes', {
            'AUTO': 'AUTO',
            'NORMAL': 'NORMAL'
        })

        # Runt attributes
        self.enum_runt_sources = Enum('enum_runt_sources', self._sources_analog)
        self.bounds_runt_width_time = self.bounds_trig_pulse_width_time
        self.enum_runt_trig_when = Enum('enum_runt_trig_when', {
            'WIDER': 'WIDERTHAN',
            'OCCURS': 'OCCURS'
        })
        self.enum_runt_polarity = Enum('enum_runt_polarity', {
            'POSITIVE': 'POSITIVE',
            'NEGATIVE': 'NEGATIVE',
            'EITHER': 'EITHER'
        })

        # Timeout attributes
        self.enum_timeout_sources = Enum('enum_timeout_sources', self._sources_analog)
        self.bounds_timeout_timer = self.bounds_trig_pulse_width_time
        self.enum_timeout_trig_when = Enum('enum_timeout_trig_when', {
            'STAYSHIGH': 'STAYSHIGH',
            'STAYSLOW': 'STAYSLOW',
            'EITHER': 'EITHER'
        })

        # Setup/Hold attributes
        self.enum_setup_hold_sources = Enum('enum_setup_hold_sources', self._sources_analog)

        # Transition attributes
        self.enum_transition_sources = Enum('enum_transition_sources', self._sources_analog)
        self.bounds_transition_time = self.bounds_trig_pulse_width_time
        self.enum_transition_transition = Enum('enum_transition_transition', {
            'FASTER': 'FASTERTHAN',
            'SLOWER': 'SLOWERTHAN'
        })
        self.enum_transition_slope = Enum('enum_transition_slope', {
            'POS': 'POSITIVE',
            'NEG': 'NEGATIVE',
            'EITHER': 'EITHER'
        })

        # Logic attributes (attributes that belong to both pattern and state trigger)
        self.enum_logic_pattern_type = Enum('enum_logic_pattern_type', {
            'AND': 'AND',
            'NAND': 'NAND',
            'OR': 'OR',
            'NOR': 'NOR'
        })
        self._enum_logic_valid_chars_bin = Enum('enum_logic_valid_chars_bin', {
            '1': '1',
            '0': '0',
            'X': 'X'
        })

        self._valid_chars_binary = ('0', '1', 'X')

        self.enum_logic_num_format = Enum('enum_logic_num_format', {
            'HEX': 'HEX',
            'BINARY': 'BINARY'
        })

        self.enum_logic_gui_format = Enum('enum_logic_gui_format', {
            'HEX': 'HEX',
            'BINARY': 'BINARY'
        })

        # Pattern attributes
        self.enum_pattern_trig_if = Enum('enum_pattern_trig_if', {
            'TRUE': 'TRUE',
            'FALSE': 'FALSE',
            'LESSTHAN': 'LESSTHAN',
            'GREATERTHAN': 'MORETHAN'
        })
        self.list_time_valid_trig_if_settings = ['GREATERTHAN', 'LESSTHAN']

        # State attributes
        self.enum_state_trig_if = Enum('enum_state_trig_if', {
            'TRUE': 'TRUE',
            'FALSE': 'FALSE'
        })
        self.enum_state_clock_source = Enum('enum_state_clock_source', {
            'CH4': 'CH4',
            'CQ': 'CQ'
        })
        self.enum_state_when_clock = Enum('enum_state_when_clock', {
            'POS': 'RISE',
            'NEG': 'FALL'
        })
        self.enum_state_channel_input = Enum('enum_state_channel_input', {
            '1': 'HIGH',
            '0': 'LOW',
            'X': 'X'
        })

        # Setup/Hold attributes
        self.enum_setup_hold_clock_edge = Enum('enum_setup_hold_clock_edge', {
            'RISE': 'RISE',
            'FALL': 'FALL'
        })

        self.enum_AB_seq_types = Enum('enum_AB_seq_types', ['A_only', 'AB_time', 'AB_events'])

        self.enum_analog_channels = Enum('enum_analog_channels', {
            'CH1': 'CH1',
            'CH2': 'CH2',
            'CH3': 'CH3',
            'CH4': 'CH4'
        })
        self.trig_level_divs = 8
        self.trig_level_aux_volts = {'1X': 8.0, '10X': 80.0}
        self.trig_logic_setup_hold_setup_timing = min_max_units(-500e-12, 1.02e-3, 'seconds')
        self.trig_logic_setup_hold_hold_timing = min_max_units(1e-9, 1.02e-3, 'seconds')
        self.bounds_trig_logic_pat_time = min_max_units(3e-10, 1.0, 'seconds')
        self.trig_logic_state_trig_if = 'ONLY_TRUE'
        self.trig_logic_state_clock_source = 'ONLY_CH4'

        if re.match('^(MSO|DPO)5(03|05|10|20)4B?$', model):
            self.bounds_holdoff_sec = namedtuple_min_max(250e-9, 8.0)
            self.bounds_Btrig_events = namedtuple_min_max(1, int(4e6))
            self.bounds_Btrig_time = namedtuple_min_max(4e-9, 8.0)
        # else:
        #     self.bounds_holdoff_sec = namedtuple_min_max(250e-9, 100.0)
        #     self.trig_level_aux_volts = {'1X': 5.0, '10X': 50.0}
        #     self.bounds_Btrig_events = namedtuple_min_max(1, int(4e9))
        #     self.bounds_Btrig_time = namedtuple_min_max(3.2e-9, 3e6)
        #     self.log.warning(f"Unknown scope model '{model}'. Using default bounds for trigger holdoff, levels, delay"
        #                      f" by time and events which may generate warnings.  Scope may limit to other values "
        #                      f"within its range.")

    def A_event(self, trig_type=None):
        """Query or set the event type for the A trigger.

        :param trig_type: Possible values for 5000 and 7000 series are: 'EDGE', 'GLITCH', 'WIDTH', 'RUNT', 'TIMEOUT',
            'PATTERN', 'STATE', 'SETUP_HOLD', 'TRANSITION', 'VIDEO'. The 7000 series adds 'WINDOW'. In the present
            version of this driver, a setup method is only provided for 'EDGE'.
        :type trig_type: enum_trigA_types|str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict|None
        """

        return self._trig_type('A', self.enum_trigA_types, trig_type)

    def B_event(self, trig_type=None):
        """Query or set the event type for the B (sequence) trigger.

        :param trig_type: The 5000 series only supports 'EDGE'. The 7000 series supports: 'EDGE', 'GLITCH', 'WIDTH',
            'RUNT', 'TIMEOUT', 'PATTERN', 'STATE', 'SETUP_HOLD', 'TRANSITION', 'WINDOW'. In the present version of this
            driver, a setup method is only provided for 'EDGE'.
        :type trig_type: enum_trigB_types|str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict|None
        """

        return self._trig_type('B', self.enum_trigB_types, trig_type)

    def level_50pcnt(self, AorB='A'):
        """
        Sets A or B trigger level to 50% of the peak-to-peak amplitude of the waveform. The default ('A')
        gives the equivalent of pushing the trigger level knob.

        :param AorB: Defaults to 'A'.
        :type AorB: str
        :return:
        :rtype:
        """

        # TRIGGER:{A|B} command

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger name '{AorB}', should be 'A' or 'B'.")

        self.write(f'TRIG:{AorB}', 'SETL')

        self.log_inst_errors()

    def sequence_settings(self, seq_type=None, event_count=None, time_sec=None, *args, **kwargs):
        """
        Query or set parameters that determine when the B trigger fires after the A trigger occurs.

        :param seq_type:

            * 'AB_time' trigger on 1 B event following A event after a delay.
            * 'AB_event' trigger after event_count B events following the A event.
            * 'A_only' disables sequence triggering.
        :type seq_type: str|enum_AB_seq_types
        :param event_count: After A event occurs, trigger after this number of B events. See bounds_Btrig_events.max.
        :type event_count: int
        :param time_sec: After A event and 1st B event, wait this many seconds before triggering.
        :type time_sec: float
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        # A_only
        # AB_time
        # AB_events

        # TRIGger:B:STATE {ON|OFF|<NR1>}
        # TRIGger:B:BY {EVENTS|TIMe|ARMAtrigb}
        # TRIGger:B:TIMe <NR3>
        # TRIGger:B:EVENTS:COUNt <NR1>   1 to 10e6

        self.log_unused_args(args, kwargs)

        if all([v is None for v in (seq_type, time_sec, event_count)]):
            return_values = {}
            sequence = self.query('TRIG:B:STATE', bool)
            if not sequence:
                return_values.update(seq_type='A_only')
            else:
                tmp = self.query('TRIG:B:BY', str)
                if tmp == 'EVENTS':
                    return_values.update(seq_type='AB_events')
                elif tmp == 'TIME':
                    return_values.update(seq_type='AB_time')
                else:
                    self.log.warning(f"'TRIG:B:STATE query returned response '{tmp}' which does not correspond to "
                                     f"seq_types 'A_only', 'AB_events', or 'AB_time'.")
            return_values.update(events_count=self.query('TRIG:B:EVENTS:COUN', int))
            return_values.update(time_sec=self.query('TRIG:B:TIME', float))
            return return_values

        seq_type = check_enum_str('seq_type', seq_type, self.enum_AB_seq_types)

        if event_count is not None:
            # if not isinstance(event_count, (int, float)) or \
            #                         not(self.bounds_Btrig_events.min <= event_count <= self.bounds_Btrig_events.max):
            #     raise ValueError(f"Bad event_count {event_count}, should be {self.bounds_Btrig_events.min} to "
            #                      f"{self.bounds_Btrig_events.max}.")

            events_min, events_max = self.bounds_Btrig_events.min, self.bounds_Btrig_events.max
            if not isinstance(event_count, (int, float)):
                raise ValueError(f"Bad event_count {event_count}, should be {events_min} to {events_max}.")
            elif not (events_min <= event_count <= events_max):
                events_actual = min(max(event_count, events_min), events_max)
                self.log.warning(f"Requested event_count {event_count} out of range {events_min} to {events_max} "
                                 f"events. Scope coerces to {events_actual} events.")

        if time_sec is not None:
            time_min, time_max = self.bounds_Btrig_time.min, self.bounds_Btrig_time.max
            if not isinstance(time_sec, (int, float)):
                raise ValueError(f"Bad time_sec {time_sec}, should be {time_min} to {time_max}.")
            elif not (time_min <= time_sec <= time_max):
                time_actual = min(max(time_sec, time_min), time_max)
                self.log.warning(f"Requested time_sec {time_sec} out of range {time_min} to {time_max} sec. Scope "
                                 f"coerces to {time_actual} sec.")

        if seq_type is not None:
            if seq_type.name == 'A_only':
                self.write('TRIG:B:STATE', 'OFF')
            elif seq_type.name == 'AB_time':
                self.write('TRIG:B:STATE', 'ON')
                self.write('TRIG:B:BY', 'TIME')
            elif seq_type.name == 'AB_events':
                self.write('TRIG:B:STATE', 'ON')
                self.write('TRIG:B:BY', 'EVENTS')
        if event_count is not None:
            self.write('TRIG:B:EVENTS:COUN', int(event_count))
        if time_sec is not None:
            self.write('TRIG:B:TIME', time_sec)

        self.log_inst_errors()

    def options(self, trig_mode=None, holdoff_sec=None, holdoff_by=None, *args, **kwargs):
        """
        Triggering parameters common to all the triggering types. Select triggering mode.

        :param trig_mode: Element of enum_trig_modes or str: 'NORMAL', 'AUTO'.
        :param holdoff_by: Element of enum_holdoff_by or str: 'AUTO', 'TIME', 'RANDOM'.
        :param holdoff_sec: 250e-9 to 8.0 seconds. After a trigger event subsequent events are ignored during holdoff.
            Note that scope holdoff_type must be 'TIME' for this to take effect.
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # TRIGger:A:MODe {AUTO|NORMal}
        # TRIGger:A:HOLDoff:BY {TIMe|DEFAult|RANDom|AUTO}
        # TRIGger:A:HOLDoff:TIMe <NR3>

        # Not implemented
        # TRIGger:ENHanced {<NR1>|OFF|ON}
        # TRIGger:SENSITivity {<NR1>|OFF|ON}

        self.log_unused_args(args, kwargs)

        if all(v is None for v in (trig_mode, holdoff_by, holdoff_sec)):
            return_values = super().options()
            return_values.update(holdoff_by=self.query('TRIGger:A:HOLDoff:BY', self.enum_holdoff_by).name)
            return return_values

        # Delegate some of the checking to the super class.
        if any(v is not None for v in (trig_mode, holdoff_sec)):
            trig_mode, holdoff_sec = super().options(trig_mode=trig_mode, holdoff_sec=holdoff_sec, *args,
                                                     skip_write=True)

        # Check the new stuff
        holdoff_by = check_enum_str('holdoff_by', holdoff_by, self.enum_holdoff_by)
        if holdoff_by is None:
            holdoff_type_state = self.query('TRIGger:A:HOLDoff:BY', self.enum_holdoff_by)
        else:
            holdoff_type_state = holdoff_by

        if holdoff_sec is not None and holdoff_type_state != self.enum_holdoff_by.TIME:
            raise ValueError(f"Setting holdoff_sec has no effect for holdoff_by '{holdoff_type_state.name}'")

        # If we got here, all's good to write.

        if trig_mode is not None:
            self.write("TRIG:A:MOD", trig_mode.value)

        if holdoff_by is not None:
            self.write("TRIGger:A:HOLDoff:BY", holdoff_by.value)

        if holdoff_sec is not None:
            self.write("TRIG:A:HOLD:TIM",  holdoff_sec)

        self.log_inst_errors()

    def edge_config(self, AorB: str, source: str = None, level: Union[int, float] = None, slope: str = None,
                    coupling: str = None, settings: str = None, *args, **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for edge trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: 'CH1', 'CH2', 'CH3', 'CH4', 'AUX', 'ACLINE'.
        :type source: enum_edge_sources | str
        :param level: Voltage level in Volts for the specified source or all sources depending on param **settings**.
        :type level: int | float
        :param slope: Choices depend on source. For CH1-4: 'RISE', 'FALL', 'EITHER' can be selected. For AUX: 'RISE',
            'FALL'. For ACLINE, slope defaults to rising edge. Value applied or returned pertains to either the
            specified source or all sources depending on param **settings**.
        :type slope: enum_edge_slope | str
        :param coupling: Choices depend on source. For CH1-4:  'AC', 'DC', 'HFR', 'LFR' can be selected. For ACLINE and
            AUX: 'DC' only. Value applied or returned pertains to either specified or all sources (depending on param
            **settings**).
        :type coupling: enum_edge_coupling | str
        :param settings: 'SHARED' applies the level, slope and coupling settings of the selected source (CH1-4)to all
            other source channels. 'INDEPENDENT' allows level, slope and coupling to be customized per source.
        :type settings: enum_settings | str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # TRIGger:{A|B}:EDGE:SOUrce {AUX|CH1|CH2|CH3|CH4|D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|D10|D11|D12|D13|D14|D15|LINE|RF}
        # TRIGger:{A|B}:LEVel
        # TRIGger:{A|B}:EDGE:COUPling {AC|DC|HFRej|LFRej|NOISErej}
        # TRIGger:{A|B}:TYPe {EDGe|LOGIc|PULSe|BUS|VIDeo}
        # TRIGger:{A|B}:EDGE:SLOpe {RISe|FALL|EITHer}
        # TRIGger:A:LEVel:CH<x> {<NR3>|ECL|TTL}  # Not needed since we set source first!
        # TRIGger:A:LEVel:AUXin {<NR3>|ECL|TTL}  # Not needed since we set source first!
        # TRIGger:A:LEVel:D<x> {<NR3>|ECL|TTL}
        # TRIGger:LVLSrcpreference

        # self.write("TRIG:A:TYP", self.enum_trigA_types.EDGE.value[0])

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if all(v is None for v in (source, level, slope, coupling, settings)):
            return_values = {}
            return_values.update(source=self.query(f"TRIG:{AorB}:EDGE:SOU?", self.enum_edge_sources).name)
            return_values.update(level=self.query(f"TRIG:{AorB}:LEV", float))  # of current source
            return_values.update(slope=self.query(f"TRIG:{AorB}:EDGE:SLO", self.enum_edge_slopes).name)  # ditto
            return_values.update(coupling=self.query(f"TRIG:{AorB}:EDGE:COUP", self.enum_edge_coupling).name)  # ditto
            return_values.update(settings=self.query("TRIG:LVLS", self.enum_settings).name)
            return return_values

        source = check_enum_str('source', source, self.enum_edge_sources)
        if source is None:
            source_state = self.query(f"TRIG:{AorB}:EDGE:SOU", self.enum_edge_sources)
        else:
            source_state = source
            if AorB == 'B' and source.name == 'ACLINE':
                raise ValueError(f"Bad source '{source}, is not available for the B trigger.")

        coupling = check_enum_str('coupling', coupling, self.enum_edge_coupling)
        if coupling is None:
            coupling_state = self.query(f"TRIG:{AorB}:EDGE:COUP?", self.enum_edge_coupling)
        else:
            coupling_state = coupling    # Avoid trying to write it.

        if coupling_state.name != 'DC' and source_state.name in ('AUX', 'ACLINE'):
            # Scope coerces coupling to DC for AUX and ACLINE.
            self.log.warning(f"Edge trigger coupling cannot be set to '{coupling_state.name}' for source "
                             f"'{source_state.name}'. Scope coerces coupling to DC.")
            coupling = None

        if level is not None:
            # See trigger Level ranges in scope data sheet.
            if source_state.name == 'ACLINE':
                self.log.warning(f"Cannot set trigger level for source '{source_state.name}'. Scope coerces to 0V.")
                level = None   # Avoid trying to write it.

            level_min, level_max = self._calc_trig_level_range(source_state, coupling_state)

            if not isinstance(level, (int, float)):
                raise ValueError(f"Bad level {level} V, should be {level_min} to {level_max} for source "
                                 f"{source_state.name}.")
            elif not (level_min <= level <= level_max):
                level_actual = min(max(level, level_min), level_max)
                self.log.warning(f"Requested level {level} V out of range {level_min} to {level_max} for source "
                                 f"{source_state.name}. Scope coerces to {level_actual}.")

        slope = check_enum_str('slope', slope, self.enum_edge_slopes)
        if slope is not None:
            if source_state.name == 'ACLINE':
                self.log.warning(f"Edge trigger slope cannot be set to {slope.name} for source 'ACLINE'. Scope coerces "
                                 f"to 'RISE'.")
                slope = None  # Avoid trying to write it.
            elif source_state.name == 'AUX':
                if slope.name == 'EITHER':
                    self.log.warning(f"Edge trigger slope cannot be set to {slope.name} for source 'AUX'. "
                                     f"Scope coerces to 'RISE'.")
                    slope = None  # Avoid trying to write it.

        settings = check_enum_str('settings', settings, self.enum_settings)

        # If we got here all new values are good, write them to instrument:

        if settings is not None:
            self.write("TRIG:LVLS", settings.value)

        if source is not None:
            self.write(f"TRIG:{AorB}:EDGE:SOU", source.value)
        if slope is not None:
            if source_state == self.enum_edge_sources.AUX:
                self.write(f"TRIG:{AorB}:EDGE:SLO:AUX", slope.value)
            else:
                self.write(f"TRIG:{AorB}:EDGE:SLO", slope.value)
        if coupling is not None:
            self.write(f"TRIG:{AorB}:EDGE:COUP", coupling.value)
        if level is not None:
            self.write(f"TRIG:{AorB}:LEV", level)  # Sets current source value.

        self.log_inst_errors()

    def glitch_config(self, AorB: str, source: str = None, level: Union[int, float] = None,
                      width: Union[int, float] = None, when_width: str = None,
                      polarity: str = None, *args, **kwargs) -> Dict[str, float]:
        """
        Query all or set any combination of parameters for glitch trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: CH[1-4], D[0-15] e.g. 'CH0', 'D3'
        :type source: str
        :param level: Set voltage glitch needs to reach in order to trigger
        :type level: int|float
        :param width: Set the timeframe that needs to be within/exceed to trigger.
        :type width: int|float
        :param when_width: Set so scope triggers when glitch width is specified within width boundaries or
            outside of width boundaries. Accepts:

            * 'GREATER_THAN'
            * 'LESS_THAN'
        :type when_width:
        :param polarity: Set the polarity of the trigger. Accepts:

            * 'POS'
            * 'NEG'
        :type polarity: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:GLItch?
        # TRIGger:{A|B}:PULse:GLItch:POLarity {POSITIVe|NEGAtive|EITher}
        # TRIGger:{A|B}:PULse:GLItch:TRIGIF {ACCept|REJect}
        # TRIGger:{A|B}:PULse:GLItch:WIDth <NR3>
        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:LEVel

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"GLITCH trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if all(v is None for v in {source, level, width, when_width, polarity}):
            return self._glitch_config_readback(AorB)

        # Parameter Checking
        source, when_width, polarity = self._glitch_config_check(AorB, source, level, width, when_width, polarity)

        # Write to instrument
        self._glitch_config_write(AorB, source, level, width, when_width, polarity)

        self.log_inst_errors()

    def _glitch_config_readback(self, AorB):
        """Read back glitch parameters."""
        return_val = {}
        return_val.update(source=self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_glitch_sources).name)
        return_val.update(level=self.query(f'TRIG:{AorB}:LEV?', float))
        return_val.update(width=self.query(f'TRIG:{AorB}:PUL:GLI:WID?', float))
        return_val.update(when_width=self.query(f'TRIG:{AorB}:PUL:GLI:TRIGIF?', self.enum_glitch_when_width).name)
        return_val.update(polarity=self.query(f'TRIG:{AorB}:PUL:GLI:POL?', self.enum_glitch_polarity).name)
        return return_val

    def _glitch_config_check(self, AorB, source, level, width, when_width, polarity):
        """Ensure all parameters are correct and will not cause issue."""
        source = check_enum_str('source', source, self.enum_glitch_sources)
        if source is None:
            source_state = self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_glitch_sources)
        else:
            source_state = source
        if level is not None:
            level_min, level_max = self._calc_trig_level_range(source_state)
            check_range('level', level, min_max_units(level_min, level_max, 'volts'))
        check_range('width', width, self.bounds_glitch_width_time)
        when_width = check_enum_str('when_width', when_width, self.enum_glitch_when_width)
        polarity = check_enum_str('polarity', polarity, self.enum_glitch_polarity)
        return source, when_width, polarity  # Return enum parameters

    def _glitch_config_write(self, AorB, source, level, width, when_width, polarity):
        """Write all parameters to instrument."""
        if source is not None:
            self.write(f'TRIG:{AorB}:PUL:SOU', source.value)
        if level is not None:
            self.write(f'TRIG:{AorB}:LEV', level)
        if width is not None:
            self.write(f'TRIG:{AorB}:PUL:GLI:WID', width)
        if polarity is not None:
            self.write(f'TRIG:{AorB}:PUL:GLI:POL', polarity.value)
        if when_width is not None:
            self.write(f'TRIG:{AorB}:PUL:GLI:TRIGIF', when_width.value)

    def width_config(self, AorB: str, source: str = None, level: Union[int, float] = None,
                     upper_limit: Union[int, float] = None, lower_limit: Union[int, float] = None,
                     when_width: str = None, polarity: str = None, *args, **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for width trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: One of the 4 analog channels on the instrument. Accepts 'CH[1-4]'.
        :type source: str
        :param level: Set voltage level that pulse need to cross in order to cause a trigger.
        :type level: int|float
        :param upper_limit: Upper boundaries of the pulses' width. Measured in seconds.
        :type upper_limit: int|float
        :param lower_limit: Lower boundaries of the pulses' width. Measured in seconds.
        :type lower_limit: int|float
        :param when_width: Set whether trigger event occurs when pulse is found within or outside boundary
            defined by upper_limit and lower_limit. Accepts:

            * 'INSIDE'
            * 'OUTSIDE'
        :type when_width: str
        :param polarity: Set polarity of the pulse that triggers event. Accepts:

            * 'POSITIVE'
            * 'NEGATIVE'
        :type polarity: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:LEVel
        # TRIGger:{A|B}:PULse:WIDth:HIGHLimit <NR3>
        # TRIGger:{A|B}:PULse:WIDth:LOWLimit <NR3>
        # TRIGger: {A | B}:PULse: WIDth:WHEn {OUTside | WIThin}
        # TRIGger:{A|B}:PULse:WIDth:POLarity {NEGAtive|POSITIVe}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"WIDTH trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if all(v is None for v in {source, level, upper_limit, lower_limit, when_width, polarity}):
            return self._width_config_readback(AorB)

        # Parameter Checking
        source, when_width, polarity = self._width_config_check(AorB, source, level, upper_limit, lower_limit,
                                                                when_width, polarity)

        # Write to instrument
        self._width_config_write(AorB, source, level, upper_limit, lower_limit, when_width, polarity)

        self.log_inst_errors()

    def _width_config_readback(self, AorB):
        """Read back all width parameters"""
        return_val = {}
        return_val.update(source=self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_width_sources).name)
        return_val.update(level=self.query(f'TRIG:{AorB}:LEV?', float))
        return_val.update(upper_limit=self.query(f'TRIG:{AorB}:PUL:WID:HIGHL?', float))
        return_val.update(lower_limit=self.query(f'TRIG:{AorB}:PUL:WID:LOWL?', float))
        return_val.update(when_width=self.query(f'TRIG:{AorB}:PUL:WID:WHE?', self.enum_width_when_width).name)
        return_val.update(polarity=self.query(f'TRIG:{AorB}:PUL:WID:POL?', self.enum_width_polarity).name)
        return return_val

    def _width_config_check(self, AorB, source, level, upper_limit, lower_limit, when_width, polarity):
        """Check Width parameters to ensure to issues will occur in writing to instrument."""
        source = check_enum_str('source', source, self.enum_width_sources)
        if source is None:
            source_state = self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_width_sources)
        else:
            source_state = source
        if level is not None:
            level_min, level_max = self._calc_trig_level_range(source_state)
            check_range('level', level, min_max_units(level_min, level_max, 'volts'))
        check_range('upper_limit', upper_limit, self.bounds_width_upper_lower_limit_time)
        check_range('lower_limit', lower_limit, self.bounds_width_upper_lower_limit_time)
        if upper_limit is not None or lower_limit is not None:
            if lower_limit is None:
                lower_limit_state = self.query(f'TRIG:{AorB}:PUL:WID:LOWL?', float)
                if upper_limit < lower_limit_state:
                    raise ValueError(f'Bad upper_limit: {upper_limit} cannot be less than lower_limit '
                                     f'{lower_limit_state}')
            elif upper_limit is None:
                upper_limit_state = self.query(f'TRIG:{AorB}:PUL:WID:HIGHL?', float)
                if lower_limit > upper_limit_state:
                    raise ValueError(f'Bad lower_limit: {lower_limit} cannot be less than upper_limit '
                                     f'{upper_limit_state}')
            else:
                if upper_limit < lower_limit:
                    raise ValueError(f'Bad upper_limit: {upper_limit} cannot be less than lower_limit {lower_limit}')
                if lower_limit > upper_limit:
                    raise ValueError(f'Bad lower_limit: {lower_limit} cannot be less than upper_limit {upper_limit}')
        when_width = check_enum_str('when_width', when_width, self.enum_width_when_width)
        polarity = check_enum_str('polarity', polarity, self.enum_width_polarity)
        return source, when_width, polarity

    def _width_config_write(self, AorB, source, level, upper_limit, lower_limit, when_width, polarity):
        """Write width parameters to instrument."""
        if source is not None:
            self.write(f'TRIG:{AorB}:PUL:SOU', source.value)
        if level is not None:
            self.write(f'TRIG:{AorB}:LEV', level)
        if upper_limit is not None:
            self.write(f'TRIG:{AorB}:PUL:WID:HIGHL', upper_limit)
        if lower_limit is not None:
            self.write(f'TRIG:{AorB}:PUL:WID:LOWL', lower_limit)
        if when_width is not None:
            self.write(f'TRIG:{AorB}:PUL:WID:WHE', when_width.value)
        if polarity is not None:
            self.write(f'TRIG:{AorB}:PUL:WID:POL', polarity.value)

    def runt_config(self, AorB: str, source: str = None, upper_level: Union[int, float] = None,
                    lower_level: Union[int, float] = None, trig_when: str = None, width: Union[int, float] = None,
                    polarity: str = None, *args, **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for runt trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: CH[1-4] e.g. 'CH0'
        :type source: str
        :param upper_level: Set or query the upper limit for the pulse runt trigger. Measured in time.
        :type upper_level: int|float
        :param lower_level: Set or query the lower limit for the pulse runt trigger. Measured in time.
        :type lower_level: int|float
        :param trig_when: Set or query the type of pulse width the trigger checks for when it detects a runt. Accepts:

            * 'WIDER' - Trigger event if runt is greate than specified width. (use width parameter.)
            * 'OCCURS' - Trigger event if a  runt of any detectable width occurs.

        :type trig_when: str
        :param width: Set or query the minimum width for the pulse runt trigger.
        :type width: int|float
        :param polarity: Set or query the polarity for the pulse runt trigger.
        :type polarity: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:PULse:RUNT:THReshold:HIGH <NR3>
        # TRIGger:{A|B}:PULse:RUNT:THReshold:LOW <NR3>
        # TRIGger:{A|B}:PULse:RUNT:WHEn {OCCurs|WIDERthan}
        # TRIGger:{A|B}:PULse:RUNT:WIDth <NR3>
        # TRIGger:{A|B}:PULse:RUNT:POLarity {POSITIVe|NEGAtive|EITher}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"RUNT trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if all(v is None for v in {source, upper_level, lower_level, trig_when, width, polarity}):
            return self._runt_config_readback(AorB)

        # Parameter Checking
        source, trig_when, polarity = self._runt_config_check(AorB, source, upper_level, lower_level, trig_when,
                                                              width, polarity)

        # Write commands to instrument
        self._runt_config_write(AorB, source, upper_level, lower_level, trig_when, width, polarity)

        self.log_inst_errors()

    def _runt_config_readback(self, AorB):
        """Read back all runt parameters"""
        return_val = {}
        return_val.update(source=self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_runt_sources).name)
        return_val.update(upper_level=self.query(f'TRIG:{AorB}:PUL:RUNT:THR:HIGH?', float))
        return_val.update(lower_level=self.query(f'TRIG:{AorB}:PUL:RUNT:THR:LOW?', float))
        trig_when = self.query(f'TRIG:{AorB}:PUL:RUNT:WHE?', self.enum_runt_trig_when).name
        return_val.update(trig_when=trig_when)
        if trig_when == 'WIDER':
            return_val.update(width=self.query(f'TRIG:{AorB}:PUL:RUNT:WID?', float))
        return_val.update(polarity=self.query(f'TRIG:{AorB}:PUL:RUNT:POL', self.enum_runt_polarity).name)
        return return_val

    def _runt_config_check(self, AorB, source, upper_level, lower_level, trig_when, width, polarity):
        """Check all runt parameters to ensure no issue will occur in writing to insturment."""
        source = check_enum_str('source', source, self.enum_runt_sources)
        if source is None:
            source_state = self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_runt_sources)
        else:
            source_state = source
        if upper_level is not None:
            level_min, level_max = self._calc_trig_level_range(source_state)
            check_range('upper_level', upper_level, min_max_units(level_min, level_max, 'volts'))
        if lower_level is not None:
            level_min, level_max = self._calc_trig_level_range(source_state)
            check_range('level', lower_level, min_max_units(level_min, level_max, 'volts'))
        if upper_level is not None or lower_level is not None:
            if lower_level is None:
                lower_level_state = self.query(f'TRIG:{AorB}:PUL:RUNT:THR:LOW?', float)
                if upper_level < lower_level_state:
                    raise ValueError(f'Bad upper_limit: {upper_level} cannot be less than lower_limit '
                                     f'{lower_level_state}.')
            elif upper_level is None:
                upper_level_state = self.query(f'TRIG:{AorB}:PUL:RUNT:THR:HIGH?', float)
                if lower_level > upper_level_state:
                    raise ValueError(f'Bad lower_limit: {lower_level} cannot be less than upper_limit '
                                     f'{upper_level_state}.')
            else:
                if upper_level < lower_level:
                    raise ValueError(f'Bad upper_limit: {upper_level} cannot be less than lower_limit {lower_level}')
                if lower_level > upper_level:
                    raise ValueError(f'Bad lower_limit: {lower_level} cannot be less than upper_limit {upper_level}')
        trig_when = check_enum_str('trig_when', trig_when, self.enum_runt_trig_when)
        check_range('width', width, self.bounds_runt_width_time)
        if width is not None:  # Revisit logic
            if trig_when is not None:
                if trig_when.name != 'WIDER':
                    raise ValueError(f'Bad trig_when value: {trig_when}. Variable trig_when needs to be set to "WIDER"'
                                     f'in order to change width. ')
            else:
                if self.query(f'TRIG:{AorB}:PUL:RUNT:WHE?', self.enum_runt_trig_when).name == 'OCCURS':
                    trig_when_state = self.query(f'TRIG:{AorB}:PUL:RUNT:WHE?', self.enum_runt_trig_when).name
                    raise ValueError(f'In order to set width, the trig_when parameter needs to be changed to "WIDER".'
                                     f'Currently trig_when is {trig_when_state}')
        polarity = check_enum_str('polarity', polarity, self.enum_runt_polarity)
        return source, trig_when, polarity

    def _runt_config_write(self, AorB, source, upper_level, lower_level, trig_when, width, polarity):
        """Write all runt parameters to instrument."""
        if source is not None:
            self.write(f'TRIG:{AorB}:PUL:SOU', source.value)
        if upper_level is not None:
            self.write(f'TRIG:{AorB}:PUL:RUNT:THR:HIGH', upper_level)
        if lower_level is not None:
            self.write(f'TRIG:{AorB}:PUL:RUNT:THR:LOW', lower_level)
        if trig_when is not None:
            self.write(f'TRIG:{AorB}:PUL:RUNT:WHE', trig_when.value)
        if width is not None:
            self.write(f'TRIG:{AorB}:PUL:RUNT:WID', width)
        if polarity is not None:
            self.write(f'TRIG:{AorB}:PUL:RUNT:POL', polarity.value)

    def timeout_config(self, AorB, source: str = None, level: Union[int, float] = None,
                       timer: Union[int, float] = None, trig_when: str = None, *args,
                       **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for pulse timeout trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: CH[1-4] e.g. 'CH0'
        :type source: str|enum_timeout_sources
        :param level: Set voltage needs to reach in order to trigger event.
        :type level: int|float
        :param timer: Specify timeout period for trigger event. Measures in seconds.
        :type timer: int|float
        :param trig_when: Set or query on what condition the pulse timeout triggers.
        :type trig_when: str|enum_timeout_trig_when
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:LEVel
        # TRIGger: {A | B}:PULse: TIMEOut:TIMe < NR3 >
        # TRIGger:{A|B}:PULse:TIMEOut:POLarity {STAYSHigh|STAYSLow|EITher}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"TIMEOUT trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if all(v is None for v in {source, level, timer, trig_when}):
            return self._timeout_config_readback(AorB)

        # Parameter Checking
        source, trig_when = self._timeout_config_check(AorB, source, level, timer, trig_when)

        # Write commands to instrument
        self._timeout_config_write(AorB, source, level, timer, trig_when)

        self.log_inst_errors()

    def _timeout_config_readback(self, AorB):
        """Read backk all timeout parameters"""
        return_val = {}
        return_val.update(source=self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_timeout_sources).name)
        return_val.update(level=self.query(f'TRIG:{AorB}:LEV?', float))
        return_val.update(timer=self.query(f'TRIG:{AorB}:PUL:TIMEO:TIM?', float))
        return_val.update(trig_when=self.query(f'TRIG:{AorB}:PUL:TIMEO:POL?', self.enum_timeout_trig_when).name)
        return return_val

    def _timeout_config_check(self, AorB, source, level, timer, trig_when):
        """Check all timeout parameters to ensure no issue will occur in writing to instrument."""
        source = check_enum_str('source', source, self.enum_timeout_sources)
        if source is None:
            source_state = self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_timeout_sources)
        else:
            source_state = source
        if level is not None:
            level_min, level_max = self._calc_trig_level_range(source_state)
            check_range('level', level, min_max_units(level_min, level_max, 'volts'))
        check_range('timer', timer, self.bounds_timeout_timer)
        trig_when = check_enum_str('trig_when', trig_when, self.enum_timeout_trig_when)
        return source, trig_when

    def _timeout_config_write(self, AorB, source, level, timer, trig_when):
        """Write timeout parameters to instrument."""
        if source is not None:
            self.write(f'TRIG:{AorB}:PUL:SOU', source.value)
        if level is not None:
            self.write(f'TRIG:{AorB}:LEV', level)
        if timer is not None:
            self.write(f'TRIG:{AorB}:PUL:TIMEO:TIM', timer)
        if trig_when is not None:
            self.write(f'TRIG:{AorB}:PUL:TIMEO:POL', trig_when.value)

    @abstractmethod
    def pattern_config(self, *args, **kwargs):
        pass

    @abstractmethod
    def state_config(self, *args, **kwargs):
        pass

    def thresholds_analog_channels(self, AorB, thresh_vals: Dict[str, Union[int, float]] = None, *args,
                                   **kwargs) -> Dict[str, Union[str, float]]:
        """
        Set or query thresholds of analog channels used for pattern/state trigger logic.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param thresh_vals: Dictionary containing channel name as the key and the desired threshold value.
            Accepts 'CH[1-4]' as valid analog channels.
        :type thresh_vals: Dict[str: int|float]
        :return: Dictionary of current threshold values for channels
        :rtype: Dict[str: float]
        """

        # TRIGger:{A|B}:LOGIc:THReshold:CH<x> <NR3>

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"PATTERN/STATE trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if thresh_vals is None:
            return_vals = {}
            for channel in range(1, 5):
                return_vals[f'CH{channel}'] = self.query(f'TRIG:{AorB}:LOGI:THR:CH{channel}', float)
            return return_vals

        # Parameter checking
        for key, val in thresh_vals.items():
            key = check_enum_str('key', key, self.enum_analog_channels)
            level_min, level_max = self._calc_trig_level_range(key)
            check_range('threshhold', val, min_max_units(level_min, level_max, 'volts'))

        # Write commands to instrument
        for key, val in thresh_vals.items():
            self.write(f'TRIG:{AorB}:LOGI:THR:{key}', val)

        self.log_inst_errors()

    def setup_hold_config(self, AorB, data_source: str = None, data_level: Union[int, float] = None,
                          clock_source: str = None, clock_level: Union[int, float] = None,
                          setup_time: Union[int, float] = None, hold_time: Union[int, float] = None,
                          clock_edge: str = None, *args, **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for logic setup/hold trigger. Trigger on violations of either
        setup time or hold time between clock and data present on any two input channels.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param data_source: The input channel providing the data signal 'CH1'-'CH4' and on MSO oscopes 'D0'-'D15'.
        :type data_source: str|enum_setup_hold_sources
        :param data_level: Data signal edges are defined by a transition through this voltage level.
            transition used in the setup/hold measurement.
        :type data_level: int|float
        :param clock_source: The input channel providing the clock signal 'CH1'-'CH4' and on MSO oscopes 'D0'-'D15'.
        :type clock_source: str|enum_setup_hold_sources
        :param clock_level: Clock signal edges are defined by a transition in the specified direction through this
            voltage level.
        :type clock_level: int|float
        :param setup_time: Time in seconds defining the beginning of the violation region with respect to the clock
            edge. Positive setup_time is **before** the clock edge, negative is **after**.
        :type setup_time: int|float
        :param hold_time: Time in seconds defining the end of the violation region with respect to the clock
            edge. Positive hold_time is **after** the clock edge, negative is **before**.
        :type hold_time: int|float
        :param clock_edge: Set or query the clock edge polarity. Accepts:

            * 'FALL'
            * 'RISE'
        :type clock_edge: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:SETHold:DATa:SOUrce CH<x>
        # TRIGger:{A|B}:LOGIc:SETHold:DATa:THReshold {ECL|TTL|<NR3>}
        # TRIGger:{A|B}:LOGIc:SETHold:CLOCk:SOUrce CH<x>
        # TRIGger:{A|B}:LOGIc:SETHold:CLOCk:THReshold {ECL|TTL|<NR3>}
        # TRIGger:{A|B}:LOGIc:SETHold:SETTime <NR3>
        # TRIGger:{A|B}:LOGIc:SETHold:HOLDTime <NR3>
        # TRIGger:{A|B}:LOGIc:SETHold:CLOCk:EDGE {FALL|RISe}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"SETUP/HOLD trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if all(v is None for v in {data_source, data_level, clock_source, clock_level, setup_time, hold_time,
                                   clock_edge}):
            return self._setup_hold_config_readback(AorB)

        # Parameter checking
        data_source, clock_source, clock_edge, curr_source, curr_clock = self._setup_hold_config_check(AorB,
                                                                                                       data_source,
                                                                                                       data_level,
                                                                                                       clock_source,
                                                                                                       clock_level,
                                                                                                       setup_time,
                                                                                                       hold_time,
                                                                                                       clock_edge)
        # Outside of param check function as this requires extra handling in some DPO models.
        if curr_clock.name == curr_source.name:
            raise ValueError(f"Attempting to set clock and data sources both to '{curr_clock.name}', must be "
                             f"different signals.")

        # Write commands to instrument
        self._setup_hold_config_write(AorB, data_source, data_level, clock_source, clock_level, setup_time, hold_time,
                                      clock_edge)

        self.log_inst_errors()

    def _setup_hold_config_readback(self, AorB):
        """Read back all setup/hold parameters."""
        return_val = {}
        return_val.update(data_source=self.query(f'TRIG:{AorB}:LOGI:SETH:DAT:SOU?',
                                                 self.enum_setup_hold_sources).name)
        return_val.update(data_level=self.query(f'TRIG:{AorB}:LOGI:SETH:DAT:THR?', float))
        return_val.update(clock_source=self.query(f'TRIG:{AorB}:LOGI:SETH:CLOC:SOU?',
                                                  self.enum_setup_hold_sources).name)
        return_val.update(clock_level=self.query(f'TRIG:{AorB}:LOGI:SETH:CLOC:THR?', float))
        return_val.update(setup_time=self.query(f'TRIG:{AorB}:LOGI:SETH:SETT?', float))
        return_val.update(hold_time=self.query(f'TRIG:{AorB}:LOGI:SETH:HOLDT?', float))
        return_val.update(clock_edge=self.query(f'TRIG:{AorB}:LOGI:SETH:CLOC:EDGE?',
                                                self.enum_setup_hold_clock_edge).name)
        return return_val

    def _setup_hold_config_check(self, AorB, data_source, data_level, clock_source, clock_level, setup_time, hold_time,
                                 clock_edge):
        """Check Setup/Hold parameters to ensure to issue occurs when writing to instrument."""
        data_source = check_enum_str('data_source', data_source, self.enum_setup_hold_sources)
        curr_source = data_source
        if curr_source is None:
            curr_source = self.query(f'TRIG:{AorB}:LOGI:SETH:DAT:SOU?', self.enum_setup_hold_sources)

        level_min, level_max = self._calc_trig_level_range(curr_source)
        check_range('data_level', data_level, min_max_units(level_min, level_max, 'volts'))

        clock_source = check_enum_str('clock_source', clock_source, self.enum_setup_hold_sources)
        curr_clock = clock_source
        if clock_source is None:
            curr_clock = clock_source = self.query(f'TRIG:{AorB}:LOGI:SETH:CLOC:SOU?', self.enum_setup_hold_sources)

        level_min, level_max = self._calc_trig_level_range(curr_clock)
        check_range('clock_level', clock_level, min_max_units(level_min, level_max, 'volts'))
        check_range('setup_time', setup_time, self.trig_logic_setup_hold_setup_timing)
        check_range('hold_time', hold_time, self.trig_logic_setup_hold_hold_timing)
        clock_edge = check_enum_str('clock_edge', clock_edge, self.enum_setup_hold_clock_edge)
        return data_source, clock_source, clock_edge, curr_source, curr_clock

    def _setup_hold_config_write(self, AorB, data_source, data_level, clock_source, clock_level, setup_time, hold_time,
                                 clock_edge):
        """Write Setup/Hold commands to instrument."""
        if data_source is not None:
            self.write(f'TRIG:{AorB}:LOGI:SETH:DAT:SOU', data_source.value)
        if data_level is not None:
            self.write(f'TRIG:{AorB}:LOGI:SETH:DAT:THR', data_level)
        if clock_source is not None:
            self.write(f'TRIG:{AorB}:LOGI:SETH:CLOC:SOU', clock_source.value)
        if clock_level is not None:
            self.write(f'TRIG:{AorB}:LOGI:SETH:CLOC:THR', clock_level)
        if setup_time is not None:
            self.write(f'TRIG:{AorB}:LOGI:SETH:SETT', setup_time)
        if hold_time is not None:
            self.write(f'TRIG:{AorB}:LOGI:SETH:HOLDT', hold_time)
        if clock_edge is not None:
            self.write(f'TRIG:{AorB}:LOGI:SETH:CLOCK:EDGE', clock_edge.value)

    def transition_config(self, AorB, source: str = None, transition: str = None, upper_level: Union[int, float] = None,
                          lower_level: Union[int, float] = None, time: Union[int, float] = None,
                          slope: str = None, *args, **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for logic setup/hold trigger. Trigger on pulse edge rates that
        are faster or slower than specified. Slope may be positive, negative, or either.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: The input channel providing the signal for pulse transition trigger: 'CH1' - 'CH4'.
        :type source: str|enum_transition_sources
        :param transition: Specifies trigger when transition of signal is faster or slower than the time parameter.
            Accepts:

            * 'FASTER'
            * 'SLOWER'
        :type transition: str|enum_transition_transition
        :param upper_level: Upper (most positive) transition trigger threshold in volts.
        :type upper_level: int|float
        :param lower_level: Lower (most negative) transition trigger threshold in volts.
        :type lower_level: int|float
        :param time: Transition time in seconds.
        :type time: int|float
        :param slope: The polarity for the transaction trigger. Accepts:

            * 'POS'
            * 'NEG'
            * 'EITHER'
        :type slope: str|enum_transition_slope
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:PULse:TRANsition:WHEn {FASTERthan|SLOWERthan}
        # TRIGger:{A|B}:PULse:TRANsition:THReshold:HIGH <NR3>
        # TRIGger:{A|B}:PULse:TRANsition:THReshold:LOW <NR3>
        # TRIGger:{A|B}:PULse:TRANsition:DELTATime <NR3>
        # TRIGger:{A|B}:PULse:TRANsition:POLarity {POSITIVe|NEGAtive|EITher}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"TRANSITION trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if all(v is None for v in {source, transition, upper_level, lower_level, time, slope}):
            return self._transition_config_readback(AorB)

        # Parameter checking
        source, transition, slope = self._transition_config_check(AorB, source, transition, upper_level, lower_level,
                                                                  time, slope)

        # Write commands to instrument
        self._transition_config_write(AorB, source, transition, upper_level, lower_level, time, slope)

        self.log_inst_errors()

    def _transition_config_readback(self, AorB):
        """Read back all transition parameters."""
        return_val = {}
        return_val.update(source=self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_transition_sources).name)
        return_val.update(transition=self.query(f'TRIG:{AorB}:PUL:TRAN:WHE?', self.enum_transition_transition).name)
        return_val.update(upper_level=self.query(f'TRIG:{AorB}:PUL:TRAN:THR:HIGH?', float))
        return_val.update(lower_level=self.query(f'TRIG:{AorB}:PUL:TRAN:THR:LOW?', float))
        return_val.update(time=self.query(f'TRIG:{AorB}:PUL:TRAN:DELTAT?', float))
        return_val.update(slope=self.query(f'TRIG:{AorB}:PUL:TRAN:POL?', self.enum_transition_slope).name)
        return return_val

    def _transition_config_check(self, AorB, source, transition, upper_level, lower_level, time, slope):
        """Check transition parameters to ensure no issues occur when writing to instrument."""
        source = check_enum_str('source', source, self.enum_transition_sources)
        curr_source = source
        if curr_source is None:
            curr_source = self.query(f'TRIG:{AorB}:PUL:SOU?', self.enum_transition_sources)

        transition = check_enum_str('transition', transition, self.enum_transition_transition)

        level_min, level_max = self._calc_trig_level_range(curr_source)
        check_range('upper_level', upper_level, min_max_units(level_min, level_max, 'volts'))
        check_range('lower_level', lower_level, min_max_units(level_min, level_max, 'volts'))

        if upper_level is not None:
            curr_lower_level = lower_level
            if curr_lower_level is None:
                curr_lower_level = self.query(f'TRIG:{AorB}:PUL:TRAN:THR:LOW?', float)
            if upper_level < curr_lower_level:
                raise ValueError(f'Bad upper_level {float(upper_level)}V, needs to be more than '
                                 f'current lower_level {curr_lower_level}V.')
        if lower_level is not None:
            curr_upper_level = upper_level
            if curr_upper_level is None:
                curr_upper_level = self.query(f'TRIG:{AorB}:PUL:TRAN:THR:HIGH?', float)
            if lower_level > curr_upper_level:
                raise ValueError(f'Bad lower_level {float(lower_level)}V,  needs to be less than '
                                 f'current upper_level {curr_upper_level}V.')

        check_range('time', time, self.bounds_transition_time)
        slope = check_enum_str('slope', slope, self.enum_transition_slope)
        return source, transition, slope

    def _transition_config_write(self, AorB, source, transition, upper_level, lower_level, time, slope):
        """Write transition parameters to instrument."""
        if source is not None:
            self.write(f'TRIG:{AorB}:PUL:SOU', source.value)
        if transition is not None:
            self.write(f'TRIG:{AorB}:PUL:TRAN:WHEN', transition.value)
        if upper_level is not None:
            self.write(f'TRIG:{AorB}:PUL:TRAN:THR:HIGH', upper_level)
        if lower_level is not None:
            self.write(f'TRIG:{AorB}:PUL:TRAN:THR:LOW', lower_level)
        if time is not None:
            self.write(f'TRIG:{AorB}:PUL:TRAN:DELTAT', time)
        if slope is not None:
            self.write(f'TRIG:{AorB}:PUL:TRAN:POL', slope.value)

    @staticmethod
    def video_config():
        return 'Video trigger not implemented in CL Instrument Library. Contact PLATDEV team if this is needed.'
