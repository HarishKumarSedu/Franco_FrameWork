import re
from enum import Enum
from typing import Dict, Union

from cl_instr_lib.base_classes.tek_scopes.dpo_mso_5k7k.trigger_5k_7k.trigger_dpo_5k_7k import Trigger_DPO_5k_7k
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import min_max_units

class Trigger_DPO_7k(Trigger_DPO_5k_7k):
    """Class providing the **Trigger** controls of a Tektronix DPO5000 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        model = self.scope.model

        # Overwrite Parameters specific to DPO7k series
        trig_dict = {
                'EDGE':       ('EDGE',  None,              None),
                'GLITCH':     ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'GLITCH'),
                'WIDTH':      ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'WIDTH'),
                'RUNT':       ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'RUNT'),
                'TIMEOUT':    ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'TIMEOUT'),
                'PATTERN':    ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'PATTERN'),
                'STATE':      ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'STATE'),
                'SETUP_HOLD': ('LOGIC', 'TRIG:{AorB}:LOGI:CLA', 'SETHOLD'),
                'TRANSITION': ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'TRANSITION'),
                'WINDOW':     ('PULSE', 'TRIG:{AorB}:PULS:CLA', 'WINDOW'),
                'VIDEO':      ('VIDEO',  None,                  None),
                # 'SPI':        ('SERIAL', None,                  'SPI'),
                # 'I2C':        ('SERIAL', None,                  'I2C'),
                # 'RS_232':     ('SERIAL', None,                  'RS232'),
                'BUS':        ('BUS',    None,                  None)
        }
        self.enum_trigA_types = Enum('enum_trigA_types', trig_dict)
        trig_dict.pop('VIDEO')
        self.enum_trigB_types = Enum('enum_trigB_types', trig_dict)
        self.enum_pulse_use_pattern_logic = Enum('enum_pulse_use_pattern_logic', {
            'YES': 'LOGIC',
            'NO': 'OCCURS'
        })
        self.trig_level_divs = 12
        # TODO: Find 10X probe value. 1X probe value is less than 1X for DPO5k??
        self.trig_level_aux_volts = {'1X': 5, '10X': 50}
        # TODO: Can only go up to 1s while DPO5000 can go up to 8?
        self.bounds_glitch_width_time = min_max_units(300e-12, 1.0, 'seconds')
        self.enum_glitch_polarity = Enum('enum_glitch_polarity', {
            'POSITIVE': 'POSITIVE',
            'NEGATIVE': 'NEGATIVE',
            'EITHER': 'EITHER'
        })

        self.bounds_width_upper_lower_limit_time = min_max_units(300e-12, 10, 'seconds')
        self.bounds_runt_width_time = min_max_units(300e-12, 1, 'seconds')
        self.bounds_timeout_timer = min_max_units(400e-12, 1, 'seconds')
        self.bounds_transition_time = min_max_units(300e-12, 1, 'seconds')
        self.trig_logic_setup_hold_setup_timing = min_max_units(-100e-9, 100e-9, 'seconds')
        self.trig_logic_setup_hold_hold_timing = min_max_units(-1e-9, 102e09, 'seconds')
        self.trig_logic_state_trig_if = 'TRUE_OR_FALSE'

        if re.match('^DPO7(05|10|25|35)4$', model):
            self.bounds_holdoff_sec = namedtuple_min_max(250e-9, 12.0)
            self.bounds_Btrig_events = namedtuple_min_max(1, int(10e6))  # TODO: Check value
            self.bounds_Btrig_time = namedtuple_min_max(5e-9, 250)  # TODO: Check value
        elif re.match('^DPO7(05|10|25|35)4C$', model):
            self.bounds_holdoff_sec = namedtuple_min_max(250e-9, 100.0)  # TODO: Check value
            self.bounds_Btrig_events = namedtuple_min_max(1, int(999e9))  # TODO: Check value
            self.bounds_Btrig_time = namedtuple_min_max(3.2e-9, 3e6)  # TODO: Check value

    def glitch_config(self, AorB: str, source: str = None, level: Union[int, float] = None,
                      width: Union[int, float] = None, when_width: str = None, polarity: str = None,
                      use_pattern_logic: str = None, pattern_type: str = None, analog_pattern: Union[str, int] = None,
                      *args, **kwargs) -> Dict[str, float]:
        """
        Query all or set any combination of parameters for glitch trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: Analog channel used to capture glitch event. Accepts 'CH[1-4]'
        :type source: str
        :param level: Set voltage glitch needs to reach in order to trigger
        :type level: int|float
        :param width: Set the timeframe that needs to be within/exceed to trigger.
        :type width: int|float
        :param when_width: Set so scope triggers when glitch width is specified within width boundaries or
            outside of width boundaries. Accepts:

            * 'GREATER_THAN'
            * 'LESS_THAN'

        :type when_width: str
        :param polarity: Set the polarity of the trigger. Accepts:

            * 'POS'
            * 'NEG'

        :type polarity: str
        :param use_pattern_logic: Set logic pattern requirement along with glitch parameters to cause a trigger event.
            The logic pattern is going to be composed of two channels: If the source for glitch is either CH1 or CH2,
            then pattern is configured using CH3 and CH4, and vice versa. This pattern accepts the following input:

            * 'YES' - Require a pattern criteria to be met in order for trigger to occur.
            * 'NO' - No pattern criteria is required and will only trigger based off of a glitch configuration.

            This parameter resembles Trigger if Glitch box beneath the trigger section in the DPO7k GUI. Use
            thresholds_analog_channels to change the threshold levels of the pattern.
        :type use_pattern_logic: str|enum_pulse_use_pattern_logic
        :param pattern_type: Pattern logic the two channels being used will adhere to. Accepts:

            * 'AND'
            * 'OR'
            * 'NAND'
            * 'NOR'

        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the logical state of the analog channels in order for a glitch trigger to occur.
            If glitch source is 'CH1' or 'CH2' then analog pattern will set 'CH3' and 'CH4' and vice versa. Parameter
            accepts:

            * '0'
            * '1'
            * 'X'
            * A binary number representing the channel configuration to define the state (0-3).

            Example: If source == 'CH1', analog_pattern='01' will set CH1 to 1 and CH2 to 0.
        :type analog_pattern: str, int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:GLItch?
        # TRIGger:{A|B}:PULse:GLItch:POLarity {POSITIVe|NEGAtive|EITher}
        # TRIGger:{A|B}:PULse:GLItch:TRIGIF {ACCept|REJect}
        # TRIGger:{A|B}:PULse:GLItch:WIDth <NR3>
        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:LEVel
        # TRIGger:{A|B}:PULse:GLItch:QUAlify {OCCurs|LOGIc|BUS}
        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        curr_source = source
        if source is None:
            curr_source = self.query(f'TRIG:{AorB}:PUL:SOU?')

        # Readback
        if all(v is None for v in {source, level, width, when_width, polarity, use_pattern_logic, pattern_type,
                                   analog_pattern}):
            return_val = self._glitch_config_readback(AorB)
            return_val = self._pulse_pattern_readback(AorB, 'GLITCH', curr_source, return_val)
            return return_val

        # Parameter Checking
        source, when_width, polarity = self._glitch_config_check(AorB, source, level, width, when_width, polarity)
        use_pattern_logic, pattern_type, write_pattern = self._pulse_pattern_check(AorB, curr_source, use_pattern_logic,
                                                                                   pattern_type, analog_pattern)

        # Write to Instrument
        self._glitch_config_write(AorB, source, level, width, when_width, polarity)
        self._pulse_pattern_write(AorB, 'GLITCH', use_pattern_logic, pattern_type, analog_pattern, write_pattern)

        self.log_inst_errors()

    def width_config(self, AorB: str, source: str = None, level: Union[int, float] = None,
                     upper_limit: Union[int, float] = None, lower_limit: Union[int, float] = None,
                     when_width: str = None, polarity: str = None, use_pattern_logic: str = None,
                     pattern_type: str = None, analog_pattern: Union[str, int] = None, *args,
                     **kwargs) -> Dict[str, float]:
        """
        Query all or set any combination of parameters for width trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: One of the 4 analog channels on the instrument. Accepts 'CH[1-4]'.
        :type source: str
        :param level: Set voltage level that pulse need to cross in order to cause a trigger.
        :type level: int|float
        :param upper_limit: Upper boundaries of the pulses' width. Measured in seconds.
        :type upper_limit: int|float
        :param lower_limit: Lower boundaries of the pulses' width. Measured in seconds.
        :type lower_limit: int|float
        :param when_width: Set whether trigger event occurs when pulse is found within or outside boundary
            defined by upper_limit and lower_limit. Accepts:

            * 'INSIDE'
            * 'OUTSIDE'

        :type when_width: str
        :param polarity: Set polarity of the pulse that triggers event. Accepts:

            * 'POSITIVE'
            * 'NEGATIVE'

        :type polarity: str
        :param use_pattern_logic: Set logic pattern requirement along with glitch parameters to cause a trigger event.
            The logic pattern is going to be composed of two channels: If the source for glitch is either CH1 or CH2,
            then pattern is configured using CH3 and CH4, and vice versa. This pattern accepts the following input:

            * 'YES' - Require a pattern criteria to be met in order for trigger to occur.
            * 'NO' - No pattern criteria is required and will only trigger based off of a glitch configuration.

            This parameter resembles Trigger if Glitch box beneath the trigger section in the DPO7k GUI. Use
            thresholds_analog_channels to change the threshold levels of the pattern.
        :type use_pattern_logic: str|enum_pulse_use_pattern_logic
        :param pattern_type: Pattern logic the two channels being used will adhere to. Accepts:

            * 'AND'
            * 'OR'
            * 'NAND'
            * 'NOR'

        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the logical state of the analog channels in order for a glitch trigger to occur.
            If glitch source is 'CH1' or 'CH2' then analog pattern will set 'CH3' and 'CH4' and vice versa. Parameter
            accepts:

            * '0'
            * '1'
            * 'X'
            * A binary number representing the channel configuration to define the state (0-3).

            Example: If source == 'CH1', analog_pattern='01' will set CH1 to 1 and CH2 to 0.
        :type analog_pattern: str, int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:LEVel
        # TRIGger:{A|B}:PULse:WIDth:HIGHLimit <NR3>
        # TRIGger:{A|B}:PULse:WIDth:LOWLimit <NR3>
        # TRIGger: {A | B}:PULse: WIDth:WHEn {OUTside | WIThin}
        # TRIGger:{A|B}:PULse:WIDth:POLarity {NEGAtive|POSITIVe}
        # TRIGger:{A|B}:PULse:WIDth:QUAlify {OCCurs|LOGIc|BUS}
        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        curr_source = source
        if curr_source is None:
            curr_source = self.query(f'TRIG:{AorB}:PUL:SOU?')

        # Read back
        if all(v is None for v in {source, level, upper_limit, lower_limit, when_width, polarity, use_pattern_logic,
                                   pattern_type, analog_pattern}):
            return_val = self._width_config_readback(AorB)
            return_val = self._pulse_pattern_readback(AorB, 'WIDTH', curr_source, return_val)
            return return_val

        # Parameter Checking
        source, when_width, polarity = self._width_config_check(AorB, source, level, upper_limit, lower_limit,
                                                                when_width, polarity)
        use_pattern_logic, pattern_type, write_pattern = self._pulse_pattern_check(AorB, curr_source, use_pattern_logic,
                                                                                   pattern_type, analog_pattern)

        # Write to Instrument
        self._width_config_write(AorB, source, level, upper_limit, lower_limit, when_width, polarity)
        self._pulse_pattern_write(AorB, 'WIDTH', use_pattern_logic, pattern_type, analog_pattern, write_pattern)

        self.log_inst_errors()

    def runt_config(self, AorB: str, source: str = None, upper_level: Union[int, float] = None,
                    lower_level: Union[int, float] = None, trig_when: str = None, width: Union[int, float] = None,
                    polarity: str = None, use_pattern_logic: str = None, pattern_type: str = None,
                    analog_pattern: Union[str, int] = None, *args, **kwargs) -> Dict[str, float]:
        """
        Query all or set any combination of parameters for runt trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: CH[1-4] e.g. 'CH0'
        :type source: str
        :param upper_level: Set or query the upper limit for the pulse runt trigger. Measured in time.
        :type upper_level: int|float
        :param lower_level: Set or query the lower limit for the pulse runt trigger. Measured in time.
        :type lower_level: int|float
        :param trig_when: Set or query the type of pulse width the trigger checks for when it detects a runt. Accepts:

            * 'WIDER' - Trigger event if runt is greate than specified width. (use width parameter.)
            * 'OCCURS' - Trigger event if a  runt of any detectable width occurs.

        :type trig_when: str
        :param width: Set or query the minimum width for the pulse runt trigger.
        :type width: int|float
        :param polarity: Set or query the polarity for the pulse runt trigger.
        :type polarity: str
        :param use_pattern_logic: Set logic pattern requirement along with glitch parameters to cause a trigger event.
            The logic pattern is going to be composed of two channels: If the source for glitch is either CH1 or CH2,
            then pattern is configured using CH3 and CH4, and vice versa. This pattern accepts the following input:

            * 'YES' - Require a pattern criteria to be met in order for trigger to occur.
            * 'NO' - No pattern criteria is required and will only trigger based off of a glitch configuration.

            This parameter resembles Trigger if Glitch box beneath the trigger section in the DPO7k GUI. Use
            thresholds_analog_channels to change the threshold levels of the pattern.
        :type use_pattern_logic: str|enum_pulse_use_pattern_logic
        :param pattern_type: Pattern logic the two channels being used will adhere to. Accepts:

            * 'AND'
            * 'OR'
            * 'NAND'
            * 'NOR'

        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the logical state of the analog channels in order for a glitch trigger to occur.
            If glitch source is 'CH1' or 'CH2' then analog pattern will set 'CH3' and 'CH4' and vice versa. Parameter
            accepts:

            * '0'
            * '1'
            * 'X'
            * A binary number representing the channel configuration to define the state (0-3).

            Example: If source == 'CH1', analog_pattern='01' will set CH1 to 1 and CH2 to 0.
        :type analog_pattern: str, int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:PULse:RUNT:THReshold:HIGH <NR3>
        # TRIGger:{A|B}:PULse:RUNT:THReshold:LOW <NR3>
        # TRIGger:{A|B}:PULse:RUNT:WHEn {OCCurs|WIDERthan}
        # TRIGger:{A|B}:PULse:RUNT:WIDth <NR3>
        # TRIGger:{A|B}:PULse:RUNT:POLarity {POSITIVe|NEGAtive|EITher}
        # TRIGger:{A|B}:PULse:RUNT:QUAlify {OCCurs|LOGIc|BUS}
        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        curr_source = source
        if curr_source is None:
            curr_source = self.query(f'TRIG:{AorB}:PUL:SOU?')

        # Read back
        if all(v is None for v in {source, upper_level, lower_level, trig_when, width, polarity, use_pattern_logic,
                                   pattern_type, analog_pattern}):
            return_val = self._runt_config_readback(AorB)
            return_val = self._pulse_pattern_readback(AorB, 'RUNT', curr_source, return_val)
            return return_val

        # Parameter Checking
        source, trig_when, polarity = self._runt_config_check(AorB, source, upper_level, lower_level, trig_when, width,
                                                              polarity)
        use_pattern_logic, pattern_type, write_pattern = self._pulse_pattern_check(AorB, curr_source, use_pattern_logic,
                                                                                   pattern_type, analog_pattern)

        # Write to Instrument
        self._runt_config_write(AorB, source, upper_level, lower_level, trig_when, width, polarity)
        self._pulse_pattern_write(AorB, 'RUNT', use_pattern_logic, pattern_type, analog_pattern, write_pattern)

        self.log_inst_errors()

    def timeout_config(self, AorB, source: str = None, level: Union[int, float] = None,
                       timer: Union[int, float] = None, trig_when: str = None, use_pattern_logic: str = None,
                       pattern_type: str = None, analog_pattern: Union[str, int] = None, *args,
                       **kwargs) -> Dict[str, float]:
        """
        Query all or set any combination of parameters for pulse timeout trigger.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: CH[1-4] e.g. 'CH0'
        :type source: str|enum_timeout_sources
        :param level: Set voltage needs to reach in order to trigger event.
        :type level: int|float
        :param timer: Specify timeout period for trigger event. Measures in seconds.
        :type timer: int|float
        :param trig_when: Set or query on what condition the pulse timeout triggers.
        :type trig_when: str|enum_timeout_trig_when
        :param use_pattern_logic: Set logic pattern requirement along with glitch parameters to cause a trigger event.
            The logic pattern is going to be composed of two channels: If the source for glitch is either CH1 or CH2,
            then pattern is configured using CH3 and CH4, and vice versa. This pattern accepts the following input:

            * 'YES' - Require a pattern criteria to be met in order for trigger to occur.
            * 'NO' - No pattern criteria is required and will only trigger based off of a glitch configuration.

            This parameter resembles Trigger if Glitch box beneath the trigger section in the DPO7k GUI. Use
            thresholds_analog_channels to change the threshold levels of the pattern.
        :type use_pattern_logic: str|enum_pulse_use_pattern_logic
        :param pattern_type: Pattern logic the two channels being used will adhere to. Accepts:

            * 'AND'
            * 'OR'
            * 'NAND'
            * 'NOR'

        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the logical state of the analog channels in order for a glitch trigger to occur.
            If glitch source is 'CH1' or 'CH2' then analog pattern will set 'CH3' and 'CH4' and vice versa. Parameter
            accepts:

            * '0'
            * '1'
            * 'X'
            * A binary number representing the channel configuration to define the state (0-3).

            Example: If source == 'CH1', analog_pattern='01' will set CH1 to 1 and CH2 to 0.
        :type analog_pattern: str, int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:LEVel
        # TRIGger: {A | B}:PULse: TIMEOut:TIMe < NR3 >
        # TRIGger:{A|B}:PULse:TIMEOut:POLarity {STAYSHigh|STAYSLow|EITher}
        # TRIGger:{A|B}:PULse:RUNT:POLarity {POSITIVe|NEGAtive|EITher}
        # TRIGger:{A|B}:PULse:TIMEO:QUAlify {OCCurs|LOGIc|BUS}
        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        curr_source = source
        if curr_source is None:
            curr_source = self.query(f'TRIG:{AorB}:PUL:SOU?')

        # Read back
        if all(v is None for v in {source, level, timer, trig_when, use_pattern_logic, pattern_type,
                                   analog_pattern}):
            return_val = self._timeout_config_readback(AorB)
            return_val = self._pulse_pattern_readback(AorB, 'TIMEOUT', curr_source, return_val)
            return return_val

        # Parameter Checking
        source, trig_when = self._timeout_config_check(AorB, source, level, timer, trig_when)
        use_pattern_logic, pattern_type, write_pattern = self._pulse_pattern_check(AorB, curr_source, use_pattern_logic,
                                                                                   pattern_type, analog_pattern)

        # Write to Instrument
        self._timeout_config_write(AorB, source, level, timer, trig_when)
        self._pulse_pattern_write(AorB, 'TIMEOUT', use_pattern_logic, pattern_type, analog_pattern, write_pattern)

        self.log_inst_errors()

    def pattern_config(self, AorB, pattern_type: str = None, analog_pattern: Union[str, int] = None,
                       trig_if: Union[str, bool] = None, timer: Union[int, float] = None, *args,
                       **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for the logic pattern trigger.

        When setting a pattern, the order of the pattern is mirrored in the order seen on the physical instrument as
        well as to be consistent with GUI's of other tek scopes. The parameter goes from smallest channel to largest
        channel e.g. CH1 -> CH4. More information on the individual channel below.

        This method will not set thresholds for the analog channels. Use threshold_analog_channels to configure that
        particular setting.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param pattern_type: Query or set logical combination of input channels for pattern to trigger.
            Valid entries:

            * 'AND'
            * 'NAND'
            * 'OR'
            * 'NOR'

        :type pattern_type: str
        :param analog_pattern: Defines the state of analog channels CH1-CH4 that must be present for triggering to
            occur.
            String  must be a combination of 4 of the characters '0', '1' or 'X' (don't care). Alternatively,
            analog_pattern may be specified as an int from 0 to 15. Any of the most significant bits not specified by
            the str or that would be a 0 in the int are replaced by 'X'. (Specifying analog_pattern=1 is equivalent to
            the binary pattern 'XXX1'.)
        :type analog_pattern: str|int
        :param trig_if: Set or query condition for generating a pattern trigger with respect to defined
            input pattern. Accepts the following inputs:

            * True|'TRUE' - Trigger when boolean input is true.
            * False|'FALSE' - Trigger when boolean input is false.
            * 'GREATERTHAN' - Trigger when boolean input is true for more than x time defined by the timer parameter.
            * 'LESSTHAN' - Trigger when boolean input is true for less than x time (x is defined by the time parameter).

        :type trig_if: str|bool
        :param timer: Set or query time requirement for generating a pattern trigger with respect to defined
            input pattern.
        :type timer: int|float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}
        # TRIGger:{A|B}:LOGIc:PATtern:WHEn
        # TRIGger:{A|B}:LOGIc:PATtern:WHEn:MORELimit <NR3>
        # TRIGger:{a|B}:LOGIc:PATtern:WHEn:LESSLimit <NR3>

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        # log_inst_errors done in self._pattern_config
        return self._pattern_config(AorB, pattern_type, analog_pattern, trig_if, timer)

    def state_config(self, AorB, pattern_type: str = None, analog_pattern: Union[str, int] = None,
                     trig_if: Union[int, float] = None, clock_level: Union[int, float] = None,
                     when_clock: str = None, *args, **kwargs) -> Dict[str, Union[int, float]]:
        """
        Query all or set any combination of parameters for logic state trigger. When clock transition occurs, scope
        will compare oscope inputs to set logic pattern and determine whether or not it meets the criteria for
        a trigger to occur.

        Note when setting an analog pattern, the parameter goes from smallest channel to largest channel e.g.
        CH1 -> CH3. More information below.

        This method will not set thresholds for digital bits or analog channels. To set digital thresholds,
        use the digital API. To set analog thresholds use thresholds_analog_channels in this module.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger. On 5000 series state trigger is only available on the 'A" trigger. On 7000 series it is
            available on both 'A' and 'B' triggers.
        :type AorB: str
        :param pattern_type: Query or set logical combination of input channels for pattern to trigger.
            Valid entries:

            * 'AND'
            * 'NAND'
            * 'OR'
            * 'NOR'

        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the state of analog channels CH1-CH3 that must be present at the clock
            edge for triggering to occur. String is interpreted as **binary** and must be a combination of 3 of the
            characters '0', '1' or 'X' (don't care). Alternatively, analog_pattern may be specified as an int from 0 to
            7. Any of the most significant bits not specified by the str or that would be a 0 in the int are replaced by
            'X'. (Specifying digital_pattern=1 is equivalent to the binary pattern 'XX1'.) . CH4 is the clock input,
            therefore cannot be used like the other channels. In a query response analog_pattern is always returned as
            the full 3 character string.
        :type analog_pattern: str|int
        :param trig_if: Set or query condition for generating a pattern trigger with respect to defined
            input pattern. The DPO5000 series only accepts True|'TRUE' as an input.
        :type trig_if: str|bool
        :param clock_level: Set or query logic threshold for clock.
        :type clock_level: int|float
        :param when_clock: Set or query what edge of the clock a trigger can occur on. Accepts:

            * 'POS'
            * 'NEG'

        :type when_clock: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}
        # TRIGger:{A|B}:LOGIc:STATE:WHEn {TRUe|FALSe}
        # TRIGger:{A|B}:LOGIc:INPut:FORMat {HEXadecimal|BINary}
        # TRIGger:{A|B}:LOGIc:THReshold:CH<x> <NR3>
        # TRIGger:{A|B}:LOGIc:STATE:INPut:CH<x> {FALL|RISe}
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        # Readback
        if all(v is None for v in {pattern_type, analog_pattern, trig_if, clock_level, when_clock}):
            return self._state_config_readback(AorB)

        # log_inst_errors done in self._state_config
        self._state_config(AorB, pattern_type, analog_pattern, trig_if, clock_level, when_clock)

    def setup_hold_config(self, AorB, data_source: str = None, data_level: Union[int, float] = None,
                          clock_source: str = None, clock_level: Union[int, float] = None,
                          setup_time: Union[int, float] = None, hold_time: Union[int, float] = None,
                          clock_edge: str = None, use_pattern_logic: str = None,
                          pattern_type: str = None, analog_pattern: Union[str, int] = None, *args,
                          **kwargs) -> Dict[str, float]:
        """
        Query all or set any combination of parameters for logic setup/hold trigger. Trigger on violations of either
        setup time or hold time between clock clock and data present on any two input channels.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param data_source: The input channel providing the data signal 'CH1'-'CH4'. If use_pattern_logic is set to
            'YES', then 2 channels will be used to determine a pattern logic. As this leaves 2 remaining channels for
            data_source and clock_source, changing clock source may inherently change data source. For example, if clock
            source is changed from CH2 to CH1, data source will then change from CH1 to CH2. The same goes for if these
            channels are being defined by CH3 and CH4. See use_pattern_logic parameter for more details.
        :type data_source: str|enum_setup_hold_sources
        :param data_level: Data signal edges are defined by a transition through this voltage level.
            transition used in the setup/hold measurement.
        :type data_level: int|float
        :param clock_source: The input channel providing the clock signal 'CH1'-'CH4'. If use_pattern_logic is set to
            'YES', then 2 channels will be used to determine a pattern logic. As this leaves 2 remaining channels for
            data_source and clock_source, changing data source may inherently change data source. For example, if data
            source is changed from CH2 to CH1, clock source will then change from CH1 to CH2. The same goes for if these
            channels are being defined by CH3 and CH4. See use_pattern_logic parameter for more details.
        :type clock_source: str|enum_setup_hold_sources
        :param clock_level: Clock signal edges are defined by a transition in the specified direction through this
            voltage level.
        :type clock_level: int|float
        :param setup_time: Time in seconds defining the beginning of the violation region with respect to the clock
            edge. Positive setup_time is **before** the clock edge, negative is **after**.
        :type setup_time: int|float
        :param hold_time: Time in seconds defining the end of the violation region with respect to the clock
            edge. Positive hold_time is **after** the clock edge, negative is **before**.
        :type hold_time: int|float
        :param clock_edge: Set or query the clock edge polarity. Accepts:

            * 'FALL'
            * 'RISE'

        :type clock_edge: str
        :param use_pattern_logic: Set logic pattern requirement along with glitch parameters to cause a trigger event.
            The logic pattern is going to be composed of two channels: If the source for glitch is either CH1 or CH2,
            then pattern is configured using CH3 and CH4, and vice versa. This pattern accepts the following input:

            * 'YES' - Require a pattern criteria to be met in order for trigger to occur.
            * 'NO' - No pattern criteria is required and will only trigger based off of a glitch configuration.

            This parameter resembles Trigger if Glitch box beneath the trigger section in the DPO7k GUI. Use
            thresholds_analog_channels to change the threshold levels of the pattern.
        :type use_pattern_logic: str|enum_pulse_use_pattern_logic
        :param pattern_type: Pattern logic the two channels being used will adhere to. Accepts:

            * 'AND'
            * 'OR'
            * 'NAND'
            * 'NOR'

        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the logical state of the analog channels in order for a glitch trigger to occur.
            If glitch source is 'CH1' or 'CH2' then analog pattern will set 'CH3' and 'CH4' and vice versa. Parameter
            accepts:

            * '0'
            * '1'
            * 'X'
            * A binary number representing the channel configuration to define the state (0-3).

            Example: If source == 'CH1', analog_pattern='01' will set CH1 to 1 and CH2 to 0.
        :type analog_pattern: str, int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:SETHold:DATa:SOUrce CH<x>
        # TRIGger:{A|B}:LOGIc:SETHold:DATa:THReshold {ECL|TTL|<NR3>}
        # TRIGger:{A|B}:LOGIc:SETHold:CLOCk:SOUrce CH<x>
        # TRIGger:{A|B}:LOGIc:SETHold:CLOCk:THReshold {ECL|TTL|<NR3>}
        # TRIGger:{A|B}:LOGIc:SETHold:SETTime <NR3>
        # TRIGger:{A|B}:LOGIc:SETHold:HOLDTime <NR3>
        # TRIGger:{A|B}:LOGIc:SETHold:CLOCk:EDGE {FALL|RISe}
        # TRIGger:{A|B}:PULse:SETHold:QUAlify {OCCurs|LOGIc|BUS}
        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        curr_data_source = data_source
        if curr_data_source is None:
            curr_data_source = self.query(f'TRIG:{AorB}:LOGI:SETH:DAT:SOU?')

        # Read back
        if all(v is None for v in {data_source, data_level, clock_source, clock_level, setup_time, hold_time,
                                   clock_edge, use_pattern_logic, pattern_type,
                                   analog_pattern}):
            return_val = self._setup_hold_config_readback(AorB)
            return_val = self._pulse_pattern_readback(AorB, 'SETUP_HOLD', curr_data_source, return_val,
                                                      trig_group='LOGI')
            return return_val

        # Parameter Checking

        data_source, clock_source, clock_edge, curr_source, curr_clock = self._setup_hold_config_check(AorB,
                                                                                                       data_source,
                                                                                                       data_level,
                                                                                                       clock_source,
                                                                                                       clock_level,
                                                                                                       setup_time,
                                                                                                       hold_time,
                                                                                                       clock_edge)
        curr_use_pattern_logic = use_pattern_logic
        if curr_use_pattern_logic is None:
            curr_use_pattern_logic = self.query(f'TRIG:A:LOGI:SETH:QUA?', self.enum_pulse_use_pattern_logic)
        else:
            curr_use_pattern_logic = check_enum_str('curr_use_pattern_logic', curr_use_pattern_logic,
                                                    self.enum_pulse_use_pattern_logic)
        # Needs errors checking if use_pattern_logic is 'NO', needs no handling if use_pattern_logic is 'YES'
        if curr_use_pattern_logic.name == 'NO':
            if curr_clock.name == curr_source.name:
                raise ValueError(f"Attempting to set clock and data sources both to '{curr_clock.name}', must be "
                                 f"different signals.")
        use_pattern_logic, pattern_type, write_pattern = self._pulse_pattern_check(AorB, curr_data_source,
                                                                                   use_pattern_logic, pattern_type,
                                                                                   analog_pattern)

        # Write to Instrument
        self._setup_hold_config_write(AorB, data_source, data_level, clock_source, clock_level, setup_time, hold_time,
                                      clock_edge)
        self._pulse_pattern_write(AorB, 'SETUP_HOLD', use_pattern_logic, pattern_type, analog_pattern, write_pattern,
                                  trig_group='LOGI')

        self.log_inst_errors()

    def transition_config(self, AorB, source: str = None, transition: str = None, upper_level: Union[int, float] = None,
                          lower_level: Union[int, float] = None, time: Union[int, float] = None, slope: str = None,
                          use_pattern_logic: str = None, pattern_type: str = None,
                          analog_pattern: Union[str, int] = None, *args, **kwargs) -> Dict[str, float]:
        """
        Query all or set any combination of parameters for logic setup/hold trigger. Trigger on pulse edge rates that
        are faster or slower than specified. Slope may be positive, negative, or either.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param source: The input channel providing the signal for pulse transition trigger: 'CH1' - 'CH4'.
        :type source: str|enum_transition_sources
        :param transition: Specifies trigger when transition of signal is faster or slower than the time parameter.
            Accepts:

            * 'FASTER'
            * 'SLOWER'

        :type transition: str|enum_transition_transition
        :param upper_level: Upper (most positive) transition trigger threshold in volts.
        :type upper_level: int|float
        :param lower_level: Lower (most negative) transition trigger threshold in volts.
        :type lower_level: int|float
        :param time: Transition time in seconds.
        :type time: int|float
        :param slope: The polarity for the transaction trigger. Accepts:

            * 'POS'
            * 'NEG'
            * 'EITHER'

        :type slope: str|enum_transition_slope
        :param use_pattern_logic: Set logic pattern requirement along with glitch parameters to cause a trigger event.
            The logic pattern is going to be composed of two channels: If the source for glitch is either CH1 or CH2,
            then pattern is configured using CH3 and CH4, and vice versa. This pattern accepts the following input:

            * 'YES' - Require a pattern criteria to be met in order for trigger to occur.
            * 'NO' - No pattern criteria is required and will only trigger based off of a glitch configuration.

            This parameter resembles Trigger if Glitch box beneath the trigger section in the DPO7k GUI. Use
            thresholds_analog_channels to change the threshold levels of the pattern.
        :type use_pattern_logic: str|enum_pulse_use_pattern_logic
        :param pattern_type: Pattern logic the two channels being used will adhere to. Accepts:

            * 'AND'
            * 'OR'
            * 'NAND'
            * 'NOR'

        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the logical state of the analog channels in order for a glitch trigger to occur.
            If glitch source is 'CH1' or 'CH2' then analog pattern will set 'CH3' and 'CH4' and vice versa. Parameter
            accepts:

            * '0'
            * '1'
            * 'X'
            * A binary number representing the channel configuration to define the state (0-3).

            Example: If source == 'CH1', analog_pattern='01' will set CH1 to 1 and CH2 to 0.
        :type analog_pattern: str, int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:PULse:SOUrce {CH<x>|D<x>|MCH<x>}
        # TRIGger:{A|B}:PULse:TRANsition:WHEn {FASTERthan|SLOWERthan}
        # TRIGger:{A|B}:PULse:TRANsition:THReshold:HIGH <NR3>
        # TRIGger:{A|B}:PULse:TRANsition:THReshold:LOW <NR3>
        # TRIGger:{A|B}:PULse:TRANsition:DELTATime <NR3>
        # TRIGger:{A|B}:PULse:TRANsition:POLarity {POSITIVe|NEGAtive|EITher}
        # TRIGger:{A|B}:PULse:TRANsition:QUAlify {OCCurs|LOGIc|BUS}
        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        curr_source = source
        if curr_source is None:
            curr_source = self.query(f'TRIG:{AorB}:PUL:SOU?')

        # Read back
        if all(v is None for v in {source, transition, upper_level, lower_level, time, slope, use_pattern_logic,
                                   pattern_type, analog_pattern}):
            return_val = self._transition_config_readback(AorB)
            return_val = self._pulse_pattern_readback(AorB, 'TRANSITION', curr_source, return_val)
            return return_val

        # Parameter Checking
        source, transition, slope = self._transition_config_check(AorB, source, transition, upper_level, lower_level,
                                                                  time, slope)
        use_pattern_logic, pattern_type, write_pattern = self._pulse_pattern_check(AorB, curr_source, use_pattern_logic,
                                                                                   pattern_type, analog_pattern)

        # Write to Instrument
        self._transition_config_write(AorB, source, transition, upper_level, lower_level, time, slope)
        self._pulse_pattern_write(AorB, 'TRANSITION', use_pattern_logic, pattern_type, analog_pattern, write_pattern)

        self.log_inst_errors()

    def _pulse_pattern_readback(self, AorB, trig_type, curr_source, return_val, trig_group='PUL'):
        trig_type = check_enum_str('trig_type', trig_type, self.pulse_triggers)  # Find SCPI command to change the
        # use_pattern_logic parameter
        curr_pattern = self.query(f'TRIG:{AorB}:LOGI:INP?')
        use_pattern_logic = self.query(f'TRIG:{AorB}:{trig_group}:{trig_type.value}:QUA?',
                                       self.enum_pulse_use_pattern_logic).name
        return_val.update(use_pattern_logic=use_pattern_logic)
        if use_pattern_logic == 'YES':
            return_val.update(pattern_type=self.query(f'TRIG:{AorB}:LOGI:FUNC?'))
            if curr_source in ['CH1', 'CH2']:
                return_val.update(analog_pattern=self._convert_pattern_readback(curr_pattern)[2:])
            elif curr_source in ['CH3', 'CH4']:
                return_val.update(analog_pattern=self._convert_pattern_readback(curr_pattern)[:2])
        return return_val

    def _pulse_pattern_check(self, AorB, curr_source, use_pattern_logic, pattern_type, analog_pattern):
        use_pattern_logic = check_enum_str('use_pattern_logic', use_pattern_logic, self.enum_pulse_use_pattern_logic)
        pattern_type, write_pattern, _ = self._pattern_config_check(AorB, pattern_type, analog_pattern, None,
                                                                    None, None, 2)
        if analog_pattern is not None:
            if curr_source in ['CH1', 'CH2']:
                write_pattern.insert(0, self._enum_valid_pattern_chars.X)
                write_pattern.insert(0, self._enum_valid_pattern_chars.X)
            elif curr_source in ['CH3', 'CH4']:
                write_pattern.extend([self._enum_valid_pattern_chars.X, self._enum_valid_pattern_chars.X])
        return use_pattern_logic, pattern_type, write_pattern

    def _pulse_pattern_write(self, AorB, trig_type, use_pattern_logic, pattern_type, analog_pattern, write_pattern,
                             trig_group='PUL'):
        trig_type = check_enum_str('trig_type', trig_type, self.pulse_triggers)  # Find SCPI command to change the
        # use_pattern_logic parameter
        if use_pattern_logic is not None:
            self.write(f'TRIG:{AorB}:{trig_group}:{trig_type.value}:QUA', use_pattern_logic.value)
        curr_use_pattern_logic = use_pattern_logic
        if use_pattern_logic is None:
            curr_use_pattern_logic = self.query(f'TRIG:{AorB}:{trig_group}:{trig_type.value}:QUA?',
                                                self.enum_pulse_use_pattern_logic)
        if any(v is not None for v in {pattern_type, analog_pattern}):
            if curr_use_pattern_logic.name != 'YES':
                raise ValueError('use_logic_pattern needs to be set to "YES" in order to configure pattern_type'
                                 'or analog_pattern')
            self._pattern_config_write(AorB, pattern_type, analog_pattern, write_pattern, None, None, None)

    def window_config(self):
        raise RuntimeError('window_config not implemented in CL Instrument Library, but ticket does exist for '
                           'it. '
                           'Please contact PLATDEV team if this is needed.')

    def spi_config(self):
        raise RuntimeError('SPI trigger not implemented in CL Instrument Library, but ticket does exist for it. '
                           'Please contact PLATDEV team if this is needed.')

    def i2c_config(self):
        raise RuntimeError('I2C trigger not implemented in CL Instrument Library, but ticket does exist for it. '
                           'Please contact PLATDEV team if this is needed.')

    def rs232_config(self):
        raise RuntimeError('RS232 trigger not implemented in CL Instrument Library, but ticket does exist for it. '
                           'Please contact PLATDEV team if this is needed.')

    def bus_config(self):
        raise RuntimeError('bus_config not implemented in CL Instrument Library, but ticket does exist for it. '
                           'Please contact PLATDEV team if this is needed.')
