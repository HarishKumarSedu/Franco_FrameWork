from cl_instr_lib.base_classes.tek_scopes.dpo_mso_5k7k.trigger_5k_7k.trigger_5k_7k import Trigger_5k_7k
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units

from enum import Enum
from typing import Dict, List, Union

class Trigger_DPO_5k_7k(Trigger_5k_7k):
    """Class providing the **Trigger** controls of a Tektronix DPO5000/7000 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        self._enum_valid_pattern_chars = Enum('_enum_valid_pattern_chars', {
            '1': 'HIGH',
            '0': 'LOW',
            'X': 'X'
        })

    def pattern_config(self, AorB, pattern_type: str = None, analog_pattern: Union[str, int] = None,
                       trig_if: Union[str, bool] = None, timer: Union[int, float] = None, *args,
                       **kwargs) -> Dict[str, Union[str, float]]:
        """
        Query all or set any combination of parameters for the logic pattern trigger.

        When setting a pattern, the order of the pattern is mirrored in the order seen on the physical instrument as
        well as to be consistent with GUI's of other tek scopes. The parameter goes from smallest channel to largest
        channel e.g. CH1 -> CH4. More information on the individual channel below.

        This method will not set thresholds for the analog channels. Use threshold_analog_channels to configure that
        particular setting.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger.
        :type AorB: str
        :param pattern_type: Query or set logical combination of input channels for pattern to trigger.
            Valid entries are 'AND', 'NAND', 'OR', 'NOR'.
        :type pattern_type: str
        :param analog_pattern: Defines the state of analog channels CH1-CH4 that must be present for triggering to
            occur. String  must be a combination of 4 of the characters '0', '1' or 'X' (don't care). Alternatively,
            analog_pattern may be specified as an int from 0 to 15. Any of the most significant bits not specified by
            the str or that would be a 0 in the int are replaced by 'X'. (Specifying analog_pattern=1 is equivalent to
            the binary pattern 'XXX1'.)
        :type analog_pattern: str|int
        :param trig_if: Set or query condition for generating a pattern trigger with respect to defined
            input pattern. Accepts the following inputs:

            * True|'TRUE' - Trigger when boolean input is true.
            * False|'FALSE' - Trigger when boolean input is false.
            * 'GREATERTHAN' - Trigger when boolean input is true for more than timer parameter.
            * 'LESSTHAN' - Trigger when boolean input is true for less than timer parameter).

        :type trig_if: str|bool
        :param timer: Set or query time requirement for generating a pattern trigger with respect to defined
            input pattern.
        :type timer: int|float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}
        # TRIGger:{A|B}:LOGIc:PATtern:WHEn
        # TRIGger:{A|B}:LOGIc:PATtern:WHEn:MORELimit <NR3>
        # TRIGger:{a|B}:LOGIc:PATtern:WHEn:LESSLimit <NR3>

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"PATTERN trigger is not available for the 'B' trigger on {self.scope.model}.")

        return self._pattern_config(AorB, pattern_type, analog_pattern, trig_if, timer)

    def _pattern_config(self, AorB, pattern_type, analog_pattern, trig_if, timer):
        """Helper function to resuse code bewteen DPO7k and DPO5k"""
        curr_trig_if = self.query(f'TRIG:{AorB}:LOGI:PAT:WHE?', self.enum_pattern_trig_if)
        if trig_if is not None:
            curr_trig_if = check_enum_str('curr_trig_if', trig_if, self.enum_pattern_trig_if)

        # Readback
        if all(v is None for v in {pattern_type, analog_pattern, trig_if, timer}):
            return self._pattern_config_readback(AorB, curr_trig_if)

        # Parameter Checking
        pattern_type, write_pattern, trig_if = self._pattern_config_check(AorB, pattern_type, analog_pattern, trig_if,
                                                                          timer, curr_trig_if, 4)

        # Write to Instrument
        self._pattern_config_write(AorB, pattern_type, analog_pattern, write_pattern, trig_if, timer, curr_trig_if)

        self.log_inst_errors()

    def _pattern_config_readback(self, AorB, curr_trig_if):
        curr_pattern = self.query(f'TRIG:{AorB}:LOGI:INP?')
        return_val = {}
        return_val.update(pattern_type=self.query(f'TRIG:{AorB}:LOGI:FUNC?', self.enum_logic_pattern_type).name)
        return_val.update(analog_pattern=self._convert_pattern_readback(curr_pattern))
        return_val.update(trig_if=curr_trig_if.name)
        if curr_trig_if.name == 'GREATERTHAN':
            return_val.update(timer=self.query(f'TRIG:{AorB}:LOGI:PAT:WHE:MOREL?', float))
        if curr_trig_if.name == 'LESSTHAN':
            return_val.update(timer=self.query(f'TRIG:{AorB}:LOGI:PAT:WHE:LESSL?', float))
        return return_val

    def _pattern_config_check(self, AorB, pattern_type, analog_pattern, trig_if, timer, curr_trig_if, max_len):
        pattern_type = check_enum_str('pattern_type', pattern_type, self.enum_logic_pattern_type)
        # Check pattern
        write_pattern = None
        if analog_pattern is not None:
            write_pattern = self._check_analog_pattern(analog_pattern, max_len)
        if trig_if is True:
            trig_if = 'TRUE'
        elif trig_if is False:
            trig_if = 'FALSE'
        trig_if = check_enum_str('trig_if', trig_if, self.enum_pattern_trig_if)
        if timer is not None:
            if curr_trig_if.name not in self.list_time_valid_trig_if_settings:
                raise ValueError(f'Incorrect trig_if config for time settings: {curr_trig_if.name}. Change trig_if to'
                                 f'"GREATERTHAN" OR "LESSTHAN" if timer configs are required.')
            check_range('timer', timer, self.bounds_trig_logic_pat_time)
        return pattern_type, write_pattern, trig_if

    def _pattern_config_write(self, AorB, pattern_type, analog_pattern, write_pattern, trig_if, timer, curr_trig_if):
        if pattern_type is not None:
            self.write(f'TRIG:{AorB}:LOGI:FUNC', pattern_type.value)
        if analog_pattern is not None:
            for channel_num, channel in enumerate(write_pattern):
                channel_num += 1  # CH1-4
                self.write(f'TRIG:{AorB}:LOGI:INP:CH{channel_num}', channel.value)
        if trig_if is not None:
            self.write(f'TRIG:{AorB}:LOGI:PAT:WHE', trig_if.value)
        if timer is not None:
            if curr_trig_if.name == 'GREATERTHAN':
                self.write(f'TRIG:{AorB}:LOGI:PAT:WHE:MOREL', timer)
            elif curr_trig_if.name == 'LESSTHAN':
                self.write(f'TRIG:{AorB}:LOGI:PAT:WHE:LESSL', timer)

    def state_config(self, AorB, pattern_type: str = None, analog_pattern: Union[str, int] = None,
                     trig_if: Union[int, float] = None, clock_level: Union[int, float] = None,
                     when_clock: str = None, *args, **kwargs) -> Dict[str, Union[int, float]]:
        """
        Query all or set any combination of parameters for logic state trigger. When clock transition occurs, scope
        will compare oscope inputs to set logic pattern and determine whether or not it meets the criteria for
        a trigger to occur.

        Note when setting an analog pattern, the parameter goes from smallest channel to largest channel e.g.
        CH1 -> CH3. More information below.

        This method will not set thresholds for digital bits or analog channels. To set digital thresholds,
        use the digital API. To set analog thresholds use thresholds_analog_channels in this module.

        :param AorB: Required parameter that specifies if you are programming the 'A' event trigger or the 'B' event
            trigger. On 5000 series state trigger is only available on the 'A" trigger. On 7000 series it is
            available on both 'A' and 'B' triggers.
        :type AorB: str
        :param pattern_type: Query or set logical combination of input channels for pattern to trigger.
            Valid entries: 'AND', 'NAND', 'OR', 'NOR'.
        :type pattern_type: str|enum_logic_pattern_type
        :param analog_pattern: Defines the state of analog channels CH1-CH3 that must be present at the clock
            edge for triggering to occur.  String is interpreted as **binary** and must be a combination of 3 of the
            characters '0', '1' or 'X' (don't care). Alternatively, analog_pattern may be specified as an int from 0 to
            7. Any of the most significant bits not specified by the str or that would be a 0 in the int are replaced by
            'X'. (Specifying digital_pattern=1 is equivalent to the binary pattern 'XX1'.) . CH4 is the clock input,
            therefore cannot be used like the other channels. In a query response analog_pattern is always returned as
            the full 3 character string.
        :type analog_pattern: str|int
        :param trig_if: Set or query condition for generating a pattern trigger with respect to defined
            input pattern. The DPO5000 series only accepts True|'TRUE' as an input.
        :type trig_if: str|bool
        :param clock_level: Set or query logic threshold for clock.
        :type clock_level: int|float
        :param when_clock: Set or query what edge of the clock a trigger can occur on. Accepts 'POS' or 'NEG'
        :type when_clock: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        :rtype: dict
        """

        # TRIGger:{A|B}:LOGIc:FUNCtion {AND|NANd|NOR|OR}
        # TRIGger:{A|B}:LOGIc:INPut <QString>
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}
        # TRIGger:{A|B}:LOGIc:STATE:WHEn {TRUe|FALSe}
        # TRIGger:{A|B}:LOGIc:INPut:FORMat {HEXadecimal|BINary}
        # TRIGger:{A|B}:LOGIc:THReshold:CH<x> <NR3>
        # TRIGger:{A|B}:LOGIc:STATE:INPut:CH<x> {FALL|RISe}
        # TRIGger:{A|B}:LOGIc:INPut:CH<x> {HIGH|LOW|X}

        self.log_unused_args(args, kwargs)

        if AorB not in ('A', 'B'):
            raise ValueError(f"Bad trigger choice AorB '{AorB}', should be 'A' or 'B'.")

        if AorB == 'B' and 'STATE' not in self.enum_trigB_types:
            raise ValueError(f"STATE trigger is not available for the 'B' trigger on {self.scope.model}.")

        # Readback
        if all(v is None for v in {pattern_type, analog_pattern, trig_if, clock_level, when_clock}):
            return self._state_config_readback(AorB)

        self._state_config(AorB, pattern_type, analog_pattern, trig_if, clock_level, when_clock)

    def _state_config(self, AorB, pattern_type, analog_pattern, trig_if, clock_level, when_clock):
        # Parameter Checking
        pattern_type = check_enum_str('pattern_type', pattern_type, self.enum_logic_pattern_type)
        # Check pattern
        write_pattern = None
        if analog_pattern is not None:
            write_pattern = self._check_analog_pattern(analog_pattern, 3)
        # Allow user to specify as str or bool.
        if trig_if is True:
            trig_if = 'TRUE'
        elif trig_if is False:
            trig_if = 'FALSE'
        trig_if = check_enum_str('trig_if', trig_if, self.enum_state_trig_if)
        if self.trig_logic_state_trig_if == 'ONLY_TRUE' and trig_if is not None:
            if trig_if.value != 'TRUE':
                raise ValueError(f'Scope {self.scope.model} can only have trig_if parameter set as True. '
                                 f'Currently attempting to set to {trig_if.value}')
        if clock_level is not None:
            level_min, level_max = self._calc_trig_level_range(self.enum_analog_channels.CH4)
            check_range('clock_level', clock_level, min_max_units(level_min, level_max, 'volts'))
        when_clock = check_enum_str('when_clock', when_clock, self.enum_state_when_clock)

        # Write to Instrument
        if pattern_type is not None:
            self.write(f'TRIG:{AorB}:LOGI:FUNC', pattern_type.value)
        if analog_pattern is not None:
            for channel_num, channel in enumerate(write_pattern):
                channel_num += 1  # CH1-3
                self.write(f'TRIG:{AorB}:LOGI:INP:CH{channel_num}', channel.value)
        if trig_if is not None:
            self.write(f'TRIG:{AorB}:LOGI:PAT:WHE', trig_if.value)
        if clock_level is not None:
            self.write(f'TRIG:{AorB}:LOGI:THR:CH4', clock_level)
        if when_clock is not None:
            self.write(f'TRIG:{AorB}:LOGI:STATE:INP:CH4', when_clock.value)

        self.log_inst_errors()

    def _state_config_readback(self, AorB):
        """Read"""
        return_val = {}
        return_val.update(pattern_type=self.query(f'TRIG:{AorB}:LOGI:FUNC?', self.enum_logic_pattern_type).name)
        curr_pattern = self.query(f'TRIG:{AorB}:LOGI:INP?')
        return_val.update(analog_pattern=self._convert_pattern_readback(curr_pattern)[:-1])
        return_val.update(trig_if=self.query(f'TRIG:{AorB}:LOGI:STATE:WHE?', self.enum_state_trig_if).name)
        return_val.update(clock_level=self.query(f'TRIG:{AorB}:LOGI:THR:CH4?', float))
        return_val.update(when_clock=self.query(f'TRIG:{AorB}:LOGI:STATE:INP:CH4?',
                                                self.enum_state_when_clock).name)
        return return_val

    @staticmethod
    def _convert_pattern_readback(pattern):
        ret_pattern = []
        for val in pattern.split(';'):
            if val == 'HIGH':
                val = '1'
            elif val == 'LOW':
                val = '0'
            ret_pattern.append(val)
        return ''.join(ret_pattern)

    def _check_analog_pattern(self, analog_pattern: Union[int, str],
                              max_len: int) -> List[Enum]:
        """
        Verify the analog pattern is valid and format it to be writable to the instrument. Specifically for the
        DPO5k & DPO7k pattern and state trigger config methods.

        :param analog_pattern: Pattern to be verified.
        :type analog_pattern: int|str
        :param max_len: Maximum length of pattern. Pattern allows up to 4 while State allows up to 3.
        :type max_len: int
        :return: Pattern that's writable to instrument.
        :rtype: List of enums with valid pattern characters.
        """
        if isinstance(analog_pattern, int):
            check_range('analog_pattern', analog_pattern, min_max_units(0, 2 ** max_len - 1, ''), val_type=int)
            analog_pattern = bin(analog_pattern).replace('0b', '')
        if not isinstance(analog_pattern, str):
            raise ValueError(f'Bad analog_pattern: {analog_pattern}. Must be int or str')
        ret_pattern = []
        if len(analog_pattern) <= 0 or len(analog_pattern) > max_len:
            raise ValueError(f'Bad analog_pattern: {analog_pattern}. String needs to be equal to or greater'
                             f'than 1 or equal to or less than {max_len}')
        for val in analog_pattern:
            val = check_enum_str('val', val, self._enum_valid_pattern_chars)
            ret_pattern.append(val)
        for i in range(max_len - len(ret_pattern)):
            ret_pattern.insert(0, self._enum_valid_pattern_chars.X)  # Add don't cares to undefined channels.
        return ret_pattern
