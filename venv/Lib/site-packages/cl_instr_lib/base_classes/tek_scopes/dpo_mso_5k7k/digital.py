import re
from enum import Enum
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from typing import Union


class Digital:
    """Class abstracting digital input functionality of a MSO5000 series oscilloscope.

    Contains objects for all 16 bits and methods that affect every bit.
    """

    def __init__(self, scope, **kwargs):
        self._channel_num = 16
        self.query = scope.query
        self.write = scope.write
        self.on_off = scope.on_off
        self.log = scope.log

        # Create Digital Groups
        self.D0 = DigitalBit(self, 0)
        self.D1 = DigitalBit(self, 1)
        self.D2 = DigitalBit(self, 2)
        self.D3 = DigitalBit(self, 3)
        self.D4 = DigitalBit(self, 4)
        self.D5 = DigitalBit(self, 5)
        self.D6 = DigitalBit(self, 6)
        self.D7 = DigitalBit(self, 7)
        self.D8 = DigitalBit(self, 8)
        self.D9 = DigitalBit(self, 9)
        self.D10 = DigitalBit(self, 10)
        self.D11 = DigitalBit(self, 11)
        self.D12 = DigitalBit(self, 12)
        self.D13 = DigitalBit(self, 13)
        self.D14 = DigitalBit(self, 14)
        self.D15 = DigitalBit(self, 15)

    # NOTE: Values are for VERBOSE 'ON', can't change to short forms unless it gets done everywhere in oscope code.
    enum_sizes = Enum('enum_sizes', {"XSMALL": "XSMALL", "SMALL": "SMALL", "MEDIUM": "MEDIUM", "LARGE": "LARGE"})

    def config(self, display_mask: int = None, global_threshold: Union[int, float] = None, size: str = None,
               ) -> Union[dict, None]:
        """
        Queries or sets the configuration of all 16 channels

        :param display_mask: The bits of this int value (0 to 65535) each control the display of one of the digital
            inputs D0 to D15.
        :type display_mask: int
        :param global_threshold: Set the threshold level for digital signal for all 16 bits of the probe.
        :type global_threshold: int|float
        :param size: Changes the sizing of every digital signal displayed on the scope screen. Accepts 'XSMALL',
            'SMALL', 'MEDIUM', or 'LARGE'. Large setting unavailable when too many digital signals are being displayed.
        :type size: str|enum_size
        :returns: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        # D<x>:THRESHold <NR3>
        # DISplay:DIGital:HEIght {SMAll|LARge|MEDium|XSMAll}
        # SELect:DIGTraces:COMbination <nr1>
        # SELect:DIGTraces:LISt <Dx>

        # Readback
        if all(v is None for v in {display_mask, size, global_threshold}):
            return_vals = {}
            return_vals.update(display_mask=self.get_display_mask())
            return_vals.update(size=self.query(f'DIS:DIG:HEI?', self.enum_sizes).name)

            # If all thresholds same, return as global value, otherwise None.
            thresholds = []
            for channel in range(0, self._channel_num):
                thresholds.append(self.query(f'D{channel}:THRESH?'))
            if all([t == thresholds[0] for t in thresholds]):
                return_vals.update(global_threshold=float(thresholds[0]))
            else:
                return_vals.update(global_threshold=None)

            return return_vals

        # Parameter checking
        check_range('display_mask', display_mask, min_max_units(0, 65535, ''))
        size_obj = check_enum_str('size', size, self.enum_sizes)
        check_range('global_threshold', global_threshold, min_max_units(-40, 40, 'Volts'))

        # Write commands to instrument
        if display_mask is not None:
            self.write('SEL:DIGT:COM', display_mask)

        if size is not None:
            self.write('DIS:DIG:HEI', size_obj.value)  # size_obj.value

        if global_threshold is not None:
            for channel in range(0, self._channel_num):
                self.write(f'D{channel}:THRESH', global_threshold)

    def get_display_mask(self):
        """
        Returns an int (0 to 65535) where each bit position corresponds to the on/off state of one of the digital
        channels D15 (MSB) to D0.
        """

        # SELect:DIGTraces:LISt <Dx>

        on_bits = self.query('SEL:DIGT:LIS?')
        display_mask = 0
        for num in re.findall('\d{1,2}', on_bits):
            display_mask += 2 ** int(num)
        return display_mask

    def group_on_off(self, group: int, state: str):
        """
        Turn group 1 or 2 of the digital bits 'ON' or 'OFF'.

        :param group: The 16 bits are broken into groups 1 (D7-D0) and 2 (D15-D8).
        :type group: int
        :param state: Value to set state. Accepts 'ON', 1, or True; 'OFF', 0, or False
        :type state: str|int|bool
        :return: None
        :rtype: None
        """

        check_range('group', group, min_max_units(1, 2, ''))

        if state not in self.on_off.api_values():
            raise ValueError(f'Bad state {state}. Valid options: {self.on_off.api_values()}')

        state = bool(int(self.on_off.to_inst(state)))

        display_mask = self.get_display_mask()

        if group == 1:
            display_mask &= 0xFF00
            if state:
                display_mask |= 0x00FF
        elif group == 2:
            display_mask &= 0x00FF
            if state:
                display_mask |= 0xFF00
        else:
            raise ValueError(f"Bad group {group}, should be 1 or 2  (Corresponding to d7_d0 or d15_d8, respectively).")

        self.config(display_mask=display_mask)

    def reset_labels(self, prefix='D', bitnum_min=0, bitnum_max=15):
        """
        Reset labels of all or a range of bits to a their original label or a custom label.

        :param prefix: Characters prefixed to the bit number. Max characters for a label is 8, so in order to prevent
            any labels from being cut off, prefix cannot be any longer than 6 characters. Default prefix is 'D'
        :type prefix: str
        :param bitnum_min: Minimum bit in range for label reset.
        :type bitnum_min: int
        :param bitnum_max: Maximum bit in range to for label reset.
        :type bitnum_max: int
        :return: None
        :rtype: None
        """

        check_range('bitnum_max', bitnum_max, min_max_units(0, 15, ''))
        check_range('bitnum_min', bitnum_min, min_max_units(0, 15, ''))
        if bitnum_max < bitnum_min:
            raise ValueError(f"bitnum_max {bitnum_max} cannot be less than bitnum_max {bitnum_min}.")

        if not isinstance(prefix, str):
            raise ValueError(f'Bad prefix: {prefix}. Prefix should be a string.')
        if len(prefix) > 6:
            self.log.warning(f'Prefix: {prefix} is longer than 6 characters making the full label cut off.')

        length = len(prefix) + 1
        if bitnum_max > 9:
            length += 1
        if length > 8:
            if length > 8:
                self.log.warning('Prefix {prefix} too long, will cause label to exceed 8 characters including number!')

        for bit in range(bitnum_min, bitnum_max+1):
            self.write(f'D{bit}:LABEL', f'"{prefix}{bit}"')

    def reset_positions(self):
        """
        Reorient the position of all digital signals to an organized, fixed position.

        Position will depend on current size and number of displayed channels.

        :return: None
        :rtype: None
        """

        size = self.query(f'DIS:DIG:HEI?')
        increment = {'LARGE': 1, 'MEDIUM': 0.5, 'SMALL': 0.25, 'XSMALL': 0.2}[size]

        pos = -4.66
        for bit in range(0, self._channel_num):
            self.write(f'D{bit}:POS', pos)
            pos += increment


class DigitalBit:
    """Class abstracting digital bit functionality of a MSO5000 series oscilloscope. Contains methods that affect a
    singular bit on digital channel.
    """

    def __init__(self, digital, bit):
        self.digital = digital
        self.bit = bit
        self.query = digital.query
        self.write = digital.write
        self.on_off = digital.on_off

    def config(self, display: str = None, threshold: Union[int, float] = None, position: Union[int, float] = None,
               label: str = None) -> Union[dict, None]:
        """
        Configure individual bit from digital input functionality

        :param display: Turn bit ON or OFF on display. Accepts 'ON', 1, or True; 'OFF', 0, False
        :type display: str|int|bool
        :param threshold: Set threshold for bit digital input.
        :type threshold: int|float
        :param position: Change position of bit on scope screen.
        :type position: int|float
        :param label: Give bit a label. Max 8 characters.
        :type label: str
        :return: If all parameters None, then query results as keyword dict of parameter names-values. Otherwise None.
        :rtype: dict|None
        """

        # SELect:D<x> { <NR1> | OFF | ON}
        # D<x>:THRESHold <NR3>
        # D<x>:POSition <NR3>
        # D<x>:LABEL <QString>

        # Readback
        if all(v is None for v in {display, threshold, position, label}):
            return_vals = {}
            return_vals.update(display=self.query(f'SEL:D{self.bit}'))
            return_vals.update(threshold=self.query(f'D{self.bit}:THRESH?'))
            return_vals.update(position=self.query(f'D{self.bit}:POS?'))
            return_vals.update(label=self.query(f'D{self.bit}:LABEL?'))
            return_vals.update()
            return return_vals

        # Parameter checking
        if display is not None:
            if display not in self.on_off.api_values():
                raise ValueError(f'Bad display value: {display}. Valid options: {self.on_off.api_values()}')

        check_range('threshold', threshold, min_max_units(-40, 40, 'Volts'))

        check_range('position', position, min_max_units(-5, 5, 'div'))

        if label is not None:
            if not isinstance(label, str):
                raise ValueError(f'Bad label: {label}. Label should be a string')
            if len(label) > 8:
                self.log.warning('Label can be 8 characters max')

        # Write commands to instrument
        if display is not None:
            self.write(f'SEL:D{self.bit}', display)

        if threshold is not None:
            self.write(f'D{self.bit}:THRESH', threshold)

        if position is not None:
            self.write(f'D{self.bit}:POS', position)

        if label is not None:
            self.write(f'D{self.bit}:LABEL', f'"{label}"')
