from enum import Enum
import struct
import numpy as np  # https://numpy.org/

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.decode_ieee_header import decode_ieee_header


class WaveformData:

    enum_waveform_sources = Enum('enum_waveform_sources', {
        'CH1': 'CH1', 'CH2': 'CH2', 'CH3': 'CH3', 'CH4': 'CH4',
        'MATH1': 'MATH1', 'MATH2': 'MATH2', 'MATH3': 'MATH3', 'MATH4': 'MATH4',
        'REF1': 'REF1', 'REF2': 'REF2', 'REF3': 'REF3', 'REF4': 'REF4'
    })

    def __init__(self, scope, **kwargs):
        self.scope = scope

        # Some local attributes that lets us access these more easily and naturally.
        self.log = self.scope.log
        self.write = self.scope.write
        self.query = self.scope.query
        self.log_inst_errors = self.scope.log_inst_errors
        self.log_unused_args = self.scope.log_unused_args

    def _fetch_waveform(self, source):

        self.scope.write("HEADER 0")

        display_was_off = False
        if not source.name.startswith('CH'):
            # To retrieve MATH or REF waveforms, they have to be displayed or the curve query will fail.
            if not self.query(f'SEL:{source.value}', int):
                display_was_off = True
                self.write(f"SEL:{source.value}", 1)

                # Protects against failure of curve query if MATH or REF waveform is not defined.
                # Workaround lack of a cmd to check existence of waveform.
                if not self.query(f'SEL:{source.value}', int):
                    raise ValueError(f"The source '{source.name}' is currently not defined in the oscope!")

        self.scope.write("DATA:SOUR", f"{source.value}")
        self.scope.write("DAT:ENC SRI")  # Signed Binary Format, LSB order

        data_width_bytes, datatype, is_big_endian = self._get_data_format_parameters(source)

        self.scope.write("WFMO:BYT_N",  f"{data_width_bytes}")

        self.scope.write("DAT:START 1")
        self.scope.write("DAT:STOP 1e10")  # Set data stop to max
        record_length = int(self.scope.query("WFMO:NR_P"))  # Query how many points are actually available
        self.scope.write("DAT:STOP",  f"{record_length}")  # Set data stop to match points available

        # Fetch horizontal scaling factors
        delta_t = float(self.scope.query("WFMO:XINCR"))
        xzero = float(self.scope.query("WFMO:XZERO"))
        pt_off = int(self.scope.query("WFMO:PT_OFF"))
        xunits = self.query('WFMO:XUNI').strip('"')

        # Fetch vertical scaling factors
        ymult = float(self.scope.query("WFMO:YMULT"))
        yzero = float(self.scope.query("WFMO:YZERO"))
        yoff = float(self.scope.query("WFMO:YOFF"))
        yunits = self.query('WFMO:YUNI').strip('"')

        # Fetch waveform data
        self.scope.write("curve?")

        # Data is sent back with ieee defined header.  ie. #41000<binary data bytes>\n

        # This is the simplest way to decode the bytes, but pyro server doesn't like container.
        # PyVISA read_binary_values() method automatically reads and parses the ieee block header for you.
        # unscaled_data = self.scope.rm_handle.read_binary_values(datatype=datatype, is_big_endian=is_big_endian,
        #                                                    container=np.ndarray, header_fmt='ieee',
        #                                                    expect_termination=True)

        # Here's an alternative method
        raw_data = self.scope.read_raw()
        num_bytes, data = decode_ieee_header(raw_data[:len(raw_data)-1])
        num_points = num_bytes//data_width_bytes
        fmt = f"{'>' if is_big_endian else '<'}{num_points}{datatype}"
        unscaled_data = struct.unpack(fmt, data)

        data_len = len(unscaled_data)
        # print(f"data_len={data_len}")

        # Create numpy arrays of floating point values for the X and Y axis
        xvalues = np.ndarray(data_len, np.float)
        yvalues = np.ndarray(data_len, np.float)

        t0 = (-pt_off * delta_t) + xzero
        for i in range(0, data_len):
            xvalues[i] = t0 + delta_t * i  # Create timestamp for the data point
            yvalues[i] = float(unscaled_data[i] - yoff) * ymult + yzero  # Convert raw ADC value into a floating point value

        if display_was_off:
            self.write(f"SEL:{source.value}", 0)

        return t0, delta_t, xvalues, yvalues, xunits, yunits

    def _get_data_format_parameters(self, source):
        source_name = source.name
        if source_name.startswith('CH'):
            acq_mode = self.query('ACQ:MOD:ACTU')
            if acq_mode.startswith(('HIRES', 'AVE')):
                width = 2
            else:
                width = 1
        elif source_name.startswith('MATH'):
            width = 4
        elif source_name.startswith('REF'):
            # REF waveform data points that come from a MATH<x> are 4 bytes (float).
            # But, REF from a CH<x> seem to always be 1 byte, even if they are HIRES or AVE.
            width = self.query('DATA:WID', int)
        else:
            # This should never happen as caller has already checked this.
            check_enum_str('source', source, self.enum_waveform_sources)  # This will raise the exception.

        is_big_endian = False
        if width == 1:
            datatype = 'b'   # aka 'signed char' 1 byte
        elif width == 2:
            datatype = 'h'   # aka 'short' 2 byte signed int
        elif width == 4:
            width = 4
            datatype = 'f'  # aka 32-bit float
            is_big_endian = True

        # print(f"source={source_name} {width} {datatype}")

        return width, datatype, is_big_endian

    def read_waveforms(self, sources, max_acq_time_ms=2000):
        """
        Starts a new acquisition, and when complete, reads one or more waveforms from the oscope and returns a dict
        containing the xvalues and yvalues for each of the specified waveform sources.

        If multiple sources are specified, the output contains a separate pair of xvalues, yvalues for
        each source. This is done despite the fact that CH<x> sources share a common timescale, because the x-axis for
        MATH<x> or REF<x> sources may be different. Consider a MATH operation that generates a frequency spectrum or a
        REF waveform that was captured using a timescale different from the current setting.

        :param sources: Either a single source specifier, e.g. 'CH1', or a list of sources, e.g.
            ['CH1', 'CH4', 'MATH1', 'REF1']. The set of allowed source specifiers may differ depending on scope model.
            To display the list, do read_waveforms.enum_waveform_sources.<tab> in the Console.
        :type sources: str|enum_waveform_sources
        :param max_acq_time_ms: Time limit on polling the oscope BUSY status to determine when the acquisition
            is complete. An exception is raised if acquisition does not complete before this time limit expires.
            Defaults to 2000ms, but you may need to set this longer when using slow sample rates and/or large record
            sizes.
        :type max_acq_time_ms: int|float
        :return: A dict of dicts, the outer set of keys being the specified sources. The value associated with each
            source key is in turn a dict containing the keys 'xvalues' and 'yvalues'. The values associated with these
            are 1D numpy ndarrays. Pass these to the python list method to obtain an ordinary python list.
        :rtype: Dict[str, Dict[str, ndarray]]
        """

        # Allow for source to be a single source (str or enum) or a list of sources (str or enum).
        was_list = True
        if not isinstance(sources, list):
            sources = [sources]
            was_list = False

        fastacq_enb = self.query('FASTA:STATE', int)
        acq_mode = self.query('ACQ:MOD:ACTU')
        env_mode_enb = True if acq_mode.startswith('ENV') else False
        wfdb_mode_enb = True if acq_mode.startswith('WFM') else False

        # Check for invalid sources, converts any str to enum.
        element_name = 'sources'
        for i, source in enumerate(sources):
            if was_list:
                element_name = f"sources[{i}]"  # Makes error message more descriptive.
            sources[i] = check_enum_str(element_name, sources[i], self.enum_waveform_sources)
            if sources[i].name.startswith('CH'):
                if fastacq_enb:
                    raise ValueError(f"Waveform time series data cannot be captured with FastAcq mode enabled.\n"
                                     f"FastAcq produces a pixel map which this code is not written to handle.")
                if wfdb_mode_enb:
                    raise ValueError(f"Waveform time series data cannot be captured using acquisition mode WFMDB.\n"
                                     f"WFMDB produces a pixel map which this code is not written to handle.")
                if env_mode_enb:
                    raise ValueError(f"Waveform time series data cannot be captured using acquisition mode Envelope.\n"
                                     f"Envelope produces min-max pairs this code is not written to handle.")

        # Run the acquisition and wait for it to complete.
        self.write('ACQ:STATE', 'ON')
        complete = self.scope.wait_for_operation_complete(max_acq_time_ms)
        if not complete:
            raise ValueError(f"Acquisition still not complete after {max_acq_time_ms}ms. Try increasing the "
                             f"wait_time_ms parameter or check the oscope acquisition and triggering setups.")

        # Fetch each waveform in turn, build return dict keyed by source names.
        return_dict = {}
        for source in sources:
            _, _, xvalues, yvalues, xunits, yunits = self._fetch_waveform(source)
            return_dict.update({source.name: {'xvalues': xvalues, 'xunits': xunits, 'yvalues': yvalues,
                                              'yunits': yunits}})

        return return_dict
