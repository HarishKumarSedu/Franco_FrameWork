from pathlib import PureWindowsPath, Path

class Setup:
    def __init__(self, scope, **kwargs):
        self.scope = scope

        # Some local attributes that lets us access these more easily and naturally.
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args

        # Define default scope location used save_to_pc_file and recall_from_pc_file.
        self.scope_temp_dir = ''
        self.config(scope_temp_dir="C:/Users/Public/Tektronix/TekScope/setups")

    def recall_from_scope_file(self, scope_dir, filename):
        """
        Restores the TekScope application to the state obtained from a .set file in the oscope filesystem.

        :param scope_dir: The full path to the directory in the scope filesystem where the setup file is located. Use
            forward slashes or Python raw string ('r' prefix) to avoid unintended interpretation of backslashes as
            escape sequences.
        :type scope_dir: str
        :param filename: The name of the setup file to be used. Must include the suffix '.set' or '.SET'.
        :type filename: str
        """

        # RECAll:SETUp {FACtory|<NR1>|<file path>}

        p = PureWindowsPath(filename)
        suffix = p.suffix.upper()
        if suffix != '.SET':
            raise ValueError(f"Bad filename '{filename}' suffix '{suffix}', must be '.set' or '.SET'.")

        # Note that the RECAll:SETUp command requires the full path, we can't use CWD to direct where the output goes.
        # In addition there is a limit of 128 characters on the full path, including the filename. Argh!
        pwp = PureWindowsPath(scope_dir, filename)  # combine the dir and the filename
        path = pwp.as_posix()  # gets us single forward slashes '/' instead of the double backslashes '\\'.

        print(f"Combined scope_dir and path length={len(path)}")

        # if len(path) > 127:
        #     raise ValueError(f"Scope limit of 128 characters exceeded for path '{path}'. Try a shorter "
        #                      "scope_dir and/or filename.")

        exists = self.scope.filesystem.is_scope_dir(scope_dir)
        if not exists:
            raise ValueError(f"Bad scope_dir '{scope_dir}', does not exist in the scope filesystem.")

        old_cwd = self.scope.filesystem.cwd()  # Use this to put cwd back the way we found it.
        self.scope.filesystem.cwd(scope_dir)
        tmp = self.query('FILES:DIR', str).split(',')
        self.scope.filesystem.cwd(old_cwd)

        scope_dir_contents = [f.strip('"') for f in tmp if f not in ('"."', '".."')]
        if filename not in scope_dir_contents:
            raise ValueError(f"Bad filename '{filename}', doesn't exist in scope_dir '{scope_dir}'.")

        self.write('RECA:SETU', f'"{path}"')
        self.query('*OPC?', bool)
        self.log_inst_errors()

    def recall_from_memory(self, mem_location):
        """
        Restores the TekScope application to the state obtained from one of the memory locations.

        :param mem_location: Identifier of the TekScope memory location. 1 to 10.
        :type mem_location: int
        """

        # RECAll:SETUp {FACtory|<NR1>|<file path>}

        if mem_location not in range(1, 11):
            raise ValueError(f"Bad mem_location {mem_location}, must be int from 1 to 10.")

        self.write('RECA:SETU', mem_location)
        self.query('*OPC?', bool)
        self.log_inst_errors()

    def save_to_scope_file(self, scope_dir, filename, create_scope_dir=False):
        r"""
        Saves the current state of the scope to the specified directory and filename in the *oscope* filesystem. These
        files can later be copied to the PC later using filesystem.scope_files_to_pc using binary transfer mode.

        :param scope_dir: Directory in oscope where file will be created. Note: use r (raw) string or use '/' to avoid
            parts of your path string being mistaken for an escape sequence (e.g. \\n).
        :type scope_dir: str
        :param filename: The filename including the suffix '.set' or '.SET'. No other suffix is allowed.
        :type filename: str
        :param create_scope_dir: If scope_dir does not exist and create_scope_dir is True, the directory will be created
            in the scope filesystem. Defaulted to false to prevent a typo in scope_dir from re-directing the file to
            some new random place.
        :type create_scope_dir: bool
        """

        # SAVe:SETUp {<file path>|<NR1>}

        p = PureWindowsPath(filename)
        suffix = p.suffix.upper()
        if suffix != '.SET':
            raise ValueError(f"Bad file name '{filename}' suffix '{suffix}', must be '.set' or '.SET'.")

        # Note that the SAV:SETU command requires the full path, we can't use CWD to direct where the output goes.
        # In addition there is a limit of 128 characters on the full path, including the filename. Argh!
        pwp = PureWindowsPath(scope_dir, filename)  # combine the dir and the filename
        path = pwp.as_posix()  # gets us single forward slashes '/' instead of the double backslashes '\\'.

        print(f"Combined scope_dir and path length={len(path)}")

        # if len(path) > 127:
        #     raise ValueError(f"Scope limit of 128 characters exceeded for path '{path}'. Try a shorter "
        #                      "scope_dir and/or filename.")

        exists = self.scope.filesystem.is_scope_dir(scope_dir)
        if not exists:
            if create_scope_dir:
                self.scope.filesystem.create_scope_path(scope_dir)
                self.log.info(f"Scope dir '{scope_dir}' did not exist, created it.")
            else:
                raise ValueError(f"Bad scope_dir '{scope_dir}', does not exist in the scope filesystem. Set "
                                 f"create_scope_dir=True to force creation of directories.")

        self.write('SAV:SETU', f'"{path}"')
        self.query('*OPC')       # On MSO456 models SAV:SETU is an OPC generating cmd. Doesn't hurt on 5000 series.
        self.log_inst_errors()

    def save_to_memory(self, mem_location):
        """
        Saves the current state of the TekScope application to a memory location.

        :param mem_location: Identifier of the TekScope memory location. 1 to 10.
        :type mem_location: int
        """

        # SAVe:SETUp {<file path>|<NR1>}

        if mem_location not in range(1, 11):
            raise ValueError(f"Bad mem_location {mem_location}, must be int from 1 to 10.")

        self.write('SAV:SETU', mem_location)
        self.log_inst_errors()

    def restore_factory(self):
        """Restores the instrument to its factory default settings."""

        # RECAll:SETUp {FACtory|<NR1>|<file path>}

        self.write('RECA:SETU', 'FAC')
        self.query('*OPC?', bool)
        self.log_inst_errors()

    # Seems like most frequently used would be these...?

    def save_to_pc_file(self, pc_dir, filename, create_pc_dir=False):
        """
        Saves the current state of the oscope into a '.set' file on the PC.

        As a convenience this combines two operations: saving the setup to the scope filesystem in a scratch file and
        then copying that file to pc_dir and renaming it to filename. These two steps are a consequence of the fact
        that the scope only provides a SCPI command to save a setup to its own filesystem. The oscope dir used for the
        scratch file is defined in the class attribute scope_temp_dir. See the config method for the means to modify
        scope_temp_dir.

        :param pc_dir:
        :type pc_dir:
        :param filename:
        :type filename:
        :param create_pc_dir:
        :type create_pc_dir:
        """

        # Uses some scratch dir in scope, use config to define alter.
        # Combo of save_to_scope_file and filesystem.scope_files_to_pc.
        # Do we need clobber protection?
        # Do we want to enforce that filename has .set suffix?

        p = Path(filename)
        suffix = p.suffix.upper()
        if suffix != '.SET':
            raise ValueError(f"Bad file name '{filename}' suffix '{suffix}', must be '.set' or '.SET'.")

        # Using scratchfile avoids cluttering up the scope with lot sof files.
        scratch_file = 'scratchfile.set'
        self.save_to_scope_file(self.scope_temp_dir, scratch_file, create_scope_dir=True)
        self.scope.filesystem.scope_files_to_pc(self.scope_temp_dir, scratch_file, pc_dir, mode='b',
                                                create_pc_dir=create_pc_dir)

        # Rename the file on the PC.
        pc_path = Path(pc_dir, scratch_file)
        target = Path(pc_dir, filename)
        pc_path.replace(target)

        self.log_inst_errors()

    def recall_from_pc_file(self, pc_dir, filename):
        """
        Recalls the oscope setup from the specified file on  the PC.

        As a convenience this combines two operations: copying the setup file from the PC to the scope filesystem in a
        scratch directory and recalling the setup from that file. These two steps are a consequence of the fact
        that the scope only provides a SCPI command to recall a setup from its filesystem. The oscope dir used for the
        scratch file is defined in the class attribute scope_temp_dir. This location can be modified if need be through
        the config method.

        :param pc_dir:
        :type pc_dir:
        :param filename:
        :type filename:
        """

        # Uses some scratch dir in scope, use config to define alter.
        # Combo of pc_files_to_scope and recall_from_scope_file.
        # Do we want to enforce that filename has .set suffix?

        p = Path(filename)
        suffix = p.suffix.upper()
        if suffix != '.SET':
            raise ValueError(f"Bad file name '{filename}' suffix '{suffix}', must be '.set' or '.SET'.")

        self.scope.filesystem.pc_files_to_scope(pc_dir, filename, self.scope_temp_dir, mode='b', create_scope_dir=True)
        self.recall_from_scope_file(self.scope_temp_dir, filename)

    def config(self, scope_temp_dir=None):
        """
        Allows redefining the temp directory used for save_to_pc_file and recall_from_pc_file.

        :param scope_temp_dir: Defaults to *'C:/Users/Public/Tektronix/TekScope/setups'*. The methods save_to_pc_file
            and recall_from_pc_file use scope_temp_dir for scratch files used to move setups to and from the PC.
            Ordinarily, there would be no reason to change scope_temp_dir from this default. The ability to change it
            may be useful to workaround to some unforeseen problem. Use forward slashes or Python raw string
            ('r' prefix) to avoid unintended interpretation of backslashes as escape sequences.
        :type scope_temp_dir: str
        """

        if scope_temp_dir is None:
            return {'scope_temp_dir': self.scope_temp_dir}

        if not self.scope.filesystem.is_scope_dir(scope_temp_dir):
            self.scope.filesystem.create_scope_path(scope_temp_dir)
            self.log.info(f"Created new setup.scope_temp_dir that didn't previously exist: '{scope_temp_dir}'.")

        if not self.scope.filesystem.is_writable_dir(scope_temp_dir):
            raise ValueError(f"Bad scope_temp_dir'{scope_temp_dir}', could not be created or is not writable."
                             f"Previous setup.scope_temp_dir '{self.scope_temp_dir}' remains in effect.")

        self.scope_temp_dir = scope_temp_dir
