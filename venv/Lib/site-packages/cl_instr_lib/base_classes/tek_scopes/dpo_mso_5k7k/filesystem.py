from pathlib import Path, PureWindowsPath
import fnmatch

from pyvisa.constants import StatusCode

class Filesystem:
    """Provides methods for manipulating the oscilloscope filesystem via the GPIB or USB connection.."""

    def __init__(self, scope, **kwargs):
        self.scope = scope

        # Some local attributes that lets us access these more easily and naturally.
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.on_off = scope.on_off
        self.log_inst_errors = scope.log_inst_errors
        self.get_inst_errors = scope.get_inst_errors
        self.log_unused_args = scope.log_unused_args

    def cwd(self, oscope_dir=None):
        """
        Queries or sets the oscope Current Working Directory (CWD). Raises ValueError if oscope_dir is not valid.

        :param oscope_dir: If None query is performed and result returned. Providing a valid path to a directory in the
            oscope causes scope current Working Directory (CWD) to be changed to the new path.
        :type oscope_dir: None | str
        :return: Query returns present CWD directory path.
        :rtype: str | None
        """

        # FILESystem:CWD {<new working directory path>}

        if oscope_dir is None:
            return self.query('FILES:CWD', str).strip('"')
        else:
            self.get_inst_errors()
            self.write("FILES:CWD", f'"{oscope_dir}"')
            errors = self.get_inst_errors()
            if len(errors) > 0:
                raise ValueError(f"Could not set oscope CWD to '{oscope_dir}'.")

        # Omitted log_inst_errors here since we called get_inst_errors already.

    def scope_files_to_pc(self, scope_dir, filenames, pc_dir, create_pc_dir=False, mode='b', read_timeout_ms=None):
        """
        Copies specified files from a directory on the oscilloscope filesystem into a directory on the PC over the GPIB
        or USB connection.

        If the target directory does not exist on the PC, an exception will be raised unless create_pc_dir is True.
        *Note that files are not renamed in the process of copying, so existing files of the same name in pc_dir will
        be clobbered!*

        :param scope_dir: The full path to the directory in the scope filesystem where the files to be copied are
            located. Use forward slashes or Python raw string ('r' prefix) to avoid unintended interpretation of
            backslashes as escape sequences.
        :type scope_dir: str
        :param filenames: Three possibilities: a literal string that is the filename to be copied, or a glob style
            wildcard (i.e. '\*.png'), or a list of literal filename strings. If no matching files are found in
            scope_dir, a ValueError is raised.
        :type filenames: str | List[str]
        :param pc_dir: Directory path on PC where the files are to be placed. Use forward slashes or Python raw string
            ('r' prefix) to avoid unintended interpretation of backslashes as escape sequences. If the directory does
            not already exist, a ValueError will be raised unless create_pc_dir is True.
        :type pc_dir: str
        :param mode: Defaults to 'b', binary mode which should be used for images. Set to 't', text mode for ASCII
            files.
        :type mode: str
        :param create_pc_dir: Defaults to False. If True and pc_dir does not exist, it will be created on the PC.
        :type create_pc_dir: bool
        :param read_timeout_ms: If not None, Visa timeout is set to this value for the copy operation(s) and then
            restored value to its previous value. Usually not needed but may be useful if problems are encountered.
        :type read_timeout_ms: None|numeric
        """

        # FILESystem:DIR?
        # FILESystem:READFile <filepath>
        # FILESystem:DELEte       # Didn't implement.

        # GPIB transfer of file data, create copy in PC file system, then optional delete.

        mode = mode.lower()
        if mode not in ('b', 't'):
            raise ValueError(f"Bad mode {mode}, should be 'b' or 't'.")

        old_cwd = self.cwd()  # Use this to put cwd back the way we found it.

        if not self.is_scope_dir(scope_dir):
            self.cwd(old_cwd)
            raise ValueError(f"Bad scope_dir '{scope_dir}', does not exist in scope file system.")

        self.cwd(scope_dir)  # Because scope FILES:DIR operates on the CWD of the scope.

        # Since we can't do any file globbing / filtering on the scope side, get a full list of files in scope_dir.
        # TODO: Optimize for case of a literal filename - then we don't need to pull the whole dir listing. Instead
        #  check for error on self.write('FILES:READF', '"FOOBAR"').

        tmp = self.query('FILES:DIR', str).split(',')
        scope_dir_contents = [f.strip('"') for f in tmp if f not in ('"."', '".."')]
        num_scope_files = len(scope_dir_contents)

        # Apply globbing / filtering to the list.
        if isinstance(filenames, str):
            # A single name or a glob pattern.
            scope_matching_files = fnmatch.filter(scope_dir_contents, filenames)
            num_match = len(scope_matching_files)
            if num_match == 0:
                self.cwd(old_cwd)
                raise RuntimeError(f"No scope files found in scope_dir '{scope_dir}' ({num_scope_files} files) that "
                                   f"match glob pattern: '{filenames}'.")
        elif isinstance(filenames, list):
            scope_matching_files = [f for f in filenames if f in scope_dir_contents]
            num_match = len(scope_matching_files)
            if num_match == 0:
                self.cwd(old_cwd)
                raise RuntimeError(f"No scope files found in scope_dir '{scope_dir}' ({num_scope_files} files) that "
                                   f"are among the {len(filenames)} in the filenames list.")
            num_requested = len(filenames)
            if num_match != num_requested:
                self.log.warn(f"Of the {num_requested} files requested, only {num_match} exist in '{scope_dir}'.")
        else:
            self.cwd(old_cwd)
            raise ValueError(f"Bad filenames '{filenames}'. Should be a literal string, a glob pattern or a list of "
                             f"literal strings.")

        # See if the directory on the PC exists, if not create it if user specified that option.
        pc_path = Path(pc_dir)
        if not pc_path.exists():
            if not create_pc_dir:
                self.cwd(old_cwd)
                raise ValueError(f"Bad pc_dir '{str(pc_path)}', does not exist. Use create_pc_dir to force automatic "
                                 "creation of a missing directory path.")
            pc_path.mkdir(parents=True)
            self.log.info(f"Specified pc_dir '{pc_dir}', did not exist, creating it per create_pc_dir==True.")
        elif not pc_path.is_dir():
            self.cwd(old_cwd)
            raise ValueError(f"Bad pc_dir '{str(pc_path)}', final element is not a directory, perhaps a file?")

        timeout_prev = self.scope.rm_handle.timeout   # Do always to avoid PyCharm warning later.
        if read_timeout_ms is not None:
            self.scope.rm_handle.timeout = read_timeout_ms

        # Finally, do the actual copy operation.
        for filename in scope_matching_files:
            self.write('FILES:READF', f'"{filename}"')
            if mode == 'b':
                data = self.scope.read_raw()
            else:
                data = self.scope.rm_handle.read()
            p = pc_path / filename
            with open(p, 'w' + mode) as f:
                f.write(data)

            x = PureWindowsPath(scope_dir, filename)
            self.log.info(f"Oscope file '{x.as_posix()}' copied to pc_dir: '{pc_path}'.")

        if read_timeout_ms is not None:
            self.scope.rm_handle.timeout = timeout_prev

        self.cwd(old_cwd)

        self.get_inst_errors()

    def is_scope_dir(self, dir_path):
        """
        Check if dir_path exists in the oscope file system. Oscope Current Working Directory (CWD) is restored to
        what it was before this method was called.

        :param dir_path: a complete directory path, must not end with a filename.
        :type dir_path: str
        :return: True if directory exists.
        :rtype: bool
        """

        # FILESystem:CWD {<new working directory path>}

        path = PureWindowsPath(dir_path)

        # Try setting cwd to the entire path. If that succeeds, all elements are directories that already exist.

        old_cwd = self.cwd()
        self.get_inst_errors()  # Clear the error queue
        self.write('FILES:CWD', f'"{str(path)}"')
        errors = self.get_inst_errors()  # This doesn't raise, so we are guaranteed to proceed to next statement which
        # puts cwd back.

        self.cwd(old_cwd)

        if len(errors) == 0:
            return True
        else:
            return False

    def create_scope_path(self, dir_path):
        """
        Check if the given directory path exists in the oscope filesystem and if it does not create it. This creates
        all intermediate missing directories as well.

        :param dir_path: A directory path that either completely or partially exists.
        :type dir_path: str
        """

        # FILESystem:CWD {<new working directory path>}
        # FILESystem:MKDir <directory path>

        # We use PureWindowsPath because we are working with paths of the scope as opposed to those of the PC.
        # PureWindowsPath does no system calls so it cannot alter the PC filesystem.
        # To access the scope filesystem, we have to use SCPI commands.

        cwd_prev = self.cwd()

        path = PureWindowsPath(dir_path)

        # OK, something is missing...try piece by piece..create the missing directories.
        self.get_inst_errors()   # Clear the error queue
        for i, part in enumerate(path.parts):
            self.write('FILES:CWD', f'"{str(part)}"')
            errors = self.get_inst_errors()
            if len(errors) > 0:
                if i == 0:
                    self.cwd(cwd_prev)
                    raise ValueError(f"Bad path '{dir_path}', could not CWD to the anchor portion '{part}'. "
                                     "Should be a '<drive>:\\'.")
                else:
                    self.write('FILES:MKDIR', f'"{str(part)}"')
                    errors = self.get_inst_errors()
                    if len(errors) > 0:
                        self.cwd(cwd_prev)
                        raise ValueError(f"Couldn't create directory '{part}', (element {i} in path '{dir_path})'. "
                                         f"There may already be a file of the same name in that location.")
                    self.write('FILES:CWD', f'"{str(part)}"')

        self.cwd(cwd_prev)

    def is_writable_dir(self, oscope_dir):
        """
        Determines if a directory on in the scope filesystem is writable by creating a test file, 'WRTTST.txt', in the
        specified directory and then deleting it.

        :param oscope_dir: The oscope directory to be tested for write-ability.
        :type oscope_dir: str, must be a full directory path including drive letter.
        :return: True if directory exists and is writable.
        :rtype: bool
        """
        path = PureWindowsPath(oscope_dir, 'WRTTST.txt').as_posix()

        self.write('FILES:WRITEF', f'"{path}", #0Oscope driver wrote this to confirm that this directory was '
                                   f'writable. It should have automatically deleted this file!')
        errors = self.get_inst_errors()
        if len(errors) > 0:
            return False

        self.write('FILES:DELE', f'"{path}"')

        return True

    def pc_files_to_scope(self, pc_dir, filenames, scope_dir, mode='b', create_scope_dir=False):
        """
        Copies specified files from a directory on the PC into a directory on the oscilloscope filesystem over the GPIB
        or USB connection.

        If the target directory does not exist on the scope, an exception will be raised unless create_scope_dir is
        True. *Note that files are not renamed in the process of copying, so existing files of the same name in
        scope_dir will be clobbered!*

        :param pc_dir: The full path to the directory in the PC filesystem where the files to be copied are
            located. Use forward slashes or Python raw string ('r' prefix) to avoid unintended interpretation of
            backslashes as escape sequences.
        :type pc_dir: str
        :param filenames: Three possibilities: a literal string that is the filename to be copied, or a glob style
            wildcard (i.e. '\*.png'), or a list of literal filename strings. If no matching files are found in
            pc_dir, a ValueError is raised.
        :type filenames: str | List[str]
        :param scope_dir: The destination in the scope filesystem for the copied files.  If the directory does
             not already exist, a ValueError will be raised unless create_scope_dir is True.
        :type scope_dir: dir
        :param mode: Defaults to 'b', binary mode which should be used for non-text files. Set to 't', text mode for
            ASCII files.
        :type mode: str
        :param create_scope_dir: If set to True, scope_dir will be created if it does not already exist.
        :type create_scope_dir: bool
        """

        mode = mode.lower()
        if mode not in ('b', 't'):
            raise ValueError(f"Bad mode {mode}, should be 'b' or 't'.")

        # See if the directory on the PC exists.
        pc_path = Path(pc_dir)
        if not pc_path.exists() or not pc_path.is_dir():
            raise ValueError(f"Bad pc_dir '{str(pc_path)}', final element is not a directory, perhaps a file?")

        # Determine which files to copy.
        if isinstance(filenames, str):
            pc_matching_paths = list(pc_path.glob(filenames))
            num_match = len(pc_matching_paths)
            if num_match == 0:
                raise RuntimeError(f"No files found in pc_dir '{pc_dir}' that match glob pattern: '{filenames}'.")
        elif isinstance(filenames, list):
            # pc_matching_paths = [f for f in filenames if Path(pc_dir, f).is_file()]
            pc_matching_paths = []
            for filename in filenames:
                p = Path(pc_dir, filename)
                if p.is_file():
                    pc_matching_paths.append(p)
            num_match = len(pc_matching_paths)
            num_requested = len(filenames)
            if num_match != num_requested:
                raise RuntimeError(f"Of the {num_requested} files requested, only {num_match} exist in '{pc_dir}'.")
        else:
            raise ValueError(f"Bad filenames '{filenames}'. Should be a literal string, a glob pattern or a list of "
                             f"literal strings.")

        if not self.is_writable_dir(scope_dir):
            if not create_scope_dir:
                raise ValueError(f"Destination scope_dir '{scope_dir}' does not exist, set create_scope_dir=True to "
                             "force creation of scope_dir.")
            else:
                self.create_scope_path(scope_dir)

        for p in pc_matching_paths:

            with open(p, 'r' + mode) as file_handle:
                data = file_handle.read()

            length = len(data)
            print(f"length={length}")

            # Turn off termination so we can send large files in chunks. This is to get around limitation of
            # FILES:WRITEF; attempting to send more than 262125 bytes in one transaction causes error 161, "premature
            # termination".

            self.scope.rm_handle.write_termination = None
            self.scope.rm_handle.send_end = False

            scope_path = PureWindowsPath(scope_dir, p.name).as_posix()
            length = len(data)
            # print(f"length={length}")
            num_digits = len(str(length))
            self.scope.write(f'FILES:WRITEF "{scope_path}", #{num_digits}{length}')

            chunk_size = 200000
            num_chunks = length // chunk_size + (length % chunk_size > 0)
            num_written = 0
            for i in range(0, num_chunks):
                first = i * chunk_size
                last = min((i+1)*chunk_size, length)
                if i == (num_chunks - 1):
                    # Special termination for last chunk of an "ARBITRARY BLOCK PROGRAM DATA" transaction.
                    self.scope.rm_handle.write_termination = '\n'
                    self.scope.rm_handle.send_end = True
                count, success = self.scope.write_raw(data[first:last])
                if success == StatusCode.success:
                    num_written += count
                else:
                    self.scope.rm_handle.write_termination = '\r\n'  # Back to normal SCPI command termination.
                    self.scope.rm_handle.send_end = True
                    raise RuntimeError(f"A write_raw failure occurred while writing file {p.name} (chunk {i+1}) "
                                       "to the scope.")

            # print(f"num_written={num_written}")

            if num_written != length:
                self.scope.rm_handle.write_termination = '\r\n'  # Back to normal SCPI command termination.
                self.scope.rm_handle.send_end = True
                raise RuntimeError(f"Copying file '{p}' to scope incomplete, only {num_written} of {length} bytes "
                                   "was written.")

            self.log.info(f"File '{p}' copied to scope path: '{scope_path}', {length} bytes.")

            # Back to normal SCPI command termination.
            self.scope.rm_handle.write_termination = '\r\n'
            self.scope.rm_handle.send_end = True

        self.log_inst_errors()



