from enum import Enum

from cl_instr_lib.helpers.check_enum_str import check_enum_str

class Measurements_5k_7k:
    """Provides methods to configure measurements and retrieve measurement data."""

    def __init__(self, scope, **kwargs):
        self.scope = scope

        # Some local attributes that lets us access these more easily and naturally.
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.on_off = scope.on_off
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args

        self.enum_meas_sources = Enum('enum_meas_sources', {
            'CH1': 'CH1', 'CH2': 'CH2', 'CH3': 'CH3', 'CH4': 'CH4',
            'M1': 'MATH1', 'M2': 'MATH2', 'M3': 'MATH3', 'M4': 'MATH4',
            'R1': 'REF1', 'R2': 'REF2', 'R3': 'REF3', 'R4': 'REF4',
            'HISTO': 'HISTOGRAM'
        })

        self.enum_meas_ampl = Enum('enum_meas_ampl', {
            'AMPL': 'AMPLITUDE',
            'RMS': 'RMS',
            'MAX': 'MAXIMUM',
            'ACRMS': 'ACRMS',
            'HIGH': 'HIGH',
            'MIN': 'MINIMUM',
            'PKPK': 'PK2PK',
            'LOW': 'LOW',
            'CYCRMS': "CRMS",
            'MEAN': 'MEAN',
            'POVRSHT': 'POVERSHOOT',
            'NOVRSHT': 'NOVERSHOOT',
            'CYMEAN': 'CMEAN'
        })
        self.enum_meas_time = Enum('enum_meas_time', {
            'RISE': 'RISE',
            'POSWID': 'PWIDTH',
            'PERIOD': 'PERIOD',
            'FALL': 'FALL',
            'NEGWID': 'NWIDTH',
            'FREQ': 'FREQ',
            'PDTYCYC': 'PDUTY',
            'NDTYCYC': 'NDUTY',
            'DELAY': 'DELAY'
        })
        self.enum_meas_more = Enum('enum_meas_more', {
            'AREA': 'AREA',
            'BRSTWID': 'BURST',
            'CYAREA': 'CAREA',
            'PHASE': 'PHASE'
        })
        self.enum_meas_histog = Enum('enum_meas_histog', {
            'WFMS': 'WAVEFORMS',
            'MEDIAN': 'MEDIAN',
            'PKPK': 'PK2PK',      #
            'HITS': 'HITS',
            'MAX': 'MAXIMUM',      #
            'MEAN': 'MEAN',        #
            'PEAKHITS': 'PEAKHITS',
            'MIN': 'MINIMUM',      #
            'STDDEV': 'STDDEV',
            'SIGMA3': 'SIGMA3',
            'SIGMA1': 'SIGMA1',
            'SIGMA2': 'SIGMA2'
        })
        self.enum_meas_comm = Enum('enum_meas_comm', {
             'EXTINC_RATIO': 'EXTINCTRATIO',
             'EXTINC_PCT':   'EXTINCTPCT',
             'EXTINCT_DB': 'EXTINCTDB',
             'EYE_HEIGHT': 'EYEHEIGHT',
             'EYE_WIDTH': 'EYEWIDTH',
             'EYE_TOP': 'PTOP',
             'EYE_BASE': 'PBASE',
             'CROSSING_PCT': 'PCTCROSS',
             'JIT_PKPK': 'PKPKJITTER',
             'JIT_RMS': 'RMSJITTER',
             'JIT_SIXSIGMA': 'SIXSIGMAJIT',
             'NOISE_PKPK': 'PKPKNOISE',
             'NOISE_RMS': 'RMSNOISE',
             'SN_RATIO': 'SNRATIO',
             'CYC_DIST': 'DISTDUTY',
             'QFACTOR': 'QFACTOR'
        })

        self.enum_meas_undefined = Enum('enum_meas_undefined', {'UNDEFINED': 'UNDEFINED'})

        self.enum_delay_edge = Enum('enum_delay_edge', {'RISE': 'RISE', 'FALL': 'FALL'})
        self.enum_delay_direction = Enum('enum_delay_direction', {'BACKWARDS': 'BACKWARDS', 'FORWARDS': 'FORWARDS'})
        self.enum_reflevel_units = Enum('enum_reflevel_units', {'ABSOLUTE': 'ABSOLUTE', 'PERCENT': 'PERCENT'})
        self.enum_gating_type = Enum('enum_gating_type', {
            'OFF': 'OFF', 'CURSOR': 'CURSOR', 'ZOOM1': 'ZOOM1', 'ZOOM2': 'ZOOM2', 'ZOOM3': 'ZOOM3', 'ZOOM4': 'ZOOM4'
        })
        self.enum_base_top_from = Enum('enum_base_top_from', {
            'MINMAX': 'MINMAX',
            'HISTOGRAM': 'HISTOGRAM',
            'MEAN': 'MEAN'
        })
        self.enum_stats_mode = Enum('enum_stats_mode', {
            'OFF': 'OFF',
            'ALL': 'ALL',
            'VALUEMEAN': 'VALUEMEAN',
            'MINMAX': 'MINMAX',
            'MEANSTD': 'MEANSTDDEV'
        })
        self.enum_annotation_select = Enum('enum_annotation_select', {
            'OFF': 'OFF',
            'MEAS1': 'MEAS1', 'MEAS2': 'MEAS2', 'MEAS3': 'MEAS3', 'MEAS4': 'MEAS4',
            'MEAS5': 'MEAS5', 'MEAS6': 'MEAS6', 'MEAS7': 'MEAS7', 'MEAS8': 'MEAS8'
        })

    # TODO: Do we need to add histogram controls?

    def all_reflevels(self, base_top_from=None, high=None, low=None, mid=None, mid2=None, units=None):
        """
        Query or set the reference levels for **all** measurements: of **both** the immediate variety and those of the
        8 periodic measurement slots.

        **Note:** To independently set reflevels for just the immed measurement, use immed_reflevels. To independently
        set reflevels for any of the 8 periodic measurement slots, use meas_reflevels.

        :param base_top_from: Sets method used to determine the 0% and 100% reference levels. Choices are:

            HISTOGRAM
                The most frequently occurring values above and below the midpoint are used for the 100% and 0%
                levels respectively. Best for pulses, ignores short-term aberrations like overshoot and ringing.
            MEAN
                The mean of all values above and the mean of all values below the midpoint are used for for the 100%
                and 0% levels respectively. Best for eye patterns.
            MINMAX
                Uses the highest and lowest values of the entire waveform record for the 100% and 0% values. Best when
                waveform has no sustained flat portions, like a sine or triangle wave.

        :type base_top_from: None|str|enum_base_top_from
        :param high: Upper level used in RISE and FALL measurements. Expressed as a %  of base_top or a voltage,
            see units parameter.
        :type high: float
        :param low: Lower level used in RISE and FALL measurements. Expressed as a %  of base_top or a voltage,
            see units parameter.
        :type low: float
        :param mid: Midpoint reference (mid1) for the "from" waveform used in PERIOD, FREQ, DELAY, and all cyclic
            measurements. Expressed as a % of base_top or a voltage, see units parameter.
        :type mid: float
        :param mid2: Midpoint reference (mid2) for the "to" waveform used in PERIOD, FREQ, DELAY, and all cyclic
            measurements. Expressed as a % of base_top or a voltage, see units parameter.
        :type mid2: float
        :param units: Determines if high, low, mid, mid2 values are interpreted as percentages of base_top or
            as absolute voltage values. 'PERCENT' or 'ABSOLUTE'.
        :type units: None|str|enum_reflevel_units
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        slot_str = ''
        return_values = self._reflevels(slot_str, base_top_from, high, low, mid, mid2, units)

        if return_values is not None:
            return return_values    # Query results.

        self.log_inst_errors()      # Making error report come from this method for easier debug.

    def meas_annotation(self, select=None):
        """
        Query or set state of Annotation, which consists of markers in the waveform display showing where the
        measurement is being made.

        Note that if a currently annotated measurement is cleared (by meas_clear or in the GUI), the scope moves
        annotation to another slot containing a defined measurement. A meas_annotation query will reflect this.

        :param select: Selects 'OFF" or one of the 8 measurement slots using the form 'MEAS<x>' where <x> is 1
            through 8. Note that MEAS<x> must correspond to a measurement slot that has been configured with a
            measurement (see meas_setup) or an exception will be raised.
        :type select: None|str|enum_annotation_select
        :return: If no input parameters are specified, the current annotation selection is returned.
        :rtype: str|None
        """

        # MEASUrement:ANNOTation:STATE {OFF|MEAS1|MEAS2|MEAS3|MEAS4|MEAS5|MEAS6|MEAS7|MEAS8}

        if select is None:
            return self.query('MEASU:ANNOT:STATE', str)

        select = check_enum_str('select', select, self.enum_annotation_select)

        if select != self.enum_annotation_select.OFF:
            meas_type, _ = self._type_from_inst(select.value)
            if meas_type == self.enum_meas_undefined.UNDEFINED:
                raise ValueError(f"Cannot enable annotation on {select.name} which is undefined.")

        self.write('MEASU:ANNOT:STATE', select.value)

        self.log_inst_errors()

    def gating(self, gating_type=None):
        """
        Query or set measurement gating.

        :param gating_type: Element of enum_gating_type or a string corresponding to one of its keys: 'OFF', 'CURSOR',
            'ZOOM1', 'ZOOM2', 'ZOOM3', 'ZOOM4'.
        :type gating_type: None|str|enum_gating_type
        :return: Query result translated into one of the names in enum_gating_type.
        :rtype: dict|None
        """

        # MEASUrement:GATing {ON|OFF|<NR1>|ZOOM<x>|CURSor}

        if gating_type is None:
            return self.query('MEASU:GAT', self.enum_gating_type).name

        gating_type = check_enum_str('gating_type', gating_type, self.enum_gating_type)

        if gating_type is not None:
            self.write('MEASU:GAT', gating_type.value)

        self.log_inst_errors()

    def immed_get_data(self):
        """
        Retrieve data from the immediate measurement system, if a measurement has been defined.

        Immediate measurements are performed on request and do not accumulate statistics over time. They are
        distinct from the 8 periodic measurement slots which do collect statistics.

        :return: dict containing keys: 'meas_type', 'value' and 'units' with data as read from the scope.
        :rtype: dict
        """

        # MEASUrement:IMMed:UNIts?
        # MEASUrement:IMMed:VALue?

        # TODO: Return channels in dict.

        meas_type = self.query("MEASU:IMM:TYP", str)

        if meas_type == "UNDEFINED":
            raise ValueError(f"For immed measurement, meas_type is 'UNDEFINED'. Use immed_setup to select a "
                             f"meas_type.")

        return_values = {}
        return_values.update(meas_type=meas_type)
        return_values.update(value=self.query('MEASU:IMM:VAL', float))

        # In phase measurement, scope returns a degree symbol that crashes the standard query that uses ascii encoding.
        self.scope.rm_handle.write('MEASU:IMM:UNI?')
        tmp = self.scope.rm_handle.read(encoding='latin-1')
        tmp = tmp.strip()
        tmp = tmp.strip('"')
        if tmp == '°':
            tmp = 'degrees'

        # tmp = self.query('MEASU:IMM:UNI', str).strip('"').strip()

        return_values.update(units='' if tmp.isspace() else tmp)

        return return_values

    def immed_reflevels(self, base_top_from=None, high=None, low=None, mid=None, mid2=None, units=None):
        """
        Query or set the reference levels for **ONLY** the immediate measurement functionality. This does not effect the
        reflevels of the 8 periodic measurement slots.

        **Note:** To set the reflevesl of all measurements **both** immediate and the 8 periodic measurements, use
        all_reflevels. To independently set reflevels for any of the 8 periodic measurement slots, use meas_reflevels.

        :param base_top_from: Sets method used to determine the 0% and 100% reference levels. Choices are:

            HISTOGRAM
                The most frequently occurring values above and below the midpoint are used for the 100% and 0%
                levels respectively. Best for pulses, ignores short-term aberrations like overshoot and ringing.
            MEAN
                The mean of all values above and the mean of all values below the midpoint are used for for the 100%
                and 0% levels respectively. Best for eye patterns.
            MINMAX
                Uses the highest and lowest values of the entire waveform record for the 100% and 0% values. Best when
                waveform has no sustained flat portions, like a sine or triangle wave.

        :type base_top_from: None|str|enum_base_top_from
        :param high: Upper level used in RISE and FALL measurements. Expressed as a %  of base_top or a voltage,
            see units parameter.
        :type high: float
        :param low: Lower level used in RISE and FALL measurements. Expressed as a %  of base_top or a voltage,
            see units parameter.
        :type low: float
        :param mid: Midpoint reference (mid1) for the "from" waveform used in PERIOD, FREQ, DELAY, and all cyclic
            measurements. Expressed as a % of base_top or a voltage, see units parameter.
        :type mid: float
        :param mid2: Midpoint reference (mid2) for the "to" waveform used in PERIOD, FREQ, DELAY, and all cyclic
            measurements. Expressed as a % of base_top or a voltage, see units parameter.
        :type mid2: float
        :param units: Determines if high, low, mid, mid2 values are interpreted as percentages of base_top or
            as absolute voltage values. 'PERCENT' or 'ABSOLUTE'.
        :type units: None|str|enum_reflevel_units
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        slot_str = 'IMMED:'
        return_values = self._reflevels(slot_str, base_top_from, high, low, mid, mid2, units)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def immed_setup(self, meas_type=None, source=None):
        """
        Query or set the measurement type and waveform source for the immediate measurement.

        Immediate measurements are performed on request and do not accumulate statistics over time. They are distinct
        from the 8 periodic measurement slots which do collect statistics.

        :param meas_type: Selects the type of measurement to be made from the possibilities contained in
            any of enum_meas_ampl, enum_meas_time, enum_meas_more or enum_meas_histog or enum_meas_undefined.
            Alternatively, a str can be supplied provided it matches an element name in one of these enums.
        :type meas_type: str|enum_meas_\*
        :param source: The waveform source for the measurement. An element of enum_meas_sources or a string
            corresponding to one of its keys: CH<x>, M<x>, or R<x>; where <x> is 1 through 4. Note that for
            meas_types from enum_meas_histog, attempting to set source to any value other than 'HISTO' will cause an
            error.
        :type source: str|enum_meas_sources
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        slot_str = 'IMMED'
        return_values = self._setup(slot_str, meas_type, source)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def immed_delay_edit(self, source1=None, edge1=None, midref1=None, source2=None, edge2=None, midref2=None,
                         midref_units=None, direction=None):
        """
        Query or set the parameters for an immed delay measurement. In contrast to the 8 periodic measurement slots,
        the scope provides no GUI for setting these parameters for the immediate delay measurement.

        **Note**: You must first use immed_setup to select DELAY as the meas_type before calling this method.

        :param source1: The waveform source for the "From" edge. An element of enum_meas_sources or a string
            corresponding to one of its keys: CH<x>, M<x>, or R<x>; where <x> is 1 through 4. 'HISTO' is not an allowed
            source for delay measurements.
        :type source1: str|enum_meas_sources
        :param edge1: Defines the "From" edge as RISE or FALL.
        :type edge1: str|enum_delay_edge
        :param midref1: Midpoint reference (mid1) for the "from" waveform. Expressed as a % of base_top or a voltage,
            see midref_units parameter.
        :type midref1: float
        :param source2: The waveform source for the "To" edge. An element of enum_meas_sources or a string
            corresponding to one of its keys: CH<x>, M<x>, or R<x>. Where <x> is 1 through 4. 'HISTO' is not an allowed
            source for delay measurements.
        :type source2: str|enum_meas_sources
        :param edge2: Defines the "To" edge as RISE or FALL.
        :type edge2: str|enum_delay_edge
        :param midref2: Midpoint reference (mid2) for the "To" waveform. Expressed as a % of base_top or a voltage,
            see midref_units parameter.
        :type midref2: float
        :param midref_units: Determines if midref1, midref2 values are interpreted as percentages of base_top or
            as absolute voltage values. 'PERCENT' or 'ABSOLUTE'.
        :type midref_units: None|str|enum_reflevel_units
        :param direction: Starting point and direction that determines where edges are found for the delay measurement.

            FORWARDS
                Starts the search at the beginning of the waveform record and looks for the **first** rising or falling
                edge in the waveform.
            BACKWARDS
                Starts the search at the end of the waveform record and looks for the **last** rising or falling edge in
                the waveform.

        :type direction: str|enum_delay_direction
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        slot_str = 'IMMED'
        method_prefix = 'immed'
        return_values = self._delay_edit(slot_str, method_prefix, source1, edge1, midref1, source2, edge2, midref2,
                               midref_units, direction)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def immed_phase_edit(self, target_source=None, ref_source=None, midref=None, midref_units=None):
        """
        Query or set the parameters for an immed phase measurement. In contrast to the 8 periodic measurement slots,
        the scope provides no GUI for setting these parameters for the immediate phase measurement.

        **Note**: You must first use immed_setup to select PHASE as the meas_type before calling this method.

        **Note**: Phase is positive when target leads the reference.

        :param target_source: The waveform source whose phase is to be compared to that of the ref_source waveform.
            An element of enum_meas_sources or a string corresponding to one of its keys: CH<x>, M<x>, or R<x>;
            where <x> is 1 through 4. 'HISTO' is not an allowed source for PHASE measurements.
        :type target_source: str|enum_meas_sources
        :param ref_source: The waveform source for the reference against which the phase of the target_source will be
            measured. An element of enum_meas_sources or a string corresponding to one of its keys: CH<x>, M<x>,
            or R<x>; where <x> is 1 through 4. 'HISTO' is not an allowed source for PHASE measurements.
        :type ref_source: str|enum_meas_sources
        :param midref: Midpoint reference.  Expressed as a % of base_top or a voltage, see midref_units parameter.
        :type midref: float
        :param midref_units: Determines if midref value is interpreted as a percentage of of base_top or as
            absolute voltage value. "PERCENT' or 'ABSOLUTE'.
        :type midref_units: None|str|enum_reflevel_units
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        slot_str = 'IMMED'
        method_prefix = 'immed'
        return_values = self._phase_edit(slot_str, method_prefix, target_source, ref_source, midref, midref_units)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def meas_clear(self, slots):
        """
        Removes selected or ALL measurements from the 8 periodic measurement slots.

        :param slots: Specifies which measurements to remove. Can be 'ALL', a single int or List[int]. The effect of
            'ALL' is the same as the "Clear All" button in the scopes Measurement Setup GUI. The effect of "Clear
            Selected" is mimicked by supplying a single slot number or a list of them. Slots are numbered 1 through 8.
        :type slots: str|int|List[int]
        :return: None
        """

        slots = self._check_slots(slots)

        for slot in slots:
            self.write(f"MEASU:MEAS{slot}:TYP", self.enum_meas_undefined.UNDEFINED.value)

        self.log_inst_errors()

    def meas_delay_edit(self, slot, source1=None, edge1=None, midref1=None, source2=None, edge2=None,
                       midref2=None, midref_units=None, direction=None):
        """
        Query or set the parameters for the periodic Delay measurement defined in the specified measurement slot.

        In the scope GUI, this functionality corresponds to clicking the Edit button to the right of a measurement
        slot containing a Delay measurement.

        **Note**: You must first use meas_setup to select DELAY as the meas_type for the slot before calling this
        method.

        :param slot: Identifies the periodic measurement slot containing the delay measurement. Legal values are 1
            through 8, but specifying a slot that does not contain a delay measurement raises an exception.
        :type slot: int
        :param source1: The waveform source for the "From" edge. An element of enum_meas_sources or a string
            corresponding to one of its keys: CH<x>, M<x>, or R<x>; where <x> is 1 through 4. 'HISTO' is not an allowed
            source for delay measurements.
        :type source1: str|enum_meas_sources
        :param edge1: Defines the "From" edge as RISE or FALL.
        :type edge1: str|enum_delay_edge
        :param midref1: Midpoint reference (mid1) for the "from" waveform. Expressed as a % of base_top or a voltage,
            see midref_units parameter.
        :type midref1: float
        :param source2: The waveform source for the "To" edge. An element of enum_meas_sources or a string
            corresponding to one of its keys: CH<x>, M<x>, or R<x>. Where <x> is 1 through 4. 'HISTO' is not an allowed
            source for delay measurements.
        :type source2: str|enum_meas_sources
        :param edge2: Defines the "To" edge as RISE or FALL.
        :type edge2: str|enum_delay_edge
        :param midref2: Midpoint reference (mid2) for the "To" waveform. Expressed as a % of base_top or a voltage,
            see midref_units parameter.
        :type midref2: float
        :param midref_units: Determines if midref1, midref2 values are interpreted as percentages of base_top or
            as absolute voltage values. 'PERCENT' or 'ABSOLUTE'.
        :type midref_units: None|str|enum_reflevel_units
        :param direction: Starting point and direction that determines where edges are found for the delay measurement.

            FORWARDS
                Starts the search at the beginning of the waveform record and looks for the **first** rising or falling
                edge in the waveform.
            BACKWARDS
                Starts the search at the end of the waveform record and looks for the **last** rising or falling edge in
                the waveform. TIP: Turn annotations on to see what this is doing, it might not be what you expect!

        :type direction: str|enum_delay_direction
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        if not(isinstance(slot, int) and (1 <= slot <= 8)):
            raise ValueError(f"Bad measurement slot {slot}, should be int 1 to 8.")

        slot_str = f'MEAS{slot}'
        method_prefix = 'meas'
        return_values = self._delay_edit(slot_str, method_prefix, source1, edge1, midref1, source2, edge2, midref2,
                                midref_units, direction)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def meas_display(self, slots='ALL', state=None):
        """
        Disables/Enables ALL or selected measurements from the 8 periodic measurement slots.

        Disabled measurements do not display any results on the scope screen and do not accumulate statistics while
        disabled. Attempting to read the results from a disabled measurement using meas_get_data(slot) will return the
        value 9.9e+37 for all the statistics. Re-enabling the measurement resets the count and the statistics.

        :param slots: Specifies which measurements to disable/enable. Can be 'ALL', or a single int or List[int]. The
            effect of 'ALL' is the same as the "Display" button in the scopes Measurement Setup GUI. By providing a
            single int or a List[int], measurements can be selectively enabled/disabled, a capability the scope GUI
            does not provide.
        :type slots: str|int|List[int]
        :param state: 'ON' (or 1 or True) enables the periodic measurements and their display. 'OFF' (or 0 or False)
            disables.
        :type state: bool|int|str
        :return: None
        """

        slots = self._check_slots(slots)

        if state is None:
            return_value = {}
            for slot in slots:
                return_value.update({slot: self.on_off.to_api(self.query(f"MEASU:MEAS{slot}:STATE", int))})
            return return_value

        for slot in slots:
            self.write(f"MEASU:MEAS{slot}:STATE", self.on_off.to_inst(state))

        self.log_inst_errors()

    def meas_get_data(self, slot):
        """
        Retrieve data from the periodic measurement system, for specified slot if a measurement has been defined for
        that slot.

        Note that the periodic measurements are performed on an ongoing basis and accumulate statistics over time if
        they are enbaled (see meas_display). The periodic measurements are distinct from the immediate measurement
        capability.

        :return: Dictionary containing value and units returned form the scope. The full set of keys are: 'value',
            'mean', 'minimum', 'maximum', 'stddev', 'count'. This complete set of keys-values is returned and is
            valid regardless of the setting of the mode parameter of the statistics_controls method.

        :rtype: dict
        """

        # MEASUrement:MEAS<x>:COUNt?
        # MEASUrement:MEAS<x>:MAXimum?
        # MEASUrement:MEAS<x>:MEAN?
        # MEASUrement:MEAS<x>:MINImum?
        # MEASUrement:MEAS<x>:STDdev?
        # MEASUrement:MEAS<x>:UNIts?
        # MEASUrement:MEAS<x>:VALue?

        # TODO: What happens if we attempt to read a slot that is not defined?
        # TODO: Return sources in dict and name of measurement.

        if not(isinstance(slot, int) and (1 <= slot <= 8)):
            raise ValueError(f"Bad measurement slot {slot}, should be int 1 to 8.")

        meas_type = self.query(f"MEASU:MEAS{slot}:TYP", str)
        if meas_type == "UNDEFINED":
            raise ValueError(f"For MEAS{slot}, meas_type is 'UNDEFINED'. Use meas_config to select a meas_type.")

        return_values = {}
        return_values.update(value=self.query(f"MEASU:MEAS{slot}:VAL", float))
        return_values.update(mean=self.query(f"MEASU:MEAS{slot}:MEAN", float))
        return_values.update(minimum=self.query(f"MEASU:MEAS{slot}:MINI", float))
        return_values.update(maximum=self.query(f"MEASU:MEAS{slot}:MAX", float))
        return_values.update(stddev=self.query(f"MEASU:MEAS{slot}:STD", float))
        return_values.update(count=self.query(f"MEASU:MEAS{slot}:COUN", float))

        # In phase measurement, scope returns a degree symbol that crashes the standard query that uses ascii encoding.
        # TODO: Breaks in simulation where rm_handle is None.
        self.scope.rm_handle.write(f'MEASU:MEAS{slot}:UNI?')
        tmp = self.scope.rm_handle.read(encoding='latin-1')
        tmp = tmp.strip()
        tmp = tmp.strip('"')
        if tmp == '°':
            tmp = 'degrees'

        # tmp = self.query(f"MEASU:MEAS{slot}:UNI", str).strip('"').strip()
        return_values.update(units='' if tmp.isspace() else tmp)

        return return_values

    def meas_phase_edit(self, slot, target_source=None, ref_source=None, midref=None, midref_units=None):
        """
        Query or set the parameters for the periodic PHASE measurement defined in the specified measurement slot.

        In the scope GUI, this functionality corresponds to clicking the Edit button to the right of a measurement
        slot containing a PHASE measurement.

        **Note**: You must first use meas_setup to select PHASE as the meas_type for the slot before calling this
        method.

        **Note**: Phase value is positive when target waveform leads the reference waveform.

        :param slot: Identifies the periodic measurement slot containing the PHASE measurement. Legal values are 1
            through 8, but specifying a slot that does not contain a PHASE measurement raises an exception.
        :type slot: int
        :param target_source: The waveform source whose phase is to be compared to that of the ref_source waveform.
            An element of enum_meas_sources or a string corresponding to one of its keys: CH<x>, M<x>, or R<x>;
            where <x> is 1 through 4. 'HISTO' is not an allowed source for PHASE measurements.
        :type target_source: str|enum_meas_sources
        :param ref_source: The waveform source for the reference against which the phase of the target_source will be
            measured. An element of enum_meas_sources or a string corresponding to one of its keys: CH<x>, M<x>,
            or R<x>; where <x> is 1 through 4. 'HISTO' is not an allowed source for PHASE measurements.
        :type ref_source: str|enum_meas_sources
        :param midref: Midpoint reference.  Expressed as a % of base_top or a voltage, see midref_units parameter.
        :type midref: float
        :param midref_units: Determines if midref value is interpreted as a percentage of of base_top or as
            absolute voltage value. "PERCENT' or 'ABSOLUTE'.
        :type midref_units: None|str|enum_reflevel_units
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        if not(isinstance(slot, int) and (1 <= slot <= 8)):
            raise ValueError(f"Bad measurement slot {slot}, should be int 1 to 8.")

        slot_str = f'MEAS{slot}'
        method_prefix = 'meas'
        return_values = self._phase_edit(slot_str, method_prefix, target_source, ref_source, midref, midref_units)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def meas_reflevels(self, slot, base_top_from=None, high=None, low=None, mid=None, mid2=None, units=None):
        """
        Query or set the reference levels for particular measurement defined in the specified periodic measurment slot.

        **Note:** To set the reflevesl of all measurements **both** immediate and the 8 periodic measurements, use
        all_reflevels. To independently set reflevels for the immediat emeasurment, use immed_reflevels.

        :param slot: Identifies the periodic measurement slot containing the measurement. Legal values are 1
            through 8.
        :type slot: int
        :param base_top_from: Sets method used to determine the 0% and 100% reference levels. Choices are:

            HISTOGRAM
                The most frequently occurring values above and below the midpoint are used for the 100% and 0%
                levels respectively. Best for pulses, ignores short-term aberrations like overshoot and ringing.
            MEAN
                The mean of all values above and the mean of all values below the midpoint are used for for the 100%
                and 0% levels respectively. Best for eye patterns.
            MINMAX
                Uses the highest and lowest values of the entire waveform record for the 100% and 0% values. Best when
                waveform has no sustained flat portions, like a sine or triangle wave.

        :type base_top_from: None|str|enum_base_top_from
        :param high: Upper level used in RISE and FALL measurements. Expressed as a %  of base_top or a voltage,
            see units parameter.
        :type high: float
        :param low: Lower level used in RISE and FALL measurements. Expressed as a %  of base_top or a voltage,
            see units parameter.
        :type low: float
        :param mid: Midpoint reference (mid1) for the "from" waveform used in PERIOD, FREQ, DELAY, and all cyclic
            measurements. Expressed as a % of base_top or a voltage, see units parameter.
        :type mid: float
        :param mid2: Midpoint reference (mid2) for the "to" waveform used in PERIOD, FREQ, DELAY, and all cyclic
            measurements. Expressed as a % of base_top or a voltage, see units parameter.
        :type mid2: float
        :param units: Determines if high, low, mid, mid2 values are interpreted as percentages of base_top or
            as absolute voltage values. 'PERCENT' or 'ABSOLUTE'.
        :type units: None|str|enum_reflevel_units
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        if not(isinstance(slot, int) and (1 <= slot <= 8)):
            raise ValueError(f"Bad measurement slot {slot}, should be int 1 to 8.")

        slot_str = f'MEAS{slot}:'
        return_values = self._reflevels(slot_str, base_top_from, high, low, mid, mid2, units)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def meas_setup(self, slot, meas_type=None, source=None):
        """
        Query or set the measurement type and waveform source for the specified periodic measurement slot.

        Periodic measurements are performed autonatically and accumulate statistics over time. They are distinct
        from the immediate measurement that does not calculate statistics.

        :param slot: Identifies the periodic measurement slot defining the measurement. Legal values are 1 through 8.
        :type slot: int
        :param meas_type: Selects the type of measurement to be made from the possibilities contained in
            any of enum_meas_ampl, enum_meas_time, enum_meas_more or enum_meas_histog or enum_meas_undefined.
            Alternatively, a str can be supplied provided it matches an element name in one of these enums.
        :type meas_type: str|enum_meas_\*
        :param source: The waveform source for the measurement. An element of enum_meas_sources or a string
            corresponding to one of its keys: CH<x>, M<x>, or R<x>; where <x> is 1 through 4. Note that for
            meas_types from enum_meas_histog, attempting to set source to any value other than 'HISTO' will cause an
            error.
        :type source: str|enum_meas_sources
        :return: If no input parameters are specified, dict of query results is returned.
        :rtype: dict|None
        """

        if not (isinstance(slot, int) and (1 <= slot <= 8)):
            raise ValueError(f"Bad measurement slot {slot}, should be int 1 to 8.")

        slot_str = f'MEAS{slot}'
        return_values = self._setup(slot_str, meas_type, source)

        if return_values is not None:
            return return_values  # Query results.

        self.log_inst_errors()  # Making error report come from this method for easier debug.

    def statistics_reset(self):
        """
        Clears the periodic measurement statistics from memory and resets the count to 0.

        :return: None
        """

        # MEASUrement:STATIstics:COUNt {RESET}

        self.write("MEASU:STATI:COUN", "RESET")

        self.log_inst_errors()

    def statistics_controls(self, mode=None, weighting=None):
        """
        Query or set parameters controlling what statistics are collected for the measurements defined in all 8 of the
        periodic measurement slots. In the scope GUI this corresponds to Measure->Statistics->Statistics Controls.

        :param mode: Choices determine what statistics are displayed on the scope screen. Note that changing between
            modes has the effect of resetting the count.

            OFF
                Turns off all measurements.
            ALL
                Statistics displayed: value, mean, min, max, stddev, count
            VALUEMEAN
                Statistics displayed: value, mean, count.  It appears that regardless of this setting a call to
                meas_get_data(slot) will still return a complete set of up to date statistics.
            MINMAX
                Synonym for ALL and reads back as ALL. MINMAX is in the programmers manual but not in the GUI.
            MEANSTD
                Synonym for ALL and reads back as ALL. MEANSTD is in the programmers manual but not in the GUI.

        :type mode: str|enum_stats_mode
        :param weighting: Described by Tek as the "time constant" for the mean and standard deviation statistics.
        :type weighting: int
        :return: If no input parameters are specified a dict of query results is returned.
        :rtype: dict|None
        """

        # MEASUrement:STATIstics:MODe {OFF|ALL|VALUEMean|MINMax|MEANSTDdev}
        # MEASUrement:STATIstics:WEIghting <NR1>

        if all([v is None for v in (mode, weighting)]):
            return_values = {}
            return_values.update(mode=self.query('MEASU:STATI:MOD', self.enum_stats_mode).name)
            return_values.update(weighting=self.query('MEASU:STATI:WEI', int))
            return return_values

        mode = check_enum_str('mode', mode, self.enum_stats_mode)

        if weighting is not None:
            weighting_max = int(1e6)
            if not isinstance(weighting, (int, float)):
                raise ValueError(f"Bad weighting {weighting}, should be int from 2 to {weighting_max}.")
            if not(2 <= weighting <= weighting_max):
                newval = max(min(int(weighting), weighting_max), 2)
                if newval != weighting:
                    self.log.warn(f"Weighting {int(weighting)} outside range 2 to {weighting_max}, scope will coerce to"
                                  f" {newval}.")

        if mode is not None:
            self.write('MEASU:STATI:MOD', mode.name)
        if weighting is not None:
            self.write('MEASU:STATI:WEI', weighting)

        self.log_inst_errors()

    # --------------------------------------------------------------------------------------------------
    # private helper methods

    def _check_meas_type(self, meas_type, source_state):
        """

        :param meas_type:
        :type meas_type:
        :param source_state:
        :type source_state:
        :return:
        :rtype:
        """

        if meas_type is None:
            return None
        if isinstance(meas_type, str):
            if meas_type in self.enum_meas_undefined.__members__.keys():
                return self.enum_meas_undefined.UNDEFINED
        else:
            if meas_type in self.enum_meas_undefined:
                return self.enum_meas_undefined.UNDEFINED

        if source_state == self.enum_meas_sources.HISTO:
            # For a HISTO source, we have only one enum to check.
            error_template = f"Bad {{name}} '{{value}}' for source '{source_state.name}', should be one of {{" \
                             f"cls_name}}: {{keys}}."
            meas_type = check_enum_str('meas_type', meas_type, self.enum_meas_histog, error_template)
            return meas_type
        else:
            # For other, we have split into 3 enums to match GUI organization. Have to look in all 3, so
            # can't use check_enum_str because that would raise exception if not in first enum we tried.
            for category in (self.enum_meas_ampl, self.enum_meas_time, self.enum_meas_more, self.enum_meas_comm):

                keys = category.__members__.keys()

                # this is the same logic as check_enum_str but with an abstract enum_cls 'category'
                if isinstance(meas_type, str):
                    if meas_type in keys:
                        return getattr(category, meas_type)  # the user passed in a reference to a string key of an enum
                else:
                    if meas_type in category:
                        return meas_type  # the user passed in an enum

        # Nothing matched. Create error reporting text.
        msg = ''
        for category in (self.enum_meas_ampl, self.enum_meas_time, self.enum_meas_more, self.enum_meas_comm):
            keys = category.__members__.keys()
            key_str = ', '.join([f"'{k}'" for k in keys])
            if len(msg) > 0:
                msg += ';\n'
            msg += f"{category.__name__}: {key_str}"

        if isinstance(meas_type, Enum):
            meas_type = meas_type.name
        raise ValueError(f"Bad meas_type '{meas_type}' for source '{source_state.name}', can be one of:\n{msg}. ")

    def _check_reflevel(self, name, value, units):
        if value is not None and units.name == 'PERCENT':
            if not(0.0 <= value <= 100.0):
                new_value = max(0, min(value, 100.0))
                self.log.warn(f"Attempted {name} setting {value}%, scope will coerce to {new_value}%.")
            if (value - int(value)) >= 0.5:
                new_value = int(value) + 1
            else:
                new_value = int(value)
            if value != new_value:
                self.log.warn(f"Attempted {name} setting {value}%, scope will round to {new_value}%.")

    @staticmethod
    def _check_slots(slots):
        """

        :param slots:
        :type slots:
        :return:
        :rtype:
        """

        possible_slots = list(range(1, 9))

        if isinstance(slots, int) and slots in possible_slots:
            return [slots]
        elif isinstance(slots, (list, tuple)):
            bad_loc = [i for i, v in enumerate(slots) if v not in possible_slots]
            if len(bad_loc) > 0:
                msg1 = ', '.join([str(slots[i]) for i in bad_loc])
                msg2 = ', '.join(str(s) for s in slots)
                raise ValueError(f"Bad values [{msg1}] in input [{msg2}], should be ints from 1 to 8")
            return slots
        elif isinstance(slots, str) and slots.upper() == 'ALL':
            return possible_slots
        else:
            raise ValueError(f"Bad slots '{slots}', should be 'ALL', a int (1-8) or a list of ints [1-8].")

    def _delay_edit(self, slot_str, method_prefix, source1, edge1, midref1, source2, edge2, midref2, midref_units,
                    direction):
        """

        :param slot_str:
        :type slot_str:
        :param method_prefix:
        :type method_prefix:
        :param source1:
        :type source1:
        :param edge1:
        :type edge1:
        :param midref1:
        :type midref1:
        :param source2:
        :type source2:
        :param edge2:
        :type edge2:
        :param midref2:
        :type midref2:
        :param midref_units:
        :type midref_units:
        :param direction:
        :type direction:
        :return:
        :rtype:
        """

        # MEASUrement:MEAS<x>:TYPe

        # MEASUrement:MEAS<x>:STATE {<NR1>|OFF|ON}
        # MEASUrement:MEAS<x>:SOUrce<x> {CH<x>|MATH<y>|REF<x>|HIStogram}
        # MEASUrement:MEAS<x>:DELay:DIREction {BACKWards|FORWards}
        # MEASUrement:MEAS<x>:DELay:EDGE<x> {FALL|RISe}

        # MEASUrement:MEAS<x>:REFLevel:METHod {ABSolute | PERCent}
        # MEASUrement:MEAS<x>:REFLevel:ABSolute:MID<x> <NR3>
        # MEASUrement:MEAS<x>:REFLevel:PERCent:MID<x> <NR3>

        meas_type, source = self._type_from_inst(slot_str)

        if meas_type != self.enum_meas_time.DELAY:
            raise ValueError(f" {slot_str} is configured for meas_type '{meas_type.name}'. Use {method_prefix}_setup "
                             f"to select meas_type='{self.enum_meas_time.DELAY.name}' before calling "
                             f"{method_prefix}_edit.")

        midref_units_state = self.query(f"MEASU:{slot_str}:REFL:METH", self.enum_reflevel_units)

        if all([v is None for v in (source1, edge1, midref1, source2, edge2, midref2, midref_units,
                                    direction)]):
            return_values = {}
            return_values.update(source1=source.name)
            return_values.update(edge1=self.query(f"MEASU:{slot_str}:DEL:EDGE1", self.enum_delay_edge).name)
            return_values.update(midref1=self.query(f"MEASU:{slot_str}:REFL:{midref_units_state.value}:MID1", float))
            return_values.update(source2=self.query(f"MEASU:{slot_str}:SOU2", self.enum_meas_sources).name)
            return_values.update(edge2=self.query(f"MEASU:{slot_str}:DEL:EDGE2", self.enum_delay_edge).name)
            return_values.update(midref2=self.query(f"MEASU:{slot_str}:REFL:{midref_units_state.value}:MID2", float))
            return_values.update(midref_units=midref_units_state.name)
            return_values.update(direction=self.query(f"MEASU:{slot_str}:DEL:DIRE", self.enum_delay_direction).name)
            return return_values

        source1 = check_enum_str('source1', source1, self.enum_meas_sources)
        if source1 is None:
            source1_state = self.query(f"MEASU:{slot_str}:SOU", self.enum_meas_sources)
        else:
            source1_state = source1

        if source1_state.name == self.enum_meas_sources.HISTO:
            raise ValueError(f"Current source1 setting {source1_state.name} is incompatible with delay measurement. "
                             "Specify a source from CH<x>, MATH<x> or REF<x>.")

        source2 = check_enum_str('source2', source2, self.enum_meas_sources)

        edge1 = check_enum_str('edge1', edge1, self.enum_delay_edge)
        edge2 = check_enum_str('edge2', edge2, self.enum_delay_edge)

        midref_units = check_enum_str('midref_units', midref_units, self.enum_reflevel_units)
        if midref_units is not None:
            midref_units_state = midref_units

        self._check_reflevel('midref1', midref1, midref_units_state)
        self._check_reflevel('midref2', midref2, midref_units_state)

        direction = check_enum_str('direction', direction, self.enum_delay_direction)

        if source1 is not None:
            self.write(f"MEASU:{slot_str}:SOU", source1.value)
        if edge1 is not None:
            self.write(f"MEASU:{slot_str}:DEL:EDGE1", edge1.value)
        if midref1 is not None:
            self.write(f"MEASU:{slot_str}:REFL:{midref_units_state.value}:MID1", midref1)
        if source2 is not None:
            self.write(f"MEASU:{slot_str}:SOU2", source2.value)
        if edge2 is not None:
            self.write(f"MEASU:{slot_str}:DEL:EDGE2", edge2.value)
        if midref2 is not None:
            self.write(f"MEASU:{slot_str}:REFL:{midref_units_state.value}:MID2", midref2)
        if midref_units is not None:
            self.write(f"MEASU:{slot_str}:REFL:METH", midref_units.value)
        if direction is not None:
            self.write(f"MEASU:{slot_str}:DEL:DIRE", direction.value)

        # Let caller log instrument errors, so log message displays caller's name.

    def _type_from_inst(self, slot_str):
        """

        :param slot_str:
        :type slot_str:
        :return:
        :rtype:
        """

        meas_type = self.query(f"MEASU:{slot_str}:TYP", str)
        source = self.query(f"MEASU:{slot_str}:SOU", self.enum_meas_sources)

        # The issue here is that enum_meas_ampl and enum_meas_histog share the values: PK2PK, MAXIMUM, MEAN, MINIMUM.
        # To distinguish, we need to also consider the source selection.
        if source.name == 'HISTO':
            if meas_type == self.enum_meas_undefined.UNDEFINED.value:
                return self.enum_meas_undefined.UNDEFINED, source
            return self.enum_meas_histog(meas_type), source
        else:
            # Assumptions: All measurements in the 3 enums can be applied to any of the CH, MATH, or REF sources, and
            # the values in the 3 enums are unique.
            for category in (self.enum_meas_ampl, self.enum_meas_time, self.enum_meas_more, self.enum_meas_comm,
                             self.enum_meas_undefined):
                if meas_type in [e.value for e in category]:
                    return category(meas_type), source

        raise ValueError(f"Scope returned meas_type '{meas_type}', for source '{source.name}', which does not "
                         f"correspond to any values in enum_meas_ampl, enum_mas_time, enum_meas_more, "
                         f"enum_meas_histog, enum_meas_comm, or enum_meas_undefined.")

    def _phase_edit(self, slot_str, method_prefix, target_source, ref_source, midref, midref_units):
        """

        :param slot_str:
        :type slot_str:
        :param method_prefix:
        :type method_prefix:
        :param target_source:
        :type target_source:
        :param ref_source:
        :type ref_source:
        :param midref:
        :type midref:
        :param midref_units:
        :type midref_units:
        :return:
        :rtype:
        """

        # MEASUrement:MEAS<x>:TYPe

        # MEASUrement:MEAS<x>:STATE {<NR1>|OFF|ON}
        # MEASUrement:MEAS<x>:SOUrce<x> {CH<x>|MATH<y>|REF<x>|HIStogram}
        # MEASUrement:MEAS<x>:DELay:DIREction {BACKWards|FORWards}
        # MEASUrement:MEAS<x>:DELay:EDGE<x> {FALL|RISe}

        # MEASUrement:MEAS<x>:REFLevel:METHod {ABSolute | PERCent}
        # MEASUrement:MEAS<x>:REFLevel:ABSolute:MID<x> <NR3>
        # MEASUrement:MEAS<x>:REFLevel:PERCent:MID<x> <NR3>

        meas_type, source = self._type_from_inst(slot_str)

        if meas_type != self.enum_meas_more.PHASE:
            raise ValueError(f" {slot_str} is configured for meas_type '{meas_type.name}'. Use {method_prefix}_setup "
                             f"to select meas_type='{self.enum_meas_more.PHASE.name}' before calling "
                             f"{method_prefix}_edit.")

        midref_units_state = self.query(f"MEASU:{slot_str}:REFL:METH", self.enum_reflevel_units)

        if all([v is None for v in (target_source, ref_source, midref, midref_units)]):
            return_values = {}
            return_values.update(target_source=source.name)
            return_values.update(ref_source=self.query(f"MEASU:{slot_str}:SOU2", self.enum_meas_sources).name)
            return_values.update(midref=self.query(f"MEASU:{slot_str}:REFL:{midref_units_state.value}:MID1", float))
            return_values.update(midref_units=midref_units_state.name)
            return return_values

        target_source = check_enum_str('target_source', target_source, self.enum_meas_sources)
        if target_source is None:
            target_source_state = self.query(f"MEASU:{slot_str}:SOU", self.enum_meas_sources)
        else:
            target_source_state = target_source

        if target_source_state.name == self.enum_meas_sources.HISTO:
            raise ValueError(f"Current target_source setting {target_source_state.name} is incompatible with phase "
                             f"measurement. Specify a source from CH<x>, MATH<x> or REF<x>.")

        ref_source = check_enum_str('ref_source', ref_source, self.enum_meas_sources)

        midref_units = check_enum_str('midref_units', midref_units, self.enum_reflevel_units)
        if midref_units is not None:
            midref_units_state = midref_units

        self._check_reflevel('midref', midref, midref_units_state)

        if target_source is not None:
            self.write(f"MEASU:{slot_str}:SOU", target_source.value)
        if ref_source is not None:
            self.write(f"MEASU:{slot_str}:SOU2", ref_source.value)
        if midref_units is not None:
            self.write(f"MEASU:{slot_str}:REFL:METH", midref_units.value)
        if midref is not None:
            self.write(f"MEASU:{slot_str}:REFL:{midref_units_state.value}:MID1", midref)

        # Let caller log instrument errors, so log message displays caller's name.

    def _reflevels(self, slot_str, base_top_from, high, low, mid, mid2, units):
        """

        :param slot_str:
        :type slot_str:
        :param base_top_from:
        :type base_top_from:
        :param units:
        :type units:
        :param high:
        :type high:
        :param low:
        :type low:
        :param mid:
        :type mid:
        :param mid2:
        :type mid2:
        :return:
        :rtype:
        """

        # slot = 'IMMED', 1..8, 'ALL'

        # MEASUrement:IMMed:METHod {HIStogram|MINMax|MEAN}      # In GUI : "Determine Base Top From" ?
        # MEASUrement:IMMed:REFLevel:METHod {ABSolute|PERCent}  # In GUI: "Units"
        # MEASUrement:IMMed:REFLevel:ABSolute:HIGH
        # MEASUrement:IMMed:REFLevel:ABSolute:LOW
        # MEASUrement:IMMed:REFLevel:ABSolute:MID<x>
        # MEASUrement:IMMed:REFLevel:PERCent:HIGH <NR1>
        # MEASUrement:IMMed:REFLevel:PERCent:LOW <NR1>
        # MEASUrement:IMMed:REFLevel:PERCent:MID<x> <NR1>

        # MEASUrement:MEAS<x>:METHod {HIStogram|MINMax|MEAN}      # In GUI : "Determine Base Top From" ?
        # MEASUrement:MEAS<x>:REFLevel:METHod {ABSolute|PERCent}  # In GUI: "Units"
        # MEASUrement:MEAS<x>:REFLevel:ABSolute:HIGH <NR3>
        # MEASUrement:MEAS<x>:REFLevel:ABSolute:LOW <NR3>
        # MEASUrement:MEAS<x>:REFLevel:ABSolute:MID<x> <NR3>
        # MEASUrement:MEAS<x>:REFLevel:PERCent:HIGH <NR3>
        # MEASUrement:MEAS<x>:REFLevel:PERCent:LOW <NR3>
        # MEASUrement:MEAS<x>:REFLevel:PERCent:MID<x> <NR3>

        # MEASUrement:METHod {HIStogram|MEAN|MINMax}      # In GUI : "Determine Base Top From" ?
        # MEASUrement:REFLevel:METHod {ABSolute|PERCent}  # In GUI: "Units"
        # MEASUrement:REFLevel:ABSolute:HIGH <NR3>
        # MEASUrement:REFLevel:ABSolute:LOW <NR3>
        # MEASUrement:REFLevel:ABSolute:MID<x> <NR3>
        # MEASUrement:REFLevel:PERCent:HIGH <NR3>
        # MEASUrement:REFLevel:PERCent:LOW <NR3>
        # MEASUrement:REFLevel:PERCent:MID<x> <NR3>

        if all([v is None for v in (base_top_from, high, low, mid, mid2, units)]):
            return_values = {}
            return_values.update(base_top_from=self.query(f"MEASU:{slot_str}METH", self.enum_base_top_from).name)
            units_state = self.query(f"MEASU:{slot_str}REFL:METH", self.enum_reflevel_units)
            return_values.update(high=self.query(f"MEASU:{slot_str}REFL:{units_state.value}:HIGH", float))
            return_values.update(low=self.query(f"MEASU:{slot_str}REFL:{units_state.value}:LOW", float))
            return_values.update(mid=self.query(f"MEASU:{slot_str}REFL:{units_state.value}:MID1", float))
            return_values.update(mid2=self.query(f"MEASU:{slot_str}REFL:{units_state.value}:MID2", float))
            return_values.update(units=units_state.name)
            return return_values

        # Check non-None inputs
        base_top_from = check_enum_str('base_top_from', base_top_from, self.enum_base_top_from)

        units = check_enum_str('units', units, self.enum_reflevel_units)
        if units is None:
            units_state = self.query(f"MEASU:{slot_str}REFL:METH", self.enum_reflevel_units)
        else:
            units_state = units

        self._check_reflevel('high', high, units_state)
        self._check_reflevel('low',  low,  units_state)
        self._check_reflevel('mid',  mid,  units_state)
        self._check_reflevel('mid2', mid2, units_state)

        # Write any new values to the instrument.
        if base_top_from is not None:
            self.write(f"MEASU:{slot_str}METH", base_top_from.value)
        if units is not None:
            self.write(f"MEASU:{slot_str}REFL:METH", units.value)
        if high is not None:
            self.write(f"MEASU:{slot_str}REFL:{units_state.value}:HIGH", high)
        if low is not None:
            self.write(f"MEASU:{slot_str}REFL:{units_state.value}:LOW", low)
        if mid is not None:
            self.write(f"MEASU:{slot_str}REFL:{units_state.value}:MID1", mid)
        if mid2 is not None:
            self.write(f"MEASU:{slot_str}REFL:{units_state.value}:MID2", mid2)

        # Let caller log instrument errors, so log message displays caller's name.

    def _setup(self, slot_str, meas_type, source):
        """

        :param slot_str:
        :type slot_str:
        :param meas_type:
        :type meas_type:
        :param source:
        :type source:
        :return:
        :rtype:
        """

        # MEASUrement:IMMed:TYPe {AMPlitude|AREa|
        #   BURst|CARea|CMEan|CRMs|DELay|DISTDUty|
        #   EXTINCTDB|EXTINCTPCT|EXTINCTRATIO|
        #   EYEHeight|EYEWIdth|FALL|FREQuency|HIGH|
        #   HITs|LOW|MAXimum|MEAN|MEDian|MINImum|
        #   NCROss|NDUty|NOVershoot|NWIdth|PBASe|
        #   PCROss|PCTCROss|PDUty|PEAKHits|PERIod|
        #   PHAse|PK2Pk|PKPKJitter|PKPKNoise|
        #   POVershoot|PTOP|PWIdth|QFACtor|RISe|
        #   RMS|RMSJitter|RMSNoise|SIGMA1|SIGMA2|
        #   SIGMA3|SIXSigmajit|SNRatio|STDdev| UNDEFINED|WAVEFORMS
        #   }
        # MEASUrement:IMMed:SOUrce<x> {CH<x>|MATH<y>|REF<x>|HIStogram}
        # MEASUrement:IMMed:DELay:DIREction {BACKWards|FORWards}
        # MEASUrement:IMMed:DELay:EDGE[1] {FALL|RISe}
        # MEASUrement:IMMed:DELay:EDGE2 {FALL|RISe}
        # MEASUrement:IMMed:METHod {HIStogram|MINMax|MEAN}

        # MEASUrement:MEAS<x>:TYPe {AMPlitude|AREa|
        #   BURst|CARea|CMEan|CRMs|DELay|DISTDUty|
        #   EXTINCTDB|EXTINCTPCT|EXTINCTRATIO|EYEHeight|
        #   EYEWIdth|FALL|FREQuency|HIGH|HITs|LOW|
        #   MAXimum|MEAN|MEDian|MINImum|NCROss|NDUty|
        #   NOVershoot|NWIdth|PBASe|PCROss|PCTCROss|PDUty|
        #   PEAKHits|PERIod|PHAse|PK2Pk|PKPKJitter|
        #   PKPKNoise|POVershoot|PTOP|PWIdth|QFACtor|
        #   RISe|RMS|RMSJitter|RMSNoise|SIGMA1|SIGMA2|
        #   SIGMA3|SIXSigmajit|SNRatio|STDdev|UNDEFINED| WAVEFORMS
        # }
        # MEASUrement:MEAS<x>:STATE {<NR1>|OFF|ON}
        # MEASUrement:MEAS<x>:SOUrce<x> {CH<x>|MATH<y>|REF<x>|HIStogram}
        # MEASUrement:MEAS<x>:DELay:DIREction {BACKWards|FORWards}
        # MEASUrement:MEAS<x>:DELay:EDGE<x> {FALL|RISe}

        if all([v is None for v in (meas_type, source)]):
            return_values = {}
            meas_type, source = self._type_from_inst(slot_str)
            return_values.update(meas_type=meas_type.name)
            return_values.update(source=source.name)
            return return_values

        source = check_enum_str('source', source, self.enum_meas_sources)
        if source is None:
            source_state = self.query(f"MEASU:{slot_str}:SOU", self.enum_meas_sources)
        else:
            source_state = source

        meas_type = self._check_meas_type(meas_type, source_state)
        if meas_type is None:
            meas_type_state, _ = self._type_from_inst(slot_str)
        else:
            meas_type_state = meas_type

        if isinstance(meas_type_state, self.enum_meas_histog) and source_state != self.enum_meas_sources.HISTO:
            self.log.warn(f"Attempting to set source '{source_state.name}' for histo meas '{meas_type_state.name}', "
                          f"scope will force source to {self.enum_meas_sources.HISTO.name}.")

        if source is not None:
            self.write(f"MEASU:{slot_str}:SOU", source.value)

        # Order matters: source is used to disambiguate certain ampl vs histo measurements, e.g PK2PK.
        if meas_type is not None:
            self.write(f"MEASU:{slot_str}:TYP", meas_type.value)

        # Let caller log instrument errors, so log message displays caller's name.
