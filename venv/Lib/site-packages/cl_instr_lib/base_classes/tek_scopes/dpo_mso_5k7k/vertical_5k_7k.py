from enum import Enum
import math
import re
import time

from cl_instr_lib.base_classes.tek_scopes.vertical import Vertical
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_numeric_vs_list import check_numeric_vs_list


class Vertical_5k_7k(Vertical):
    """Class providing the **Vertical Channel** controls of a Tektronix 5000 series oscilloscope."""

    def __init__(self, scope, **kwargs):
        super().__init__(scope, **kwargs)

        if re.match('^DPO7(05|10|25|35)4C?$', self.scope.model):
            self.enum_coupling = Enum('enum_coupling', {'AC': 'AC', 'DC': 'DC', 'GND': 'GND'})
            self.enum_coupling_tap = Enum('enum_coupling_tap', {'DC': 'DC', 'GND': 'GND'})
            self.enum_coupling_tcp = Enum('enum_coupling_tcp', {'DC': 'DC', 'AC': 'AC', 'GND': 'GND'})
            self.enum_coupling_tdp = Enum('enum_coupling_tdp', {'DC': 'DC', 'DCREJ': 'DCREJECT', 'GND': 'GND'})
        else:
            self.enum_coupling = Enum('enum_coupling', {'AC': 'AC', 'DC': 'DC'})
            self.enum_coupling_tap = Enum('enum_coupling_tap', {'DC': 'DC'})
            self.enum_coupling_tcp = Enum('enum_coupling_tcp', {'DC': 'DC', 'AC': 'AC'})
            self.enum_coupling_tdp = Enum('enum_coupling_tdp', {'DC': 'DC', 'DCREJ': 'DCREJECT'})


        self._probes_setting_termination = ['TPP0500', 'TPP0500B', 'TPP1000',   # compatible with 5k series only
                                            'TAP1500', 'TAP2500', 'TAP3500',        # compatible with both 5k and 7k
                                            'TCP0030']
        # TAP1500/2500 not tested
        # The 7000 series scopes lack a notch on the right side of probe socket necessary to accept a TPP series probe.

        self._analog_input_ranges = (
            (1e6, namedtuple_min_max(1e-3, 10.0)),
            (50.0, namedtuple_min_max(1e-3, 1.0)),
        )

        self.enum_dsp_bw_enhance = Enum('enum_dsp_bw_enhance', {
            'AUTO': 'AUTO',
            'OFF': 'OFF'
        })

        # See setup method.
        # self._offset_table = (
        #     (0.0010, 0.0500, 1.0, 1.0),
        #     (0.0505, 0.0995, 0.5, 0.5),
        #     (0.1000, 0.500,  10.0, 10.0),
        #     (0.5050, 0.995,  5.0, 5.0),
        #     (1.0000, 5.0,  100.0, 5.0),
        #     (5.0500, 10.0, 100.0, None)   # 1M limit is datasheet is 50V, which seems wrong. Actual scope goes to 100.
        # )
        self._offset_range = namedtuple_min_max(-100, +100)

        self._position = namedtuple_min_max(-5, +5)

    def setup(self, channel, scale=None, position=None, coupling=None, invert=None, bandwidth=None, label=None,
              offset=None, termination=None, dsp_bw_enhance=None, *args, **kwargs):
        """
        Query all or set any combination of oscope vertical parameters for a specified channel.

        :param channel: Channel number: 1 - 4.
        :type channel: int
        :param scale: volts per division.
        :type scale: int|float
        :param position: Screen position in divisions.  Will warn on out-of-bounds, but scope will set to
            min/max allowed.
        :type position: int|float
        :param coupling: 'AC', 'DC', 'GND'. Available options may depend may depend on probe type. 'GND' not available
            on 5000 series.
        :type coupling: str|enum_coupling
        :param invert: Accepts any of the values defined as on or off, always returns 'ON' or 'OFF'.
        :type invert: str|int|bool
        :param bandwidth: 'FULL' or a float value in Hz. With float value, oscope uses closest available setting based
            on probe type and setting of **dsp_bw_enhance**. Will warn if the resulting value does not match supplied
            float value.
        :type bandwidth: str|float
        :param label: Text to display on the oscope screen along with the trace. Up to 30 characters.
        :type label: str
        :param offset: voltage, range depends on scale and coupling. Will warn on out-of-bounds, but scope will set to
            min/max allowed.
        :type offset: float
        :param termination: Without probe connected 1e6 or 50 Ohms. If dictated by probe, attempting to set will be
            ignored and a warning generated.
        :type termination: float
        :param dsp_bw_enhance: Selects the "Digital Filters DSP Enabled" option vs the "Analog Only" option.

            AUTO
                DSP filters are used to enhance bandwidth - restricts **bandwidth** choices to those choices
                in the scope Vertical Setup GUI *not marked HW*. If the requested bandwidth is less than the lowest
                non-HW choice, the scope will set the bandwidth to the lowest non-HW choice and a warning is
                generated.
            OFF
                Restricts **bandwidth** choices to those *marked HW* in the scope Vertical Setup GUI. If the
                requested bandwidth is not a HW choice the scope sets the bandwidth to the minimum HW choice that
                exceeds the requested bandwidth.
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # CH<x>:SCAle <NR3>
        # CH<x>:POSition <NR3>
        # CH<x>:COUPling {AC | DC | DCREJect}  # Actually has GND not DCREJ
        # CH<x>:TERmination {FIFty|MEG|<NR3>}
        # CH<x>:INVert {ON|OFF}
        # CH<x>:BANdwidth {FULl|<NR3>}
        # CH<x>:LABel:NAMe <Qstring>
        # CH<x>:OFFSet <NR3>

        # CH<x>:PRObe:GAIN?
        # CH<x>:BANdwidth:ENHanced

        self.log_unused_args(args, kwargs)

        if channel not in self._channel_numbers:
            msg = ", ".join([f"{c}" for c in self._channel_numbers])
            raise ValueError(f"Bad channel: {channel}, should be one of {msg}.")

        probe_type = self.query(f"CH{channel}:PROBE:ID:TYPE", str).strip('"')
        if re.match('TAP\d{4}', probe_type):
            enum_coupling = self.enum_coupling_tap
        elif re.match('TCP\d{4}', probe_type):
            enum_coupling = self.enum_coupling_tcp
        elif re.match('TDP\d{4}', probe_type):
            enum_coupling = self.enum_coupling_tdp
        else:
            enum_coupling = self.enum_coupling

        if all(v is None for v in {scale, position, coupling, invert, bandwidth, label, offset, termination,
                                   dsp_bw_enhance}):
            return_vals = {}
            return_vals.update(scale=self.query(f"CH{channel}:SCA?", float))
            return_vals.update(position=self.query(f"CH{channel}:POS?", float))
            return_vals.update(coupling=self.query(f"CH{channel}:COUP?", enum_coupling).name)
            return_vals.update(invert=self.on_off.to_api(self.query(f"CH{channel}:INV?", int)))
            return_vals.update(bandwidth=self.query(f"CH{channel}:BAN?", float))
            tmp = self.query(f"CH{channel}:{self._cmd_label_name}", str).strip('"').strip()
            return_vals.update(label='' if tmp.isspace() else tmp)
            return_vals.update(offset=self.query(f"CH{channel}:OFFS?", float))
            return_vals.update(termination=self.query(f"CH{channel}:TERM?", float))
            return_vals.update(dsp_bw_enhance=self.query(f"CH{channel}:BAN:ENH", self.enum_dsp_bw_enhance).name)
            return return_vals

        # Check all settings before applying.

        probe_type = self.query(f"CH{channel}:PROBE:ID:TYPE", str).strip('"')
        termination_state = self.query(f"CH{channel}:TERM?", float)

        if termination is not None:
            if termination not in [50, 1e6]:
                raise ValueError(f"Bad termination value: {termination}, should be 50 or 1e6.")
            if probe_type in self._probes_setting_termination:
                self.log.warning(f"Requested termination {termination} ignored. Termination is set by probe "
                                 f"'{probe_type}'.")
                termination = None   # Prevent subsequent write.
            else:
                self.log.warning(f"You are setting termination to {termination} Ohms for unknown probe type "
                                 f"'{probe_type}'.")
                termination_state = termination

        probe_gain = self.query(f"CH{channel}:PROBE:GAIN", float)
        input_range = self._get_input_range_1x(termination_state)

        scale_min, scale_max = [v / probe_gain for v in input_range]

        if scale is not None:
            if not isinstance(scale, (int, float)) or scale < scale_min or scale > scale_max:
                raise ValueError(f"Bad scale value {scale}, should be {scale_min:4.3f} to {scale_max} Volts / Div")

        coupling = check_enum_str('coupling', coupling, enum_coupling)
        if isinstance(termination_state, (int, float)) and math.isclose(termination_state, 50.0) and coupling == 'AC':
            self.log.warning(f"AC coupling is not allowed with 50 Ohm termination. Defaulting to DC.")

        invert = self.on_off.to_inst(invert)

        dsp_bw_enhance = check_enum_str('dsp_bw_enhance', dsp_bw_enhance, self.enum_dsp_bw_enhance)
        if dsp_bw_enhance is None:
            dsp_bw_enhance_state = self.query(f"CH{channel}:BAN:ENH", self.enum_dsp_bw_enhance)
        else:
            dsp_bw_enhance_state = dsp_bw_enhance

        if bandwidth is not None:
            # Scope does round up to nearest supported BW, we exploit this to allow instrument substitution,
            # that's why there is not a numeric range check here.
            if bandwidth != 'FULL' and not isinstance(bandwidth, (int, float)):
                raise ValueError(f"Bad bandwidth {bandwidth}, should be 'FULL' or a numeric value.")

        if label is not None and (not isinstance(label, str) or len(label) > 30):
            raise ValueError(f"Bad label {label}, should be string not longer than 30 characters.")

        if offset is not None:
            if not(isinstance(offset, (int, float)) and (self._offset_range.min <= offset <= self._offset_range.max)):
                raise ValueError(f"Bad offset {offset} V, outside maximum limits of {self._offset_range.min} V "
                                 f"to {self._offset_range.max} V.")

        # Offsets larger than datasheet limit seem to cause no errors and result in scope clamping offset to it's
        # extreme for the volts/div range. In addition, the extreme it clamps to is sometimes less than the datasheet
        # value. For these reasons I gave up on trying to pre-check the offset for the scale.

        if position is not None:
            if not (self._position.min <= position <= self._position.max):
                position_actual = min(max(position, self._position.min), self._position.max)
                self.log.warning(f"Requested position {position} outside range {self._position.min} to "
                                 f"{self._position.max}. Setting to {position_actual}.")
                # position = position_actual

        # If we got here all new values are good, write them to instrument:

        if termination is not None:
            self.write(f"CH{channel}:TER", termination)  # Scale max and coupling depend on this, order matters!
            actual_termination = self.query(f"CH{channel}:TER", float)
            if not math.isclose(termination, actual_termination):
                self.log.warning(f"Scope replaced requested termination {termination} with {actual_termination}.")
        if scale is not None:
            self.write(f"CH{channel}:SCA", scale)
        if coupling is not None:
            self.write(f"CH{channel}:COUP", coupling.value)
            actual_coupling = self.query(f"CH{channel}:COUP", enum_coupling)
            if coupling != actual_coupling:
                self.log.warning(f"Scope replaced requested coupling {coupling.name} with {actual_coupling.name}.")
        if invert is not None:
            self.write(f"CH{channel}:INV", self.on_off.to_inst(invert))
        if dsp_bw_enhance is not None:
            self.write(f"CH{channel}:BAN:ENH", dsp_bw_enhance.value)
        if bandwidth is not None:
            self.write(f"CH{channel}:BAN", bandwidth)
            actual_bandwidth = self.query(f"CH{channel}:BAN?", float)
            if bandwidth == 'FULL' or not math.isclose(bandwidth, actual_bandwidth):
                tmp1 = f"'{bandwidth}'" if isinstance(bandwidth, str) else f"{bandwidth:1.5G} Hz"
                tmp2 = f"'{termination_state}'" if isinstance(termination_state, str) else f"{termination_state:1.5G}" \
                                                                                           f" Ohms"
                self.log.warning(f"Bandwidth {tmp1} replaced with {actual_bandwidth:1.5G} Hz for dsp_bw_enhance="
                                 f"'{dsp_bw_enhance_state.name}' and termination={tmp2}")
        if label is not None:
            self.write(f"CH{channel}:{self._cmd_label_name}", f'"{label}"')
        if offset is not None:
            # Since offset bounds vary with volts/div settings, inform the user when the scope clamps the offset to a
            # value other than what they asked for.
            self.write(f"CH{channel}:OFFS", offset)
            actual_offset = self.query(f"CH{channel}:OFFS", float)
            if not math.isclose(offset, actual_offset):
                self.log.warning(f"Requested offset {offset} V replaced by scope with {actual_offset} V. ")

        if position is not None:
            self.write(f"CH{channel}:POS", position)

        self.log_inst_errors()

    def probe_setup_TCP(self, channel, probe_range=None, degauss_autozero=None):
        """
        Query range and degauss state or set range and/or execute a degauss on a **current** probe.

        :param channel: Integers 1-4 for normal oscope vertical channels, or 'AUXIN' for oscope Aux In input.
        :type channel: int|str
        :param probe_range: 5 or 30. Units are Amps.
        :type probe_range: int|float
        :param degauss_autozero: True causes a degauss autozero operation to start. This takes about 26 seconds to
            complete. The start and end of the operation are logged as info messages. An degauss autozero operation
            that does not return a PASSED result raises a RuntimeError.
        :type degauss_autozero: bool
        :return: Dict with keys 'probe_range', 'degauss_state' reflecting present conditions.
        :rtype: dict
        """

        # CH<x>:PRObe:FORCEDRange <dynamicRangeNR3>
        # CH<x>:PRObe:AUTOZero EXECute
        # CH<x>:PRObe:DEGAUSS EXECute
        # CH<x>:PRObe:DEGAUSS:STATE?

        if isinstance(channel, str):
            m = re.match('^(DPO|MSO)5\d{3}', self.scope.get_model())   # Includes B models.
            if m is not None and channel == 'AUXIN':
                raise ValueError(f"Bad channel '{channel}', 5000 series oscopes do not provide the functionality on "
                                 f"the AUXIN input needed for TCP series probes.")
            if channel != 'AUXIN':
                raise ValueError(f"Bad channel {channel}, should be int 1 through {self._num_chan} or 'AUXIN.")
        elif isinstance(channel, int):
            if channel not in self._channel_numbers:
                raise ValueError(f"Bad channel, should be int 1 through {self._num_chan} or 'AUXIN'.")
            channel = f"CH{channel}"
        else:
            raise ValueError(f"Bad channel, should be int 1 through {self._num_chan} or 'AUXIN'.")

        probe_type = self.query(f'{channel}:PRO:ID:TYP').strip('"')
        if re.match('^TCP0030A{0,1}$', probe_type) is None:
            raise ValueError(f"Invalid probe '{probe_type}' on {channel}. Expected TCP0030, TCP0030A.")

        return_values = {}
        if probe_range is not None:
            if probe_range not in (5, 30):
                raise ValueError(f"Bad probe_range {probe_range}, should be int or float, 5 or 30 Amps.")
            self.write(f'{channel}:PRO:FORCEDR', probe_range)

        return_values.update(probe_range=self.query(f'{channel}:PRO:FORCEDR', float))

        if degauss_autozero:
            pyvisa_timeout = self.scope.rm_handle.timeout
            msg_prefix = f"Degauss operation on channel {channel} TCP0030 probe"
            self.log.info(msg_prefix + ', starting.')
            self.write(f"{channel}:PRO:DEGAUSS", 'EXECUTE')
            degauss_timeout = 40.0
            time_start = time.monotonic()
            self.scope.rm_handle.timeout = 1000*degauss_timeout
            while (time.monotonic() - time_start) < degauss_timeout:
                # This polling doesn't seem to work as expected because query doesn't return until degauss is done.
                # So pyvisa timeout has to be long enough query doesn't timeout. Gross.
                cmd = f'{channel}:PRO:DEGAUSS:STATE'
                degauss_state = self.query(cmd)  # Seems to block here while degauss, so pyvisa timeout has to be long.
                if degauss_state != 'RUNNING':
                    break
                time.sleep(1)
            else:
                self.scope.rm_handle.timeout = pyvisa_timeout
                raise RuntimeError(f"{msg_prefix},  still running after {degauss_timeout:.2f} sec.")
            if degauss_state == 'PASSED':
                self.log.info(f"{msg_prefix}, state 'PASSED' after {(time.monotonic() - time_start):.2f} sec.")
            else:
                self.scope.rm_handle.timeout = pyvisa_timeout
                raise RuntimeError(f"{msg_prefix}, state '{degauss_state}' after {degauss_timeout:.2f} sec.")

            self.scope.rm_handle.timeout = pyvisa_timeout  # Put back the way it was.

        return_values.update(degauss_state=self.query(f'{channel}:PRO:DEGAUSS:STATE'))
        self.log_inst_errors()
        return return_values

    def probe_setup_TDP(self, channel, probe_range=None, bandwidth=None, coupling=None, autozero=None):
        """
        Query or set range, bandwidth and coupling and/or execute an autozero operation on a **differential voltage**
        probe.

        :param channel: Integers 1-4 for normal oscope vertical channels, or 'AUXIN' for oscope Aux In input.
        :type channel: int|str
        :param probe_range: 4.25 or 42.5. Units are Volts.
        :type probe_range: int|float
        :param bandwidth: On TDP1000 this will be 'FULL', 1e6, 10e3 or 100Hz. The latter three values correspond to the
            BW limit LEDs on the probe. With 'FULL' the bandwidth is controlled by the oscope vertical channel settings
            up to the limit of the probe. NOte: On 5000 series, if the bandwidth is set by the probe, it seems to always
            read back as 0 (scope FW bug?).
        :type bandwidth: float
        :param coupling: Is 'DC' or 'DCREJ'.  Is identical to the coupling setting of the vertical channel the probe is
            plugged into.
        :type coupling: str|enum_coupling_tdp
        :param autozero: True causes a autozero operation to start. Requires about 20 seconds to complete.
        :type autozero: None|bool
        :return: Dict with keys 'probe_range', 'bandwidth', 'coupling'.
        :rtype: dict
        """

        # CH<x>:PRObe:FORCEDRange <dynamicRangeNR3>
        # CH<x>:PRObe:AUTOZero EXECute
        # CH<x>:PRObe:DEGAUSS EXECute
        # CH<x>:PRObe:DEGAUSS:STATE?

        if isinstance(channel, str):
            m = re.match('^(DPO|MSO)5\d{3}', self.scope.get_model())   # Includes B models.
            if m is not None and channel == 'AUXIN':
                raise ValueError(f"Bad channel '{channel}', 5000 series oscopes do not provide the functionality on "
                                 f"the AUXIN input needed for TDP series probes.")
            if channel != 'AUXIN':
                raise ValueError(f"Bad channel {channel}, should be int 1 through {self._num_chan} or 'AUXIN.")
        elif isinstance(channel, int):
            if channel not in self._channel_numbers:
                raise ValueError(f"Bad channel, should be int 1 through {self._num_chan} or 'AUXIN'.")
            channel = f"CH{channel}"
        else:
            raise ValueError(f"Bad channel, should be int 1 through {self._num_chan} or 'AUXIN'.")

        probe_type = self.query(f'{channel}:PRO:ID:TYP').strip('"')
        if re.match('^TDP\d{4}$', probe_type) is None:
            raise ValueError(f"Invalid probe '{probe_type}' on {channel}. Expected TDP series (differential voltage) "
                             f"probe'.")

        if all([v is None for v in (probe_range, bandwidth, coupling, autozero)]):
            return_values = {}
            return_values.update(probe_range=self.query(f'{channel}:PRO:FORCEDR', float))
            return_values.update(bandwidth=self.query(f'{channel}:BANDWIDTH', float))
            return_values.update(coupling=self.query(f'{channel}:COUPLING', self.enum_coupling_tdp).name)
            return return_values

        if probe_range is not None:
            probe_range = check_numeric_vs_list('probe_range', probe_range, [4.25, 42.5])

        bw_list = ['FULL', 1e6, 10e3, 100.0]
        if bandwidth is not None and bandwidth not in bw_list:
            msg = ', '.join([f"'{v}'" if isinstance(v, str) else f"{v:g}" for v in bw_list])
            raise ValueError(f"Bad bandwidth {bandwidth}, should be one of {msg}.")

        coupling=check_enum_str('coupling', coupling, self.enum_coupling_tdp)

        if autozero is not None:
            if autozero not in (True, False):
                raise ValueError(f"Bad autozero {autozero}, should be None, True or False.")

        if probe_range is not None:
            self.write(f'{channel}:PRO:FORCEDR', probe_range)
        if bandwidth is not None:
            self.write(f'{channel}:BANDWIDTH', bandwidth)
        if coupling is not None:
            self.write(f'{channel}:COUPLING', coupling.value)

        if autozero is not None:
            az_delay = 25
            self.log.info(f"Starting autozero operation on {channel} {probe_type}. Takes about {az_delay} seconds.")
            self.write(f'{channel}:PROBE:AUTOZ EXECUTE')
            # If another command is issued before AUTOZ is complete, we get a pyvisa timeout. Unlike the TCP degauss,
            # there is no status query we can poll to see when AUTOZ is complete.
            time.sleep(25)
            self.log.info(f"Autozero operation on {channel} {probe_type}, should be complete now.")

        self.log_inst_errors()
