from enum import Enum
import math
import re

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.base_classes.tek_scopes.oscope_tek_base import namedtuple_min_max


class Vertical:
    def __init__(self, scope, **kwargs):
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.on_off = scope.on_off
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args

        if hasattr(scope, "_num_chan"):
            # This allows for MSO[456] code to pass in number of channels.
            self._num_chan = scope._num_chan
        else:
            # Existing DPO-MSO 5000 code relied on this.
            self._num_chan = 4

        self._channel_numbers = list(range(1, self._num_chan + 1))
        tmp = [f'CH{x}' for x in self._channel_numbers]
        self.enum_ch_names = Enum('enum_ch_names', tmp)

        self.enum_coupling = Enum('enum_coupling', {
            'AC': 'AC',
            'DC': 'DC',
            'GND': 'GND'
        })

        self._analog_input_ranges = (
            (1e6, namedtuple_min_max(2e-3, 5.0)),
        )

        self._offset_table = (
            (0.002, 0.200, 1.0, None),
            (0.200, 5.000, 25.0, None),
        )

        self._position = namedtuple_min_max(-4, +4)

        # Code in analog method uses f-string to prepend 'CH{x}' where x is channel number.
        self._cmd_label_name = 'LABEL'  # Older scope use just use 'CH<x>:LABEL', new ones use 'CH<x>:LABEL:NAME.

    def _get_input_range_1x(self, termination):
        for term, min_max in self._analog_input_ranges:
            if term == termination:
                return min_max
            elif isinstance(term, (int, float)) and isinstance(termination, (int, float)) and \
                    math.isclose(termination, term):
                return min_max
        raise ValueError(f"No entry in _analog_input_ranges for termination {termination}.")

    def setup(self, channel, scale=None, position=None, coupling=None, invert=None, bandwidth=None, label=None,
              offset=None, *args, **kwargs):
        """
        Query all or set any combination of oscope vertical parameters for a specified channel.

        :param channel: int channel number
        :param scale: volts per division
        :param position: -5 to +5 divisions.
        :param coupling: 'AC', 'DC', 'GND'. Options vary with probe type.
        :param invert: Accepts any of the values defined as on or off, always returns 'ON' or 'OFF'.
        :param bandwidth: 20e6, 250e6, and 'FULL'.
        :param label: str up to 30 characters.
        :param offset: voltage, range depends on scale and coupling. Will warn on out-of-bounds, but scope will set to
            min/max allowed.

        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # CH<x>:SCAle <NR3>
        # CH<x>:POSition <NR3>
        # CH<x>:COUPling {AC | DC | DCREJect}  # Actually has GND not DCREJ
        # CH<x>:INVert {ON|OFF}
        # CH<x>:BANdwidth {FULl|<NR3>}
        # CH<x>:LABel:NAMe <Qstring>
        # CH<x>:OFFSet <NR3>

        # CH<x>:PRObe:GAIN?

        skip_write = kwargs.pop('skip_write', False)
        self.log_unused_args(args, kwargs)

        if channel not in self._channel_numbers:
            msg = ", ".join([f"{c}" for c in self._channel_numbers])
            raise ValueError(f"Bad channel: {channel}, should be one of {msg}.")

        if all(v is None for v in {scale, position, coupling, invert, bandwidth, label, offset}):
            return_vals = {}
            return_vals.update(scale=self.query(f"CH{channel}:SCA?", float))
            return_vals.update(position=self.query(f"CH{channel}:POS?", float))
            return_vals.update(coupling=self.query(f"CH{channel}:COUP?", self.enum_coupling).name)
            return_vals.update(invert=self.on_off.to_api(self.query(f"CH{channel}:INV?", int)))
            return_vals.update(bandwidth=self.query(f"CH{channel}:BAN?", float))
            tmp = self.query(f"CH{channel}:{self._cmd_label_name}", str).strip('"').strip()
            return_vals.update(label='' if tmp.isspace() else tmp)
            return_vals.update(offset=self.query(f"CH{channel}:OFFS?", float))
            return return_vals

        # Check all settings before applying.

        # Termination cannot be set on DPO2024, it's always 1Meg and always reads back as such.  By reading it back
        # we have code that will work on another models where termination can be set.
        termination_state = self.query(f"CH{channel}:TER?", float)

        probe_gain = self.query(f"CH{channel}:PROBE:GAIN", float)
        input_range = self._get_input_range_1x(termination_state)
        input_min, input_max = [v / probe_gain for v in input_range]

        if scale is not None:
            if not isinstance(scale, (int, float)) or scale < input_min or scale > input_max:
                raise ValueError(f"Bad scale value {scale}, should be {input_min:4.3f} to {input_max} Volts / Div")

        coupling = check_enum_str('coupling', coupling, self.enum_coupling)

        invert = self.on_off.to_inst(invert)

        if bandwidth is not None:
            # Scope does round up to nearest supported BW, we exploit this to allow instrument substitution,
            # that's why there is not a numeric range check here.
            if bandwidth != 'FULL' and not isinstance(bandwidth, (int, float)):
                raise ValueError(f"Bad bandwidth {bandwidth}, should be 'FULL' or a numeric value.")

        if label is not None and (not isinstance(label, str) or len(label) > 30):
            raise ValueError(f"Bad label {label}, should be string not longer than 30 characters.")

        if offset is not None:
            if scale is None:
                scale_state = self.query(f"CH{channel}:SCA?", float)
            else:
                scale_state = scale

            offset_min, offset_max = self._chan_offset_range(scale_state, probe_gain, termination_state)
            # print(f"offset_min={offset_min}, offset_max={offset_max}")
            if not (offset_min <= offset <= offset_max):
                offset_actual = min(max(offset, offset_min), offset_max)
                self.log.warning(f"Requested offset {offset} outside range {offset_min} to {offset_max}. Setting to "
                                 f"{offset_actual}.")
                # offset = offset_actual

        if position is not None:
            if not (self._position.min <= position <= self._position.max):
                position_actual = min(max(position, self._position.min), self._position.max)
                self.log.warning(f"Requested position {position} outside range {self._position.min} to "
                                 f"{self._position.max}. Setting to {position_actual}.")
                # position = position_actual

        # If we got here all new values are good, write them to instrument:

        # A derived class might be using us just for some input checking...
        if skip_write:
            # Return to derived class so it can finish checking the rest of its parameters.
            return scale, position, termination_state, coupling, invert, bandwidth, label, offset

        if scale is not None:
            self.write(f"CH{channel}:SCA", scale)
        if coupling is not None:
            self.write(f"CH{channel}:COUP", coupling.value)
        if invert is not None:
            self.write(f"CH{channel}:INV", self.on_off.to_inst(invert))
        if bandwidth is not None:
            self.write(f"CH{channel}:BAN", bandwidth)
            actual_bandwidth = self.query(f"CH{channel}:BAN?", float)
            if bandwidth == 'FULL' or not math.isclose(bandwidth, actual_bandwidth):
                tmp = f"'{bandwidth}'" if isinstance(bandwidth, str) else f"{bandwidth:0.3e}"
                self.log.warning(f"Scope substituted requested bandwidth {tmp} with "
                                 f"{actual_bandwidth:0.3e}.")
        if label is not None:
            self.write(f"CH{channel}:{self._cmd_label_name}", f'"{label}"')
        if offset is not None:
            print(f"setting offset {offset}")
            self.write(f"CH{channel}:OFFS", offset)
        if position is not None:
            self.write(f"CH{channel}:POS", position)

        self.log_inst_errors()

    def _chan_offset_range(self, volts_per_div, probe_gain, termination):
        """
        Calculates analog input offset bounds, uses lookup table defined in __init__.

        :param volts_per_div:
        :param probe_gain:
        :param termination:
        :return: [offset_min offset_max]
        """

        scaled_setting = volts_per_div * probe_gain  # So same table works for both
        for low, high, onemeg, fifty in self._offset_table:
            if low <= scaled_setting <= high:
                if isinstance(termination, (int, float)) and math.isclose(termination, 50.0):
                    if probe_gain != 1.0:
                        raise ValueError(f"With 50 Ohm termination, expected probe gain of 1.0, not {probe_gain}.")
                    else:
                        return [-1.0 * fifty, fifty]
                elif isinstance(termination, (int, float)) and math.isclose(termination, 1e6):
                    return [-1.0 * onemeg / probe_gain, onemeg / probe_gain]  # reverse the scaling
                else:
                    raise ValueError(f"Bad termination value {termination}, expected 50.0 or 1e6.")

        raise ValueError(f"No offset range found for volts_per_div={volts_per_div}, probe_gain={probe_gain}, "
                         f"termination={termination}")

    def channel_display(self, on_list=None, off_list=None):
        """
        Query or specify which channels are displayed and which are not.

        :param on_list: List of channel numbers to display.
        :type on_list: List[int]
        :param off_list: List of channel numbers to not display. Takes precedence if a number also appears in on_list
        :type off_list: List[int]
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from scope.
        """

        # SELect:CH<x> {ON|OFF|1|0}

        if all([on_list is None, off_list is None]):
            on_list = []
            off_list = []
            for c in self._channel_numbers:
                v = self.query(f"SEL:CH{c}?", int)
                if v:
                    on_list.append(c)
                else:
                    off_list.append(c)
            return {'on_list': on_list, 'off_list': off_list}

        msg = ", ".join([f"{c}" for c in self._channel_numbers])
        if on_list is not None:
            bad = [c for c in on_list if c not in self._channel_numbers]
            if bad:
                raise ValueError(f"on_list: bad channels {bad}, should be from set {msg}.")

        if off_list is not None:
            bad = [c for c in off_list if c not in self._channel_numbers]
            if bad:
                raise ValueError(f"off_list: bad channels {bad}, should be from set {msg}.")

        if on_list is not None:
            for c in on_list:
                self.write(f"SEL:CH{c}",  "ON")

        if off_list is not None:
            for c in off_list:
                self.write(f"SEL:CH{c}", "OFF")

        self.log_inst_errors()

    def probe_status(self, channel='ALL'):
        """
        Returns information about the probes presently connected to the oscope.

        :param channel: Defaults to 'ALL' which fetches the probe information for all the oscope vertical channels
            and the 'AUXIN' input. Alternatively, channel may be an int corresponding to the vertical input channel
            number which can be 1 to the number of input channels or the string 'AUXIN'.
        :type channel: str|int
        :return: Either a dict containing the probe information for the specified channel, or an nested dict
            where the outer dict is keyed by channel number/'AUXIN' with values being a dict of the probe info for the
            channel identified by key. The keys for the probe info dict are:

            * 'probe_type' - The probe model number, eg. 'TCP0030', 'TCP0500B', 'TPP1000', 'TAP3500', etc. Basic \
                probes (non TekVPI) like the P6139B, identify with their attenuation factor, e.g. '10X'. \
                No probe (BNC input) identifies as '1X'.
            * 'units' - The display units. For a voltage probe this is 'V', for a current probe 'A".
            * 'gain' - The reciprocal of the probe attenuation factor. All 10:1 probes (VPI or not) return 0.1. No \
                probe (BNC input) returns 1.0
            * 'probe_range' - If applicable, the present setting, e.g for TCP0030 5.0 or 30.0 Amps. If not applicable: \
                'N/A'.
            * 'control' - Refers to how range is set, if applicable can be 'AUTO' or 'MANUAL. If not applicable \
                returns 'AUTO'.
            * 'serial_num' - Probe serial number, if applicable, otherwise 'N/A'.
            * 'degauss_state' - Only included for current probes. Is 'PASSED' if probe has been degaussed; is \
                'RUNNING' if a degauss operation is still in progress. (The Tek docs are not clear if any other values \
                are possible.)
            * 'bandwidth' - Only included for differential probes. On TDP1000 this will be 350e6, 1e6, 10e3 or 100Hz. \
                The latter three values corresponding to the BW limit LEDs on the probe. Is identical to the \
                bandwidth setting of the vertical channel the probe is plugged into.
            * 'coupling' -  Only included for differential probes. Is 'DC' or 'DCREJ'.  Is identical to the \
                coupling setting of the vertical channel the probe is plugged into.

        :rtype: dict | dict[dict]
        """

        # CH<x>:PRObe:AUTOZero EXECute
        # CH<x>:PRObe:DEGAUSS EXECute

        # CH<x>:PRObe:ID:TYPe?

        # CH<x>:PRObe:GAIN?
        # CH<x>:PRObe:FORCEDRange <dynamicRangeNR3>
        # CH<x>:PRObe:ID:SERnumber?
        # CH<x>:PRObe:DEGAUSS:STATE?

        # AUXIn:PROBEFunc:EXTAtten
        # AUXIn:PROBEFunc:EXTDBatten
        # CH<x>:PROBEFunc:EXTAtten <NR3>
        # CH<x>:PROBEFunc:EXTDBatten <NR3>

        msg = f"Bad channel {channel}, should be integer 1 through {self._num_chan}, 'AUXIN' or 'ALL'."

        if isinstance(channel, str):
            if channel == 'ALL':
                channels = self._channel_numbers
                channels.append('AUXIN')
            elif channel == 'AUXIN':
                channels = ['AUXIN']
            else:
                raise ValueError(msg)
        elif isinstance(channel, int):
            if channel not in self._channel_numbers:
                raise ValueError(msg)
            channels = [channel]
        else:
            raise ValueError(msg)

        return_all = {}

        for chan in channels:

            if chan == 'AUXIN':
                chan_id = 'AUXIN'
            else:
                chan_id = f'CH{chan}'

            probe_info = {}
            probe_info.update(probe_type=self.query(f'{chan_id}:PRO:ID:TYP').strip('"'))
            probe_info.update(units=self.query(f'{chan_id}:PRO:UNI').strip('"'))
            probe_info.update(gain=self.query(f'{chan_id}:PRO:GAIN'))
            probe_info.update(ext_atten=self.query(f'{chan_id}:PROBEFunc:EXTAtten', float))
            probe_info.update(probe_range=self.query(f'{chan_id}:PRO:FORCEDR'))

            if chan == 'AUXIN':
                probe_info.update(control='N/A')
            else:
                probe_info.update(control=self.query(f'{chan_id}:PROBECO'))

            probe_info.update(serial_num=self.query(f'{chan_id}:PRO:ID:SER').strip('"'))

            if re.match('^TCP\d{4}$', probe_info['probe_type']):
                probe_info.update(degauss_state=self.query(f'{chan_id}:PRO:DEGAUSS:STATE'))
                probe_info.update(coupling=self.query(f'{chan_id}:COUPLING', self.enum_coupling_tcp).name)

            if re.match('^TDP\d{4}$', probe_info['probe_type']):
                probe_info.update(bandwidth=self.query(f'{chan_id}:BANDWIDTH', float))
                probe_info.update(coupling=self.query(f'{chan_id}:COUPLING', self.enum_coupling_tdp).name)

            if channel == 'ALL':
                return_all.update({chan: probe_info})
            else:
                return probe_info

        return return_all

    def probe_setup(self, channel, ext_atten=None, ext_atten_db=None):
        """
        Allows querying or setting the external attenuation for the specified channel. Is useful with basic
        probes (non-TekVPI) whose characteristics cannot be automatically sensed by the oscope.

        For example, the Tek P2221 probe attenuation cannot be autodetected by the oscope, so you can used this
        method to set ext_atten to match the setting of the slide switch on the side of the probe (1X vs 10X).
        This gives you properly scaled voltage values on the scope.

        Value can be set using either  ext_atten or ext_atten_db but not both. Both are returned

        :param channel: Use integers 1 through 4 to specify one of the vertical input channels, use 'AUXIN' for the
            auxiliary trigger input.
        :type channel: int|str
        :param ext_atten: Attenuation factor (not gain factor). Can be 1e-10 to 1e+10. An attenuation factor of 10
            corresponds to an ext_atten_db value of 20 dB.
        :type ext_atten: float
        :param ext_atten_db: Attenuation factor expressed in dB.
        :type ext_atten_db: float
        :return: Returns dict of present setting, containing both ext_atten and ext_atten_db representations.
        :rtype: dict|None
        """

        # AUXIn:PROBEFunc:EXTAtten
        # AUXIn:PROBEFunc:EXTDBatten
        # CH<x>:PROBEFunc:EXTAtten <NR3>
        # CH<x>:PROBEFunc:EXTDBatten <NR3>

        if isinstance(channel, str):
            # m = re.match('^(DPO|MSO)5\d{3}', self.scope.get_model())   # Includes B models.
            # if m is not None and channel == 'AUXIN':
            #     raise ValueError(f"Bad channel '{channel}', 5000 series oscopes do not provide the functionality on "
            #                      f"the AUXIN input needed for TCP series probes.")
            if channel != 'AUXIN':
                raise ValueError(f"Bad channel {channel}, should be int 1 through {self._num_chan} or 'AUXIN.")
        elif isinstance(channel, int):
            if channel not in self._channel_numbers:
                raise ValueError(f"Bad channel, should be int 1 through {self._num_chan} or 'AUXIN'.")
            channel = f"CH{channel}"
        else:
            raise ValueError(f"Bad channel, should be int 1 through {self._num_chan} or 'AUXIN'.")

        if all([v is None for v in (ext_atten, ext_atten_db)]):
            return_values = {}
            return_values.update(ext_atten=self.query(f'{channel}:PROBEF:EXTA', float))
            return_values.update(ext_atten_db=self.query(f'{channel}:PROBEF:EXTDB', float))
            return return_values

        ext_atten = check_range('ext_atten', ext_atten, min_max_units(1e-10, 1e+10, "attenuation factor"))
        ext_atten_db = check_range('ext_atten_db', ext_atten_db, min_max_units(-200, 200, "dB attenuation factor"))

        if all([v is not None for v in (ext_atten, ext_atten_db)]):
            raise ValueError(f"You specified attenuation as both a ratio {ext_atten:4g} and in dB {ext_atten_db}, "
                             f"please specify using one or the other, not both.")

        if ext_atten is not None:
            self.write(f'{channel}:PROBEF:EXTA', ext_atten)
        if ext_atten_db is not None:
            self.write(f'{channel}:PROBEF:EXTDB', ext_atten_db)

        self.log_inst_errors()


