import re
import pyvisa
from collections import namedtuple
from cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types import *

# meas_dict mirrors the structure of the Select panel in DPOJET. Also, we could pull this in from a yml
# file or from some query on options installed in the scope.
# Key name must match what is returned from 'DPOJET:MEAS<x>:TYPE?'
meas_info = namedtuple('meas_info', 'cls editions')

meas_dict = {
    'period_freq': {       # All are in both Essentials and Advanced
        "PERIOD":          meas_info(MeasTypePeriodFreq,    ('DJE', 'DJA')),
        "NPERIOD":         meas_info(MeasTypeNPERIOD,       ('DJE', 'DJA')),
        "CCPERIOD":        meas_info(MeasTypeDuty,          ('DJE', 'DJA')),
        "PWIDTH":          meas_info(MeasTypeNoEdges,       ('DJE', 'DJA')),
        "NWIDTH":          meas_info(MeasTypeNoEdges,       ('DJE', 'DJA')),
        "PDUTY":           meas_info(MeasTypeDuty,          ('DJE', 'DJA')),
        "NDUTY":           meas_info(MeasTypeDuty,          ('DJE', 'DJA')),
        "PCCDUTY":         meas_info(MeasTypeNoEdges,       ('DJE', 'DJA')),
        "NCCDUTY":         meas_info(MeasTypeNoEdges,       ('DJE', 'DJA')),
        "FREQUENCY":       meas_info(MeasTypePeriodFreq,    ('DJE', 'DJA')),
        "DATARATE":        meas_info(MeasTypeDataRate,      ('DJE', 'DJA')),
    },
    'jitter': {            # All Advanced except TIE and PHASENOISE
        "TJBER":           meas_info(MeasTypeTJBER,         ('DJA',)),
        "PJ":              meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "RJ":              meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "DJ":              meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "DJDIRAC":         meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "RJDIRAC":         meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "SRJ":             meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "DDJ":             meas_info(MeasTypeDDJ,           ('DJA',)),
        "DCD":             meas_info(MeasTypeDCD,           ('DJA',)),
        "TIE":             meas_info(MeasTypeTIE,           ('DJE', 'DJA')),
        "FN":              meas_info(MeasTypeFbyN,          ('DJA',)),
        "J9":              meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "PHASENOISE":      meas_info(MeasTypePHASENOISE,    ('DJE', 'DJA')),
        "PJRMS":           meas_info(MeasTypeTJBER,         ('DJA',)),
        "J2":              meas_info(MeasTypeJitNoBER,      ('DJA',)),
        "SJFREQ":          meas_info(MeasTypeSJFREQ,        ('DJA',)),
    },
    'time': {              # All in both Essentials and Advanced, except RISESLEWRATE, FALLSLEWRATE
        "RISETIME":         meas_info(MeasTypeRiseFall,     ('DJE', 'DJA')),
        "FALLTIME":         meas_info(MeasTypeRiseFall,     ('DJE', 'DJA')),
        "SKEW":             meas_info(MeasTypeSkew,         ('DJE', 'DJA')),
        "SSCPROFILE":       meas_info(MeasTypeNoEdges,      ('DJE', 'DJA')),
        "HIGHTIME":         meas_info(MeasTypeNoEdges,      ('DJE', 'DJA')),
        "LOWTIME":          meas_info(MeasTypeNoEdges,      ('DJE', 'DJA')),
        "SETUP":            meas_info(MeasTypeSetupHold,    ('DJE', 'DJA')),
        "SSCMODRATE":       meas_info(MeasTypeNoEdges,      ('DJE', 'DJA')),
        "RISESLEWRATE":     meas_info(MeasTypeSlewRise,     ('DJA',)),
        "FALLSLEWRATE":     meas_info(MeasTypeSlewFall,     ('DJA',)),
        "HOLD":             meas_info(MeasTypeSetupHold,    ('DJE', 'DJA')),
        "SSCFREQDEV":       meas_info(MeasTypeNoEdges,      ('DJE', 'DJA')),
        "TIMEOUTSIDELEVEL": meas_info(MeasTypeLevel,        ('DJE', 'DJA')),
        "SSCFREQDEVMIN":    meas_info(MeasTypeSSC,          ('DJE', 'DJA')),
        "SSCFREQDEVMAX":    meas_info(MeasTypeSSC,          ('DJE', 'DJA')),
    },
    'eye': {               # Advanced only
        "WIDTH":            meas_info(MeasTypeEyeWidth,     ('DJA',)),
        "WIDTHBER":         meas_info(MeasTypeTJBER,        ('DJA',)),
        "HEIGHTBER":        meas_info(MeasTypeEyeHEIGHTBER, ()),
        "HEIGHT":           meas_info(MeasTypeEyeHEIGHT,    ()),
        "EYEHIGH":          meas_info(MeasTypeEyeHIGH,      ()),
        "QFACTOR":          meas_info(MeasTypeEyeHIGH,      ()),
        "MASKHITS":         meas_info(MeasTypeEyeMask,      ()),
        "EYELOW":           meas_info(MeasTypeEyeHIGH,      ()),
        "AUTOFITMASKHITS":  meas_info(MeasTypeEyeMaskAdv,   ()),
    },
    'ampl': {               # Advanced Only
        "HIGH":             meas_info(MeasTypeAmplHIGH,     ()),
        "COMMONMODE":       meas_info(MeasTypeCOMMONMODE,   ('DJA',)),
        "OVERSHOOT":        meas_info(MeasTypeAmpOVERSHOOT, ('DJA',)),
        "CYCLEMIN":         meas_info(MeasTypeNoEdges,      ('DJA',)),
        "LOW":              meas_info(MeasTypeAmplHIGH,     ()),
        "TNTRATIO":         meas_info(MeasTypeRiseFall,     ('DJA',)),
        "UNDERSHOOT":       meas_info(MeasTypeAmpOVERSHOOT, ('DJA',)),
        "CYCLEMAX":         meas_info(MeasTypeRiseFall,     ('DJA',)),
        "HIGHLOW":          meas_info(MeasTypeAmplHIGH,     ()),
        "VDIFFXOVR":        meas_info(MeasTypeVDIFFXOVR,    ('DJA',)),
        "CYCLEPKTOPK":      meas_info(MeasTypeNoEdges,      ('DJA',)),
        "ACCOMMONMODE":     meas_info(MeasTypeACCOMMONMODE, ('DJA',)),
    }
}

class Dpojet:
    """Provides methods to configure measurements and retrieve measurement data. This class in intended to be
    composed inside a DPO/MSO 5000/7000 series driver."""

    enum_control_buttons = Enum('enum_control_buttons', {'RUN': 'RUN', 'SINGLE': 'SINGLE', 'RECALC': 'RECALC',
                                'CLEAR': 'CLEAR', 'STOP': 'STOP'})

    def __init__(self, scope, edition, **kwargs):
        """
        Initializes references to objects in the enclosing scope object, creates enums for the measurement categories
        defined in meas_dict for the edition of DPOJET being used. Creates attributes corresponding to any existing
        measurements define in the DPOJET measurement list in the connected oscope.
        """

        # Some local attributes that lets us access these more easily and naturally.
        self.scope = scope
        self.log = scope.log
        self.write = scope.write
        self.query = scope.query
        self.on_off = scope.on_off
        self.log_inst_errors = scope.log_inst_errors
        self.log_unused_args = scope.log_unused_args
        self.get_inst_errors = scope.get_inst_errors

        self.edition = edition

        # Process the meas_dict to create a all-in-one dict for easy meas_type to class look-up.
        # Also, create enums for keys of each category. Store these in attributes.
        self._meas_class_dict = {}  # Categories are merged together, to simplify meas_type -> class lookup.
        self._meas_enums = []       # List containing the enums for each category.

        for category_name, category_values in meas_dict.items():
            # Add the meas_types
            meas_in_category = []
            for meas_type, info in category_values.items():
                if self.edition in info.editions:
                    self._meas_class_dict.update({meas_type: info})
                    meas_in_category.append(meas_type)

            if len(meas_in_category) > 0:
                enum_name = f"enum_{category_name}_measurements"
                self.__setattr__(enum_name, Enum(enum_name, meas_in_category))
                self._meas_enums.append(self.__getattribute__(enum_name))

        # self.write('DPOJET:ACTIVATE; *OPC')
        # self.write('*WAI')
        # print(f"busy={self.query('BUSY', int)}")
        self.get_inst_errors()   # Clear the instrument error buffer.
        time_start = time.monotonic()
        attempts = 0
        self.log.info(f"Activating DPOJET, please be patient, a cold start can take tens of seconds. ")
        while (time.monotonic() - time_start) < 40:
            try:
                num_meas = self.query('DPOJET:NUMMEAS', int)
                break
            except:
                attempts += 1
                self.log.info(f"Still waiting on DPOJET to startup....")
                time.sleep(10)
                self.get_inst_errors()  # Clear the instrument error buffer, there may be a  410,"Query INTERRUPTED"
        else:
            raise RuntimeError(f"DPOJET failed to start!")
        self.log.info(f"DPOJET initialized, found {num_meas} measurements already selected in oscope.")


        self._meas_obj_dict = {}  # MeasType objects, keyed by meas_name. Updated as user adds and deletes measurements.
        self.update_meas_objs()   # Scans scope for measurements, creates composed MeasType objects.

        self.log_inst_errors()

    def add_meas(self, meas_type, custom_name=None):
        """
        Adds a new measurement to the DPOJET measurement list in the oscope and creates the corresponding
        attribute / object in this driver that provides the methods to configure the measurement.

        By default the attribute name will be the same as meas_type with a 1 based integer appended to allow for
        multiple instances of the same type. (Each instance can be configured differently.) Alternatively,
        a custom name can be assigned.

        :param meas_type: String name of the measurement type, these are based on the icon names in the oscope GUI
            but have been made into legal Python identifiers. For the complete list see `Measurement Type Names`_.
            This driver also provides a set of enums corresponding to the categories shown in the select
            tabs of the DPOJET GUI: 'period_freq', 'jitter', 'time', 'eye', 'ampl'.
        :type meas_type: str|enum<category>_measurements
        :param custom_name: A custom name to assign to the measurement and the attribute. Must be a valid Python
            identifier.
        :type custom_name: str
        :return: The name as it will appear in DPOJET's list of selected measurements on the oscope.
        :rtype: str
        """

        meas_type = self._check_meas_type(meas_type)

        if custom_name is not None:
            if not isinstance(custom_name, str) or not custom_name.isidentifier():
                raise ValueError(f"Bad custom_name '{custom_name}' must be a str that is a valid Python identifier.")

        self.write('DPOJET:ADDM', meas_type.name)
        meas_num = self.query('DPOJET:NUMM', int)

        if custom_name is not None:
            meas_num = self.query('DPOJET:NUMM', int)
            self.write(f'DPOJET:MEAS{meas_num}:CUST', f'"{custom_name}"')

        self.get_inst_errors()

        # Before calling add_meas, the measurements list in the scope may have been altered through the GUI.
        # Since we have no way of knowing what they did, the safest thing to do is destroy and recreate all measurement
        # attributes.
        self.update_meas_objs()

        # Display uses the custom name if it exists.
        name = self.query(f'DPOJET:MEAS{meas_num}:CUST').strip('"')
        if name != '':
            return name
        else:
            return self.query(f'DPOJET:MEAS{meas_num}:NAME').strip('"')

    def clear_all_meas(self):
        """
        Clears all measurements from the DPOJET measurement list in the oscope. Deletes all the coresponding
        attributes from this driver.

        :return: None
        """

        self.write(f'DPOJET:CLEARALLM')
        self.update_meas_objs()

    # def clear_selected_meas(self):
    #     # There is no SCPI cmd to do this!?!?!
    #     # Could write code to pull existing state of all measurements from scope, delete all, then write back all but
    #     # the deleted. Will need to call all the state retrieval methods in each class. Fun!
    #     pass

    def get_display_names(self):
        """
        Queries the oscope to obtain the name of every measurement currently selected in DPOJET.

        :return: Display of name. This is the name as it appears in the DPOJET measurement list. It may be the
            default name of the measurement or it may be a custom defined name.
        :rtype: List[str]
        """

        # DPOJET:NUMMEAS?
        # DPOJET:MEAS<x>:NAME?

        num_meas = self.query('DPOJET:NUMMEAS', int)
        display_names = []
        for slot in range(1, num_meas+1):
            # Display uses the custom name if it exists.
            name = self.query(f'DPOJET:MEAS{slot}:CUST').strip('"')
            if name == '':
                name = self.query(f'DPOJET:MEAS{slot}:NAME').strip('"')
            display_names.append(name)

        return display_names

    # def preferences(self):
    #     pass

    def update_meas_objs(self):
        """
        Deletes the existing attributes in this driver that correspond(ed) to the measurements that selected in
        DPOJET, and recreates the measurement attributes base on what is currently defined in the oscope.

        Call this method if you have interacted with the scope DPOJET GUI to delete or add measurements.

        :return: None

        """

        # Purge the existing meas attributes
        # self.log.info('Purging attributes.')
        for meas_name in self._meas_obj_dict:
            delattr(self, meas_name)
        self._meas_obj_dict = {}

        attr_info = self._make_meas_attr_names()

        for meas_row in attr_info:   # (slot, display_name, meas_name, meas_type)
            self._add_meas_obj(*meas_row)

    def control_panel(self, button=None):
        """
        Query current DPOJET run state or transition to a new state. Corresponds to the "Control Panel" buttons found to
        the right of the DPOJET application GUI window.

        Note: This function will do nothing except log a warning if you attempt an operation that is not allowed in the
        present state of DPOJET. Note that you an use the readback form of this method to poll to see if DPOJET has
        transitioned back to the STOP state.

        :param button: Start and stop the sequence of operations for DPOJET to acquire information from the
            waveform and perform the selected measurements. Available choices depend on current run state.

            * CLEAR - Clears the current result display and resets any statistical results and autoset ref levels. \
                Is available if DPOJET is currently in RUN or STOP state.
            * RECALC - Runs the selected measurements on the current acquisition. Can only be executed from the STOP \
                state. Causes a transition to RUN state and back to STOP.
            * SINGLE - Initiates a new acquisition and runs the selected measurements. Can only be executed from the \
                STOP state. Causes a transition to RUN state and back to STOP.
            * RUN - Initiates a new acquisition and runs the selected measurements repeatedly until STOP is selected \
                or population limit is reached. Used only for live sources.
        :type button: str|enum_control_buttons
        :return: If button is None, current DPOJET state is read and returned, is either 'RUN' or 'STOP". Otherwise
            None.
        :rtype: str|None
        """

        # DPOJET:STATE {RUN | SINGLE | RECALC | CLEAR | STOP}

        state = self.query('DPOJET:STATE', self.enum_control_buttons).name

        if button is None:
            return state

        button = check_enum_str('button', button, self.enum_control_buttons)

        if state == 'RUN':
            allowed = ('CLEAR', 'STOP')
        elif state == 'STOP':
            allowed = ('CLEAR', 'RUN', 'SINGLE', 'RECALC')
        else:
            self.log.warn(f"DPOJET in unexpected state '{state}', button '{button.name}' ignored.")
            allowed = None

        if button.name not in allowed:
            msg = ', '.join([f"'{s}'" for s in allowed])
            self.log.warn(f"Cannot perform '{button.name} while DPOJET is in {state}. Only {msg} are allowed.")
        else:
            if allowed is not None:
                self.write('DPOJET:STATE', button.value)

        self.log_inst_errors()

    def _add_meas_obj(self, meas_num, display_name, meas_name, meas_type):
        """Create driver MeasType object that is appropriate for meas_type and add that object as an attribute of this
        driver object. Update the dictionary that maps meas_num to the object.

        :return: The name of the newly created attribute.
        :type return: str
        """

        info = self._meas_class_dict.get(meas_type)         # Get the class type for meas_type
        if info is None:
            self.log.warn(f"Oscope DPOJET selection list includes meas_type '{meas_type}' which is not supported "
                          f"in this version of the DPOJET driver.")
            return None
        obj = info.cls(self, meas_num, display_name, meas_name, meas_type)  # Instantiate the child object
        self._meas_obj_dict[display_name] = obj             # Add it to the dict, integer meas_name serves as key.
        setattr(self, display_name, obj)                 # Add attribute to hold obj reference.
        return display_name

    def __getattribute__(self, item):
        """When an attribute containing a measurement object is accessed, checks if corresponding measurement is in
        the DPOJET measurement list in the oscope and is of the same type.

        If not, possibly because user altered the list in the scope through the DPOJET GUI, a call to
        update_meas_objs is performed automatically to re-sync the driver attributes with the measurement list in
        the oscope.
        """

        item_obj = super().__getattribute__(item)
        if isinstance(item_obj, MeasTypes):
            attr_name = item_obj.display_name
            if not item_obj.exists_in_scope():
                self.log.warn(f"DPOJET meas '{attr_name}' not defined at location {item_obj.meas_num} in "
                              f"scope. Recreating attributes based on measurement list read from scope.")
                self.update_meas_objs()

            return self._meas_obj_dict.get(attr_name, None)

        return item_obj

    def _make_meas_attr_names(self):
        """
        Queries oscope DPOJET measurement list to obtain measurement names and types for each slot.

        :return: List of date for each measurement currently selected in DPOJET.
        :rtype:  List[Tuple(slot, display_name, meas_name, meas_type))]
        """

        data = []
        display_names = []

        num_meas = self.query('DPOJET:NUMMEAS', int)
        for slot in range(1, num_meas + 1):

            # Display uses the custom name if it exists. We want to name our attribute to match this.
            custom_name = self.query(f'DPOJET:MEAS{slot}:CUST').strip('"')
            meas_name = self.query(f'DPOJET:MEAS{slot}:NAME').strip('"')
            meas_type = self.query(f'DPOJET:MEAS{slot}:TYPE')
            if custom_name == '':
                display_name = meas_name
            else:
                display_name = custom_name

            # When user selects measurement type 'FN', scope inserts custom name of the form 'F/2', 'F/4', 'F/8'. These
            # automatically change if subrate_divisor is changed.

            if meas_type == 'FN':
                display_name = self._fn_name_handling(slot)

            if not display_name.isidentifier():
                # If user put weird characters in the Custom Name, then they have to fix it.
                self.log.warning(f"Attribute not created for measurement slot {slot} because name "
                                 f"'{display_name}' is not a valid Python identifier. Use DPOJET GUI to "
                                 f"modify Custom Name.")
                continue

            meas_type = self.query(f'DPOJET:MEAS{slot}:TYPE')
            data.append([slot, meas_name, meas_type])
            display_names.append(display_name)

        # The scope adds a numeric suffix to make multiple instances of the same measurement have unique name in the
        # measurement list. However, users could the custom measurement name in the configure->general panel to create
        # a name that does duplicate a name already in the list. We make such duplicates unique so we can use the names
        # for attributes by adding a suffix "_<n>" where n is an incrementing integer.
        unique_names = set(display_names)
        duplicate_names = [name for name in unique_names if display_names.count(name) > 1]
        dupe_suffixes = dict.fromkeys(duplicate_names, 0)  # A counter ofr each duplicate, start at 0.

        data_out = []
        for data_row, display_name in zip(data, display_names):
            slot, meas_name, meas_type = data_row
            if display_name in dupe_suffixes:
                dupe_suffixes[display_name] += 1
                display_name = f"{display_name}_{dupe_suffixes[display_name]}"
                self.write(f'DPOJET:MEAS{slot}:CUST', f'"{display_name}"')  # Make scope use our now unique name.
            data_out.append((slot, display_name, meas_name, meas_type))

        return data_out

    def _fn_name_handling(self, slot):

        custom_name = self.query(f'DPOJET:MEAS{slot}:CUST').strip('"')
        if re.match('^F(/|(over))[248]', custom_name):
            # Name might have been modified by user in which case it doesn't update with changes in subrate_divisor,
            # even if string provided strings looks like user put in is of the form 'F/2'.

            # Setting to a different value tricks scope into updating custom name to be responsive.
            subrate_divisor = self.query(f'DPOJET:MEAS{slot}:EDGES:SUBRATED')
            changed_divisor = {'TWO': 'FOUR', 'FOUR': 'TWO', 'EIGHT': 'TWO'}[subrate_divisor]
            self.write(f'DPOJET:MEAS{slot}:EDGES:SUBRATED', changed_divisor)
            self.write(f'DPOJET:MEAS{slot}:EDGES:SUBRATED', subrate_divisor)
            custom_name = self.query(f'DPOJET:MEAS{slot}:CUST').strip('"')
            custom_name = custom_name.replace('/', 'over')

            # Custom name user is not tied to subrate_divisor, so use it as is.
        return custom_name

    # def _rename_meas_attr(self, attr_name, new_name):
    #     obj = getattr(self, attr_name)
    #     self._meas_obj_dict.pop(attr_name)
    #     delattr(self, attr_name)
    #     setattr(self, new_name, obj)

    def _check_meas_type(self, meas_type):
        """
        Checks user input meas_type to see if it corresponds to an element of one of the multiple enums that define the
        various categories of measurements - returns matching enum element if any.

        None type input is just passed through. String input or enum elements are checked against the list of enums and
        the first matching enum element is returned. If no match, then an exception is raise explaining the available
        options.

        :param meas_type: String name or enum element to be checked. May also be None type which is just passed
            through.
        :type meas_type: None|str|enum element
        :return: None|enum element
        """

        if meas_type is None:
            return None

        # For other, we have split into multiple enums to match GUI organization. Have to look in all of them, so
        # can't use check_enum_str because that would raise exception if not in first enum we tried.
        for category in self._meas_enums:
            keys = category.__members__.keys()
            if meas_type in keys:
                return getattr(category, meas_type)  # Input was a string name.
            if meas_type in category:                # Input was an enum element.
                return meas_type

        # Nothing matched. Create error reporting text.

        msg = ''
        for category in self._meas_enums:
            keys = category.__members__.keys()
            key_str = ', '.join([f"'{k}'" for k in keys])
            if len(msg) > 0:
                msg += ';\n'
            msg += f"{category.__name__}: {key_str}"

        if isinstance(meas_type, Enum):  # Get the key name.
            meas_type = meas_type.name

        # Add message indicating measurement is supported in a different edition of DPOJET.
        msg_suffix = ''
        for category_name, category_values in meas_dict.items():
            if meas_type in category_values:
                editions = category_values[meas_type].editions
                if len(editions) > 0:
                    editions = ', '.join([f"'{e}'" for e in editions])
                    msg_suffix = f"meas_type '{meas_type}' not supported in DOJET edition '{self.edition}'. Requires " \
                                 f"edition {editions}"
                else:
                    msg_suffix = f"meas_type '{meas_type}' is a DOJET Advanced edition measurement that is " \
                                 f"not yet implemented in this driver."

        if msg_suffix != '':
            msg = msg + '\n' + msg_suffix

        raise ValueError(f"Bad meas_type '{meas_type}', can be one of:\n{msg}. ")
