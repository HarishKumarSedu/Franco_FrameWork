from enum import Enum
import time

from cl_instr_lib.base_classes.tek_scopes.dpojet.clk_recovery import *

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units

enum_sources = Enum('enum_sources', {
            'CH1': 'CH1', 'CH2': 'CH2', 'CH3': 'CH3', 'CH4': 'CH4',
            'REF1': 'REF1', 'REF2': 'REF2', 'REF3': 'REF3', 'REF4': 'REF4',
            'MATH1': 'MATH1', 'MATH2': 'MATH2', 'MATH3': 'MATH3', 'MATH4': 'MATH4'
        })

class SupressUnresolved:
    # Import into mix-in classes below to suppress inspections on these references.

    query: classmethod
    write: classmethod
    log_inst_errors: classmethod
    on_off: object
    log: object
    meas_num: int

class MeasTypes:
    """
    Base class for all of the DPOJET measurements the user may define in the oscope. This class provides methods common
    to all the  DPOJET MeasType* classes derived from it.

    Those derived classes provide the various config and other methods that are particular to a specific group of
    measurement types.
    """

    enum_autoset = Enum('enum_autoset', {'VERTSCALE': "VERT", 'HORIZRES': 'HORI', 'BOTH': 'BOTH'})
    autoset_time_max = 60

    enum_ref_units = Enum('enum_ref_units', {'PERCENT': '1', 'ABSOLUTE': '0'})
    enum_base_top_from = Enum('enum_base_top_from', {'AUTO': 'AUTO', 'MINMAX': 'MINMAX',
                                                     'HISTO_FULL': 'FULLHISTOGRAM', 'HISTO_EYE': 'EYEHISTOGRAM'})

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        self.container = container
        self.scope = container.scope

        # Some local attributes that lets us access these more easily and naturally.
        self.log = container.scope.log
        self.write = container.scope.write
        self.query = container.scope.query
        self.on_off = container.scope.on_off
        self.log_inst_errors = container.scope.log_inst_errors
        self.log_unused_args = container.scope.log_unused_args
        self.get_inst_errors = container.scope.get_inst_errors

        self.enum_sources = enum_sources

        self.enum_gating = Enum('enum_gating', {'OFF': 'OFF', 'ZOOM': 'ZOOM', 'CURSORS': 'CURSOR'})
        self.enum_qualify_sources = self.enum_sources
        self.enum_qualify_active = Enum('enum_qualify_active', {'HIGH': 'HIGH', 'LOW': 'LOW'})
        self.enum_population_limit_by = Enum('enum_population_limit_by', {'ACQ': 'ACQUISITIONS', 'POPU': 'POPULATION'})
        self.enum_population_condition = Enum('enum_population_condition', {'EACH_MEAS': 'EACHMEAS',
                                                                            'LAST_MEAS': 'LASTMEAS'})

        self.enum_results_acquisitions = Enum('enum_results_acquisitions', {'ALL': 'ALLA', 'CURR': 'CURR'})
        self.enum_results_stat_names = Enum('enum_results_stat_names', ['MEAN', 'STDD', 'MAX', 'MIN', 'PK2PK', 'POPU',
                                                                   'MAXCC', 'MINCC'])

        self._meas_num = meas_num
        self._display_name = display_name
        self._meas_name = meas_name
        self._meas_type = meas_type

        if isinstance(self, ClkRecoverySelect):
            self.config_clk_recovery_params = None
            self.update_clk_recovery_method()

    # Defining as properties to make these read only. If user were to assign to these - big problems!
    @property
    def meas_num(self):
        return self._meas_num

    @property
    def display_name(self):
        return self._display_name

    @property
    def meas_name(self):
        return self._meas_name

    @property
    def meas_type(self):
        return self._meas_type

    def config_general(self, range_limits=None, max_value=None, min_value=None, custom_name=None):
        """
        Query all or set any of the parameters that are on the Config->General tab.

        All DPOJET measurements have this tab and these parameters, but their values are **specific** to the particular
        measurement instance.

        :param range_limits: Enable or disable qualifying the measurement using the specified measurement
            limits. Accepts any of the values defined as on or off, always returns ‘ON’ or ‘OFF’.
        :type range_limits: str|int|bool
        :param max_value: Maximum value for valid measurement. If smaller than min, scope will set min to the same
            value.
        :type max_value: int|float
        :param min_value: Minimum value for valid measurement. If larger than max, scope will set max to the same value.
        :type min_value: int|float
        :param custom_name: Changes name of measurement as seen in the list of selected measurements in DPOJET and
            re-names the corresponding attribute in this driver to match. Consequently, custom_name must be a
            valid Python identifier: Upper and lower case letters, digits and underscore and cannot begin with a number.
        :type custom_name: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more values, return type is None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:MEASRange:STATE {1 | 0}
        # DPOJET:MEAS<x>:MEASRange:MAX <NR3>
        # DPOJET:MEAS<x>:MEASRange:MIN
        # DPOJET:MEAS<x>:CUSTomname <string>

        if all([v is None for v in (range_limits, max_value, min_value, custom_name)]):
            return_values = {}
            return_values.update(range_limits=self.on_off.to_api(self.query(f'DPOJET:MEAS{self.meas_num}:MEASR:STATE')))
            return_values.update(max_value=self.query(f'DPOJET:MEAS{self.meas_num}:MEASR:MAX', float))
            return_values.update(min_value=self.query(f'DPOJET:MEAS{self.meas_num}:MEASR:MIN', float))
            return_values.update(custom_name=self.query(f'DPOJET:MEAS{self.meas_num}:CUST').strip('"'))
            return return_values

        range_limits = self.on_off.to_inst(range_limits)

        # Skipping the usual checking for max_value and min_value because they vary for every single measurement.
        # Very labor intensive to build lookup table of values of all measurements. See p253 of manual.
        # max_value = check_range('max_value', max_value, self.bounds_range_limit_max)

        if max_value is not None and not isinstance(max_value, (int, float)):
            raise ValueError(f"Bad max_value '{max_value}', should be numeric.")
        max_value_state = max_value
        if max_value_state is None:
            max_value_state = self.query(f'DPOJET:MEAS{self.meas_num}:MEASR:MAX', float)

        # min_value = check_range('min_value', min_value, self.bounds_range_limit_min)
        if min_value is not None and not isinstance(min_value, (int, float)):
            raise ValueError(f"Bad max_value '{max_value}', should be numeric.")
        min_value_state = min_value
        if min_value_state is None:
            min_value_state = self.query(f'DPOJET:MEAS{self.meas_num}:MEASR:MIN', float)

        if max_value_state < min_value_state:
            # units = self.bound_range_limits.units
            if min_value is None:
                self.log.warn(f"max_value {max_value}, less than current min_value {min_value_state}. "
                              f"Scope will coerce min_value to {max_value}.")
            elif max_value is None:
                self.log.warn(f"min_value {min_value}, greater than current max_value {max_value_state}. "
                              f"Scope will coerce max_value to {min_value}.")
            else:
                self.log.warn(f"max_value {max_value}, less than min_value {min_value}. "
                              f"Scope will coerce max_value to {min_value}.")

        if range_limits is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:MEASR:STATE', range_limits)
        if max_value is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:MEASR:MAX', max_value)
        if min_value is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:MEASR:MIN', min_value)

        if custom_name is not None:
            if not isinstance(custom_name, str) or not custom_name.isidentifier():
                raise ValueError(f"Bad custom_name '{custom_name}' must be a str that is a valid Python identifier.")
            self.write(f'DPOJET:MEAS{self.meas_num}:CUST', f'"{custom_name}"')
            self.container.update_meas_objs()

        self.log_inst_errors()
    
    def config_global(self, gating=None, qualify=None, population=None):
        """
        Query all or set any of the parameters that are on the Config->Global tab.

        All DPOJET measurements instances have this tab and these parameters, but the values are NOT specific to a
        measurement instance. The values chosen here apply to all measurements.

        :param gating: Focus the analysis on the region of the waveform defined by:

            * OFF - No gating, measuremenst over entire waveform.
            * ZOOM - Zooms into specified region of the waveform and analysis is performed there.
            * CURSORS - Gates waveform with vertical cursors and analysis is performed within the cursors.
        :type gating: str|enum_gating
        :param qualify: Enable or disable using the Qualify With Logic conditions that can be defined using the
            method config_global_qualify. Accepts any of the values defined as on or off, always returns ‘ON’ or ‘OFF’.
        :type qualify: str|int|bool
        :param population: Enable or disable using the Population Limit conditions that can be defined using the method
            config_global_population. Accepts any of the values defined as on or off, always returns ‘ON’ or ‘OFF’.
        :type population: str|int|bool
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more vaulues, return type is None.
        :rtype: dict|None
        """

        # DPOJET:GATING {OFF | ZOOM | CURSOR | MARKS}
        # DPOJET:QUALify:STATE {1 | 0}
        # DPOJET:POPULATION:STATE {1 | 0}

        if all([v is None for v in (gating, qualify, population)]):
            return_values = {}
            return_values.update(gating=self.query('DPOJET:GATING', self.enum_gating).name)
            return_values.update(qualify=self.on_off.to_api(self.query('DPOJET:QUAL:STATE')))
            return_values.update(population=self.on_off.to_api(self.query('DPOJET:POPULATION:STATE')))
            return return_values

        gating = check_enum_str('gating', gating, self.enum_gating)
        qualify = self.on_off.to_inst(qualify)
        population = self.on_off.to_inst(population)

        if gating is not None:
            self.write('DPOJET:GATING', gating.value)
        if qualify is not None:
            self.write('DPOJET:QUAL:STATE', qualify)
        if population is not None:
            self.write('DPOJET:POPULATION:STATE', population)

        self.log_inst_errors()

    def config_global_qualify(self, qualify=None, source=None, active=None, mid_voltage=None, hysteresis=None):
        """
        Query or set qualifying conditions that must be met for measurements to be made.

        All sources for the measurement and qualify inputs must have same Horizontal Sample Rate, Record Length and
        Position for proper functioning.

        :param qualify: Enable or disable using the Qualify With Logic conditions. Identical to the qualify parameter of
            the method config_global. Accepts any of the values defined as on or off, always returns ‘ON’ or ‘OFF’.
        :type qualify: str|int|bool
        :param source: Signal or clock source 'CH1'-'CH4', 'REF1'-'REF4', 'MATH1'- 'MATH4'.
        :type source: str|enum_qualify_sources
        :param active: State of qualifier source waveform that enables measurements:

            * HIGH - Enables measurements in regions where the qualifier waveform is above the mid reference level.
            * LOW - Enables measurements in regions where the qualifier waveform is below the mid reference level
        :type active: str|enum_qualify_active
        :param mid_voltage: Vertical reference level of the qualifier source waveform.
        :type mid_voltage: int|float
        :param hysteresis: Value applied to the mid_voltage level to prevent small amounts of noise from producing
            multiple threshold crossings. Value in volts.
        :type hysteresis: int|float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more vaulues, return type is None.
        :rtype: dict|None
        """

        # DPOJET:QUALify:STATE {1 | 0}
        # DPOJET:QUALify:SOUrce {CH1 – CH4 | MATH1 - MATH4 | REF1 - REF4 | SEARCH0 – SEARCH8}
        # DPOJET:QUALify:ACTIVE {HIGH | LOW}
        # DPOJET:REFLevels:CH<x>:ABSolute:RISEMid <NR3>
        # DPOJET:REFLevels:CH<x>:ABSolute:FALLMid <NR3>
        # DPOJET:REFLevels:CH<x>:ABSolute:HYSTeresis <NR3>

        if all([v is None for v in (qualify, source, active, mid_voltage, hysteresis)]):
            return_values = {}
            return_values.update(qualify=self.on_off.to_api(self.query('DPOJET:QUAL:STATE')))
            source = self.query('DPOJET:QUAL:SOU', self.enum_qualify_sources).name
            return_values.update(source=source)
            active = self.query('DPOJET:QUAL:ACTIVE', self.enum_qualify_active).name
            return_values.update(active=active)

            if active == 'HIGH':
                cmd = f'DPOJET:REFL:{source}:ABS:RISEM'
            else:
                cmd = f'DPOJET:REFL:{source}:ABS:FALLM'
            return_values.update(mid_voltage=self.query(cmd, float))
            return_values.update(hysteresis=self.query(f'DPOJET:REFL:{source}:ABS:HYST', float))
            return return_values

        qualify = self.on_off.to_inst(qualify)

        source = check_enum_str('source', source, self.enum_qualify_sources)
        source_state = source  # Needed to create write cmd.
        if source_state is None:
            source_state = self.query('DPOJET:QUAL:SOU', self.enum_qualify_sources)

        active = check_enum_str('active', active, self.enum_qualify_active)
        active_state = active  # Needed to choose write cmd.
        if active_state is None:
            active_state = self.query('DPOJET:QUAL:ACTIVE', self.enum_qualify_active).name

        mid_voltage = check_range('mid_voltage', mid_voltage, min_max_units(-20, 20, 'V'))
        hysteresis = check_range('hysteresis', hysteresis, min_max_units(0, 10, 'V'))

        if qualify is not None:
            self.write('DPOJET:QUAL:STATE', qualify)
        if source is not None:
            self.write('DPOJET:QUAL:SOU', source.value)
        if active is not None:
            self.write('DPOJET:QUAL:ACTIVE', active.value)
        if mid_voltage is not None:
            if active_state.name == 'HIGH':
                cmd = f'DPOJET:REFL:{source_state.name}:ABS:RISEM'
            else:
                cmd = f'DPOJET:REFL:{source_state.name}:ABS:FALLM'
            self.write(cmd, mid_voltage)
        if hysteresis is not None:
            self.write(f'DPOJET:REFL:{source_state.name}:ABS:HYST', hysteresis)

        self.log_inst_errors()

    def config_global_population(self, population=None, limit_by=None, limit=None, condition=None):
        """
        Query or set the limit on the amount of waveform data to be analyzed.

        :param population: Enable or disable using the Population Limit conditions. Identical to population parameter of
            method config_global. Accepts any of the values defined as on or off, always returns ‘ON’ or ‘OFF’.
        :type population: str|int|bool
        :param limit_by: How the limit is defined:

            * ACQ - Limit by the number of acquisition cycles to be performed.
            * POPU - Limit by number of measurement observations that will be accumulated. Some measurements may \
                accumulate observations more quickly than others.
        :type limit_by: str|enum_population_limit_by
        :param limit: The number of acquisition cycles or measurement observations to be takeb before stopping
            sequencing.
        :type limit: int
        :param condition: Defines when sequencing stops:

            * EACH_MEAS - Each measurement stops accumulating as soon as it reaches the specified limit. Sequencing \
                does not stop until all measurements have reached the limit, at which time every measurement will have \
                exactly the limit.
            * LAST_MEAS - Sequencing continues and all measurements continue accumulating until the last (slowest \
                accumulating) measurement reaches the limit, at which time they all stop. When sequencing stops, all \
                measurements except one may have higher population than the limit.
        :type condition: str|enum_population_condition
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more values, return type is None.
        :rtype: dict|None
        """

        # DPOJET:POPULATION:STATE {1 | 0}
        # DPOJET:POPULATION:LIMITBY {ACQuisitions | POPUlation}
        # DPOJET:POPULATION:LIMIT <NR3>
        # DPOJET:POPULATION:CONDition {EACHmeas | LASTmeas}

        if all([v is None for v in (population, limit_by, limit, condition)]):
            return_values = {}
            return_values.update(population=self.on_off.to_api(self.query('DPOJET:POPULATION:STATE')))
            return_values.update(limit_by=self.query('DPOJET:POPULATION:LIMITBY', self.enum_population_limit_by).name)
            return_values.update(limit=self.query('DPOJET:POPULATION:LIMIT', int))
            return_values.update(condition=self.query('DPOJET:POPULATION:COND', self.enum_population_condition).name)
            return return_values

        population = self.on_off.to_inst(population)
        limit_by = check_enum_str('limit_by', limit_by, self.enum_population_limit_by)
        limit = check_range('limit', limit, min_max_units(1, 2**31-1, ''), val_type=int)
        condition = check_enum_str('condition', condition, self.enum_population_condition)

        if population is not None:
            self.write('DPOJET:POPULATION:STATE', population)
        if limit_by is not None:
            self.write('DPOJET:POPULATION:LIMITBY', limit_by.value)
        if limit is not None:
            self.write('DPOJET:POPULATION:LIMIT', limit)
        if condition is not None:
            self.write('DPOJET:POPULATION:COND', condition.value)

        self.log_inst_errors()

    def exists_in_scope(self):
        """Returns True if object corresponds to a measurement currently defined in the oscope's DPOJET
        measurement table, measurement type and name must match.
        """

        meas_type = self.query(f'DPOJET:MEAS{self._meas_num}:TYP')
        if meas_type != self.meas_type:
            return False

        # Display uses the custom name if it exists. We want to name our attribute to match this.
        meas_name = self.query(f'DPOJET:MEAS{self.meas_num}:NAME').strip('"')
        if meas_name != self._meas_name:
            return False

        return True

    def get_stat_data(self, acquisitions='ALL', stat_names=None):
        """
        Returns a dict of statistical data for the measurement.

        :param acquisitions: Defines the set of acquisitions over which the measurement result was obtained. Defaults
            to ALL.

            * ALL - All acquisitions since last CLEAR operation (see the control_panel method in the dpojet object).
            * CURR - The measurement results are just from the Current Acquisition as shown in the Results GUI.

        :type acquisitions: str|enum_results_acquisitions
        :param stat_names: Either a single string or a list of strings from the set 'MEAN', 'STDD', 'MAX', 'MIN',
            'PK2PK', 'POPU', 'MAXCC', 'MINCC'. Defaults to this full list. These are the keys of
            enum_results_stat_names.
        :type stat_names: str|List[str]
        :return: dict of the specified statistical results, keys are the specified stat_names. Values are floats.
        :rtype: dict
        """

        # DPOJET:MEAS<x>:RESULts:ALLAcqs:HITPopulation? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLAcqs:HITS? <NR3>
        # *  DPOJET:MEAS<x>:RESULts:ALLAcqs:MAX? <NR3>
        # * DPOJET:MEAS<x>:RESULts:ALLAcqs:MAXCC? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLAcqs:MAXHits? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLacqs:MAX:HIGHLimit? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLacqs:MAX:HIGHMArgin? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLacqs:MIN:LOWLimit? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLacqs:MIN:LOWMArgin? <NR3>
        # * DPOJET:MEAS<x>:RESULts:ALLAcqs:MEAN? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLacqs:MEAN:HIGHLimit? <NR3>
        # * DPOJET:MEAS<x>:RESULts:ALLAcqs:MIN? <NR3>
        # * DPOJET:MEAS<x>:RESULts:ALLAcqs:MINCC? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLAcqs:MINHits? <NR3>
        # * DPOJET:MEAS<x>:RESULts:ALLacqs:PK2PK? <NR3>
        # * DPOJET:MEAS<x>:RESULts:ALLAcqs:POPUlation? <NR1>
        # DPOJET:MEAS<x>:RESULts:ALLAcqs:SEG<x>:Hits? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLAcqs:SEG<x>:MAXHits? <NR3>
        # DPOJET:MEAS<x>:RESULts:ALLAcqs:SEG<x>:MINHits? <NR3>
        # * DPOJET:MEAS<x>:RESULts:ALLAcqs:STDDev? <NR3>

        # DPOJET:MEAS<x>:RESULts:CURRentacq:MAX? <NR3>
        # DPOJET:MEAS<x>:RESULts:CURRentacq:MAXCC? <NR3>
        # DPOJET:MEAS<x>:RESULts:CURRentacq:MEAN? <NR3>
        # DPOJET:MEAS<x>:RESULts:CURRentacq:MIN? <NR3>
        # DPOJET:MEAS<x>:RESULts:CURRentacq:MINCC? <NR3>
        # DPOJET:MEAS<x>:RESULts:CURRentacq:PK2PK? <NR3>
        # DPOJET:MEAS<x>:RESULts:CURRentacq:POPUlation? <NR1>
        # DPOJET:MEAS<x>:RESULts:CURRentacq:StdDev? <NR3>

        # DPOJET:MEAS<x>:RESULTS:STATus? <string>

        acquisitions = check_enum_str('acquisitions', acquisitions, self.enum_results_acquisitions)
        acquisitions = acquisitions.value

        msg = ', '.join([f"'{e.name}'" for e in self.enum_results_stat_names])
        msg = f"Bad stat_names '{stat_names}', should be a single key (string) from " \
              f"enum_results_stat_names, or a list of such strings.\nValid stat_names are {msg}."

        stat_names_list = list(self.enum_results_stat_names.__members__.keys())

        if stat_names is None:
            # Default to dumping out all stats, so make a list of all the names as strings.
            pass
        elif isinstance(stat_names, str):
            # Allow for user input a a single string.
            stat_names = check_enum_str('stat_names', stat_names, self.enum_results_stat_names).name
            stat_names_list = [stat_names]  # Convert to list of str.
        elif isinstance(stat_names, list):
            stat_names_list = []
            for element in stat_names:
                stat_names_list.append(check_enum_str('stat_names', element, self.enum_results_stat_names).name)
        elif not isinstance(stat_names, list):
            raise ValueError(msg)

        data = {}
        for name in stat_names_list:
            if name == 'POPU':
                data_type = int
            else:
                data_type = float
            scpi_cmd = f"DPOJET:MEAS{self.meas_num}:RESUL:{acquisitions}:{name}"
            data[name] = self.query(scpi_cmd, data_type)

        return data

    # def get_status(self):
    #     """
    #     If test limits were defined, return PASS/FAIL results.
    #     """
    #
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:LIMits:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:LIMits:HIgh:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:LIMits:LOw:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:MAXCC:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:MAX:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLAcqs:MEAN:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLAcqs:MINCC:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLAcqs:MIN:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:PK2PK:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:POPUlation:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:ALLacqs:STDDEV:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:MAXCC:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:MAX:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:MEAN:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:MINCC:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:MIN:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:PK2PK:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:POPUlation:STATus? {PASS | FAIL}
    #     # DPOJET:MEAS<x>:RESULts:CURRentacq:STDDev:STATus? {PASS | FAIL}
    #     pass

    def delete(self):
        # NO SCPI cmd that does this, may be more complicated ways to make this happen.
        pass

    def _reflevels(self, source_name, ref_units=None, high=None, mid=None, low=None, fall_high=None,
                   fall_mid=None, fall_low=None, base_top_from=None, hysteresis=None, autoset_enable=None):
        """
        Helper function used to implement reflevels on a per source basis, this is called by individual measurements
        with their current source selection. Also, provides common code for handling measurements that have two sources,
        examples: DELAY, SETUP, HOLD.

        The DPOJET SCPI command set appears to lack a command for controlling the Advanced checkbox in the GUI. If
        Advanced is NOT checked, then the high, mid, and low parameters apply to both the rising and falling edges.
        If Advanced IS checked, then the thresholds for the falling edge can be independently set using the
        parameters fall_high, fall_mid, and fall_low.

        :param source_name: Can be one of

            * CH<x> - Channel specific thresholds, <x> is input channel number, 1-4
            * MATH<x> - MATH waveform specific threshold. <x> is the MATH id, 1-4
            * REF<x>  - REF waveform specific threshold. <x> is the REF id, 1-4
        :param ref_units: Determines units of ref level values:

            * 'PERCENT' - As a percentage of the difference between the top and base of the waveform. The
                base_top_from parameter chooses one of several methods of determining the top and base.
            * 'ABSOLUTE' - As a voltage value.
        :type ref_units: str|enum_ref_units
        :param high: The high threshold specified in the units defined by ref_units.
        :type high: float
        :param mid: The mid threshold specified in the units defined by ref_units.
        :type mid: float
        :param low: The low threshold specified in the units defined by ref_units.
        :type low: float
        :param fall_high: The high threshold specified in the units defined by ref_units.
        :type fall_high: float
        :param fall_mid: The mid threshold specified in the units defined by ref_units.
        :type fall_mid: float
        :param fall_low: The low threshold specified in the units defined by ref_units.
        :type fall_low: float
        :param base_top_from: The method used with PERCENT units to determine the top and base of the waveform:

            * AUTO - automatically chooses a reference level method.
            * MINMAX - reference levels are relative to the measurement MIN and MAX.
            * HISTO_MEAN - reference levels are relative to the histogram mean BASE and TOP.
            * HISTO_MODE - reverence levels are relative to the eye histogram BASE and TOP
        :type base_top_from: str|enum_base_top_from
        :param hysteresis: Sets the hysteresis of the ref levels using the same units as ref_units. Percent of top
            base or volts in the case of absolute units.
        :type hysteresis: float
        :param autoset_enable: If 'ON' and ref_units is currently 'PERCENT', then a reflevel autoset will be performed
            on the source during the next acquisition. This determines the voltage levels corresponding to the
            percentage thresholds. Accepts 'ON'/'OFF', 0/1, True/False. ALways returns 'ON'/'OFF'.
        :type autoset_enable: str|int|bool
        :return: None
        """

        # DPOJET:REFLevels:CH<x>:AUTOSet {1 | 0}           #  Can also be MATH<x> or REF<x>. 1 =  percent, 0 = absolute
        # DPOJET:REFLevels:CH<x>:ABSolute:RISEHigh <NR3>
        # DPOJET:REFLevels:CH<x>:ABSolute:RISELow <NR3>
        # DPOJET:REFLevels:CH<x>:ABSolute:RISEMid <NR3 >
        # DPOJET:REFLevels:CH<x>:ABSolute:FALLHigh <NR3>
        # DPOJET:REFLevels:CH<x>:ABSolute:FALLLow <NR3>
        # DPOJET:REFLevels:CH<x>:ABSolute:FALLMid <NR3>
        # DPOJET:REFLevels:CH<x>:ABSolute:HYSTeresis <NR3>
        # DPOJET:REFLevels:CH<x>:BASETop {MINMax | FULLhistogram | EYEhistogram | AUTO}
        # DPOJET:REFLevels:CH<x>:PERcent:FALLHigh <NR3>
        # DPOJET:REFLevels:CH<x>:PERcent:FALLLow <NR3>
        # DPOJET:REFLevels:CH<x>:PERcent:FALLMid <NR3>
        # DPOJET:REFLevels:CH<x>:PERcent:PERCENTReflevel {1 | 0}   # 1=Percentage, 0=Absolute
        # DPOJET:REFLevels:CH<x>:PERcent:HYSTeresis <NR3>
        # DPOJET:REFLevels:CH<x>:PERcent:RISEHigh <NR3>
        # DPOJET:REFLevels:CH<x>:PERcent:RISELow <NR3>
        # DPOJET:REFLevels:CH<x>:PERcent:RISEMid <NR3>
        # DPOJET:REFLevels:CH<x>:AUTOSet {1 | 0}

        source_name = check_enum_str(source_name, source_name, self.enum_sources).name

        if all([v is None for v in (ref_units, high, mid, low, fall_high, fall_mid, fall_low, base_top_from,
                                    hysteresis, autoset_enable)]):
            return_values = {}
            # Used the name "units" for consistency with 5000 series driver, values are 'PERCENT', 'ABSOLUTE'.
            # Determines which SCPI cmds to use for thresholds etc.
            ref_units_name = self.query(f'DPOJET:REFL:{source_name}:PER:PERCENTR', self.enum_ref_units).name
            return_values.update(ref_units=ref_units_name)
            return_values.update(high=self.query(f'DPOJET:REFL:{source_name}:{ref_units_name}:RISEH', float))
            return_values.update(mid=self.query(f'DPOJET:REFL:{source_name}:{ref_units_name}:RISEM', float))
            return_values.update(low=self.query(f'DPOJET:REFL:{source_name}:{ref_units_name}:RISEL', float))
            return_values.update(fall_high=self.query(f'DPOJET:REFL:{source_name}:{ref_units_name}:FALLH', float))
            return_values.update(fall_mid=self.query(f'DPOJET:REFL:{source_name}:{ref_units_name}:FALLM', float))
            return_values.update(fall_low=self.query(f'DPOJET:REFL:{source_name}:{ref_units_name}:FALLL', float))
            if ref_units_name == 'PERCENT':
                return_values.update(base_top_from=self.query(f'DPOJET:REFL:{source_name}:BASET'))
            return_values.update(hysteresis=self.query(f'DPOJET:REFL:{source_name}:{ref_units_name}:HYST', float))
            return_values.update(autoset_enable=self.on_off.to_api(self.query(f'DPOJET:REFL:{source_name}:AUTOS')))
            return return_values

        ref_units = check_enum_str('ref_units', ref_units, self.enum_ref_units)
        if ref_units is not None:
            ref_units_name = ref_units.name
        else:
            ref_units_name = self.query(f'DPOJET:REFL:{source_name}:PER:PERCENTR', self.enum_ref_units).name

        scope = locals()
        # Check for appropriate use of ref level inputs for the rising edge and also for the falling edge
        # if ref_type='SAME'.
        names = ('high', 'mid', 'low')
        indices = [i for i, name in enumerate(names) if eval(name, scope) is not None]
        if len(indices) > 0:
            if ref_units_name == 'PERCENT':
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(1, 100, '%'))
            else:
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(-100, 100, 'V'))

        # These are used in the scope for the falling edge if ref_type='ABS_UNIQUE' or 'PCNT_CUSTOM'.
        names = ('fall_high', 'fall_mid', 'fall_low')
        indices = [i for i, name in enumerate(names) if eval(name, scope) is not None]
        if len(indices) > 0:
            if ref_units_name == 'PERCENT':
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(1, 100, '%'))
            else:
                for i in indices:
                    check_range(names[i], eval(names[i], scope), min_max_units(-100, 100, 'V'))

        base_top_from = check_enum_str('base_top_from', base_top_from, self.enum_base_top_from)
        if base_top_from is not None:
            if ref_units_name != 'PERCENT':
                raise ValueError(f"base_top_from is not a choice with ref_units '{ref_units_name}', "
                                 f"only 'PERCENT'.")

        if ref_units_name == 'PERCENT':
            check_range('hysteresis', hysteresis, min_max_units(0, 50, '%'))
        else:
            check_range('hysteresis', hysteresis, min_max_units(-100, 100, 'V'))

        autoset_enable = self.on_off.to_inst(autoset_enable)

        # End of input validation checks - now write to the scope.

        if ref_units is not None:
            self.write(f'DPOJET:REFL:{source_name}:PER:PERCENTR', ref_units.value)
        if high is not None:
            self.write(f'DPOJET:REFL:{source_name}:{ref_units_name}:RISEH', high)
        if mid is not None:
            self.write(f'DPOJET:REFL:{source_name}:{ref_units_name}:RISEM', mid)
        if low is not None:
            self.write(f'DPOJET:REFL:{source_name}:{ref_units_name}:RISEL', low)
        if fall_high is not None:
            self.write(f'DPOJET:REFL:{source_name}:{ref_units_name}:FALLH', fall_high)
        if fall_mid is not None:
            self.write(f'DPOJET:REFL:{source_name}:{ref_units_name}:FALLM', fall_mid)
        if fall_low is not None:
            self.write(f'DPOJET:REFL:{source_name}:{ref_units_name}:FALLL', fall_low)
        if base_top_from is not None:
            self.write(f'DPOJET:REFL:{source_name}:BASET', base_top_from.value)
        if hysteresis is not None:
            self.write(f'DPOJET:REFL:{source_name}:{ref_units_name}:HYST', hysteresis)
        if autoset_enable is not None:
            self.write(f'DPOJET:REFL:{source_name}:AUTOS', autoset_enable)

        self.log_inst_errors()

    def ref_levels_autoset(self):
        """
        This command performs an autoset on the DPOJET ref levels on any signal sources selected that have
        the  autoset_enable  set to 'ON'. Call this function to manually cause the calculation of the voltage levels
        corresponding to any reference levels that have been selected to be defined in terms of percentage of base-top.
        Note that oscope acquisitions must be running for the ref_level_auto set to occur.

        Also, this autoset is distinct from the DPOJET source autoset that adjusts vertical scale and horizontal
        timebase. The source autoset can be invoked through the config_source method of the particular measurement.

        :return: None
        """

        # DPOJET:REFLevels:AUTOSet

        self.write('DPOJET:REFL:AUTOS', 'EXEC')

        self.log_inst_errors()

# ======================================================================================================================
# "Mix-in classes" - these are not intended to be instantiated directly. They are used to add various config methods
# (corresponding to the Configure tabs in the GUI) via inheritance into the classes derived from MeasType. These
# derived classes each support one or more of the measurements. See manual p 261 for table of measurements and the
# combination of configure tabs they require.

class EdgesClkedge(SupressUnresolved):

    enum_clk_edge = Enum('enum_clk_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})

    def config_edge(self, clk_edge=None):
        """
        Queries or sets the parameter of the Configure->Edges for those measurements having just a clk_edge
        parameter. Such measurements as: CCPERIOD, PDUTY, NDUTY.

        :param clk_edge: Choose the edge: 'RISE', 'FALL', 'BOTH'.
        :type clk_edge: str|enum_clk_edge
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if clk_edge is None:
            return_value = {}
            return_value.update(clk_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE', self.enum_clk_edge).name)
            return return_value

        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)

        if clk_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE', clk_edge.value)

        self.log_inst_errors()


class EdgesMain(SupressUnresolved):

    enum_main_edge = Enum('enum_main_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})

    def config_edge(self, main_edge=None):
        """
        Queries or sets the parameter of the Configure->Edges for those measurements having just a main_edge
        parameter. Such measurements as: VDIFFXOVR.

        :param main_edge: Choose the edge: 'RISE', 'FALL', 'BOTH'.
        :type main_edge: str|enum_clk_edge
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if main_edge is None:
            return_value = {}
            return_value.update(main_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE', self.enum_main_edge).name)
            return return_value

        main_edge = check_enum_str('main_edge', main_edge, self.enum_main_edge)

        if main_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE', main_edge.value)

        self.log_inst_errors()


class EdgesSignaltype(SupressUnresolved):
    enum_signal_type = Enum('enum_signal_type', {'CLOCK': 'CLOCK', 'DATA': 'DATA', 'AUTO': 'AUTO'})

    def config_edge(self, signal_type=None):
        """
        Queries or sets the parameter of the Configure->Edges for those measurements having just a signal_type
        parameter. Such measurements as: DCD.

        :param signal_type: Choose the edge: 'CLOCK', 'DATA', 'AUTO'.
        :type signal_type: str|enum_clk_edge
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if signal_type is None:
            return_value = {}
            return_value.update(signal_type=self.query(f'DPOJET:MEAS{self.meas_num}:SIGNALT',
                                                       self.enum_signal_type).name)
            return return_value

        signal_type = check_enum_str('signal_type', signal_type, self.enum_signal_type)

        if signal_type is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:SIGNALT', signal_type.value)

        self.log_inst_errors()


class EdgesSignaltypeClkedge(SupressUnresolved):
    enum_signal_type = Enum('enum_signal_type', {'CLOCK': 'CLOCK', 'DATA': 'DATA', 'AUTO': 'AUTO'})
    enum_clk_edge = Enum('enum_clk_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})

    def config_edge(self, signal_type=None, clk_edge=None):
        """
        Queries or sets the parameters of the Configure->Edges for those measurements having both a signal_type
        and a clk_edge parameter. Applies to: PERIOD, FREQUENCY, PJ, RJ, DJ, DJDIRAC, PJDIRAC, SRJ, J9, J2, SJFREQ,
        TIE, TJBER.

        :param signal_type: Choose the edge: 'CLOCK', 'DATA', 'DATA'.
        :type signal_type: str|enum_clk_edge
        :param clk_edge: Choose the edge: 'RISE', 'FALL', 'BOTH'.
        :type clk_edge: str|enum_clk_edge
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (signal_type, clk_edge)]):
            return_value = {}
            return_value.update(signal_type=self.query(f'DPOJET:MEAS{self.meas_num}:SIGNALT',
                                                       self.enum_signal_type).name)
            return_value.update(clk_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE', self.enum_clk_edge).name)
            return return_value

        signal_type = check_enum_str('signal_type', signal_type, self.enum_signal_type)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)

        if clk_edge is not None:
            if signal_type is None:
                signal_type_state = self.query(f'DPOJET:MEAS{self.meas_num}:SIGNALT', self.enum_signal_type)
            else:
                signal_type_state = signal_type
            if signal_type_state.name == 'DATA':
                self.log.warn(f"Selecting clk_edge '{clk_edge.name} will have no effect while signal_type is 'DATA'.")

        if signal_type is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:SIGNALT', signal_type.value)
        if clk_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE', clk_edge.value)

        self.log_inst_errors()


class EdgesSignaltypeClkedgeN(SupressUnresolved):
    enum_signal_type = Enum('enum_signal_type', {'CLOCK': 'CLOCK', 'DATA': 'DATA', 'AUTO': 'AUTO'})
    enum_clk_edge = Enum('enum_clk_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})

    def config_edge(self, signal_type=None, clk_edge=None, N=None, edge_increment=None):
        """
        Queries or sets the parameters of the Configure->Edges for the NPERIOD measurement.

        :param signal_type: Choose the edge: 'CLOCK', 'DATA', 'AUTO'.
        :type signal_type: str|enum_clk_edge
        :param clk_edge: Choose the edge: 'RISE', 'FALL', 'BOTH'.
        :type clk_edge: str|enum_clk_edge
        :param N: Specifies number of cycles or unit interval in each N-period group.
        :type N: int
        :param edge_increment: Specifies the temporal displacement in edges between consecutive measurements.
        :type edge_increment: int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (signal_type, clk_edge, N, edge_increment)]):
            return_value = {}
            return_value.update(signal_type=self.query(f'DPOJET:MEAS{self.meas_num}:SIGNALT',
                                                       self.enum_signal_type).name)
            return_value.update(clk_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE', self.enum_clk_edge).name)
            return_value.update(N=self.query(f'DPOJET:MEAS{self.meas_num}:N', int))
            return_value.update(edge_increment=self.query(f'DPOJET:MEAS{self.meas_num}:EDGEI', int))
            return return_value

        signal_type = check_enum_str('signal_type', signal_type, self.enum_signal_type)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)
        N = check_range('N', N, min_max_units(1, int(1e6), ''), val_type=int)
        edge_increment = check_range('edge_increment', edge_increment, min_max_units(1, int(10e3), ''), val_type=int)

        if clk_edge is not None:
            if signal_type is None:
                signal_type_state = self.query(f'DPOJET:MEAS{self.meas_num}:SIGNALT', self.enum_signal_type)
            else:
                signal_type_state = signal_type
            if signal_type_state.name == 'DATA':
                self.log.warn(f"Selecting clk_edge '{clk_edge.name} will have no effect while signal_type is 'DATA'.")

        if signal_type is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:SIGNALT', signal_type.value)
        if clk_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE', clk_edge.value)
        if N is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:N', N)
        if edge_increment is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGEI', edge_increment)

        self.log_inst_errors()


# noinspection SpellCheckingInspection
class EdgesSignaltypeClkedgeSubrate(SupressUnresolved):
    enum_signal_type = Enum('enum_signal_type', {'CLOCK': 'CLOCK', 'DATA': 'DATA', 'AUTO': 'AUTO'})
    enum_clk_edge = Enum('enum_clk_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})
    enum_subrate_divisor = Enum('enum_subrate_divisor', {'TWO': 'TWO', 'FOUR': 'FOUR', 'EIGHT': 'EIGHT'})

    def config_edge(self, signal_type=None, clk_edge=None, subrate_divisor=None):
        """
        Queries or sets the parameters of the Configure->Edges for the measurement FN.

        Note that the scope attempts to name the measurements F/2, F/4, F/8 depending on the value of subrate_divisor.
        Because such name sare not valid Python identifers, the corresponding attribute names in this driver will be
        Fby2, Fby4, Fby8. Altering subrate_divisor on an existing measurement will cause a rescan of the scope
        measurement list and re-creation of the measurement attributes in the driver. If a custom name is applied to
        an F/N measurement, then changing subrate_divisor will cause the custom name to be deleted.

        :param signal_type: Choose the edge: 'RISE', 'FALL', 'BOTH'.
        :type signal_type: str|enum_clk_edge
        :param clk_edge: Choose the edge: 'RISE', 'FALL', 'BOTH'.
        :type clk_edge: str|enum_clk_edge
        :param subrate_divisor: Specifies the subrate divisor value 2, 4 or 8 which is used to define the F/2, F/4, F/8
            jitter measurement.
        :type subrate_divisor: int
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (signal_type, clk_edge, subrate_divisor)]):
            return_value = {}
            return_value.update(signal_type=self.query(f'DPOJET:MEAS{self.meas_num}:SIGNALT',
                                                       self.enum_signal_type).name)
            return_value.update(clk_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE', self.enum_clk_edge).name)
            return_value.update(subrate_divisor=self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:SUBRATED',
                                                    self.enum_subrate_divisor).name)
            return return_value

        signal_type = check_enum_str('signal_type', signal_type, self.enum_signal_type)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)
        subrate_divisor = check_enum_str('subrate_divisor', subrate_divisor, self.enum_subrate_divisor)

        if clk_edge is not None:
            if signal_type is None:
                signal_type_state = self.query(f'DPOJET:MEAS{self.meas_num}:SIGNALT', self.enum_signal_type)
            else:
                signal_type_state = signal_type
            if signal_type_state.name == 'DATA':
                self.log.warn(f"Selecting clk_edge '{clk_edge.name} will have no effect while signal_type is 'DATA'.")

        if signal_type is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:SIGNALT', signal_type.value)
        if clk_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE', clk_edge.value)
        if subrate_divisor is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGES:SUBRATED', subrate_divisor.value)

            # Because scope may  create a custom name like F/8 that cannot be used as an attribute name,
            self.container.update_meas_objs()

        self.log_inst_errors()


class EdgesFromTo(SupressUnresolved):
    enum_from_edge = Enum('enum_from_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})
    enum_to_edge = Enum('enum_to_edge', {'SAME': 'SAMEAS', 'OPPOSITE': 'OPPOSITEAS'})

    def config_edge(self, from_edge=None, to_edge=None):
        """
        Queries all or set any combination of Configure->Edges parameters for the SKEW measurement.

        :param from_edge: Choose RISE, FALL, or BOTH.
        :type from_edge: str|enum_from_edge
        :param to_edge: SAME (as from edge) or OPPOSITE (of the from edge).
        :type to_edge: str|enum_to_edge
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (from_edge, to_edge)]):
            return_value = {}
            return_value.update(from_edge=self.query(f'DPOJET:MEAS{self.meas_num}:FROM',
                                                     self.enum_from_edge).name)
            return_value.update(to_edge=self.query(f'DPOJET:MEAS{self.meas_num}:TOE', self.enum_to_edge).name)
            return return_value

        from_edge = check_enum_str('from_edge', from_edge, self.enum_from_edge)
        to_edge = check_enum_str('to_edge', to_edge, self.enum_to_edge)

        if from_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:FROM', from_edge.value)
        if to_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:TOE', to_edge.value)

        self.log_inst_errors()


# noinspection PyUnresolvedReferences
class EdgesSlew(SupressUnresolved):
    enum_slew_technique = Enum('enum_slew_technique', {'NOMINAL': 'NOMINALMETHOD', 'DDR': 'DDRMETHOD'})

    # enum_from_level, enum_to_level are define in the derived classes.

    # TODO: Split this for ease of documentation - re. from_level, to_level choices.

    def config_edge(self, from_level=None, to_level=None, slew_technique=None):
        """
        Queries all or set any combination of Configure->Edges parameters for the measurements RISESLEWRATE,
        FALLSLEWRATE.

        :param from_level: Available choices depend on measurement:

             RISESLEWRATE - from_level can be 'MID' or 'LOW'.
             FALLSLEWRATE = from_level can be 'MID' or 'HIGH'.
        :type from_level:
        :param to_level:
        :type to_level:
        :param slew_technique:
        :type slew_technique:
        :return:
        :rtype:
        """

        if all([v is None for v in (from_level, to_level, slew_technique)]):
            return_value = {}
            return_value.update(from_level=self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:FROML',
                                                      self.enum_from_level).name)
            return_value.update(to_level=self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:TOL', self.enum_to_level).name)
            return_value.update(slew_technique=self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:SLEWRATET',
                                                     self.enum_slew_technique).name)
            return return_value

        from_level = check_enum_str('from_level', from_level, self.enum_from_level)
        to_level = check_enum_str('to_level', to_level, self.enum_to_level)
        slew_technique = check_enum_str('slew_technique', slew_technique, self.enum_slew_technique)

        from_state = from_level
        if from_state is None:
            from_state = self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:FROML', self.enum_from_level)
        to_state = to_level
        if to_state is None:
            to_state = self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:TOL', self.enum_to_level)
        if from_state.name == to_state.name:
            raise ValueError(f"from_level and to_level cannot both be '{from_state.name}'.")

        if from_level is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGES:FROML', from_level.value)
        if to_level is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGES:TOL', to_level.value)
        if slew_technique is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGES:SLEWRATET', slew_technique.value)

        self.log_inst_errors()


class EdgesClkData(SupressUnresolved):
    enum_clk_edge = Enum('enum_clk_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})
    enum_data_edge = Enum('enum_data_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})

    def config_edge(self, clk_edge=None, data_edge=None):
        """
        Queries or sets the parameter of the Configure->Edges for those measurements having a clk_edge and a
        data_edge parameter. Applies to measurements: SETUP, HOLD.

        :param clk_edge: RISE, FALL, or BOTH.
        :type clk_edge: str|enum_clk_edge
        :param data_edge: RISE, FALL, or BOTH.
        :type data_edge: str|enum_data_edge
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (clk_edge, data_edge)]):
            return_value = {}
            return_value.update(clk_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE1', self.enum_clk_edge).name)
            return_value.update(data_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE2',
                                                     self.enum_data_edge).name)
            return return_value

        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)
        data_edge = check_enum_str('data_edge', data_edge, self.enum_data_edge)

        if clk_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE1', clk_edge.value)
        if data_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE2', data_edge.value)

        self.log_inst_errors()


class EdgesLevel(SupressUnresolved):
    enum_level = Enum('enum_level', {'HIGH': 'HIGH', 'LOW': 'LOW', 'BOTH': 'BOTH'})
    bounds_ref_volts = min_max_units(-100, 100, 'V')

    def config_edge(self, level=None, high_ref_volts=None, low_ref_volts=None):
        """
        Queries or sets the parameters of Configure->Edges for the measurement TIMEOUTSIDELEVEL.

        :param level: Chooses which waveform excursions are included in the measurement:

            HIGH - Time Outside Level measurement is computed only in overshoot using High Ref Level.
            LOW - Time Outside Level measurement is computed only in undershoot using Low Ref Level.
            BOTH - Time Outside Level measurement is computed in both overshoot and undershoot using High and Low
            Ref Levels.

        :type level: str|enum_level
        :param high_ref_volts: The the high reference voltage level. Used when level is HIGH or BOTH.
        :type high_ref_volts: float
        :param low_ref_volts: The the low reference voltage level. Used when level is LOW or BOTH.
        :type low_ref_volts: float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (level, high_ref_volts, low_ref_volts)]):
            return_value = {}
            return_value.update(level=self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:LEV', self.enum_level).name)
            return_value.update(high_ref_volts=self.query(f'DPOJET:MEAS{self.meas_num}:HIGHREFV', float))
            return_value.update(low_ref_volts=self.query(f'DPOJET:MEAS{self.meas_num}:LOWREFV', float))
            return return_value

        level = check_enum_str('level', level, self.enum_level)
        high_ref_volts = check_range('high_ref_volts', high_ref_volts, self.bounds_ref_volts)
        low_ref_volts = check_range('low_ref_volts', low_ref_volts, self.bounds_ref_volts)

        level_state = level
        if level_state is None:
            level_state = self.query(f'DPOJET:MEAS{self.meas_num}:EDGES:LEV', self.enum_level)
        if level_state.name == 'HIGH' and low_ref_volts is not None:
            self.log.warn(f"The selected level is '{level_state.name}', so setting low_ref_volts to "
                          f"{low_ref_volts} V will have no effect on the measurement.")
        elif level_state.name == 'LOW' and high_ref_volts is not None:
            self.log.warn(f"The selected level is '{level_state.name}', so setting high_ref_volts to "
                          f"{high_ref_volts} V will have no effect on the measurement.")

        if level is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGES:LEV', level.value)
        if high_ref_volts is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:HIGHREFV', high_ref_volts)
        if low_ref_volts is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:LOWREFV', low_ref_volts)

        self.log_inst_errors()


class EdgesRefVoltage(SupressUnresolved):
    bounds_ref_volts = min_max_units(-100, 100, 'V')

    def config_edge(self, ref_volts=None):
        """
        Queries or sets the parameters of Configure->Edges for the measurements OVERSHOOT, UNDERSHOOT.

        :param ref_volts: The voltage level that defines an overshoot or undershoot event.
        :type ref_volts: float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        if ref_volts is None:
            return_value = {}
            return_value.update(ref_volts=self.query(f'DPOJET:MEAS{self.meas_num}:REFV', float))
            return return_value

        ref_volts = check_range('ref_volts', ref_volts, self.bounds_ref_volts)

        if ref_volts is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:REFV', ref_volts)

        self.log_inst_errors()


class RjDjBER(SupressUnresolved):
    enum_rjdj_mode = Enum('enum_rjdj_mode', {'MANUAL': '0', 'AUTO': '1'})
    enum_rjdj_pattern_type = Enum('enum_rjdj_pattern_type', {'ARBITRARY': 'ARBITRARY', 'REPEATING': 'REPEATING'})
    bounds_pattern_length = min_max_units(2, 1_000_000, 'UI')

    def config_rjdj(self, mode=None, pattern_type=None, pattern_length=None,
                    window_length=None, target_ber_exponent=None):
        if all([v is None for v in (mode, pattern_type, pattern_length, window_length, target_ber_exponent)]):
            return_value = {}
            return_value.update(mode=self.query(f"DPOJET:MEAS{self.meas_num}:RJDJ:DETECTPLEN",
                                                self.enum_rjdj_mode).name)

            pattern_type = self.query(f"DPOJET:MEAS{self.meas_num}:RJDJ:TYP", self.enum_rjdj_pattern_type).name
            return_value.update(pattern_type=pattern_type)
            if pattern_type == 'ARBITRARY':
                return_value.update(window_length=self.query(f"DPOJET:MEAS{self.meas_num}:RJDJ:WINDO", float))
            else:
                return_value.update(pattern_length=self.query(f"DPOJET:MEAS{self.meas_num}:RJDJ:PATL", float))

            return_value.update(target_ber_exponent=self.query(f"DPOJET:MEAS{self.meas_num}:RJDJ:BER", float))
            return return_value

        mode = check_enum_str('mode', mode, self.enum_rjdj_mode)

        pattern_type = check_enum_str('pattern_type', pattern_type, self.enum_rjdj_pattern_type)
        pattern_type_state = pattern_type
        if pattern_type_state is None:
            pattern_type_state = self.query(f"DPOJET:MEAS{self.meas_num}:RJDJ:TYP", self.enum_rjdj_pattern_type)

        pattern_length = check_range('pattern_length', pattern_length, min_max_units(2, 1_000_000, 'UI'))
        if pattern_type_state.name == 'ARBITRARY' and pattern_length is not None:
            self.log.warn(f"Setting pattern_length {pattern_length}, will have no effect since pattern_type is "
                          f"'{pattern_type_state.name}'.")

        window_length = check_range('window_length', window_length, min_max_units(2, 24, 'UI'))
        if pattern_type_state.name == 'REPEATING' and window_length is not None:
            self.log.warn(f"Setting window_length {window_length}, will have no effect since pattern_type is "
                          f"'{pattern_type_state.name}'.")

        target_ber_exponent = check_range('target_ber_exponent', target_ber_exponent, min_max_units(2, 18, ''))

        if mode is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:RJDJ:DETECTPLEN", mode.value)
        if pattern_type is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:RJDJ:TYP", pattern_type.value)
        if pattern_length is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:RJDJ:PATL", pattern_length)
        if window_length is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:RJDJ:WINDO", window_length)
        if target_ber_exponent is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:RJDJ:BER", target_ber_exponent)

        self.log_inst_errors()


class RjDj(RjDjBER):

    # noinspection PyMethodOverriding
    def config_rjdj(self, mode=None, pattern_type=None, pattern_length=None,
                    window_length=None):
        return_values = super().config_rjdj(mode, pattern_type, pattern_length, window_length,
                                            target_ber_exponent=None)
        if return_values is not None:
            return_values.pop('target_ber_exponent')


class BitTypeUIrange:
    def config_bit_type(self, bit_type, start_pcnt, end_pcnt, num_bins):
        pass

class BitType:
    def config_bit_type(self, bit_type):
        pass

class BitTypeXpcnt:
    def config_bit_type(self, bit_type, ui_x_pcnt):
        pass

class BitTypeMask:
    def config_bit_type(self, bit_type, mask_file):
        pass

class BitTypeMaskAdv:
    def config_bit_type(self, bit_type, mask_file, mask_offset):
        pass

class BitTypeCenter:
    def config_bit_type(self, bit_type, center_pcnt, method):
        pass

class BER:
    def config_ber(self, target_ber_exponent):
        pass

class Filters(SupressUnresolved):
    enum_filter_hp_order = Enum('enum_filter_hp_order', {
        'NONE': 'NONE', 'FIRST': 'FIRST', 'SECOND': 'SECOND', 'THIRD': 'THIRD'})
    enum_filter_lp_order = Enum('enum_filter_hp_order', {
        'NONE': 'NONE', 'FIRST': 'FIRST', 'SECOND': 'SECOND', 'THIRD': 'THIRD'})

    def config_filters(self, hp_order=None, hp_freq_hz=None, lp_order=None, lp_freq_hz=None, ramp_time=None,
                       blanking_time=None):
        """
        Query all or set any of the parameters that are on the Config->Filters tab. Modifies the measurement data by
        applying a High Pass Filter IIR and/or a Low Pass Filter IIR filters to the waveform data to be analyzed.

        Most DPOJET measurements instances have this tab and these parameters, but the values are **specific** to an
        individual measurement instance.

        :param hp_order: Value 'NONE' disables the High Pass Filter; 'FIRST', 'SECOND' and 'THIRD' specifies the
            order of the High Pass Butterworth filter.
        :type hp_order: str|enum_filter_hp_order
        :param hp_freq_hz: The -3dB corner frequency of the HPF in Hz.
        :type hp_freq_hz: int|float
        :param lp_order: Value 'NONE' disables the Low Pass Filter; 'FIRST', 'SECOND' and 'THIRD' specifies the
            order of the Low Pass Butterworth filter.
        :type lp_order: str|enum_filter_lp_order
        :param lp_freq_hz: The -3dB corner frequency of the LPF in Hz.
        :type lp_freq_hz: int|float
        :param ramp_time: Used to exclude form the measurement results the effect of the filter transient that may
            occur in response to the arrival of an input signal. Duration of the raised-cosine smoothing function to be
            applied to the measurement vector before the vector is filtered. Value is 0 to 10 which are multiples of
            the reciprocal of the lower of the two filter frequencies. Value 0 disables the smoothing operation.
        :type ramp_time: int|float
        :param blanking_time: Used to exclude form the measurement results the effect of the filter transient that may
            occur in response to the arrival of an input signal. Duration that the filter output is suppresed and not
            included in the measurement statistics or any plots.  Value is 0 to 10 which are multiples of the
            reciprocal of the lower of the two filter frequencies. Value 0 disables the blanking operation.
        :type blanking_time: int|float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more vaulues, return type is None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:FILTers:HIGHPass:SPEC {NONE | FIRST | SECOND | THIRD}
        # DPOJET:MEAS<x>:FILTers:HIGHPass:FREQ <NR3>
        # DPOJET:MEAS<x>:FILTers:LOWPass:SPEC {NONE | FIRST | SECOND | THIRD}
        # DPOJET:MEAS<x>:FILTers:LOWPass:FREQ <NR3>
        # DPOJET:MEAS<x>:FILTers:RAMPtime
        # DPOJET:MEAS<x>:FILTers:BLANKingtime <NR3>

        if all([v is None for v in (hp_order, hp_freq_hz, lp_order, lp_freq_hz, ramp_time, ramp_time)]):
            return_values = {}
            return_values.update(hp_order=self.query(f'DPOJET:MEAS{self.meas_num}:FILT:HIGHP:SPEC',
                                                     self.enum_filter_hp_order).name)
            return_values.update(hp_freq_hz=self.query(f'DPOJET:MEAS{self.meas_num}:FILT:HIGHP:FREQ', float))
            return_values.update(lp_order=self.query(f'DPOJET:MEAS{self.meas_num}:FILT:LOWP:SPEC',
                                                     self.enum_filter_lp_order).name)
            return_values.update(lp_freq_hz=self.query(f'DPOJET:MEAS{self.meas_num}:FILT:LOWP:FREQ', float))
            return_values.update(ramp_time=self.query(f'DPOJET:MEAS{self.meas_num}:FILT:RAMP', float))
            return_values.update(blanking_time=self.query(f'DPOJET:MEAS{self.meas_num}:FILT:BLANK', float))
            return return_values

        hp_order = check_enum_str('hp_order', hp_order, self.enum_filter_hp_order)
        hp_freq_hz = check_range('hp_freq_hz', hp_freq_hz, min_max_units(10, 1e12, 'Hz'))
        lp_order = check_enum_str('lp_order', lp_order, self.enum_filter_lp_order)
        lp_freq_hz = check_range('lp_freq_hz', lp_freq_hz, min_max_units(10, 1e12, 'Hz'))
        ramp_time = check_range('ramp_time', ramp_time, min_max_units(0, 10, '1/F'))
        blanking_time = check_range('blanking_time', blanking_time, min_max_units(0, 10, '1/F'))

        if hp_order is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:FILT:HIGHP:SPEC', hp_order.value)
        if hp_freq_hz is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:FILT:HIGHP:FREQ', hp_freq_hz)
        if lp_order is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:FILT:LOWP:SPEC', lp_order.value)
        if lp_freq_hz is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:FILT:LOWP:FREQ', lp_freq_hz)
        if ramp_time is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:FILT:RAMP', ramp_time)
        if blanking_time is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:FILT:BLANK', blanking_time)

        self.log_inst_errors()


# noinspection PyUnresolvedReferences
class FiltersHPF(SupressUnresolved):
    def config_filters(self, high_pass_enb=None):
        """
        Query all or set the state (enabled or disabled) of the 30kHz high-pass sliding window filter use dto remove
        low frequency components in the AC Common Mode measurements.

        :param high_pass_enb: Enable or disable using the HPF.  Accepts any of the values defined as on or off, always
            returns ‘ON’ or ‘OFF’.
        :type high_pass_enb:
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more vaulues, return type is None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:COMMONMode:FILTers:STATE {ON | OFF}

        if high_pass_enb is None:
            return_values = {}
            return_values.update(high_pass_enb=self.on_off.to_api(self.query(
                                        f'DPOJET:MEAS{self.meas_num}:COMMONM:FILT:STATE')))
            return return_values

        high_pass_enb = self.on_off.to_inst(high_pass_enb)

        if high_pass_enb is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:COMMONM:FILT:STATE', high_pass_enb)

        self.log_inst_errors()

class Source(SupressUnresolved):
    enum_sources: object
    enum_autoset: object
    autoset_time_max: float

    def config_source(self, source=None, autoset=None):
        """
        Query or set the signal source for measurements based on one signal. Optionally, invoke one of the various
        autoset modes.

        Invoking autoset will cause this method to enter polling loop to detect the competition of the autoset process.
        In case of malfunction, the polling loop has a timeout set by the attribute autoset_time_max (default 60
        sec).

        :param source: The Source1 value: 'CH1'- 'CH4', 'MATH1'-'MATH4', 'REF1'-'REF4'. Selected source is programmed
            before any autoset is invoked.
        :type source: str|enum_sources
        :param autoset: Specifies autoset mode, if any, to invoke on the existing or the newly specified source. Note:
            there is no SCPI command to support the Undo operation that exists in the oscope GUI.

            * VERTSCALE - If a channel waveform is clipped or does not exceed six vertical divisions, adjust the \
                scale so that the waveform occupies about eight divisions.
            * HORIZRES - Sets the horizontal resolution so that the number of samples on the fastest transition (edge) \
                exceeds 5 samples per edge.
            * BOTH - Performs a sequence: Oscilloscope Autoset, Vertical scale and Horizontal resolution.

        :type autoset: None|str|enum_autoset
        :return: If both parameters are None, source value is queried and returned in a dict. Otherwise None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:SOUrce1 {CH1 - CH4 | MATH1 - MATH4 | REF1 - REF4 | D0 — D15}
        # DPOJET:SOURCEAutoset {HORIzontal | VERTical | BOTH}
        # DPOJET:SOURCEAutoset:STATE?

        # TODO: What do DPOJET:SOURCEAutoset:HORizontal:UICount <NR3> and DPOJET:SOURCEAutoset:HORizontal:UIValue <NR3>
        #  do?

        if all([v is None for v in (source, autoset)]):
            return {'source': self.query(f'DPOJET:MEAS{self.meas_num}:SOU1', self.enum_sources).name}

        source = check_enum_str('source', source, self.enum_sources)
        autoset = check_enum_str('autoset', autoset, self.enum_autoset)

        if source is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:SOU1', source.value)

        if autoset is not None:
            autoset_source = self.query(f'DPOJET:MEAS{self.meas_num}:SOU1', self.enum_sources).name
            self.log.info(f"Starting autoset '{autoset.name}' on source '{autoset_source}'.")
            self.write(f'DPOJET:SOURCEA', autoset.value)

            state = self.query('DPOJET:SOURCEA:STATE').strip('"')
            time_start = time.monotonic()
            while state == 'RUNNING':
                if (time.monotonic() - time_start) > self.autoset_time_max:
                    raise RuntimeError(f"Source '{source}' autoset '{autoset.name}' not complete after "
                                       f"{self.autoset_time_max} sec.")
                state = self.query('DPOJET:SOURCEA:STATE').strip('"')

            self.log.info(f"Autoset '{autoset.name}' on source '{autoset_source}' complete after "
                          f"{time.monotonic() - time_start:.2f} seconds.")

        self.log_inst_errors()


class SourcesDual(SupressUnresolved):
    enum_sources: object
    enum_autoset: object
    autoset_time_max: float

    def config_sources(self, source1=None, source2=None, autoset=None):
        """
        Query or set the signal sources for measurements based on two signals. Optionally, invoke one of the various
        autoset modes.

        Invoking autoset will cause this method to enter polling loop to detect the competition of the autoset process.
        In case of malfunction, the polling loop has a timeout set by the attribute autoset_time_max (default 60
        sec).

         Note: there is no SCPI command to support the Undo operation that exists in the oscope GUI.

        :param source1: The Source1 value 'CH1'- 'CH4', 'MATH1'-'MATH4', 'REF1'-'REF4'. Selected source is programmed
            before any autoset is invoked.
        :type source1: str|enum_sources
        :param source2: The Source2 value 'CH1'- 'CH4', 'MATH1'-'MATH4', 'REF1'-'REF4'. Selected source is programmed
            before any autoset is invoked.
        :type source2: str|enum_sources
        :param autoset: Specifies autoset mode, if any, to invoke on the existing or the newly specified source.

            * VERTSCALE - If a channel waveform is clipped or does not exceed six vertical divisions, adjust the \
                scale so that the waveform occupies about eight divisions.
            * HORIZRES - Sets the horizontal resolution so that the number of samples on the fastest transition (edge) \
                exceeds 5 samples per edge.
            * BOTH - Performs a sequence: Oscilloscope Autoset, Vertical scale and Horizontal resolution.

        :type autoset: None|str|enum_autoset
        :return: If all parameters are None, source1 and source2 values are queried and returned in a dict. Otherwise
            returns None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:SOUrce1 {CH1 - CH4 | MATH1 - MATH4 | REF1 - REF4 | D0 — D15}
        # DPOJET:SOURCEAutoset {HORIzontal | VERTical | BOTH}
        # DPOJET:SOURCEAutoset:STATE?

        if all([v is None for v in (source1, source2, autoset)]):
            return_values = {}
            return_values.update(source1=self.query(f'DPOJET:MEAS{self.meas_num}:SOU1', self.enum_sources).name)
            return_values.update(source2=self.query(f'DPOJET:MEAS{self.meas_num}:SOU2', self.enum_sources).name)
            return return_values

        source1 = check_enum_str('source1', source1, self.enum_sources)
        source2 = check_enum_str('source2', source2, self.enum_sources)

        autoset = check_enum_str('autoset', autoset, self.enum_autoset)

        if source1 is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:SOU1', source1.value)
        if source2 is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:SOU2', source2.value)

        if autoset is not None:
            autoset_source1 = self.query(f'DPOJET:MEAS{self.meas_num}:SOU1', self.enum_sources).name
            autoset_source2 = self.query(f'DPOJET:MEAS{self.meas_num}:SOU2', self.enum_sources).name
            self.log.info(f"Starting autoset '{autoset.name}' on sources '{autoset_source1}' and '{autoset_source2}'.")

            self.write(f'DPOJET:SOURCEA', autoset.value)

            state = self.query('DPOJET:SOURCEA:STATE').strip('"')
            time_start = time.monotonic()
            while state == 'RUNNING':
                if (time.monotonic() - time_start) > self.autoset_time_max:
                    raise RuntimeError(f"Autoset '{autoset.name}' on sources '{autoset_source1}' and "
                                       f"'{autoset_source2}' not complete after {self.autoset_time_max} sec.")
                state = self.query('DPOJET:SOURCEA:STATE').strip('"')

            self.log.info(f"Autoset '{autoset.name}' on sources '{autoset_source1}' and '{autoset_source2}' complete "
                          f"after {time.monotonic() - time_start:.2f} seconds.")

        self.log_inst_errors()


class Reflevels_source1(SupressUnresolved):
    _reflevels: classmethod
    enum_sources: object

    def ref_levels_src1(self, ref_units=None, high=None, mid=None, low=None, fall_high=None, fall_mid=None,
                        fall_low=None, base_top_from=None, hysteresis=None, autoset_enable=None):

        source = self.query(f'DPOJET:MEAS{self.meas_num}:SOU1', self.enum_sources).name

        return self._reflevels(source, ref_units, high, mid, low, fall_high, fall_mid, fall_low, base_top_from,
                               hysteresis, autoset_enable)

class Reflevels_source2(SupressUnresolved):
    _reflevels: classmethod
    enum_sources: object

    def ref_levels_src2(self, ref_units=None, high=None, mid=None, low=None, fall_high=None, fall_mid=None,
                        fall_low=None, base_top_from=None, hysteresis=None, autoset_enable=None):

        source = self.query(f'DPOJET:MEAS{self.meas_num}:SOU2', self.enum_sources).name

        return self._reflevels(source, ref_units, high, mid, low, fall_high, fall_mid, fall_low, base_top_from,
                               hysteresis, autoset_enable)

# ======================================================================================================================
# Derived classes each supporting a group of measurements having a common set of configuration parameters.

class MeasTypePeriodFreq(MeasTypes, EdgesSignaltypeClkedge, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_types: PERIOD, FREQUENCY.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------
# PERIOD/FREQUENCY related, some TIME related.

class MeasTypeNoEdges(MeasTypes, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: PWIDTH, NWIDTH, PCCDUTY, NCCDUTY, SSCPROFILE, HIGHTIME,
    LOWTIME, SSCMODRATE, CYCLEMIN, CYCLEPKTOPK

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeNPERIOD(MeasTypes, EdgesSignaltypeClkedgeN, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: NPERIOD.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)


# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeDuty(MeasTypes, EdgesClkedge, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: PDUTY, NDUTY, CCPERIOD.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeDataRate(MeasTypes, EdgesSignaltypeClkedge, Reflevels_source1, Source):
    """MeasType providing config method for meas_types: DATARATE.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------
# JITTER related

class MeasTypeTJBER(MeasTypes, EdgesSignaltypeClkedge, ClkRecoverySelect, RjDjBER, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: TJBER, WIDTHBER

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeJitNoBER(MeasTypes, EdgesSignaltypeClkedge, ClkRecoverySelect, RjDj, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: PJ, RJ, DJ, DJDIRAC, RJDIRAC, SRJ, J9, PJRMS, J2

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeDDJ(MeasTypes, ClkRecoverySelect, RjDj, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: DJD.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeDCD(MeasTypes, EdgesSignaltype, ClkRecoverySelect, RjDj, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: DCD.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeTIE(MeasTypes, EdgesSignaltypeClkedge, ClkRecoverySelect, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: TIE.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.

    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeFbyN(MeasTypes, EdgesSignaltypeClkedgeSubrate, ClkRecoverySelect, RjDj, Filters, Reflevels_source1,
                   Source):
    """MeasType providing config method for meas_type: FN.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypePHASENOISE(MeasTypes, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: PHASENOISE.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    enum_active_edge = Enum('enum_active_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

    def config_edge(self, active_edge=None, lower_freq_hz=None, upper_freq_hz=None):
        """
        Queries or sets the parameters of the Configure->Edges for the PHASENOISE measurement.

        :param active_edge: Choose the edge: 'RISE', 'FALL', 'BOTH'.
        :type active_edge: str|enum_clk_edge
        :param lower_freq_hz: 0 to 1e12 Hz.
        :type lower_freq_hz: float
        :param upper_freq_hz: 0 to 1e12 Hz.
        :type upper_freq_hz: float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting value, return type is None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:EDGE1 {RISe | FALL | BOTH}
        # DPOJET:MEAS<x>:PHASENoise:HIGHLimit <NR3>
        # DPOJET:MEAS<x>:PHASENoise:LOWLimit <NR3>

        if all([v is None for v in (active_edge, lower_freq_hz, upper_freq_hz)]):
            return_value = {}
            return_value.update(active_edge=self.query(f'DPOJET:MEAS{self.meas_num}:EDGE1', self.enum_active_edge).name)
            return_value.update(lower_freq_hz=self.query(f'DPOJET:MEAS{self.meas_num}:PHASEN:LOWL', float))
            return_value.update(upper_freq_hz=self.query(f'DPOJET:MEAS{self.meas_num}:PHASEN:HIGHL', float))
            return return_value

        active_edge = check_enum_str('active_edge', active_edge, self.enum_active_edge)
        lower_freq_hz = check_range('lower_freq_hz', lower_freq_hz, min_max_units(0, 1e12, 'Hz'))
        upper_freq_hz = check_range('upper_freq_hz', upper_freq_hz, min_max_units(0, 1e12, 'Hz'))

        if active_edge is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:EDGE', active_edge.value)

        if lower_freq_hz is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:PHASEN:LOWL', lower_freq_hz)

        if upper_freq_hz is not None:
            self.write(f'DPOJET:MEAS{self.meas_num}:PHASEN:HIGHL', upper_freq_hz)

        self.log_inst_errors()

        # self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSJFREQ(MeasTypes, EdgesSignaltypeClkedge, ClkRecoverySelect, RjDj, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: SJFREQ.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

    def config_filters(self, sj_freq_hz, sj_bw_hz):
        pass
        # self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------
# TIME related

class MeasTypeRiseFall(MeasTypes, ClkRecoverySelect, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: RISETIME, TNTRATIO, CYCLEMAX

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSkew(MeasTypes, EdgesFromTo, Filters, Reflevels_source1, Reflevels_source2, SourcesDual):
    """MeasType providing config method for meas_type: SKEW.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSetupHold(MeasTypes, EdgesClkData, Filters, Reflevels_source1, Reflevels_source2, SourcesDual):
    """MeasType providing config method for meas_type: SETUP, HOLD.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.

    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSlewRise(MeasTypes, EdgesSlew, Filters, Reflevels_source1, Source):
    enum_from_level = Enum('enum_from_level', {'MID': 'MID', 'LOW': 'LOW'})
    enum_to_level = Enum('enum_to_level', {'HIGH': 'HIGH', 'MID': 'MID'})

    """MeasType providing config method for meas_type: RISESLEWRATE.
    
    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSlewFall(MeasTypes, EdgesSlew, Filters, Reflevels_source1, Source):
    enum_from_level = Enum('enum_from_level', {'HIGH': 'HIGH', 'MID': 'MID'})
    enum_to_level = Enum('enum_to_level', {'MID': 'MID', 'LOW': 'LOW'})

    """MeasType providing config method for meas_type: FALLSLEWRATE.
    
    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.   
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeSSC(MeasTypes, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: SSCFREQDEV, SSCFREQDEVMIN, SSCFREQDEVMAX.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

    def config_ssc(self, nominal_freq):
        pass
        # self.log_inst_errors()

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeLevel(MeasTypes, EdgesLevel, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: TIMEOUTSIDELEVEL.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------
# Eye related

class MeasTypeEyeWidth(MeasTypes, ClkRecoverySelect, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: WIDTH

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeEyeHEIGHTBER(MeasTypes, BitTypeUIrange, ClkRecoverySelect, BER, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: HEIGHTBER

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeEyeHEIGHT(MeasTypes, BitType, ClkRecoverySelect, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: HEIGHT

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeEyeHIGH(MeasTypes, BitTypeXpcnt, ClkRecoverySelect, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: EYEHIGH, QFACTOR, EYELOW

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeEyeMask(MeasTypes, BitTypeMask, ClkRecoverySelect, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: MASKHITS

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeEyeMaskAdv(MeasTypes, BitTypeMaskAdv, ClkRecoverySelect, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: AUTOFITMASKHITS

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeAmplHIGH(MeasTypes, BitTypeCenter, ClkRecoverySelect, Filters, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: HIGH, LOW, HIGHLOW

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeCOMMONMODE(MeasTypes, Reflevels_source1, Reflevels_source2, SourcesDual):
    """MeasType providing config method for meas_types: COMMONMODE.

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)


# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeAmpOVERSHOOT(MeasTypes, EdgesRefVoltage, Reflevels_source1, Source):
    """MeasType providing config method for meas_type: OVERSHOOT, UNDERSHOOT

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeVDIFFXOVR(MeasTypes, EdgesMain, Filters, Reflevels_source1, Reflevels_source2, SourcesDual):
    """MeasType providing config method for meas_type: VDIFFXOVR

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)

# ----------------------------------------------------------------------------------------------------------------------

class MeasTypeACCOMMONMODE(MeasTypes, FiltersHPF, Reflevels_source1, Reflevels_source2, Source):
    """MeasType providing config method for meas_type: ACCOMMONMODE

    The parent class :class:`~cl_instr_lib.base_classes.tek_scopes.dpojet.meas_types.MeasTypes` contains the
    documentation for those methods common to all measurements so those are not shown here.
    """

    def __init__(self, container, meas_num, display_name, meas_name, meas_type, **kwargs):
        super().__init__(container, meas_num, display_name, meas_name, meas_type, **kwargs)
