from enum import Enum
from pathlib import PureWindowsPath

from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units

class SuppressUnresolved:
    # Import into mix-in classes below to suppress inspections on these references.

    query: classmethod
    write: classmethod
    log_inst_errors: classmethod
    on_off: object
    log: object
    meas_num: int

class ClkRecoveryExplicitMixin(SuppressUnresolved):
    """Helper class to be inherited into classes for "Explicit CLock - Edge" and Explicit Clock - PLL. """

    enum_clk_edge = Enum('enum_clk_edge', {'RISE': 'RISE', 'FALL': 'FALL', 'BOTH': 'BOTH'})
    enum_sources = Enum('enum_sources', {
        'CH1': 'CH1', 'CH2': 'CH2', 'CH3': 'CH3', 'CH4': 'CH4',
        'REF1': 'REF1', 'REF2': 'REF2', 'REF3': 'REF3', 'REF4': 'REF4',
        'MATH1': 'MATH1', 'MATH2': 'MATH2', 'MATH3': 'MATH3', 'MATH4': 'MATH4'
    })
    enum_auto_manual = Enum('enum_auto_manual', {'AUTO': 'AUTO', 'MANUAL': 'MANUAL'})
    enum_recalc_when = Enum('enum_recalc_when', {'WHEN_REQ': 'FIRST', 'EVERY_ACQ': 'EVERY'})

    def _explicit_read(self):

        # DPOJET:MEAS<x>:SOUrce2
        # DPOJET:MEAS<x>:EDGE2
        # DPOJET:MEAS<x>:CLOCKRecovery:CLOCKMultiplier <NR3>

        return_values = {}
        return_values.update(clk_source=self.query(f"DPOJET:MEAS{self.meas_num}:SOUrce2", self.enum_sources).name)
        return_values.update(clk_edge=self.query(f"DPOJET:MEAS{self.meas_num}:EDGE2", self.enum_clk_edge).name)
        return_values.update(clk_multiplier=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:CLOCKMultiplier",
                                                       int))
        return return_values

    def _explicit_check(self, clk_source, clk_edge, clk_multiplier):
        clk_source = check_enum_str('clk_source', clk_source, self.enum_sources)
        clk_edge = check_enum_str('clk_edge', clk_edge, self.enum_clk_edge)
        clk_multiplier = check_range('clk_multiplier', clk_multiplier, min_max_units(1, 1000, ''), val_type=int)
        return clk_source, clk_edge, clk_multiplier

    def _explicit_write(self, clk_source, clk_edge, clk_multiplier):

        # DPOJET:MEAS<x>:SOUrce2
        # DPOJET:MEAS<x>:EDGE2
        # DPOJET:MEAS<x>:CLOCKRecovery:CLOCKMultiplier <NR3>

        if clk_source is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:SOUrce2", clk_source.value)
        if clk_edge is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:EDGE2", clk_edge.value)
        if clk_multiplier is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:CLOCKMultiplier", clk_multiplier)

    def _explicit_advanced_read(self):
        # DPOJET:MEAS<x>:CLOCKRecovery:NOMINALOFFset:SELECTIONtype {AUTO | MANUAL}
        # DPOJET:MEAS<x>:CLOCKRecovery:NOMINALOFFset:AUTO?
        # DPOJET:MEAS<x>:CLOCKRecovery:NOMINALOFFset:MANual <NR3>
        # DPOJET:MEAS<x>:CLOCKRecovery:NOMINALOFFset:Recalctype {FIRST | EVERY}

        return_values = {}
        return_values.update(nominal_clk_offset=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:NOMINALOFF:SELECTION",
                                                    self.enum_auto_manual).name)
        return_values.update(manual_clk_offset=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:NOMINALOFF:MAN", float))
        return_values.update(recalc_when=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:NOMINALOFF:Recalc",
                                                    self.enum_recalc_when).name)
        return return_values

    def _explicit_advanced_check(self, nominal_clk_offset, manual_clk_offset, recalc_when):
        nominal_clk_offset = check_enum_str('nominal_clk_offset', nominal_clk_offset, self.enum_auto_manual)
        manual_clk_offset = check_range('manual_clk_offset', manual_clk_offset, min_max_units(0, 1.0, 'sec'),
                                        val_type=float)
        recalc_when = check_enum_str('recalc_when', recalc_when, self. enum_recalc_when)
        return nominal_clk_offset, manual_clk_offset, recalc_when

    def _explicit_advanced_write(self, nominal_clk_offset, manual_clk_offset, recalc_when):

        if nominal_clk_offset is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:NOMINALOFF:SELECTION", nominal_clk_offset.value)
        if manual_clk_offset is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:NOMINALOFF:MAN", manual_clk_offset)
        if recalc_when is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:NOMINALOFF:Recalc", recalc_when.value)


# noinspection PyUnresolvedReferences
class ClkRecoveryAdvancedMixin(SuppressUnresolved):
    """
    Helper class to be inherited into classes for 'PLL - Custom MW',  'Constant Clock-Mean' and
    'ClkRecoveryMeanMedian' clock recovery methods.
    """

    enum_nom_data_rate = Enum('enum_nom_data_rate', {'AUTO': '0', 'MANUAL': '1'})

    # On the Advanced Panel
    # DPOJET:MEAS<x>:CLOCKRecovery:DATARate {1 | 0}
    # DPOJET:MEAS<x>:CLOCKRecovery:CLOCKBitrate <NR3>
    # DPOJET:MEAS<x>:CLOCKRecovery:PATTern {1 | 0}
    # DPOJET:MEAS<x>:CLOCKRecovery:CLOCKPath <string>

    def _advanced_read(self):
        return_values = {}
        nominal_data_rate = self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:DATAR", self.enum_nom_data_rate)
        return_values.update(nominal_data_rate=nominal_data_rate.name)
        return_values.update(manual_bitrate=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:CLOCKB", float))
        return_values.update(known_pattern=self.on_off.to_api(self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:PATT",
                                                                     int)))
        tmp = self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:CLOCKP", str).strip('"')
        tmp = PureWindowsPath(tmp).as_posix()   # Gives us forward slashes.
        return_values.update(pattern_file=tmp)
        return return_values

    def _advanced_check(self, nominal_data_rate, manual_bitrate, known_pattern, pattern_file):

        nominal_data_rate = check_enum_str('nominal_data_rate', nominal_data_rate, self.enum_nom_data_rate)

        nom_data_rate_state = nominal_data_rate
        if nom_data_rate_state is None:
            nom_data_rate_state = self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:DATAR", self.enum_nom_data_rate)

        manual_bitrate = check_range('manual_bitrate', manual_bitrate, min_max_units(0, 100e9, 'bits/sec'))

        if nom_data_rate_state.name == 'AUTO' and manual_bitrate is not None:
            self.log.warn(f"With nominal_data_rate '{nom_data_rate_state.name}' attempting to set manual_bitrate="
                          f"={manual_bitrate}bit/sec will be ignored by the oscope.")
            manual_bitrate = None  # cause write to be skipped, scope ignores it anyway.

        known_pattern = self.on_off.to_inst(known_pattern)

        if pattern_file is not None:
            pattern_file = PureWindowsPath(pattern_file)
            scope_dir = pattern_file.parent
            old_cwd = self.scope.filesystem.cwd()  # Use this to put cwd back the way we found it.

            if not self.scope.filesystem.is_scope_dir(scope_dir):
                self.scope.filesystem.cwd(old_cwd)
                raise ValueError(f"Bad known_patten, scope_dir '{scope_dir}', does not exist in scope file system.")

            self.scope.filesystem.cwd(scope_dir)
            tmp = self.query('FILES:DIR', str).split(',')
            scope_dir_contents = [f.strip('"') for f in tmp if f not in ('"."', '".."')]
            file_name = pattern_file.name
            if file_name not in scope_dir_contents:
                self.scope.filesystem.cwd(old_cwd)
                raise ValueError(f"Bad known_patten, the file '{file_name}' does not exist in scope_dir '{scope_dir}'.")

            self.scope.filesystem.cwd(old_cwd)
            pattern_file = pattern_file.as_posix()

        return nominal_data_rate, manual_bitrate, known_pattern, pattern_file

    def _advanced_write(self, nominal_data_rate, manual_bitrate, known_pattern, pattern_file):
        # Be sure you run all parameters through the _advanced_check method before calling this!
        # _advanced_check converts nominal_data_rate to an enum element and known_pattern to interument on/off value.

        if nominal_data_rate is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:DATAR", nominal_data_rate.value)
        if manual_bitrate is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:CLOCKB", manual_bitrate)
        if known_pattern is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:PATT", known_pattern)
        if pattern_file is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:CLOCKP", f'"{str(pattern_file)}"')


class ClkRecoveryPLLMixin(SuppressUnresolved):
    """
    Helper class to be inherited into classes for 'PLL - Custom MW' and 'Explict Clock - PLL' clock recovery methods.
    """

    enum_pll_model = Enum('enum_pll_model', {'TYPE1': 'ONE', 'TYPE2': 'TWO'})
    enum_pll_bwtype = Enum('enum_pll_bwtype', {'LOOPBW': 'LOOPBW', 'JTFBW': 'JTFBW'})

    def _pll_read(self):
        # DPOJET:MEAS<x>:CLOCKRecovery:MODel {ONE | TWO}
        # DPOJET:MEAS<x>:CLOCKRecovery:LOOPBandwidth <NR3>
        # DPOJET:MEAS<x>:CLOCKRecovery:BWType {LOOPBW | JTFBW}
        # DPOJET:MEAS<x>:CLOCKRecovery:DAMPing <NR3>

        return_values = {}
        pll_model = self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:MODel", self.enum_pll_model)
        return_values.update(pll_model=pll_model.name)
        return_values.update(bandwidth=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:LOOPB", float))
        if pll_model.value == 'TWO':
            return_values.update(bw_type=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:BWT",
                                                    self.enum_pll_bwtype).name)
            return_values.update(damping=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:DAMP", float))
        return return_values

    def _pll_check(self, pll_model, bandwidth, bw_type, damping):
        pll_model = check_enum_str('pll_model', pll_model, self.enum_pll_model)
        pll_model_state = pll_model
        if pll_model_state is None:
            pll_model_state = self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:MODel", self.enum_pll_model)

        bw_type = check_enum_str('bw_type', bw_type, self.enum_pll_bwtype)
        if pll_model_state.name == 'TYPE1' and bw_type is not None and bw_type.name == 'JTFBW':
            raise ValueError(f"Cannot set bw_type '{bw_type.name}' with pll_model '{pll_model_state.name}'.")

        bandwidth = check_range('bandwidth', bandwidth, min_max_units(1.0, 2.5e9, 'Hz'), val_type=float)

        damping = check_range('damping', damping, min_max_units(0.5, 2.0, ''), val_type=float)
        if pll_model_state.name == 'TYPE1' and damping is not None:
            raise ValueError(f"Cannot set damping {damping} with pll_model '{pll_model_state.name}'.")

        return pll_model, bandwidth, bw_type, damping

    def _pll_write(self, pll_model, bandwidth, bw_type, damping):
        if pll_model is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:MODel", pll_model.value)
        if bw_type is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:BWT", bw_type.value)
        if bandwidth is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:LOOPB", bandwidth)
        if damping is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:DAMP", damping)


class ClkRecoveryPllCustom(ClkRecoveryPLLMixin, ClkRecoveryAdvancedMixin):
    """
    Callable object of this type is instantiated in the config_clk_recovery_params attribute when the selected Clock
    Recovery Method is 'CUSTOM', aka "PLL - Custom BW" in the oscope GUI.
    """

    def __init__(self, container):
        self.query = container.query
        self.write = container.write
        self.meas_num = container.meas_num
        self.on_off = container.on_off
        self.log_inst_errors = container.log_inst_errors
        self.log = container.log
        self.scope = container.scope

    def __call__(self, pll_model=None, bandwidth=None, bw_type=None, damping=None,
                 nominal_data_rate=None, manual_bitrate=None, known_pattern=None, pattern_file=None):
        """
        Query all or set any of the parameters related to the Clock Recovery Method 'CUSTOM' (in oscope GUI "PLL -
        Custom BW").

        :param pll_model: Choose PLL type implemented by the software model.

            * TYPE1 - Transfer function approaches 0 Hz with slope of 1/s.
            * TYPE2 - Transfer function approaches 0 Hz with slope of 1/s**2.

        :type pll_model: str|enum_pll_model
        :param bandwidth: For TYPE1 loops this is Loop BW. For TYPE2 loops, bw_type determines if this is Loop BW or
            JTFBW. Values is in Hz.
        :type bandwidth: float
        :param bw_type: For TYPE2 loops, determines if bandwidth is 'LOOPBW' or 'JTFBW'.
        :type bw_type: str|enum_pll_bwtype
        :param damping: Damping ratio of the PLL. Only applies to TYPE2 loops.
        :type damping: float
        :param nominal_data_rate: AUTO for normal operation. MANUAL when specifying nominal_data_rate.
        :type nominal_data_rate:
        :param manual_bitrate: Used with nominal_data_rate=MANUAL to specify an approximate bit rate to help identify
            the unit interval when the data pattern is such that it could be interpreted as multiple clock rates. Units
            are bits/sec.
        :type manual_bitrate: float
        :param known_pattern: OFF for normal operation. ON to specify a data pattern from a file.
        :type known_pattern: str|int|bool
        :param pattern_file: Full path in the oscope's Windows filesystem to the file containing the desired data
            pattern. Note: use r (raw) string or use '/'  to avoid parts of your path string being mistaken for an
            escape sequence (e.g. \\n).
        :type pattern_file: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more values, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (pll_model, bandwidth, bw_type, damping,
                                    nominal_data_rate, manual_bitrate, known_pattern, pattern_file)]):
            return_values = self._pll_read()
            return_values.update(self._advanced_read())
            return return_values

        pll_model, bandwidth, bw_type, damping = self._pll_check(pll_model, bandwidth, bw_type, damping)
        nominal_data_rate, manual_bitrate, known_pattern, pattern_file = \
            self._advanced_check(nominal_data_rate, manual_bitrate, known_pattern, pattern_file)

        self._pll_write(pll_model, bandwidth, bw_type, damping)
        self._advanced_write(nominal_data_rate, manual_bitrate, known_pattern, pattern_file)

        self.log_inst_errors()


class ClkRecoveryMeanMedian(ClkRecoveryAdvancedMixin):
    """
    Callable object of this type is instantiated in the config_clk_recovery_params attribute when the selected Clock
    Recovery Method is 'CONSTMEAN' or 'CONSTMEDIAN, aka "Constant Clock - Mean" or "Constant Clock - Median" in the
    oscope GUI.
    """

    enum_auto_calc = Enum('enum_auto_calc', {'FIRST': 'FIRST', 'EVERY': 'EVERY'})

    def __init__(self, container):
        self.query = container.query
        self.write = container.write
        self.meas_num = container.meas_num
        self.on_off = container.on_off
        self.log_inst_errors = container.log_inst_errors
        self.log = container.log
        self.scope = container.scope

    def __call__(self, auto_calc=None,
                 nominal_data_rate=None, manual_bitrate=None, known_pattern=None, pattern_file=None):
        """
        Query all or set any of the parameters related to the Clock Recovery Methods 'CONSTMEAN' or 'CONSTMEDIAN,
        (aka "Constant Clock -  Mean" or "Constant Clock - Median" in the oscope GUI).

        Note: The data rate is normally determined automatically by analysis of the data stream. High noise or
        ambiguous data patterns may defeat so two advanced clock recovery methods

        :param auto_calc: Determines when algorithm determines best-fit clock frequency and phase. Note selecting
            Clear in the sequencing controls will reset clock recovery so both freq and phase will be optimized on the
            next acquisition.

            * FIRST - Both freq and phase determines only of the first oscope acquisition. Subsequent acquisitions \
                perform a best fit on phase but retain the freq from the first acquisition.
            * EVERY - Perform a a new best-fit freq and phase for every acquisition.

        :type auto_calc: str|enum_auto_calc
        :param nominal_data_rate: AUTO for normal operation. MANUAL when specifying nominal_data_rate.
        :type nominal_data_rate:
        :param manual_bitrate: Used with nominal_data_rate=MANUAL to specify an approximate bit rate to help identify
            the unit interval when the data pattern is such that it could be interpreted as multiple clock rates. IN
            bits/sec.
        :type manual_bitrate: float
        :param known_pattern: OFF for normal operation. ON to specify a data pattern from a file.
        :type known_pattern: str|int|bool
        :param pattern_file: Full ath in the oscope's Windows filesystem to the file containing the desired data
            pattern.
        :type pattern_file: str
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more values, return type is None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:CLOCKRecovery:MEANAUTOCalculate {FIRST | EVERY}

        # On the Advanced Panel
        # DPOJET:MEAS<x>:CLOCKRecovery:DATARate {1 | 0}
        # DPOJET:MEAS<x>:CLOCKRecovery:CLOCKBitrate <NR3>
        # DPOJET:MEAS<x>:CLOCKRecovery:PATTern {1 | 0}
        # DPOJET:MEAS<x>:CLOCKRecovery:CLOCKPath <string>

        if all([v is None for v in (auto_calc, nominal_data_rate, manual_bitrate, known_pattern, pattern_file)]):
            return_values = {}
            return_values.update(auto_calc=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKR:MEANAUTOC",
                                                      self.enum_auto_calc).name)
            return_values.update(self._advanced_read())
            return return_values

        auto_calc = check_enum_str('auto_calc', auto_calc, self.enum_auto_calc)
        nominal_data_rate, manual_bitrate, known_pattern, pattern_file = \
            self._advanced_check(nominal_data_rate, manual_bitrate, known_pattern, pattern_file)

        if auto_calc is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKR:MEANAUTOC", auto_calc.value)

        self._advanced_write(nominal_data_rate, manual_bitrate, known_pattern, pattern_file)

        self.log_inst_errors()


class CLkRecoveryFixed(SuppressUnresolved):
    """
    Callable object of this type is instantiated in the config_clk_recovery_params attribute when the selected Clock
    Recovery Method is 'CONSTFIXED' aka "Constant Clock Fixed" in the oscope GUI.
    """

    def __init__(self, container):
        self.query = container.query
        self.write = container.write
        self.meas_num = container.meas_num
        self.on_off = container.on_off
        self.log_inst_errors = container.log_inst_errors

    def __call__(self, clk_freq=None):
        """
        Query all or set any of the parameters related to the Clock Recovery Method 'CONSTFIXED' (aka "Constant Clock
        Mean" in the oscope GUI).

        :param clk_freq: Use this exact frequency in Hz as the reference clock rather than attempting to derive the
            data rate from the signal under test. Clock phase is determined from the signal such that the median
            difference between recovered and measured edges is zero.
        :type clk_freq: float
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more values, return type is None.
        :rtype: dict|None
        """

        # DPOJET:MEAS<x>:CLOCKRecovery:CLOCKFrequency <NR3>

        if clk_freq is None:
            return_values = {}
            return_values.update(clk_freq=self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:CLOCKFrequency"))
            return return_values

        clk_freq = check_range('clk_freq', clk_freq, min_max_units(1, 25e9, 'Hz'))

        if clk_freq is not None:
            self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:CLOCKFrequency", clk_freq)

        self.log_inst_errors()

class ClkRecoveryExplictEdge(ClkRecoveryExplicitMixin):
    """
    Callable object of this type is instantiated in the config_clk_recovery_params attribute when the selected Clock
    Recovery Method is 'EXPEDGE' aka "Explicit Clock - Edge" in the oscope GUI.
    """

    def __init__(self, container):
        self.query = container.query
        self.write = container.write
        self.meas_num = container.meas_num
        self.on_off = container.on_off
        self.log_inst_errors = container.log_inst_errors

    def __call__(self, clk_source=None, clk_edge=None, clk_multiplier=None,
                 nominal_clk_offset=None, manual_clk_offset=None, recalc_when=None):
        """
        Query all or set any of the parameters related to the Clock Recovery Method 'EXPLICIT_EDGE' (aka
        "Explicit Clock - Edge" in the oscope GUI).

        :param clk_source: Select an explicit reference clock source to be used in the measurement rather than a
            ref clock derived from the signal being measured. Source can be  'CH1'-'CH4','MATH1-MATH4' or 'REF1-REF4'.
        :type clk_source: str|enum_sources
        :param clk_edge: Specify whether the rising, falling or both edges of selected source should be considered.
        :type clk_edge: str|enum_clk_edge
        :param clk_multiplier: If > 1, linear interpolation will be used between each pair of clk_source edges to
            create clk_multiplier-1 additional reference edges. This gives a total of clk_multiplier edges per actual
            clock_source edge.
        :type clk_multiplier: int
        :param nominal_clk_offset: Specifies how reference clock edges are associated with data edges.

            * AUTO - Automatically calculates the clock data skew and shifts the reference clock edges before the \
                application associates each data edge with the closest clock edge.
            * MANUAL - Use manual_offset (positive or negative) to shift the reference clock edge before the \
                application associates each data edge with the closet data edge.

        :type nominal_clk_offset: str|enum_auto_manual
        :param manual_clk_offset: When aut_manual=MANUAL is selected, enter a positive or negative offset of the ref
            clock relative to the data.
        :type manual_clk_offset: float
        :param recalc_when: Specifies when the AUTo calculationof nominal_clock_offset is performed.

            * WHEN_REQ - Recalculates the nominal clock offset value whenever a new measurement is added or results \
                are cleared or there are any measurement configuration changes.
            * EVERY_ACQ - Recalculates the nominal clock offset value for every acquisition.

        :type recalc_when: str|enum_recalc_when
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more values, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (clk_source, clk_edge, clk_multiplier,
                                    nominal_clk_offset, manual_clk_offset, recalc_when)]):
            # Do read back and return.
            return_values = self._explicit_read()
            return_values.update(self._explicit_advanced_read())
            return return_values

        # User entered one or more values, do checks, raise exception if any are bad.
        clk_source, clk_edge, clk_multiplier = self._explicit_check(clk_source, clk_edge, clk_multiplier)
        nominal_clk_offset, manual_clk_offset, recalc_when = \
            self._explicit_advanced_check(nominal_clk_offset, manual_clk_offset, recalc_when)

        # All input values OK, write to the instrument.
        self._explicit_write(clk_source, clk_edge, clk_multiplier)
        self._explicit_advanced_write(nominal_clk_offset, manual_clk_offset, recalc_when)

        self.log_inst_errors()

class ClkRecoveryExplictPLL(ClkRecoveryExplicitMixin, ClkRecoveryPLLMixin):
    def __init__(self, container):
        self.query = container.query
        self.write = container.write
        self.meas_num = container.meas_num
        self.on_off = container.on_off
        self.log_inst_errors = container.log_inst_errors

    def __call__(self, clk_source=None, clk_edge=None, clk_multiplier=None,
                 pll_model=None, bandwidth=None, bw_type=None, damping=None,
                 nominal_clk_offset=None, manual_offset=None, recalc_when=None):
        """
        Query all or set any of the parameters related to the Clock Recovery Method 'EXPLICIT_PLL' (aka
        "Explicit Clock - PLL" in the oscope GUI).

        :param clk_source: Select an explicit reference clock source to be used in the measurement rather than a
            ref clock derived from the signal being measured. Source can be  'CH1'-'CH4','MATH1-MATH4' or 'REF1-REF4'.
        :type clk_source: str|enum_sources
        :param clk_edge: Specify whether the rising, falling or both edges of selected source should be considered.
        :type clk_edge: str|enum_clk_edge
        :param clk_multiplier: If > 1, linear interpolation will be used between each pair of clk_source edges to
            create clk_multiplier-1 additional reference edges. This gives a total of clk_multiplier edges per actual
            clock_source edge.
        :type clk_multiplier: int
        :param pll_model: Choose PLL type

            * TYPE1 - Transfer function approaches 0 Hz with slope of 1/s.
            * TYPE2 - Transfer function approaches 0 Hz with slope of 1/s**2.

        :type pll_model: str|enum_pll_model
        :param bandwidth: For TYPE1 loops this is Loop BW. For TYPE2 loops, bw_type determines if this is Loop BW or
            JTFBW. Values is in Hz.
        :type bandwidth: float
        :param bw_type: For TYPE2 loops, determines if bandwidth is 'LOOPBW' or 'JTFBW'.
        :type bw_type: str|enum_pll_bwtype
        :param damping: Damping ratio of the PLL. Only applies to TYPE2 loops.
        :type damping: float
        :param nominal_clk_offset: Specifies how reference clock edges are associated with data edges.

            * AUTO - Automatically calculates the clock data skew and shifts the reference clock edges before the \
                application associates each data edge with the closest clock edge.
            * MANUAL - Use manual_offset (positive or negative) to shift the reference clock edge before the \
                application associates each data edge with the closet data edge.

        :type nominal_clk_offset: str|enum_auto_manual
        :param manual_offset: When aut_manual=MANUAL is selected, enter a positive or negative offset of the ref
            clock relative to the data.
        :type manual_offset: float
        :param recalc_when: Specifies when the AUTo calculationof nominal_clock_offset is performed.

            * WHEN_REQ - Recalculates the nominal clock offset value whenever a new measurement is added or results \
                are cleared or there are any measurement configuration changes.
            * EVERY_ACQ - Recalculates the nominal clock offset value for every acquisition.

        :type recalc_when: str|enum_recalc_when
        :return: Query (all input parameters None) returns a dict of parameter name-value pairs. Values read from
            scope. When setting one or more values, return type is None.
        :rtype: dict|None
        """

        if all([v is None for v in (clk_source, clk_edge, clk_multiplier,
                                    pll_model, bandwidth, bw_type, damping,
                                    nominal_clk_offset, manual_offset, recalc_when)]):
            # Do read back and return.
            return_values = self._explicit_read()
            return_values.update(self._pll_read())
            return_values.update(self._explicit_advanced_read())
            return return_values

        # User entered one or more values, do checks, raise exception if any are bad.
        clk_source, clk_edge, clk_multiplier = self._explicit_check(clk_source, clk_edge, clk_multiplier)
        pll_model, bandwidth, bw_type, damping = self._pll_check(pll_model, bandwidth, bw_type, damping)
        nominal_clk_offset, manual_offset, recalc_when = \
            self._explicit_advanced_check(nominal_clk_offset, manual_offset, recalc_when)

        self._explicit_write(clk_source, clk_edge, clk_multiplier)
        self._pll_write(pll_model, bandwidth, bw_type, damping)
        self._explicit_advanced_write(nominal_clk_offset, manual_offset, recalc_when)

        self.log_inst_errors()

class ClkRecoverySelect(SuppressUnresolved):
    enum_clk_recovery_methods = Enum('enum_clk_recovery_methods', {
        'PLL_CUSTOM_BW': 'CUSTOM',
        'CONSTANT_MEAN': 'CONSTMEAN',
        'CONSTANT_MEDIAN': 'CONSTMEDIAN',
        'CONSTANT_FIXED': 'CONSTFIXED',
        'EXPLICIT_EDGE': 'EXPEDGE',
        'EXPLICIT_PLL': 'EXPPLL',
    })
    _clk_recovery_classes = {
        'CUSTOM': ClkRecoveryPllCustom,
        'CONSTMEAN': ClkRecoveryMeanMedian,
        'CONSTMEDIAN': ClkRecoveryMeanMedian,
        'CONSTFIXED': CLkRecoveryFixed,
        'EXPEDGE': ClkRecoveryExplictEdge,
        'EXPPLL': ClkRecoveryExplictPLL
    }

    def __init__(self):

        #: Callable object providing parameter query or set for the selected `Clock Recovery`_ Method.
        self.config_clk_recovery_params = None

    def config_clk_recovery_method(self, method=None):
        """
        Query or set the Clock Recovery Method the oscope will use to establish a reference clock for this
        measurement. Timing comparisons are made relative to the edges of this reference clock.

        If the Clock Recovery Method is changed from its previous setting, the attribute config_clk_recovery_params
        in the measurement object is changed to match the chosen Clock Recovery Method. That attribute can be called
        as a method to customize the parameters of the chosen Clock Recovery Method.

        :param method: Algorithm used by the oscope to create the reference clock, choose from:

            *  PLL_CUSTOM_BW - Use PLL to extract clock from the signal. The attribute config_clk_recovery_params \
                will contain object of type :class:`ClkRecoveryPllCustom`.
            *  CONSTANT_MEAN -  Determines the ref clock frequency and phase using linear regression to on the set of \
                acquired edge positions to minimize the mean squared error. The attribute config_clk_recovery_params \
                will contain object of type :class:`ClkRecoveryMeanMedian`.
            *  CONSTANT_MEDIAN - Determines the ref clock frequency and phase using linear regression to on the set \
                of acquired edge positions such that the median error between recovered and measured edges is 0. \
                The attribute config_clk_recovery_params will contain object of type :class:`ClkRecoveryMeanMedian`.
            *  CONSTANT_FIXED - Specify a constant frequency (not extracted from the signal). Oscope adjusts clock  \
                phase such that median difference between the recovered and measured edges is zero. The attribute \
                config_clk_recovery_params will contain object of type :class:`CLkRecoveryFixed`.
            *  EXPLICIT_EDGE -  Use an additional signal input, possibly multiplied by an integer, as the ref clock. \
                The attribute config_clk_recovery_params will contain object of type  :class:`ClkRecoveryExplictEdge`. \
                This selection converts what is normally a single source measurement into a dual source measurement. \
                In the oscope GUI, the clk source is the rightmost source in the measurement table.
            *  EXPLICIT_PLL -  Use an additional signal input, fed through a software PLL model, as the ref clock. \
                The attribute config_clk_recovery_params will contain object of type  :class:`ClkRecoveryExplictPLL`. \
                This selection converts what is normally a single source measurement into a dual source measurement. \
                In the oscope GUI, the PLL source is the rightmost source in the measurement table.
        :type method: str|enum_clk_recovery_methods
        :return: None
        """

        # DPOJET:MEAS<x>:CLOCKRecovery:METHod {STANDARD | CUSTOM | CONSTMEAN | CONSTFIXED | EXPEDGE | EXPPLL |
        #   CONSTMEDIAN | BEHAVIORAL}

        if method is None:
            cr_method = self.update_clk_recovery_method()
            return self.enum_clk_recovery_methods(cr_method).name

        method = check_enum_str('method', method, self.enum_clk_recovery_methods)

        # if method not in self._clk_recovery_classes:
        #     msg = ', '.join(f"'{k}'" for k in self._clk_recovery_classes)
        #     raise ValueError(f"Bad or unsupported clk recovery method '{method}, should be one of: {msg}.")

        self.write(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:METHod", method.value)

        self.update_clk_recovery_method()

        self.log_inst_errors()

    # noinspection PyUnresolvedReferences
    def update_clk_recovery_method(self):
        cr_method = self.query(f"DPOJET:MEAS{self.meas_num}:CLOCKRecovery:METHod")

        cls = self._clk_recovery_classes.get(cr_method)
        if cls is None:
            self.log.warn(f"DPOJET Clock Recovery Method {cr_method} is not configurable in this driver.")
        elif not isinstance(self.config_clk_recovery_params, cls):
            self.config_clk_recovery_params = cls(self)

        return cr_method
