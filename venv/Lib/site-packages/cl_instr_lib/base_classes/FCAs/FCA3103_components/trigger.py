# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import *
# Include python libraries
from enum import Enum
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class Trigger:
    """Class for controlling the Trigger sub-system on the Tektronix FCA3103.

    Used for setup, initiating, and stopping trigger models."""

    def __init__(self, fca):
        self.fca = fca
        self.write = fca.write
        self.query = fca.query
        self.log = fca.log
        self.enum_slope = fca.enum_slope
        self.log_inst_errors = fca.log_inst_errors
        self.get_inst_errors = fca.get_inst_errors
        self.on_off = fca.on_off

    enum_arm_count = Enum("enum_arm_count", {'OFF': "1", 'INF': "INF"})

    enum_start_source = Enum("enum_start_source", {'A': "EXT1", 'B': "EXT2", 'E': "EXT4", 'OFF': "IMM"})
    enum_stop_source = Enum("enum_stop_source", {'A': "EXT1", 'B': "EXT2", 'E': "EXT4", 'OFF': "IMM",
                                                 'TIMER': "TIM"})

    def initiate(self):
        """
        Set the instrument's trigger system to take a measurement or multiple measurements.

        Initiate the trigger system to take a measurement. Changes the instrument trigger sub-system state from
        idle-state to wait-for-bus-arm-state.
        """
        # INITiate Initiate the trigger system to take a measurement.

        self.write(f"INIT")
        self.log_inst_errors()

    def initiate_continuous(self, continuous_on_off=None):
        """
        Initiate the trigger system to take continuous measurements.

        :param continuous_on_off: on_off value that does the following:

            * OFF - the trigger system remains in the idle-state until Continuous is set to ON or the method
              initiate is used.
            * ON - the completion of a measurement cycle immediately starts a new trigger cycle without entering
              the idle-state.
        :type continuous_on_off: str | int | bool
        :return: If called empty, queries the instrument for state of Continuous triggering.
        :rtype: str | None
        """
        # INITiate:CONTinuous Initiate the trigger system to take continuous measurements
        if continuous_on_off is None:
            return_value = {}
            return_value.update(continuous_on_off=self.on_off.to_api(self.query(f"INIT:CONT")))
            return return_value

        self.on_off.to_inst(continuous_on_off)
        self.write(f"INIT:CONT {self.on_off.to_inst(continuous_on_off)}")
        self.log_inst_errors()

    def abort(self):
        """Terminates a measurement.

        The trigger sub-system state is set to idle-state. The command does not invalidate already finished results
        when breaking an array measurement. This means that you can fetch a partial result after an abort.
        """
        # SYSTem:PRESet Recalls the default settings for the instrument.
        self.write("ABORT")
        self.log_inst_errors()

    def arming(self, count=None, delay=None, start_slope=None, start_source=None, stop_slope=None, stop_source=None,
               timer=None):
        """
        Configure or query parameters relating to trigger looping, timers, delays, sources and slopes.

        :param count: Loops the trigger sub-system count number of times. One of the following:

            *  INT  - Integer value between 2 and  2,147,483,647.
            * 'OFF' - Turns off looping in the trigger system.
            * 'INF' - Turns on infinite looping in the trigger system.
        :type count: enum_arm_count | str | int
        :param delay: Sets a delay between the pulse on the selected arming input and the time when the instrument
            starts measuring. Value between 20ns and 2s.
        :type delay: int | float
        :param start_slope: Sets the slope for the start arming condition. One of the following:

            * POSITIVE - Positive slope.
            * NEGATIVE - Negative slope.
        :type start_slope: enum_slope | str
        :param start_source: Selects start-arming input or switches off the start-arming function. When switched off
            the delay is inactive. One of the following:

            * A - Input channel A.
            * B - Input channel B.
            * E - Input channel E.
            * OFF - Trigger source is turned off and trigger is immediate
        :type start_source: enum_start_source | str
        :param stop_slope: Sets the slope for the stop arming condition.One of the following:

            * POSITIVE - Positive slope.
            * NEGATIVE - Negative slope.
        :type stop_slope: enum_slope | str
        :param stop_source: Selects stop-arming input or switches off the stop-arming function. The FCA3100 Series also
            has a programmable timer that is accessible in Totalize mode. One of the following:

            * A - Input channel A.
            * B - Input channel B.
            * E - Input channel E.
            * TIMER - Timer trigger based on the timer parameter.
            * OFF - Trigger source is turned off and trigger is immediate.
        :type stop_source: enum_stop_source | str
        :param timer: This command sets a delay between a pulse on the selected start arming input
            (when totalizing starts) and the point of time when totalizing stops. Value between 20ns and 2s.
        :type timer: int | float
        :return: If called empty, a dictionary of the parameter values reflecting the state of the instrument.
        :rtype: dict | None
        """
        # ARM:COUNt Sets or returns the upward exit of the wait-for-bus-arm state.
        # ARM:DELay Sets or returns a delay between the pulse on the selected arming input and the time when the
        # instrument starts measuring.
        # ARM:LAYer2 Overrides the waiting for bus arm, provided the source is set to bus.
        # ARM:LAYer2:SOURce Sets or returns the mode for the wait-for-bus-arm function
        # ARM:SLOPe Sets or returns the slope for the start arming condition.
        # ARM:SOURce Selects START arming input or switches off the start arming function.
        # ARM:STOP:SLOPe Sets or returns the slope for the stop arming condition.
        # ARM:STOP:SOURce Selects STOP arming input or switches off the STOP arming function.
        # ARM:STOP:TIMer Sets or returns a delay between a pulse on the selected start arming input and the
        # point of time when totalizing stops (FCA3100 Series only, Totalize mode only).

        # read back
        if all(param is None for param in [count, delay, start_slope, start_source, stop_slope, stop_source, timer]):
            ret_dict = {}
            temp = self.query("ARM:COUN")
            count = 'OFF' if (temp == '1') else temp
            ret_dict.update(count=count)
            ret_dict.update(delay=self.query("ARM:DEL", float))
            ret_dict.update(start_slope=self.query("ARM:SLOP", self.enum_slope).name)
            ret_dict.update(start_source=self.query("ARM:SOUR", self.enum_start_source).name)
            ret_dict.update(stop_slope=self.query("ARM:STOP:SLOP", self.enum_slope).name)
            ret_dict.update(stop_source=self.query("ARM:STOP:SOUR", self.enum_stop_source).name)
            ret_dict.update(timer=self.query("ARM:STOP:TIM", float))
            return ret_dict

        # parameter checks
        count_err = f"Bad count {count}. Should be 'OFF', 'INF', or integer between 2 and 2,147,483,647"
        if isinstance(count, int):
            check_range('count', count, min_max_units(2, 2147483647, 'Iterations'), count_err)
        else:
            count_obj = check_enum_str('count', count, self.enum_arm_count, count_err)
            if count_obj is not None:
                count = count_obj.value

        check_range('delay', delay, min_max_units(20e-9, 2, "Seconds"))
        check_range('timer', timer, min_max_units(20e-9, 2, "Seconds"))
        start_slope_obj = check_enum_str('start_slope', start_slope, self.enum_slope)
        stop_slope_obj = check_enum_str('stop_slope', stop_slope, self.enum_slope)
        start_source_obj = check_enum_str('start_source', start_source, self.enum_start_source)
        stop_source_obj = check_enum_str('stop_source', stop_source, self.enum_stop_source)

        # write to instrument
        if count is not None:
            self.write("ARM:COUN", count)
        if delay is not None:
            self.write("ARM:DEL", delay)
        if start_slope is not None:
            self.write("ARM:SLOP", start_slope_obj.value)
        if start_source is not None:
            self.write("ARM:SOUR", start_source_obj.value)
        if stop_slope is not None:
            self.write("ARM:STOP:SLOP", stop_slope_obj.value)
        if stop_source is not None:
            self.write("ARM:STOP:SOUR", stop_source_obj.value)
        if timer is not None:
            self.write("ARM:STOP:TIM", timer)

        self.log_inst_errors()

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
