# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import *
import cl_instr_lib.helpers.file_io as file
# Include python libraries
from enum import Enum
import time
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class System:
    """
    Class for controlling the System sub-systems on the Tektronix FCA3103.

    Used for manipulating memory, system status, display of the instrument.
    """
    def __init__(self, fca):
        self.fca = fca
        self.write = fca.write
        self.query = fca.query
        self.read_raw = fca.read_raw
        self.log = fca.log
        self.log_inst_errors = fca.log_inst_errors
        self.get_inst_errors = fca.get_inst_errors
        self.on_off = fca.on_off
        self.enum_slope = fca.enum_slope
        self.delay_range = fca.delay_range
        self.decode_ieee_header = fca.decode_ieee_header

    enum_input_AB = Enum("enum_input_AB", {"A": '1', "B": '2'})
    enum_coupling = Enum("enum_coupling", {"AC": 'AC', "DC": 'DC'})
    enum_polarity = Enum("enum_polarity", {"NORMAL": 'NORM', "INVERTED": 'INV'})
    enum_output_type = Enum("enum_output_type", {"PULSE": 'PULS', "GATE": 'GATE', "ALARM": 'ALAR', "OFF": 'OFF'})
    attenuation_range = min_max_units(1, 10, 'Units')
    filter_range = min_max_units(1, 50e6, 'Hz')
    impedance_range = min_max_units(50, 1e6, 'Ω')

    # FURTHER IMPLEMENTATION
    # Memory sub-system
    # --------------------------
    # MEMory:DATA:RECord:COUNt? Returns the number of samples in a given memory location.
    # MEMory:DATA:RECord:DELete Erases a given memory location.
    # MEMory:DATA:RECord:FETCh? Returns one sample from a given memory location.
    # MEMory:DATA:RECord:FETCh:ARRay? Returns multiple samples from a given memory location.
    # MEMory:DATA:RECord:FETCh:STARt Sets the pointer to the first sample in a given memory location.
    # MEMory:DATA:RECord:NAME? Returns the name of a given memory location.
    # MEMory:DATA:RECord:SAVE Saves samples in a given memory location.
    # MEMory:DATA:RECord:SETTings? Returns the instrument settings used when the specified <Dataset> was saved.
    # MEMory:DELete:MACRo Deletes an individual macro.
    # MEMory:FREE:MACRo? Returns the bytes used and available for macros.
    # MEMory:NSTates? Returns (one greater than) the number of available memory locations for instrument settings.

    # Status sub-system
    # --------------------------
    # STATus:DREGister0? Returns the contents of the Device Event Register.
    # STATus:DREGister0:ENABle Sets the enable bit of the Device Register 0.
    # STATus:OPERation? Returns the contents of the operation event status register
    # STATus:OPERation:CONDition? Returns the contents of the operation status condition register.
    # STATus:OPERation:ENABle Sets the enable bits of the operation status enable register.
    # STATus:PRESet Sets or clears all other enable registers other than the IEEE-488.2 enable registers.
    # STATus:QUEStionable? Returns the contents of the status questionable event register.
    # STATus:QUEStionable:
    # CONDition? Returns the contents of the status questionable condition register.
    # STATus:QUEStionable:ENABle Sets the enable bits of the status questionable enable register.

    def output(self, out_type=None, polarity=None, pulse_period=None, pulse_width=None):
        """
        Configure and query instrument output parameters.

        :param out_type: The command controls the rear panel pulse output configuration. One of the Following:

            * PULSE - The output serves as a fixed TTL level pulse generator.
            * GATE - (low level) Means that the output signals a pending measurement.
            * ALARM - (low or high level) Means that the output has an alarm condition.
            * OFF -  (low level) Means no activity.
        :type out_type: str | enum_output_type
        :param polarity: The command controls the polarity of the pulse output, but only if it is configured
            as an alarm circuit. One of the following:

            * NORMAL - Output level is high when the alarm is activated.
            * INVERTED - Output level is low when the alarm is activated.

        :type polarity: str | enum_polarity
        :param pulse_period: The pulse generator time parameters are activated when the output type is
            configured to pulse  20ns to 2s.
        :type pulse_period: int | float
        :param pulse_width: The pulse generator time parameters are activated when the output type is configured to
            pulse. 20ns to 2s.
        :type pulse_width: int | float
        :return: If called empty, a dictionary of the parameter values reflecting the state of the instrument.
        :rtype: dict | None
        """
        # Output sub-system
        # --------------------------
        # OUTPut:POLarity Sets or returns the polarity of the pulse output.
        # OUTPut:TYPE Sets or returns the function of the pulse output.
        # SOURce:PULSe:PERiod Sets the period for the pulse output.
        # SOURce:PULSe:WIDTh Sets the pulse width for the pulse output.

        # read back
        if all(parameter is None for parameter in [polarity, out_type, pulse_period, pulse_width]):
            return_value = {}
            return_value.update(polarity=self.query(f"OUTP:POL"))
            return_value.update(out_type=self.query(f"OUTP:TYPE", self.enum_output_type).name)
            return_value.update(pulse_width=self.query(f"SOUR:PULS:WIDT", float))
            return_value.update(pulse_period=self.query(f"SOUR:PULS:PER", float))
            self.log_inst_errors()
            return return_value

        # check parameters
        polarity_obj = check_enum_str("polarity", polarity, self.enum_polarity)
        out_type_obj = check_enum_str("out_type", out_type, self.enum_output_type)
        check_range("pulse_width", pulse_width, self.delay_range)
        check_range("pulse_period", pulse_period, self.delay_range)

        # write to instrument
        if polarity is not None:
            self.write("OUTP:POL", polarity_obj.value)
        if out_type is not None:
            self.write("OUTP:TYPE", out_type_obj.value)
        if pulse_width is not None:
            self.write("SOUR:PULS:WIDT", pulse_width)
        if pulse_period is not None:
            self.write("SOUR:PULS:PER", pulse_period)

        self.log_inst_errors()

    def input(self, channel, attenuation=None, coupling=None, a_filter=None, d_filter=None, d_filter_freq=None,
              impedance=None, trigger_level=None, auto_trigger_level=None, relative_trigger_level=None, slope=None):
        """
        Configure and query instrument input parameters.

        :param channel: Input channel being accessed. Either 'A' or 'B'.
        :type channel: str | enum_input_AB
        :param attenuation: Attenuates the specified input channel signal by 1 or 10. Numeric values <5 set the
            attenuation to 1. Numeric values ≥5 set the attenuation to 10.
        :type attenuation: int
        :param coupling: Selects Coupling:

            * "AC" - AC coupling (normally used for frequency measurements).
            * "DC" - DC coupling (normally used for time measurements).
        :type coupling: str | enum_coupling
        :param a_filter: on_off value ('ON'/'OFF' preferred) that switches on or off the analog low pass filter.
            It has a cutoff frequency of 100 kHz.
        :type a_filter: str | int | bool
        :param d_filter: on_off value ('ON'/'OFF' preferred) that switches on or off the digital low pass filter.
            Cutoff frequency is determined by d_filter_freq.
        :type d_filter: str | int | bool
        :param d_filter_freq: Any frequency between 1 Hz and 50 MHz.
        :type d_filter_freq: int | float
        :param impedance: The input impedance can be set to 50 Ω or 1 MΩ.
        :type impedance: int | float
        :param trigger_level: The input can be set to auto_trigger_level or to fixed trigger levels  of between
            -5V and +5V in steps of 2.5mV. If the attenuation is set to 10X, the range is -50V and +50V in 25 mV steps.
            Setting an absolute trigger level turns off auto_trigger_level for the selected channel.
        :type trigger_level: int | float
        :param auto_trigger_level: on_off value ('ON'/'OFF' preferred) that switches on or off the automatic
            control of the trigger level. **Note:** trigger_level will override this parameter if both are used.
            The auto-trigger function normally sets the trigger levels to 50 % of the signal amplitude,
            except for the following measurements or modes:

            * Rise/Fall time measurements - Here the Input(A) trigger level is set to 10%resp. 90% and the Input(B)
              trigger level is set to 90% respectively. 10% of the amplitude.
            * Frequency and Period Average mode - The input trigger levels are set to 70% and 30% of the signal
              amplitude.
            * Functions for which AUTO does not work are Frequency or Period Back-to-Back, Time Interval Error (TIE)
              and Totalize. If one of these is selected, an AUTO ONCE is performed instead.
        :type auto_trigger_level: str | int | bool
        :param relative_trigger_level: When auto-trigger is active, the relative trigger levels are normally fixed at
            values that depend on the selected function, for instance 10% (Input A) and 90% (Input B) for Rise Time,
            50% (Input A & Input B) for Time Interval, 70% (Input A) and 30% (Input B) for Frequency.
            At times you may want to change these values. Since the default values are restored automatically after
            changing function, this command may have to be sent repeatedly. The two input channels are programmed
            separately and are not interdependent.
        :type relative_trigger_level: int | float
        :param slope: on_off value ('ON'/'OFF' preferred) that selects if the instrument should trigger on a positive
            or a negative transition. Selecting negative slope is useful for Time Interval measurements. The slope
            is fixed for Pos/Neg Pulse Width/Duty Factor and Rise/Fall Time.
        :type slope: str | int | bool
        :return: If called empty, a dictionary of the parameter values reflecting the state of the instrument.
        :rtype: dict | None
        """
        # Input sub-system
        # --------------------------
        # INPut{[1]|2}:ATTenuation Sets or returns the input attenuation.
        # INPut{[1]|2}:COUPling Sets or returns the input coupling.
        # INPut{[1]|2}:FILTer Switches on or off the analog low pass filter.
        # INPut{[1]|2}:FILTer:DIGital Switches on or off the digital low pass filter.
        # INPut{[1]|2}:FILTer:DIGital:FREQuency Sets or returns the digital filter cutoff frequency.
        # INPut{[1]|2}:IMPedance Sets or returns the input impedance.
        # INPut{[1]|2}:LEVel Sets or returns the input threshold level.
        # INPut{[1]|2}:LEVel:AUTO Switches auto-trigger level on or off.
        # INPut{[1]|2}:LEVel:RELative Sets or returns specific trigger levels for different measurements.
        # INPut{[1]|2}:SLOPe Sets or returns the slope for certain measurements.

        channel_obj = check_enum_str("channel", channel, self.enum_input_AB)

        list_of_parameters = [attenuation, coupling, a_filter, d_filter, d_filter_freq, impedance, trigger_level,
                              auto_trigger_level, relative_trigger_level, slope]

        # read back
        if all(parameter is None for parameter in list_of_parameters):
            return_value = {}
            return_value.update(channel=channel_obj.name)
            return_value.update(attenuation=self.query(f"INPUT{channel_obj.value}:ATT", float))
            return_value.update(coupling=self.query(f"INPUT{channel_obj.value}:COUP"))
            return_value.update(a_filter=self.on_off.to_api(self.query(f"INPUT{channel_obj.value}:FILT")))
            return_value.update(d_filter=self.on_off.to_api(self.query(f"INPUT{channel_obj.value}:FILT:DIG")))
            return_value.update(d_filter_freq=self.query(f"INPUT{channel_obj.value}:FILT:DIG:FREQ", float))
            return_value.update(impedance=self.query(f"INPUT{channel_obj.value}:IMP", float))
            return_value.update(trigger_level=self.query(f"INPUT{channel_obj.value}:LEV", float))
            return_value.update(auto_trigger_level=self.on_off.to_api(self.query(f"INPUT{channel_obj.value}:LEV:AUTO")))
            return_value.update(relative_trigger_level=self.query(f"INPUT{channel_obj.value}:LEV:REL", float))
            return_value.update(slope=self.query(f"INPUT{channel_obj.value}:SLOP", self.enum_slope).name)
            self.log_inst_errors()
            return return_value

        # check parameters
        coupling_obj = check_enum_str('coupling', coupling, self.enum_coupling)
        slope_obj = check_enum_str('slope', slope, self.enum_slope)
        check_range('d_filter_freq', d_filter_freq, self.filter_range)
        check_range('impedance', impedance, self.impedance_range)
        check_range('attenuation', attenuation, self.attenuation_range)
        check_range("relative_trigger_level", relative_trigger_level, min_max_units(0, 100, 'Percent'))
        self.on_off.to_inst(a_filter)
        self.on_off.to_inst(d_filter)
        self.on_off.to_inst(auto_trigger_level)

        # trigger level range depends on attenuation of the input.
        prev_att = self.query("INPUT:ATT", int)
        if (attenuation is not None and attenuation >= 5) or prev_att == 10:
            check_range('trigger_level', trigger_level, min_max_units(-50, 50, 'Volts'))
        else:
            check_range('trigger_level', trigger_level, min_max_units(-5, 5, 'Volts'))

        # write to the instrument
        if attenuation is not None:
            self.write(f"INPUT{channel_obj.value}:ATT", attenuation)
        if coupling is not None:
            self.write(f"INPUT{channel_obj.value}:COUP", coupling_obj.value)
        if a_filter is not None:
            self.write(f"INPUT{channel_obj.value}:FILT", self.on_off.to_inst(a_filter))
        if d_filter is not None:
            self.write(f"INPUT{channel_obj.value}:FILT:DIG", self.on_off.to_inst(d_filter))
        if d_filter_freq is not None:
            self.write(f"INPUT{channel_obj.value}:FILT:DIG:FREQ", d_filter_freq)
        if impedance is not None:
            self.write(f"INPUT{channel_obj.value}:IMP", impedance)
        if trigger_level is not None:
            self.write(f"INPUT{channel_obj.value}:LEV", trigger_level)
        if auto_trigger_level is not None:
            if trigger_level is None:
                self.write(f"INPUT{channel_obj.value}:LEV:AUTO", self.on_off.to_inst(auto_trigger_level))
        if relative_trigger_level is not None:
            self.write(f"INPUT{channel_obj.value}:LEV:REL", relative_trigger_level)
        if slope is not None:
            self.write(f"INPUT{channel_obj.value}:SLOP", slope_obj.value)

        self.log_inst_errors()

    def input_auto_set(self):
        """Automatically sets the trigger levels for the measurement function and input signal amplitude."""
        # AUTO Performs the same task as the front panel button AUTO SET.
        self.write("AUTO ONCE")
        self.log_inst_errors()

    def recall_preset(self):
        """Recalls the default settings for the instrument."""
        # SYSTem:PRESet Recalls the default settings for the instrument.
        self.write("AUTO PRES")
        time.sleep(0.1)  # time needed for the instrument to recall the presets
        self.write("SYST:PRES")
        time.sleep(0.2)  # time needed for the instrument to recall the presets
        self.log_inst_errors()

    def temperature(self):
        """
        Queries the internal temperature of the instrument in Celsius.

        :return: Temperature of the instrument in Celsius.
        :rtype: str
        """
        # SYSTem:TEMPerature?
        # Returns the temperature in degrees C at the fan control sensor inside the instrument housing.
        temp = self.query('SYST:TEMP?') + "°C"
        self.log_inst_errors()
        return temp

    def display(self, on_off=None):
        """
        Queries or sets the Display State (ON or OFF) of the instrument.

        :param on_off: on_off value ('ON'/'OFF' preferred) that sets the state of the instrument display
        :type on_off: Str | int | bool
        :return: State of the instrument display.
        :rtype: str
        """
        # DISPlay:ENABle Turns On/Off the updating of the screen

        if on_off is None:
            on_off = self.on_off.to_api(self.query('DISP:ENAB'))
            self.log_inst_errors()
            return on_off

        self.write("DISP:ENAB", self.on_off.to_inst(on_off))
        self.log_inst_errors()

    def self_test(self):
        """
        Instructs the machine to conduct an internal self test.

        :return: Error code or 'No Error'.
        :rtype: str
        """
        error_dict = {"0": "No Error", "1": "RAM Failure", "2": "ROM Failure", "4": "Logic Failure",
                      "8": "Display Failure"}

        error_code = error_dict.get(self.query("*TST?", str))
        if error_code is not 'No Error':
            raise RuntimeError(f"{error_code} detected.")
        return error_code

    def screenshot(self, pc_dir, file_name, create_dir=False):
        """
        Queries the instrument for a block of data containing a screen image in Windows BMP format. This image will be
        saved to the directory and filename specified by the pc_dir and file_name parameters.

        :param pc_dir: Directory being accessed or created for the write command.
        :type pc_dir: str
        :param file_name: File name for the write command. exclude file extension. 'sample.txt' should be 'sample'.
        :type file_name: str
        :param create_dir: on_off value ('ON'/'OFF' preferred) that determines if a directory will be made in the event
            pc_dir does not currently exist. Defaults to False.
        :type create_dir: bool | int | str
        :return: Creates a BMP file in the specified directory.
        """
        # HCOPy:SDUMp:DATA? Returns block data containing a screen image in Windows BMP format.
        self.write("HCOP:SDUM:DATA?")
        raw_data = self.read_raw()
        self.log_inst_errors()
        # remove newline and IEEE header from read
        data_length, data = self.decode_ieee_header(raw_data[:len(raw_data)-1])
        file.write(pc_dir, file_name, 'bmp', data, binary_data=True, create_dir=create_dir)


# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
