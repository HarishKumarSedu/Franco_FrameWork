# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import *
# Include python libraries
from enum import Enum
from abc import ABC
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# Configuration and Measure both inherit from the MeasureConfigABC. Much of the scpi commands are the same
# across both sub-systems with the caveat of configure operations being writes to 'setup' the instrument for read
# commands or trigger system commands, while the Measurement sub-system is directly querying the instrument for values.

# There is also abstraction occuring in the form of using the same methods for taking singular measurements or multiple
# measurements, by using the array size. Having an array size of one acts as the scpi command is missing the array
# formatting. e.g. MEAS:ARR:FREQ? (array_size), (channel) and MEAS:FREQ? (channel) are essentially the same command so
# their methods have logic to determine if single or multiple measurements are wanted.

# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class MeasureConfigABC(ABC):
    """
    Abstract Base Class for the Measurement and Configuration subsystems.

    All configuration and settings regarding taking measurements is handled within the Config class.
    All Querying of data from measurements or fetching/reading data from the instruments read buffer is handled within
    the Measure class.

    Measurements can be taken from the FCA3103 in three ways in varying complexity:

        * measure - configures, initiates and returns value in one step.
        * config -> read - configure in one step to select settings, then initiates and returns value using read.
        * config -> initiate -> fetch - configures in one step to select settings, then initiates using the trigger
          sub-system, then data must be fetched off the instrument's read buffer.

    """

    def __init__(self, fca, meas_or_config):
        self.fca = fca
        self.write = fca.write
        self.query = fca.query
        self.read_raw = fca.read_raw
        self.log = fca.log
        self.log_inst_errors = fca.log_inst_errors
        self.get_inst_errors = fca.get_inst_errors
        self.on_off = fca.on_off
        self.enum_channel_AB = fca.enum_channel_AB
        self.enum_channel_ABC = fca.enum_channel_ABC
        self.acq_aperture = fca.acq_aperture
        self.acq_aperture_btb = fca.acq_aperture_btb
        self.delay_range = fca.delay_range
        self.hoff_range = fca.delay_range
        self._meas_or_conf = meas_or_config

    # function enumerations and ranges
    enum_func_freq = Enum("enum_func_freq", {"FREQUENCY": "FREQ", "FREQUENCY_BURST": "FREQ:BURS",
                                             "FREQUENCY_PRF": "FREQ:PRF"})
    enum_func_duty_cycles = Enum("enum_func_duty_cycles", {"POS_DUTY": "PDUT", "NEG_DUTY": "NDUT"})
    enum_func_period = Enum("enum_func_period", {"PERIOD": "PER", "PERIOD_AVERAGE": "PER:AVER"})
    enum_func_slew = Enum("enum_func_slew", {'POSITIVE': "PSLE", 'NEGATIVE': "NSLE"})
    enum_func_rise_fall = Enum("enum_func_rise_fall", {'RISE': "RTIM", 'FALL': "FTIM"})
    enum_func_pulse_width = Enum("enum_func_pulse_width", {'P_WIDTH': "PWID", 'N_WIDTH': "NWID"})
    enum_func_voltage = Enum("enum_func_voltage", {'MAX': "VOLT:MAX", 'MIN': "VOLT:MIN", 'PEAK2PEAK': "VOLT:PTP"})
    enum_text_format = Enum("enum_text_format", {'ASCII': "ASC", 'REAL': "REAL", 'PACKED': "PACK"})
    enum_border = Enum("enum_border", {'NORMAL': "NORM", 'SWAPPED': "SWAP"})

    array_range = min_max_units(1, 10000, 'Samples')
    channel_AB_freq_range = min_max_units(0.001, 3e8, 'Hz')
    channel_AB_period_range = min_max_units(3.3e-9, 1000, 's')  # res 50 ps (single); 12 digit/s avg. (FCA3100 Series)
    channel_AB_period_range_btb = min_max_units(4e-6, 1000, 's')
    channel_C_freq_range = min_max_units(1e8, 3e9, 'Hz')
    channel_C_period_range = min_max_units(50e-12, 10e-9, 's')  # res 50 ps (single); 12 digit/s avg. (FCA3100 Series)
    channel_voltage_range = min_max_units(0, 12, 'Vrms')

    # FURTHER IMPLEMENTATION
    # Measure sub-system
    # --------------------------

    # MEASure:MEMory? Recalls an instrument setting stored in memory and returns a measurement value.
    # MEASure:MEMory<N>? Recalls an instrument setting stored in memory and returns a measurement value.
    # TOTalize:GATE Opens and closes the gate for continuous measurements
    # MEASure:ARRay:STSTamp? Takes a series of back-to-back time-stamp measurements.
    # MEASure:ARRay:TIError? Takes a series of back-to-back relative frequency measurements.

    # Configure sub-system
    # --------------------------
    # CONFigure:TOTalize[:CONTinuous]  Set up the instrument to take repeated measurements.

    def freq_btb(self, channel, array_size=None):
        """
        A series of consecutive frequency average measurements without dead time can be made in order to fulfill
        the requirements for correct calculation of Allan variance or deviation.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure:ARRay:FREQuency:BTBack? Takes a series of back-to-back frequency measurements.
        # check all parameters
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + "FREQ:BTB"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def period_btb(self, channel, array_size=None):
        """
        Every positive or negative zero crossing (depending on the selected slope) up to the maximum frequency
        (interpolator calibration ON/OFF = 125kHz/250kHz) is time-stamped. For every new time stamp the
        previous value is subtracted from the current value, and the result is stored.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure:ARRay:PERiod:BTBack? Takes a series of back-to-back period measurements.
        # check all parameters
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + "PER:BTB"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def freq(self, function, channel, array_size=None):
        """
        Frequency operation. Method used for configuring or measuring depending on the class from which it is called.

        A measurement query in the measurement class and a write in the configure class.

        :param function: frequency operation:

            * FREQUENCY - Traditional frequency measurements.
            * FREQUENCY_BURST -Measures the carrier frequency of a burst. The burst duration must be less than
              50% of the pulse repetition frequency (PRF).
            * FREQUENCY_PRF - Measures the PRF ( Pulse Repetition Frequency) of a burst signal. The burst
              duration must be less than 50% of the pulse repetition frequency (PRF).
        :type function: str | enum_func_freq
        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_ABC
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure:FREQuency? Takes a frequency measurement.
        # MEASure:FREQuency:BURSt? Takes a measurement of the carrier frequency of a burst.
        # MEASure:FREQuency:PRF? Takes a pulse-repetition frequency measurement.

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_func_freq)
        channel_obj = check_enum_str('channel', channel, self.enum_channel_ABC)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + function_obj.value

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def freq_pow(self, array_size=None):
        """
        Frequency power operation on channel C.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # FREQ:POW
        # MEASure:FREQuency:POWer[:AC]? Takes a power measurement.

        # check all parameters
        channel_obj = check_enum_str('channel', 'C', self.enum_channel_ABC)  # forces channel C without changing code
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + "FREQ:POW"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def freq_ratio(self, channel1, channel2, array_size=None):
        """
        Frequency ratio operation. ratio = Ch1 / Ch2

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        **Note:** Operations including channels that are disconnected result in a VISA IO error.

        :param channel1: Numerator channel to which the measurement is taking place.
        :type channel1: str | enum_channel_ABC
        :param channel2: Denominator channel to which the measurement is taking place.
        :type channel2: str | enum_channel_ABC
        :param array_size: size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # FREQ:RAT
        # MEASure:FREQuency:RATio? Takes a frequency ratio measurement.

        # check all parameters
        channel1_obj = check_enum_str('channel1', channel1, self.enum_channel_ABC)
        channel2_obj = check_enum_str('channel2', channel2, self.enum_channel_ABC)
        if channel1_obj.name == channel2_obj.name:
            raise ValueError(f"Bad Channels {channel1_obj.name} and {channel2_obj.name}. "
                             f"Ratio needs different channels")
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'
        channel_ratio_str = f"{channel1_obj.value},{channel2_obj.value}"

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += channel_ratio_str
        cmd_header = self._meas_or_conf + array_str + "FREQ:RAT"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def n_cycles(self, channel, array_size=None):
        """
        If frequency burst is active, this method operates on the number of cycles in each burst.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_ABC
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        #  NCYCL
        # MEASure[:VOLT]:NCYCles? Measures the number of cycles in a burst.

        # check all parameters
        channel_obj = check_enum_str('channel', channel, self.enum_channel_ABC)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + "NCYC"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def duty_cycles(self, function, channel, array_size=None, threshold=None):
        """
        Duty cycle measurement is performed. That is, the ratio between the on time and the off time of the
        input pulse.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

         :param function: Duty cycle operation:

            * POS_DUTY - Traditional positive duty cycle measurements.
            * NEG_DUTY - Traditional negative duty cycle measurements.

        :type function: str | enum_func_duty_cycles
        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :param threshold: Sets the trigger levels in volts. If omitted, the auto-trigger level is set to 50 percent
            of the signal.
        :type threshold: int | float
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure:NDUTycycle? Takes a negative duty cycle measurement.
        # MEASure{:PDUTycycle|:DCYCle}? Takes a positive duty cycle measurement.

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_func_duty_cycles)
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, self.array_range)
        check_range('threshold', threshold, self.channel_voltage_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += '' if threshold is None else f'{threshold}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + function_obj.value

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def period(self, function, channel, array_size=None):
        """
        period time operations.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

         :param function: Operations:

            * PERIOD - A period time measurement. Acquisition aperture does not affect this measurement.
            * PERIOD_AVERAGE - A traditional period time measurement is performed on multiple periods. Measuring time
              set by the Acquisition aperture determines the resolution.

        :type function: str | enum_func_period
        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_ABC
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure:PERiod? Takes a period measurement.
        # MEASure:PERiod:AVERage? Returns an average of multiple period measurements.

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_func_period)
        channel_obj = check_enum_str('channel', channel, self.enum_channel_ABC)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + function_obj.value

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def phase(self, channel1, channel2, array_size=None):
        """
        Traditional phase operation.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        :param channel1: Channel to which the measurement is taking place. Start channel.
        :type channel1: str | enum_channel_AB
        :param channel2: Channel to which the measurement is taking place. Stop channel.
        :type channel2: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # PHASe
        # MEASure:PHASe? Takes a phase measurement.

        # check all parameters
        channel1_obj = check_enum_str('channel1', channel1, self.enum_channel_AB)
        channel2_obj = check_enum_str('channel2', channel2, self.enum_channel_AB)
        if channel1_obj.name == channel2_obj.name:
            raise ValueError(f"Bad Channels {channel1_obj.name} and {channel2_obj.name}. "
                             f"Phase needs different channels")
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'
        channels_str = f"{channel1_obj.value},{channel2_obj.value}"

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += channels_str
        cmd_header = self._meas_or_conf + array_str + "PHASE"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def slew(self, function, channel, array_size=None):
        """
        This command observes the slew rate in V/s on either main input channel.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

         :param function: Operations:

            * POSITIVE - The positive slew rate in V/s
            * NEGATIVE - The negative slew rate in V/s

        :type function: str | enum_func_slew
        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure[:VOLT]:NSLEwrate? Takes a negative slew rate measurement.
        # MEASure[:VOLT]:PSLEwrate? Takes a positive slew rate measurement.

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_func_slew)
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + function_obj.value

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def rise_fall(self, function, channel, array_size=None):  # low_thresh=None, high_thresh=None
        """
        The transition time from threshold to threshold of the signal amplitude is measured.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        The measurement is always a single measurement and the Auto-trigger is always on, setting the trigger
        levels to 10% and 90% of the amplitude. If you need an average transition time measurement or other trigger
        levels, use the SENSe subsystem and manually set trigger levels instead.

        :param function: Operations:

            * RISE - Transition time from 10% to 90%
            * FALL - Transition time from 90% to 10%
        :type function: str | enum_func_rise_fall
        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure{:FALL:TIME|:FTIM}? Takes a fall time measurement.
        # MEASure{:RISE:TIME|:RTIM}? Takes a rise time measurement.

        # :param low_thresh: lower threshold.
        # :type low_thresh:
        # :param high_thresh: higher threshold
        # :type high_thresh:
        # TODO: figure out how to use the threshold system.

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_func_rise_fall)
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + function_obj.value

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def pulse_width(self, function, channel, array_size=None):
        """
        pulse width operations

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

         :param function: Operations:

            * P_WIDTH - A positive pulse width measurement is performed.
            * N_WIDTH - A negative pulse width measurement is performed.

        :type function: str | enum_func_pulse_width
        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure:NWIDth? Takes a negative pulse width measurement.
        # MEASure:PWIDth? Takes a positive pulse width measurement.

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_func_pulse_width)
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + function_obj.value

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def time_interval(self, channel1, channel2, array_size=None):
        """
        Traditional time-interval measurements are performed.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        The trigger levels are set automatically, and positive slope is used. The first channel in the channel list is
        the start channel, and the second is the stop channel.

        :param channel1: Channel to which the measurement is taking place. Start Channel.
        :type channel1: str | enum_channel_AB
        :param channel2: Channel to which the measurement is taking place. Stop Channel.
        :type channel2: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # measure Time interval TINTerval
        # MEASure:TINTerval? Takes a time interval measurement.

        # check all parameters
        channel1_obj = check_enum_str('channel1', channel1, self.enum_channel_AB)
        channel2_obj = check_enum_str('channel2', channel2, self.enum_channel_AB)
        if channel1_obj.name == channel2_obj.name:
            raise ValueError(f"Bad Channels {channel1_obj.name} and {channel2_obj.name}."
                             f" time interval needs different channels")
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'
        channels_str = f"{channel1_obj.value},{channel2_obj.value}"

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += channels_str
        cmd_header = self._meas_or_conf + array_str + "TINT"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def timestamp(self, channel, array_size):
        """
        Time stamps are taken of all positive and negative trigger level crossings of the selected input channel.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        Automatically invokes format(time_info='ON') to get the time stamp data.

        :param channel: Channel to which the measurement is taking place. Start Channel.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement. 2-10000 Samples.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # measure timestamp TSTAmp
        # MEASure:ARRay:TSTAmp? Takes a series of back-to-back time-stamp measurements taken at all
        # positive and negative trigger level crossings.

        # check all parameters
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, min_max_units(2, 10000, 'Samples'))
        array_size = int(array_size) if array_size is not None else None
        if array_size is None:
            raise ValueError(f"Bad array_size {array_size} must be between 2 and 10000 samples.")

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + "TSTA"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def voltage(self, function, channel, array_size=None):
        """
        Voltage operations.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        :param function: Voltage operation:

            * MAX - Measures the positive peak voltage with the input DC coupled.
            * MIN - Measures the negative peak voltage with the input DC coupled.
            * PEAK2PEAK - This command measures the peak-to-peak voltage on either main input channel.
        :type function: str | enum_func_voltage
        :param channel: Channel to which the measurement is taking place.
        :type channel: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # MEASure[:VOLT]:MAXimum? Takes a positive peak voltage measurement.
        # MEASure[:VOLT]:MINimum? Takes a negative peak voltage measurement.
        # MEASure[:VOLT]:PTPeak? Takes a peak-to-peak voltage measurement.

        # check all parameters
        function_obj = check_enum_str('function', function, self.enum_func_voltage)
        channel_obj = check_enum_str('channel', channel, self.enum_channel_AB)
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += f"{channel_obj.value}"
        cmd_header = self._meas_or_conf + array_str + function_obj.value

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]

    def voltage_ratio(self, channel1, channel2, array_size=None):
        """
        Voltage ratio operation.

        This command measures the peak-to-peak voltage ratio in dB between the selected channels.

        Method used for configuring or measuring depending on the class from which it is called.
        A measurement query in the measurement class and a write in the configure class.

        :param channel1: Numerator channel to which the measurement is taking place.
        :type channel1: str | enum_channel_AB
        :param channel2: Denominator channel to which the measurement is taking place.
        :type channel2: str | enum_channel_AB
        :param array_size: Size of the array used in the measurement.

            * 1 | None - Traditional single measurement. (Default)
            * 2-10000 - Array of measurements.
        :type array_size: int
        :return: If Measurement taken, returns as a float or a list of float values regardless of config.format().
        :rtype: None | float | list[float]
        """
        # measure voltage ratio VOLT:RATIO
        # MEASure[:VOLT]:RATio? Takes a peak-to-peak voltage ratio measurement.

        # check all parameters
        channel1_obj = check_enum_str('channel1', channel1, self.enum_channel_AB)
        channel2_obj = check_enum_str('channel2', channel2, self.enum_channel_AB)
        if channel1_obj.name == channel2_obj.name:
            raise ValueError(f"Bad Channels {channel1_obj.name} and {channel2_obj.name}."
                             f" Voltage Ratio needs different channels")
        check_range('array_size', array_size, self.array_range)
        array_size = int(array_size) if array_size is not None else None

        # if the user specifies an array of one then the scpi header omits ARR: and omit array size param.
        array_str = '' if array_size in [1, None] else 'ARR:'
        channels_str = f"{channel1_obj.value},{channel2_obj.value}"

        # create the command and target for neatness and debug
        pre_target = '' if array_size in [1, None] else f'{array_size}, '
        pre_target += channels_str
        cmd_header = self._meas_or_conf + array_str + "VOLT:RAT"

        # write or query depending on if the method is configuring or measuring.
        if self._meas_or_conf == "CONF:":
            # send command, log errors
            self.write(cmd_header, pre_target)  # MEAS:(ARR:)(FUNC) (size), (channel)
            self.log_inst_errors()
        else:
            # send command, log errors
            # MEAS:(ARR:)(FUNC)? (size), (channel)
            ret_data = self.query(cmd_header, pre_target_params=pre_target).split(',')
            self.log_inst_errors()

            # if the returned list has one value then return a single float
            if len(ret_data) > 1:
                return [float(value) for value in ret_data]
            else:
                return ret_data[0]


class Measure(MeasureConfigABC):
    """
    Class for controlling the Measure sub-system on the Tektronix FCA3103. Inherits from the MeasureConfigABC.

    Used for collecting measurements from the instrument.

    All Querying of data from measurements or fetching/reading data from the instruments read buffer is handled within
    the Measure class.
    """

    def __init__(self, fca):
        super().__init__(fca, meas_or_config="MEAS:")

    def fetch(self):
        """
        Fetches a single measurement from the instrument memory without conducting another measurement.

        **Note:** Depending on the measurement formatting, the returned value from the instrument could be
        ASCII or byte data. See config.format() method.

        :return: Data from the Instrument's read buffer. Either ASCII or Byte Data
        :rtype: str | bytes
        """
        # FETCh[:SCALar]? Fetches a single measurement.
        data = self._query_helper("FETCH")
        return data

    def fetch_array(self, array_size="MAX"):
        """
        Fetch multiple measurements from the instrument memory in an array of size max_samples.

        **Note:** Depending on the measurement formatting, the returned value from the instrument could be
        ASCII or byte data. See config.format() method.
        :param array_size: Size of the read back array, between 1 and 10000. Defaults to maximum size.
        :type array_size: str | int | float
        :return: Data from the Instrument's read buffer. Either ASCII or Byte Data
        :rtype: str | bytes
        """
        if array_size != "MAX":
            check_range('array_size', array_size, self.array_range)
        # FETCh:ARRay? Fetches multiple measurements.
        data = self._query_helper("FETC:ARR?", pre_target=array_size)
        return data

    def read(self):
        """
        Performs a new single measurement and returns it from the instrument.

        **Note:** Depending on the measurement formatting, the returned value from the instrument could be
        ASCII or byte data. See config.format() method.

        :return: Data from the Instrument's read buffer. Either ASCII or Byte Data
        :rtype: str | bytes
        """
        # READ? Performs a new measurement and reads out a measuring result.
        data = self._query_helper("READ?")
        return data

    def read_array(self, array_size):
        """
        Read multiple measurements from the instrument memory in an array.

        **Note:** Depending on the measurement formatting, the returned value from the instrument could be
        ASCII or byte data. See config.format() method.

        :param array_size: size of the desired array of readings, from 1 to 10k
        :type array_size: int
        :return: Data from the Instrument's read buffer. Either ASCII or Byte Data
        :rtype: str | bytes
        """
        # READ:ARRay? Performs multiple measurements and reads out the measuring results.
        check_range("array_size", array_size, min_max_units(1, 10000, "Samples"))
        data = self._query_helper("READ:ARR?", pre_target=array_size)
        return data

    def _query_helper(self, query_msg, ret_type=None, pre_target=None, target=None):
        """Helper to avoid format errors of the query data coming back. """

        if self.fca._formatting == 'REAL':  # PACKED OR REAL MODE

            # handle the parsing of the query statement exactly like query does in instrument class
            query_msg = query_msg.rstrip("?") + '?'
            if pre_target is not None:
                query_msg += ' ' + pre_target
            if target is not None:
                if query_msg[-1] != '?':
                    query_msg += ','
                query_msg += ' ' + target

            # write the query instead so we may read_raw ex post facto
            self.write(query_msg)
            raw_data = self.read_raw()
            return raw_data[:len(raw_data) - 1]  # strip the newline on the return.

        else:
            return self.query(query_msg, ret_type, pre_target, target)

class Config(MeasureConfigABC):
    """
    Class for controlling the Configure sub-system on the Tektronix FCA3103. Inherits from the MeasureConfigABC.

    The configure sub-system sets up the instrument to make the same measurements
    as the Measure sub-system, but without initiating the measurement and fetching the
    result.

    Use configure when you want to change any parameters before making the measurement.

    All configuration and settings regarding taking measurements is handled within the Config class.
    """

    def __init__(self, fca):
        super().__init__(fca, meas_or_config="CONF:")

    sync_per_range = min_max_units(1e-6, 2.0, 'Seconds')

    def format(self, text_format=None, border=None, max_samples=None, time_info=None):
        """
        Query or configure various formatting parameters for fetching data.

        :param text_format: Sets the format in which the result is sent on the bus.

            * ASCII - The length is automatically controlled by the resolution of each measurement result.
            * REAL - The length parameter is ignored; the output is always in 8-byte format. See time_info. **Note**
              there is no support for decoding REAL data in this driver, use PACKED mode instead.
            * PACKED - The length parameter is ignored; the output is always in 8-byte format. See time_info.
        :type text_format: str | enum_text_format
        :param border: Sets the order in which response data bytes formatted as REAL or PACKED are sent on the bus.

            * NORMAL - Response data is sent with the MSB first and the LSB last (big-endian order)
            * SWAPPED -  Response data is sent with the LSB first and the MSB last (little-endian order)
        :type border: str | enum_border
        :param max_samples: Sets or queries the upper limit for fetch_array_max command in number of samples.
            integer value from 4 to 10000.
        :type max_samples: int
        :param time_info: on_off value ('ON'/'OFF' Preferred) determining the inclusion of measurement time stamps.
            Time stamping is always done at the start of a measurement with full measurement resolution, and is saved in
            the measurement buffer together with the measurement result.

            * ASCII mode - Both the measured value and the timestamp value are given as floating-point numbers
              expressed in the basic units (Hz or s).
            * REAL mode - (float64, float64) The result is given as an eight-byte block containing the floating-point
              measured value followed by an eight-byte block containing the floating point timestamp value.
            * PACKED mode - (float64, int64) The result is given as an eight-byte block containing the floating-point
              measured value followed by an eight-byte block containing the timestamp value expressed as a
              64-bit integer with the unit being ps.
        :type time_info: str | int | bool
        :return: If called empty, a dictionary of the parameter values reflecting the state of the instrument.
        :rtype: dict | None
        """
        # FORMat Sets or returns the format in which the result is sent on the bus.
        # FORMat:BORDer Sets or returns the order in which response data bytes formatted.
        # FORMat:SMAX Sets or queries the upper limit for FETCh:ARRay?
        # FORMat:TINFormation Turns on/off the time stamping of measurements.

        if all(param is None for param in [text_format, border, max_samples, time_info]):
            return_value = {}
            text_format = self.query("FORM", self.enum_text_format).name
            return_value.update(text_format=text_format)
            self.fca._formatting = text_format
            return_value.update(border=self.query("FORM:BORD", self.enum_border).name)
            return_value.update(max_samples=self.query("FORM:SMAX", int))
            return_value.update(time_info=self.on_off.to_api(self.query("FORM:TINF")))
            self.log_inst_errors()
            return return_value

        # check all parameters.
        text_format_obj = check_enum_str("text_format", text_format, self.enum_text_format)
        border_obj = check_enum_str("border", border, self.enum_border)
        check_range('max_samples', max_samples, min_max_units(4, 10000, 'Samples'))
        self.on_off.to_inst(time_info)

        # write to machine
        if text_format is not None:
            self.write(f'FORM {text_format_obj.value}')
            self.fca._formatting = text_format_obj.name
        if border is not None:
            self.write(f'FORM:BORD {border_obj.value}')
        if max_samples is not None:
            self.write(f'FORM:SMAX {int(max_samples)}')
        if time_info is not None:
            self.write(f'FORM:TINF {self.on_off.to_inst(time_info)}')

        # log errors
        self.log_inst_errors()

    def acquisition(self, aperture=None, hold_off=None):
        """
        Configure and query acquisition parameters such as gate time and hold off time for measurements.

        :param aperture: Sets the gate time for one measurement in seconds.
            20 ns to 1000s, although back to back readings operate between 10us and 500s.
        :type aperture: int | float
        :param hold_off: Sets the Hold Off time value or turn the functionality off.

            * 'OFF' - turns hold_off function off.
            *  float - 20ns to 2s hold off time.
        :type hold_off: str | int | float
        :return: if called empty, returns a dictionary of the current parameters.
        :rtype: None | dict
        """
        # ACQuisition:APERture Sets or returns the gate time for a measurement.
        # ACQuisition:HOFF Switches the holdoff function on or off.
        # ACQuisition:HOFF:TIME Sets or returns the holfoff time value.

        # read back
        if all(param is None for param in [aperture, hold_off]):
            return_value = {}
            return_value.update(aperture=self.query("ACQ:APER", float))
            on_or_off = self.on_off.to_api(self.query("ACQ:HOFF"))
            if on_or_off == "OFF":  # return 'off' or the hold off time.
                return_value.update(hold_off=on_or_off)
            else:
                return_value.update(hold_off=self.query("ACQ:HOFF:TIME"))
            self.log_inst_errors()
            return return_value

        # check parameters
        check_range('aperture', aperture, self.acq_aperture)
        if aperture is not None and not (self.acq_aperture_btb.min <= aperture <= self.acq_aperture_btb.max):
            self.log.warning(f"Aperture {aperture} is outside of bounds for back to back measurements. "
                             f"If configuring a BTB measurement use aperture between {self.acq_aperture_btb.min} and"
                             f"{self.acq_aperture_btb.max} {self.acq_aperture_btb.units}")

        error_msg = f"Bad hold_off {hold_off}. Should be 'OFF' or a value between {self.hoff_range.min}" \
                    f" and {self.hoff_range.max} {self.hoff_range.units}"

        # if none of the acceptable types throw an error
        if hold_off is not None:
            if not isinstance(hold_off, (int, float, str)):
                raise ValueError(error_msg)
            if isinstance(hold_off, str) and hold_off != 'OFF':
                raise ValueError(error_msg)
            elif isinstance(hold_off, (int, float)):
                check_range('hold_off', hold_off, self.hoff_range)

        if aperture is not None:
            self.write("ACQ:APER", aperture)
        if hold_off is not None:
            # if the user specified an non off value, turn it system on and assign the time.
            if hold_off == "OFF":
                self.write("ACQ:HOFF", self.on_off.to_inst(hold_off))
            else:
                self.write("ACQ:HOFF", self.on_off.to_inst("ON"))
                self.write("ACQ:HOFF:TIME", hold_off)

        self.log_inst_errors()

    def frequency_burst(self, aperture=None, prescaler=None, start_delay=None, sync_period=None):
        """
        Configure and query frequency burst settings from the instrument.

        :param aperture: Sets the time length within a burst during which the burst frequency is measured. 20ns to 2s.
        :type aperture: int | float
        :param prescaler: on_off value ('ON'/'OFF' preferred) that determines extends the burst frequency limit.
            The limit is 300 MHz if the prescaler is ON and 160 MHz if it is OFF.
        :type prescaler: str | int | bool
        :param start_delay: Sets the burst start delay (the time length between the burst start and the actual start of
            the burst measuring time). This parameter controls the point of time when a measurement sample is taken.

            * 'OFF' -  No start delay is incorporated.
            * float -  a value from 20ns to 2s
        :type start_delay: int | float | str
        :param sync_period: Sets the synchronization delay time used in burst measurements. A correct value should be
         longer than the burst time and shorter than 1/PRF (the inverse of the pulse repetition frequency). 1 s to 2s.
        :type sync_period: int | float
        :return: if called empty, returns a dictionary of the current parameters.
        :rtype: None | dict
        """
        # FREQuency:BURSt:APERture Sets the time length within a burst during which the burst frequency is measured.
        # FREQuency:BURSt:PREScaler[:STATe] Switches the frequency burst prescaler on and off.
        # FREQuency:BURSt:STARt:DELay Sets or returns the time length between the burst start
        #   and the actual start of the burst measuring time.
        # FREQuency:BURSt:SYNC:PERiod Sets the synchronization delay time used in burst measurements.

        # read back
        if all(param is None for param in [aperture, prescaler, start_delay, sync_period]):
            return_value = {}
            return_value.update(aperture=self.query("FREQ:BURST:APER", float))
            return_value.update(prescaler=self.on_off.to_api(self.query("FREQ:BURST:PRES")))
            delay = self.query("FREQ:BURST:STAR:DEL", float)
            start_delay = self.on_off.to_api(delay) if delay == 0 else delay
            return_value.update(start_delay=start_delay)
            return_value.update(sync_period=self.query("FREQ:BURST:SYNC:PER", float))
            self.log_inst_errors()
            return return_value

        # check parameters
        check_range('aperture', aperture, self.delay_range)
        check_range('sync_period', sync_period, self.sync_per_range)
        self.on_off.to_inst(prescaler)

        error_msg = f"Bad start_delay {start_delay}. Should be 'OFF' or a value between {self.delay_range.min}" \
                    f" and {self.delay_range.max} {self.delay_range.units}"

        # if none of the acceptable types throw an error
        if not isinstance(start_delay, (int, float, str)):
            raise ValueError(error_msg)
        if isinstance(start_delay, str) and start_delay != 'OFF':
            raise ValueError(error_msg)
        elif isinstance(start_delay, (int, float)):
            check_range('start_delay', start_delay, self.delay_range)

        # write to the machine
        if aperture is not None:
            self.write("FREQ:BURST:APER", aperture)
        if prescaler is not None:
            self.write("FREQ:BURST:PRES", self.on_off.to_inst(prescaler))
        if start_delay is not None:
            if start_delay == 'OFF':
                self.write("FREQ:BURST:STAR:DEL", 0)
            else:
                self.write("FREQ:BURST:STAR:DEL", start_delay)
        if sync_period is not None:
            self.write("FREQ:BURST:SYNC:PER", sync_period)

        self.log_inst_errors()


# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
