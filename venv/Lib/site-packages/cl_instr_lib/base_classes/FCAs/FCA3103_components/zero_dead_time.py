# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import *
from cl_instr_lib.helpers.user_delay import seconds_to_hms, wait_visualizer
import cl_instr_lib.helpers.file_io as file_io
# Include python libraries
from threading import Thread, Event
import time
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class ZeroDeadTimeTest:

    def __init__(self, fca):
        self.fca = fca
        self.trigger = fca.trigger
        self.system = fca.system
        self.measure = fca.measure
        self.config = fca.config
        self.byte_decode = fca.byte_decode
        self.enum_channel_AB = fca.enum_channel_AB
        self.decode_ieee_header = fca.decode_ieee_header
        self.write = fca.write
        self.query = fca.query
        self.read_raw = fca.read_raw
        self.log = fca.log
        self.log_inst_errors = fca.log_inst_errors

    _user_interrupt = Event()  # threading event for continuous test
    _continuous_thread = None
    _run_time_s = None
    _input_str = None
    _zdt_file = None
    _zdt_buffer_file = None

    acq_aperture_zdt_test = min_max_units(170e-6, 500, 'seconds')

    def start(self, pc_dir, file_name, sample_rate, channel, run_time_s, create_dir=False):
        """
        Performs a continuous reading test with zero dead time.

        Data from channel A or B is sampled at a rate defined by sample_rate. Binary measurement and timestamp data
        is saved to a text file in the pc_dir in (file_name).txt and read buffer data is saved to
        (file_name)_read_buffer.txt. The test will run for a specified amount of seconds run_time_s or can be
        interrupted gracefully using the keyboard press CTRL+C while the test is running.

        **Note:** The instrument seems to have an internal overflow issue after 10 million samples have been taken.
        This causes the timestamps to have a small but noticeable jump at the overflow. If timestamp data is important
        for the test application, this error can be avoided by careful structuring of the parameters run_time_s and
        meas_gate_time. Adjust the amount of samples the instrument is taking to under 10 million samples.
        i.e. 1ms gate for 2 hours of runtime  = 720,000 samples.

        :param pc_dir: Directory being accessed or created for the storage of the continuous data.
        :type pc_dir: str
        :param file_name: File name for the command. Exclude file extension. 'sample.txt' should be 'sample'.
        :type file_name: str
        :param sample_rate: Period of readings being taken from the machine. Ranging from 170us to 500s.
            Samples below 200us are non verifiable as this exceeds the instrument's sample rate for continuous readings.
            Sets the config.acquisition(aperture)
        :type sample_rate: float | int
        :param channel: The channel being used for this measurement. Either A or B.
        :type channel: str
        :param run_time_s: The total runtime of the test in seconds.
        :type run_time_s: int | float
        :param create_dir: Have the pc_dir be created if it does not already exist.
        :type create_dir: bool
        :return: returns the data of the read buffer volume.
        :rtype: list
        """
        # check input parameters
        file_io.check_filepath(pc_dir, create_dir)
        file_io.check_filename(file_name)
        check_range('sample_rate', sample_rate, self.acq_aperture_zdt_test)
        check_range('run_time_s', run_time_s, min_max_units(0, 345600, "Seconds"))
        channel_obj = check_enum_str('Channel', channel, self.enum_channel_AB)

        # read meaningful time values out to the user
        if sample_rate < 2e-4:
            self.log.warning("The Instrument samples at 10K/s, The smallest verifiable measurement time is 200us.")

        hours, minutes, seconds = seconds_to_hms(run_time_s)
        hms = f"{hours}h:{minutes}m:{seconds}s"
        print(f"Test Runtime will be: {hms}. Use [fca_obj].zdt_test.stop() to end test at any time.")
        wait_visualizer(5)  # allow time for reading the above print statement

        self.system.recall_preset()  # recall system presets before initialization of test parameters
        # machine initialization
        # self.write(f"CONF:FREQ:BTB {channel_obj.value}")  # setup frequency readings back to back
        self.config.freq_btb(channel=channel_obj.name)

        # self.write(f"ACQ:APER {meas_gate_time}")  # set interval of measurements
        self.config.acquisition(aperture=sample_rate, hold_off='OFF')

        # Turn off display
        self.system.display('OFF')

        # FORMat:PACKED : sends bytes instead of strings
        # FORMat:TINFormation 1: adds time info to the data
        self.config.format(text_format='PACKED', time_info='ON')

        self.trigger.initiate_continuous("ON")  # enable continuous acquisition mode
        self.trigger.arming(count='INF')  # The instrument loops the trigger sub-system infinitely
        self.log_inst_errors()

        # Multithreading for the continuous polling
        # ------------------------------------------------------

        self._user_interrupt.clear()
        self._run_time_s = run_time_s

        self._continuous_thread = Thread(name='continuous_thread',
                                         target=self._continuous_thread_loop,
                                         args=(self._user_interrupt,
                                               pc_dir,
                                               file_name,
                                               run_time_s))

        # have the read_write_loop continue until the user ends it or time runs out.
        self._continuous_thread.start()

    def stop(self):
        """Stop the threaded zero dead time test process immediately."""
        self._user_interrupt.set()
        if self._continuous_thread is not None:
            self._continuous_thread.join()

    def wait_until_done(self):
        """Wait statement that will allow the zero dead time test to conclude. Not interruptable once this is called."""
        if self._continuous_thread is not None:
            self._continuous_thread.join()

    def _continuous_thread_loop(self, user_interrupt, pc_dir, file_name, run_time):
        """Multithreading loop of querying the raw data from the instrument and saving it to a file."""
        time_start = time.time()
        read_buffer_size = []
        hms = None
        append_flag = False  # write on first iteration
        while not user_interrupt.is_set():
            t1_start = time.perf_counter()
            # read the raw binary data, parse data from ieee length header
            raw_data = self._raw_binary_read()
            data_length, data = self.decode_ieee_header(raw_data)

            # write/append binary data to file
            if data_length > 0:
                # save header into a list of the sizes of data coming from read buffer
                read_buffer_size.append(data_length)

                if append_flag is False:
                    file_io.write(pc_dir, file_name, 'txt', data, binary_data=True)
                    append_flag = True
                else:
                    file_io.fast_append(pc_dir, file_name, 'txt', data, binary_data=True)

            # take measurement of time passes in query/write and since start
            t1_stop = time.perf_counter()
            current_time = time.time() - time_start

            if current_time >= run_time:  # break loop if current time surpasses declared run_time
                user_interrupt.set()

            # read meaningful time values out to the user
            hours, minutes, seconds = seconds_to_hms(current_time)
            hms = f"{hours}h:{minutes}m:{seconds}s"
            print(f"Test Runtime: {hms}. Speed of last Query/Write: {(t1_stop - t1_start):.3f}s."
                  f" Use [fca_obj].zdt_test.stop() to end.")

        # print the final runtime out to the user
        print("--------------")
        print("Exiting....\n")
        print(f"Final Runtime: {hms} \n")
        print("--------------")

        # Send abort command after test has completed
        self.trigger.abort()
        self.config.format(text_format='ASCII', time_info='OFF')
        self.system.display('ON')
        self.system.recall_preset()
        self.log_inst_errors()

        # write the buffer to a txt file
        file_io.write(pc_dir, file_name + "_read_buffer", 'txt', read_buffer_size)

        # confirm the process has stopped to the user
        print("Continuous read process stopped. \n")

    def _raw_binary_read(self):
        """Reads all the raw data from the buffer."""
        self.write("FETC:ARR? MAX")
        raw_data = self.read_raw()
        return raw_data[:len(raw_data) - 1]  # remove newline for concurrent reads 160008

    def recall_data(self, pc_dir, file_name):
        """
        Method intended to read in data from the continuous test with zero dead time. Returns data structures
        of readings, timestamps, time deltas, and read buffer.

        The user should specify a existing directory and file name of the binary data from the test.
        If the binary data is in a file named 'continuity_test.txt' file name should be 'continuity_test' and
        this method will read 'continuity_test.txt' and 'continuity_test_read_buffer.txt'.

        **Note:** Will not work over pyro server because of numpy. Import an empty reference to the Driver to use this
        method

        :param pc_dir: Directory being accessed for the read command.
        :type pc_dir: str
        :param file_name: File name for the read command. Exclude file extension. 'sample.txt' should be 'sample'.
            **Note** This method will automatically find the read buffer file as well, so only specify the root file.
        :type file_name: str
        :return: Returns measurements, timestamps, time deltas, and the read buffer data.
        :rtype: np.array & np.array & np.array & list
        """

        dataset = file_io.read(pc_dir, file_name, 'txt', 'bytes')
        buffer = file_io.read(pc_dir, file_name + "_read_buffer", 'txt', 'list_int')
        readings, timestamps, deltas = self.byte_decode(dataset)
        return readings, timestamps, deltas, buffer

# -----------------------------------------------------------
#                        END OF FILE
# -----------------------------------------------------------
