import inspect
import os
import time
import visa
import re
import cl_instr_lib
import logging
from cl_instr_lib.helpers.instr_logging import InstrLoggingAdapter, add_file_handler, add_stream_handler
from cl_instr_lib.helpers.on_off import OnOff, on_off_vals
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.base_classes.instrument import Instrument
from enum import Enum


class InstrumentVisa(Instrument):

    """A mixin class used to provide facilities common to all the drivers:

         - initialization of PyVisa resource handle;
         - ability to simulate an instrument;
         - logging of SCPI commands sent to and data received from the instrument (or simulation buffer);
         - debug function for reading and logging instrument error buffer;
         - object providing single sourced translation of ON / OFF values between API and instruments.
    """

    # Translator to/from various API representations and instrument representation.
    on_off = OnOff(off_vals=on_off_vals(('OFF', False, 0, '0'), '0', ('OFF', '0', 0), 'OFF'),
                   on_vals=on_off_vals(('ON', True, 1, '1'), '1', ('ON', '1', 1), 'ON'))

    # enum for inst_error_handling values
    enum_inst_error_handling = Enum('enum_inst_error_handling', 'RAISE LOG_ERRORS LOG_ALWAYS NO_CHECK')
    enum_unused_args_handling = Enum('enum_unused_args_handling', 'LOG_UNUSED RAISE LOG_ALWAYS')

    def __init__(self, resource_name=None, logger=None, rm_handle=None,
                 model_re=None, options_re=None, sim_idn=None, sim_opt=None,
                 reset_values=None, additional_rtn_types=None, channel_specific_cmds=None, channel_sel_default=None,
                 channel_sel_cmd=None, **kwargs):
        """
        Initializes code common to all drivers: PyVisa connection, simulation buffer, logging etc. Params beyond logger
            have to do with handling the quirks of some instruments in hardware simulation.

        :param resource_name: <Bus>::<Address>. Suffix '::INSTR' may be omitted. Examples: 'GPIB0::6',
            'USB0::0x0699::0x0345::C010767', 'COM5'.
        :type resource_name: str
        :param logger: Used to display SCPI commands/data if DEBUG level is enabled.
        :type logger: None or reference to UM Framework logger or other logger derived from Python logger.

        :param sim_idn: Used to simulate instrument's response to an '*IDN?' query. None if *IDN is not
            supported.
        :type sim_idn: None or str
        :param sim_opt: Used to simulate instrument's response to an '*OPT?' query. None if *OPT is not
            supported.
        :type sim_opt: None or str
        :param reset_values: Simbuffer gets initialized at reset with these values if supplied. This supports simulated
            queries of read only instrument registers. Example: Tek 4000 CONFIG queries.
        :type reset_values: None or dict of SCPI command value pairs.
        :param additional_rtn_types: Modify or extend the built-in values used in simulated queries when a value does
            not already exist in the simbuffer from reset_values or a prior write. Built in values are: {int: 0,
            float: 0.0,  str: '',  bool: False}.
        :param channel_specific_cmds: Writing or querying the one of these commands in simulation consults the simbuffer
            or channel_sel_default to obtain to determine the target channel. Example instrument: E3631A.
        :type channel_specific_cmds: [str] which are SCPI command strings.
        :param channel_sel_default: Any channel specific command will use this value to distinguish the target if a
            channel select value doesn't already exist in the simbuffer from reset_values or a prior simulated write.
        :type channel_sel_default: int or str as used by the instrument to distinguish the target channel.
        :param channel_sel_cmd: The simulation looks in the simbuffer for a prior write to this command to obtain
            value that identifies the presently selected channel.
        :type channel_sel_cmd: str
        """
        super().__init__(resource_name)

        self.simbuffer = {}

        self._sim_idn = sim_idn
        self._sim_opt = sim_opt
        self.reset_values = reset_values

        self.channel_specific_cmds = channel_specific_cmds
        self.channel_sel_default = channel_sel_default
        self.channel_sel_cmd = channel_sel_cmd

        self.module = self.__module__

        # These are used for simulated queries when there is no existing entry in the simbuffer for the SCPI cmd.
        self.lookup_rtn_default = {int: 0, float: 0.0, str: '', bool: False}
        if additional_rtn_types is not None:
            self.lookup_rtn_default.update(additional_rtn_types)

        # Establish defaults
        self.log_scpi = False
        self.unused_args_handling = self.enum_unused_args_handling.LOG_UNUSED
        self.inst_error_handling = self.enum_inst_error_handling.RAISE

        if resource_name is None and rm_handle is None:
            # User wants to simulate the instrument for development purposes, etc.
            self.log = self.get_logger_adapter(logger)
            self.log.setLevel('INFO')
            self.rm_handle = None
            self.simulated_inst = True
            self.inst_error_handling = self.enum_inst_error_handling.NO_CHECK  # No error queue on simulated instrument!
            self._reset_simbuf()  # Initializes the sim buffer
            self._rm_handle_is_external = False
        else:
            # User wants to use a real hardware instrument.
            if rm_handle is not None:
                self.rm_handle = rm_handle   # We were passed an existing handle, use it!
                self._rm_handle_is_external = True
            else:
                # try to open the resource handle.
                rm = visa.ResourceManager()
                self.rm_handle = rm.open_resource(resource_name)
                self._rm_handle_is_external = False

            self.simulated_inst = False

            tmp = self.rm_handle.resource_info[0][3].split('::')
            m = re.match('ASRL(\d+)', tmp[0])
            if m is not None:
                # We have a COM connected instrument.
                self.resource_name = f"COM{m[1]}"
            else:
                self.resource_name = '::'.join(tmp[0:-1])

            self.log = self.get_logger_adapter(logger)
            self.log.setLevel('INFO')

            # Check that hardware model and options match what the driver requires.
            if model_re is not None:
                actual_model = self.get_model()  # See default implementation below.
                if re.search(model_re, actual_model) is None:
                    raise ValueError(f"Instrument at '{self.resource_name}' does not match model_re '{model_re}', "
                                     f"actual model '{actual_model}'.")
                self.log.info(f"Instrument is model '{actual_model}'.")
                if options_re is not None:
                    actual_options = self.get_options()  # See default implementation below.
                    if re.search(options_re, actual_options) is None:
                        raise ValueError(f"Instrument at '{self.resource_name}' does not match options_re "
                                         f"'{options_re}', actual options '{actual_options}'.")
                    self.log.info(f"Instrument has options '{actual_options}'.")

    def __del__(self):
        # Does nothing if simulated or already closed.
        if hasattr(self, 'rm_handle') and self.rm_handle is not None and not self._rm_handle_is_external:
            # Logging a message here fails if logger is instantiated by the driver rather than passed in,
            # probably because logger or something it depends on is already destroyed prior to getting here.
            # This shows up when running standalone as a script (not in PyCharm console).

            # msg = f"Deleting driver object, closing pyvisa session {self.rm_handle.session}"
            # if hasattr(self, 'log') and isinstance(self.log, InstrLoggingAdapter):  # Doesn't seem to be sufficient.
            #     self.log.info(msg)
            # else:
            # print(msg)
            self.rm_handle.close()

    def close_resource(self):
        """
        Closes the pyvisa resource handle (rm_handle) if one exists.

        **NOTE:** This invalidates the pyvisa handle inside this driver instance which will cause a subsequent
        attempt to  use the driver to read/write to the instrument to fail. Use reopen_resource to re-establish the
        handle inside the driver instance.
        """
        # Do nothing if simulated or already closed or if externally supplied (in Framework).
        if self.rm_handle is not None and not self._rm_handle_is_external:
            self.rm_handle.close()

    def reopen_resource(self):
        """
        Re-establishes the pyvisa handle inside this driver instance using the stored resource name (aka address).
        """

        if self.resource_name is not None and not self._rm_handle_is_external:  # Does nothing if simulated.
            rm = visa.ResourceManager()
            self.rm_handle = rm.open_resource(self.resource_name)

    def debug_options(self, log_scpi=None, unused_args_handling=None, inst_error_handling=None):
        """
        Query or set driver debug options.

        :param log_scpi: True causes every SCPI command and response to be logged at the logger INFO level. False
            disables logging of the SCPI commands.
        :type log_scpi: None|bool
        :param unused_args_handling: Driver methods designed to accommodate instrument substitution use args and kwargs
            to absorb and ignore any extra arguments passed from calling code that was written for another instrument.
            Such methods begin with a call to log_unused_args. This parameter controls what log_unused_args does.

            * 'LOG_UNUSED' - Just log the unused parameters that were passed in using the INFO logging level. This is \
                the default mode, allowing instrument substitution to function. The message contains the location \
                within the driver where log_unused_args was called.
            * 'RAISE' - Does what LOG_UNUSED does, but the ERROR logging level is used and a RuntimeError exception \
                is raised. Instrument substitution will fail if parameters are passed in that are not used by the \
                present instrument driver. In interactive use, 'RAISE' can be useful to make it obvious when you \
                misspell a keyword argument name.
            * 'LOG_ALWAYS' - Always generates logging output showing the location where log_unused_args was called.

        :type unused_args_handling: None|enum_unused_args_handling|str
        :param inst_error_handling: Any driver method that writes data to the instrument ends with a call to the method
            log_instr_errors. This parameter controls what that call does:

            * 'LOG_ERRORS' - Only generates logging output if the instrument error buffer is non-empty. The ERROR \
                logging level is used. The message contains the call location and the instrument error buffer contents.
            * 'RAISE' - Does what LOG_ERRORS does, but in addition raises a RuntimeError exception containing the \
                same message text. This is the default and is the preferred setting for general use in the Framework.
            * 'NO_CHECK' - The log_instr_errors method returns immediately, doing nothing. No clutter in the log, no \
                additional bus transactions, no safety net (user beware).
            * 'LOG_ALWAYS' - Always generates logging output showing the location from where log_inst_errors was \
                called as well as the contents of the instrument error buffer, if any. This is especially useful in \
                developing the driver parameter checking logic, it makes visible any instrument errors resulting from \
                escapes from the logic.

        :type inst_error_handling: None|enum_inst_error_handling|str
        :return: dict|None
        """

        if all([v is None for v in (log_scpi, inst_error_handling, unused_args_handling)]):
            return_values = {}
            return_values.update(log_scpi=self.log_scpi)
            return_values.update(unused_args_handling=self.unused_args_handling.name)
            return_values.update(inst_error_handling=self.inst_error_handling.name)
            return return_values

        # Check all inputs

        if log_scpi is not None:
            if not isinstance(log_scpi, bool):
                raise ValueError(f"Bad log_scpi {log_scpi}, should be bool (True or False).")

        unused_args_handling = check_enum_str('unused_args_handling', unused_args_handling,
                                              self.enum_unused_args_handling)

        inst_error_handling = check_enum_str('inst_error_handling', inst_error_handling, self.enum_inst_error_handling)

        # All checks pass, commit the new values.
        if log_scpi is not None:
            self.log_scpi = log_scpi

        if unused_args_handling is not None:
            self.unused_args_handling = unused_args_handling

        if inst_error_handling is not None:
            self.inst_error_handling = inst_error_handling

    def query(self, scpi_cmd, rtn_type=None, pre_target_params=None, target=None, post_target_params=None,
              *args, **kwargs):
        """Wrapper around pyvisa query to support return type conversion, logging, and instrument simulation.

        example structure = "scpi_cmd? pre_target_params, target, post_target_params"

        :param scpi_cmd: Command string, you may omit the '?' character on the end.
        :type scpi_cmd: str
        :param pre_target_params: Additional parameters added to the query statement after the '?' at the end of a scpi
            command. pre_target_params comes before the simulation key argument 'target'.
        :type pre_target_params: str
        :param target: Additional parameter added after the '?' and pre_target_params. target is logged as a key in the
            simulation dictionary.
        :type target: str
        :param post_target_params: Additional parameters added to the query statement after the target parameter.
        :type post_target_params: str
        :param rtn_type: a Python type to cast the return value, e.g. str, int, float, bool, an enum. If not specified,
            defaults to str. **Note:** When using the Framework, do not specify the type as it cannot be serialized
            and transported through the Pyro server.
        :type rtn_type: a Python type object
        :return: the value returned from the instrument converted (cast) to the specified type.
        """

        # Needed to do this because types are not serializable through Pyro server.
        # TODO: Solution for passing type from client. VALTECH-493.
        if rtn_type is None:
            rtn_type = str

        # Create key used for simulation dict. This handles:
        # Normal syntax which is just a command header, for example: 'TRAC:FILL:MODE?', with or without the '?'.
        # As well as query with a selection argument following the ?: 'TRAC:FILL:MODE? "buffername"'
        header = scpi_cmd.strip().rstrip('?')
        key = header
        cmd = header + '?'
        if pre_target_params is not None:
            cmd += ' ' + pre_target_params
        if target is not None:
            key += ' ' + target
            if cmd[-1] != '?':
                cmd += ','
            cmd += ' ' + target
        if post_target_params is not None:
            if cmd[-1] != '?':
                cmd += ','
            cmd += ' ' + post_target_params

        prior_write = False
        if self.simulated_inst:
            if self.channel_specific_cmds is not None and scpi_cmd.startswith(self.channel_specific_cmds):
                key_prefix = self.simbuffer.get(self.channel_sel_cmd, str(self.channel_sel_default)) + ';'
                key = key_prefix + key
            default_rtn_val = self.lookup_rtn_default.get(rtn_type, self.lookup_rtn_default[str])
            value_str = self.simbuffer.get(key, default_rtn_val)
            if key in self.simbuffer:
                prior_write = True
        else:
            # noinspection PyUnresolvedReferences
            value_str = self.rm_handle.query(cmd).strip()  # Remove newline in response.

        if rtn_type is bool:
            value = rtn_type(int(value_str))
        else:
            value = rtn_type(value_str)

        if self.log_scpi:
            log_string = f"'{cmd}' -> '{value_str}'"
            if self.simulated_inst:
                log_string = 'simulated_inst: ' + log_string
                if prior_write:
                    log_string += ' (from prior write)'
                else:
                    log_string += ' (no prior write)'
            self.log.info(log_string)

        return value

    def write(self, scpi_cmd, value=None, target=None):
        """
        Wrapper around pyvisa write to support logging, and instrument simulation.

        :param scpi_cmd: Command string, you may omit the '?' character on the end
        :type scpi_cmd: str
        :param value: a single value to be written by the command to the instrument.
        :type value: str, int, float
        :param target: Used when the syntax of the SCPI command requires an additional parameter be sent
            specifying the target of the operation within the instrument. For example the syntax
            :TRACe:FILL:MODE <fillType>, "<bufferName>" can be achieved by the call
            write(':TRACe:FILL:MODE', 'ONCE', target='"defbuffer1"').
        :return: None
        """

        if value is None:
            cmd_str = scpi_cmd
        else:
            cmd_str = f"{scpi_cmd} {value}".rstrip()  # strip here ensures that if value=='', no extra space is sent.
            if value == '':                           # legacy code may depend on old value default which was ''.
                value = None

        if target:
            if value is not None:
                cmd_str += ', ' + target   # Need comma after a value
            else:
                cmd_str += ' ' + target    # There was no value.

        if self.simulated_inst:
            key = scpi_cmd
            if self.channel_specific_cmds is not None and scpi_cmd.startswith(self.channel_specific_cmds):
                key_prefix = self.simbuffer.get(self.channel_sel_cmd, self.channel_sel_default).strip() + ';'
                key = key_prefix + scpi_cmd
            if target:
                key += ' ' + target   # Construct key that is target specific.
            self.simbuffer[key] = f"{value}"  # String as used in SCPI, also can be converted to desired rtn type.
        else:
            # noinspection PyUnresolvedReferences
            self.rm_handle.write(cmd_str)

        if self.log_scpi:
            log_string = f"'{cmd_str}'"
            if self.simulated_inst:
                log_string = 'simulated_inst: ' + log_string
            self.log.info(log_string)

    def read_raw(self, size=None):
        """
        A wrpper around PyVISA's read_raw method - provides location for any encoding steps needed for use with
        Pyro server

        :param size: Chunk size to use when reading data.
        :type size: int
        :return: Data read from the instrument.
        :rtype: bytes
        """

        return self.rm_handle.read_raw(size)

    def write_raw(self, message):
        """
        A wrpper around PyVISA's write_raw method - provides location for any encoding steps needed for use with
        Pyro server

        :param message: The message to be sent.
        :type message: bytes
        :return: The number of bytes written.
        :rtype:  int
        """

        return self.rm_handle.write_raw(message)

    def read_bytes(self, count, chunk_size=None, break_on_termchar=False):
        """
        A wrpper around PyVISA's read_bytes method - provides location for any encoding steps needed for use with
        Pyro server
        
        :param count: The number of bytes to read from the instrument.
        :type count: int
        :param chunk_size: The chunk size to use to perform the reading.
        :type chunk_size: int
        :param break_on_termchar:  Should the reading stop when a termination character is encountered.
        :type break_on_termchar: bool
        :rtype: bytes
        """

        return self.rm_handle.read_bytes(count, chunk_size, break_on_termchar)

    def write_binary_values(self, message, values, datatype='f', is_big_endian=False, termination=None, encoding=None,
                            header_fmt='ieee'):
        """Write a string message to the device followed by values in binary
        format. A wrapper around the PyVISA method to allow operation through the Pyro server.

        The write_termination is always appended to it.

        :param message: the message to be sent.
        :type message: unicode (Py2) or str (Py3)
        :param values: data to be writen to the device.
        :param datatype: the format string for a single element. See struct
                         module.
        :param is_big_endian: boolean indicating endianess.
        :param header_fmt: format of the header prefixing the data. Possible
                           values are: 'ieee', 'hp', 'empty'
        :return: number of bytes written.
        :rtype: int
        """

        return self.rm_handle.write_binary_values(message, values, datatype, is_big_endian, termination,
                            encoding, header_fmt)

    # TODO: Making query_binary_values will require PyroReceiver changes because of container=list.
    # For alternative method see AfgArbWfm.editmem_data_read
    #
    # def query_binary_values(self, message, datatype='f', is_big_endian=False,
    #                         container=list, delay=None, header_fmt='ieee',
    #                         expect_termination=True, data_points=0,
    #                         chunk_size=None):
    #     """Query the device for values in binary format returning an iterable
    #     of values. A wrapper around the PyVISA method to allow operation through the Pyro server.
    #
    #     :param message: the message to send to the instrument.
    #     :param datatype: the format string for a single element. See struct
    #                      module.
    #     :param is_big_endian: boolean indicating endianess.
    #                           Defaults to False.
    #     :param container: container type to use for the output data.
    #     :param delay: delay in seconds between write and read operations.
    #                   if None, defaults to self.query_delay
    #     :param expect_termination: when set to False, the expected length of
    #                                the binary values block does not account
    #                                for the final termination character (the
    #                                read termination)
    #     :param data_points: Number of points expected in the block. This is
    #                         used only if the instrument does not report it
    #                         itself. This will be converted in a number of bytes
    #                         based on the datatype.
    #     :param chunk_size: Size of the chunks to read from the device. Using
    #                        larger chunks may be faster for large amount of
    #                        data.
    #     :returns: the answer from the device.
    #     :rtype: list
    #     """
    #
    #     return self.rm_handle.query_binary_values(message, datatype, is_big_endian,
    #                     container, delay, header_fmt,
    #                     expect_termination, data_points,
    #                     chunk_size)

    def get_inst_errors(self, time_max_sec=2):
        """Reads the instrument SYST:ERR buffer to obtain all errors (until "No error.." is returned). Loop has 2sec
        time limit to prevent getting stuck in this loop,
        """

        err_list = []

        if self.simulated_inst:
            return err_list

        time_start = time.monotonic()
        time_max = 2  # sec
        while (time.monotonic() - time_start) < time_max:
            err_msg = self.query('SYST:ERR', str)
            if 'No error' in err_msg:
                break
            else:
                err_list.append(err_msg)
        else:
            raise RuntimeError(f"Error queue not emptied after {time_max} seconds.")
        return err_list

    def log_inst_errors(self):
        """
        Checks instrument error queue and reports errors through the logging system and possibly by
        raising an exception.

        **NOTE:** The behavior of log_inst_errors is defined by the inst_error_handling parameter of debug_options().

        Drivers contain calls to this method at strategic points, typically at the end of methods that write new data to
        the instrument using SCPI commands. Although driver methods are designed to prevent errors caused by bad input
        data by raising ValueError exceptions, log_inst_errors provides for detection of escapes from this logic.
        The messages produced by log_inst_errors include the filename, method and line number of the log_inst_errors
        call.
        """

        if self.inst_error_handling == self.enum_inst_error_handling.NO_CHECK:
            return

        err_list = self.get_inst_errors()
        if err_list or self.inst_error_handling == self.enum_inst_error_handling.LOG_ALWAYS:
            # User wants a log message in all cases, even when there is no error.
            frame_record = inspect.stack()[1]
            filename = frame_record[1].split('\\')[-1]
            filename = os.path.basename(filename)
            caller = frame_record[3]
            lineno = frame_record[2]
            msg = f"log_inst_errors : {filename}: line {lineno} : {caller} : "
            if err_list:
                for err_line in err_list:
                    msg += f"\n    {err_line}"
            else:
                msg += "No errors."
            if self.inst_error_handling == self.enum_inst_error_handling.LOG_ALWAYS:
                # Just log, regardless of existence of errors. Driver development use case.
                if err_list:
                    self.log.error(msg)  # log as an actual error - red text
                else:
                    self.log.info(msg)  # log as an actual error
                return

            # Only LOG_ERRORS or RAISE gets this far...
            self.log.error(msg)  # log as an actual error
            if self.inst_error_handling == self.enum_inst_error_handling.RAISE:
                raise RuntimeError(msg)

    def _parse_idn(self, idn):
        r"""Breaks '\*IDN' query response string into its component parts. Acts as a place to centralize handling of
        the weird cases of instruments that deviate from the standard of 4 comma separated fields."""

        # TODO: Return _parse_idn result as a dict

        mfg, model, serial, ver = None, None, None, None
        if idn is None:
            return [mfg, model, serial, ver]

        pattern = r"^(FTS Systems, Inc.),\s*([^,]+),\s*([^,]+)"
        m = re.search(pattern, idn)
        if m is not None:
            mfg = m.group(1).replace(',', '')
            model = m.group(2)
            serial = None
            ver = m.group(3)
        else:
            # PSI9040T IDN has comma on right end. Strip this off so it does not look like 5 fields.
            fields = [x.strip() for x in idn.rstrip(', ').split(',')]
            num_fields = len(fields)
            if num_fields == 2:
                mfg, model = fields
            elif num_fields == 4:
                mfg, model, serial, ver = fields
            elif num_fields == 5:
                self.log.warning(f"{idn} has 5 fields, which is unusual. Assuming meaning of fields is: "
                                 f"mfg, model, skip, ver, serial. (like Temptronic ECO-710)")
                # self.log.info
                mfg, model = fields[:2]
                serial = fields[4]
                ver = fields[3]
            else:
                raise RuntimeError(f"{idn} IDN has {num_fields} fields, do not know how to handle, skipping this "
                                   f"instrument.")

        return [mfg, model, serial, ver]

    def get_idn(self):
        r"""Returns the result of the '\*IDN?' query if the instrument supports it, otherwise raises exception."""

        if self._sim_idn is None:
            raise RuntimeError(r"Instrument doesn't support '\*IDN?' query.")

        return self.query('*IDN?', str).strip()

    def get_model(self):
        r"""Returns the model field of the '\*IDN?' query response. For instruments that don't support'\*IDN?', override
        this method in the driver implementation to implement some other means of getting the model name.
        """

        _, model, _, _ = self._parse_idn(self.get_idn())
        return model

    def get_opt(self):
        r"""Returns the result of the '\*OPT?' query if the instrument supports it, otherwise raises exception."""

        if self._sim_opt is None:
            raise RuntimeError(r"Instrument doesn't support '\*OPT?' query.")

        return self.query('*OPT?', str).strip()

    def get_options(self):
        r"""Uses get_opt to obtain model information. For instruments that don't support '\*OPT?', override this
            method in the driver implementation to implement some other means of getting the info.
        """

        return self.get_opt()

    def reset(self):
        r"""Send '\*RST' to the instrument. If instrument is simulated, contents of simbuffer is cleared and
            re-initialized with the reset_values specified by the driver implementation."""

        self._reset_simbuf()
        self.write('*RST', '')  # So *RST shows up in simbuffer, but can't do this until simbuffer is setup!

    def _reset_simbuf(self):
        """If instrument is simulated, contents of simbuffer is cleared and
            re-initialized with the reset_values specified by the driver implementation."""

        if self.simulated_inst:
            # Setup dict that mimics instrument: key=SCPI cmd, value=data.
            self.simbuffer = {}
            if self._sim_idn is not None:
                self.simbuffer.update({'*IDN': self._sim_idn})
            if self._sim_opt is not None:
                self.simbuffer.update({'*OPT': self._sim_opt})
            if self.reset_values is not None:
                self.simbuffer.update(self.reset_values)

# -----------------------------------------------------------
#                        END OF FILE
# -----------------------------------------------------------
