from cl_instr_lib.base_classes.signal_generator import SignalGenerator
from cl_instr_lib.base_classes.sg_channel_ABC import SGChannel_ABC
from cl_instr_lib.base_classes.rs_smb.freq import Freq
from cl_instr_lib.base_classes.rs_smb.power import Power
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.helpers.check_enum_str import check_enum_str

from collections import namedtuple
from enum import Enum
from typing import Union

ProgrammingBounds = namedtuple('ProgrammingBounds', [])

class SmbBase(SignalGenerator):
    """Base class for Driver class R&S SMB family"""

    def __init__(self, visa_resource_name, chan_pgm_bounds, logger=None, **kwargs):

        # Setup the simulation code inherited from Instrument
        super().__init__(visa_resource_name, logger, **kwargs)

        enum_rf = Enum('enum_rf', {})
        enum_lf = Enum('enum_lf', {})

        #: Attribute containing object that controls **RF**. See `RFchannel class`_.
        self.RF = RfChannel(self, 'RF', chan_pgm_bounds, enum_rf)

        #: Attribute containing object that controls **LF**. See `LFchannel class`_.
        self.LF = LfChannel(self, 'LF', chan_pgm_bounds, enum_lf)

        self._channel_names = ['RF', 'LF']

class Channel(SGChannel_ABC):
    """Class for output channel abstraction of signal generators"""

    def __init__(self, signal_generator, channel_name, programming_bounds, enum_combine):
        super().__init__(signal_generator=signal_generator, channel_name=channel_name,
                         programming_bounds=programming_bounds)

        # Define references to objects in the container object
        self.log = signal_generator.log
        self.write = signal_generator.write
        self.query = signal_generator.query
        self.on_off = signal_generator.on_off
        self.log_inst_errors = signal_generator.log_inst_errors
        self.get_inst_errors = signal_generator.get_inst_errors

    def output_state(self, channel_scpi: str, on_off: Union[int, str, bool] = None, **kwargs) -> str:
        """
        Queries or sets the state (OFF or ON) of the AFG channel main output.

        :param channel_scpi: SCPI command related to exact channel.
        :type channel_scpi: str
        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type on_off: int|str|bool
        :return: Current output state.
        :rtype: str
        """

        # :OUTPut<hw>[:STATe] <State>
        # [:SOURce]:LFOutput[:STATe] <State>

        # Readback
        if on_off is None:
            return self.on_off.to_api(self.query(f'{channel_scpi}?'))

        # Parameter Checking and Writing to Instrument
        if on_off not in self.on_off.api_values():
            raise ValueError(f'Bad on_off value: {on_off}. Valid entries: {self.on_off.api_values}')
        self.on_off.to_inst(self.write(f'{channel_scpi}', on_off))

class RfChannel(Channel):
    """Class for RF channel abstraction."""

    def __init__(self, signal_generator, channel_name, programming_bounds, enum_combine):
        super().__init__(signal_generator, channel_name, programming_bounds, enum_combine)

        #: Attribute containing object that controls frequency of main (RF) output. See `Freq class`_.
        self.freq = Freq(self)

        #: Attribute containing object that controls power of main (RF) output. See `Power class`_.
        self.power = Power(self)

    def output_state(self, on_off: Union[int, str, bool] = None, **kwargs) -> str:
        """
        Class for RF output channel abstraction.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type on_off: int|str|bool
        :return: Current output state.
        :rtype: str
        """
        super().output_state('OUTP:STAT', on_off=on_off, **kwargs)

class LfChannel(Channel):
    """Class for LF channel abstraction."""

    def __init__(self, signal_generator, channel_name, programming_bounds, enum_combine):
        super().__init__(signal_generator, channel_name, programming_bounds, enum_combine)

        #: Attribute containing object that controls frequency of the LFO output. See `Freq class`_.
        self.freq = Freq(self)

        self.enum_shape = Enum('enum_shape', {
            'SINE': 'SINE',
            'SQUARE': 'SQU',
            'TRIANGLE': 'TRI',
            'SAWTOOTH': 'SAWT',
            'ISAWTOOTH': 'ISAW'
        })
        self.enum_impedance = Enum('enum_impedance', {
            '10': 'LOW',
            '600': 'G600'
        })

        self.output_amplitude_min_max = min_max_units(0, 3, 'volts')

    def output_state(self, on_off=None, **kwargs) -> str:
        """
        Class for LFO channel abstraction.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type on_off: int|str|bool
        :return: Current output state.
        :rtype: str
        """
        super().output_state('LFO:STAT', on_off=on_off, **kwargs)

    def function_level(self, amplitude: Union[int, float] = None) -> float:
        """
        Output level of generated waveform.

        The LFO amplitude is measured in peak-to-peak voltage with 50 ohm source impedance.

        :param amplitude: Set amplitude level.
        :type amplitude: int|float
        :return: Current output amplitude.
        :rtype: float
        """

        # [:SOURce]:LFOutput:VOLTage <Voltage>

        # Reaback
        if amplitude is None:
            return self.query('LFO:VOLT?', float)
        # Parameter Checking and Write to Instrument
        else:
            check_range('amplitude', amplitude, self.output_amplitude_min_max)
            self.write('LFO:VOLT', amplitude)

    def function_shape(self, shape: str = None) -> str:
        """
        Set the LFO waveform shape.

        :param shape: Set shape of waveform. Accepts 'SINE', 'SQUARE', 'TRIANGLE', 'SAWTOOTH', 'ISAWTOOTH'.
        :type shape: str
        :return: Current shape
        :rtype: str
        """

        # [: SOURce]:LFOutput: SHAPe < Shape >

        # Readback
        if shape is None:
            return self.query('LFO:SHAP?', self.enum_shape).name
        # Parameter Checking and Write to Instrument
        shape = check_enum_str('shape', shape, self.enum_shape)
        self.write('LFO:SHAP', shape.value)

    def impedance(self, impedance: int = None) -> str:
        """
        Set the LFO output impedance.

        The 10 ohm option is represented as 'LOW' in the instrument GUI and manual.

        :param impedance: Set impedance leve. Accepts 10 or 600 (ohms).
        :type impedance: int|enum_impedance
        :return: Current impedance (ohms).
        :rtype: int
        """

        # [:SOURce]:LFOutput:SIMPedance

        # Readback
        if impedance is None:
            return int(self.query('LFO:SIMP?', self.enum_impedance).name)
        # Parameter Checking and Write to Instrument
        else:
            impedance = check_enum_str('impedance', str(impedance), self.enum_impedance)
            self.write('LFO:SIMP', impedance.value)