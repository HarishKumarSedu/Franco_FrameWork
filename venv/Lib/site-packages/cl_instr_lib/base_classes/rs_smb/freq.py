from enum import Enum
from typing import Union
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.helpers.check_enum_str import check_enum_str

RF = ''
LF = 'LFO'

class Freq:
    """Class abstracting frequency functionality for SMB signal generators"""

    def __init__(self, channel):
        self.log = channel.log
        self.write = channel.write
        self.query = channel.query

        self.enum_mode = Enum('enum_mode', {'FIXED': 'CW', 'SWEEP': 'SWE'})
        if channel.channel_name == 'RF':
            self.source = ''
            self.freq_min_max = min_max_units(8e3, 6e9, 'Hz')
            self.step_min_max = min_max_units(1e-3, 5.99999e9, 'Hz')
            self.mult_min_max = min_max_units(1e-3, 1e5, '')
            self.offset_min_max= min_max_units(-6.7e10, 6.7e10, 'Hz')
        elif channel.channel_name == 'LF':
            self.source = 'LFO:'
            self.freq_min_max = min_max_units(1e-1, 1e6, 'Hz')
            self.step_min_max = min_max_units(1e-1, 1e6, 'Hz')
        else:
            raise ValueError(f'Bad channel: {channel.channel_name}.')
        self.dwell_time_min_max = min_max_units(5e-3, 100, 'seconds')

    def mode(self, mode: str = None):
        """
        Set the frequency mode for either the RF or LF to be in fixed (constant frequency) mode or sweep mode. To
        configure both of these modes, use the config() method within freq.py module. LIST mode is nor currently
        supported.

        :param mode: Set desired frequency mode. Accepts 'FIXED', 'SWEEP'
        :type mode: str|enum_mode
        :return: Current frequency mode.
        :rtype: str
        """

        # [:SOURce<hw>]:FREQuency:MODE <Mode>

        # Readback
        if mode is None:
            return self.query(f'{self.source}FREQ:MODE?', self.enum_mode).name
        else:
            mode = check_enum_str('mode', mode, self.enum_mode)
            self.write(f'{self.source}FREQ:MODE', mode.value)

    # TODO: Implement sweep modes (single, auto, etc) and also add logarithmic sweep
    def config(self, freq: Union[int, float] = None, start: Union[int, float] = None,
                     stop: Union[int, float] = None, step: Union[int, float] = None, mult: Union[int, float] = None,
                     offset: Union[int, float] = None, dwell_time: Union[int, float] = None):
        """
        Configure parameters for both fixed frequency and sweep mode.

        Fixed frequency uses freq parameter to set the constant frequency. mult and offset are used to adapt changes
        to the frequency and its limits for RF frequencies.

        Use start, stop, step, and dwell_time to configure a frequency sweep. Parameters mult and offset can also be
        used to support this mode.

        Setting the center frequency with a span to sweep is not currently supported.

        See mode() method in freq.py module.

        :param freq: Set frequency to a constant value.
        :type freq: int|float
        :param start: Set the frequency to begin the sweep at. Must be less than stop.
        :type start: int|float
        :param stop: Set the frequency to end the sweep at. Must be greater than start.
        :type stop: int|float
        :param step: Set how much the frequency is incremented by throughout the sweep.
        :type step: int|float
        :param mult: Set value of a multiplication factor of the frequency. Only available for RF. Available for both
            fixed and sweep mode.
        :type mult: int|float
        :param offset: Set value to offset frequency. Only available for RF. Available for both fixed and sweep mode.
        :type offset: int|float
        :param dwell_time: Time between frequency incrementations in sweep.
        :type dwell_time: int|float
        :return: Dictionary of currently set values.
        :rtype: dict
        """

        # [:SOURce<hw>]:FREQuency:STARt <Start>
        # [:SOURce<hw>]:FREQuency:STOP <Stop>
        # [:SOURce<hw>]:SWEep[:FREQuency]:STEP[:LINear] <Linear>
        # [:SOURce<hw>]:FREQuency:MULTiplier <Multiplier>
        # [:SOURce<hw>]:FREQuency:OFFSet <Offset>
        # [:SOURce<hw>]:SWEep[:FREQuency]:DWELl <Dwell>

        # Readback
        if all(v is None for v in {freq, start, stop, step, mult, offset, dwell_time}):
            return_val = {}
            return_val.update(freq=self.query(f'{self.source}FREQ?', float))
            return_val.update(start=self.query(f'{self.source}FREQ:STAR?', float))
            return_val.update(stop=self.query(f'{self.source}FREQ:STOP?', float))
            return_val.update(step=self.query(f'{self.source}SWE:FREQ:STEP:LIN?', float))
            return_val.update(dwell_time=self.query(f'{self.source}SWE:FREQ:DWEL?', float))
            if self.source == RF:
                return_val.update(mult=self.query('FREQ:MULT?', float))
                return_val.update(offset=self.query('FREQ:OFFS?', float))
            return return_val

        # Parameter Checking
        if self.source == RF:
            check_range('mult', mult, self.mult_min_max)
            check_range('offset', offset, self.offset_min_max)
        else:  # LFO doesn't support multiply or offset of frequency.
            mult = 1
            offset = 0
        if mult is not None:
            curr_mult = mult
        else:
            curr_mult = self.query('FREQ:MULT', float)
        if offset is not None:
            curr_offset = offset
        else:
            curr_offset = self.query('FREQ:OFFS?', float)
        cal_freq_min_max = self.__calibrate_freq_min_max(self.freq_min_max, curr_mult, curr_offset)
        check_range('freq', freq, cal_freq_min_max)
        check_range('start', start, cal_freq_min_max)
        check_range('stop', stop, cal_freq_min_max)
        if start is not None:
            if stop is not None:
                curr_stop = stop
            else:
                curr_stop = self.query(f'{self.source}FREQ:STOP?', float)
            if start >= curr_stop:
                raise ValueError(f'Bad start value {start} must be less than stop value {curr_stop}')
        if stop is not None:
            if start is not None:
                curr_start = start
            else:
                curr_start = self.query(f'{self.source}FREQ:STAR?', float)
            if stop <= curr_start:
                raise ValueError(f'Bad stop value {stop} must be more than start value {curr_start}')
        check_range('step', step, self.step_min_max)
        check_range('dwell_time', dwell_time, self.dwell_time_min_max)

        # Write to Instrument
        if freq is not None:
            self.write(f'{self.source}FREQ', freq)
        if start is not None:
            self.write(f'{self.source}FREQ:STAR', start)
        if stop is not None:
            self.write(f'{self.source}FREQ:STOP', stop)
        if step is not None:
            self.write(f'{self.source}SWE:FREQ:STEP:LIN', step)
        if self.source == RF:
            if mult is not None:
                self.write('FREQ:MULT', mult)
            if offset is not None:
                self.write('FREQ:OFFS', offset)
        if dwell_time is not None:
            self.write(f'{self.source}SWE:FREQ:DWEL', dwell_time)

    def __calibrate_freq_min_max(self, values, mult, offset):
        """
        Internal function used to calculate new freq limits based off of mult and offset.

        :param values: Base enum when mult = 1 and offset = 0
        :type values: min_max_units
        :param mult: multiplier
        :type mult: int|float
        :param offset: offset
        :type offset: int|float
        :return: Calibrated min_max values
        :rtype: min_max_units
        """
        return min_max_units(values.min * mult + offset, values.max * mult + offset, 'Hz')

class RfFreq(Freq):
    pass

class LfFreq(Freq):
    pass