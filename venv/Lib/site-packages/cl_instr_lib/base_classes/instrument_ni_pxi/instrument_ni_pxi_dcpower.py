import re
import hightime

from cl_instr_lib.base_classes.instrument_ni_pxi.instrument_ni_pxi_base import InstrumentNiPxiBase
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from nidcpower.session import Session
from nidcpower.enums import *


class InstrumentNiPxiDcpower(InstrumentNiPxiBase):
    """
    Base class for National Instruments PXI / PXIe modular instrument supported by the nidcpower Python package.
    Manages the creation of the Instrument Session object as needed for operating standalone or with the framework Pyro
    server.
    """

    def __init__(self, requested_model, resource_name, rm_handle=None, logger=None, **kwargs):
        """
        Initialize Base class for a National Instruments PXI / PXIe modular instrument. Manages the creation of the
        Instrument Session object as needed for operating standalone or with the framework Pyro server.

        :param requested_model: Identifies instrument model, e.g. 'NI PXIe-4139' or 'NI PXIe-4139 (40W)'. If controlling
            actual hardware (resource_name is not None), then instrument_model read from the hardware must either
            be an exact match or contain requested_model as a prefix. Example: if requested_model is 'NI PXIe-4139' and
            actual hardware returns 'NI PXIe-4139 (40W)', this is allowed but generates a warning. Conversely, if
            requested_model is 'NI PXIe-4139 (40W)' and the hardware returns 'NI PXIe-4139', an exception is raised;
            the idea being that the more capable instrument was specifically requested and is not available. If
            simulating hardware (resource_name is None), then requested_model is used to set up the session for the
            specified HW.
        :type requested_model: str
        :param resource_name: For actual hardware this identifies the chassis and slot of the hardware as it appears in
            NIMAX: for example 'PXI1Slot8'. For simulated HW this is None.
        :type resource_name: str|None
        :param rm_handle: In the validation framework this is used to pass in a reference to an already existing
            Session object. In the standalone usecase, this is always None.
        :type rm_handle: Session|None
        :param logger: In the validation framework this is used to pass in a reference to the framework logger. If None,
            then a logger is created (see Instrument class) that is used in the standalone usecase.
        :type logger: Logger|None
        :param kwargs: Could be passed on to inits of possible derived classes.
        :type kwargs: various
        """

        super().__init__(requested_model, resource_name, logger, **kwargs)

        # nidcpower.Session(self, resource_name, channels=None, reset=False, options={}, independent_channels=True)
        # nidigital.Session(self, resource_name, id_query=False, reset_device=False, options={})
        # niswitch.Session(self, resource_name, topology="Configured Topology", simulate=False, reset_device=False)

        if resource_name is None and rm_handle is None:
            # resource_name is None means we want a simulated instrument.

            # No hardware, so make up a resource name. Can't have spaces in it though.
            self._io_resource_descriptor = 'sim_' + requested_model.replace(' ', '_').replace('(', '').replace(')', '')
            self.simulated_inst = True
            self._session_is_external = False

            # For the simulation setup, we need the numeric part and any suffix that defines a particular variant.
            m = re.match(r'NI PXIe?-(\d{4}.*)', requested_model)
            model_number = m[1]

            self.session = Session(resource_name=self._io_resource_descriptor, reset=False,
                                               options={'simulate': True, 'driver_setup': {'Model': model_number}},
                                               **kwargs)
        else:
            if rm_handle is None:
                # resource name was provided, indicating we have actual hardware
                # rm_handle is None, so we need to create the session
                self._io_resource_descriptor = resource_name  # Use name as shown in NIMAX.
                self.simulated_inst = False
                self.session = Session(resource_name=self._io_resource_descriptor, reset=False, **kwargs)
                self._session_is_external = False
            else:
                # rm_handle was externally provided (from Framework).
                # Used in the framework on the client side where existing rm_handle is supplied by PyroServer. Server
                # initialization has already executed driver __init__ which put the instrument into run state.
                # Do abort so client can re-run driver __init__, which might include setting nimi properties
                # that require the instrument to be in the uncommitted state.
                rm_handle.abort()
                self.session = rm_handle
                self.simulated_inst = self.session.simulate  # supplied session may point to a simulated or physical hw.
                self._session_is_external = True

        self.rm_handle = self.session  # Pyro server initialization code looks for rm_handle.

        # This makes the console side logging work.
        if not self.session.simulate:
            self.resource_name = self.session.io_resource_descriptor

        self.log = self.get_logger_adapter(logger)
        self.log.setLevel('INFO')

        self._check_model_variants()

        self.check_cal_dates()
        self.check_cal_temp()

    def check_cal_dates(self):
        """
        Issues warnings if more than 1 day (24 hours) has elapsed since the last self calibration.

        This method does nothing if the driver is operating in simulation mode.

        :return: Dict keys are 'last_self_cal_datetime' and 'self_cal_recommended'. The datetime values are strings of
            the form '2023-02-13 15:37:00'. The cal_recommended value is boolean, with True indicating calibration
            should be performed.
        :rtype: dict
        """

        if self.simulated_inst:
            return   # TODO: We could make this return some mocked data.

        return_values = {}
        str_fmt = '%Y-%m-%d %H:%M:%S'  # Format returned to user.

        # Check External Cal, recommended interval: annual.
        # # TODO: Get a Cal vendor who is able to update this the EEPROM when they do the annual cal!
        # last_ext_cal_datetime = self.session.get_ext_cal_last_date_and_time()
        # if isinstance(last_ext_cal_datetime, hightime.datetime):
        #     last_cal_str = last_ext_cal_datetime.strftime(str_fmt)
        # else:
        #     # In framework Pyro casts datetime objects to string. We need datetime for delta calculation.
        #     last_ext_cal_datetime = hightime.datetime.strptime(last_ext_cal_datetime, '%Y-%m-%dT%H:%M:%S')
        #     last_cal_str = last_ext_cal_datetime.strftime(str_fmt)
        #
        # return_values.update(last_ext_cal_datetime=last_cal_str)
        #
        # ext_recommended = self.session.get_ext_cal_recommended_interval()  # Gives timedelta obj, not months.
        # if isinstance(ext_recommended, float):
        #     ext_recommended = hightime.timedelta(seconds=ext_recommended)
        #
        # delta = hightime.datetime.now() - last_ext_cal_datetime
        #
        # if delta.days >= ext_recommended.days:
        #     self.log.warning(f'Last external calibration was {last_cal_str}, which is {delta.days} days ago, '
        #                      f'exceeding the recommended interval of {ext_recommended.days} days!')
        #     return_values.update(ext_cal_recommended=True)
        # else:
        #     return_values.update(ext_cal_recommended=True)

        # Check self_cal, recommended interval: daily

        last_self_cal_datetime = self.session.get_self_cal_last_date_and_time()
        if isinstance(last_self_cal_datetime, hightime.datetime):
            last_cal_str = last_self_cal_datetime.strftime(str_fmt)
        else:
            # In framework Pyro casts datetime objects to string. We need datetime for delta calculation.
            last_self_cal_datetime = hightime.datetime.strptime(last_self_cal_datetime, '%Y-%m-%dT%H:%M:%S')
            last_cal_str = last_self_cal_datetime.strftime(str_fmt)

        return_values.update(last_self_cal_datetime=last_cal_str)

        delta = hightime.datetime.now() - last_self_cal_datetime
        if delta.days >= 1:
            self.log.warning(f'Last self calibration was {last_cal_str}, {delta.days} days ago!\n'
                             f'Self calibration using the <smu>.perform_self_cal method is recommended.')
            return_values.update(self_cal_recommended=True)
        else:
            return_values.update(self_cal_recommended=False)

        return return_values

    def check_cal_temp(self):
        """
        Issues warning if current temperature is more than +/- 5 degrees C different from the temperature at which the
        last self calibration was performed.

        Note that if the instrument has been powered off for a while, you will likely get this warning. Rather than
        immediately performing a self_cal in that case, you may want to wait some warmup period (~30 minutes) for the
        internal temperature to stabilize to a value near last_self_cal_temp.

        This method does nothing if the driver is operating in simulation mode.

        :return: Dict keys are 'current_temp', 'last_self_cal_temp' and 'near_cal_temp'. The temperature values
            are floats in degrees C. The near_cal_temp value is boolean, with True indicating the current temp is
            within 5 C from the temp used in the last self_cal.
        :rtype: dict
        """

        if self.simulated_inst:
            return   # TODO: We could make this return some mocked data.

        return_values = {}

        last_self_cal_temp = self.session.get_self_cal_last_temp()
        current_temp = self.session.read_current_temperature()
        return_values.update({'last_self_cal_temp': last_self_cal_temp, 'current_temp': current_temp})
        if abs(current_temp - last_self_cal_temp) >= 5.0:
            self.log.warning(f'Current temperature {current_temp:3.1f}C, is more than +/- 5C different from last '
                             f'self_cal temp of {last_self_cal_temp:3.1f}C.\nIf powering on from a prolonged '
                             f'powered down state, wait for the instrument temperature to stabilize (~30 minutes) '
                             f'before doing <smu>.perform_self_cal.\n'
                             f'Use <smu>.check_cal_temp() to observe the temperatures.')
            return_values.update(near_cal_temp=False)
        else:
            return_values.update(near_cal_temp=True)

        return return_values

    # TODO: Put this code back in once Pyro is fixed (PLATDEV-1620)
    # def perform_self_cal(self, persistence=SelfCalibrationPersistence.KEEP_IN_MEMORY):
    #     """
    #     Performs a self_cal on the SMU. This is done at the session level, so all channels in multi-chanel SMUs are
    #     calibrated.
    #
    #     :param persistence: Default value is 'KEEP_IN_MEMORY' which does **not** store the cal results in non-volatile
    #         EEPROM. This is preferred even though the results of the calibration are lost if reset() is called or the
    #         power is cycled or another self_cal is run because it conserves the EEPROMs limited number of write
    #         cycles. Since self cal should be run daily and setups likely remain powered all day, there is little
    #         value in using WRITE_TO_EEPROM unless it is desired to preserve the cal results across a power cycle or
    #         a reset. Note that for the 4139, only WRITE_TO_EEPROM is supported by the instrument.
    #     :type persistence: str|SelfCalibrationPersistence
    #     :return: None
    #     """
    #
    #     persistence = check_enum_str('persistence', persistence, SelfCalibrationPersistence)
    #     if self.get_model().startswith('NI PXIe-4139'):
    #         if persistence == SelfCalibrationPersistence.KEEP_IN_MEMORY:
    #             raise ValueError(f"Bad persistence '{persistence.name}' for {self.get_model()}, with this model you "
    #                              f"must use 'WRITE_TO_EEPROM'.")
    #
    #     self.session.self_calibration_persistence = persistence
    #
    #     self.session.self_cal()

    def perform_self_cal(self):
        """
        Performs a self_cal on the SMU. This calibrates all channels in multi-chanel SMUs.

        **Be advised this will disconnect the SMU output and reset any existing settings!**

        NOTE: The value of self_calibration_persistence used is the instrument default value. Pyro server serialization
        issues (PLATDEV-1620) prevent making the persistence configurable from the Client at this time. For the 4139,
        the default persistence is WRITE_TO_EEPROM. For 4145, 4147 and 4163, it is KEEP_IN_MEMORY. For the latter SMUs,
        this means cal data will be volatile, meaning it will not persist across resets or power cycles. This should
        not be a big limitation considering that daily self_cal is recommended and this driver only resets the SMU
        if you call the reset() method or perform_self_cal().

        :return: None
        """

        self.session.self_cal()



