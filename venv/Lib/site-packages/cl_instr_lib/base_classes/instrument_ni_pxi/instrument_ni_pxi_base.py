import re

from cl_instr_lib.base_classes.instrument import Instrument
from cl_instr_lib.helpers.on_off import OnOff, on_off_vals


class InstrumentNiPxiBase(Instrument):
    """
    Base class for National Instruments PXI / PXIe modular instruments providing methods whose implementation is common
    to the various PXI / PXIe modules. Instrument classes for specific NIMI packages, e.g. nidcpower, niswitch etc are
    derived from this and add the session initialization for the specific package.
    """

    # Translator to/from various API representations that can be used in our APi vs. the nimi API.
    on_off = OnOff(off_vals=on_off_vals(('OFF', False, 0, '0'), False, ('OFF', '0', 0), 'OFF'),
                   on_vals=on_off_vals(('ON', True, 1, '1'), True, ('ON', '1', 1), 'ON'))

    def __init__(self, requested_model, resource_name, logger, **kwargs):
        """
        Initialize Base class for National Instruments PXI / PXIe modular instruments.
        """
        self.requested_model: str = requested_model
        """Requested instrument model name"""
        self._session_is_external: bool = True
        """Was the session provided externally?"""

        super().__init__(resource_name=resource_name)

        self.log = self.get_logger_adapter(logger)
        self.log.setLevel('INFO')

    def __del__(self):
        """Closes the session only if it had created it"""
        if not self._session_is_external and hasattr(self, 'session') and self.session:
            self.session.close()

    def _check_model_variants(self):
        actual_model = self.get_model()

        if actual_model == self.requested_model:
            # Exact match - no problem !
            self.log.info(f"Instrument is model '{actual_model}'.")  # What we have always done.
        else:
            # actual_model might be a variant of model. Then model is a prefix, variant info is a suffix.
            # For example, model is 'NI PXIe-4139' and the hardware returns 'NI PXIe-4139 (40W)'
            # The presence of the suffix seems to indicate a more capable instrument.
            # Note that if model included the suffix - that indicates the more capable instrument was
            # required, so re will return None and ValueError will happen!
            check_re = '^' + self.requested_model + '.*$'
            m = re.match(check_re, actual_model)
            if m is None:
                raise ValueError(f"Instrument at '{self.resource_name}' does not match model '{self.requested_model}', "
                                 f"actual model '{actual_model}'.")

            # Got a suffix that wasn't in the requested model, allow this, but warn user.
            self.log.info(f"Instrument is model '{actual_model}', requested model was '{self.requested_model}'.")

    def get_model(self):
        """
        Returns the result of the reading the instrument_model property.

        :return: Instrument Model string
        :rtype: str
        """

        return self.session.instrument_model

    def reset(self):
        """
        Resets the device to a known state. The method disables power generation, resets session properties to their
        default values, clears errors such as overtemperature and unexpected loss of auxiliary power, commits the
        session properties, and leaves the session in the Uncommitted state. This method also performs a hard reset on
        the device and driver software. This method has the same functionality as using reset in Measurement &
        Automation Explorer.
        """
        self.session.reset_device()
