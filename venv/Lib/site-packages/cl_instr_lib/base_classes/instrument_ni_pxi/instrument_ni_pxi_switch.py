import re

from cl_instr_lib.base_classes.instrument_ni_pxi.instrument_ni_pxi_base import InstrumentNiPxiBase
from niswitch.session import Session


class InstrumentNiPxiSwitch(InstrumentNiPxiBase):
    """
    Base class for National Instruments PXI / PXIe modular instrument supported by the niswitch Python package.
    Manages the creation of the Instrument Session object as needed for operating standalone or with the framework Pyro
    server.
    """

    def __init__(self, requested_model, topology, resource_name, rm_handle=None, logger=None, **kwargs):
        """
        Initialize Base class for a National Instruments PXI / PXIe modular instrument. Manages the creation of the
        Instrument Session object as needed for operating standalone or with the framework Pyro server.

        :param requested_model: Identifies instrument model, e.g. 'PXI-2567'. If controlling
            actual hardware (resource_name is not None), then instrument_model read from the hardware must either be an
            exact match or contain requested_model as a prefix. If simulating hardware (resource_name is None), then
            requested_model is used to set up the session for the specified HW.
        :type requested_model: str
        :param topology String that identifies switching topology to be used. Note that the values provided in the
            NI Modular Instrument Python API under the Session method have been found to not work. For the PXI-2567, for
            example the documentation shows the string as 'NISWITCH_TOPOLOGY_2567_INDEPENDENT', but the string that
            actually works is '2567/Independent'.
        :type topology
        :param resource_name: For actual hardware this identifies the chassis and slot of the hardware as it appears in
            NIMAX: for example 'PXI1Slot5'. For simulated HW this is None.
        :type resource_name: str|None
        :param rm_handle: In the validation framework this is used to pass in a reference to an already existing
            Session object. In the standalone usecase, this is always None.
        :type rm_handle: Session|None
        :param logger: In the validation framework this is used to pass in a reference to the framework logger. If None,
            then a logger is created (see Instrument class) that is used in the standalone usecase.
        :type logger: Logger|None
        :param kwargs: Could be passed on to inits of possible derived classes.
        :type kwargs: various
        """

        super().__init__(requested_model, resource_name, logger, **kwargs)

        # nidcpower.Session(self, resource_name, channels=None, reset=False, options={}, independent_channels=True)
        # nidigital.Session(self, resource_name, id_query=False, reset_device=False, options={})
        # niswitch.Session(self, resource_name, topology="Configured Topology", simulate=False, reset_device=False)

        if resource_name is None and rm_handle is None:
            # resource_name is None means we want a simulated instrument.

            # No hardware, so make up a resource name. Can't have spaces in it though.
            self._io_resource_descriptor = 'sim_' + requested_model.replace(' ', '_').replace('(', '').replace(')', '')
            self.simulated_inst = True
            self._session_is_external = False

            # For the simulation setup, we need the numeric part and any suffix that defines a particular variant.
            m = re.match(r'NI PXIe?-(\d{4}.*)', requested_model)
            model_number = m[1]

            self.session = Session(resource_name=self._io_resource_descriptor, topology=topology, reset_device=False,
                                   simulate=True)
        else:
            if rm_handle is None:
                # resource name was provided, indicating we have actual hardware
                # rm_handle is None, so we need to create the session
                self._io_resource_descriptor = resource_name  # Use name as shown in NIMAX.
                self.simulated_inst = False
                self.session = Session(resource_name=self._io_resource_descriptor, topology=topology,
                                       reset_device=False)
                self._session_is_external = False
            else:
                # rm_handle was externally provided (from Framework).
                # Used in the framework on the client side where existing rm_handle is supplied by PyroServer. Server
                # initialization has already executed driver __init__ which put the instrument into run state.
                # Do abort so client can re-run driver __init__, which might include setting nimi properties
                # that require the instrument to be in the uncommitted state.
                self.session = rm_handle
                self.simulated_inst = self.session.simulate  # supplied session may point to a simulated or physical hw.
                self._session_is_external = True

        self.rm_handle = self.session  # Pyro server initialization code looks for rm_handle.

        # This makes the console side logging work.
        if not self.session.simulate:
            self.resource_name = self.session.io_resource_descriptor

        self.log = self.get_logger_adapter(logger)
        self.log.setLevel('INFO')

        self._check_model_variants()

    def reset(self):
        """
        Resets the NI-Switch instrument
        """
        self.session.reset()
