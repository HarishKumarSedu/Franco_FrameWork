from abc import ABC, abstractmethod
from cl_instr_lib.base_classes.pyro_isinstance import PyroIsinstance

class DmmBasic_ABC(PyroIsinstance):
    def __init__(self, visa_resource_name, logger=None, **kwargs):
        super().__init__(visa_resource_name, logger=None, **kwargs)

    @abstractmethod
    def measure(self, function=None):
        # :MEASure[:<function>]?
        pass

    @abstractmethod
    def setup_aci(self, irange, npl_cycles, bandwidth, *args, **kwargs):
        pass

    @abstractmethod
    def setup_dci(self, irange, npl_cycles, *args, **kwargs):
        pass

    @abstractmethod
    def setup_dcv(self, vrange=None, npl_cycles=None, *args, **kwargs):
        pass

    @abstractmethod
    def setup_acv(self, vrange, npl_cycles, bandwidth, *args, **kwargs):
        pass

    @abstractmethod
    def setup_ohms2w(self, rrange, npl_cycles, *args, **kwargs):
        pass

    @abstractmethod
    def setup_ohms4w(self, rrange, npl_cycles, *args, **kwargs):
        pass

    @abstractmethod
    def setup_freq(self, threshold, *args, **kwargs):
        pass

    @abstractmethod
    def setup_period(self, threshold,  *args, **kwargs):   # Might need to reconsider digits vs aperature
        pass

    @abstractmethod
    def select_function(self, function=None):
        # [:SENSe[1]]:FUNCtion <name>
        pass

    @abstractmethod
    def initiate(self,  *args, **kwargs):
        pass

    @abstractmethod
    def abort(self):
        # :ABORt
        pass

    @abstractmethod
    def setup_trigger(self, event_source, delay_sec, samp_count, trig_count):
        # :TRIGger[:SEQuence[1]]:SOURce <name>
        # :TRIGger[:SEQuence[1]]:DELay <n>
        pass

    @abstractmethod
    def fetch(self):
        # FETCH?
        pass

    @abstractmethod
    def read(self):
        # READ?
        pass
