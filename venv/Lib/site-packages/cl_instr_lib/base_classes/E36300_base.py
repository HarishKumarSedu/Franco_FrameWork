from collections import namedtuple

from cl_instr_lib.base_classes.instrument_chanlist import InstrumentChanList
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC

ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])


class E36300_base(InstrumentChanList, PowerSupply):
    """Driver base class for Keysight E36300 series Triple Output Power Supplies."""

    def __init__(self, visa_resource_name, ch1_bounds, ch2_bounds, ch3_bounds, logger=None, **kwargs):
        # Setup the simulation code inherited from Instrument.
        """ First parameter is command to determine number of channels.
            Not applicable to E36313A, so using 'FIXED: {number of channels}'
        """
        super().__init__(visa_resource_name,
                         chan_id_max=3, logger=logger,
                         channel_specific_cmds=('VOLT', 'CURR', 'MEAS'),
                         channel_sel_default=1,
                         channel_sel_cmd='INST:NSEL',
                         **kwargs)

        # Create the channel objects. (Note creating the attributes directly enables auto-complete in editor.)
        # Pass power supply self down to channel so he knows who his container is.
        self.OUTPUT_CH1 = Channel(self, 'CH1', 1, ch1_bounds)
        self.OUTPUT_CH2 = Channel(self, 'CH2', 2, ch2_bounds)
        self.OUTPUT_CH3 = Channel(self, 'CH3', 3, ch3_bounds)

        self._channel_names = ['OUTPUT_CH1', 'OUTPUT_CH2', 'OUTPUT_CH3']

        """ The following classes/methods are now 'referenced' within the Channel Class '__init__' method:
                self.track = PsuTrack()
                self.delay = PsuDelay()
                self.LIST = PsuList()
                self.sense = PsuSense()

            Although they can be 'referenced' here and the code will work, pyCharm may have issues resolving the
            method/attributes and have difficulty displaying 'help' documentation.  
        """

    def reset(self):
        """
        |   **Description**
        |   Clear status and error buffers before resetting the instrument.

        :return: None
        :rtype:
        """

        self.write('*CLS', '')
        super().reset()

    @staticmethod
    def replace_channel_names(resp):
        """
        |   **Description**
        |    Replaces returned channel information with 'CH1', 'CH2', and 'CH3', as the unit
             will generally return the Legacy E3631A channel names of P6V, P25V, and N25V.
        |       Unit can use either set of names.

        :param resp: Original response string from unit.
        :type resp: str or list
        :return: Returns reformatted response from unit with channel names replaced with 'CH1',
                 'CH2' or 'CH3'
        :rtype: str or list
        """

        if type(resp) is str:
            resp = resp.replace('P6V', 'CH1')
            resp = resp.replace('P25V', 'CH2')
            resp = resp.replace('N25V', 'CH3')
        else:
            resp = list(resp)       # convert to a list
            for index, element in enumerate(resp):
                resp[index] = resp[index].replace('P6V', 'CH1')
                resp[index] = resp[index].replace('P25V', 'CH2')
                resp[index] = resp[index].replace('N25V', 'CH3')

        return resp

    def output_state(self, on_off=None):
        """
        |   **Description**
        |   Queries or sets the output state (OFF or ON) of **ALL** three outputs.
        |       This allows compatibility with E3631A driver.

        :param on_off: Options are:

                        * None - unit is queried
                        * For ON accepts: 'ON', True, 1 or '1'.
                        * For OFF accepts: 'OFF', False, 0, or '0'.
        :type on_off: str or int
        :return: If None/no arguments are supplied, instrument is queried and the state ('ON' or 'OFF')
                 of **EACH** channel is returned e.g. 'CH1 : ON, CH2 : ON, CH3 : ON'.
        :rtype: str

        ::

            Example:

                1. E36313A.output_state()
                        # will return a string with the status of ALL three outputs

                2. E36313A.output_state(on_off='ON)
                        # will enable ALL three channels
        """

        channels = [1, 2, 3]
        if on_off is None:

            resp = self.query('OUTP:STATE?', str, channels)

            ''' return string with status of each channel '''
            out_state = ''
            for index, ch in enumerate(resp):
                # print (f'{index} = {ch}')
                out_state += f'CH{channels[index]}: {self.on_off.to_api(int(ch))}, '

            return out_state.rstrip(', ')

        # Instrument does not like white space at end of scpi_cmd, hence using value = ';'
        self.write(f'OUTP:STAT', self.on_off.to_inst(on_off), channels)

    def trigger_source(self, trig=None):
        """
        |   **Description**
        |   Query or configure the TRIGGER source for **ALL** output channels.

        :param trig: Options are:

                        * None/no argument will query the unit
                        * 'BUS' (remote cmd is trigger)
                        * 'EXT' (All configured connector pins)
                        * 'IMM' (as soon as output is enabled)
                        * 'PIN#' (Digital pins 1,2 or 3)
        :type trig: str
        :return: Current Trigger mode for each channel, e.g. 'CH1: BUS, CH2: BUS, CH3: BUS'
        :rtype: str 
        
        ::

            Example:

                1. E36313A.trigger_source()
                        # will return the trigger source for each channel.

                2. E36313A.trigger_source('EXT')
                        # will configure 'external' trigger for each channel
        """

        if trig is None:
            # List comprehension
            resp = [f'CH{[1, 2, 3][ind]}: {elem}' for ind, elem in
                    enumerate(self.query('TRIG:SOUR?', str, [1, 2, 3]))]
            return str(resp).replace('\'', '').strip('[]')
        elif str(trig).upper() in ['BUS', 'EXT', 'IMM', 'PIN1', 'PIN2', 'PIN3']:
            self.write('TRIG:SOUR', trig.upper(), [1, 2, 3])
        else:
            raise ValueError(f"Bad value {str(trig).upper()}. "
                             f"Should be either 'BUS', 'EXT', 'IMM', 'PIN1','PIN2','PIN3'")

    def couple(self, on_off=None, channels=None):
        """
        |   **Description**
        |   Queries or sets how the channels are 'coupled' for output synchronization,
            e.g. a single enable can be used to enable multiple channels.
        |
        |    This can be utilised with the 'delay' methods to sequence how the channels are enabled.

        :param on_off: Options are:

                        * None/no argument will query the unit
                        * 'OFF' will disable for all channels.
                        * 'ON' will enable ONLY for the channels listed in '**channels**'.
        :type on_off: str
        :param channels: List of channels (by number) that will be 'coupled', e.g [1,2,3].
        :type channels: list(int)

        :return: {'**on_off**': None, '**channels**': channels that have been 'COUPLEd'
        :rtype: dict

        ::

            Example:

                1. E36313A.couple()
                        # Will return the status of the coupling mode (default should be 'NONE')

                2. E36313A.couple('on', [1,3])
                        # Will enable coupling between CH1 and CH3. When either channel is
                        # enabled/disabled, the other channel will also be enabled/disabled.
        """

        if on_off is None:
            resp = self.query('OUTP:STAT:COUP:CHAN?')
            return {'on_off': None, 'channels': self.replace_channel_names(resp)}

        if 'OFF' in self.on_off.to_api(on_off):
            self.write('OUTP:STAT:COUP:CHAN', value='NONE')
            return

        if 'ON' in self.on_off.to_api(on_off) and channels is None:
            raise ValueError(f"Coupling not enabled as no channels specified. "
                             f"Param 'channels' should be a list, e.g. [1,2]")

        if type(channels) is not list:
            raise ValueError(f"Coupling not enabled as no channels specified. "
                             f"Param 'channels' should be a list, e.g. [1,2]")
        else:
            if len(channels) == 3:  # Assumption that user enters [1,2,3] to apply coupling to all channels
                chan_list = 'ALL'
            else:
                chan_list = ''
                for ch in channels:
                    chan_list += f'CH{ch}, '
                chan_list = chan_list.rstrip(', ')

            # print (chan_list)
            self.write('OUTP:STAT:COUP:CHAN', value=chan_list)

    def save_config(self, location=0):
        """
        |   **Description**
        |   Save the current configuration to non-volatile storage on unit
        |      There are 10 locations, 0 to 9

        :param location: Storage Location in non-volatile memory - in range from 0 to 9
        :type location: int
        :return: None
        :rtype:

        ::

            Example:

                1. E36313A.save_config(3)
                        # will store the current configuration of unit to location 3
        """

        if type(location) is not int:
            raise ValueError(f"Bad location {location} specified. Should be an Integer in range [0-9].")
        elif 0 <= location <= 9:
            self.write('*SAV', location)
            self.log.info(f'Configuration saved to location {location}')
        else:
            raise ValueError(f"Bad location {location} specified. Should be an Integer in range [0-9].")

    def recall_config(self, location=0):
        """
        |   **Description**
        |   Recall a configuration from non-volatile storage on unit
        |       There are 10 locations, 0 to 9

        :param location: Storage Location in non-volatile memory - in the range from 0 to 9
        :type location: int
        :return: None
        :rtype:

        ::

            Example:

                1. E36313A.recall_config(3)
                        # will recall configuration from location 3
        """

        if type(location) is not int:
            raise ValueError(f"Bad location {location} specified. Should be an Integer in range [0-9].")
        elif 0 <= location <= 9:
            self.write('*RCL', location)
            self.log.info(f'Configuration recalled from location {location}')
        else:
            raise ValueError(f"Bad location {location} specified. Should be an Integer in range [0-9].")


class Channel(PSChannel_ABC):
    """Implements the methods to control a channel of a power supply."""

    def __init__(self, power_supply, channel_name, channel_id, programming_bounds):
        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)
        self.channel_id = channel_id

        # extend Channel class with the new classes defined
        channel = (power_supply, channel_name, channel_id, programming_bounds)

        # Create 'delay' objects to 'append' the Delay Functions
        self.delay = PsuDelay(channel)

        # Create 'LIST' objects to 'append' the PsuList Functions
        self.LIST = PsuList(channel)

        # Create 'sense' objects to 'append' the PsuSense Functions
        self.sense = PsuSense(channel)

        # Create 'track' objects to 'append' the Track Functions - note only applicable to CH2 and CH3
        if 'CH1' not in channel_name:
            self.track = PsuTrack(channel)

    def source_voltage(self, voltage=None, current_limit=None, *args, **kwargs):
        """
        |   **Description**
        |   Queries all or sets any combination of parameters for operating as a **VOLTAGE** source.

        :param voltage: Output voltage in Volts. See attribute *'programming_bounds'* for limits.
        :type voltage: float
        :param current_limit: Compliance limit for output current in Amperes. See attribute
                              *'programming_bounds'* for limits.
        :type current_limit: float

        :return: If no arguments are supplied, instrument is queried and a dict of parameter
                 names-values is returned.
        :rtype: dict

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.source_voltage()
                        # will return the settings for voltage, current

                2. E36313A.OUTPUT_CH<n>.source_voltage(5.0, 1.0)
                        # will set voltage to 5.0V, current limit to 1.0A

                3. E36313A.OUTPUT_CH<n>.source_voltage(3.3)
                        # will set voltage to 3.3V, and current limit will not be altered
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit}):
            self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
            return_value = {}
            return_value.update(voltage=self.power_supply.query("VOLT", float))
            return_value.update(current_limit=self.power_supply.query("CURR", float))
            return return_value

        if voltage is not None and not \
                (self.programming_bounds.volts_min <= voltage <= self.programming_bounds.volts_max):
            raise ValueError(f"Bad voltage {voltage} V for {self.power_supply.get_model()} {self.channel_name},"
                             f" should be {self.programming_bounds.volts_min} to "
                             f"{self.programming_bounds.volts_max} V.")

        if current_limit is not None and not (
                self.programming_bounds.amps_min <= current_limit <= self.programming_bounds.amps_max):
            raise ValueError(f"Bad current_limit {current_limit} A for {self.power_supply.get_model()} "
                             f"{self.channel_name}, should be {self.programming_bounds.amps_min} to "
                             f"{self.programming_bounds.amps_max} A.")

        if any(v is not None for v in {voltage, current_limit}):
            # Going to set something, so select the channel in the instrument.
            self.power_supply.write(self.power_supply.channel_sel_cmd, f"{self.channel_id}")

        if voltage is not None:
            self.power_supply.write("VOLT", voltage)

        if current_limit is not None:
            self.power_supply.write("CURR", current_limit)

        self.power_supply.log_inst_errors()

    def measure_voltage(self):
        """
        |   **Description**
        |   Returns the measured value at the output in Volts.

        :return: Measured voltage
        :rtype: float

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.measure_voltage()
                        # will return 'measured' output voltage for the SPECIFIED channel.
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
        return self.power_supply.query("MEAS:VOLT", float)

    def measure_current(self):
        """
        |   **Description**
        |   Returns the measured value at the output in Amperes.

        :return: Measured current
        :rtype: float

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.measure_current()
                        # will return 'measured' output current for the SPECIFIED channel.
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
        return self.power_supply.query("MEAS:CURR", float)

    def output_state(self, on_off=None):
        """
        |   **Description**
        |   Queries or sets the output state (OFF or ON) for the SPECIFIED channel.
        |       The E36313A supports independent ON/OFF controls for each output.

        :param on_off: Options are:

                        * None - unit is queried
                        * For ON accepts: 'ON', True, 1 or '1'.
                        * For OFF accepts: 'OFF', False, 0, or '0'.
        :type on_off: str (or int)
        :return: returns the status of the specified channel
        :rtype: str

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.output_state()
                        # will return the status of the channel SPECIFIED

                2. E36313A.OUTPUT_CH<n>.output_state('on')
                        # will enable the channel SPECIFIED
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if on_off is None:
            return self.power_supply.on_off.to_api(self.power_supply.query('OUTP:STAT', int))
        elif self.power_supply.on_off.to_api(on_off) in ['OFF', 'ON']:
            self.power_supply.write('OUTP:STAT', self.power_supply.on_off.to_inst(on_off))
            return
        else:
            raise ValueError(f"Bad value {on_off}, should be {self.power_supply.on_off.api_off_values()} or "
                             f"{self.power_supply.on_off.api_on_values()}.")

    def trigger_source(self, trig=None):
        """
        |   **Description**
        |   Query or configure the TRIGGER source for the SPECIFIED channel

        :param trig: Options are:

                        * None/no argument will query the unit
                        * 'BUS' (remote cmd is trigger)
                        * 'EXT' (All configured connector pins)
                        * 'IMM' (as soon as output is enabled)
                        * 'PIN#' (Digital pins 1,2 or 3)
        :type trig: str
        :return: returns the Current Trigger mode for the channel SPECIFIED, e.g
                 ['BUS', 'EXT', 'IMM', 'PIN1','PIN2','PIN3']
        :rtype: str

        ::

            Example:
                1. E36313A.OUTPUT_CH<n>.trigger_source()
                        # Will return the trigger source for the SPECIFIED channel

                2. E36313A.OUTPUT_CH<n>.trigger_source('EXT')
                        # Will configure external trigger for the SPECIFIED channel
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if trig is None:
            return self.power_supply.query('TRIG:SOUR?', str).strip()
        elif str(trig).upper() in ['BUS', 'EXT', 'IMM', 'PIN1', 'PIN2', 'PIN3']:
            self.power_supply.write('TRIG:SOUR', trig.upper())
        else:
            raise ValueError(f"Bad value {str(trig).upper()}. "
                             f"Should be either 'BUS', 'EXT', 'IMM', 'PIN1','PIN2','PIN3'")

    def get_status(self):
        """
        |   **Description**
        |   Returns a string indicating present operating mode of the channel.

        :return: One of 'OFF', 'CC' = Current compliance limit exceeded, 'CV' = Normal voltage
                  source operation, 'UN' = Unregulated (Bad).
        :rtype: str
        """

        isum = self.power_supply.query(f"STAT:QUES:INST:ISUM{self.channel_id}:COND", int)
        return {0: 'OFF', 1: 'CC', 2: 'CV', 3: 'UN'}[isum]


class PsuDelay(object):
    """
    |   Class for the Delay feature, to implement the methods required
    |
    |   Inherits attributes from the *'Channel'* class defined in this driver
    """
    ''' ### Pass in the Channel object and extract the required channel information '''

    def __init__(self, channel):
        """
        Pass in the channel object for the required channel information to be extracted for functionality

        :param channel: Tuple of the Power Supply Channel attributes 'power_supply, channel_name, channel_id, and
                        programming_bounds
        """

        self.power_supply = channel[0]          # power_supply
        self.channel_name = channel[1]          # channel_name
        self.channel_id = channel[2]            # channel_id
        self.programming_bounds = channel[3]    # programming_bounds

    def get_delays(self):
        """
        |   **Description**
        |   Queries the Rise/Fall delays (in secs) that are applied for the SPECIFIED Channel. 
            The delay is with respect to when the 'trigger' for the channel is sent.
        |       Although the delay can be set from 0.000 to 3600.000 with a 1ms resolution (MIN = 0,
        |   MAX = 3600), read back of the delays are 'rounded down' to the nearest second.
        |
        |       Note: This is 'best' used with the COUPLE mode, therefore having the ability to
                control the enable sequence of the channels.

        :return: return both the On and Off delays for the channel SPECIFIED.
                 (NOTE: Readings are 'rounded-down' to nearest second)
        :rtype: str

        ::

            Example:

                E36313A.OUTPUT_CH<n>.delay.get_delays()
                        # Will return 'CH<n>: DEL:RISE: {del_rise}s / DEL:FALL: {del_fall}s'
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        del_rise = self.power_supply.query('OUTP:STAT:DEL:RISE?', rtn_type=float)
        del_fall = self.power_supply.query('OUTP:STAT:DEL:FALL?', rtn_type=float)

        return f'{self.channel_name}: DEL:RISE: {del_rise}s / DEL:FALL: {del_fall}s'

    def set_delays(self, on_delay=None, off_delay=None):
        """
        |   **Description**
        |   Configures the ON/RISE and OFF/FALL delays, with respect to the 'trigger', for the
            specified Channel.
        |       To read the delays, use *get_delays()* method.

        :param on_delay: Delay in seconds that channel **enables** with respect to the 'trigger'.
                         None will make no change. To set a delay, use 'MIN', 'MAX, or a float from
                         0.000 to 3600.000 (1ms resolution).
        :type on_delay: float
        :param off_delay: Delay in seconds that channel **disables** with respect to the 'trigger'.
                          None will make no change. To set a delay, use 'MIN', 'MAX, or a float from
                          0.000 to 3600.000 (1ms resolution).
        :type off_delay: float
        :return: {'on_delay': 'type float', 'off_delay': 'type float'}
        :rtype: dict

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.delay.set_delays(on_delay=1.3, off_delay=0.5)
                        # Output will turn ON 1.3s after the 'enable trigger' and
                        # turn OFF 0.5s after the 'disable trigger'

                2. E36313A.OUTPUT_CH<n>.delay.set_delays(on_delay='MAX', off_delay=None)
                        # Output will turn ON 3600.0s after the 'enable trigger' and
                        # no change will be made to the off_delay
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
        max_min = {'MAX': 3600.0, 'MIN': 0.0}

        if on_delay is None and off_delay is None:
            self.power_supply.log.info(f'No changes made to the on/off Delay times for {self.channel_name}')
            return {'on_delay': 'type float', 'off_delay': 'type float'}

        if on_delay is not None:
            if str(on_delay).upper() in ['MIN', 'MAX']:
                self.power_supply.write('OUTP:STAT:DEL:RISE', value=str(on_delay).upper())
                self.power_supply.log.info(f'Delay (Rise) for {self.channel_name} has been set to '
                                           f'{max_min[str(on_delay).upper()]}')
            elif 0.0 <= float(on_delay) <= 3600.0:
                self.power_supply.write('OUTP:STAT:DEL:RISE', value=str(on_delay))
                self.power_supply.log.info(f'Delay (Rise) for {self.channel_name} has been set to {float(on_delay)}')
            else:
                raise ValueError(f"Bad value {on_delay}. Should be 0.000 <= on_delay <= 3600.000")

        if off_delay is not None:
            if str(off_delay).upper() in ['MIN', 'MAX']:
                self.power_supply.write('OUTP:STAT:DEL:FALL', value=str(off_delay).upper())
                self.power_supply.log.info(f'Delay (Fall) for {self.channel_name} has been set to '
                                           f'{max_min[str(off_delay).upper()]}')
            elif 0.0 <= float(off_delay) <= 3600.0:
                self.power_supply.write('OUTP:STAT:DEL:FALL', value=str(off_delay))
                self.power_supply.log.info(f'Delay (Fall) for {self.channel_name} has been set to {float(off_delay)}')
            else:
                raise ValueError(f"Bad value {off_delay}. Should be 0.000 <= off_delay <= 3600.000")

        return


class PsuTrack(object):
    """
    |   Class for the Track feature, to implement the methods required
    |       **Only** applicable to OUTPUT_CH2 and OUTPUT_CH3.
    |
    |   Inherits attributes from the *'Channel'* class defined in this driver
    """
    ''' ### Pass in the Channel object and extract the required channel information '''

    def __init__(self, channel):
        """
        Pass in the channel object for the required channel information to be extracted for functionality

        :param channel: Tuple of the Power Supply Channel attributes 'power_supply, channel_name, channel_id, and
                        programming_bounds
        """

        self.power_supply = channel[0]          # power_supply
        self.channel_name = channel[1]          # channel_name
        self.channel_id = channel[2]            # channel_id
        self.programming_bounds = channel[3]    # programming_bounds

    def state(self, on_off=None):
        """
        |   **Description**
        |   Queries or sets the 'TRACK' mode for CH2 and CH3 (applies to voltage only).
        |       When enabled, CH2 and CH3 will have the same VOLTAGE and both are updated when
            EITHER channel is updated.
        |
        |       If enabling TRACK, the 'COUPLE' mode will be DISABLE (i.e. set to 'NONE').

        :param on_off: 'OFF' or 'ON' to disabled/enable. No Argument will query the unit.
        :type on_off: str (or int)
        :return: If None/no arguments are supplied, instrument is queried and the state ('ON' or 'OFF')
                 returned.
        :rtype: str

        ::

            Example:

                1. E36313A.OUTPUT_CH<2 or 3>.track.state()
                        # will return the current state of the tracking mode
                        # E36313A.OUTPUT_CH3.track.state() will do the same

                2. E36313A.OUTPUT_CH2.track.state('ON')
                        # will enable tracking for CH2 and CH3
                        # E36313A.OUTPUT_CH3.track.state('ON') will do the same
        """

        # print(self.channel_id)
        # print(self.channel_name)

        if 'CH1' in self.channel_name.upper():
            raise ValueError(f"Tracking NOT applicable to {self.channel_name}. Tracking only applicable to CH2 and CH3")

        if on_off is None:
            return self.power_supply.on_off.to_api(self.power_supply.query('OUTP:TRACK:STAT?', int))

        if 'ON' in self.power_supply.on_off.to_api(on_off):
            #   switch off Coupling - error in Programming manual as implying 'CHANN' instead of 'CHAN'
            self.power_supply.write('OUTP:STAT:COUP:CHAN', 'NONE')

            if self.power_supply.log_scpi:
                log_string = f"Channel Coupling Disabled (cannot be used with Tracking)"
                if self.power_supply.simulated_inst:
                    log_string = 'simulated_inst: ' + log_string
                self.power_supply.log.info(log_string)

        self.power_supply.write('OUTP:TRACK:STAT', self.power_supply.on_off.to_inst(on_off))
        return


class PsuList(object):
    """
    |   Class for the LIST feature, to implement the methods required
    |
    |   Inherits attributes from the *'Channel'* class defined in this driver
    """
    ''' ### Pass in the Channel object and extract the required channel information '''

    def __init__(self, channel):
        """
        Pass in the channel object for the required channel information to be extracted for functionality

        :param channel: Tuple of the Power Supply Channel attributes 'power_supply, channel_name, channel_id, and
                        programming_bounds
        """

        self.power_supply = channel[0]          # power_supply
        self.channel_name = channel[1]          # channel_name
        self.channel_id = channel[2]            # channel_id
        self.programming_bounds = channel[3]    # programming_bounds

    def get_config(self):
        r"""
        |   **Description**
        |   Queries the contents of the LIST sequence/memory. To CLEAR the Memory, this needs to be
            manually done via the Front panel (or \*RST, but this will reset the unit to default
            settings).

        :return: list of contents for the LIST sequence/memory
        :rtype: dict

        ::

            Example

                E36313A.OUTPUT_CH<n>.LIST.get_config()
                        # will return {'TRIG': 'BUS, 'STEP': 'AUTO',
                        #              'COUNT':, '+1', 'LAST STEP', 'OFF',
                        #              '# POINTS': '+1',
                        #              'VOLT': [0.0],
                        #              'CURR': [0.001], or [0.002] for CH1
                        #              'DWELL': [0.01],
                        #              'BOST': [0],
                        #              'EOST': [0]}
        """

        dict_out = {}
        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        # Get the TRIG mode, i.e. method which will trigger the 'LIST' to run
        dict_out['TRIG'] = self.power_supply.query('TRIG:SOUR?', str).strip()
        # Get the STEP mode, i.e. Once or Auto
        dict_out['STEP'] = self.power_supply.query('SOUR:LIST:STEP?', str).strip()
        # Get the COUNT, i.e. num of iterations/cycles the 'LIST' will be repeated
        dict_out['COUNT'] = self.power_supply.query('SOUR:LIST:COUNT?', str).strip()
        # Get the ACTION that occurs when 'LIST' complete
        dict_out['LAST STEP'] = self.power_supply.on_off.to_api(self.power_supply.query('SOUR:LIST:TERM:LAST?', int))
        # Get number of points
        dict_out['NUM PTS'] = self.power_supply.query('SOUR:LIST:VOLT:POINTS?', str).strip()
        # Get the list of voltages
        # list comprehension
        # resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:VOLT?', str).split(',')]
        dict_out['VOLT'] = [float(elem) for elem in self.power_supply.query('SOUR:LIST:VOLT?', str).split(',')]
        # Get the list of currents
        # list comprehension
        # resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:CURR?', str).split(',')]
        dict_out['CURR'] = [float(elem) for elem in self.power_supply.query('SOUR:LIST:CURR?', str).split(',')]
        # Get the list of Dwell Times
        # list comprehension
        # resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:DWELL?', str).split(',')]
        dict_out['DWELL'] = [float(elem) for elem in self.power_supply.query('SOUR:LIST:DWELL?', str).split(',')]
        # Get the list of BOST settings
        # list comprehension
        # resp = [int(elem) for elem in self.power_supply.query('SOUR:LIST:TOUT:BOST?', str).split(',')]
        dict_out['BOST'] = [int(elem) for elem in self.power_supply.query('SOUR:LIST:TOUT:BOST?', str).split(',')]
        # Get the list of EOST settings
        # list comprehension
        # resp = [int(elem) for elem in self.power_supply.query('SOUR:LIST:TOUT:EOST??', str).split(',')]
        dict_out['EOST'] = [int(elem) for elem in self.power_supply.query('SOUR:LIST:TOUT:EOST??', str).split(',')]
        self.power_supply.log.info(f'To clear the Contents of the LIST memory, use front panel')
        return dict_out

    def set_properties(self, step='AUTO', count='MIN', laststep='ON'):
        """
        |   **Description**
        |   Configure the following 'LIST' properties: LIST:STEP, LIST:COUNT, and LIST:TERM:LAST
        |       To read the properties, use *'view_config()'* method.

        for each param, the 1st description is the API default

        :param step: Options are:

                        * 'AUTO' to run automatically transition through the LIST (Dwell)
                        * 'ONCE' to manually step through the LIST (trigger each step)
        :type step: str
        :param count: Number of times the list is executed

                        * 'MIN' = 1
                        * 'MAX' = 9999
                        * 1 <= any integer <= 9999
                        * 'INF' = continuous
        :type count: int (or str)
        :param laststep: Options are:

                        * 'ON' - output will retain settings from last step in 'LIST'
                        * 'OFF' - output will return to the settings defined by the **main** settings
        :type laststep: str
        :return: None
        :rtype:

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.LIST.set_properties(step='ONCE', count=2, laststep='OFF')
                        # 'Step' through list, two times and output returns to programmed
                        # settings before LIST was run

                2. E36313A.OUTPUT_CH<n>.LIST.set_properties(step='AUTO', count='MIN', laststep='ON')
                        # 'Automatically' transition through LIST, one time and output
                        # retains last setting in LIST
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if str(step).upper() in ['AUTO', 'ONCE']:
            self.power_supply.write('SOUR:LIST:STEP', step.upper())
        else:
            raise ValueError(f"Bad value {step.upper()} for LIST:STEP. Should be 'AUTO' or 'ONCE'.")

        if type(count) is str:
            if count.upper() in ['MIN', 'MAX', 'INF']:
                self.power_supply.write('SOUR:LIST:COUNT', count.upper())
            else:
                raise ValueError(
                    f"Bad value {str(count).upper()}. Should be 'MIN', 'MAX', 'INF' or 1 <= count <= 9999.")
        elif 1 <= int(count) <= 9999:
            self.power_supply.write('SOUR:LIST:COUNT', int(count))
        else:
            raise ValueError(f"Bad value {str(count).upper()}. Should be 'MIN', 'MAX', 'INF' or 1 <= count <= 9999.")

        if str(laststep).upper() in ['ON', 'OFF', '0', '1']:
            self.power_supply.write('SOUR:LIST:TERM:LAST', self.power_supply.on_off.to_inst(laststep))
        else:
            raise ValueError(f"Bad value {str(laststep).upper()}. Should be 'ON', 'OFF', '0', '1'.")

    def enable(self, volt_ena=None, curr_ena=None):
        """
        |   **Description**
        |   Query or set the Voltage and Current mode for the specified Channel. If setting, the mode
            will be set to either fixed or to track the LIST settings.
        |       Will basically set 'SOUR:VOLT LIST' or 'SOUR:VOLT FIXED'
        |                          'SOUR:CURR LIST' or 'SOUR:CURR FIXED'

        :param volt_ena: Options are:

                        * None/no argument will query the unit
                        * 'OFF' will disable the LIST mode, i.e. *'SOUR:VOLT FIXED'*.
                        * 'ON' will enable the LIST mode, i.e. *'SOUR:VOLT LIST'*
        :type volt_ena: str (or int)
        :param curr_ena: Options are:

                        * None/no argument will query the unit
                        * 'OFF' will disable the LIST mode, i.e. *'SOUR:VOLT FIXED'*.
                        * 'ON' will enable the LIST mode, i.e. *'SOUR:VOLT LIST'*
        :type curr_ena: str (or int)

        :return: returns the status of the *'SOUR:VOLT'* and *'SOUR:CURR'* settings
        :rtype: dict

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.LIST.enable()
                        # Will return the setting for SOUR:VOLT and SOUR:CURR

                2. E36313A.OUTPUT_CH<n>.LIST.enable('on')
                        # Will config SOUR:VOLT LIST ('OFF' will return unit to 'FIXED')
                        #             SOUR:CURR will remain unchanged

                3. E36313A.OUTPUT_CH<n>.LIST.enable('on', 'off')
                        # Will config SOUR:VOLT LIST ('OFF' will return unit to 'FIXED')
                        #             SOUR:CURR FIXED

                4. E36313A.OUTPUT_CH<n>.LIST.enable(curr_ena='off')
                        # Will config SOUR:VOLT will remain unchanged
                        #             SOUR:CURR FIXED
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if volt_ena is None and curr_ena is None:
            return {'volt_mode': self.power_supply.query('SOUR:VOLT:MODE?', str).strip(),
                    'curr_mode': self.power_supply.query('SOUR:CURR:MODE?', str).strip()}

        state_dict = {'OFF': 'FIXED', 'ON': 'LIST'}

        if volt_ena is not None:
            if self.power_supply.on_off.to_api(volt_ena) in ['ON', 'OFF']:
                self.power_supply.write('SOUR:VOLT:MODE', state_dict[self.power_supply.on_off.to_api(volt_ena)])
            else:
                raise ValueError(f"Bad value {volt_ena}. Should be either 'OFF', 'ON', 0 or 1.")

        if curr_ena is not None:
            if self.power_supply.on_off.to_api(curr_ena) in ['ON', 'OFF']:
                self.power_supply.write('SOUR:CURR:MODE', state_dict[self.power_supply.on_off.to_api(curr_ena)])
            else:
                raise ValueError(f"Bad value {curr_ena}. Should be either 'OFF', 'ON', 0 or 1.")

        return

    def run(self):
        r"""
        |   **Description**
        |   Run the LIST mode (currently only applicable when 'TRIG:SOUR' is 'BUS' or 'IMM').
        |
        |   Confirms TRIG mode, i.e. 'BUS' or 'IMM', then sends the BUS trigger sequence to unit, i.e.
        |       Send 'INIT:IMM'
        |       then '\*TRG' - only required if 'TRIG:SOUR' = 'BUS'
        |   
        |   Note: This will also be required if 'stepping' through the LIST.

        :return: None
        :rtype: 

        ::

            Example
                
                E36313A.OUTPUT_CH<n>.LIST.run()
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        ''' Confirm the number of elements for VOLT, CURR and DWELL match '''
        # self.tidy_up_list()

        self.power_supply.log.info(f'self.power_supply.query(\'TRIG:SOUR?\',str) = '
                                   f'{self.power_supply.query("TRIG:SOUR?", str)}')
        if 'BUS' in self.power_supply.query('TRIG:SOUR?', str):
            self.power_supply.write('INIT:IMM', '')
            # time.sleep(0.1)         # Delay added between the INITialise and TRiGger
            self.power_supply.write('*TRG', '')
            self.power_supply.write('*WAI', '')
        else:
            self.power_supply.write('INIT:IMM', '')

        return

    def tidy_up_list(self):
        """
        |   **Description**
        |   Queries the points that have been added to the LIST memory and determines if any padding
            is required.
        |       Note that BOST and EOST elements will not be checked.

        :return: None
        :rtype:
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        v_list = self.power_supply.query('SOUR:LIST:VOLT?').rstrip().split(',')
        max_size = {'VOLT': len(v_list)}
        c_list = self.power_supply.query('SOUR:LIST:CURR?').rstrip().split(',')
        max_size['CURR'] = len(c_list)
        dw_list = self.power_supply.query('SOUR:LIST:DWELL?').rstrip().split(',')
        max_size['DWELL'] = len(dw_list)

        if not (max_size['VOLT'] == max_size['CURR']) & (max_size['VOLT'] == max_size['DWELL']):

            if 'VOLT' not in max(max_size):
                if 1 < max_size['VOLT'] < max_size[max(max_size)]:
                    last_val = v_list[-1]
                    for i in range(max_size[max(max_size)]-max_size['VOLT']):
                        v_list.append(last_val)
                    self.voltage(v_list)

            if 'CURR' not in max(max_size):
                if 1 < max_size['CURR'] < max_size[max(max_size)]:
                    last_val = c_list[-1]
                    for i in range(max_size[max(max_size)]-max_size['CURR']):
                        c_list.append(last_val)
                    self.current(c_list)

            if 'DWELL' not in max(max_size):
                if 1 < max_size['DWELL'] < max_size[max(max_size)]:
                    last_val = dw_list[-1]
                    for i in range(max_size[max(max_size)]-max_size['DWELL']):
                        dw_list.append(last_val)
                    self.dwell(dw_list)

        return

    def voltage(self, voltages=None):
        """
        |   **Description**
        |   Query or set the voltages for each 'step' in the LIST sequence/memory.

        :param voltages: Limits are specific for the channel SPECIFIED.

                        Options are:

                            * None/no argument will query the unit
                            * Single value (same value for all points
                            * list(float) of voltages for each point.
        :type: list(float) (or single float)
        :return: If no argument passed, returns a list of voltages set for each step in the sequence.
        :rtype: list

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.LIST.voltage(1)
                        # apply 1V to all steps already defined

                2. E36313A.OUTPUT_CH<n>.LIST.voltage([1,1.1,0.5,3])
                        # apply the list defined above
                        # If list is smaller than the no of steps in memory, then the last value
                        # will be applied to any steps beyond the range of the list, i.e. 4 steps
                        # are defined in above list, but if there was 8 STEPS in the LIST,
                        # then steps 5-8 would have same value as last value in above list
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if voltages is None:
            # List comprehension
            resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:VOLT?', str).split(',')]
            return {'voltages': resp}

        if type(voltages) is int or type(voltages) is float:
            if self.programming_bounds.volts_min <= voltages <= self.programming_bounds.volts_max:
                self.power_supply.write('SOUR:LIST:VOLT', value=voltages)
            else:
                raise ValueError(f"Bad voltage {voltages} V for {self.power_supply.get_model()} {self.channel_name}, "
                                 f"should be {self.programming_bounds.volts_min} to "
                                 f"{self.programming_bounds.volts_max} V.")

            return

        if type(voltages) is not list:
            raise ValueError(f"Voltages should be entered as a List, "
                             f"i.e. [1.0, 1.2, 1.3], or as an 'int' or 'float.'")

        volt_str = ''
        for volt in voltages:
            if self.programming_bounds.volts_min <= float(volt) <= self.programming_bounds.volts_max:
                volt_str += f'{str(volt)}, '
            else:
                raise ValueError(f"Bad voltage {voltages} V for {self.power_supply.get_model()} {self.channel_name}, "
                                 f"should be {self.programming_bounds.volts_min} to "
                                 f"{self.programming_bounds.volts_max} V.")

        volt_str = volt_str.strip(', ')

        self.power_supply.write(f'SOUR:LIST:VOLT', value=volt_str)
        self.tidy_up_list()
        return

    def current(self, currents=None):
        """
        |   **Description**
        |   Query or set the currents for each 'step' in the LIST sequence/memory.

        :param currents: Limits are specific for the channel SPECIFIED.

                            Options are:

                            * None/no argument will query the unit
                            * Single value (same value for all points)
                            * list(float) of currents for each point.
        :type: list(float) (or single float)
        :return: If no argument passed, returns a list of currents set for each step in the sequence.
        :rtype: list

        ::

            Example:
                1. E36313A.OUTPUT_CH<n>.LIST.current(1)
                        # apply 1A to all steps already defined

                2. E36313A.OUTPUT_CH<n>.LIST.current([1,1.1,0.5,3])
                        # apply the list defined above
                        # If list is smaller than the no of steps in memory, then the last value
                        # will be applied to any steps beyond the range of the list, i.e. 4 steps
                        # are defined in above list, but if there was 8 STEPS in the LIST,
                        # then steps 5-8 would have same value as last value in above list
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if currents is None:
            # List comprehension
            resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:CURR?', str).split(',')]
            return {'currents': resp}

        if type(currents) is int or type(currents) is float:
            if self.programming_bounds.amps_min <= currents <= self.programming_bounds.amps_max:
                self.power_supply.write('SOUR:LIST:CURR', value=currents)
            else:
                raise ValueError(f"Bad current_limit {currents} A for {self.power_supply.get_model()} "
                                 f"{self.channel_name}, should be {self.programming_bounds.amps_min} to "
                                 f"{self.programming_bounds.amps_max} A.")
            return

        if type(currents) is not list:
            raise ValueError(f"Currents should be entered as a List, "
                             f"i.e. [1.0, 1.2, 1.3], or as an 'int' or 'float.'")

        curr_str = ''
        for curr in currents:
            if self.programming_bounds.amps_min <= float(curr) <= self.programming_bounds.amps_max:
                curr_str += f'{str(curr)}, '
            else:
                raise ValueError(f"Bad current_limit {currents} A for {self.power_supply.get_model()} "
                                 f"{self.channel_name}, should be {self.programming_bounds.amps_min} to "
                                 f"{self.programming_bounds.amps_max} A.")
        curr_str = curr_str.strip(', ')

        self.power_supply.write(f'SOUR:LIST:CURR', value=curr_str)
        self.tidy_up_list()
        return

    def dwell(self, dtimes=None):
        """
        |   **Description**
        |   Query or set the Dwell Time (in secs) for each 'step' in the LIST sequence/memory.

        :param dtimes: Range is 0.01s to 3600.000 with 1ms resolution. If < 0.01 entered, code will default to 0.01.

                            Options are:

                            * None/no argument will query the unit
                            * Single value (same value for all points)
                            * list(float) of dwell times for each point.
        :type: list(float) (or single float)
        :return: If no argument passed, returns a list of Dwell Times set for each step in the sequence.
        :rtype: list

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.LIST.dwell(1)
                        # apply 1s to all steps already defined

                2. E36313A.OUTPUT_CH<n>.LIST.dwell([1,1.1,0.5,3])
                        # apply the list defined above
                        # If list is smaller than the no of steps in memory, then the last value
                        # will be applied to any steps beyond the range of the list, i.e. 4 steps
                        # are defined in above list, but if there was 8 STEPS in the LIST,
                        # then steps 5-8 would have same value as last value in above list
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if dtimes is None:
            # List comprehension
            resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:DWELL?', str).split(',')]
            return {'dtimes': resp}

        if type(dtimes) is int or type(dtimes) is float:
            if dtimes < 0.01:
                self.power_supply.log.info(f"Bad Dwell Time {dtimes} applied - minimum of 0.01 has been applied.")
                dtimes = 0.01

            if 0.01 <= float(dtimes) <= 3600.0:
                self.power_supply.write('SOUR:LIST:DWELL', value=dtimes)
            else:
                raise ValueError(f"Bad Dwell Time {dtimes} applied! Should be in range 0.01 to 3600.0")
            return

        if type(dtimes) is not list:
            raise ValueError(f"Dwell Times should be entered as a List, "
                             f"i.e. [1.0, 1.2, 1.3], or as an 'int' or 'float.'")

        dtime_str = ''
        for dtime in dtimes:
            if float(dtime) < 0.01:
                self.power_supply.log.info(f"Bad Dwell Time {dtimes} applied - Minimum of 0.01 has been applied.")
                dtime = 0.01

            if 0.01 <= float(dtime) <= 3600.0:
                dtime_str += f'{str(dtime)}, '
            else:
                raise ValueError(f"Bad Dwell Time within {dtimes} applied! Should be in range 0.01 to 3600.0")

        dtime_str = dtime_str.strip(', ')

        self.power_supply.write(f'SOUR:LIST:DWELL', value=dtime_str)
        self.tidy_up_list()
        return

    def bost(self, bosts=None):
        """
        |   **Description**
        |   Query or set the BOST settings for each 'step' in the LIST sequence/memory.

        :param bosts: 0 or 1

                            Options are:

                            * None/no argument will query the unit
                            * Single value (same value for all points)
                            * list(int) of currents for each point.
        :type: list(int) (or single int)
        :return: If no argument passed, returns a list of BOST settings set for each step in the sequence.
        :rtype: list

        ::

            Example:
                1. E36313A.OUTPUT_CH<n>.LIST.bost(1)
                        # Enable trigger out for all steps already defined

                2. E36313A.OUTPUT_CH<n>.LIST.bost([1,0,1,0])
                        # apply the list defined above
                        # If list is smaller than the no of steps in memory, then the last value
                        # will be applied to any steps beyond the range of the list, i.e. 4 steps
                        # are defined in above list, but if there was 8 STEPS in the LIST,
                        # then steps 5-8 would have same value as last value in above list
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if bosts is None:
            # List comprehension
            resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:TOUT:BOST?', str).split(',')]
            return {'bosts': resp}

        if type(bosts) is int:
            if 0 <= bosts <= 1:
                self.power_supply.write('SOUR:LIST:TOUT:BOST', value=bosts)
            else:
                raise ValueError(f"Bad value {bosts} - should be either 0 or 1")
            return

        if type(bosts) is not list:
            raise ValueError(f"BOSTs should be entered as a List, "
                             f"i.e. [0, 0, 1, 0], or as an 'int.'")

        bost_str = ''
        for bost_elem in bosts:
            if 0 <= bost_elem <= 1:
                bost_str += f'{str(bost_elem)}, '
            else:
                raise ValueError(f"Bad value {bosts} - should be either 0 or 1")
        bost_str = bost_str.strip(', ')

        self.power_supply.write(f'SOUR:LIST:TOUT:BOST', value=bost_str)
        return

    def eost(self, eosts=None):
        """
        |   **Description**
        |   Query or set the EOST settings for each 'step' in the LIST sequence/memory.

        :param eosts: 0 or 1

                            Options are:

                            * None/no argument will query the unit
                            * Single value (same value for all points)
                            * list(int) of eost for each point.
        :type: list(int) (or single int)
        :return: If no argument passed, returns a list of EOST settings set for each step in the sequence.
        :rtype: list

        ::

            Example:
                1. E36313A.OUTPUT_CH<n>.LIST.eost(1)
                        # Enable trigger out for all steps already defined

                2. E36313A.OUTPUT_CH<n>.LIST.eost([1,0,1,0])
                        # apply the list defined above
                        # If list is smaller than the no of steps in memory, then the last value
                        # will be applied to any steps beyond the range of the list, i.e. 4 steps
                        # are defined in above list, but if there was 8 STEPS in the LIST,
                        # then steps 5-8 would have same value as last value in above list
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if eosts is None:
            # List comprehension
            resp = [float(elem) for elem in self.power_supply.query('SOUR:LIST:TOUT:EOST?', str).split(',')]
            return {'eosts': resp}

        if type(eosts) is int:
            if 0 <= eosts <= 1:
                self.power_supply.write('SOUR:LIST:TOUT:EOST', value=eosts)
            else:
                raise ValueError(f"Bad value {eosts} - should be either 0 or 1")
            return

        if type(eosts) is not list:
            raise ValueError(f"EOSTs should be entered as a List, "
                             f"i.e. [0, 0, 1, 0], or as an 'int.'")

        eost_str = ''
        for eost_elem in eosts:
            if 0 <= eost_elem <= 1:
                eost_str += f'{str(eost_elem)}, '
            else:
                raise ValueError(f"Bad value {eosts} - should be either 0 or 1")
        eost_str = eost_str.strip(', ')

        self.power_supply.write(f'SOUR:LIST:TOUT:EOST', value=eost_str)
        return

    def load_from_csv(self, filepath, rowstart=0):
        """
        |   **Description**
        |   Load 'LIST' from file, i.e. .csv.
        |       Col_1 = voltages, Col_2 = currents, Col_3 = Dwell Times
        |       optional columns: Col_4 = BOST, Col_5 = EOST

        :param filepath: Full path to to .csv to be loaded to LIST, e.g.
                         '*C:\\\\validation\\\\projects\\\\ProjName\\\\PSU\\\\TypSupply.csv*'
        :type filepath: str
        :param rowstart: Default is 0. Row at which to start parsing data, e.g. does file have header row(s).
        :type rowstart: int
        :return: None
        :rtype:

        ::

            Example:
                
                1. E36313A.OUTPUT_CH<n>.LIST.load_from_csv(r'C:\\validation\\projects\\ProjName\\PSU\\TypSupply.csv')
                        # This will read 'C:\\validation\\projects\\ProjName\\PSU\\TypSupply.csv'
                        # and update the LIST with contents of file (from row 0).

                2. E36313A.OUTPUT_CH<n>.LIST.load_from_csv(r'C:\\validation\\projects\\ProjName\\PSU\\TypSupply.csv', 1)
                        # This will read 'C:\\validation\\projects\\ProjName\\PSU\\TypSupply.csv'
                        # and update the LIST with contents of file from row 1 (skip row 0, i.e. could be a header).
        """

        try:
            with open(filepath) as fhndle:
                contents = fhndle.readlines()
        except FileNotFoundError as err:
            raise FileNotFoundError(f'Error in {filepath}: {err}.')
        else:
            volts = []
            currs = []
            dtimes = []
            bosts = []
            eosts = []
            for row, line in enumerate(contents):
                if row >= rowstart:
                    tmp_list = line.strip().split(',')
                    volts.append(tmp_list[0].strip())
                    currs.append(tmp_list[1].strip())
                    dtimes.append(tmp_list[2].strip())
                    if len(tmp_list) >= 4:
                        bosts.append(tmp_list[3].strip())
                    else:
                        bosts.append(0)

                    if len(tmp_list) >= 5:
                        eosts.append(tmp_list[4].strip())
                    else:
                        eosts.append(0)

            # print(f'V: {volts}')
            # print(f'C: {currs}')
            # print(f'D: {dtimes}')
            # print(f'B: {bosts} - {[int(elem) for elem in bosts]}')
            # print(f'E: {eosts}')

            self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

            ''' Data is extracted from file as lists of strings: using List Comprehension to convert to correct type '''
            self.voltage([float(elem) for elem in volts])
            self.current([float(elem) for elem in currs])
            self.dwell([float(elem) for elem in dtimes])
            ''' ### Need to convert the last two lists into a string (No API/method for the entering BOST/EOST) '''
            # self.power_supply.write(f'SOUR:LIST:TOUT:BOST', str([int(elem) for elem in bosts]).strip('[]'))
            # self.power_supply.write(f'SOUR:LIST:TOUT:EOST', str([int(elem) for elem in eosts]).strip('[]'))
            self.bost([int(elem) for elem in bosts])
            self.eost([int(elem) for elem in eosts])


class PsuSense(object):
    """
    |   Class for the Sense Mode, to implement the methods required
    |
    |   Inherits attributes from the *'Channel'* class defined in this driver
    """
    ''' ### Pass in the Channel object and extract the required channel information '''

    def __init__(self, channel):
        """
        Pass in the channel object for the required channel information to be extracted for functionality

        :param channel: Tuple of the Power Supply Channel attributes 'power_supply, channel_name, channel_id, and
                        programming_bounds
        """

        self.power_supply = channel[0]          # power_supply
        self.channel_name = channel[1]          # channel_name
        self.channel_id = channel[2]            # channel_id
        self.programming_bounds = channel[3]    # programming_bounds

    def fourwire(self, on_off=None):
        """
        |   **Description**
        |   Query or set the 4-wire sense mode for the channel specified.
        |       Note that the Sense Connections are at the rear of the unit.

        :param on_off: either 'ON', 'OFF', 0, 1
        :type on_off: str
        :return: if None/no arguments entered, will return the status of the 4W Sense mode for the
                 channel specified

                 * 'OFF' = 'INT' (internally sensed)
                 * 'ON'  = 'EXT' (externally sensed)
        :rtype: str

        ::

            Example:

                1. E36313A.OUTPUT_CH<n>.SENSE.fourwire()
                        # Will return the status of the 4-wire sense for the channel specified

                2. E36313A.OUTPUT_CH<n>.SENSE.fourwire('ON')
                        # This will enable 4-wire sense for the channel specified
        """

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)

        if on_off is None:
            return {'INT': 'OFF', 'EXT': 'ON'}[self.power_supply.query('SOUR:VOLT:SENS?', str).strip()]

        self.power_supply.write('SOUR:VOLT:SENS',
                                value={'ON': 'EXT', 'OFF': 'INT'}[self.power_supply.on_off.to_api(on_off)])
        return


def self_test(psu):
    """
        **Example Code**
        Test code for the driver
    """
    # imports specific to the self test
    import time
    import pprint

    psu.debug_options(log_scpi=False, inst_error_handling='LOG_ALWAYS')
    # return state of output (note that this will return state of ALL outputs
    print(f'ID string should contain {psu.get_model()}')
    print(f'    psu.get_idn() = {psu.get_idn()}')
    print(f'Resetting unit to default state')
    print(f'    psu.reset - {psu.reset()}')

    print(f'\n{"*" * 6} Output Enables {"*" * 6}')
    print(f'    Global - Check state of all outputs - all should report OFF')
    print(f'            psu.output_state() = {psu.output_state()}')
    print(f'    Global - Enable all outputs - all should report \'ON\' when queried')
    print(f'            psu.output_state(\'ON\') = {psu.output_state("ON")}; '
          f'Query-> {psu.output_state()}\n')
    print(f'    Global - Disable all outputs - all should report \'OFF\' when queried')
    print(f'            psu.output_state(\'OFF\') = {psu.output_state("OFF")}; '
          f'Query-> {psu.output_state()}\n')
    print(f'    Channel - Sequence: CH1 \'ON\', CH3 \'ON\', CH3 \'OFF\', CH2 \'ON\'')
    print(f'            psu.output_state() = {psu.output_state()}')
    print(f'            psu.OUTPUT_CH1.output_state(\'ON\') = '
          f'{psu.OUTPUT_CH1.output_state("ON")};'
          f' Query-> {psu.OUTPUT_CH1.output_state()}')
    print(f'            Global Query-> {psu.output_state()}\n')
    print(f'            psu.OUTPUT_CH3.output_state(\'ON\') = {psu.OUTPUT_CH3.output_state("ON")};'
          f' Query-> {psu.OUTPUT_CH3.output_state()}')
    print(f'            Global Query-> {psu.output_state()}\n')
    print(f'            psu.OUTPUT_CH3.output_state(\'OFF\') = {psu.OUTPUT_CH3.output_state("OFF")};'
          f' Query-> {psu.OUTPUT_CH3.output_state()}')
    print(f'            Global Query-> {psu.output_state()}\n')
    print(f'            psu.OUTPUT_CH2.output_state(\'ON\') = {psu.OUTPUT_CH2.output_state("ON")};'
          f' Query-> {psu.OUTPUT_CH2.output_state()}')
    print(f'            Global Query-> {psu.output_state()}\n')

    print(f'\n{"*" * 6} Trigger Source {"*" * 6}')
    print(f'    Global - Check Trigger Source for all outputs - all should report \'BUS\'')
    print(f'            psu.trigger_source() = {psu.trigger_source()}')
    print(f'    Global - Trigger Source = \'IMMediate\' for all outputs - all should report \'IMM\'')
    print(f'            psu.output_state(\'IMM\') = {psu.trigger_source("IMM")};'
          f' Query-> {psu.trigger_source()}')
    print(f'    Global - Trigger Source = \'BUS\' for all outputs - all should report \'BUS\'')
    print(f'            psu.output_state(\'BUS\') = {psu.trigger_source("BUS")};'
          f' Query-> {psu.trigger_source()}')
    print(f'\n    Channel - Sequence: CH1 \'IMM\', CH3 \'EXT\', CH2 \'PIN2\'')
    print(f'            psu.OUTPUT_CH1.trigger_source(\'IMM\') = {psu.OUTPUT_CH1.trigger_source("IMM")};'
          f' Query-> {psu.OUTPUT_CH1.trigger_source()}')
    print(f'            Global Query-> {psu.trigger_source()}')
    print(f'\n            psu.OUTPUT_CH3.trigger_source(\'EXT\') = {psu.OUTPUT_CH3.trigger_source("EXT")};'
          f' Query-> {psu.OUTPUT_CH3.trigger_source()}')
    print(f'            Global Query-> {psu.trigger_source()}')
    print(f'\n            psu.OUTPUT_CH2.trigger_source(\'PIN2\') = {psu.OUTPUT_CH2.trigger_source("PIN2")};'
          f' Query-> {psu.OUTPUT_CH2.trigger_source()}')
    print(f'            Global Query-> {psu.trigger_source()}')
    print(f'\n            Revert back to BUS')
    print(f'            psu.output_state(\'BUS\') = {psu.trigger_source("BUS")};'
          f' Query-> {psu.trigger_source()}')

    print(f'\n{"*" * 6} COUPLE {"*" * 6}')
    print(f'    Check COUPLE configuration - should report \'NONE\'')
    print(f'            psu.couple() = {psu.couple()}')
    print(f'    Couple CH1 & CH3 - all should report \'CH1, CH3\'')
    print(f'            psu.couple(\'ON\', [1,3]) = {psu.couple("ON", [1, 3])}; Query-> {psu.couple()}')
    print(f'            *Note: if \'channels\' is empty/None, then ValueError is raised')
    print(f'    Couple Mode in action')
    print(f'            psu.output_state(\'OFF\') = {psu.output_state("OFF")}; '
          f'Query-> {psu.output_state()}')
    print(f'    All Outputs should be disabled - now enable CH3')
    print(f'            psu.OUTPUT_CH3.output_state(\'ON\') = {psu.OUTPUT_CH3.output_state("ON")};'
          f' Query-> {psu.output_state()}')
    print(f'    CH1 & CH3 should report enabled - now disable CH1')
    print(f'            psu.OUTPUT_CH1.output_state(\'OFF\') = {psu.OUTPUT_CH1.output_state("OFF")};'
          f' Query-> {psu.output_state()}')
    print(f'    CH1 & CH3 should report disabled')
    print(f'    Disable coupling - Should now report None')
    print(f'            psu.couple(\'OFF\') = {psu.couple("OFF")}; Query {psu.couple()}')

    print(f'\n{"*" * 6} Source Voltage {"*" * 6}')
    print(f'    Query CH1 settings - should report \'0V, {round(psu.OUTPUT_CH1.programming_bounds.amps_max, 0)}A\'')
    print(f'            psu.OUTPUT_CH1.source_voltage() = {psu.OUTPUT_CH1.source_voltage()}')
    print(f'    Config CH1 - 1.0V, 0.5A - should report same when queried')
    print(f'            psu.OUTPUT_CH1.source_voltage(1.0, 0.5) = '
          f'{psu.OUTPUT_CH1.source_voltage(1.0, 0.5)}; Query-> {psu.OUTPUT_CH1.source_voltage()}')
    print(f'    Config CH2 - 15.0V, 0.95A - should report same when queried')
    # MOD for 36312
    print(f'            psu.OUTPUT_CH2.source_voltage(15.0, 0.95) = '
          f'{psu.OUTPUT_CH2.source_voltage(15.0, 0.95)}; Query-> {psu.OUTPUT_CH2.source_voltage()}')  # 0.95

    print(f'\n{"*" * 6} SAVE/RECALL {"*" * 6}')
    print(f'    Save above settings to location 0')
    print(f'            psu.save_config(0) = {psu.save_config(0)}')
    print(f'    Recall location 9')
    print(f'            psu.recall_config(9) = {psu.recall_config(9)}')
    print(f'    Query channel settings - should be at default if unit not has not been programmed')
    print(f'            psu.OUTPUT_CH1.source_voltage() = {psu.OUTPUT_CH1.source_voltage()}')
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')
    print(f'    Recall location 0')
    print(f'            psu.recall_config(0) = {psu.recall_config(0)}')
    print(f'    Query channel settings - should be programmed with CH1: 1.0V, 0.5A & CH2: 15V, 0.95A')
    print(f'            psu.OUTPUT_CH1.source_voltage() = {psu.OUTPUT_CH1.source_voltage()}')
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')

    print(f'\n{"*" * 6} Measure Voltage/Current {"*" * 6}')
    print(f'    pre-config unit')
    print(f'    Config CH1 - 1.0V, 0.5A, CH2 - 15.0V, 0.95A')

    print(f'    Enable CH1 and CH2')
    print(f'            psu.output_state() = {psu.output_state()}')
    print(f'            psu.OUTPUT_CH1.output_state(\'ON\') = {psu.OUTPUT_CH1.output_state("ON")};'
          f' Query-> {psu.OUTPUT_CH1.output_state()}')
    print(f'            Global Query-> {psu.output_state()}')
    print(f'            psu.OUTPUT_CH2.output_state(\'ON\') = {psu.OUTPUT_CH2.output_state("ON")};'
          f' Query-> {psu.OUTPUT_CH2.output_state()}')
    print(f'            Global Query-> {psu.output_state()}')
    print(f'    Measure CH1 voltage - 1.0V')
    print(f'            psu.OUTPUT_CH1.measure_voltage() = {psu.OUTPUT_CH1.measure_voltage()}')
    print(f'    Measure CH2 current - should be near 0A if no load')
    print(f'            psu.OUTPUT_CH3.measure_current() = {psu.OUTPUT_CH3.measure_current()}')
    print(f'    Disable Outputs')
    print(f'            psu.output_state(\'OFF\') = {psu.output_state("OFF")}')

    print(f'\n{"*" * 6} Delay {"*" * 6}')
    print(f'    Query delays configure - note delays are rounded DOWN to nearest second')
    print(f'            psu.OUTPUT_CH1.delay.get_delays() = {psu.OUTPUT_CH1.delay.get_delays()}')
    print(f'    Set delays')
    print(f'            psu.OUTPUT_CH1.delay.set_delays(1.0, 2.0) = '
          f'{psu.OUTPUT_CH1.delay.set_delays(1.0, 2.0)}')
    print(f'            psu.OUTPUT_CH2.delay.set_delays(3.0, 4.0) = '
          f'{psu.OUTPUT_CH2.delay.set_delays(3.0, 4.0)}')
    print(f'            ** psu.OUTPUT_CH1.delay.get_delays() = {psu.OUTPUT_CH1.delay.get_delays()}')
    print(f'            ** psu.OUTPUT_CH2.delay.get_delays() = {psu.OUTPUT_CH2.delay.get_delays()}')

    print(f'\n{"*" * 6} Sense {"*" * 6}')
    print(f'    Query Sense configuration')
    print(f'            psu.OUTPUT_CH1.sense.fourwire() = {psu.OUTPUT_CH1.sense.fourwire()}')
    print(f'    Set delays')
    print(f'            psu.OUTPUT_CH1.sense.fourwire(\'ON\') = {psu.OUTPUT_CH1.sense.fourwire("ON")}; '
          f' Query-> {psu.OUTPUT_CH1.sense.fourwire()}')
    print(f'            psu.OUTPUT_CH1.sense.fourwire(\'OFF\') = {psu.OUTPUT_CH1.sense.fourwire("OFF")}; '
          f' Query-> {psu.OUTPUT_CH1.sense.fourwire()}')

    print(f'\n{"*" * 6} TRACK feature {"*" * 6}')
    print(f'    Check TRACK configuration (only for CH2 & CH3)')
    print(f'        psu.OUTPUT_CH2.track.state() = {psu.OUTPUT_CH2.track.state()}')
    print(f'    Enable TRACK mode - can enable via CH2 or CH3')
    print(f'            psu.OUTPUT_CH2.track.state(\'ON\') = {psu.OUTPUT_CH2.track.state("ON")}; '
          f'Query-> {psu.OUTPUT_CH2.track.state()}')
    print(f'            psu.OUTPUT_CH3.track.state(\'OFF\') = {psu.OUTPUT_CH3.track.state("OFF")}; '
          f'Query-> {psu.OUTPUT_CH3.track.state()}')
    print(f'    TRACK Mode in action')
    # MOD for 36312
    print(f'        psu.OUTPUT_CH2.source_voltage(15.0, 1) = {psu.OUTPUT_CH2.source_voltage(15.0, 1)}')  # 1.25
    print(f'        psu.OUTPUT_CH3.source_voltage(12.0, 1) = {psu.OUTPUT_CH3.source_voltage(12.0, 1)}')  # 1.25
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')
    print(f'            psu.OUTPUT_CH3.source_voltage() = {psu.OUTPUT_CH3.source_voltage()}')
    print(f'    TRACK Mode enabled')
    print(f'        psu.OUTPUT_CH3.track.state(\'ON\') = {psu.OUTPUT_CH3.track.state("ON")}')
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')
    print(f'            psu.OUTPUT_CH3.source_voltage() = {psu.OUTPUT_CH3.source_voltage()}')
    print(f'            *Note: only changing voltage this time')
    print(f'        psu.OUTPUT_CH3.source_voltage(9.0) = {psu.OUTPUT_CH3.source_voltage(9.0)}')
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')
    print(f'            psu.OUTPUT_CH3.source_voltage() = {psu.OUTPUT_CH3.source_voltage()}')
    print(f'        psu.OUTPUT_CH2.source_voltage(13.0) = {psu.OUTPUT_CH2.source_voltage(13.0)}')
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')
    print(f'            psu.OUTPUT_CH3.source_voltage() = {psu.OUTPUT_CH3.source_voltage()}')
    print(f'    TRACK Mode disabled')
    print(f'        psu.OUTPUT_CH2.track.state(\'OFF\') = {psu.OUTPUT_CH2.track.state("OFF")}')
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')
    print(f'            psu.OUTPUT_CH3.source_voltage() = {psu.OUTPUT_CH3.source_voltage()}')
    print(f'        psu.OUTPUT_CH3.source_voltage(0.0) = {psu.OUTPUT_CH3.source_voltage(0.0)}')
    print(f'            psu.OUTPUT_CH2.source_voltage() = {psu.OUTPUT_CH2.source_voltage()}')
    print(f'            psu.OUTPUT_CH3.source_voltage() = {psu.OUTPUT_CH3.source_voltage()}')
    print(f'        psu.OUTPUT_CH2.source_voltage(15.0) = {psu.OUTPUT_CH3.source_voltage(15.0)}')

    print(f'\n{"*" * 6} LIST feature {"*" * 6}')
    print(f'    LIST Mode in action')
    print(f'        psu.OUTPUT_CH3.LIST.get_config()')
    print(f'            {psu.OUTPUT_CH3.LIST.get_config()}')
    print(f'        psu.OUTPUT_CH3.LIST.set_properties(step=\'ONCE\', count=5, laststep=\'OFF\')')
    psu.OUTPUT_CH3.LIST.set_properties(step='ONCE', count=5, laststep='OFF')
    print(f'        psu.OUTPUT_CH3.LIST.get_config()')
    print(f'        psu.OUTPUT_CH3.LIST.set_properties(step=\'AUTO\', count=1, laststep=\'ON\')')
    psu.OUTPUT_CH3.LIST.set_properties(step='AUTO', count=1, laststep='ON')
    print(f'    Query state')
    print(f'        psu.OUTPUT_CH3.LIST.enable() = {psu.OUTPUT_CH3.LIST.enable()}')
    print(f'    Enter \'sequence\' to the LIST memory')
    print(f'        psu.OUTPUT_CH3.LIST.voltage([0,1,2,3,4,5,0]) = '
          f'{psu.OUTPUT_CH3.LIST.voltage([0, 1, 2, 3, 4, 5, 0])}')
    print(f'        psu.OUTPUT_CH3.LIST.voltage() = {psu.OUTPUT_CH3.LIST.voltage()}')
    print(f'        psu.OUTPUT_CH3.LIST.current([0.2,0.3,0.4]) = '
          f'{psu.OUTPUT_CH3.LIST.current([0.2, 0.3, 0.4])}')
    print(f'        psu.OUTPUT_CH3.LIST.current() = {psu.OUTPUT_CH3.LIST.current()}')
    print(f'        psu.OUTPUT_CH3.LIST.dwell([1,2,1,3]) = '
          f'{psu.OUTPUT_CH3.LIST.dwell([0.1, 0.2, 0.1, 0.3])}')
    print(f'        psu.OUTPUT_CH3.LIST.dwell() = {psu.OUTPUT_CH3.LIST.dwell()}')
    print(f'        psu.OUTPUT_CH3.LIST.bost() = {psu.OUTPUT_CH3.LIST.bost()}')
    print(f'        psu.OUTPUT_CH3.LIST.eost() = {psu.OUTPUT_CH3.LIST.eost()}')
    print(f'        psu.OUTPUT_CH3.LIST.get_config()')
    pprint.pprint(psu.OUTPUT_CH3.LIST.get_config(), indent=12)
    print(f'        *NOTE: for the currents and dwell times, the last value in list entered has been repeated ')
    print(f'    Enable LIST')
    print(f'        psu.OUTPUT_CH3.LIST.enable(\'ON\') = {psu.OUTPUT_CH3.LIST.enable("ON")}; '
          f' Query-> {psu.OUTPUT_CH3.LIST.enable()}')
    print(f'    Enable the Output so the LIST can run')
    print(f'        psu.OUTPUT_CH3.output_state(\'ON\') = {psu.OUTPUT_CH3.output_state("ON")}')
    print(f'        psu.OUTPUT_CH3.LIST.run() = {psu.OUTPUT_CH3.LIST.run()}')
    time.sleep(3)
    print(f'        psu.OUTPUT_CH3.LIST.enable(\'OFF\') = {psu.OUTPUT_CH3.LIST.enable("OFF")}; '
          f' Query-> {psu.OUTPUT_CH3.LIST.enable()}')

    print(f'        psu.OUTPUT_CH3.LIST.get_config()')
    pprint.pprint(psu.OUTPUT_CH3.LIST.get_config(), indent=12)
    print()
    print(f'    Clearing contents of location 0 - code not being displayed')
    print(f'\nResidual Errors: {psu.get_inst_errors()}\n')
    psu.reset()
    psu.save_config(0)
    print(f'    Location 0 reset to default\n\n')
