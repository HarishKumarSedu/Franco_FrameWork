# -----------------------------------------------------------


def check_list_num(name, values, min_val, max_val, units, show_max_bad=10, types=(int, float)):
    """
    Check an entire list of int or float elements and create error message describing which elements are out of bounds.

    :param name: Name of list parameter
    :type name: str
    :param values: list parameter
    :type values: list[float]
    :param min_val: a minimum value to be checked against the list values
    :type min_val: int | float
    :param max_val: a minimum value to be checked against the list values
    :type max_val: int | float
    :param units: SI units of the values, used for error printing.
    :type units: str
    :param show_max_bad: Maximum amount of errors printed.
    :type show_max_bad: int
    :return: if there are bad elements in the list, the method will raise a ValueError.
    :rtype: None
    """
    bad_indices = [index for index, value in enumerate(values)
                   if not(isinstance(value, types) and min_val <= value <= max_val)]

    num_bad = len(bad_indices)
    if num_bad <= 0:  # if no bad indices were found then the check has passed and we can return.
        return None

    show_bad = min(num_bad, show_max_bad)
    msg = f"{name} contains {num_bad} values outside range {min_val} to {max_val} {units}. "
    msg += f"The first {show_bad} are:\n" if num_bad > show_bad else "They are:\n"
    msg += ",\n".join([f"    {name}[{bad_indices[i]}]={values[bad_indices[i]]}" for i in range(show_bad)])
    raise ValueError(msg)


def check_list_on_off(name, values, acceptable_values=('OFF', False, 0, '0', 'ON', True, 1, '1'), show_max_bad=10):
    """
    Check an entire list of on_off elements and create error message describing which elements are out of bounds.

    :param name: Name of list parameter
    :type name: str
    :param values: list parameter
    :type values: list[float]
    :param acceptable_values: List or tuple of acceptable values to check the list of elements against. defaults to
        on_off.api_values() = ('OFF', False, 0, '0', 'ON', True, 1, '1')
    :type acceptable_values: list | tuple
    :param show_max_bad: Maximum amount of errors printed.
    :type show_max_bad: int
    :return: if there are bad elements in the list, the method will raise a ValueError.
    :rtype: None
    """

    bad_indices = [index for index, element in enumerate(values) if element not in acceptable_values]
    num_bad = len(bad_indices)

    if num_bad <= 0:  # if no bad indices were found then the check has passed and we can return.
        return None

    show_bad = min(num_bad, show_max_bad)
    msg = f"{name} contains {num_bad} values that are not within the accepable values {acceptable_values}. "
    msg += f"The first {show_bad} are:\n" if num_bad > show_bad else "They are:\n"
    msg += ",\n".join([f"    {name}[{bad_indices[i]}]={values[bad_indices[i]]}" for i in range(show_bad)])
    raise ValueError(msg)


# -----------------------------------------------------------
