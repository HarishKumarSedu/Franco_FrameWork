from operator import itemgetter
from math import isclose
from collections import namedtuple
from pprint import pprint
import warnings

min_max = namedtuple('min_max', ['min', 'max'])


class InstrumentRanges:
    """
    Objects of this class contain the selectable ranges of some instrument parameter and provide useful operations
    related to programming a range or its associated parameter. For example, the current_limit_ranges and the
    current_limit of an SMU.
    """

    def __init__(self, parameter_name, parameter_units, min_max_pairs, has_auto=True, rel_tol=0.001,
                 bipolar_values=False):
        """

        :param parameter_name: A string naming the instrument parameter that the ranges are associated with. This is
            used in the generation of warning and error messages.
        :type parameter_name: str
        :param parameter_units: A string describing the parameter units, for example 'V' or 'A' or 'Ohms'. This is
            used in the generation of warning and error messages.
        :type parameter_units: str
        :param min_max_pairs: A list of all the ranges where each range consists of an instance of the namedtuple
            max_min which defines the minimum and maximum value for each range. Note that each of the max values also
            serve to identify a particular instrument range. The list does not have to be in any specific order.
        :type min_max_pairs: List[max_min(float, float)]
        :param has_auto: Set to True if instrument supports auto-ranging, this will cause 'AUTO' to be considered as
             an instrument range.
        :type has_auto: bool
        :param rel_tol: Relative tolerance for determining if a range value matches one of the defined ranges in the
            method get_min_for_range. Default is 0.001 which corresponds to within +/- 0.1%.
        :type rel_tol: float
        :param bipolar_values: If True, the methods that compare a parameter value to the ranges perform an absolute
            value operation on the value before comparing to ranges. This allows for ranges that are programmed as
            positive numbers, yet the allowed values are symmetric around 0. For example, on the PXIe-4139 SMU,
            voltage_level and voltage_level_range. If False, the supplied value is compared directly to the ranges.
            On the 4139: current_limit (always positive) and the current_limit_ranges (also always positive).
        :type bipolar_values: bool
        """

        self.parameter_name = parameter_name
        self.parameter_units = parameter_units
        self.has_auto = has_auto
        self.rel_tol = rel_tol
        self.bipolar_values = bipolar_values

        # Put the ranges into ascending order by the max field of each namedtuple. This is essential for searching used
        # in methods to work properly.
        self.min_max_pairs = tuple(sorted(min_max_pairs, key=itemgetter(1)))

        # Split into separate lists.
        max_values = []
        for pair in self.min_max_pairs:
            max_values.append(pair.max)
        self.max_values = max_values

        duplicates = len(self.max_values) - len(set(self.max_values))
        if duplicates:
            raise ValueError(f"Bad min_max_pairs, the list contains elements with identical values in their 'max' "
                             f"fields. The max fields must be unique because they serve to identify each range.")

        min_values = []
        for pair in self.min_max_pairs:
            min_values.append(pair.min)
        self.min_values = min_values

    def get_ranges(self):
        """
        Returns list of values that identify a range.

        :return: List includes 'AUTO' if instrument supports auto-ranging, followed by floats which are the max
            values allowed by the defined ranges.
        :rtype: List[str|float]
        """

        return_value = []
        if self.has_auto:
            return_value = ['AUTO']
        return_value.extend(self.max_values)
        return return_value

    def get_highest_range(self):
        """Return the highest max value found in all the ranges. This identifies the highest range."""

        return self.max_values[len(self.max_values)-1]

    def get_lowest_range(self):
        """Return the lowest max value found in all the ranges. This identifies the lowest range."""
        return self.max_values[0]

    def coerced_range(self, requested_range):
        """
        Returns a valid instrument range that is at least equal to requested range.

        Return value is requested_range when it exactly matches and thereby identifies a particular defined range.
        If a requested_range value is between two defined ranges, that may be intentional on the users part, or it
        may be a floating point representation issue. There is no way to determine which, so to avoid instrument over
        range errors, we use the next higher range.

        :param requested_range: A floating point value to compare against the max values of the defined ranges. If the
            instrument supports auto-ranging, the string 'AUTO' may also be used.
        :type requested_range: float|str
        :return: If requested_range was a float, return is either a float representing a valid instrument range or None
            when requested_range exceeds the largest available range. If requested range is 'AUTO', then return is
            'AUTO'.
        :rtype: float|str|None
        """

        if isinstance(requested_range, str):
            if self.has_auto and requested_range == 'AUTO':
                return 'AUTO'
        else:
            # Either return requested_range when it exactly matches a defined range or round up to next defined range.
            index = self._find_index_above(requested_range, self.max_values)
            if index is not None:
                coerced = self.max_values[index]
                if coerced > requested_range:
                    warnings.warn(f"Requested {self.parameter_name}_range {requested_range} {self.parameter_units} "
                                  f"is not an exact match to a valid range.\n"
                                  f"Coercing to range {coerced} {self.parameter_units}. "
                                  f"To avoid this, use one of the exact values {self.get_ranges()}.")
                return coerced

        raise ValueError(f"Bad {self.parameter_name}_range {requested_range}  {self.parameter_units}, "
                         f"should be one of {self.get_ranges()}.")

    def get_optimal_range(self, value):
        """
        Returns float value of the smallest range that is larger than value. This is the range that would provide the
        best resolution while accommodating value and is typically the range that the instrument auto-range feature
        would pick if enabled.

        :param value: Value you want to program for the parameter. If attribute bipolar_values is False, this value is
            compared to the ranges to select an applicable range.  If bipolar_values is True, then abs(value) is compared
            to the ranges.
        :type value: float
        :return: The maximum value the recommended range can output. Will be None if value exceeds the largest range.
        :rtype: float|None
        """

        if self.bipolar_values:
            value = abs(value)

        index = self._find_index_above(value, self.max_values)
        if index is not None:
            return self.max_values[index]
        return None

    def is_value_in_range(self, value, range_id):
        """
        Returns True if value is within range, False otherwise.

        :param value: A value for the instrument parameter to be checked against the range whose max value is range_id.
            If attribute bipolar_values is False, this value is compared to the ranges to select an applicable range.
            If bipolar_values is True, then abs(value) is compared to the range.
        :type value: float
        :param range_id: float value corresponding to the max value of one of the defined ranges or, if attribute
            has_auto is True, it may also be the str 'AUTO'.
        :type range_id: str|float
        """

        range_min, range_max = self.get_range_bounds(range_id)

        if self.bipolar_values:
            value = abs(value)

        return range_min <= value <= range_max

    def error_on_out_of_range(self, value, range_id):
        """
        Raises ValueError if value is outside range, otherwise does nothing.

        :param value: A value for the instrument parameter to be checked against the range whose max value is range_id.
            If attribute bipolar_values is False, this value is compared to the ranges to select an applicable range.
            If bipolar_values is True, then abs(value) is compared to the range. Note that this allows for values from
            -range_max to +range_max.
        :type value: float
        :param range_id: float value corresponding to the max value of one of the defined ranges or, if attribute
            has_auto is True, it may also be the str 'AUTO'.
        :type range_id: str|float
        """

        range_min, range_max = self.get_range_bounds(range_id)

        if self.bipolar_values:
            if not(range_min <= abs(value) <= range_max):
                if range_min == 0.0:  # range_min is hardcoded 0.0 so should not be a floating point comparison issue.
                    # Case of range is set with positive numbers, symmetric reflected around 0 and include 0.
                    raise ValueError(f"Bad {self.parameter_name}: {value} {self.parameter_units}, should be "
                                     f"{-1.0*range_max} to {range_max} for {self.parameter_name}_range={range_id}.")
                else:
                    # Case of range is set with positive numbers, but values are limited to ranges on either side of 0
                    # which don't include 0.
                    raise ValueError(f"Bad {self.parameter_name}: {value} {self.parameter_units}, should be either "
                                     f"{-1.0*range_max} to {-1.0*range_min} or {range_min} to {range_max} "
                                     f"for {self.parameter_name}_range={range_id}.")
        else:
            if not (range_min <= value <= range_max):
                raise ValueError(f"Bad {self.parameter_name}: {value} {self.parameter_units}, should be "
                                 f"{range_min} to {range_max} for {self.parameter_name}_range={range_id}.")

    def get_min_for_range(self, range_id):
        """
        Returns the minimum value allowed for the range whose maximum value is range_id or, if
        auto-ranging is supported, the minimum value for the lowest defined range.

        Note that range_id is intended to be an exact match for one of the defined ranges. However, since range_id is
        likely to come from the instrument itself rather than a hardcoded float value, the rel_tol attribute is used
        with the math.isclose function to do the matching.

        :param range_id: Numeric value matching (within rel_tol) the max value of one of the instrument ranges or,
            if the instrument provides auto-ranging, the string 'AUTO'.
        :type range_id: str|float
        :return: The min value allowed with the specified range or, if range_id is 'AUTO', the min value of the lowest
            of the instrument ranges defined. None is returned if a match for range_id cannot be found.
        :rtype: float|None
        """

        if isinstance(range_id, str):
            if self.has_auto:
                if range_id == 'AUTO':
                    return self.min_values[0]
        else:
            index = self._get_index_from_range_id(range_id)
            if index is not None:
                return self.min_values[index]

        raise RuntimeError(f"Bad range_id '{range_id}', could not match to any of {self.get_ranges()}.\n"
                           f"Matching tolerance is determined by attribute rel_tol={self.rel_tol}, which is equivalent "
                           f"to +/-{self.rel_tol*100}%.")

    def get_range_bounds(self, range_id):
        """
        Returns a tuple consisting of (min_value, max_value) of the range specified by range_id.

        :param range_id: float value corresponding to the max value of one of the defined ranges or, if attribute
            has_auto is True, it may also be the str 'AUTO'.
        :type range_id: str|float
        :return: If attribute has_auto is True and range_id is 'AUTO', min_value comes from the lowest range and
            max_value from the highest. Otherwise, the min and max values come from the range whose max value matches
            range_id.
        :rtype: tuple(float, float)
        """

        if isinstance(range_id, str):
            if self.has_auto:
                if range_id == 'AUTO':
                    return self.get_min_for_range(self.get_lowest_range()), self.get_highest_range()
        else:
            return self.get_min_for_range(range_id), range_id

        raise ValueError(f"Bad range_id {range_id}, should be one of {self.get_ranges()}.")

    def _get_index_from_range_id(self, range_id):
        """
        Returns the index where range_id is found in self.max_values. Matching uses math.isclose compare float values
        to within self.rel_tol. max_values consist of the values that identify the instrument ranges sorted into
        ascending order.

        :param range_id: The max value of the range we are looking for.
        :type range_id: float
        :return: range_id is found in self.max_values. return None if
        :rtype: int
        """
        for i, r in enumerate(self.max_values):
            if isclose(range_id, r, rel_tol=self.rel_tol):
                return i
        return None

    def _find_index_above(self, value, ranges):
        """
        Returns the smallest value in a sorted list that is equal to or larger than a given value.

        An application is to find the lowest meter range that will allow measurement of the given value.

        :param value: The value to compare against the list of ranges. If attribute bipolar_values is False, this value
            is compared to the ranges to select an applicable range. If bipolar_values is True, then abs(value)
            is compared to the range.
        :type value: float
        :param ranges: List of ranges in ascending order.
        :type ranges: List[float]
        :return: The smallest value in ranges that is greater than or equal to value. If value is greater then the
            largest element of ranges, the largest element is returned.
        :rtype: int
        """

        if self.bipolar_values:
            value = abs(value)

        max_i = len(ranges) - 1

        if value > ranges[max_i]:
            return None

        for i in range(max_i, -1, -1):
            if value == ranges[i]:
                return i
            if i == 0:
                return 0
            if ranges[i - 1] < value <= ranges[i]:
                return i
