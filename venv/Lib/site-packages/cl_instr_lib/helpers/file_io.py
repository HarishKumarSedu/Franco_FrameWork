# -----------------------------------------------------------
from enum import Enum
from pathlib import Path
import csv
import json
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.on_off import OnOff, on_off_vals
# -----------------------------------------------------------
enum_file_type = Enum("enum_file_type", {"csv": '.csv', "txt": '.txt', "bin": '.bin', "bmp": ".bmp", "gif": ".gif",
                                         "png": ".png", "jpg": ".jpg", "json": ".json"})
enum_append_file_type = Enum("enum_file_type", {"csv": '.csv', "txt": '.txt', "bin": '.bin'})
enum_ret_data_type = Enum("enum_ret_data_type",
                          {"dict": "dict", "str": "str", "list_str": "list_str",
                           "list_float": "list_float", "list_int": "list_int", "bytes": "bytes"})
on_off = OnOff(off_vals=on_off_vals(('OFF', False, 0, '0'), '0', ('OFF', '0', 0), 'OFF'),
               on_vals=on_off_vals(('ON', True, 1, '1'), '1', ('ON', '1', 1), 'ON'))


def write(pc_dir, file_name, file_type, data, header=None, binary_data=False, create_dir=False):
    """
    Writes a data structure to a file in a PC directory.

    This method overwrites existing files or creates new files upon use. If the directory does not exist,
    one can be created using the create_dir parameter.

    :param pc_dir: Directory being accessed or created for the write command.
    :type pc_dir: str
    :param file_name: File name for the write command. Exclude file extension. 'sample.txt' should be 'sample'.
    :type file_name: str
    :param file_type: File type for the write command. One of the following:

        * txt  - Creates a text file able to store string, list, dict. and binary/byte data.
        * bin  - Creates a binary file able to store binary/byte data.
        * csv  - Creates a comma separated value (csv) file able to store lists of lists
        * bmp  - Creates a bitmap image file from binary data (data must be preformatted).
        * gif  - Creates a Graphics Interchange Format image file from binary data (data must be preformatted).
        * png  - Creates a Portable Network Graphics format image file from binary data (data must be preformatted).
        * jpg  - Creates a JPEG image file from binary data (data must be preformatted).
        * json - Creates a json file for complex data structures.
    :type file_type: str | enum_file_type
    :param data: Data structure being passed directly into the file.
        **Note:** When passing in csv data,
        this parameter must be a list of lists with the interior lists equal size to the header.
    :type data: str | list | dict | bytes | list[list]
    :param header: Header of data structure being passed directly into the file. Use only when using csv data, otherwise
        None.
    :type header: list[str] | None
    :param binary_data: on_off value (True/False Preferred) that determines if the data being written is binary/byte.
        Defaults to False.
    :type binary_data: bool | int | str
    :param create_dir: on_off value (True/False Preferred) that determines if a directory will be made in the event
        pc_dir does not currently exist. Defaults to False.
    :type create_dir: bool | int | str
    """
    file_name = file_name.strip()  # remove spaces on ends
    on_off.to_inst(binary_data)

    # change operation if binary is being sent
    if binary_data in on_off.off_vals.from_api:
        operation = 'w'
    else:
        operation = 'wb'

    # check all parameters
    check_filename(file_name)
    path = check_filepath(pc_dir, create_dir)
    file_type = (check_enum_str('file_type', file_type, enum_file_type)).value
    operation, w_data = _check_w_a_params(file_type, operation, data, header)

    # create the path and open the file
    path_str = path / (file_name + file_type)

    # write to the file
    if file_type == '.csv':  # csv file handling
        with open(path_str, operation, newline='') as file:
            writer = csv.writer(file)
            writer.writerow(header)  # header
            writer.writerows(data)  # data
    elif file_type == '.json':
        with open(path_str, operation, encoding='utf-8') as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
    elif file_type in ['.txt', '.bin', '.bmp', '.gif']:
        with open(path_str, operation) as file:
            file.write(w_data)
    else:
        with open(path_str, operation) as file:
            file.write(w_data)


def append(pc_dir, file_name, file_type, data, binary_data=False):
    """
    Appends a data structure to an existing file in a PC directory.

    **Note:** Not all file types can be appended in this fashion (json, images).

    :param pc_dir: Directory being accessed or created for the append command.
    :type pc_dir: str
    :param file_name: File name for the append command. Exclude file extension. 'sample.txt' should be 'sample'.
    :type file_name: str
    :param file_type: File type for the append command. One of the following:

        * txt - Creates a text file able to store string, list, dict. and binary/byte data.
        * bin - Creates a binary file able to store binary/byte data.
        * csv - Creates a comma separated value (csv) file able to store lists of lists.
    :type file_type: str | enum_file_type
    :param data: data structure being passed directly into the file.
        **Note:** When passing in csv data,
        this parameter must be a list of lists with the interior lists equal size to the header.
    :type data: str | list | dict | bytes
    :param binary_data: on_off value (True/False Preferred) that determines if the data being written is binary/byte.
    :type binary_data: bool | int | str
    """
    file_name = file_name.strip()  # remove spaces on ends
    on_off.to_inst(binary_data)

    if binary_data in on_off.off_vals.from_api:
        operation = 'a'
    else:
        operation = 'ab'

    # check all parameters
    check_filename(file_name)
    path = check_filepath(pc_dir)
    file_type = (check_enum_str('file_type', file_type, enum_append_file_type)).value
    operation, w_data = _check_w_a_params(file_type, operation, data, None)

    # create the path and open the file
    path_str = path / (file_name + file_type)

    # write to the file

    if file_type == '.csv':  # csv file handling
        with open(path_str, operation, newline='') as file:
            writer = csv.writer(file)
            writer.writerows(data)  # data
    elif file_type in ['.txt', '.bin']:
        with open(path_str, operation) as file:
            file.write(w_data)


def fast_append(pc_dir, file_name, file_type, data, binary_data=False):
    """
    Appends a data structure to an existing file in a PC directory.

    **Note:** Not all file types can be appended in this fashion (json, images).

    This method is faster as it has less parameter checks than that of the normal append function. Assuming that a
    successful write/append was made using the same parameters then this function will work as expected.

    :param pc_dir: Directory being accessed or created for the append command.
    :type pc_dir: str
    :param file_name: file name for the append command. exclude file extension. 'sample.txt' should be 'sample'.
    :type file_name: str
    :param file_type: file type for the append command. One of the following:

        * txt - Creates a text file able to store string, list, dict. and binary/byte data.
        * bin - Creates a binary file able to store binary/byte data.
        * csv - Creates a comma separated value (csv) file able to store lists of lists.
    :type file_type: str | enum_file_type
    :param data: Data structure being passed directly into the file.
        **Note:** When passing in csv data,
        this parameter must be a list of lists with the interior lists equal size to the header.
    :type data: str | list | dict | bytes
    :param binary_data: on_off value (True/False Preferred) that determines if the data being written is binary/byte.
    :type binary_data: bool | int | str
    """
    if binary_data in on_off.off_vals.from_api:
        operation = 'a'
    else:
        operation = 'ab'

    # check all parameters
    pc_path = Path(pc_dir)
    path_str = pc_path / (file_name + '.' + file_type)

    w_data = None
    # create the path and open the file
    if file_type == 'csv':
        if not isinstance(data, list):
            raise ValueError(f"Bad data type {type(data)}. Should be a list of lists")
    else:
        if isinstance(data, list):
            w_data = ', '.join(map(str, data))
        elif isinstance(data, dict):
            w_data = str(data)
        elif isinstance(data, (str, bytes)):
            w_data = data
        else:
            raise ValueError(f"Bad data type {type(data)}. Should be str | dict | list | bytes")

    # write to the file
    if file_type == 'csv':  # csv file handling
        with open(path_str, operation, newline='') as file:
            writer = csv.writer(file)
            writer.writerows(data)  # data
    elif file_type in ['txt', 'bin']:
        with open(path_str, operation) as file:
            file.write(w_data)


def read(pc_dir, file_name, file_type, ret_data_type='str'):
    """
    Read's a file and returns a data structure.

    When specifically using text files, the same data type put in to the file should be called for it's return in the
    ret_data_type.

    :param pc_dir: Directory being accessed or created for the read command.
    :type pc_dir: str
    :param file_name: File name for the read command. exclude file extension. 'sample.txt' should be 'sample'.
    :type file_name: str
    :param file_type: File type for the read command.
    :type file_type: str | enum_file_type
    :param ret_data_type: Data structure being returned from the file. **Note:** This parameter only applies to txt
        files. Based on the data type used in write file method. One of the following:

        * str  - Returns a text string of data values comma delimited. (default)
        * dict - Returns a dictionary of values.
        * list_str - Returns a list of string values.
        * list_int - Returns a list of integer values.
        * list_float - Returns a list of float values.
        * bytes  - Returns binary/byte data stored.
    :type ret_data_type: str
    :return: Data from file. If a text file, in the form of the return data type parameter.
    :rtype:  str | list | dict | bytes | list[list[obj]]
    """
    file_name = file_name.strip()  # remove spaces on ends
    ret_data_type = (check_enum_str('ret_data_type', ret_data_type, enum_ret_data_type)).value

    if ret_data_type in ["dict", "str", "list_str", "list_int", "list_float"]:
        operation = 'r'
    else:
        operation = 'rb'

    # check all parameters
    file_type = check_enum_str('file type', file_type, enum_file_type).value
    path = check_filepath(pc_dir)
    operation = _check_operation(operation, file_type)

    # create the path and open the file
    path_str = path / (file_name + file_type)
    with open(path_str, operation) as file:

        # read from the file
        if file_type == '.json':
            r_data = json.load(file)
        elif file_type == '.csv':  # csv file handling
            reader = csv.reader(file)
            r_data = []
            for row in reader:
                r_data.append(row)
        elif file_type in ['.txt', '.bin', '.bmp', '.gif']:
            data = file.read()
            if ret_data_type == 'list_str':
                r_data = _string_to_list(data)
            elif ret_data_type == 'list_int':
                r_data = _list_of_int(_string_to_list(data))
            elif ret_data_type == 'list_float':
                r_data = _list_of_float(_string_to_list(data))
            elif ret_data_type == 'dict':
                r_data = _string_to_dict(data)
            else:
                r_data = data
        else:
            data = file.read()
            r_data = data

    return r_data


def check_filepath(pc_dir, create_dir=False):
    """
    Method that checks if a directory and filepath exists, and optionally creates one.

    :param pc_dir: Directory being accessed or created for the command.
    :type pc_dir: str
    :param create_dir: on_off value (True/False Preferred) that determines if a directory will be made in the event
        pc_dir does not currently exist.
    :type create_dir: bool | int | str
    :return: The directory path.
    :rtype: path
    """
    on_off.to_inst(create_dir)

    # See if the directory on the PC exists, if not create it if user specified that option.
    pc_path = Path(pc_dir)
    if not pc_path.exists():
        if create_dir in on_off.off_vals.from_api:
            raise ValueError(f"Bad directory '{str(pc_path)}', does not exist. "
                             "Use create_dir to force automatic creation of a missing directory path.")

        pc_path.mkdir(parents=True)
        print(f"Specified directory '{pc_dir}', did not exist, creating it because create_dir == True.")

    elif not pc_path.is_dir():
        raise ValueError(f"Bad directory '{str(pc_path)}', final element is not a directory, perhaps a file?")

    return pc_path


def check_filename(filename):
    """
    Method that validates a filename string for windows and linux systems.

    :param filename: a filename given by a user.
    :type filename: str
    """
    if not isinstance(filename, str):
        raise ValueError(f" File name is {filename} of type {type(filename)}. Should be a string.")

    illegal_characters = r'<>:"/|\?*'
    for element in filename:
        if element in illegal_characters or (0 <= ord(element) <= 31):  # illegal ascii for filenames
            raise ValueError(f" File name {filename} cannot contain {element} or any one of the following:\n"
                             f"{illegal_characters}")


def decode_ieee_header(dataset):
    """
    Helper for reading an IEEE header designating the amount of data in a binary data packet, PACKED and REAL data
    always starts with this IEEE header.

    :param dataset: Binary/byte data received from the instrument.
    :type dataset: bytes
    :return: The length of the dataset and the dataset with the header removed.
    :rtype: int & bytes
    """

    ieee_header_length = int(chr(dataset[1]))
    # ieee_header = raw_data[0:1+ieee_header_length]
    data_length = int(dataset[2:2 + ieee_header_length])
    if data_length > 0:
        data = dataset[2 + ieee_header_length:]
    else:
        data = None
    return data_length, data


def csv_data_encoder(data, header_length):
    """
    Helper that takes a list of values and a csv header, then creates a list of lists for each row of the
    desired csv file.

    :param data: csv data that needs to be parsed for use in file writing or appending.
    :type data: list
    :param header_length: length of the file's header
    :type header_length: int
    :return: data formatted as a list of row lists
    :rtype: list
    """
    csv_data = []
    data_length = len(data)

    for row in range(0, data_length, header_length):

        temp_list = []
        for row_index in range(header_length):
            temp_list.append(data[row+row_index])

        csv_data.append(temp_list)

    return csv_data


def csv_data_decoder(csv_raw_data):
    """
    Helper that takes decodes csv data.

    Takes the list of list structure of the csv file and creates a dictionary of lists for use in programs.

    **Note:** The decoder is formatted such that the first element in the csv_raw_data list must be the header of the
    csv data.

    :param csv_raw_data: csv data from reading a csv file. must be in the list of lists structure.
    :type csv_raw_data: list
    :return: data formatted a dictionary of lists
    :rtype: dict
    """
    csv_dict = {}
    header = csv_raw_data[0]  # the first list of a csv is the header info, we will draw a lot from this.
    data_len = len(csv_raw_data)

    # create empty lists for each header in the csv_dict
    for element in header:
        csv_dict.update({element: list()})

    for row in range(1, data_len):
        for element in header:  # update the list in the csv_dict for each element in the header.
            csv_dict.get(element).append(csv_raw_data[row][header.index(element)])

    return csv_dict


def _check_w_a_params(file_type, operation, data, header):
    """Helper that checks the general read write parameters used."""

    operation = _check_operation(operation, file_type)

    write_data = None
    if file_type == '.csv':
        if not isinstance(data, list):
            raise ValueError(f"Bad data type {type(data)}. Should be a list of lists")
        if header is not None and not isinstance(header, list):
            raise ValueError(f"Bad data type {type(header)}. Should be a list")
    elif file_type in ['.txt', '.bin', '.bmp']:
        if isinstance(data, list):
            write_data = ', '.join(map(str, data))
        elif isinstance(data, dict):
            write_data = str(data)
        elif isinstance(data, (str, bytes)):
            write_data = data
        else:
            raise ValueError(f"Bad data type {type(data)}. Should be str | dict | list | bytes")
    else:
        write_data = data

    return operation, write_data


def _check_operation(operation, file_type):
    """Helper function that verifies a file operation."""
    enum_file_operation_txt = Enum("enum_file_operation_txt",
                                   {"w": 'w', "r": 'r', "wb": 'wb', "rb": 'rb', "a": 'a', "ab": 'ab'})
    enum_file_operation_csv = Enum("enum_file_operation_csv", {"w": 'w', "r": 'r', "a": 'a'})
    enum_file_operation_bin = Enum("enum_file_operation_bin", {"wb": 'wb', "rb": 'rb', "ab": 'ab'})

    if file_type == '.csv':
        operation = (check_enum_str('operation', operation, enum_file_operation_csv)).value
    elif file_type == '.bin':
        operation = (check_enum_str('operation', operation, enum_file_operation_bin)).value
    else:
        operation = (check_enum_str('operation', operation, enum_file_operation_txt)).value

    return operation


def _string_to_dict(input_str):
    return eval(input_str)


def _string_to_list(input_str):
    return input_str.split(', ')


def _list_of_int(dataset):
    return [int(element) for element in dataset]


def _list_of_float(dataset):
    return [float(element) for element in dataset]


class File:
    """
    Class for file objects. File class stores allows for storage of attributes such as directory, name, and type.
    File class also inherits file_io manipulation (write/append/read) for the file object.

    :param pc_dir: Directory being accessed or created by the file object.
    :type pc_dir: str

    :param file_name: file name for the file object. exclude file extension. 'sample.txt' should be 'sample'.
    :type file_name: str

    :param file_type: file type for the file object. One of the following:

        * txt - creates a text file able to store string, list, dict. and binary/byte data. (default)
        * bin - creates a binary file able to store binary/byte data.
        * csv - creates a comma separated value (csv) file able to store lists of lists
        * bmp  - Creates a bitmap image file from binary data (data must be preformatted).
        * gif  - Creates a Graphics Interchange Format image file from binary data (data must be preformatted).
        * png  - Creates a Portable Network Graphics format image file from binary data (data must be preformatted).
        * jpg  - Creates a JPEG image file from binary data (data must be preformatted).
        * json - creates a json file for complex data structures.
    :type file_type: str | enum_file_type

    :param create_dir: on_off value (True/False Preferred) that determines if a directory will be made in the event
        pc_dir does not currently exist. Defaults to False.
    :type create_dir: bool | int | str
    """

    # :param create_file: on_off value (True/False Preferred) that will write the file on file object instantiation.
    # :type create_file: bool | int | str
    # :param data: optional data structure being stored if the file is written using create_file. Data is not in the
    #     object for memory efficiency.
    # :type data: None | str | list | dict | bytes | list[list]
    # :param header: csv header of data structure being passed directly into the file object.
    #     Use only when using csv data, otherwise None.
    # :type header: list[str] | None
    # :param binary_data: on_off value (True/False Preferred) that determines if the data being written is
    #     binary/byte. Defaults to False.
    # :type binary_data: bool | int | str

    enum_file_type = Enum("enum_file_type",
                          {"csv": '.csv', "txt": '.txt', "bin": '.bin', "bmp": ".bmp", "json": ".json"})
    enum_ret_data_type = Enum("enum_ret_data_type",
                              {"dict": "dict", "str": "str", "list_str": "list_str",
                               "list_float": "list_float", "list_int": "list_int", "bytes": "bytes"})

    def __init__(self, pc_dir, file_name, file_type='txt', create_dir=False):

        # make sure the parameters are valid
        check_filepath(pc_dir, create_dir)
        check_filename(file_name)
        file_type = (check_enum_str('file_type', file_type, enum_file_type)).name  # txt not .txt at this stage

        # core parameters
        self.pc_dir = pc_dir
        self.file_name = file_name
        self.file_type = file_type

        # aliases
        self.dir = pc_dir
        self.name = file_name
        self.type = file_type
        self.full_name = file_name + '.' + file_type

    def write(self, data, header=None, binary_data=False):
        """
        Write a data structure to the file specified by the object.

        :param data: data structure being passed directly into the file.
            **Note:** When passing in csv data,
            this parameter must be a list of lists with the interior lists equal size to the header.
        :type data: str | list | dict | bytes | list[list]
        :param header: Geader of data structure being passed directly into the file. Use only when using csv data,
            otherwise None.
        :type header: list[str] | None
        :param binary_data: on_off value (True/False Preferred) that determines if the data being written is
         binary/byte. Defaults to False.
        :type binary_data: bool | int | str
        """
        write(self.pc_dir, self.file_name, self.file_type, data, header=header, binary_data=binary_data)

    def append(self, data, binary_data=False):
        """
        Append a data structure to the file specified by the object.

        **Note:** Not all file types can be appended in this fashion (json, images).

        :param data: data structure being passed directly into the file.
            **Note:** When passing in csv data,
            this parameter must be a list of lists with the interior lists equal size to the header.
        :type data: str | list | dict | bytes | list[list]
        :param binary_data: on_off value (True/False Preferred) that determines if the data being written is
         binary/byte. Defaults to False.
        :type binary_data: bool | int | str
        """
        append(self.pc_dir, self.file_name, self.file_type, data, binary_data=binary_data)

    def fast_append(self, data, binary_data=False):
        """
        Append a data structure to the file specified by the object.

        **Note:** Not all file types can be appended in this fashion (json, images).

        This method is faster as it has less parameter checks than that of the normal append function. Assuming that a
        successful write/append was made using the same parameters then this function will work as expected.

        :param data: data structure being passed directly into the file.
            **Note:** When passing in csv data,
            this parameter must be a list of lists with the interior lists equal size to the header.
        :type data: str | list | dict | bytes | list[list]
        :param binary_data: on_off value (True/False Preferred) that determines if the data being written is
         binary/byte. Defaults to False.
        :type binary_data: bool | int | str
        """
        fast_append(self.pc_dir, self.file_name, self.file_type, data, binary_data=binary_data)

    def read(self, ret_data_type='str'):
        """
        Reads the file object and returns a data structure.

        When specifically using text files, the same data type put in to the file should be called
        for it's return in the ret_data_type.

        :param ret_data_type: Data structure being returned from the file.
            **Note:** This parameter only applies to txt files. Based on the data type used in write file method.
            One of the following:

            * str  - Returns a text string of data values comma delimited. (default)
            * dict - Returns a dictionary of values.
            * list_str - Returns a list of string values.
            * list_int - Returns a list of integer values.
            * list_float - Returns a list of float values.
            * bytes  - Returns binary/byte data stored.
        :type ret_data_type: str
        :return: Data from file. If a text file, in the form of the return data type parameter.
        :rtype:  str | list | dict | bytes | list[list[obj]]
        """
        data = read(self.pc_dir, self.file_name, self.file_type, ret_data_type=ret_data_type)
        return data


# -----------------------------------------------------------
