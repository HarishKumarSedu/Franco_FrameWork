# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
from cl_instr_lib.helpers.user_delay import *
# -----------------------------------------------------------
#                           NOTES
# -----------------------------------------------------------

# -----------------------------------------------------------
#                          METHODS
# -----------------------------------------------------------


def print_test(inst_obj, method_str, method_parameter=None, assert_str=None, delay=0, expect_error=False):
    """
    Helper function that streamlines print debugging.

    :param inst_obj: the instrument object, passed through for calling functions
    :type inst_obj: instrument
    :param method_str: a method from the instrument in string form. DO NOT call with parameter already inserted
    :type method_str: str
    :param method_parameter: Parameter that we want passed into, if multiple parameters, pass as a string
    :type method_parameter: str | int | bool | float
    :param assert_str: Assert an expected value for a write command. value checked in assertion is 'return_val'
    :type assert_str: str
    :param delay: delay needed for a machine to process commands
    :type delay: int | float
    :param expect_error: If you expect an fail due to a warning you cannot surpress, set this to true to pass the test
    :type expect_error: bool
    :return: dictionary of pass fail values
    :rtype: dict
    """
    # Color Print testing
    # print(u"\u001b[30m A \u001b[31m B \u001b[32m C \u001b[33m D \u001b[0m")
    # print(u"\u001b[34m E \u001b[35m F \u001b[36m G \u001b[37m H \u001b[0m")

    test_passed = 1
    error_dict = {}
    test_outcomes = ('FAIL', 'PASS', 'PASS WITH OVERRIDE')
    # for minimizing the next few lines
    method_str = method_str.rstrip("()") + "()"
    ms = method_str
    mp = method_parameter
    inst_obj = inst_obj  # this isn't directly used in the code as it is used in eval statements

    # -----------------------------------------------------------
    if method_parameter is not None:

        # Parse the method string to include the param in the parentheses
        function_call_str = ms[:ms.find("()") + 1] + str(mp) + ms[ms.find("()") + 1:]
        function_with_param = "inst_obj." + function_call_str

    function_without_param = "inst_obj." + method_str

    # Write/Read to the machine
    # -----------------------------------------------------------

    if method_parameter is not None:

        try:
            print(u'\u001b[34mRead back from Method before write: ' + method_str)
            return_val = eval(function_without_param)
            print(u'\u001b[34mReturned: ', end='')
            print(return_val)
        except:
            eval("inst_obj.log.warning('Method test read back failed.')")
            read_before = test_outcomes[0]
        else:
            read_before = test_outcomes[1]

        print(u"\u001b[0m", end='')  # Reset color to normal
        wait_visualizer(delay)

        try:
            print(u'\u001b[34mMethod Called: ' + function_call_str)
            eval(function_with_param)
        except:
            eval("inst_obj.log.warning('Method test writing failed, a warning or error was raised.')")
            write = test_outcomes[0]
        else:
            write = test_outcomes[1]

        print(u"\u001b[0m", end='')  # Reset color to normal
        wait_visualizer(delay)

        try:
            print(u'\u001b[34mRead Back from Method After write: ' + method_str)
            return_val = eval(function_without_param)

        except:
            eval("inst_obj.log.warning('Method test read back failed.')")
            print(u'\u001b[34mReturned: ', end='')
            print(return_val)
            read_after = test_outcomes[0]
        else:
            print(u'\u001b[34mReturned: ', end='')
            print(return_val)
            read_after = test_outcomes[1]

        if assert_str is not None:

            assert eval(assert_str), f"Error with assertion. return_val {return_val} " \
                                        f"does not follow logic of assertion_str " + assert_str
            print("Assertion Passed")

        if all(outcomes == "PASS" for outcomes in [read_before, write, read_after]):
            test_passed = 1
        else:
            test_passed = 0

        error_dict.update(passed=test_passed, read_before=read_before, write=write, read_after=read_after)

        if expect_error:
            if test_passed == 0:
                test_passed = 1
                error_dict.update(passed=test_passed)
                for key in error_dict:
                    if error_dict[key] == test_outcomes[0]:
                        error_dict[key] = test_outcomes[2]
            else:
                raise RuntimeError("Expect error was used but the initial test passed. Inspect further.")

    else:  # -----------------------------------------------------------
        try:
            print(u'\u001b[34mRead Back from Method: ' + method_str)
            return_val = eval(function_without_param)
            print(u'\u001b[34mReturned: ', end='')
            print(return_val)
        except:
            eval("inst_obj.log.warning('Method test read back failed.')")
            read = test_outcomes[0]
        else:
            test_passed = 1
            read = test_outcomes[1]

        if expect_error:
            if test_passed == 0:
                test_passed = 1
                read = test_outcomes[2]
            else:
                raise RuntimeError("Expect error was used but the initial test passed. Inspect test further.")

        error_dict.update(passed=test_passed, read_after=read)

    print(u"\u001b[0m", end='')  # Reset color to normal
    wait_visualizer(delay)
    return error_dict


def method_print_pytest(inst_obj, method_str, method_parameter=None, assertion_str=None, delay=0, expect_error=False):
    test_val = print_test(inst_obj, method_str, method_parameter, assertion_str, delay, expect_error)
    assert test_val['passed'] == 1, f"Error Dictionary: {test_val}"
    
# -----------------------------------------------------------
