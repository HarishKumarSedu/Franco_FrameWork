from enum import Enum


def check_enum_str(name, value, enum_cls, error_template=None):
    """Returns element of enum_cls that matches value or raises ValueError if no match. None values are just returned.

    :param name: The name of the variable in the caller. Used in formatting the exception message.
    :type name: str
    :param value: The value of the variable to be checked. If None, no check is performed and None is returned.
    :type value: None, or an enum element, or a string
    :param enum_cls: The enum class to check the value against.
    :type enum_cls: Enum
    :param error_template: If None default default f-string used to generate the error message. See
    :type error_template: str
    :return: An element of enum_cls that matches the value passed in. Return None if value was None.
    :rtype: Enum element or None.

    :default error template: "Bad {name} '{value}', should be one of {cls_name}: {keys}."

    The cls_name and keys are extracted by this function from the supplied enum_cls.
    """

    # This removes the need in the driver to wrap every call to this function in a " if name is not None:" conditional.
    if value is None:
        return None

    keys = enum_cls.__members__.keys()

    if isinstance(value, str):
        if value in keys:
            return getattr(enum_cls, value)
    else:
        if value in enum_cls:
            return value

    key_str = ', '.join([f"'{k}'" for k in keys])
    keys = key_str
    if error_template is None:
        error_template = "Bad {name} '{value}', should be one of {cls_name}: {keys}."
    raise ValueError(error_template.format(name=name, value=value, cls_name=enum_cls.__name__, keys=keys))


if __name__ == "__main__":
    enum_numbers = Enum('enum_foo', {'one': 1, 'two': 2})
    err_template = "Bad name '{value}', should be an element of {cls_name} or one of the strings: {keys}."
    check_enum_str('foo', 'bar', enum_numbers) # , err_template)
