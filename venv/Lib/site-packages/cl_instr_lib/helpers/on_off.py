from collections import namedtuple

on_off_vals = namedtuple('OnOffValues', ['from_api', 'to_inst', 'from_inst', 'to_api'])


class OnOff:
    """Class providing a central location defining the representations accepted from the API for the binary values
        ('ON', 'OFF', 0, 1, True, False) and translating these the strings '1' or '0' to be programmed into the
        instrument. Also, the reverse: query results may use various representations, but we wish the values returned
        to the API to use a consistent representation ('ON', 'OFF'). Note that this is crucial for instrument
        substitution.
    """

    def __init__(self, off_vals, on_vals):
        if not isinstance(off_vals, on_off_vals):
            raise ValueError(f"Bad off_vals '{off_vals}', should be of namedtuple of type {on_off_vals.__name__}.")
        self.off_vals = off_vals

        if not isinstance(on_vals, on_off_vals):
            raise ValueError(f"Bad on_vals '{on_vals}', should be of namedtuple of type {on_off_vals.__name__}.")
        self.on_vals = on_vals

    def to_inst(self, from_api):
        """Returns the state value to send to the instrument given one of the API representations of 'OFF' or 'ON'.
            If the values None in passed in, it is simply returned.
        """

        if from_api is None:
            return None       # A trick to avoid if statements to the defaulted arguments.

        tmp = from_api
        if isinstance(tmp, str):
            tmp = tmp.upper()

        if tmp in self.off_vals.from_api:
            return self.off_vals.to_inst
        elif tmp in self.on_vals.from_api:
            return self.on_vals.to_inst
        else:
            msg = "Bad on_off value: "
            msg += f"'{from_api}'" if isinstance(from_api, str) else f"{from_api}"
            msg += ", 'ON' or 'OFF' preferred, but may be any of: "
            msg += ", ".join([f"'{x}'" if isinstance(x, str) else f"{x}" for x in (self.off_vals.from_api +
                                                                                   self.on_vals.from_api)])
            msg += "."
            raise ValueError(msg)

    def to_api(self, from_inst):
        """Returns 'ON' or 'OFF' given one of the possible values returned from the instrument."""

        tmp = from_inst
        if isinstance(tmp, str):
            tmp = tmp.upper()

        if tmp in self.off_vals.from_inst:
            return self.off_vals.to_api
        elif tmp in self.on_vals.from_inst:
            return self.on_vals.to_api
        else:
            raise ValueError(f"Bad on_off value from instrument: {from_inst}.")

    def api_off_values(self):
        """Returns tuple of values that may be used **from** the instrument driver API to represent the 'OFF' state."""

        return self.off_vals.from_api

    def api_on_values(self):
        """Returns tuple of values that may be used **from** the instrument driver API to represent the 'ON' state."""

        return self.on_vals.from_api

    def api_values(self):
        """Returns tuple of values that may be used **from** the instrument driver API to represent the 'ON'
            and the 'OFF' states. The concatenation of api_off_values and api_on_values."""

        return self.off_vals.from_api + self.on_vals.from_api
