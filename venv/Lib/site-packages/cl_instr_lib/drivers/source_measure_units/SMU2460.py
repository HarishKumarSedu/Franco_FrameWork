# -----------------------------------------------------------
#                       INCLUDES
# -----------------------------------------------------------
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.power_supply import PowerSupply

from cl_instr_lib.base_classes.SMUs.smu2460_components.measure import Measure
from cl_instr_lib.base_classes.SMUs.smu2460_components.source import Source
from cl_instr_lib.base_classes.SMUs.smu2460_components.reading_buffers import ReadingBuffers
from cl_instr_lib.base_classes.SMUs.smu2460_components.trigger import Trigger
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from enum import Enum
from collections import namedtuple

# -----------------------------------------------------------
#                         NOTES
# -----------------------------------------------------------

min_max_units = namedtuple('min_max_units', ['min', 'max', 'units'])

# -----------------------------------------------------------
#                        CLASSES
# -----------------------------------------------------------


class SMU2460(InstrumentVisa, PowerSupply):
    """
    Driver class for the Keithley 2460 Source Measure Unit.

    The following attributes contain objects that correspond to most of the sub-systems shown on the SMU MENU screen.
    """

    enum_terminals_location = Enum('enum_terminals_location', {'FRONT': 'FRON', 'REAR': 'REAR'})

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):

        super().__init__(visa_resource_name, logger,
                         model_re='^MODEL 2460$',
                         sim_idn='KEITHLEY INSTRUMENTS,MODEL 2460,04475146,1.6.7c',
                         **kwargs)

        # terminals = self.get_fr_switch()
        # if terminals != 'FRONT':
        #     self.log.warning("REAR terminals selected. To use the front "
        #                      "panel terminals, the INPUTS button must be pushed manually!")

        self.current_bounds = min_max_units(-7.35, +7.35, 'Amps')
        self.voltage_bounds = min_max_units(-105.0, +105.0, 'Volts')

        #: Object containing the `Source`_  methods. Also, composes `Sweep`_ and `ConfigListSource`_ objects.
        self.source = Source(self)

        #: Object containing the `Reading Buffers`_ methods.
        self.reading_buffers = ReadingBuffers(self)

        #: Object containing the `Measure`_  methods. Also, composes a `ConfigListMeasure`_ object.
        self.measure = Measure(self)

        #: Object containing the `Trigger`_ methods.
        self.trigger = Trigger(self)

        self._channel_names = ["source"]   # Consistency with power supply drivers.

        self.create_scratch_buffer()


    def terminals_location(self, location=None):
        """
        Queries or sets selection of front vs rear terminals.

        :param location: 'FRONT' or 'REAR'
        :type location: str|enum_terminals_location
        :return: 'FRONT' or 'REAR'
        :rtype: str
        """

        # :ROUTe:TERMinals

        if location is None:
            return self.query(':ROUT:TERM', self.enum_terminals_location)
        location = check_enum_str('location', location, self.enum_terminals_location)

        self.write(':ROUT:TERM', location.value)

    def reset(self):
        """
        Performs an instrument \*RST and calls create_scratch_buffer to create the reading buffer used by this driver
        for throw away measurements used to force screen updates when certain parameters are updated.
        """

        super().reset()
        self.create_scratch_buffer()

    def create_scratch_buffer(self):
        """
        Used by driver init and reset methods to create a reading buffer called 'scratch'. Can also be used to restore
        this buffer should it be accidentally deleted.

        The source_voltage and source_current methods in this driver use the scratch buffer to do a measurement
        when values voltage/current values are changed. These throw-away measurements are diverted to the scratch
        buffer but their purpose is to cause the SMU display to update. This trick is needed because in remote operation
        the instrument stays in the Idle state unless a trigger model is running.

        To ensure that the scratch buffer is correctly configured, this method deletes any existing buffer named
        'scratch' and re-creates it. Deleting a non-existent buffer may cause an error dialog to pop-up on the
        instrument screen. Such pop-ups can be manually disabled from System.EventLog.LogSettings section of the
        instrument GUI. (Sadly, this cannot be remedied programmatically due to the SMU lacking SCPI commands for
        testing buffer existence and for remotely disabling pop-ups.)
        """

        # The scratch buffer is used by the measure command performed at the end of the source_voltage and
        # source_current methods. The measure command is there to make the home screen display values update, as users
        # would expect a power supply to do.

        buffer_name = 'scratch'

        if self.reading_buffers.buffer_exists(buffer_name):
            # Existing buffer might not be configured correctly.
            self.reading_buffers.delete_buffer(buffer_name, force=True)

        self.reading_buffers.make_buffer(buffer_name, capacity=10, style='STANDARD', fill_mode='CONTINUOUS')

# -----------------------------------------------------------
#                         MAIN
# -----------------------------------------------------------


if __name__ == '__main__':
    smu2460 = SMU2460('GPIB0::18')  # Replace visa_resource_name with None for simulated hardware.
    smu2460.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')

# -----------------------------------------------------------
#                     END OF FILE
# -----------------------------------------------------------
