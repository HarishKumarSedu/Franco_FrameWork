from math import copysign

from cl_instr_lib.base_classes.instrument_ni_pxi.instrument_ni_pxi_dcpower import InstrumentNiPxiDcpower
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.SMUs.ni_smu_components.ni_smu_channel_output_relay import NiSmuChannelOutputRelay, \
    ProgrammingBounds, CompensationBounds
from cl_instr_lib.helpers.inst_ranges import InstrumentRanges, min_max
from cl_instr_lib.helpers.check_range import min_max_units


class NiPxie4163(InstrumentNiPxiDcpower, PowerSupply):
    """Class for controlling either variant of the National Instruments PXIe-4163 Source Measure Unit (SMU).

    In NIMAX these identify as 'NI PXIe-4163' or as 'NI PXIe-4163 (10pA)'. The latter has an additional lower current
    range of 1e-6 A. This driver adapts to the particular hardware pointed to by resource_name. If there is no hardware,
    resource_name is None and the simulated instrument will be 'NI PXIe-4163'.
    """

    def __init__(self, resource_name=None, rm_handle=None, logger=None, **kwargs):

        model = 'NI PXIe-4163'  # This matches both HW models: 'NI PXIe-4163' or 'NI PXIe-4163 (10pA)'.
        # model also serves to identify the model to simulate when resource_name=None.

        super().__init__(model, resource_name, rm_handle, logger, independent_channels=True, **kwargs)

        # Gets max for chassis. 50e-3 A on >=58W cooling capacity, 30e-3 A all other chassis.
        current_max = self.session.channels[0].query_max_current_limit(0)

        # Account for sink limitations on current in quadrants 2 and 4 shown in the spec Figure 1.
        self.vsource_sink_current_limit = lambda voltage: copysign(current_max - 0.001 * abs(voltage), -1.0 * voltage)
        self.isource_sink_voltage_limit = lambda current: max(-24.0, 1000.0*(current - current_max)) if current > 0.0 \
            else min(24.0, 1000.0 * (current + current_max))

        programing_bounds = ProgrammingBounds(-24.0, 24.0, -0.05, 0.05, -1.2, 24.0*current_max)

        # Note voltage can be set positive or negative, but the NI driver property voltage_level_range is always
        # set using a positive number.
        self.voltage_ranges = InstrumentRanges('voltage', 'V',
                                               (min_max(0,  24.0),),
                                               has_auto=True,  # Enables 'AUTO' to be used as a range value.
                                               rel_tol=0.001,  # Used to match range query result to max values.
                                               bipolar_values=True  # Uses abs(voltage) for comparison to range.
                                               )

        # The ranges common to both the 'NI PXIe-4163' and the 'NI PXIe-4163 (10pA)'.
        ranges_current = [
            min_max(10e-8,  10e-6),
            min_max(100e-8, 100e-6),
            min_max(1e-5,   1e-3),
            min_max(10e-5,  10e-3),
            min_max(10e-5,  current_max),
        ]
        if self.get_model() == 'NI PXIe-4163 (10pA)':
            ranges_current.insert(0, min_max(1e-8, 1e-6))   # Additional 1uA range.

        # Assumes current_limit is set by a single property that is always a positive number that falls into one of
        # these ranges. This corresponds to the default SYMMETRIC setting of the NI driver property
        # compliance_limit_symmetry.
        self.current_limit_ranges = InstrumentRanges('current_limit', 'A', ranges_current, has_auto=True, rel_tol=0.001,
                                                     bipolar_values=False  # Because current_limit is always positive.
                                                     )

        # Note current can be set positive or negative, but the NI driver property current_level_range property is
        # always set using a positive number.
        ranges_current = [
            min_max(0.0, 10e-6),
            min_max(0.0, 100e-6),
            min_max(0.0, 1e-3),
            min_max(0.0, 10e-3),
            min_max(0.0, current_max),
        ]
        if self.get_model() == 'NI PXIe-4163 (10pA)':
            ranges_current.insert(0, min_max(0.0, 1e-6))   # Additional 1uA range.

        self.current_ranges = InstrumentRanges('current', 'A', ranges_current, has_auto=True, rel_tol=0.001,
                                               bipolar_values=True  # Use abs(current) for comparison to range.
                                               )

        # Assumes voltage_limit is set by a single property that is always a positive number that falls into one of
        # these ranges. This corresponds to the default SYMMETRIC setting of the NI driver property
        # compliance_limit_symmetry.
        self.voltage_limit_ranges = InstrumentRanges('voltage_limit', 'V',
                                                     (min_max(0.24, 24.0),),
                                                     has_auto=True,  # Enables 'AUTO' to be used as a range value.
                                                     rel_tol=0.001,  # Used to match range query result to max values.
                                                     bipolar_values=False  # Because voltage_limit is always positive.
                                                     )

        self.compensation_bounds = CompensationBounds(gain_bandwidth_voltage=min_max_units(10, 20e6, 'Hz'),
                                                      gain_bandwidth_current=min_max_units(10, 20e6, 'Hz'),
                                                      compensation_frequency=min_max_units(100, 300e3, 'Hz'),
                                                      pole_zero_ratio=min_max_units(0.125, 8.0, ''))

        # If these were created in a loop with setattr they won't show up in the stub file and the editor autocomplete.
        self.CHANNEL0 = NiSmuChannelOutputRelay(self, "CHANNEL0", 0, programing_bounds)
        self.CHANNEL1 = NiSmuChannelOutputRelay(self, "CHANNEL1", 1, programing_bounds)
        self.CHANNEL2 = NiSmuChannelOutputRelay(self, "CHANNEL2", 2, programing_bounds)
        self.CHANNEL3 = NiSmuChannelOutputRelay(self, "CHANNEL3", 3, programing_bounds)

        self.CHANNEL4 = NiSmuChannelOutputRelay(self, "CHANNEL4", 4, programing_bounds)
        self.CHANNEL5 = NiSmuChannelOutputRelay(self, "CHANNEL5", 5, programing_bounds)
        self.CHANNEL6 = NiSmuChannelOutputRelay(self, "CHANNEL6", 6, programing_bounds)
        self.CHANNEL7 = NiSmuChannelOutputRelay(self, "CHANNEL7", 7, programing_bounds)

        self.CHANNEL8 = NiSmuChannelOutputRelay(self, "CHANNEL8", 8, programing_bounds)
        self.CHANNEL9 = NiSmuChannelOutputRelay(self, "CHANNEL9", 9, programing_bounds)
        self.CHANNEL10 = NiSmuChannelOutputRelay(self, "CHANNEL10", 10, programing_bounds)
        self.CHANNEL11 = NiSmuChannelOutputRelay(self, "CHANNEL11", 11, programing_bounds)

        self.CHANNEL12 = NiSmuChannelOutputRelay(self, "CHANNEL12", 12, programing_bounds)
        self.CHANNEL13 = NiSmuChannelOutputRelay(self, "CHANNEL13", 13, programing_bounds)
        self.CHANNEL14 = NiSmuChannelOutputRelay(self, "CHANNEL14", 14, programing_bounds)
        self.CHANNEL15 = NiSmuChannelOutputRelay(self, "CHANNEL15", 15, programing_bounds)

        self.CHANNEL16 = NiSmuChannelOutputRelay(self, "CHANNEL16", 16, programing_bounds)
        self.CHANNEL17 = NiSmuChannelOutputRelay(self, "CHANNEL17", 17, programing_bounds)
        self.CHANNEL18 = NiSmuChannelOutputRelay(self, "CHANNEL18", 18, programing_bounds)
        self.CHANNEL19 = NiSmuChannelOutputRelay(self, "CHANNEL19", 19, programing_bounds)

        self.CHANNEL20 = NiSmuChannelOutputRelay(self, "CHANNEL20", 20, programing_bounds)
        self.CHANNEL21 = NiSmuChannelOutputRelay(self, "CHANNEL21", 21, programing_bounds)
        self.CHANNEL22 = NiSmuChannelOutputRelay(self, "CHANNEL22", 22, programing_bounds)
        self.CHANNEL23 = NiSmuChannelOutputRelay(self, "CHANNEL23", 23, programing_bounds)

        self._channel_names = []
        for chan in range(24):
            name = f"CHANNEL{chan}"
            obj = self.__getattribute__(name)
            self._channel_names.append(obj.channel_name)


if __name__ == '__main__':
    smu4163 = NiPxie4163('PXI1Slot8')  # None)  # Replace resource_name with None for simulated hardware.
