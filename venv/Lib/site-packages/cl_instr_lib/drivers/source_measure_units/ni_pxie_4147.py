from math import copysign
from cl_instr_lib.base_classes.instrument_ni_pxi.instrument_ni_pxi_dcpower import InstrumentNiPxiDcpower
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.SMUs.ni_smu_components.ni_smu_channel_output_relay import NiSmuChannelOutputRelay, \
    ProgrammingBounds, CompensationBounds
from cl_instr_lib.helpers.inst_ranges import InstrumentRanges, min_max
from cl_instr_lib.helpers.check_range import min_max_units


class NiPxie4147(InstrumentNiPxiDcpower, PowerSupply):
    """Class for controlling a National Instruments PXIe, 4-Channel, Â±8 V, 3 A Precision PXI Source Measure Unit.
    """

    def __init__(self, resource_name=None, rm_handle=None, logger=None, **kwargs):

        model = 'NI PXIe-4147'  # model also serves to identify the model to simulate when resource_name=None.

        super().__init__(model, resource_name, rm_handle, logger, independent_channels=True, **kwargs)

        # Sink power has a dependence on chassis cooling capacity, but I don't see a way to use query_max_current_limit
        # as I did on 4163 to determine what chassis we're in.  query_max_current_limit only applies to sourcing, on
        # 4147 the sourcing capability doesn't depend on the chassis.
        # So, since we only warn on sinking capacity - I'll assume we're in a < 58W chassis, so we'll warn about
        # exceeding 15W / ch sinking. Users of >=58W chassis will just have to live with the warnings.
        power_source_max = 24
        power_sink_max = 15

        self.vsource_sink_current_limit = lambda voltage: copysign(3.0, -1.0*voltage) if abs(voltage) <= 5.0 \
            else copysign(power_sink_max/voltage, -1.0*voltage)

        self.isource_sink_voltage_limit = lambda current: copysign(8.0, -1.0*current) if \
            abs(current) <= (power_sink_max/8.0) else copysign(power_sink_max/current, -1.0*current)

        programing_bounds = ProgrammingBounds(-8.0, 8.0, -3.0, 3.0, -1.0*power_sink_max, power_source_max)

        # Note voltage can be set positive or negative, but the NI driver property voltage_level_range is always
        # set using a positive number.
        self.voltage_ranges = InstrumentRanges('voltage', 'V',
                                               (min_max(0, 1.0),
                                                min_max(0, 8.0)),
                                               has_auto=True,  # Enables 'AUTO' to be used as a range value.
                                               rel_tol=0.001,  # Used to match range query result to max values.
                                               bipolar_values=True  # Uses abs(voltage) for comparison to range.
                                               )

        # Assumes current_limit is set by a single property that is always a positive number that falls into one of
        # these ranges. This corresponds to the default SYMMETRIC setting of the NI driver property
        # compliance_limit_symmetry.
        self.current_limit_ranges = InstrumentRanges('current_limit', 'A',
                                                     (min_max(  1e-8,   1e-6),
                                                      min_max( 10e-8,  10e-6),
                                                      min_max(100e-8, 100e-6),
                                                      min_max(  1e-5,   1e-3),
                                                      min_max( 10e-5,  10e-3),
                                                      min_max(100e-5, 100e-3),
                                                      min_max(  3e-2,    3.0),
                                                      ),
                                                     has_auto=True,
                                                     rel_tol=0.001,
                                                     bipolar_values=False  # Because current_limit is always positive.
                                                     )

        # Note current can be set positive or negative, but the NI driver property current_level_range property is
        # always set using a positive number.
        self.current_ranges = InstrumentRanges('current', 'A',
                                               (min_max(0.0,  10e-6),
                                                min_max(0.0,   1e-6),
                                                min_max(0.0, 100e-6),
                                                min_max(0.0,   1e-3),
                                                min_max(0.0,  10e-3),
                                                min_max(0.0, 100e-3),
                                                min_max(0.0,    3.0),
                                                ),
                                               has_auto=True,
                                               rel_tol=0.001,
                                               bipolar_values=True  # Use abs(current) for comparison to range.
                                               )

        # Assumes voltage_limit is set by a single property that is always a positive number that falls into one of
        # these ranges. This corresponds to the default SYMMETRIC setting of the NI driver property
        # compliance_limit_symmetry.
        self.voltage_limit_ranges = InstrumentRanges('voltage_limit', 'V',
                                                     (min_max(10e-3, 1.0),
                                                      min_max(80e-3, 8.0)),
                                                     has_auto=True,  # Enables 'AUTO' to be used as a range value.
                                                     rel_tol=0.001,  # Used to match range query result to max values.
                                                     bipolar_values=False  # Because voltage_limit is always positive.
                                                     )

        self.compensation_bounds = CompensationBounds(gain_bandwidth_voltage=min_max_units(10, 2e6, 'Hz'),
                                                      gain_bandwidth_current=min_max_units(10, 2e6, 'Hz'),
                                                      compensation_frequency=min_max_units(50, 1e6, 'Hz'),
                                                      pole_zero_ratio=min_max_units(0.125, 8.0, ''))

        # Yes I know we could do this in a loop with setattr, but it doesn't work with the pyro server!
        self.CHANNEL0 = NiSmuChannelOutputRelay(self, "CHANNEL0", 0, programing_bounds)
        self.CHANNEL1 = NiSmuChannelOutputRelay(self, "CHANNEL1", 1, programing_bounds)
        self.CHANNEL2 = NiSmuChannelOutputRelay(self, "CHANNEL2", 2, programing_bounds)
        self.CHANNEL3 = NiSmuChannelOutputRelay(self, "CHANNEL3", 3, programing_bounds)

        self._channel_names = ["CHANNEL0", "CHANNEL1", "CHANNEL2", "CHANNEL3"]


if __name__ == '__main__':
    smu4147 = NiPxie4147('PXI1Slot7')  # None)  # Replace resource_name with None for simulated hardware.
