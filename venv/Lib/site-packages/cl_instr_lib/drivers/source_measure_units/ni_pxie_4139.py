import math

from cl_instr_lib.base_classes.instrument_ni_pxi.instrument_ni_pxi_dcpower import InstrumentNiPxiDcpower
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.SMUs.ni_smu_components.ni_smu_channel_output_relay import NiSmuChannelOutputRelay, \
    ProgrammingBounds, CompensationBounds
from cl_instr_lib.helpers.inst_ranges import InstrumentRanges, min_max
from cl_instr_lib.helpers.check_range import min_max_units


class NiPxie4139(InstrumentNiPxiDcpower, PowerSupply):
    """Class for controlling either variant of the  National Instruments PXIe-4139 Source Measure Unit (SMU):

    ±60 V, ±3 A DC, ±10 A Pulsed, 20 W DC, 100 fA Precision System PXI Source Measure Unit
    ±60 V, ±3 A DC, ±10 A Pulsed, 40 W DC, 100 fA Precision System PXI Source Measure Unit

    The 20 W version front panel says "NI PXIe-4139 Precision System SMU" and NIMAX shows it as "NI PXIe-4139".
    The 40W version front panel says "NI PXIe-4139 40W System SMU" and NIMAX shows it as "NI PXIe-4139 (40W)".

    The power check in the source_voltage and source_current methods of this driver is based on the method
    nidcpower.query_max_current_limit() which should allow it to adapt to the 40W version though this has not been
    tested on actual hardware.
    """

    def __init__(self, resource_name=None, rm_handle=None, logger=None, **kwargs):

        model = 'NI PXIe-4139'  # This matches both 'NI PXIe-4139' or as 'NI PXIe-4139 (40W)'.
        # model also serves to identify the model to simulate when resource_name=None.

        super().__init__(model, resource_name, rm_handle, logger, **kwargs)

        if self.get_model() == 'NI PXIe-4139 (40W)':
            current_max = self.session.channels[0].query_max_current_limit(10)
            if current_max > 2.0:
                power_source_max = 40.0   # We are in a >= 58W chassis
                power_sink_max = 40.0
            else:
                power_source_max = 20.0
                power_sink_max = 12.0
        else:
            # For 20W SMU, chassis cooling capacity doesn't matter.
            power_source_max = 20.0
            power_sink_max = 12.0

        # Account for power sinking capability being less than the sourcing capability. See the spec quadrant diagram.
        self.vsource_sink_current_limit = lambda voltage: math.copysign(3.0, -1.0*voltage) if \
            (abs(voltage) <= power_sink_max / 3.0) else math.copysign(power_sink_max/voltage, -1.0*voltage)

        self.isource_sink_voltage_limit = lambda current: math.copysign(60.0, -1.0*current) if \
            (abs(current) <= power_sink_max / 60.0) else math.copysign(power_sink_max/current, -1.0*current)

        programing_bounds = ProgrammingBounds(-60.0, 60.0, -3.0, 3.0, -1.0*power_sink_max, power_source_max)

        # Note voltage can be set positive or negative, but the NI driver property voltage_level_range is always
        # set using a positive number.
        self.voltage_ranges = InstrumentRanges('voltage', 'V',
                                               (min_max(  0,  0.6),
                                                min_max(  0,  6.0),
                                                min_max(  0, 60.0),
                                                ),
                                               has_auto=True,  # Enables 'AUTO' to be used as a range value.
                                               rel_tol=0.001,  # Used to match range query result to max values.
                                               bipolar_values=True  # Uses abs(voltage) for comparison to range.
                                               )

        # Assumes current_limit is set by a single property that is always a positive number that falls into one of
        # these ranges. This corresponds to the default SYMMETRIC setting of the NI driver property
        # compliance_limit_symmetry.
        self.current_limit_ranges = InstrumentRanges('current_limit', 'A',
                                                     (min_max(  1e-8,   1e-6),
                                                      min_max( 10e-8,  10e-6),
                                                      min_max(100e-8, 100e-6),
                                                      min_max(  1e-5,   1e-3),
                                                      min_max( 10e-5,  10e-3),
                                                      min_max(100e-5, 100e-3),
                                                      min_max(  1e-2,    1.0),
                                                      min_max(  3e-2,    3.0),
                                                      ),
                                                     has_auto=True,
                                                     rel_tol=0.001,
                                                     bipolar_values=False  # Because current_limit is always positive.
                                                     )

        # Note current can be set positive or negative, but the NI driver property current_level_range property is
        # always set using a positive number.
        self.current_ranges = InstrumentRanges('current', 'A',
                                               (min_max(0.0,  10e-6),
                                                min_max(0.0,   1e-6),
                                                min_max(0.0, 100e-6),
                                                min_max(0.0,   1e-3),
                                                min_max(0.0,  10e-3),
                                                min_max(0.0, 100e-3),
                                                min_max(0.0,    1.0),
                                                min_max(0.0,    3.0),
                                                ),
                                               has_auto=True,
                                               rel_tol=0.001,
                                               bipolar_values=True  # Use abs(current) for comparison to range.
                                               )

        # Assumes voltage_limit is set by a single property that is always a positive number that falls into one of
        # these ranges. This corresponds to the default SYMMETRIC setting of the NI driver property
        # compliance_limit_symmetry.
        self.voltage_limit_ranges = InstrumentRanges('voltage_limit', 'V',
                                                     (min_max(0.006, 0.6),
                                                      min_max(0.06, 6.0),
                                                      min_max(0.6, 60.0),
                                                      ),
                                                     has_auto=True,  # Enables 'AUTO' to be used as a range value.
                                                     rel_tol=0.001,  # Used to match range query result to max values.
                                                     bipolar_values=False  # Because voltage_limit is always positive.
                                                     )

        self.compensation_bounds = CompensationBounds(gain_bandwidth_voltage=min_max_units(10, 20e6, 'Hz'),
                                                      gain_bandwidth_current=min_max_units(10, 20e6, 'Hz'),
                                                      compensation_frequency=min_max_units(20, 20e6, 'Hz'),
                                                      pole_zero_ratio=min_max_units(0.125, 8.0, ''))

        output_name = "CHANNEL0"
        self.CHANNEL0 = NiSmuChannelOutputRelay(self, output_name, 0, programing_bounds)
        self._channel_names = [output_name]


if __name__ == '__main__':
    smu4139 = NiPxie4139('PXI1Slot4')  # None)  # Replace resource_name with None for simulated hardware.

    if True:
        from driver_test_codes.ni_pxie_4139_tests import ni_pxie_4139_tests
        ni_pxie_4139_tests(smu4139, do_source_voltage=False, do_source_current=False)
