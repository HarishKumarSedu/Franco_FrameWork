from cl_instr_lib.base_classes.instrument_ni_pxi.instrument_ni_pxi_switch import InstrumentNiPxiSwitch
from niswitch.enums import *

from cl_instr_lib.helpers.check_list_values import check_list_num


class NiPxi2567(InstrumentNiPxiSwitch):
    """Class for controlling a National Instruments 64-Channel PXI Relay Driver Module.
    """

    def __init__(self, resource_name=None, rm_handle=None, logger=None, **kwargs):
        model = 'PXI-2567'   # Unlike other NI PXI instruments, this one doesn't return the 'NI ' prefix in model query!
        super().__init__(model, '2567/Independent', resource_name, rm_handle, logger, **kwargs)

        self._num_relays = self.session.number_of_relays

    def config_relays(self, relay_nums, state):
        """
        Configure 1 or more relay driver channels to the same state.

        :param relay_nums: Identifies which relays channel(s) will have state applied to them. Relays are numbered
            0 to 63. relay_nums may be be an int (0 to 63) identifying a single relay or a list of any length whose
            elements are ints in the range 0 to 63. Relays will be switched in the order they appear in the list.
        :type relay_nums: int | List[int]
        :param state: 'CLOSED' corresponds to the channel pin being pulled to ground by the channel FET. 'OPEN'
            corresponds to a floating pin (FET off).
        :type state: str
        :return: None
        """

        relay_nums = self._check_relay_nums(relay_nums)

        if state == 'CLOSED':
            action = RelayAction.CLOSE
        elif state == 'OPEN':
            action = RelayAction.OPEN
        else:
            raise ValueError(f"Bad state '{state}', should be 'OPEN' or 'CLOSED'.")

        for relay in relay_nums:
            relay_name = f"k{relay}"
            self.session.relay_control(relay_name, action)

    def get_relay_states(self, relay_nums=None):
        """
        Reads existing states of specified relay friver channels.

        :param relay_nums: Identifies which relay channel(s) will be read. Relays are numbered 0 to 63.
            relay_nums may be be an int (0 to 63) identifying a single relay or a list of any length whose
            elements are ints in the range 0 to 63. Relays states will be read in the order they appear in the list.
        :type relay_nums: int | List[int]
        :return: Dict keyed where keys are the elements of relay_num and the values are the states of the corresponding
            relay channels. Values are 'OPEN' (a floating pin), or 'CLOSED' (a pin pulled to ground through a FET).
        :rtype: dict[int: str]
        """

        if relay_nums is None:
            relay_nums = list(range(self._num_relays))
        else:
            relay_nums = self._check_relay_nums(relay_nums)

        return_values = {}
        for relay in relay_nums:
            return_values[relay] = self.session.get_relay_position(f"k{relay}").name
        return return_values

    def disconnect_all(self):
        """Sets all 64 relay driver channels to the 'OPEN' state (pin is floating).
        """

        self.session.disconnect_all()

    # helpers

    def _check_relay_nums(self, relay_nums):
        """Validate an int or a list as corresponding to valid relay channel(s)."""

        if isinstance(relay_nums, int):
            relay_nums = [relay_nums]

        if isinstance(relay_nums, list):
            check_list_num('relay_nums', relay_nums, 0, self._num_relays-1, '', show_max_bad=10, types=(int,))
        else:
            raise ValueError(f"Bad relay_nums {relay_nums}, should be a list of int values in range 0 to "
                             f"{self._num_relays-1}.")

        return relay_nums


if __name__ == '__main__':
    sw2567 = NiPxi2567('PXI1Slot5')  # None)  # Replace resource_name with None for simulated hardware.
