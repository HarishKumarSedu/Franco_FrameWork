from enum import Enum

from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_numeric_vs_list import check_numeric_vs_list


# TODO: Are there SCPI cmds for selecting what is displayed on the the LCD display ?


class PBZ2020A(InstrumentVisa, PowerSupply):
    """Class for controlling Kikusui PBZ2020 and PBZ2020A bipolar power supplies / waveform amplifiers."""

    enum_status_regname = Enum('enum_status_regname', {'QUES': 'QUES', 'OPER': 'OPER'})

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):
        # Setup the simulation code inherited from Instrument.
        super().__init__(visa_resource_name, logger,
                         channel_specific_cmds=('VOLT', 'CURR', 'MEAS'),
                         channel_sel_default=1,
                         channel_sel_cmd='INST:NSEL',
                         model_re='^PBZ20-20A?$',
                         sim_idn='KIKUSUI,PBZ20-20A,ZG002733,1.01',
                         **kwargs)

        self.status_clear()  # Clears all previous errors that might block command execution.

        self.write(f"STAT:OPER:ENAB {0x7FFF}")
        self.write(f"STAT:QUES:ENAB {0x7FFF}")

        #: Object containing the `Channel`_ methods that configure and control the output.
        self.OUTPUT = Channel(self, 'OUTPUT', None)

        self._channel_names = ['OUTPUT']

    # ---------------------------------------------------------------------------

    def reset(self):
        """ Resets the Power Supply to factory defaults, turns output off.
            NOTE: Sets status enable registers to 0x7FFF.
        """

        super().reset()

        # Enable all status bits ... Kikusui defaults for these regs is 0.
        self.write(f"STAT:OPER:ENAB {0x7FFF}")
        self.write(f"STAT:QUES:ENAB {0x7FFF}")

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def output_state(self, on_off=None):
        """
        Queries or writes the state of the Power Supply output. If no input is given, the current state
        of power of the instrument is read back.

        Functionality is the same as the output_state method of the OUTPUT object.

        :param on_off: 'ON'|'OFF'
        :type on_off: str
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        :rtype: str
        """

        # Since there is only 1 output, we can just call the individual channel method.

        return self.OUTPUT.output_state(on_off)

    # ---------------------------------------------------------------------------

    def status_reg_bits(self, regname):
        """
        Queries OPER or QUES status register and returns dictionary showing name-values of bits. Page 76 & 78 of
        the "file://ausapp11/fermata/CL-Instrument-Manuals/Power-Supplies/Kikusui-PBZ20_20A/PBZ_IF_V2_E3.pdf"

        :param regname: Selects which status register will be read:

            * OPER - Operating conditions e.g. measuring, waiting for trigger, CC, CV modes, etc.
            * QUES - Questionable status e.g. , Over Voltage, Over Current, etc.
        :type regname:  str|enum_status_regname
        :return: Dictionary showing name-values of bits
        :rtype: dict
        """

        # TODO: Figure out if we need to set the ENABLE registers to non-default values.

        regname = check_enum_str('regname', regname, self.enum_status_regname)

        if regname.name == 'OPER':
            conditions = {'Measuring': 4, 'Waiting for TRIG': 5, 'Constant Voltage': 8,
                          'Constant Current': 10, 'Transient Delay': 11, 'Program': 14}
        elif regname.name == 'QUES':
            conditions = {
                'Over Voltage': 0, 'Over Current': 1, 'AC Power Off': 3, 'Over Temp': 4, 'Over Power': 5,
                'V-Limit': 8, 'I-Limit': 9, 'Shutdown Alarm': 11, 'Power Limit': 12, 'UNLOCKED': 13
            }
        else:
            raise ValueError(f"Bad status regname '{regname}', needs to be 'OPER' or 'QUES'.")

        value = self.query(f'STAT:{regname.value}:COND', int)

        result = {}
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    # ---------------------------------------------------------------------------

    def beep(self, on_off=None):
        """
        Turns the buzzer on and off.

        :param on_off: 'ON'|'OFF'
        :type on_off: str
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        :rtype: str
        """

        if on_off is None:
            return self.on_off.to_api(self.query("SYST:CONF:BEEP:STAT?", int))

        on_off = self.on_off.to_inst(on_off)

        self.write("SYST:CONF:BEEP:STAT", on_off)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.
        Does not clear the STB, call status_clear to do that, but beware status_clear clears the error
        queue as well.

        :return: Names-values of the 3 status bits as a dict.
        :rtype: Dict
        """

        value = self.query('*STB?', int)

        conditions = {'ERR': 2, 'QUES': 3, 'MAV': 4, 'ESB': 5, 'RQS': 6, 'OPER': 7}

        result = {}
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """
        Clears the STB (status byte) and the error queue by sending \*CLS command.
        """

        self.write('*CLS')

        self.log_inst_errors()


class Channel(PSChannel_ABC):
    """Implements the methods to control a output of a PBZ20-20A bipolar power supply / waveform amplifier."""

    resp_volt = (3.5e-6, 10e-6, 35e-6, 100e-6)
    resp_curr = (35e-6, 100e-6, 350e-6, 1e-3)
    sweep_time = min_max_units(1e-6, 1000.0, 'Seconds')
    dc_voltage_bounds_unip = min_max_units(0.2, 21, 'Volts')
    dc_voltage_bounds_bip = min_max_units(-21, 21, 'Volts')
    dc_current_bounds = min_max_units(-21, 21, 'Amps')
    ovp_unip_cv_limits = min_max_units(-0.2, 21, 'V')
    ovp_bip_cv_limits = min_max_units(-21, 21, 'V')
    ocp_cc_pos_limits = min_max_units(0.2, 21.5, 'A')
    ocp_cc_neg_limits = min_max_units(-21.5, -0.2, 'A')
    ac_voltage_bounds_unip = min_max_units(-21, 21, 'VoltsPkPk')
    ac_voltage_bounds_bip = min_max_units(-42, 42, 'VoltsPkPk')
    ac_current_bounds = min_max_units(-42, 42, 'AmpsPkPk')
    gain_range_cv = min_max_units(-20, 20, 'V/V')
    gain_range_cc = min_max_units(-20, 20, 'A/V')
    aperture_sec = min_max_units(0.1e-3, 3600, 'seconds')
    freq_hz = min_max_units(1e-2, 1.05e5, 'freq_hz')
    angle_units = min_max_units(0, 359, 'degrees')
    mode_to_parameter = {'CV': 'VOLT', 'CC': 'CURR'}
    # enum_trig_in_modes = Enum('enum_trig_in_modes', {'AUTO': 'AUTO', 'RISING': 'EXTPOS', 'FALLING': 'EXTNEG'})
    # enum_trigger_modes = Enum('enum_trigger_modes', {'MARKER': '1', 'SYNC': '0', 'OFF': 'OFF'})
    # enum_ac_sweep_mode = Enum('enum_ac_sweep_mode', {'LOG': 'LOG', 'LINEAR': 'LIN'})
    # enum_trig_pol = Enum('enum_trig_in_modes', {'HIGH': 'POS', 'LOW': 'NEG'})
    enum_meas_functions = Enum('enum_meas_functions', {'DC': 'DC', 'AC': 'AC', 'DCAC': 'DCAC', 'PEAK': 'PEAK'})
    enum_ac_sources = Enum('enum_ac_sources', {'CV': 'VoltsPkPk', 'CC': 'AmpsPkPk'})
    enum_shapes = Enum('enum_shapes', {'SINE': 'SIN', 'SQUARE': 'SQU', 'TRIANGLE': 'TRI'})
    enum_polarities = Enum('enum_polarity', {'BIP': 'BIP', 'UNIP': 'UNIP'})
    # enum_sync_features = Enum('enum_sync_features', {'MASTER': 'MAST', 'SLAVE': 'SLAV', 'SLAVE_END': 'STER',
    #                                                 'OFF': 'OFF'})
    enum_config_mode = Enum('enum_config_mode', {'CC': 'CC', 'CV': 'CV'})
    enum_sources = Enum('enum_sources', {'INT': 'INT', 'EXT': 'EXT', 'BOTH': 'BOTH'})
    enum_terminals = Enum('enum_terminals', {'BNC': 'BNC', 'J1': 'J1', 'BOTH': 'BOTH'})
    enum_prot_modes = Enum('enum_prot_modes', {'LIMIT': 'LIM', 'TRIP': 'TRIP'})
    enum_prot_action = Enum('enum_prot_action', {'OUT_OFF': '0', 'POW_OFF': '1'})
    enum_meas = Enum('enum_meas', {'VOLTS_DC': 'VOLT:DC', 'VOLTS_RMS': 'VOLT:AC', 'VOLTS_PK_MIN': 'VOLT:MIN',
                                   'VOLTS_PK_MAX': 'VOLT:MAX', 'CURRENT_DC': 'CURR:DC', 'CURRENT_RMS': 'CURR:AC',
                                   'CURRENT_PK_MIN': 'CURR:MIN', 'CURRENT_PK_MAX': 'CURR:MAX'})

    def __init__(self, power_supply, channel_name, programming_bounds):
        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)

        self.on_off = power_supply.on_off
        self.query = power_supply.query
        self.write = power_supply.write
        self.log = power_supply.log
        self.log_unused_args = power_supply.log_unused_args
        self.log_inst_errors = power_supply.log_inst_errors

    def source_voltage(self, voltage=None, ilimit=None, neg_ilimit=None, *args, **kwargs):
        """
        Queries or sets the voltage output level and current limits. Will force mode to Constant Voltage (CV) mode.

        This method included for inter-changeability with other power supplies that would be used as rail sources in the
        validation framework. Other methods provide for more of the features of the PBZ20-20A.

        :param voltage: Voltage to output in Volts.
        :type voltage: float|None
        :param ilimit: Positive current limit to set in Amps.
        :type ilimit: float|None
        :param neg_ilimit: Negative current limit to set in Amps.
        :type neg_ilimit: float|None
        :param args: Catches any unused args and and displays them in the log.
        :type args: int|float
        :param kwargs: Catches any keyword errors and displays them in the log.
        :type kwargs: kwargs
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing all the
            present settings. The dictionary key/value pairs correspond to the parameters of this method.

        :rtype: dict
        """

        self.log_unused_args(args, kwargs)

        source = self.signal_source()['source']
        if source not in ('INT', 'BOTH'):
            raise ValueError(f"Before reading or setting the source value, set signal source to 'INT' or 'BOTH'. "
                             f"Presently source is '{source}'.")

        mode = self.query('FUNC:MODE')
        if mode != 'CV':
            self.config(mode='CV')

        if all([v is None for v in (voltage, ilimit, neg_ilimit)]):
            return_values = {}
            return_values.update(voltage=self.dc_source())
            protection_values = self.prot_curr()
            return_values.update(ilimit=protection_values["pos_level"])
            return_values.update(neg_ilimit=protection_values["neg_level"])
            return return_values

        # Check user inputs

        polarity = self.query('FUNC:POL', self.enum_polarities)
        if polarity.name == 'BIP':
            voltage = check_range('voltage', voltage, self.dc_voltage_bounds_bip)
            ilimit = check_range('ilimit', ilimit, self.dc_current_bounds)
            neg_ilimit = check_range('neg_ilimit', neg_ilimit, self.dc_current_bounds)
        else:
            voltage = check_range('voltage', voltage, self.dc_voltage_bounds_unip)
            ilimit = check_range('ilimit', ilimit, self.dc_current_bounds)
            neg_ilimit = check_range('neg_ilimit', neg_ilimit, self.dc_current_bounds)

        # Everything is now checked - write to instrument:

        if voltage is not None:
            self.dc_source(voltage)

        if ilimit is not None:
            self.prot_curr(pos_level=ilimit)

        if neg_ilimit is not None:
            self.prot_curr(neg_level=neg_ilimit)

        # No log_inst_errors because it is in the other methods we are calling.

    # TODO: Someday add source_current.

    def config(self, polarity=None, mode=None, volt_resp_time=None, curr_resp_time=None, sensing=None, *args, **kwargs):
        """
        Queries or sets parameters on the config menu, first page.

        NOTE - If you have the PBZ2020\ **A** model, you can achieve peak transient current output (120A) by
        configuring as follows (from the Kikusui reference card). This does not apply to non-A models which are
        limited to 20A max. See spec sheet p10.

            * Turn output OFF
            * polarity = BIP or UNIP
            * mode='CV'
            * curr_resp_time = 1e-3
            * dc_source(0)
            * Turn output ON
            * Program the desired output voltage ( BOOM! )

        :param polarity: Cannot be changed while output is ON.

            * None - no effect unless all args are None, see above.
            * 'BIP' - bipolar operation (default)
            * 'UNIP' - unipolar operation
        :type polarity: str|None
        :param mode: Cannot be changed while output is ON.

            * None - no effect unless all args are None, see above.
            * 'CV' - supply regulates a constant output voltage. (default)
            * 'CC' - supply regulates a constant output current
        :type mode: str|None
        :param volt_resp_time: Rise/fall time for rated load in CV mode, in seconds.

            * None - no effect unless all args are None, see above.
            * fixed values - 3.5e-6 (default), 10e-6, 35e-6, 100e-6
        :type volt_resp_time: None|fixed values
        :param curr_resp_time: Rise/fall time for rated load  in CC mode, in seconds.

            * None - no effect unless all args are None, see above.
            * fixed values - 35e-6 (default), 100e-6, 350e-6, 1e-3
        :type curr_resp_time: None|Fixed values
        :param sensing: Enables remote sense input on rear panel. Cannot be changed while output is ON. For ON accepts:
            'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'. Query always returns 'ON' or 'OFF'.
        :type sensing: str|int|bool
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
                 the present settings.
        :rtype: dict|None
        """

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {polarity, mode, volt_resp_time, curr_resp_time, sensing}):
            return_val = {}
            return_val.update(polarity=self.query('FUNC:POL?', self.enum_polarities).name)
            return_val.update(mode=self.query('FUNC:MODE?', self.enum_config_mode).name)
            return_val.update(volt_resp_time=(self.query("VOLT:RESP?", float)))
            return_val.update(curr_resp_time=(self.query("CURR:RESP?", float)))
            return_val.update(sensing=self.on_off.to_api(self.query('SYST:CONF:RSEN?', int)))
            return return_val

        output_state = self.output_state()

        # Check all before writing anything.
        if polarity is not None:
            if output_state == 'ON':
                raise ValueError("Changing output polarity is not allowed while output is ON.")
            polarity = check_enum_str('polarity', polarity, self.enum_polarities)

        if mode is not None:
            if output_state == 'ON':
                raise ValueError(f"Changing output mode is not allowed while output is ON.")
            mode = check_enum_str('mode', mode, self.enum_config_mode)

        if curr_resp_time is not None:
            curr_resp_time = check_numeric_vs_list('curr_resp_time', curr_resp_time, self.resp_curr, rel_tol=0.001)

        if volt_resp_time is not None:
            volt_resp_time = check_numeric_vs_list('volt_resp_time', volt_resp_time, self.resp_volt, rel_tol=0.001)

        if sensing is not None:
            if output_state == 'ON':
                raise ValueError("Changing sensing is not allowed while output is ON.")
            sensing = self.on_off.to_inst(sensing)

        # Everything is now checked - write to instrument:

        if polarity is not None:
            self.write("FUNC:POL", polarity.value)

        if mode is not None:
            self.write("FUNC:MODE", mode.value)

        if volt_resp_time is not None:
            self.write("VOLT:RESP", volt_resp_time)

        if curr_resp_time is not None:
            self.write("CURR:RESP", curr_resp_time)

        if sensing is not None:
            self.write("SYST:CONF:RSEN", sensing)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def signal_source(self, source=None, ext_terminal=None, *args, **kwargs):
        """
        Defines where input to the waveform amplifier comes from. See Users Manual page 36 Circuit Configuration
        Diagram, and page 54 Using External Control Signals.

        :param source: cannot be changed while output is ON.

            * 'INT' - Use only the internal DC and AC sources.
            * 'EXT' - Enables external inputs as selected by ext_terminal.
            * 'BOTH' - Signal is the sum of internal and external sources.
        :type source: str
        :param ext_terminal: Cannot be changed while output is ON.

            * 'BNC' - Ext AC signal in from BNC connector EXT SIG IN on front panel.
            * 'J1' - Control DC output (V or I) using voltage input from rear panel
            * 'BOTH' - Control using both of the above.
        :type ext_terminal: str
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
                 the present settings.
        :rtype: dict|None
        """

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {source, ext_terminal}):
            return_val = {}
            return_val.update(source=self.query('FUNC:SOUR?', self.enum_sources).name)
            return_val.update(ext_terminal=self.query('FUNC:EXT:TERM?', self.enum_terminals).name)
            return return_val

        output_state = self.output_state()
        if output_state == 'ON':
            raise ValueError("Changing signal source or ext_terminal is not allowed while output is ON.")

        # Check both before writing anything.
        source = check_enum_str('source', source, self.enum_sources)
        ext_terminal = check_enum_str('ext_terminal', ext_terminal, self.enum_terminals)

        if source is not None:
            self.write("FUNC:SOUR", source.value)

        if ext_terminal is not None:
            self.write("FUNC:EXT:TERM", ext_terminal.value)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def ext_source_gain(self, gain=None, *args, **kwargs):
        """
        When using external signal source, configure the gain for the signal path.

        This method applies the gain to whichever operating mode is presently in effect ('CV' or 'CC').

        Gain can only be read back or set if signal_source is set to 'EXT' or 'BOTH', and ext_terminal to 'BNC' or
        'BOTH'. Gain cannot be read back if signal_source is 'INT', or ext_terminal is 'J1'.

        :param gain: CV gain is -20 to +20V/V. CC gain is -20A/V to +20 A/V. Negative gain is signal inversion.
        :type gain: float|int
        :return: If no arguments are supplied, instrument is queried and the gain is returned as a floating point number
        :rtype: float
        """

        self.log_unused_args(args, kwargs)

        tmp = self.signal_source()
        source, ext_terminal = [tmp[k] for k in ('source', 'ext_terminal')]
        if source == 'INT' or ext_terminal == 'J1':
            raise ValueError(f"Before reading or setting the gain, set signal_source to 'EXT' or 'BOTH', and "
                             f"ext_terminal to 'BNC' or 'BOTH'. Presently source is '{source}' and"
                             f" ext_terminal is '{ext_terminal}'.")

        mode = self.config()['mode']

        if gain is None:
            ret_values = {}
            cmd = f'FUNC:EXT:{self.mode_to_parameter[mode]}:GAIN?'
            ret_values.update(gain=self.query(cmd, float))
            return ret_values

        if mode == 'CV':
            gain = check_range('gain', gain, self.gain_range_cv)
        else:
            gain = check_range('gain', gain, self.gain_range_cc)

        # Although the instrument provides separate SCPI commands for voltage and current gain, writing to the one not
        # presently in effect does cause an error in the instrument. See Users Manual page 57.

        if gain is not None:
            self.write(f"FUNC:EXT:{self.mode_to_parameter[mode]}:GAIN", gain)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def dc_source(self, value=None, *args, **kwargs):
        """
        Queries or sets parameters the DC source value voltage or current depending on present mode of operation.

        Note that if no argument is supplied, the level is returned as a floating point number of Volts or Amps.

        :param value: Can only be applied if signal source is 'INT' or 'BOTH'.

            * floating point number of volts if operating in CV mode.
            * floating point number of amps if operating in CC mode.
        :type value: float
        :return: The current DC source voltage setting
        :rtype: float
        """

        self.log_unused_args(args, kwargs)

        source = self.signal_source()['source']
        if source not in ('INT', 'BOTH'):
            raise ValueError(f"Before reading or setting the source value, set signal source to 'INT' or 'BOTH'. "
                             f"Presently source is '{source}'.")

        tmp = self.config()
        mode, polarity = [tmp[k] for k in ('mode', 'polarity')]

        if value is None:
            return self.query(f"{self.mode_to_parameter[mode]}", float)

        if mode == 'CV':
            if polarity == 'UNIP':
                value = check_range('value', value, self.dc_voltage_bounds_unip)
            else:
                value = check_range('value', value, self.dc_voltage_bounds_bip)
        else:
            value = check_range('value', value, self.dc_current_bounds)

        self.write(f"{self.mode_to_parameter[mode]}", value)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    # TODO: Sweep functionality
    # TODO: Warn on combined effect of AC + DC on amplitude ranges.

    def ac_source(self, on_off=None, shape=None, freq_hz=None, phase_enb=None, angle=None, duty=None,
                  amplitude_pkpk=None, *args, **kwargs):
        """
        Queries or sets many of the parameters on the AC menu. Sweep not supported. The dictionary key/value pairs
        correspond to the parameters of this method.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'. Query always
            returns 'ON' or 'OFF'.
        :type on_off: str|int|bool
        :param shape: Shape of the AC waveform

            * 'SINE' - sinusoidal waveform. Args phase_enb and angle apply only to this choice.
            * 'SQUARE' - square wave. Arg duty cycle only applies to this choice.
            * 'TRIANGLE' - triangle waveform.
        :type shape: str|enum_shapes
        :param freq_hz: The frequency in Hz of the AC waveform.
        :type freq_hz: float
        :param phase_enb: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'. Query always
            returns 'ON' or 'OFF'.

            * ON - means starting phase of AC signal is controlled as per angle Arg.
            * OFF - starting phase is unspecified.
        :type phase_enb: str|int|bool
        :param angle: Starting phase of AC signal in degrees.
        :type angle: float
        :param duty: Only applicable with the SQUARE waveform. Floating point number with allowable ranges and
            resolution depending on signal freq. This is passed as a percent value. Example: "duty=0.5" means 0.5% duty
            cycle, & "duty=50" means 50% duty cycle.
        :type duty: float
        :param amplitude_pkpk: Floating point number, range depends on operating mode and polarity.

            * -42 to 42 Volts(CV) or Amps(CC) in BIP
            * -21 to 21 Volts(CV) in UNIP
            * -42 to 42 Amps(CC) in UNIP
        :type amplitude_pkpk: int
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
            the present settings.
        :rtype: dict|None
        """

        self.log_unused_args(args, kwargs)

        source = self.signal_source()['source']
        if source not in ('INT', 'BOTH'):
            raise ValueError(f"Before reading or setting the source value, set signal_source to 'INT' or 'BOTH'. "
                             f"Presently source is '{source}'.")

        tmp = self.config()
        mode, polarity = [tmp[k] for k in ('mode', 'polarity')]

        if all(v is None for v in {on_off, shape, freq_hz, phase_enb, angle, duty, amplitude_pkpk}):
            return_val = {}
            return_val.update(on_off=self.on_off.to_api(self.query("AC:STAT?", int)))
            return_val.update(shape=self.query("FUNC?", self.enum_shapes).name)
            return_val.update(freq_hz=self.query("FREQ?", float))
            angle, phase_enb = self.query("PHAS?").split(',')
            return_val.update(angle=float(angle))
            return_val.update(phase_enb=self.on_off.to_api(phase_enb))
            return_val.update(duty=self.query("SQU:DCYC?", float))
            return_val.update(amplitude_pkpk=self.query(f"{self.mode_to_parameter[mode]}:AC?", float))
            return return_val

        # Check all of the inputs before writing anything - all good or nothing happens.

        on_off = self.on_off.to_inst(on_off)
        shape = check_enum_str('shape', shape, self.enum_shapes)
        freq_hz = check_range('freq_hz', freq_hz, self.freq_hz)
        phase_enb = self.on_off.to_inst(phase_enb)
        angle = check_range('angle', angle, self.angle_units)

        if duty is not None:
            # Prevent error that would be caused by attempting to set duty for non-SQU waveform.
            shape_state = shape
            if shape_state is None:
                shape_state = self.query("FUNC", self.enum_shapes)
            if shape_state.name != 'SQUARE':
                raise ValueError(f"Cannot set duty cycle for shape '{shape_state.name}'.")

            # Duty cycle limits depend on freq.
            freq_hz_state = freq_hz
            if freq_hz_state is None:
                freq_hz_state = self.query("FREQ?", float)

            fixed = False
            if freq_hz_state < 100:
                duty_min, duty_max, duty_res = [0.1, 99.9, 0.1]
            elif freq_hz_state < 1000:
                duty_min, duty_max, duty_res = [1.0, 99.0, 1.0]
            elif freq_hz_state < 10000:
                duty_min, duty_max, duty_res = [10.0, 90.0, 10.0]
            else:
                duty_min, duty_max, duty_res = [50.0, 50.0, 1.0]
                fixed = True

            if not (duty_min <= duty <= duty_max):
                if not fixed:
                    raise ValueError(
                        f"Bad duty cycle {duty} for freq {freq_hz_state:.3g} Hz, should be {duty_min:3.1f} to "
                        f"{duty_max:3.1f} percent. Resolution {duty_res}%")
                else:
                    raise ValueError(
                        f"Bad duty cycle {duty} for freq {freq_hz_state:.3g} Hz, for >= 10kHz must use 50% duty cycle.")

        # Amplitude ranges depend on mode and polarity.

        if mode == 'CV':
            if polarity == 'UNIP':
                amplitude_pkpk = check_range('amplitude_pkpk', amplitude_pkpk, self.ac_voltage_bounds_unip)
            else:
                amplitude_pkpk = check_range('amplitude_pkpk', amplitude_pkpk, self.ac_voltage_bounds_bip)
        else:
            amplitude_pkpk = check_range('amplitude_pkpk', amplitude_pkpk, self.ac_current_bounds)

        # End of checks - start writing to instrument.

        if on_off is not None:
            self.write("AC:STAT", on_off)

        if shape is not None:
            self.write("FUNC", shape.value)

        if freq_hz is not None:
            self.write("FREQ", freq_hz)

        # TODO: Be sure to test all combinations of setting/not setting phase enb.
        # Instrument bundles angle and phase_enb into the same SCPI command!
        tmp = [v is not None for v in (angle, phase_enb)]
        if any(tmp):  # Eliminates [F, F] which is no changes.
            if all(tmp):  # Handles changing both.
                self.write("PHASE", f"{angle}, {phase_enb}")
            else:
                existing_angle, existing_phase_enb = self.query("PHAS?").split(',')
                if tmp == [False, True]:
                    self.write("PHAS", existing_angle, phase_enb)
                else:
                    self.write("PHASE", angle, existing_phase_enb)

        if duty is not None:
            self.write("SQU:DCYC", duty)

        # SCPI command used depends on output mode: CV or CC.
        if amplitude_pkpk is not None:
            self.write(f"{self.mode_to_parameter[mode]}:AC", amplitude_pkpk)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------
    # TODO: Meas trigger features.

    def meas_config(self, function=None, aperture_sec=None):
        """
        Configure which measurement function will be performed and displayed on the LCD when triggered either by AUTO
        (default) or INT or EXT source (source selection not implemented in driver).

            * NOTE - Invoking the meas(item) method also changes what is displayed on the LCD.

        :param function:

            * 'AC' - AC RMS (AC coupling).
            * 'DC' - direct current.
            * 'DCAC' - RMS of both = SQRT(DC^2 + AC^2)
            * 'PEAK' - Maximum and Minimum.
        :type function: str|enum_meas_functions
        :param aperture_sec: Measurement time. 0.1e-3 to 3600 seconds.
        :type aperture_sec:  float
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
                 the present settings.
        :rtype: dict|None
        """

        if all(v is None for v in {function, aperture_sec}):
            return_val = {}
            return_val.update(function=self.query("SENS:FUNC?", self.enum_meas_functions).name)
            return_val.update(aperture_sec=self.query("SENS:APER?", float))
            return return_val

        function = check_enum_str('function', function, self.enum_meas_functions)

        aperture_sec = check_range('aperture_sec', aperture_sec, self.aperture_sec)

        if function is not None:
            self.write("SENS:FUNC", function.name)

        if aperture_sec is not None:
            self.write("SENS:APER", aperture_sec)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def meas_fetch(self, item=None):
        """
        Fetches already measured data without initiating a new measurement. Will raise a value error if no measurements
        have been taken already.

        :param item:

            * 'VOLTS_DC' - DC component of voltage across the load.
            * 'VOLTS_RMS' - RMS value of waveform voltage across the load = SQRT(Vdc^2 + ACrms^2)
            * 'VOLT_PK_MIN'- the lowest excursion of the voltage waveform across the load.
            * 'VOLT_PK_MAX' - the highest excursion of the voltage waveform across the load.
            * 'CURRENT_DC' - DC component of current through the load.
            * 'CURRENT_RMS' - RMS value of current through the load = SQRT(Idc^2 + Iacrms^2)
            * 'CURRENT_PK_MIN' - the lowest excursion of the current through the load.
            * 'CURRENT_PK_MAX' - the highest excursion of the current through the load.
        :type item: str|enum_meas
        :return: Specified measurement
        :rtype: float
        """

        if item is None:
            msg = ", ".join([f"'{x.name}'" for x in self.enum_meas])
            raise ValueError(f"Bad item '{item}', should be one of: {msg}.")

        item_obj = check_enum_str('item', item, self.enum_meas)

        return self.query(f"FETC:{item_obj.value}?", float)

    # ---------------------------------------------------------------------------

    def meas(self, item=None):
        """
        Perform the specified measurement and return the result. If no measurement specified then all measurement
        results are returned in a dictionary.

        :param item:

            * 'VOLTS_DC' - DC component of voltage across the load.
            * 'VOLTS_RMS' - RMS value of waveform voltage across the load = SQRT(Vdc^2 + ACrms^2)
            * 'VOLT_PK_MIN'- the lowest excursion of the voltage waveform across the load.
            * 'VOLT_PK_MAX' - the highest excursion of the voltage waveform across the load.
            * 'CURRENT_DC' - DC component of current through the load.
            * 'CURRENT_RMS' - RMS value of current through the load = SQRT(Idc^2 + Iacrms^2)
            * 'CURRENT_PK_MIN' - the lowest excursion of the current through the load.
            * 'CURRENT_PK_MAX' - the highest excursion of the current through the load.
        :type item: str|enum_meas
        :return: Specified measurement | All measurements
        :rtype: float|dict
        """

        if item is None:
            ret_val = {}
            for element in self.enum_meas:
                ret_val.update({element.name: self.query(f"MEAS:{element.value}", float)})
            return ret_val

        item_obj = check_enum_str('item', item, self.enum_meas)

        return self.query(f"MEAS:{item_obj.value}?", float)

    def measure_voltage(self):
        """Returns the measured value at the output in Volts."""

        return self.meas('VOLTS_DC')

    def measure_current(self):
        """Returns the measured value at the output in Amperes."""

        return self.meas('CURRENT_DC')

    # ---------------------------------------------------------------------------

    def output_state(self, on_off=None):
        """
        Queries or writes the state of the Power Supply output. If no input is given, the current state
        of power of the instrument is read back.

        :param on_off: 'ON'|'OFF'
        :type on_off: str
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        :rtype: str
        """

        if on_off is None:
            return self.on_off.to_api(self.query('OUTP:STAT?', int))

        on_off = self.on_off.to_inst(on_off)

        self.write("OUTP:STAT", on_off)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def prot_curr(self, prot_mode=None, pos_level=None, neg_level=None):
        """
        Define current protection mode and levels.

        :param prot_mode: Defines what will happen when a current excursion exceeds a limit.

            * 'LIMIT' - Current excursions will be limited to the values specified.
            * 'TRIP' - A Current excursion reaching the one of the specified values will cause either the output to \
                be disabled or the power switch to turn off the entire PBZ20-20. The choice is set by the method \
                prot_ocp_ovp_action.
        :type prot_mode: str
        :param pos_level: The most positive Current in the + direction (out the + terminal).
        :type pos_level: int|float
        :param neg_level: The most current in the - direction (into the + terminal).
        :type neg_level: int|float
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
                 the present settings.
        :rtype: dict|None
        """

        if all(v is None for v in {prot_mode, pos_level, neg_level}):
            return_val = {}
            prot_mode_state = self.query('CURR:PROT:STAT?', self.enum_prot_modes).name
            return_val.update(prot_mode=prot_mode_state)
            if prot_mode_state == 'TRIP':
                return_val.update(pos_level=self.query('CURR:PROT:OVER?', float))
                return_val.update(neg_level=self.query('CURR:PROT:UND?', float))
            else:
                return_val.update(pos_level=self.query('CURR:LIM:UPP?', float))
                return_val.update(neg_level=self.query('CURR:LIM:LOW?', float))
            return return_val

        # Check all inputs, apply only if all good.
        prot_mode = check_enum_str("prot_mod", prot_mode, self.enum_prot_modes)

        # Get present prot_mode, because SCPI cmd for setting levels changes depending on mode.
        prot_mode_state = prot_mode
        if prot_mode_state is None:
            prot_mode_state = self.query('CURR:PROT:STAT?', self.enum_prot_modes)

        pos_level = check_range('pos_level', pos_level, self.ocp_cc_pos_limits)
        neg_level = check_range('neg_level', neg_level, self.ocp_cc_neg_limits)

        neg_level_state = neg_level
        if neg_level_state is None:
            if prot_mode_state.name == 'TRIP':
                neg_level_state = self.query('CURR:PROT:UND?', float)
            else:
                neg_level_state = self.query('CURR:LIM:LOW?', float)

        pos_level_state = pos_level
        if pos_level_state is None:
            if prot_mode_state.name == 'TRIP':
                pos_level_state = self.query('CURR:PROT:OVER?', float)
            else:
                pos_level_state = self.query('CURR:LIM:UPP?', float)

        if prot_mode is not None:
            self.write("CURR:PROT:STAT", prot_mode.value)

        if pos_level is not None:
            if prot_mode_state.name == 'TRIP':
                self.write("CURR:PROT:OVER", pos_level)
            elif prot_mode_state.name == 'LIMIT':
                self.write("CURR:LIM:UPP", pos_level)
            else:
                raise KeyError(f"Bad prot_mode_state '{prot_mode_state.name}'.")

        if neg_level is not None:
            if prot_mode_state.name == 'TRIP':
                self.write("CURR:PROT:UND", neg_level)
            elif prot_mode_state.name == 'LIMIT':
                self.write("CURR:LIM:LOW", neg_level)
            else:
                raise KeyError(f"Bad prot_mode_state '{prot_mode_state.name}'.")

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def prot_volt(self, prot_mode=None, pos_level=None, neg_level=None):
        """
        Define voltage protection mode and levels.

        :param prot_mode: Defines what will happen when a voltage excursion exceeds a limit.

            * 'LIMIT' - Voltage excursions will be limited to the values specified.
            * 'TRIP' - A voltage excursion reaching the one of the specified values will cause either the output to be \
                disabled or the power switch to turn off the entire PBZ20-20. The choice is set by the method \
                prot_ocp_ovp_action.
        :type prot_mode: str|enum_prot_modes
        :param pos_level: The most positive voltage allowed.
        :type pos_level: int|float
        :param neg_level: The most negative voltage allowed.
        :type neg_level: int|float
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
                 the present settings.
        :rtype: dict|None
        """

        if all(v is None for v in {prot_mode, pos_level, neg_level}):
            return_val = {}
            prot_mode_state = self.query('VOLT:PROT:STAT?', self.enum_prot_modes).name
            return_val.update(prot_mode=prot_mode_state)
            if prot_mode_state == 'TRIP':
                return_val.update(pos_level=self.query('VOLT:PROT:OVER?', float))
                return_val.update(neg_level=self.query('VOLT:PROT:UND?', float))
            else:
                return_val.update(pos_level=self.query('VOLT:LIM:UPP?', float))
                return_val.update(neg_level=self.query('VOLT:LIM:LOW?', float))
            return return_val

        # Check all inputs, apply only if all good.
        prot_mode = check_enum_str("prot_mode", prot_mode, self.enum_prot_modes)
        prot_mode_state = prot_mode  # SCPI cmd for setting levels changes depending on mode.
        if prot_mode_state is None:
            prot_mode_state = self.query('VOLT:PROT:STAT?', self.enum_prot_modes)

        polarity = self.query('FUNC:POL?', self.enum_polarities)

        if polarity.name == 'UNIP':
            pos_level = check_range('pos_level', pos_level, self.ovp_unip_cv_limits)
            neg_level = check_range('neg_level', neg_level, self.ovp_unip_cv_limits)
        else:
            pos_level = check_range('pos_level', pos_level, self.ovp_bip_cv_limits)
            neg_level = check_range('neg_level', neg_level, self.ovp_bip_cv_limits)

        neg_level_state = neg_level
        if neg_level_state is None:
            if prot_mode_state.name == 'TRIP':
                neg_level_state = self.query('VOLT:PROT:UND?', float)
            else:
                neg_level_state = self.query('VOLT:LIM:LOW?', float)

        pos_level_state = pos_level
        if pos_level_state is None:
            if prot_mode_state.name == 'TRIP':
                pos_level_state = self.query('VOLT:PROT:OVER?', float)
            else:
                pos_level_state = self.query('VOLT:LIM:UPP?', float)

        if neg_level_state > pos_level_state:
            if neg_level is not None:
                self.log.warning(
                    f"Requested neg_level {neg_level}V ignored, cannot be higher than pos_level {pos_level_state}V. "
                    f"neg_level will be set equal to pos_level.")
            if pos_level is not None:
                self.log.warning(
                    f"Requested pos_level {pos_level}V ignored, cannot be lower than neg_level {neg_level_state}V. "
                    f"pos_level will be set equal to neg_level.")

        if neg_level is not None and prot_mode_state.name == 'TRIP' and polarity.name == 'UNIP':
            if neg_level != -0.2:
                self.log.warning(f"Requested neg_level {neg_level}V ignored, with prot_mode 'TRIP' and "
                                 f"polarity 'UNIP' supply will limit to -0.2V. ")

        # All inputs good, now write them.
        if prot_mode is not None:
            self.write("VOLT:PROT:STAT", prot_mode.value)

        if pos_level is not None:
            if prot_mode_state.name == 'TRIP':
                self.write("VOLT:PROT:OVER", pos_level)
            elif prot_mode_state.name == 'LIMIT':
                self.write("VOLT:LIM:UPP", pos_level)
            else:
                raise KeyError(f"Bad prot_mode_state '{prot_mode_state.name}'.")

        if neg_level is not None:
            if prot_mode_state.name == 'TRIP':
                self.write("VOLT:PROT:UND", neg_level)
            elif prot_mode_state.name == 'LIMIT':
                self.write("VOLT:LIM:LOW", neg_level)
            else:
                raise KeyError(f"Bad prot_mode_state '{prot_mode_state.name}'.")

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def prot_clear(self):
        """If the output switches off due to an OCP or OVP event, you must call this
        method to clear the alarm condition before re-enabling the output."""

        self.write('OUTP:PROT:CLE')

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    def prot_ocp_ovp_action(self, action=None):
        """
        Define what action will be taken when an Over Current Protection or Over Voltage Protection is activated.

        :param action: Action that will occur when OCP or OVP is activated.

            * 'OUT_OFF' - Output switches off. PBZ20-20 power switch stays on.
            * 'POW_OFF' - PBZ20-20 power switch switches itself off powering down the supply.
        :type action: str
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
                 the present settings.
        :rtype: str|None
        """

        if action is None:
            response = self.query("SYST:CONF:BTR:PROT?", self.enum_prot_action).name
            return response

        action = check_enum_str('action', action, self.enum_prot_action)

        self.write("SYST:CONF:BTR:PROT", action.value)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------
    #
    # def sync_operation(self, sync_op=None):
    #     """
    #     Sets the synchronous operation mode. Set one unit as the master unit, and set the other units as either slave
    #     units or slave end units. Set unit as slave end unit if you want to use TRIG OUT signals.
    #
    #     :param sync_op: Select the synchronous operation mode.
    #
    #         * 'OFF' - Do not perform synchronous operation (default).
    #         * 'MASTER' - Master unit.
    #         * 'SLAVE' - Slave unit.
    #         * 'SLAVE_END' - Slave end unit.
    #     :type sync_op: str|enum_sync_features
    #     :return: If no arguments are supplied, the instrument is queried and the state of the operation mode is
    #              returned.
    #     :rtype: None|str
    #     """
    #     if sync_op is None:
    #         return self.query("SYST:CONF:SYNC:OPER?", self.enum_sync_features).name
    #
    #     sync_op = check_enum_str('sync', sync_op, self.enum_sync_features).value
    #
    #     self.write("SYST:CONF:SYNC:OPER", sync_op)
    #
    #     self.log_inst_errors()

    def trigger(self, trig_out_output=None, *args, **kwargs):
        """
        Query or set the state of the trigger output.

        :param trig_out_output: Trigger signal output. Transmits the synchronization signal for AC signals.

            * 'OFF'(0) - Do not generate trigger signal output (default).
            * 'ON'(1) - Generate trigger signal output.
        :type trig_out_output: str|int|bool
        :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
                 the present settings.
        :rtype: dict|None
        """

        self.log_unused_args(args, kwargs)
        if trig_out_output is None:
            return_val = {}
            return_val.update(trig_out_output=self.on_off.to_api(self.query("OUTP:TRIG:STAT?", int)))
            return return_val

        # Performing checks on the user input
        trig_out_output = self.on_off.to_inst(trig_out_output)

        # Everything looks good, write to the instrument.
        if trig_out_output is not None:
            self.write("OUTP:TRIG:STAT", trig_out_output)

        self.log_inst_errors()

    # ---------------------------------------------------------------------------

    # def trigger(self, trig_out_output=None, trig_in_type=None, trig_in_pol=None, trig_out_type=None, trig_out_pol=None,
    #             trig_freq=None, *args, **kwargs):
    #     """
    #     Not sure how to explain this yet.
    #
    #         NOTE - If the PBZ is in a state in which it does not accept triggers, an SCPI error
    #         (-211, "Trigger ignored") occurs.
    #
    #     :param trig_out_output: Trigger signal output. Transmits the synchronization signal for AC signals and the
    #                             marker signal for frequency sweeps.
    #
    #         * 'OFF'(0) - Do not generate trigger signal output (default).
    #         * 'ON'(1) - Generate trigger signal output.
    #     :type trig_out_output: str|int|bool
    #     :param trig_in_type: Set the trigger input response on the rising, or falling edge, or take repeated
    #                          measurements.
    #
    #         * 'AUTO' - Automatically takes repeated measurements.
    #         * 'RISING' - Starts measuring when a rising edge is detected in the TRIG IN input signal.
    #         * 'FALLING' - Starts measuring when a falling edge is detected in the TRIG IN input signal.
    #     :type trig_in_type: str|enum_trig_in_modes
    #     :param trig_in_pol: Sets the polarity of the trigger signal input.
    #
    #         * 'POS' - High level.
    #         * 'NEG' - Low level.
    #     :type trig_in_pol: str|enum_trig_pol
    #     :param trig_out_pol: Sets the polarity of the trigger signal input.
    #
    #         * 'POS' - Rising.
    #         * 'NEG' - Falling.
    #     :type trig_out_pol: str|enum_trig_pol
    #     :param trig_out_type:
    #
    #         * 'OFF' - No signal is generated.
    #         * 'SYNC' - AC signal synchronization signals are generated (the duty ratio is fixed to 50%). Only generated
    #                    when the internal signal source's AC signal is turned on. TRIG OUT can only be set to SYNC if
    #                    sync_operation() was set to 'SLAVE_END'.
    #         * 'MARKER' - Frequency marker signals are generated, only when frequency sweep is on. If sync_operation()
    #                      is not set to 'OFF', you cannot set TRIG OUT to MARKER.
    #     :type trig_out_type: str|enum_trigger_modes
    #     :param trig_freq: Sets the frequency marker. The marker frequency can be set to a value between the specified
    #            start and stop frequency set in the sweep method.
    #     :type trig_freq: float|int
    #     :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
    #              the present settings.
    #     :rtype: dict|None
    #     """
    #
    #     self.log_unused_args(args, kwargs)
    #     sync_op = self.sync_operation()
    #     if all(v is None for v in {trig_out_output, trig_in_type, trig_in_pol, trig_out_type, trig_out_pol,
    #                                trig_out_type, trig_freq}):
    #         return_val = {}
    #         return_val.update(trig_out_output=self.on_off.to_api(self.query("OUTP:TRIG:STAT?", int)))
    #         return_val.update(trig_in_type=self.query("SENS:TRIG:SOUR?", self.enum_trig_in_modes).name)
    #         return_val.update(trig_in_pol=self.query("INP:TRIG:POL?", self.enum_trig_pol).name)
    #         return_val.update(trig_out_type=self.query("MARK?", self.enum_trigger_modes).name)
    #         return_val.update(trig_out_pol=self.query("OUTP:TRIG:POL?", self.enum_trig_pol).name)
    #         return_val.update(trig_freq=self.query("MARK:FPO?", float))
    #         return return_val
    #
    #     # Performing checks on the user input
    #     trig_out_output = self.on_off.to_inst(trig_out_output)
    #     trig_in_type = check_enum_str('trig_in', trig_in_type, self.enum_trig_in_modes)
    #     trig_in_pol = check_enum_str('trig_in_pol', trig_in_pol, self.enum_trig_pol)
    #     trig_out_type = check_enum_str('trig_type', trig_out_type, self.enum_trigger_modes)
    #     trig_out_pol = check_enum_str('trig_out_pol', trig_out_pol, self.enum_trig_pol)
    #     trig_freq = check_range('trig_freq', trig_freq, self.freq_hz)
    #
    #     # Performing checks on the system configuration.
    #     if trig_out_type is not None:
    #         if trig_out_type.value == 'OFF' and sync_op != 'SLAVE_END':
    #             raise ValueError(
    #                 f"Bad input, trig_out can only be configured in {trig_out_type.name} if sync_operation() is set "
    #                 f"to 'SLAVE_END'.")
    #         elif trig_out_type.value == 'ON' and sync_op != 'OFF':
    #             raise ValueError(f"Bad input, trig_out can only be configured in {trig_out_type.name} if "
    #                              f"sync_operation() is set to 'OFF'.")
    #
    #     # Everything looks good, write to the instrument.
    #     if trig_out_output is not None:
    #         self.write("OUTP:TRIG:STAT", trig_out_output)
    #
    #     if trig_in_type is not None:
    #         self.write("SENS:TRIG:SOUR", trig_in_type.value)
    #
    #     if trig_out_type is not None:
    #         if trig_out_type.value == 'OFF':
    #             self.ac_source(duty=50)
    #             self.write("MARK", trig_out_type.value)
    #         else:
    #             self.write("MARK", trig_out_type.value)
    #
    #     if trig_freq is not None:
    #         self.write("MARK:FPO", trig_freq)
    #
    #     if trig_in_pol is not None:
    #         self.write("INP:TRIG:POL", trig_in_pol.value)
    #
    #     if trig_out_pol is not None:
    #         self.write("OUTP:TRIG:POL", trig_out_pol.value)
    #
    #     self.log_inst_errors()

    # ---------------------------------------------------------------------------
    #
    # def sweep(self, on_off=None, sweep_mode=None, sweep_time=None, start_freq=None, stop_freq=None,
    #           *args, **kwargs):
    #     """
    #     The settable ranges are the same for bipolar and unipolar mode. Not sure how to explain this yet.
    #
    #     :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'. Query
    #         always returns 'ON' or 'OFF'.
    #     :type on_off: str|int|bool
    #     :param sweep_mode: Sets the sweep mode.
    #
    #         * 'LOG' - Logarithmic sweep (the frequency changes logarithmically).
    #         * 'LINEAR' - Linear sweep (the frequency changes linearly)
    #     :type sweep_mode: str|enum_ac_sweep_mode
    #     :param sweep_time: Sets the sweep time in seconds.
    #     :type sweep_time: int|float
    #     :param start_freq: Used to set the starting frequency of the sweep. This is independent of regular frequency
    #         setting defined in the ac_source method.
    #
    #         NOTE - if sweep('OFF'), the frequency value is the value specified in the FREQ setting.
    #
    #     :type start_freq:float
    #     :param stop_freq: Used to set the stop frequency of the sweep. This is independent of regular frequency
    #         setting defined in the ac_source method.
    #     :type stop_freq:float
    #     :return: If no arguments are supplied, the instrument is queried and a dictionary is returned showing
    #         the present settings.
    #     :rtype: dict|None
    #     """
    #
    #     self.log_unused_args(args, kwargs)
    #     sync_op = self.sync_operation()
    #     if all(v is None for v in {on_off, sweep_mode, sweep_time, start_freq, stop_freq}):
    #         return_val = {}
    #         return_val.update(on_off=self.on_off.to_api(self.query("SWE:STAT?", int)))
    #         return_val.update(sweep_mode=self.query("SWE:SPAC?", self.enum_ac_sweep_mode).name)
    #         return_val.update(sweep_time=self.query("SWE:TIME?", float))
    #         return_val.update(start_freq=self.query("SWE:FREQ:STAR?", float))
    #         return_val.update(stop_freq=self.query("SWE:FREQ:STOP?", float))
    #         return return_val
    #
    #     # Performing checks on the user input
    #     on_off = self.on_off.to_inst(on_off)
    #     sweep_mode = check_enum_str('sweep_mode', sweep_mode, self.enum_ac_sweep_mode)
    #     sweep_time = check_range('sweep_time', sweep_time, self.sweep_time)
    #     start_freq = check_range('start_freq', start_freq, self.freq_hz)
    #     stop_freq = check_range('stop_freq', stop_freq, self.freq_hz)
    #
    #     # Performing checks on the system configuration.
    #     if sync_op != 'OFF':
    #         raise ValueError(
    #             f"Sweep cannot be on when sync_operation is configured in '{sync_op}' mode. Sweep can only "
    #             f"be 'ON' when synchronous operation mode is 'OFF'. Call sync_operation method to change "
    #             f"the operation mode.")
    #
    #     start_freq_state = start_freq
    #     if start_freq_state is None:
    #         start_freq_state = self.query("SWE:FREQ:STAR?", float)
    #
    #     stop_freq_state = stop_freq
    #     if stop_freq_state is None:
    #         stop_freq_state = self.query("SWE:FREQ:STOP?", float)
    #
    #     if stop_freq_state >= start_freq_state:
    #         raise ValueError(f"Requested stop marker frequency {stop_freq_state}, cannot be less than the start "
    #                          f"frequency {start_freq_state}. The request will be ignored")
    #
    #     # Everything looks good, write to the instrument.
    #     if start_freq is not None:
    #         self.write("SWE:FREQ:START", start_freq)
    #
    #     if stop_freq is not None:
    #         self.write("SWE:FREQ:STOP", stop_freq)
    #
    #     if on_off is not None:
    #         self.write("SWE:STAT", on_off)
    #
    #     if sweep_mode is not None:
    #         self.write("SWE:SPAC", sweep_mode.value)
    #
    #     if sweep_time is not None:
    #         self.write("SWE:TIME", sweep_time)
    #
    #     self.log_inst_errors()
    #

# ===============================================================================


if __name__ == '__main__':
    pbz2020A = PBZ2020A('GPIB0::10')  # Replace visa_resource_name with None for simulated hardware.
    pbz2020A.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
