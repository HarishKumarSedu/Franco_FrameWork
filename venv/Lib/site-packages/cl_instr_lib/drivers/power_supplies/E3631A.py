from collections import namedtuple

from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC


ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])


class E3631A(InstrumentVisa, PowerSupply):
    """Driver class for HP/Agilent/Keysight E3631A Triple Output Power Supply."""

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):

        # Setup the simulation code inherited from Instrument.
        super().__init__(visa_resource_name, logger,
                         channel_specific_cmds=('VOLT', 'CURR', 'MEAS'),
                         channel_sel_default=1,
                         channel_sel_cmd='INST:NSEL',
                         model_re='^E3631A$',
                         sim_idn='HEWLETT-PACKARD,E3631A,0,2.1-5.0-1.0',
                         **kwargs
                         )

        # Create the channel objects. (Note creating the attributes directly enables auto-complete in editor.)
        # Pass power supply self down to channel so he knows who his container is.
        self.OUTPUT_P6V = Channel(self, 'OUTPUT_P6V',  1, ProgrammingBounds(0.0, 6.18, 0.0, 5.15))
        self.OUTPUT_P25V = Channel(self, 'OUTPUT_P25V', 2, ProgrammingBounds(0.0, 25.75, 0.0, 1.03))
        self.OUTPUT_N25V = Channel(self, 'OUTPUT_N25V', 3, ProgrammingBounds(-25.75, 0.0, 0.0, 1.03))

        self._channel_names = ['OUTPUT_P6V', 'OUTPUT_P25V', 'OUTPUT_N25V']

    def output_state(self, on_off=None):
        """Queries or sets the power supply output state (OFF or ON) of all three outputs.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """

        if on_off is None:
            return self.on_off.to_api(self.query('OUTP', int))

        self.write('OUTP', self.on_off.to_inst(on_off))

    def outputs_independent_on_off(self):
        """ Returns True if each channel can be turned ON or OFF independently of the others."""

        return False

class Channel(PSChannel_ABC):
    """Implements the methods to control a output of a power supply."""

    def __init__(self, power_supply, channel_name, channel_id, programming_bounds):
        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)
        self.channel_id = channel_id

    def source_voltage(self, voltage=None, current_limit=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **VOLTAGE** source.

        :param voltage: Output voltage in Volts. See attribute programming_bounds for maximum voltage value.
        :type voltage: float
        :param current_limit: Compliance limit for output current in Amperes. See attribute programming_bounds
                        for maximum current value.
        :type current_limit: float
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit}):
            self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
            return_value = {}
            return_value.update(voltage=self.power_supply.query("VOLT", float))
            return_value.update(current_limit=self.power_supply.query("CURR", float))
            return return_value

        if voltage is not None and not \
                (self.programming_bounds.volts_min <= voltage <= self.programming_bounds.volts_max):
            raise ValueError(f"Bad voltage {voltage} V for E3631A {self.channel_name}, should be "
                             f"{self.programming_bounds.volts_min} to {self.programming_bounds.volts_max} V.")

        if current_limit is not None and not (
                self.programming_bounds.amps_min <= current_limit <= self.programming_bounds.amps_max):
            raise ValueError(f"Bad current_limit {current_limit} A for E3631A {self.channel_name}, should be "
                             f"{self.programming_bounds.amps_min} to {self.programming_bounds.amps_max} A.")

        if any(v is not None for v in {voltage, current_limit}):
            # Going to set something, so select the channel in the instrument.
            self.power_supply.write(self.power_supply.channel_sel_cmd, f"{self.channel_id}")

        if voltage is not None:
            self.power_supply.write("VOLT", voltage)

        if current_limit is not None:
            self.power_supply.write("CURR", current_limit)

        self.power_supply.log_inst_errors()

    def measure_voltage(self):
        """Returns the measured value at the output in Volts."""

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
        return self.power_supply.query("MEAS:VOLT", float)

    def measure_current(self):
        """Returns the measured value at the output in Amperes."""

        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
        return self.power_supply.query("MEAS:CURR", float)

    def output_state(self, on_off=None):
        """Queries the output state (OFF or ON).

        Note that this output specific method is query only and the value returned reflects the state of all three
        outputs of the E3631, which does not provide independent ON/OFF controls for each output.

        :param on_off: If not None, error is raised. Provided to allow calls from client code written for other
            supplies with independent channel controls.
        """

        # TODO: The compatibility implications of this need to be rethought: consider client code written for a
        #  single output supply.

        if on_off is None:
            return self.power_supply.output_state()
        else:
            raise ValueError(f"E363x does not provide individual control of outputs state , "
                             f"use power supply method output_state to control all 3 outputs.")

    def get_status(self):
        """Returns a string indicating present operating mode of the channel.

        :returns: One of 'OFF', 'CC' = Current compliance limit exceeded, 'CV' = Normal voltage source operation,
            'UN' = Unregulated (Bad).
        """

        isum = self.power_supply.query(f"STAT:QUES:INST:ISUM{self.channel_id}:COND", int)
        return {0: 'OFF', 1: 'CC', 2: 'CV', 3: 'UN'}[isum]


if __name__ == '__main__':

    ps3631A = E3631A('GPIB0::5')  # Replace visa_resource_name with None for simulated hardware.
    ps3631A.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
