from collections import namedtuple

from cl_instr_lib.base_classes.instrument_chanlist import InstrumentChanList
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC

ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])


class N6700(InstrumentChanList, PowerSupply):
    """Driver class for HP/Agilent/Keysight N6700 Multiple Output Power Supply."""

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):

        reset_values = {'SYST:CHAN:COUNT': 2}

        super().__init__(visa_resource_name, chan_count_cmd='SYST:CHAN:COUNT', logger=logger,
                         model_re='^N6700B$',
                         sim_idn='Agilent Technologies,N6700B,MY54005712,D.04.09',
                         reset_values=reset_values,
                         **kwargs)

        # Create the channel objects. (Note creating the attributes directly enables auto-complete in editor.)
        # Pass power supply self down to channel so he knows who his container is.
        self.OUT1 = N6762A(self, 'OUT1', 1, ProgrammingBounds(0.0, 51.0, 0.0, 3.059))
        self.OUT2 = N6762A(self, 'OUT2', 2, ProgrammingBounds(0.0, 51.0, 0.0, 3.059))

        self._channel_names = ['OUT1', 'OUT2']

    def output_state(self, channel, on_off=None):
        """Queries or sets the power supply output state (OFF or ON) of one of the 2 outputs.

        :param channel: selects which channel to sent command to (1 or 2)
        :type channel: int
        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """

        if not (isinstance(channel, int) and (1 <= channel <= self.channel_id_max)):
            raise ValueError(f"Bad channel {channel}. Should be int value from 1 to {self.channel_id_max}.")

        if on_off is None:
            return self.on_off.to_api(self.query('OUTP', int, channel))

        self.write('OUTP', self.on_off.to_inst(on_off), channel)


class N6762A(PSChannel_ABC):
    """Implements the methods to control a output of a power supply."""

    def __init__(self, power_supply, channel_name, channel_id, programming_bounds):
        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)
        self.channel_id = channel_id

    def source_voltage(self, voltage=None, current_limit=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a **VOLTAGE** source.

        :param voltage: Output voltage in Volts. See attribute programming_bounds for maximum voltage value.
        :type voltage: float
        :param current_limit: Compliance limit for output current in Amperes. See attribute programming_bounds
                        for maximum current value.
        :type current_limit: float
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit}):
            return_value = {}
            return_value.update(voltage=self.power_supply.query("VOLT", float, self.channel_id))
            return_value.update(current_limit=self.power_supply.query("CURR", float, self.channel_id))
            return return_value

        if voltage is not None and not \
                (self.programming_bounds.volts_min <= voltage <= self.programming_bounds.volts_max):
            raise ValueError(f"Bad voltage {voltage} V for N6700 {self.channel_name}, should be "
                             f"{self.programming_bounds.volts_min} to {self.programming_bounds.volts_max} V.")

        if current_limit is not None and not (
                self.programming_bounds.amps_min <= current_limit <= self.programming_bounds.amps_max):
            raise ValueError(f"Bad current_limit {current_limit} A for N6700 {self.channel_name}, should be "
                             f"{self.programming_bounds.amps_min} to {self.programming_bounds.amps_max} A.")

        if voltage is not None:
            self.power_supply.write("VOLT", voltage, self.channel_id)

        if current_limit is not None:
            self.power_supply.write("CURR", current_limit, self.channel_id)

        self.power_supply.log_inst_errors()

    def measure_voltage(self):
        """Returns the measured value at the output in Volts."""

        return self.power_supply.query("MEAS:VOLT", float, self.channel_id)

    def measure_current(self):
        """Returns the measured value at the output in Amperes."""

        return self.power_supply.query("MEAS:CURR", float, self.channel_id)

    def output_state(self, on_off=None):
        """Queries or sets the power supply output state (OFF or ON) of one of the 2 outputs.

        :param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
        """

        if on_off is None:
            return self.power_supply.output_state(channel=self.channel_id)

        self.power_supply.output_state(channel=self.channel_id, on_off=on_off)

    def get_status(self):
        """Returns a string indicating present operating mode of the channel.

        :returns: One of 'OFF', 'CC' = Current compliance limit exceeded, 'CV' = Normal voltage source operation.
        """

        isum = self.power_supply.query("STAT:OPER:COND", int, self.channel_id)
        return {4: 'OFF', 2: 'CC', 1: 'CV'}[isum]


if __name__ == '__main__':
    ps6700 = N6700('USB0::0x0957::0x0907::MY54005712')  # Replace visa_resource_name with None for simulated hardware.
    ps6700.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
