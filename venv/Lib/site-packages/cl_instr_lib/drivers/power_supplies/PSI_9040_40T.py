from collections import namedtuple
import re

from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC

ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max',
                                                     'watts_min', 'watts_max', 'ohms_min', 'ohms_max'])
ProtectionBounds = namedtuple('ProtectionBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max',
                                                   'watts_min', 'watts_max'])


class PSI_9040_40T(InstrumentVisa, PowerSupply):
    """Driver class for EA PSI9040_40T Power Supply."""

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):

        # Setup the simulation code inherited from Instrument.
        super().__init__(visa_resource_name, logger,
                         model_re='^PSI 9040-40 T$',
                         sim_idn='EA Elektro-Automatik GmbH & Co. KG, PSI 9040-40 T,'
                                 ' 2073110008, V2.04 15.05.2017 V3.07 06.08.2019 V1.0.2,',
                         **kwargs)

        # Create the channel objects. (Note creating the attributes directly enables auto-complete in editor.)
        # Pass power supply self down to channel so he knows who his container is.
        self.OUTPUT = Channel(self, 'OUTPUT', 1, ProgrammingBounds(0.0, 40.8, 0.0, 40.8, 0.0, 1020.0, 0.0, 30.0),
                    ProtectionBounds(0.0, 44.0, 0.0, 44.0, 0.0, 1100.0))

        self._channel_names = ['OUTPUT']

    def output_state(self, on_off=None):
        """Queries or sets the power supply output state: OFF or ON.

                "param on_off: For ON accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
                :return: If no arguments are supplied, instrument is queried and state is returned as 'ON' or 'OFF'.
                """

        if on_off is None:
            return self.query('OUTP', str)  # Supply will return 'OFF' for off, 'ON' for on.

        self.write('OUTP', self.on_off.to_inst(on_off))  # Works because supply can use 0 for OFF, 1 for ON.


class Channel(PSChannel_ABC):

    def __init__(self, power_supply, channel_name, channel_id, programming_bounds, protection_bounds):

        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)
        self.channel_id = channel_id
        self.protection_bounds = protection_bounds

        self.system_lock('ON')  # PSI9040 requires this to initiate remote control.
        self.status_clear()  # Clear previous errors that might block command execution

    def source_voltage(self, voltage=None, current_limit=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a VOLTAGE source.

        Note: Before any parameters can be written to the instrument, it must be enabled for remote operation using the
        system_lock method.

        :param voltage: Output voltage in volts. See attribute programming_bounds for maximum voltage value.
        :type voltage: float
        :param current_limit: Compliance limit for current delivered to the load. See attribute programming_bounds
                        for maximum current value.
        :type current_limit: float
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit}):
            return_value = {}
            # TODO: This won't work in simulation, empty string can't be converted to float!
            tmp1 = self.power_supply.query("VOLT", str)
            tmp1 = re.sub(r'[^\d\.$]', '', tmp1)
            return_value.update(voltage=float(tmp1))
            tmp2 = self.power_supply.query("CURR", str)
            tmp2 = re.sub(r'[^\d\.$]', '', tmp2)
            return_value.update(current_limit=float(tmp2))
            return return_value

        if voltage is not None and not \
                (self.programming_bounds.volts_min <= voltage <= self.programming_bounds.volts_max):
            raise ValueError(f"Bad voltage {voltage} V for PSI9040 {self.channel_name}, should be "
                             f"{self.programming_bounds.volts_min} to {self.programming_bounds.volts_max} V.")

        if current_limit is not None and not (
                self.programming_bounds.amps_min <= current_limit <= self.programming_bounds.amps_max):
            raise ValueError(f"Bad current_limit {current_limit} A for PSI9040 {self.channel_name}, should be "
                             f"{self.programming_bounds.amps_min} to {self.programming_bounds.amps_max} A.")

        if voltage is not None:
            self.power_supply.write("VOLT", voltage)

        if current_limit is not None:
            self.power_supply.write("CURR", current_limit)

        self.power_supply.log_inst_errors()

    def output_state(self, on_off=None):
        return self.power_supply.output_state(on_off)

    def get_status(self):
        tmp_dict = self.status_reg_bits('OPER')
        for key, value in tmp_dict.items():
            if value:
                return key
        return tmp_dict

    def measure_voltage(self):
        """Returns measured voltage in Volts.

        :return: Measured voltage in Volts.
        :rtype: float
        """

        tmp = self.power_supply.query("MEAS:VOLT", str)
        tmp = re.sub(r'[^\d\.$]', '', tmp)
        return float(tmp)

    def measure_current(self):
        """Returns measured current in Amps.

        :return: Measured current in Amps.
        :rtype: float
        """

        tmp = self.power_supply.query("MEAS:CURR", str)
        tmp = re.sub(r'[^\d\.$]', '', tmp)
        return float(tmp)

    def measure_power(self):
        """Returns measured power in Watts.

        :return: Measured power in Watts. Measured using SCPI command 'MEAS:POW' that exists in this supply.
        :rtype: float
        """

        tmp = self.power_supply.query("MEAS:POW", str)
        tmp = re.sub(r'[^\d\.$]', '', tmp)
        return float(tmp)

    # ---------------------------------------------------------------------------

    def meas(self, param=None):
        """
        Queries the actual measured value of the specified parameter.

        **NOTE: This method is deprecated and will be removed in a future release. Use methods measure_voltage,
        measure_current or measure_power instead.**

        Args:
            param:
                None:  - Reads all 3 measurements and returns as comma separated sting including units.
                'CURR' - measured Current (Amps) as a float
                'POW'  - measured Power   (Watts) as a float
                'VOLT' - measured Voltage (Volts) as a float

           Args are not case sensitive.
        """

        self.power_supply.log.warning("The meas method is deprecated and will be removed in a future release.")
        self.power_supply.log.warning("    Use methods measure_voltage, measure_current or measure_power instead.")

        if param is None:
            param = 'ALL'

        param_u = param.upper()
        if param_u not in ('CURR', 'VOLT', 'POW', 'ALL'):
            raise ValueError(f"Bad meas parameter '{param}. Should be one of 'VOLT', 'CURR', 'POW', 'ALL'")

        if param_u == 'ALL':
            param_all_list = self.power_supply.query('MEAS:ARR', str).split(', ')
            for i in range(len(param_all_list)):
                param_all_list[i] = re.sub(r'[^\d\.$]', '', param_all_list[i])
                param_all_list[i] = str(float(param_all_list[i]))
            param_all_str = ','.join(param_all_list)
            return param_all_str

        ret_val = self.power_supply.query('MEAS:' + param_u, str)
        tmp = re.sub(r'[^\d\.$]', '', ret_val)
        ret_val = float(tmp)
        return ret_val

    # ---------------------------------------------------------------------------

    def system_lock(self, on_off=None):
        """Queries or sets how supply is controlled. Lock must be ON for remote control to change settings of the
         supply.

        Args:
            on_off:
                None: queries present setting.
                'ON': remote control enabled for writing.
                'OFF': Settings can be changed on the front panel.
        Returns:
            'REMOTE': remote control mode is in effect
            'NONE':   front panel control is in effect
        """

        if on_off is None:
            return self.power_supply.query('SYST:LOCK:OWNER', str)

        # if on_off not in self.power_supply.enum_on_off:
        #     raise ValueError(f"Bad on_off {on_off}, should be one of enum_off_on")
        inst_value = self.power_supply.on_off.to_inst(on_off)
        self.power_supply.write('SYST:LOCK', inst_value)

    # ---------------------------------------------------------------------------

    def power_limit(self, watts=None):
        """Queries or sets the power compliance value.

        Note this limits the voltage and or current delivered to the load to from exceeding the
        set value. This is different than Over Power protection (opp) which shuts off the output.

        Args:
            watts: None: queries present setting, returns float value in watts.
                   Numeric value in watts to set.
        """

        if watts is None:
            # Read and return voltage output setting and current limit setting.
            tmp = self.power_supply.query('POW', str)
            tmp = re.sub(r'[^\d\.$]', '', tmp)
            return float(tmp)

        if self.programming_bounds.watts_min <= watts <= self.programming_bounds.watts_max:
            self.power_supply.write('POW', watts)
        else:
            raise ValueError(f"Bad power {watts} W, should be from "
                             f"{self.programming_bounds.watts_min} W to {self.programming_bounds.watts_max} W.")

    # ---------------------------------------------------------------------------

    def resistance(self, ohms=None):
        """Queries or sets the series resistance value that is in effect in UIR mode.

        Note that the series resistance is not present in the UIP mode. See method mode
        to change modes.

        Args:
            ohms: None: queries present setting, returns float value in Ohms.
                   Numeric value in Ohms to set, value 0.1 to 30. Note that values >30 cause
                   a -222, "Data out if range" error even though supply allows adjustment
                   limit to be 30.6. Firmware bug??

        """

        if ohms is None:
            # Read and return voltage output setting and current limit setting.
            tmp = self.power_supply.query('RES', str)
            tmp = re.sub(r'[^\d\.$]', '', tmp)
            return float(tmp)

        if ohms < 0.05:
            raise ValueError(f"Cannot set resistance < 0.05 Ohm. To eliminate series resistance, "
                             f"use the mode method to select 'UIP' mode.")

        if self.programming_bounds.ohms_min <= ohms <= self.programming_bounds.ohms_max:
            self.power_supply.write('RES', ohms)
        else:
            raise ValueError(f"Bad resistance {ohms} ohms, should be from "
                             f"{self.programming_bounds.ohms_min} ohms to {self.programming_bounds.ohms_max} ohms.")

    # ---------------------------------------------------------------------------

    def mode(self, modename=None):
        """Queries or selects the operating mode of the supply: power limiting or series resistance.

        Args:
            modename:
                None:   Returns abbreviation of mode currently selected.
                UIP:    Voltage/Current/Power
                UIR:    Voltage/Current/Resistance
        """

        if modename is None:
            return self.power_supply.query('SYST:CONFIG:MODE', str)

        modename_u = modename.upper()
        if modename_u not in ('UIP', 'UIR'):
            raise ValueError(f"Invalid mode '{modename}', should be one of 'UIP' or 'UIR'.\n"
                             f"'UIP' = Voltage/Current/Power\n"
                             f"'UIR' = Voltage/Current/Resistance")

        self.power_supply.write('SYST:CONFIG:MODE', modename_u)

    # ---------------------------------------------------------------------------

    def status_reg_bits(self, regname):
        """Queries OPER or QUES status register and returns dictionary showing name-values of bits.

        Args:
            regname: 'oper' or 'ques'. Not case sensitive.

        """

        regname_u = regname.upper()
        if regname_u == 'OPER':
            conditions = {'CV': 8, 'CC': 9, 'CP': 10, 'CR': 11}
        elif regname_u == 'QUES':
            conditions = {
                'OVP': 0, 'OCP': 1, 'OPP': 2, 'OT': 3, 'OVD': 4, 'UVD': 5, 'OCD': 6, 'UCD': 7, 'OPD': 8,
                'Local': 9, 'Remote': 10, 'Output On': 11, 'Function': 12, 'Power Fail': 12
            }
        else:
            raise ValueError(f"Bad status regname '{regname}', needs to be 'oper' or 'ques'.")

        value = self.power_supply.query(f'STAT:{regname_u}:COND', int)

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    # ---------------------------------------------------------------------------

    def ocp_state(self, on_off=None):
        if on_off is None:
            return 'ON'

        self.power_supply.log.warning(f"This supply cannot turn off Over Current Protection. "
                                      f"Current OCP value is {self.power_supply.query('CURR:PROT', str)}.")

    # ---------------------------------------------------------------------------

    def ovp_state(self, on_off=None):
        if on_off is None:
            return 'ON'

        self.power_supply.log.warning(f"This supply cannot turn off Over Voltage Protection. "
                                     f"Current OVP value is {self.power_supply.query('VOLT:PROT', str)}.")

    # ---------------------------------------------------------------------------

    def opp_state(self, on_off=None):
        if on_off is None:
            return 'ON'

        self.power_supply.log.warning(f"This supply cannot turn off Over Power Protection. "
                                     f"Current OPP value is {self.power_supply.query('POW:PROT', str)}.")

    # ---------------------------------------------------------------------------

    def ocp_value(self, ilimit=None):

        if ilimit is None:
            tmp = self.power_supply.query('CURR:PROT', str)
            tmp = re.sub(r'[^\d\.$]', '', tmp)
            return float(tmp)

        if self.protection_bounds.amps_min <= ilimit <= self.protection_bounds.amps_max:
            self.power_supply.write('CURR:PROT', ilimit)
        else:
            raise ValueError(f"Bad ilimit {ilimit} A, should be from "
                             f"{self.protection_bounds.amps_min} A to {self.protection_bounds.amps_max} A.")

    # ---------------------------------------------------------------------------

    def ocp_tripped(self):
        """ Queries if Over Current Protection has tripped.

            OCP shuts off the supply output when the current drawn exceeds the set value.

            Return:
                True if OCP trip has occurred..
        """

        return self.status_reg_bits('QUES')['OCP']

    # ---------------------------------------------------------------------------

    def ocp_clear(self):
        """ Clears Over Current Protection trip.

            OCP shuts off the supply output when the current drawn exceeds the set value.

            Note that after clearing the trip state, the output will remain off until
            reactivated using the output method.

        """

        self.getError()

    # ---------------------------------------------------------------------------

    def ovp_value(self, vlimit=None):

        if vlimit is None:
            tmp = self.power_supply.query('VOLT:PROT', str)
            tmp = re.sub(r'[^\d\.$]', '', tmp)
            return float(tmp)

        if self.protection_bounds.volts_min <= vlimit <= self.protection_bounds.volts_max:
            self.power_supply.write('VOLT:PROT', vlimit)
        else:
            raise ValueError(f"Bad vlimit {vlimit} V, should be from "
                             f"{self.protection_bounds.volts_min} V to {self.protection_bounds.volts_max} V.")

    # ---------------------------------------------------------------------------

    def ovp_tripped(self):
        """ Queries if Over Voltage Protection has tripped.

            OCP shuts off the supply output when the volatge exceeds the set value.

            Return:
                True if OCP trip has occurred..
        """

        return self.status_reg_bits('QUES')['OVP']

    # ---------------------------------------------------------------------------

    def ovp_clear(self):
        """ Clears Over Voltage Protection trip.

            OVP shuts off the supply output when the voltage drawn exceeds the set value.

            Note that after clearing the trip state, the output will remain off until
            reactivated using the output method.

        """

        self.getError()

    # ---------------------------------------------------------------------------

    def opp_value(self, watts=None):
        """ Queries or sets the Over Power Protection level of the supply.

            OPP shuts off the supply output when the power exceeds the set value.

            Args:
                watts: None or float representing current in Watts.

            Return:
                Query returns the present OPP setpoint in Watts.
        """

        if watts is None:
            tmp = self.power_supply.query('POW:PROT', str)
            tmp = re.sub(r'[^\d\.$]', '', tmp)
            return float(tmp)

        if self.protection_bounds.watts_min <= watts <= self.protection_bounds.watts_max:
            self.power_supply.write('POW:PROT', watts)
        else:
            raise ValueError(f"Bad vlimit {watts} W, should be from "
                             f"{self.protection_bounds.watts_min} W to {self.protection_bounds.watts_max} W.")

    # ---------------------------------------------------------------------------

    def opp_tripped(self):
        """ Queries if Over Power Protection has tripped.

            OPP, if enabled, shuts down the supply when the power exceeds the set value.

            Return:
                Query returns True if trip has occurred.
        """

        return self.status_reg_bits('QUES')['OPP']

    # ---------------------------------------------------------------------------

    def opp_clear(self):
        """ Clears Over Voltage Protection trip.

            OPP shuts off the supply output when the voltage drawn exceeds the set value.

            Note that after clearing the trip state, the output will remain off until
            reactivated using the output method.

        """

        self.getError()

    # ---------------------------------------------------------------------------

    def adjustment_hilimits(self, param=None, limit=None):
        """Queries or sets upper bounds for output parameters "VOLT', 'CURR', 'POW', 'RES'.

        Args:
            param: None: All 4 limits are read and returned as a dict of name-value pairs. 'VOLT', 'CURR', 'POW',
            'RES': Any of these with limit=None, results in the value being read and returned as a float.
            limit: int or float value to set.

        Effect of adjustment_limits:
        Under LOCAL control turing the knob 1 click beyond the adjustment_hilimit for the
        parameter results in a Limit message on the fromt panel LCD screen.

        Under REMOTE control attempting to set a value above the limit will set ERR bit in the
        status byte (read with method status(), and an error "-221, 'Settng Conflict' in the error
        queue, read with method getError(),
        """

        legal_params = {'VOLT': 40.8, 'CURR': 40.8, 'POW': 1020, 'RES': 30}
        # See comment on method resistance() for why max here is 30.

        if param is None and limit is None:
            return_val = {}
            for param in legal_params:
                tmp = self.power_supply.query(f"{param}:LIM:HIGH", str)
                tmp = re.sub(r'[^\d\.$]', '', tmp)
                value = float(tmp)
                name = param
                return_val.update({name: value})

            return return_val

        if param not in legal_params:
            msg = ", ".join(["'{}'".format(x) for x in legal_params])
            raise ValueError(f"Bad param name '{param}', should be one of {msg}.")

        if limit is None:
            tmp = self.power_supply.query(f"{param}:LIM:HIGH", str)
            tmp = re.sub(r'[^\d\.$]', '', tmp)
            return float(tmp)

        value_max = legal_params[param]
        if limit > value_max:
            raise ValueError(f"Bad high limit for {param}: {limit}, max is {value_max}.")
        else:
            cmd = f"{param}:LIM:HIGH"
            self.power_supply.write(cmd, limit)

    # ---------------------------------------------------------------------------

    def getError(self):
        """Reads a single error string (oldest) from supply error queue.

        Error queue is First In First Out. Will return "0, 'No Error" on the read
        following reading the last error.

        Clears device Alarm bits in QUEStionable Status register if the condition that
        caused the alarm is gone.
        """

        return self.power_supply.query('SYST:ERR', str)

    def status(self):
        """
        Reads the status byte register and returns the names-values of the 3 status bits as a dict.

        Does not clear the STB, call status_clear to do that, but beware that clears the error
        queue as well.

        """

        value = self.power_supply.query('*STB', int)

        conditions = {'ERR': 2, 'QUES': 3, 'OPER': 7}

        result = dict()
        for name, bit in conditions.items():
            mask = 2 ** bit
            result.update({name: (value & mask) > 0})

        return result

    def status_clear(self):
        """Clears the STB (status byte) and the error queue by sending '\*CLS', command."""

        self.power_supply.write('*CLS', "")


if __name__ == '__main__':
    ps9040T = PSI_9040_40T('COM5')  # Replace visa_resource_name with None for simulated hardware.
    ps9040T.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
