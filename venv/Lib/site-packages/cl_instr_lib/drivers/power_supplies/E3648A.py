from collections import namedtuple
from enum import Enum

from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.power_supply import PowerSupply
from cl_instr_lib.base_classes.ps_channel_ABC import PSChannel_ABC
from cl_instr_lib.helpers.check_enum_str import check_enum_str


ProgrammingBounds = namedtuple('ProgrammingBounds', ['volts_min', 'volts_max', 'amps_min', 'amps_max'])
RangeBounds = namedtuple('RangeBounds', ['LOW', 'HIGH'])


class E3648A(InstrumentVisa, PowerSupply):
    """Driver class for HP/Agilent/Keysight E3648A Dual Output Power Supply."""

    enum_forcing_ranges = Enum('enum_forcing_ranges', {'LOW': 'P8V', 'HIGH': 'P20V'})

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):

        # Setup the simulation code inherited from Instrument.
        super().__init__(visa_resource_name, logger,
                         reset_values={'VOLT:RANG': self.enum_forcing_ranges.LOW},
                         additional_rtn_types={self.enum_forcing_ranges: self.enum_forcing_ranges.LOW},
                         channel_specific_cmds=('VOLT', 'CURR', 'MEAS'),
                         channel_sel_default=1,
                         channel_sel_cmd='INST:NSEL',
                         model_re='^E3648A$',
                         sim_idn='Agilent Technologies,E3648A,0,1.7-5.0-1.0',
                         **kwargs)

        # Create the channel objects. (Note creating the attributes directly enables auto-complete in editor.)
        # Pass power supply self down to channel so he knows who his container is.
        self.OUT1 = Channel(self, 'OUT1', self.enum_forcing_ranges, 1,
                            RangeBounds(ProgrammingBounds(0.0, 8.24, 0.0, 5.15),
                                        ProgrammingBounds(0.0, 20.60, 0.0, 2.575)))
        self.OUT2 = Channel(self, 'OUT2', self.enum_forcing_ranges, 2,
                            RangeBounds(ProgrammingBounds(0.0, 8.24, 0.0, 5.15),
                                        ProgrammingBounds(0.0, 20.60, 0.0, 2.575)))

        self._channel_names = ['OUT1', 'OUT2']

    def output_state(self, on_off=None):
        if on_off is None:
            return self.on_off.to_api(self.query('OUTP', int))  # PSM_6003 return 0 for off, 1 for on.

        self.write('OUTP', self.on_off.to_inst(on_off))  # Works because PSM_6003 can use 0 for OFF, 1 for ON.

    def outputs_independent_on_off(self):
        """ Returns True if each channel can be turned ON or OFF independently of the others."""

        return False


class Channel(PSChannel_ABC):

    def __init__(self, power_supply, channel_name, enum_forcing_ranges, channel_id, programming_bounds):
        super().__init__(power_supply=power_supply, channel_name=channel_name, programming_bounds=programming_bounds)
        self.channel_id = channel_id
        self.enum_forcing_ranges = enum_forcing_ranges

    def source_voltage(self, voltage=None, current_limit=None, forcing_range=None, *args, **kwargs):
        """
        Queries all or sets any combination of parameters for operating as a VOLTAGE source.

        :param voltage: Output in Volts. Max value depends on forcing_range setting, see attribute programming_bounds.
        :type voltage: float
        :param current_limit: Compliance limit in Amps. Max value depends on forcing_range setting, see attribute
                              programming_bounds.
        :type current_limit: float
        :param forcing_range: 'LOW' or 'HIGH' or element of enum_forcing_ranges. See attribute programming_bounds
                              for the voltage and current capabilities of each range.
        :type forcing_range: enum_forcing_ranges, str
        :return: If no arguments are supplied, instrument is queried and a dict of parameter names-values is returned.
        """

        self.power_supply.log_unused_args(args, kwargs)

        if all(v is None for v in {voltage, current_limit, forcing_range}):
            self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
            return_value = {}
            return_value.update(voltage=self.power_supply.query("VOLT", float))
            return_value.update(current_limit=self.power_supply.query("CURR", float))
            return_value.update(forcing_range=self.power_supply.query('VOLT:RANG', self.enum_forcing_ranges).name)
            return return_value

        # We need range setting to bounds check voltage/current settings.
        forcing_range_setting = forcing_range
        if forcing_range is None:
            # User didn't provide range, get it from the instrument.
            forcing_range_setting = self.power_supply.query('VOLT:RANG', self.enum_forcing_ranges)

        # get the object of the setting regardless of user input or instrument query.
        forcing_range_obj = check_enum_str("forcing_range", forcing_range_setting, self.enum_forcing_ranges)

        # Based on the name of the range, get the appropriate voltage bounds.
        volts_min = getattr(self.programming_bounds, forcing_range_obj.name).volts_min
        volts_max = getattr(self.programming_bounds, forcing_range_obj.name).volts_max

        if voltage is None:
            # User didn't provide the voltage, so read it from the instrument.
            voltage_setting = self.power_supply.query('VOLT', float)
            if voltage_setting > volts_max:
                # User shifted from high range to low, so supply would limit to upper bound of low range!
                raise ValueError(f"Requested range {forcing_range_obj.name} does not support present output "
                                 f"voltage setting {voltage_setting} V.")
        elif not (volts_min <= voltage <= volts_max):
            # User gave us a new voltage, it is not valid for the range that will be in effect.
            raise ValueError(f"Bad voltage {voltage} V for E3648A forcing_range {forcing_range_obj.name}, "
                             f"should be {volts_min} to {volts_max} V.")

        # Based on the name of the range, get the appropriate current bounds.
        amps_min = getattr(self.programming_bounds, forcing_range_obj.name).amps_min
        amps_max = getattr(self.programming_bounds, forcing_range_obj.name).amps_max

        if current_limit is None:
            # User didn't provide the current, read it from the instrument.
            current_setting = self.power_supply.query('CURR', float)
            if current_setting > amps_max:
                # User shifted from low voltage range to high, so supply will limit to upper bound of high range!
                raise ValueError(f"Requested range {forcing_range_obj.name} does not support present current limit"
                                 f"setting {current_setting} to {amps_max} A.")
        elif not (amps_min <= current_limit <= amps_max):
            raise ValueError(f"Bad current_limit {current_limit} A for E3648A, should be "
                             f"{amps_min} to {amps_max} A.")

        # Now that all values have been checked, write new values to the instrument

        if any(v is not None for v in {voltage, current_limit, forcing_range}):
            # Going to set something, so select the channel in the instrument.
            self.power_supply.write(self.power_supply.channel_sel_cmd, f"{self.channel_id}")

        if forcing_range is not None:
            self.power_supply.write("VOLT:RANG", forcing_range_obj.value)

        if voltage is not None:
            self.power_supply.write("VOLT", voltage)

        if current_limit is not None:
            self.power_supply.write("CURR", current_limit)

        self.power_supply.log_inst_errors()

    def measure_voltage(self):
        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
        return self.power_supply.query("MEAS:VOLT", float)

    def measure_current(self):
        self.power_supply.write(self.power_supply.channel_sel_cmd, self.channel_id)
        return self.power_supply.query("MEAS:CURR", float)

    def output_state(self, on_off=None):
        if on_off is None:
            return self.power_supply.output_state(on_off)
        else:
            raise ValueError(f"E3648A does not provide individual control of outputs state , "
                             f"use output_state method of the power supply.")

    def get_status(self):
        isum = self.power_supply.query(f"STAT:QUES:INST:ISUM{self.channel_id}:COND", int)
        return {0: 'OFF', 1: 'CC', 2: 'CV', 3: 'UN'}[isum]


if __name__ == '__main__':
    ps3648A = E3648A('GPIB0::7')  # Replace visa_resource_name with None for simulated hardware.
    ps3648A.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
