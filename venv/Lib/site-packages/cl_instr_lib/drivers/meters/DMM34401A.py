from enum import Enum
from collections import namedtuple

from cl_instr_lib.base_classes.dmm_basic_ABC import DmmBasic_ABC
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units

Bounds = namedtuple('Bounds', ['range_min', 'range_max', 'res_min', 'res_max'])


class DMM34401A(DmmBasic_ABC, InstrumentVisa):
    """Driver class for HP/Agilent/Keysight 34401A Digital Multimeter."""

    #: These Enum objects or keys (strings) can be used in method calls that take the **function** parameter.
    #: Keys are 'DCV', 'ACV', 'DCI', 'ACI', 'OHMS2', 'OHMS4', 'FREQ', 'PER'.
    enum_functions = Enum('enum_functions', {'DCV': 'VOLT', 'ACV': 'VOLT:AC', 'DCI': 'CURR', 'ACI': 'CURR:AC',
                                             'OHMS2': 'RES', 'OHMS4': 'FRES', 'FREQ': 'FREQ', 'PER': 'PER'})

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):
        super().__init__(visa_resource_name, logger,
                         model_re='^34401A$',
                         sim_idn='HEWLETT-PACKARD,34401A,0,11-5-3',
                         **kwargs)

    def measure(self, function=None):
        """
        One-shot measurement, using default (post-\*RST) configurations for function.

        ATTENTION: Any previously programed non-default configuration for the named function is lost and
        replaced by the \*RST values!

        Equivalent to this sequence of SCPI cmds: "ABORt;CONFIGure<function>; READ?".
        Note that READ? itself is equivalent to ABORt; INITiate; FETCh?

        :param function: Identifies DMM measurement function:'DCV', 'ACV', 'DCI', 'ACI', 'OHMS2', 'OHMS4', 'FREQ', 'PER'
            If None, instrument function presently selected in the instrument is used.
        :type: str, enum_functions, None:
        :return: the value measured
        :rtype: float
        """

        # :MEASure[:<function>]?
        function_obj = check_enum_str('function', function, self.enum_functions)

        if function_obj is None:
            tmp = self.query('MEAS', float)
        else:
            tmp = self.query(f"MEAS:{function_obj.value}", float)

        self.log_inst_errors()

        return tmp

    def _setup_dc(self, scpi_prefix, bounds, unit, dc_range=None, npl_cycles=None, resolution=None, impedance=None):
        """
        Helper function for DC measurements. Query all or set any combination.

        A DC function in the DMM does not have to be selected to program these parameters. These configuration
        settings for DCV are remembered by the DMM when other functions are selected using the select_function method.

        :param scpi_prefix: SCPI command prefix (CURR:DC, VOLT:DC, RES, FRES) or (self.enum_functions.<function>.value)
        :type scpi_prefix: str (enum value from enum_functions)
        :param bounds: named tuple consisting of values for range min, range max, resolution min, resolution max
        :type bounds: namedtuple
        :param unit: Unit for output (A, V DC, Ohms2w, Ohms4w)
        :type unit: str
        :param dc_range: 'AUTO' or float near expected voltage (0.1 to 1000).
        :type dc_range: str or float
        :param npl_cycles: Integration rate in power line cycles 0.02 to 100.
        :type npl_cycles: float
        :param resolution: Measurement resolution in volts.
        :type resolution: float
        :param impedance:  Enable or disable the automatic input resistance mode
                            'ON' or 'OFF' or 1 or 0
        :type impedance: str, int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:NPLCycles {0.02|0.2|1|10|100|MINimum|MAXimum}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Volts. Effects measurement accuracy over bus!
        # INPut:IMPedance:AUTO {OFF|ON}

        # Query
        if all(v is None for v in {dc_range, npl_cycles, resolution, impedance}):
            return_value = {}
            if self.query(f'{scpi_prefix}:RANG:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'{scpi_prefix}:RANG', float)
            return_value.update(dc_range=value1)

            return_value.update(npl_cycles=self.query(f'{scpi_prefix}:NPLC', float))
            return_value.update(resolution=self.query(f'{scpi_prefix}:RES', float))

            if scpi_prefix != 'VOLT:DC':
                return return_value
            return_value.update(impedance=self.query(f'INP:IMP:AUTO', bool))
            return return_value

        # Validation checks
        if dc_range is not None:
            if dc_range != 'AUTO' and not \
                    (isinstance(dc_range, (float, int)) and (bounds.range_min <= dc_range <= bounds.range_max)):
                raise ValueError(f"Bad dc_range {dc_range}. Should be 'AUTO' or "
                                 f"float value from {bounds.range_min} to {bounds.range_max} {unit}.")

        check_range('npl_cycles', npl_cycles, min_max_units(0.02, 100, ''))
        check_range('resolution', resolution, min_max_units(bounds.res_min, bounds.res_max, ''))

        # Writes (If reached all input values are good)
        if dc_range is not None:
            if dc_range == 'AUTO':
                self.write(f'{scpi_prefix}:RANG:AUTO', 1)
            else:
                self.write(f'{scpi_prefix}:RANG', dc_range)

        if npl_cycles is not None:
            self.write(f'{scpi_prefix}:NPLC', npl_cycles)

        if resolution is not None:
            self.write(f'{scpi_prefix}:RES', resolution)

        if impedance is not None:
            self.write(f'INP:IMP:AUTO', self.on_off.to_inst(impedance))

        self.log_inst_errors()

    def _setup_ac(self, scpi_prefix, bounds, unit, ac_range=None, bandwidth=None, resolution=None):
        """
        Helper function for AC measurements. Query all or set any combination.

        A AC function in the DMM does not have to be selected to program these parameters. These configuration
        settings for ACV are remembered by the DMM when other functions are selected using the select_function method.

        :param scpi_prefix: SCPI command prefix (CURR:AC, VOLT:AC) or (self.enum_functions.<function>.value)
        :type scpi_prefix: str (enum value from enum_functions)
        :param bounds: named tuple consisting of values for range min, range max, resolution min, resolution max
        :type bounds: namedtuple
        :param unit: Unit for output (A, V AC)
        :type unit: str
        :param ac_range: 'AUTO' or float near expected voltage (0.1 to 1000).
        :type ac_range: str or float
        :param bandwidth: Specify the lowest frequency expected in the input signal. (3 to 200 Hz)
        :type bandwidth: float
        :param resolution: Measurement resolution in volts.
        :type resolution: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Amps. Effects measurement accuracy over bus!
        # [SENSe:]DETector:BANDwidth {3|20|200|MINimum|MAXimum}

        # Query
        if all(v is None for v in {ac_range, bandwidth, resolution}):
            return_value = {}
            if self.query(f'{scpi_prefix}:RANG:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'{scpi_prefix}:RANG', float)
            return_value.update(ac_range=value1)
            return_value.update(bandwidth=self.query(f'DET:BAND', float))
            return_value.update(resolution=self.query(f'{scpi_prefix}:RES', float))
            return return_value

        # Validation checks
        if ac_range is not None:
            if ac_range != 'AUTO' and not \
                    (isinstance(ac_range, (float, int)) and (bounds.range_min <= ac_range <= bounds.range_max)):
                raise ValueError(f"Bad ac_range {ac_range}. Should be 'AUTO' or "
                                 f"float value from {bounds.range_min} to {bounds.range_max} {unit}.")

        check_range("bandwidth", bandwidth, min_max_units(3, 200, 'Hz'))
        check_range("resolution", resolution, min_max_units(bounds.res_min, bounds.res_max, ''))

        # Writes (If reached all input values are good)
        if ac_range is not None:
            if ac_range == 'AUTO':
                self.write(f'{scpi_prefix}:RANG:AUTO', 1)
            else:
                self.write(f'{scpi_prefix}:RANG', ac_range)

        if bandwidth is not None:
            self.write(f'DET:BAND', bandwidth)

        if resolution is not None:
            self.write(f'{scpi_prefix}:RES', resolution)

        self.log_inst_errors()

    def setup_aci(self, irange=None, bandwidth=None, resolution=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to AC CURRENT measurements.

        The ACI function in the DMM does not have to selected to program these parameters. These configuration settings
        for ACI are remembered by the DMM when other functions are selected using the select_function method.  Be aware
        that using the measure method will reset all of these settings to their defaults.

        :param irange: 'AUTO' or float near expected current (1.0 to 3.0 A).
        :type irange: float, str
        :param bandwidth:  The frequency of the input signal (3 to 200 Hz)
        :type bandwidth: float
        :param resolution: This DMM specifies actual measurement resolution in the same units as the measurement
            function, (1e-06 to 0.0003 A rms). This is different than the Keithley 2000 which uses digits to specify
            display resolution.
        :type resolution: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function> = CURRent:AC
        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Amps. Effects measurement accuracy over bus!
        # [SENSe:]DETector:BANDwidth {3|20|200|MINimum|MAXimum}

        self.log_unused_args(args, kwargs)

        tmp = self._setup_ac(self.enum_functions.ACI.value, Bounds(1.0, 3.0, 1e-06, 0.0003), 'A',
                             irange, bandwidth, resolution)

        if tmp is not None:
            return tmp

    def setup_dci(self, irange=None, npl_cycles=None, resolution=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to DC CURRENT measurements.

        The DCI function in the DMM does not have to selected to program these parameters. These configuration settings
        for DCI are remembered by the DMM when other functions are selected using the select_function method.  Be aware
        that using the measure method will reset all of these settings to their defaults.

        :param irange: 'AUTO' or float near expected current (0.01 to 3.0 A).
        :type irange: float
        :param npl_cycles:  Integration rate in power line cycles (0.02 to 100).
        :type npl_cycles: float
        :param resolution: This DMM specifies actual measurement resolution in the same units as the measurement
            function, (3e-09 to 0.0003 A). This is different than the Keithley 2000 which uses digits to specify display
            resolution.
        :type resolution: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function> = CURRent:DC
        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:NPLCycles {0.02|0.2|1|10|100|MINimum|MAXimum}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Amps. Effects measurement accuracy over bus!

        tmp = self._setup_dc(self.enum_functions.DCI.value, Bounds(0.01, 3.0, 3e-09, 0.0003), 'A',
                             irange, npl_cycles, resolution)

        self.log_unused_args(args, kwargs)

        if tmp is not None:
            return tmp

    def setup_dcv(self, vrange=None, npl_cycles=None, resolution=None, impedance=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to DC VOLTAGE measurements.

        The DCV function in the DMM does not have to be selected to program these parameters. These configuration
        settings for DCV are remembered by the DMM when other functions are selected using the select_function method.
        Be aware that using the measure method will reset all of these settings to their defaults.

        :param vrange: 'AUTO' or float near expected voltage (0.1 to 1000 V DC).
        :type vrange: float
        :param npl_cycles: Integration rate in power line cycles (0.02 to 100).
        :type npl_cycles: float
        :param resolution: This DMM specifies actual measurement resolution in the same units as the measurement
            function, (3e-08 to 0.09999999 V DC). This is different than the Keithley 2000 which uses digits to specify
            display resolution.
        :type resolution: float
        :param impedance:  Enable or disable the automatic input resistance mode
                            'ON' or 'OFF' or 1 or 0
        :type impedance: int, str
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function> = VOLTage:DC
        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:NPLCycles {0.02|0.2|1|10|100|MINimum|MAXimum}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Volts. Effects measurement accuracy over bus!
        # INPut:IMPedance:AUTO {OFF|ON}

        tmp = self._setup_dc(self.enum_functions.DCV.value, Bounds(0.1, 1000, 3e-08, 0.09999999), 'V DC',
                             vrange, npl_cycles, resolution, impedance)

        self.log_unused_args(args, kwargs)

        if tmp is not None:
            return tmp

    def setup_acv(self, vrange=None, bandwidth=None, resolution=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to AC VOLTAGE measurements.

        The ACV function in the DMM does not have to be selected to program these parameters. These configuration
        settings for ACV are remembered by the DMM when other functions are selected using the select_function method.
        Be aware that using the measure method will reset all of these settings to their defaults.

        :param vrange:  'AUTO' or float near expected voltage (0.1 to 1000 V AC).
        :type vrange: float
        :param bandwidth: The frequency of the input signal (3 to 200 Hz)
        :type bandwidth: float
        :param resolution: This DMM specifies actual measurement resolution in the same units as the measurement
            function, (1e-07 to 0.09999999 V rms). This is different than the Keithley 2000 which uses digits to specify
            display resolution.
        :type resolution: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function> = VOLTage:AC
        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Volts. Effects measurement accuracy over bus!
        # [SENSe:]DETector:BANDwidth {3|20|200|MINimum|MAXimum}

        tmp = self._setup_ac(self.enum_functions.ACV.value, Bounds(0.1, 1000, 1e-07, 0.09999999), 'V AC',
                             vrange, bandwidth, resolution)

        self.log_unused_args(args, kwargs)

        if tmp is not None:
            return tmp

    def setup_ohms2w(self, rrange=None, npl_cycles=None, resolution=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to Two-Wire RESISTANCE measurements.

        The OHMS2 function in the DMM does not have to selected to program these parameters. These configuration
        settings for OHMS2 are remembered by the DMM when other functions are selected using the select_function method.
        Be aware that using the measure method will reset all of these settings to their defaults.

        :param rrange: 'AUTO' or float near expected resistance (100.0 to 1e08 Ohms).
        :type rrange: float, str
        :param npl_cycles: Integration rate in power line cycles (0.02 to 100).
        :type npl_cycles: float
        :param resolution: This DMM specifies actual measurement resolution in the same units as the measurement
            function, (3e-05 to 10000.0 Ohms). This is different than the Keithley 2000 which uses digits to specify
            display resolution.
        :type resolution: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function> = RES
        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:NPLCycles {0.02|0.2|1|10|100|MINimum|MAXimum}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Ohms. Effects measurement accuracy over bus!

        self.log_unused_args(args, kwargs)

        tmp = self._setup_dc(self.enum_functions.OHMS2.value, Bounds(100.0, 1e08, 3e-05, 10000.0), 'Ohms2w',
                             rrange, npl_cycles, resolution)

        if tmp is not None:
            return tmp

    def setup_ohms4w(self, rrange=None, npl_cycles=None, resolution=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to Four-Wire RESISTANCE measurements.

        The OHMS4 function in the DMM does not have to selected to program these parameters. These configuration
        settings for OHMS4 are remembered by the DMM when other functions are selected using the select_function method.
        Be aware that using the measure method will reset all of these settings to their defaults.

        :param rrange: 'AUTO' or float near expected resistance (100.0 to 1e08 Ohms).
        :type rrange: float, str
        :param npl_cycles: Integration rate in power line cycles (0.02 to 100).
        :type npl_cycles: float
        :param resolution: This DMM specifies actual measurement resolution in the same units as the measurement
            function, (3e-05 to 10000.0 Ohms). This is different than the Keithley 2000 which uses digits to specify
            display resolution.
        :type resolution: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # <function> = FRES
        # <function>:RANGe {<range>|MINimum|MAXimum}
        # <function>:RANGe:AUTO {OFF|ON}
        # <function>:NPLCycles {0.02|0.2|1|10|100|MINimum|MAXimum}
        # <function>:RESolution {<resolution>|MINimum|MAXimum}      In Ohms. Effects measurement accuracy over bus.

        self.log_unused_args(args, kwargs)

        tmp = self._setup_dc(self.enum_functions.OHMS4.value, Bounds(100.0, 1e08, 3e-05, 10000.0), 'Ohms4w',
                             rrange, npl_cycles, resolution)

        if tmp is not None:
            return tmp

    def setup_freq(self, threshold=None, aperture=None, *args, **kwargs):
        """
        Queries all or sets parameters relating to measuring input frequency.

        :param threshold: Threshold is used to specify the expected input level. The instrument will then automatically
                select the most sensitive voltage threshold range. (0.1 to 1000 V)
        :type threshold: float, str
        :param aperture: aperture time (or gate time) is analogous to integration time (0.01 to 1)
        :type aperture: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # FREQuency:VOLTage:RANGe {<range>|MINimum|MAXimum}         threshold
        # FREQuency:VOLTage:RANGe:AUTO {OFF|ON}
        # FREQuency:APERture {0.01|0.1|1|MINimum|MAXimum}   Corresponds to digits, see manual. Make work if either given

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {threshold, aperture}):
            return_value = {}
            if self.query(f'FREQ:VOLT:RANG:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'FREQ:VOLT:RANG', float)
            return_value.update(threshold=value1)
            return_value.update(aperture=self.query(f'FREQ:APER', float))
            return return_value

        if threshold is not None:
            if threshold != 'AUTO' and not (isinstance(threshold, (float, int)) and (0.1 <= threshold <= 1000)):
                raise ValueError(f"Bad threshold {threshold}. "
                                 f"Should be 'AUTO' or float value from 0.1 to 1000 V.")

        check_range('aperture', aperture, min_max_units(0.01, 1, "Seconds"))

        if threshold is not None:
            if threshold == 'AUTO':
                self.write(f'FREQ:VOLT:RANG:AUTO', 1)
            else:
                self.write(f'FREQ:VOLT:RANG', threshold)

        if aperture is not None:
            self.write(f'FREQ:APER', aperture)

        self.log_inst_errors()

    def setup_period(self, threshold=None, aperture=None, *args, **kwargs):
        """
        Queries all or sets parameters relating to measuring input period.

        :param threshold: Threshold is used to specify the expected input level. The instrument will then automatically
                select the most sensitive voltage threshold range. (0.1 to 1000 V)
        :type threshold: float, str
        :param aperture:  aperture time (or gate time) is analogous to integration time (0.01 to 1)
        :type aperture: float
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # PERiod:VOLTage:RANGe {<range>|MINimum|MAXimum}         threshold
        # PERiod:VOLTage:RANGe:AUTO {OFF|ON}
        # PERiod:APERture {0.01|0.1|1|MINimum|MAXimum}   Corresponds to digits, see manual. Make work if either given?

        self.log_unused_args(args, kwargs)

        if all(v is None for v in {threshold, aperture}):
            return_value = {}
            if self.query(f'PER:VOLT:RANG:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'PER:VOLT:RANG', float)
            return_value.update(threshold=value1)
            return_value.update(aperture=self.query(f'PER:APER', float))
            return return_value

        if threshold is not None:
            if threshold != 'AUTO' and not (isinstance(threshold, (float, int)) and (0.1 <= threshold <= 1000)):
                raise ValueError(f"Bad threshold {threshold}. "
                                 f"Should be 'AUTO' or float value from 0.1 to 1000 V.")

        check_range('aperture', aperture, min_max_units(0.01, 1, "Seconds"))

        if threshold is not None:
            if threshold == 'AUTO':
                self.write(f'PER:VOLT:RANG:AUTO', 1)
            else:
                self.write(f'PER:VOLT:RANG', threshold)

        if aperture is not None:
            self.write(f'PER:APER', aperture)

        self.log_inst_errors()

    def select_function(self, function=None):
        """
        Query or select the measurement function of the instrument. Note that each measurement function in the DMM
        remembers its unique setup configuration such as range, npl_cycles, etc. that you may have previously setup
        using the setup_<function> methods. select_function allows for rapid switching between functions without
        re-programming the configurations.

        :param function: Identifies measurement function: 'DCV', 'ACV', 'DCI', 'ACI', 'OHMS2', 'OHMS4', 'FREQ', 'PER'.
            If None, instrument function is queried.
        :type function: str, enum_functions
        :return: The function mnemonic corresponding to the return value of the query.
        :rtype: str
        """

        # function = suffix of config. Use enum to map to names needed by instrument, see p 168
        # [:SENSe[1]]:FUNCtion <name>

        if function is None:
            tmp = self.query('FUNC', str).strip('"')
            return self.enum_functions(tmp).name

        function_obj = check_enum_str('function', function, self.enum_functions)

        if function_obj is not None:
            self.write('FUNC', f'"{function_obj.value}"')

        self.log_inst_errors()

    def initiate(self, *args, **kwargs):
        """
        Change the state of the triggering system from the “idle” state to the
        “wait-for-trigger” state. Measurements will begin when the specified
        trigger conditions are satisfied after the INITiate command is
        received. The readings are placed in the multimeter’s internal memory
        (up to 512 readings can be stored). Readings are stored in memory until
        you are able to retrieve them. Use the FETCh? command to retrieve
        reading results.
        """

        # INITiate     # There is no IMMediate vs CONTinuous like on Keithley.

        self.log_unused_args(args, kwargs)

        self.write('INIT', '')

        self.log_inst_errors()

    def abort(self):
        """
        Command halts any measurement in progress via device clear (an IEEE-488 low-level bus message)
        """

        self.rm_handle.clear()  # See p 76 of manual.

    def setup_trigger(self, event_source=None, delay_sec=None, sample_count=None, trig_count=None, ):
        """
        Query all or set any combination parameters related to the trigger system.  This allows for measurements to be
        made when a trigger is received.

        :param event_source: 'IMM', 'EXT', 'BUS'
        :type event_source: str
        :param delay_sec: Delay between detection of an event and the the start of a "Device Action".
            0 to 3600 seconds. A Device Action is primarily a measurement, but may include: Filtering or Hold
            operations,  which involve acquiring multiple readings to produce a measurement result.
        :type delay_sec: float, str
        :param sample_count: Readings performed per trigger.
        :type sample_count: int
        :param trig_count: Number of triggers that must occur before returning to the Idle state (1 to 50000)
        :type trig_count: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """

        # TRIGger:SOURce {BUS|IMMediate|EXTernal}
        # TRIGger:DELay {<seconds>|MINimum|MAXimum}  0 to 3600 seconds.
        # TRIGger:DELay:AUTO {OFF|ON}
        # SAMPle:COUNt {<value>|MINimum|MAXimum}  readings per trigger 1...50,000
        # TRIGger:COUNt {<value>|MINimum|MAXimum|INFinite} Number of triggers before retuning to idle. 1...50,000

        if all(v is None for v in {event_source, delay_sec, sample_count, trig_count}):
            return_value = {}
            return_value.update(event_source=self.query('TRIG:SOUR', str))

            if self.query(f'TRIG:DEL:AUTO', bool):
                value1 = 'AUTO'
            else:
                value1 = self.query(f'TRIG:DEL', float)
            return_value.update(delay_sec=value1)

            return_value.update(sample_count=self.query('SAMP:COUN', int))
            return_value.update(trig_count=self.query('TRIG:COUN', int))
            return return_value

        if event_source is not None:
            event_source_tup = ('IMM', 'EXT', 'BUS')
            if event_source in event_source_tup:
                self.write('TRIG:SOUR', event_source)
            else:
                raise ValueError(f'Bad event_source {event_source}. Should be one of {event_source_tup}.')

        if delay_sec is not None:
            if delay_sec != 'AUTO' and not (isinstance(delay_sec, (float, int)) and (0 <= delay_sec <= 3600)):
                raise ValueError(f"Bad delay_sec {delay_sec}. "
                                 f"Should be 'AUTO' or float value from 0 to 3600 seconds.")

        check_range("sample_count", sample_count, min_max_units(1, 50000, ''), val_type=int)
        check_range("trig_count", trig_count, min_max_units(1, 50000, ''), val_type=int)

        # If reached all input values are good
        if event_source is not None:
            self.write('TRIG:SOUR', event_source)

        if delay_sec is not None:
            if delay_sec == 'AUTO':
                self.write(f'TRIG:DEL:AUTO', 1)
            else:
                self.write(f'TRIG:DEL', delay_sec)

        if sample_count is not None:
            self.write('SAMP:COUN', sample_count)

        if trig_count is not None:
            self.write('TRIG:COUN', trig_count)

        self.log_inst_errors()

    def fetch(self):
        """
        Transfer readings stored in the multimeter’s internal memory by the INITiate command to the multimeter’s output
        buffer where you can read them into your PC.
        """

        # FETCH?

        return self.query('FETCH', float)

    def read(self):
        """
        Change the state of the trigger system from the “idle” state to the “wait-for-trigger” state. Measurements
        will begin when the specified trigger conditions are satisfied following the receipt of the READ?
        command. Readings are sent immediately to the output buffer.
        """

        # READ?

        return self.query('READ', float)

    def get_fr_switch(self):
        """
        Returns whether front or rear inputs are selected.

        :return: 'FRONT', 'REAR'
        :rtype: str

        """

        # ROUTe:TERMinals?

        tmp = self.query('ROUT:TERM', str)
        if tmp == 'FRON':
            return "FRONT"
        else:
            return "REAR"


if __name__ == '__main__':
    dmm34401A = DMM34401A('GPIB0::27')   # Replace visa_resource_name with None for simulated hardware.
    dmm34401A.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
