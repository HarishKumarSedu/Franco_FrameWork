# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Inherit from the instrument classes
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.base_classes.dmm_basic_ABC import DmmBasic_ABC
# Include Other Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import *  # imports all from file

# Include Python libraries
from time import sleep
from enum import Enum
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# This instrument uses a non standard way of communicating errors
# all commands return some kind of confirmation, with error messages
# detailed in the _msg_dict.
# Because of this, all writes are queries, and both methods are overloaded to
# to interpret theses quirks.
# There is also a minimal SCPI command set for this instrument. Documentation
# is sparse and is missing key commands like *ERR.
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class DMM8104(InstrumentVisa, DmmBasic_ABC):
    """Class for controlling Transmille 8104 Digital Multimeter."""

    #  Data and Structures
    # -----------------------------------------------------------
    # Known as FILTER SPEED in documentation
    _enum_sample_period = Enum('_enum_sample_period', {'125ms': 0, '250ms': 1, '500ms': 2,
                                                       '1s': 3, '2s': 4, '4s': 5, '8s': 6,
                                                       '16s': 7, '32s': 8, '64s': 9})
    # Function modes
    # SCPI COMMANDS ARE WRONG IN MANUAL!
    # change function with FUNC DC:VOLT
    enum_functions = Enum('enum_functions',
                          {'DCV': 'DC:VOLT', 'ACV': 'AC:VOLT', 'DCI': 'DC:CURR', 'ACI': 'AC:CURR',
                           'OHM2W_LOWI': 'RES:LOWI', 'OHM4W_LOWI': 'FRES:LOWI', 'OHM2W': 'RES:HIGHI',
                           'OHM4W': 'FRES:HIGHI', "THERMO": "THERMOCOUPLE:"})

    # named tuples for min max range checks
    volt_range = min_max_units(0.1, 1000, "Volts")
    ac_curr_range = min_max_units(1e-4, 30, "Amps")
    dc_curr_range = min_max_units(1e-8, 30, "Amps")
    resistance_lowi_range = min_max_units(100, 1e4, "Ohms")
    resistance_2wire_range = min_max_units(10, 1e9, "Ohms")
    resistance_4wire_range = min_max_units(1, 1e5, "Ohms")

    # Error Message Dictionary
    _msg_dict = {'*2': "Command correct with an incorrect input signal",
                 '*3': "Command correct with incorrect or missing parameters",
                 '*6': "Unauthorised command",
                 '*7': "Command sent with incorrect range",
                 '*9': "Unrecognised Command",
                 }  # "*0" : Sucessful Command. don't want to include it here since msg_dict is used in error checks

    # Power on default settings for the machine. The dictionary is overwritten in methods
    # This is used since the instrument does not query for many commands
    _default_settings_dict = {'FUNCTION': "DCV",
                              "RANGE": 1000,
                              "AUTORANGE": "OFF",
                              "RESOLUTION": 7,
                              "PERIOD": '1s',
                              "MATHS": "OFF",
                              "TRIGGER": "AUTO",
                              "INPUT": "FRONT",
                              "GUARD": "OPEN"
                              }
    _settings_dict = _default_settings_dict  # set the settings to the default at the beginning and on reset
    _settings_msg = "The parameters you receive may not be the instruments true state if local changes have been made."
    _not_implemented_msg = "The Transmille 8104 does not support this method"
    _response_code_list = ['*0', "*2", '*3', '*6', '*7', '*9']
    #  init
    # -----------------------------------------------------------

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):
        super().__init__(visa_resource_name, logger,
                         model_re='^8104$',  # match the model string from the IDN
                         sim_idn='TRANSMILLE,8104,,1.3.7+1.0',  # a simulated IDN string
                         **kwargs)
        self.error_queue = []
        self.reset()  # this is good for consistency of settings on the machine with the python code, may be unwanted.

    #  Methods
    # -----------------------------------------------------------

    def setup_dci(self, irange=None, sample_period=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to DC current measurements.

        Changes the function state to DC Current for the method to work.

        :param irange: DC Current Range, in ascending decade values from 10nA to 30A
        :type irange: int
        :param sample_period: time Period for the meter to obtain a sample
        :type sample_period: str
        :param digits: Values 4 through 8 correspond to a display resolution of 4.5 to 8.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """
        # SCPI Commands
        # RANGE:DC:CURRent <value> #DC CURRENT  Value = 0.000,000,01 to 30

        # log unused arguments
        self.log_unused_args(args, kwargs)

        # read back
        if all(param is None for param in [irange, digits, sample_period]):
            return_value = {}
            return_value.update(function=self.select_function())
            range_str = self.query("RANGE")  # range string returns function and range, parse in line
            return_value.update(irange=range_str[range_str.find(' ')+1:])
            return_value.update(digits=self._settings_dict['RESOLUTION'])  # cannot be queried
            return_value.update(sample_period=self._settings_dict['PERIOD'])  # cannot be queried
            return return_value

        # resolution and sample period check
        period_obj = self._r_and_sp_check(digits, sample_period)  # methods returns the enum obj of the period
        check_range('irange', irange, self.dc_curr_range)

        # Handles writing to the instrument and the settings_dict
        self.select_function(self.enum_functions.DCI.name)
        sleep(0.5)
        self._setup_helper(func_value=irange, resolution=digits,
                           period_obj=period_obj, enum_functions_obj=self.enum_functions.DCI)
        self.log_inst_errors()

    def setup_aci(self, irange=None, sample_period=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to AC current measurements.

        Changes the function state to AC Current for the method to work.

        :param irange: AC Current Range, in ascending decade values from 100uA to 30A
        :type irange: int
        :param sample_period: time Period for the meter to obtain a sample
        :type sample_period: str
        :param digits: Values 4 through 8 correspond to a display resolution of 4.5 to 8.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """
        # SCPI Commands
        # RANGE:AC:CURRent <value> #AC CURRENT Value = 0.000,1 to 30

        # log unused arguments
        self.log_unused_args(args, kwargs)

        # read back
        if all(param is None for param in [irange, digits, sample_period]):
            return_value = {}
            return_value.update(function=self.select_function())
            range_str = self.query("RANGE")  # range string returns function and range, parse in line
            return_value.update(irange=range_str[range_str.find(' ')+1:])
            return_value.update(digits=self._settings_dict['RESOLUTION'])  # cannot be queried
            return_value.update(sample_period=self._settings_dict['PERIOD'])  # cannot be queried
            return return_value

        # resolution and sample period check

        period_obj = self._r_and_sp_check(digits, sample_period)  # methods returns the enum obj of the period
        check_range('irange', irange, self.ac_curr_range)

        # Handles writing to the instrument and the settings_dict
        self.select_function(self.enum_functions.ACI.name)
        sleep(0.5)
        self._setup_helper(func_value=irange, resolution=digits,
                           period_obj=period_obj, enum_functions_obj=self.enum_functions.ACI)
        self.log_inst_errors()

    def setup_dcv(self, vrange=None, sample_period=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to DC voltage measurements.

        Changes the function state to DC Voltage for the method to work.

        :param vrange: DC Voltage Range, in ascending decade values from 0.1 to 1000
        :type vrange: int
        :param sample_period: time Period for the meter to obtain a sample
        :type sample_period: str
        :param digits: Values 4 through 8 correspond to a display resolution of 4.5 to 8.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """
        # SCPI Commands
        # RANGE:DC:VOLTage <value> #DC VOLTAGE  Value = 0.1 to 1,000
        # x[x.find(' ')+1:]

        # log unused arguments
        self.log_unused_args(args, kwargs)

        # read back
        if all(param is None for param in [vrange, digits, sample_period]):
            return_value = {}
            return_value.update(function=self.select_function())
            range_str = self.query("RANGE")  # range string returns function and range, parse in line
            return_value.update(vrange=range_str[range_str.find(' ')+1:])
            return_value.update(digits=self._settings_dict['RESOLUTION'])  # cannot be queried
            return_value.update(sample_period=self._settings_dict['PERIOD'])  # cannot be queried
            return return_value

        # resolution and sample period check
        period_obj = self._r_and_sp_check(digits, sample_period)  # methods returns the enum obj of the period
        check_range('vrange', vrange, self.volt_range)

        # Handles writing to the instrument and the settings_dict
        self.select_function(self.enum_functions.DCV.name)
        sleep(0.5)
        self._setup_helper(func_value=vrange, resolution=digits,
                           period_obj=period_obj, enum_functions_obj=self.enum_functions.DCV)

        self.log_inst_errors()

    def setup_acv(self, vrange=None, sample_period=None, digits=None, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to AC voltage measurements.

        Changes the function state to AC Voltage for the method to work.

        :param vrange: AC Voltage Range, in ascending decade values from 0.1 to 1000
        :type vrange: int
        :param sample_period: time Period for the meter to obtain a sample
        :type sample_period: str
        :param digits: Values 4 through 8 correspond to a display resolution of 4.5 to 8.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """
        # SCPI Commands
        # RANGE:AC:VOLTage <value> #AC VOLTAGE Value = 0.1 to 1,000

        # log unused arguments
        self.log_unused_args(args, kwargs)

        # read back
        if all(param is None for param in [vrange, digits, sample_period]):
            return_value = {}
            return_value.update(function=self.select_function())
            range_str = self.query("RANGE")  # range string returns function and range, parse in line
            return_value.update(vrange=range_str[range_str.find(' ')+1:])
            return_value.update(digits=self._settings_dict['RESOLUTION'])  # cannot be queried
            return_value.update(sample_period=self._settings_dict['PERIOD'])  # cannot be queried
            return return_value

        # resolution and sample period check
        period_obj = self._r_and_sp_check(digits, sample_period)  # methods returns the enum obj of the period
        check_range('vrange', vrange, self.volt_range)

        # Handles writing to the instrument and the settings_dict
        self.select_function(self.enum_functions.ACV.name)
        sleep(0.5)
        self._setup_helper(func_value=vrange, resolution=digits,
                           period_obj=period_obj, enum_functions_obj=self.enum_functions.ACV)
        self.log_inst_errors()

    def setup_ohms2w(self, rrange=None, sample_period=None, digits=None, low_curr=True, *args, **kwargs):
        """
        Query all or set any combination of parameters relating to 2-Wire resistance measurements.

        Changes the function state to Ohms 2-wire with low/normal current for the method to work.

        :param rrange: Resistance Range, in ascending decade values from 10Ω to 1GΩ
                       More restrictive for low current.
        :type rrange: int
        :param sample_period: time Period for the meter to obtain a sample
        :type sample_period: str
        :param low_curr: Flag to enable Low current mode> turn to false to allow for larger resistance range
        :type low_curr: bool | on_off
        :param digits: Values 4 through 8 correspond to a display resolution of 4.5 to 8.5 digits. Reading
            returned over the bus remains full precision. This is different than the resolution setting of the Agilent
            DMMs.
        :type digits: int
        :return: Parameter names and values as read from the DMM.
        :rtype: dict
        """
        # RANGE:RESistance:LOWI <value> # 2WIRE RESISTANCE LOW CURRENT  Value = 100 to 10,000
        # RANGE:RESistance <value> # 2WIRE RESISTANCE   Value = 10 to 1,000,000,000

        # log unused arguments
        self.log_unused_args(args, kwargs)

        # Read back
        if all(param is None for param in [rrange, digits, sample_period]):
            return_value = {}
            return_value.update(function=self.select_function())
            range_str = self.query("RANGE")  # range string returns function and range, parse in line
            return_value.update(rrange=range_str[range_str.find(' ')+1:])
            return_value.update(digits=self._settings_dict['RESOLUTION'])  # cannot be queried
            return_value.update(sample_period=self._settings_dict['PERIOD'])  # cannot be queried
            return return_value

        self.select_function()

        # check parameters
        if low_curr in self.on_off.api_on_values():
            self.log.warning("Resistance measurement defaults to low current mode for safety purposes. \n"
                             " Override by setting low_curr False in method setup parameters")
            functions_obj = self.enum_functions.OHM2W_LOWI
            check_range('rrange', rrange, self.resistance_lowi_range)
        elif low_curr in self.on_off.api_off_values():
            functions_obj = self.enum_functions.OHM2W
            check_range('rrange', rrange, self.resistance_2wire_range)
        else:  # error out with possible low curr values
            functions_obj = None
            self.on_off.to_inst(low_curr)

        period_obj = self._r_and_sp_check(digits, sample_period)  # methods returns the enum obj of the period

        # Handles writing to the instrument and the settings_dict
        self.select_function(functions_obj.name)
        sleep(0.5)
        self._setup_helper(func_value=rrange, resolution=digits,
                           period_obj=period_obj, enum_functions_obj=functions_obj)
        self.log_inst_errors()  # log errors

    def setup_ohms4w(self, rrange=None, sample_period=None, digits=None, low_curr=True, *args, **kwargs):
        """
          Query all or set any combination of parameters relating to 4-Wire resistance measurements.

          Changes the function state to Ohms 4-wire with low/normal current for the method to work.

          :param rrange: Resistance Range, in ascending decade values from 1Ω to 100kΩ.
                         More restrictive for low current.
          :type rrange: int
          :param sample_period: time Period for the meter to obtain a sample
          :type sample_period: str
          :param low_curr: Flag to enable Low current mode turn to false to allow for larger resistance range
          :type low_curr: bool | on_off
          :param digits: Values 4 through 8 correspond to a display resolution of 4.5 to 8.5 digits. Reading
              returned over the bus remains full precision. This is different than the resolution setting of the Agilent
              DMMs.
          :type digits: int
          :return: Parameter names and values as read from the DMM.
          :rtype: dict
          """
        # RANGE:FRESistance:LOWI <value> # 4WIRE RESISTANCE LOW CURRENT  Value = 100 to 10,000
        # RANGE:FRESistance:HIGHI <value> # 4WIRE RESISTANCE   Value = 1 to 100,000

        # log unused arguments
        self.log_unused_args(args, kwargs)

        # Read back
        if all(param is None for param in [rrange, digits, sample_period]):
            # self.log.warning(self._settings_msg)  # TODO: Remove/Edit if commands become callable, applies to all.
            return_value = {}
            return_value.update(function=self.select_function())
            range_str = self.query("RANGE")  # range string returns function and range, parse in line
            return_value.update(rrange=range_str[range_str.find(' ')+1:])
            return_value.update(digits=self._settings_dict['RESOLUTION'])  # cannot be queried
            return_value.update(sample_period=self._settings_dict['PERIOD'])  # cannot be queried
            return return_value

        self.select_function()

        # check parameters
        if low_curr in self.on_off.api_on_values():
            self.log.warning("Resistance measurement defaults to low current mode for safety purposes. \n"
                             " Override by setting low_curr False in method setup parameters")
            functions_obj = self.enum_functions.OHM4W_LOWI
            check_range('rrange', rrange, self.resistance_lowi_range)

        elif low_curr in self.on_off.api_off_values():
            check_range('rrange', rrange, self.resistance_4wire_range)
            functions_obj = self.enum_functions.OHM4W
        else:  # error out with possible low curr values
            functions_obj = None
            self.on_off.to_inst(low_curr)

        period_obj = self._r_and_sp_check(digits, sample_period)  # methods returns the enum obj of the period

        # Handles writing to the instrument and the settings_dict
        self.select_function(functions_obj.name)
        sleep(0.5)
        self._setup_helper(func_value=rrange, resolution=digits,
                           period_obj=period_obj, enum_functions_obj=functions_obj)
        self.log_inst_errors()  # log errors

    def select_function(self, function=None):
        """
        Select or query the function of the Multimeter.

        :param function: Function string, sent to select a AC/DC measurement of voltage, current, and resistance
        :type function: str | enum_functions
        :return: current function the instrument is in.
        :rtype: str | None
        """
        # FUNC:[AC/DC]:[VOLTAGE/CURRENT]

        # Read back
        if function is None:

            ret_val = self._check_function_state()
            self._settings_dict["FUNCTION"] = ret_val  # update function param
            self.log_inst_errors()
            return ret_val

        # check input
        function_obj = check_enum_str('function', function, self.enum_functions)

        # write to the machine
        try:
            # FUNC DC:VOLTAGE
            self.write(f"FUNC {function_obj.value}")
        except BaseException:
            raise RuntimeError("Instrument did not respond to the FUNC command. The firmware may be out of date. "
                               "You will have to change the function manually (locally). ")
        else:
            # update the python settings dict if try statement did not fail
            self._settings_dict["FUNCTION"] = function_obj.name
            self.log_inst_errors()

    def measure(self, digits=_settings_dict["RESOLUTION"], sample_period=_settings_dict["PERIOD"], *args, **kwargs):
        """
        More sophisticated and preferred read method for when taking measurements.

        :param digits: trailing digit resolution. values from 4 to 8. Power on default is 7
        :type digits: int
        :param sample_period: period to sample for a reading from 125msec to 64sec. Power on default is 1 sec
        :type sample_period: str
        :return: measurement reading without units.
        :rtype: float
        """
        # D<Digits>  #SET RESOLUTION digits = 4 to 8
        # F<Filter_Range>
        # #SET FILTER Filter_Range = 0 to 9
        # # where 0:125ms, 1:250ms, 2:500ms, 3:1s, 4:2s, 5:4s, 6:8s, 7:16s, 8:32s, 9:64s

        # Log unused parameters
        self.log_unused_args(args, kwargs)

        # check input values
        period_obj = self._r_and_sp_check(digits, sample_period)  # methods returns the enum obj of the period

        # if period is large extend the piVISA timeout
        large_period = None
        if sample_period in ['8s', '16s', '32s', '64s']:
            # get the int value of the extended period in milliseconds
            large_period = True
            self.log.warning(f"The sample period used may take up to a minute to complete this operation.")

        # if the parameters being passed in are not the current values on the instrument, update values.
        if digits != self._settings_dict["RESOLUTION"]:
            self.write(f"D{digits}")
            sleep(0.1)
            self._settings_dict['RESOLUTION'] = digits
        if sample_period != self._settings_dict["PERIOD"]:
            self.write(f"F{period_obj.value}")
            sleep(0.1)
            self._settings_dict['PERIOD'] = sample_period
        self.log_inst_errors()

        # The sampling period greater than 4 seconds requires a longer timeout period, requiring the edit of timeout.
        # The Instrument also does not continuously hold the measurement value in the read buffer, so for 32s and 64s
        # measurements, the machine needs to be probed for the value a few times before returning a value.
        default_timeout = self.rm_handle.timeout
        if large_period:
            self.rm_handle.timeout = 10000  # give ten seconds for timeout, good enough for 8s and 16s

        return_val = None
        attempts = 6  # attempts usually catch the value within 3 tries, this 6 attempts with 10 second timeout = 1 min
        for i in range(attempts):
            # print(f"attempt {i+1}:")  # helped with debug
            try:
                return_val = (self.query("READ"))  # READ?  #Returns the next reading obtained by the Instrument
            except:
                attempts -= 1
                self.log.warning(f"Measurement value was not in read buffer. Trying {attempts} more attempts")
            else:
                break  # needed to break the for loop

        self.rm_handle.timeout = default_timeout  # set timeout back to default
        self.log_inst_errors()

        return float(return_val)

    def backlight(self, state=None):
        """
         writes the state of the display backlight. Cannot query.

        :param state: Turn the backlight 'ON' or 'OFF'
        :type state: int | str
        """
        # DISPLAY:BACKLIGHT<parameter> #BACKLIGHT ENABLE 0/1 or on/off
        self.write('DISPLAY:BACKLIGHT', self.on_off.to_inst(state))
        self.log_inst_errors()

    def temp_internal(self):
        """
         Queries the Internal temp of the Multimeter in degrees Celsius.

        :return: Return the status of the backlight
        :rtype: str
        """
        # *TEMP? # The Instrument will respond with the internal temperature in °C
        temperature = self.query('TEMP').lstrip('*0\r')
        return temperature+'C'

    def read(self):
        """Returns the next reading obtained by the Instrument"""
        return self.query("READ?")  # READ?

    #  Overloaded Methods
    # -----------------------------------------------------------

    def write(self, cmd, val=None):
        """
        Wrapper around pyvisa write to support logging, and instrument simulation.

        :param cmd: Command string
        :type cmd: str
        :param val: a single value to be written by the command to the instrument.
        :type val: str, int, float
        :return: None
        """
        if val is None:
            resp = self.rm_handle.query(f"{cmd}")
        else:
            resp = self.rm_handle.query(f"{cmd} {val}")
        self._response_check(resp)

    def query(self, cmd, rtn_type=None, *args, **kwargs):
        """Wrapper around pyvisa query to support return type conversion, logging, and instrument simulation.

        :param cmd: Command string, you may omit the '?' character on the end
        :type cmd: str
        :param rtn_type: a Python type to cast the return value, e.g. str, int, float, bool, an enum. If not specified,
            defaults to str. **Note:** When using the Framework, do not specify the type as it cannot be serialized
            and transported through the Pyro server.
        :type rtn_type: a Python type object
        :return: the value returned from the instrument converted (cast) to the specified type.
        """
        cmd = cmd.rstrip('?') + '?'  # Ensure actual command includes '?'.
        value_str = self.rm_handle.query(cmd).strip()  # Remove newline in response.

        if rtn_type is None:
            rtn_type = str

        if rtn_type is bool:
            value = rtn_type(int(value_str))
        else:
            value = rtn_type(value_str)

        error_response = self._response_check(value_str)
        if error_response is False:
            return value

    def get_inst_errors(self, **kwargs):
        """Overloaded function from instrument class. Obtains all errors from the error queue"""

        temp = self.error_queue
        self.error_queue = []
        return temp

    def reset(self):
        """
        Reset method that overloads the instrument base reset with the added functionality
        of receiving the identification string.
        """

        super().reset()
        sleep(1.0)
        idn = self.get_idn()
        # set the settings to the default at the beginning and on reset
        self._settings_dict = self._default_settings_dict
        sleep(1.0)
        return idn

# Helper Methods
# -----------------------------------------------------------

    def _response_check(self, resp):
        """Response parsing for interpretation of the instrument errors. used in write/query"""
        resp = resp.lstrip('*0')
        resp = resp.lstrip('\r')
        resp = resp.strip('\r\n')
        msg = self._msg_dict.get(resp)
        if msg is not None:
            self.error_queue.append(msg)
            return True
        return False

    def _r_and_sp_check(self, resolution=None, sample_period=None):
        """Helper method to check the resolution and sample period values"""
        # Check input Values
        check_range('Resolution', resolution, min_max_units(4, 8, 'digits'))
        period_obj = check_enum_str("sample_period", sample_period, self._enum_sample_period)
        return period_obj

    def _setup_helper(self, func_value=None, resolution=None, period_obj=None, enum_functions_obj=None):
        """Helper method that writes to both the instrument and the _settings_dict"""

        # Check that the function matches the desired functions_obj before writing otherwise you change the wrong RANGE
        # self._check_function_state(enum_functions_obj, low_curr=low_curr)
        # write to the machine and update the settings_dict
        if func_value is not None:  # "RANGE:{enum_functions.DCV.value} {vrange}" == "RANGE:DC:VOLT [number]
            self.write(f"RANGE:{enum_functions_obj.value}", func_value)
            self._settings_dict['RANGE'] = func_value
        if resolution is not None:
            self.write(f"D{resolution}")
            self._settings_dict['RESOLUTION'] = resolution
        if period_obj is not None:
            self.write(f"D{period_obj.value}")
            self._settings_dict['PERIOD'] = period_obj.name

    def _check_function_state(self, enum_functions_obj=None, low_curr=None):
        """helper function to check the function state, or check it against a specific state"""

        # beginning of range query returns the current function.
        func_str = self.query("RANGE")
        func_str = func_str[:func_str.find(' ')]
        # if the current mode is resistance and the last function setting was LOWI return.

        # There is no way to determine if in low current mode based on query. make func_str match other names
        if func_str in ['RES', "FRES"]:
            func_str = {'RES': "OHM2W", "FRES": "OHM4W"}.get(func_str)
            if low_curr or self._settings_dict["FUNCTION"] in ['OHM2W_LOWI', "OHM4W_LOWI"]:
                func_str += "_LOWI"

        self._settings_dict["FUNCTION"] = func_str  # update function param

        if enum_functions_obj is not None:  # if a object is passed in, we check it against the current state
            if func_str != enum_functions_obj.name:
                raise ValueError(f"Bad Function state {func_str}. "
                                 f"Use select_function to change function before setting values.")

        return func_str

    #  DMM ABC Methods not being implemented
    # -----------------------------------------------------------
    # TODO: perhaps pass the not implemented message up to abstract base class to be overwritten

    def setup_freq(self, threshold, *args, **kwargs):
        raise NotImplementedError(self._not_implemented_msg)

    def setup_period(self, threshold, *args, **kwargs):
        raise NotImplementedError(self._not_implemented_msg)

    def setup_trigger(self, event_source, delay_sec, samp_count, trig_count):
        raise NotImplementedError(self._not_implemented_msg)

    def initiate(self, *args, **kwargs):
        # INITiate
        raise NotImplementedError(self._not_implemented_msg)

    def abort(self):
        raise NotImplementedError(self._not_implemented_msg)

    def fetch(self):
        raise NotImplementedError(self._not_implemented_msg)


# Further Implementation
# -----------------------------------------------------------
    # TODO: need further info (from Manufacturer?) to implement the below commands.
    # SCPI Commands
    # -------------------
    # #THERMOCOUPLE TC_TYPE = B,E,J,K,N,R,S,T   Cold_Junction = -273 to 1800’C OR ‘AUTO'
    # RANGE:THERMOCOUPLE:<TC_TYPE> <Cold_Junction>
    # RANGE:PRT:ITS <probe_number> #PRT ITS90 LIN Probe_Number = 1 to 10
    # RANGE:PRT{:IEC} <probe_number> #PRT IEC751 LIN Probe_Number = 1 to 10  :IEC optional
    # #Electrometer Output Voltage Voltage = 10, 50, 100, 150, 200, 250, 300
    # ELECTROMETER:VOLTAGE <voltage> CANNOT QUERY

# -----------------------------------------------------------
#                            MAIN
# -----------------------------------------------------------


if __name__ == '__main__':
    dmm8104 = DMM8104('GPIB0::22')
    dmm8104.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')

    test_machine_on_start = False
    if test_machine_on_start:
        from driver_test_codes.DMM8104_test import *
        self_test(dmm8104)

# -----------------------------------------------------------
#                         END OF FILE
# -----------------------------------------------------------
