from cl_instr_lib.base_classes.DMM2000_base import DMM2000_base


import time

idn_model = 'MODEL 2000'
options = '200X-SCAN'


class DMM2000SCAN(DMM2000_base):
    def __init__(self, visa_resource_name=None, logger=None, **kwargs):
        super().__init__(visa_resource_name, logger,
                         model_re='^MODEL 2000$', options_re='.*200X-SCAN.*',
                         sim_idn='KEITHLEY INSTRUMENTS INC.,MODEL 2000,0608798,A13  /A02',
                         sim_opt='0,200X-SCAN',
                         **kwargs)

        terminals = self.get_fr_switch()
        if terminals != 'REAR':
            self.log.warning("FRONT terminals selected. REAR terminals must"
                             " be selected to use switcher. INPUTS button must be pushed manually!")

        self.open_all_channels()

    def channel_read(self, channel, delay_sec=0):
        """Closes a relay channel and, after a possible delay, performs the presently selected measurement function
        using the DMMs read method and returns the result.

        The state of relay is checked and if not already closed, a close command is sent followed by the specified delay
        before the measurement is performed. Note that a delay before the execution of the measurement can also be
        introduced through the meter setup_trigger method. Also, the hold functionality of the meter is another,
        possibly, more optimum way to deal with setting time issues.

        Raises exception if called when Front/Rear switch is not in the REAR position. Note this is a manual switch
        and cannot be be controlled remotely.

        :param channel: The relay channel that the measurement is to be performed upon. 1 through 10.
        :type channel: int
        :param delay_sec: Seconds to wait after relay state change before performing the measurement. Skipped if
            relay is already closed.
        :type delay_sec:
        :return: the value returned by the meter read operation.
        :rtype: float
        """

        terminals = self.get_fr_switch()
        if terminals != 'REAR':
            raise RuntimeError(f"FRONT input terminals are selected. REAR terminals must be selected to use switcher. "
                               f"INPUTS button must be pushed manually.")

        if not self.channel_isclosed(channel):
            self.close_channel(channel)
            time.sleep(delay_sec)

        tmp = super().read()

        self.log_inst_errors()
        return tmp

    def channel_isclosed(self, channel):
        """
        Checks if specified relay channel is closed.

        :param channel: The relay channel to check. 1 through 10.
        :type channel: int
        :return: True if specified channel relay is closed.
        :rtype: bool
        """

        if not isinstance(channel, int) or channel < 1 or channel > 10:
            raise ValueError(f"Bad channel {channel} should be 1 to 10.")

        tmp = self.query(':ROUT:CLOS:STAT', str).strip('(@)')
        if tmp == '':
            return False
        return int(tmp) == channel

    def close_channel(self, channel):
        """
        Close the relay specified by channel. Note closing a relay opens any other relay that is closed.

        :param channel: The relay channel to close. 1 through 10.
        :type channel: int
        """

        if not isinstance(channel, int) or channel < 1 or channel > 10:
            raise ValueError(f"Bad channel {channel} should be 1 to 10.")

        self.write(':ROUT:CLOS', f'(@{channel})')

        self.log_inst_errors()

    def open_all_channels(self):
        """
        Open any relay that is presently closed..
        """

        self.write(':ROUT:OPEN:ALL', '')
        # self.log_inst_errors()


if __name__ == '__main__':
    dmm2000scan = DMM2000SCAN('GPIB0::17')  # Replace visa_resource_name with None for simulated hardware.
    dmm2000scan.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
