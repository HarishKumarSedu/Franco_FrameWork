from cl_instr_lib.base_classes.temp_forcing.temp_BaseClass import Temp_BaseClass
import ctypes
import re


class SensataIQPhase(Temp_BaseClass):
    """
    Class for controlling a SensataIQPhase temperature forcing system
    """

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):
        # Setup the simulation code inherited from Instrument.
        super().__init__(visa_resource_name,
                         logger=logger, **kwargs)

        # Get comport number from the rm_handle that the super class opened. Then close it so that the
        # Sensata TC:COMM:OPEN:SER command can open it.
        resource_name = self.rm_handle.resource_name
        self.rm_handle.close()

        m = re.search('ASRL(\d+)', resource_name)

        if m is None:
            raise ValueError(
                f"Bad VISA resource name '{self.rm_handle.resource_name}', expected something like ASRL<int>.")
        comport_name = 'COM' + m.group(1)

        self._sensata_id = None

        # super().__init__()
        self._comport_name = comport_name
        self.__name = f"{__class__.__name__}('{comport_name}')"

        # Load the DLL
        dll_path = r"C:\Program Files\TC_SCPI\lib\TC_SCPI_Main.dll"
        self._dll_obj = ctypes.cdll.LoadLibrary(dll_path)

        # Open the comport to the machine
        cmdstr = f"TC:COMM:OPEN:SER {self._comport_name}"
        status, sensata_id, response = self._wrap_dll(-1, cmdstr)
        if status != 1:
            raise ValueError(f"{self.__name} initialization failed.")

        self._sensata_id = sensata_id
        print(f"{self.__name} initialized, sensata_id={self._sensata_id}.")

    def __del__(self):
        """When object is garbage collected, this will get called to reset to a safe temp and close the COM port."""
        if self._sensata_id is not None:
            # If _sensata_id doesn't exist (we error-ed out of __init__), niether of these is going to work.
            super().__del__()
            self._wrap_dll(self._sensata_id, "TC:COMM:CLOSE")

    def _wrap_dll(self, sensata_id, command):
        """
        Encapsulates the conversions needed to interface between Python and the DLL.
        """
        param1 = ctypes.c_int32(sensata_id)
        param1_ptr = ctypes.pointer(param1)
        param2 = ctypes.c_char_p(command.encode())
        param3 = ctypes.create_string_buffer(256)
        status = self._dll_obj.TC_SCPI_IO(param1_ptr, param2, param3)

        return [status, param1_ptr.contents.value, param3.value.decode('utf-8')]

    def get_errors(self):
        error_list = []
        status = 1
        while status:
            status, sensata_id, response = self._wrap_dll(self._sensata_id, 'SYST:ERR?')
            if status:
                tmp = response.split(',')
                resp_tuple = (int(tmp[0]), tmp[1].strip(' ').strip('"'))
                if resp_tuple[0] == 0:
                    break  # Then no actual error, we got the response "0, 'No Error'"
                else:
                    error_list.append(resp_tuple)
            else:
                error_list.append(tuple("Reading error returned status={status}"))

        if status != 1:
            raise ValueError(f"{self.__name}, DLL return code {status} while checking errors.")

        return error_list

    def get_temperature(self):
        """
        Returns the set point of the temperature forcing system in deg C.

        :return: Set point value read back from the temperature forcing system. Units are degrees C.
        :rtype: float
        """
        status, sensata_id, response = self._wrap_dll(self._sensata_id, 'CONT:SPT?')
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} get_temperature: {error_list}.")
        return float(response)

    def measure_temperature(self):
        """
        Returns the present temperature in deg C.

        :return: The present temperature as measured by the temperature forcing system. Units are degrees C.
        :rtype: float
        """
        status, sensata_id, response = self._wrap_dll(self._sensata_id, 'MEAS?')
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} measure_temperature {error_list}.")
        return float(response)

    def set_temperature(self, temperature_degc):
        """
        Set the temperature forcing system setpoint. Units are in deg C.

        :param temperature_degc: Desired setpoint in degrees C.
        :type temperature_degc: float
        :return: None
        :rtype: None
        """
        cmdstr = f'CONT:SPT {temperature_degc}'
        self._wrap_dll(self._sensata_id, cmdstr)
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} set_temperature({temperature_degc}) {error_list}.")
        self.set_regulation(True)

    def set_regulation(self, enable):
        substr = {False: "OFF", True: "ON"}[enable]
        cmdstr = f"CONT:ENAB {substr}"
        self._wrap_dll(self._sensata_id, cmdstr)
        error_list = self.get_errors()
        if len(error_list) > 0:
            raise ValueError(f"{self.__name} regulation({enable})  {self.get_errors()}.")


if __name__ == "__main__":
    sensataIQPhase = SensataIQPhase('ASRL29')  # com port
    sensataIQPhase.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
