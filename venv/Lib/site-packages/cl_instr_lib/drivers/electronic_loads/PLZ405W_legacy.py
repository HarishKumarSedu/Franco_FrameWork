from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa


class PLZ405W_legacy(InstrumentVisa):
    """Class for controlling Kikusui Electronic Load PLZ405W.

    NOTE: This driver is based on code written for the old instmngr package and adapted so it can be initialized within
    the validation framework. Future cl-instr-lib releases may include a new class that implements an API more
    consistent with the other PLZ e-loads in the cl-instr-lib package.
    """

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):

        super().__init__(visa_resource_name,
                         logger,
                         model_re='^PLZ405W$',
                         sim_idn="KIKUSUI,PLZ405W,BP003149,IFC1.08.0002 FPGA1.01.006 IOC1.03.006",
                         **kwargs)

    def reset(self):
        """ Resets the Electronic Load to its factory defaults, mostly .
        Does not modify STATUS enable registers.
        """

        self.write('*RST')  # '*RST' doesn't reset STAT:*:ENAB bits on this inst.

    def switching(self, curr=None, depth=None, freq=None, duty=None):
        """
        This function configures the switching function of the electronic load.
            NOTE: The default values are None, to allow shorter code for sweeping values. This means that the values
            will not be changed in no input is provided for that parameter.

        :param float curr: This is the current the electronic load will draw when the load is switched high.
        :param float depth: This is the current when the load is switched low, this must be lower than "curr".
        :param int freq: This is the frequency at which the electronic load will switch.
        :param float duty: This is the percentage of the period that the load will be HIGH.
        """
        # Set the mode to CC
        self.write("SOURCE:FUNCTION CC")

        # Set the peak current for the load if it's not None
        if curr is not None:
            self.write(f"SOURCE:CURRENT:LEVEL {curr}")

        # Set the current for the bottom of the switching load if it's given a value
        if depth is not None:
            self.write(f"SOURCE:CURRENT:LEVEL:PULSE:LEVEL {depth}")

        # Set the frequency for the switching load in Hz
        if freq is not None:
            self.write(f"SOURCE:CURRENT:LEVEL:PULSE:FREQUENCY {freq}")

        # Set the duty cycle of the swtiching load in %
        if duty is not None:
            self.write(f"SOURCE:CURRENT:LEVEL:PULSE:DCYCLE {duty}")

        # Turn on the switching load
        self.write(f"INITIATE:PULSE")

    def cnst_load(self, curr):
        """
        This function sets the current level of the constant electronic load.

        :param float curr: This is the current of the load in Amps.
        """
        # Set the mode to CC and the range to medium (8A)
        self.write("SOURCE:FUNCTION CC")

        # checks if the load is switching
        switching = self.query(f"TRIG:TRAN:EXEC?").strip().split(",")

        # if it is switching then stop the swithcing trigger
        if switching[0].lower() == 'puls':
            self.write(f"ABORT:PULSE")

        # Set the current load
        self.write(f"SOURCE:CURRENT:LEVEL {curr}")

    def change_range(self, range='Medium'):
        """
        This function sets the current range of the electronic load.

        :param range: This is the range, either low, medium or high
        """
        # Setting the load to the lowest range
        if range.lower() == "low":
            self.write("SOURCE:CURRENT:RANGE LOW")
        # Setting the load to the middle range
        elif range.lower() == "med" or "medium":
            self.write("SOURCE:CURRENT:RANGE MEDIUM")
        # Setting the load to the highest range
        elif range.lower() == "high":
            self.write("SOURCE:CURRENT:RANGE HIGH")

    def meas(self, param):
        """
        This returns a measurement from the electronic load.

        :param param: Electrical parameter measured by the load.

            * 'CURRent' - measured Current (Amps)
            * 'VOLTage' - measured Voltage (Volts)
            * 'POWer'   - messured Power (Watts)
        :type param: str
        :return: Returns the specified parameter
        :rtype: float
        """
        # Read the power measurement and return it as a float
        return float((self.query(f"READ:{param}?")))

    def state(self, state=None):
        """
        Sets or Queries the state of the Electronic Load.

        :param state:
            * None    - Queries instrument, returns a string detailing if the load is 'ON' or 'OFF'
            * 'ON'    - Sets the electronic load output ON
            * 'OFF'   - Sets the electronic load output OFF
        :return: String detailing the current output state of the electronic load
        :rtype: str
        """
        if state is None:
            if int((self.query("INPUT:STATE?"))):
                return 'ON'
            else:
                return 'OFF'
        else:
            self.write(f"INPUT:STATE {state.upper()}")


if __name__ == '__main__':
    plz405w = PLZ405W_legacy('GPIB0::7')
    plz405w.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
