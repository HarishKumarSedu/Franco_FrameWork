# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include Instrument Drivers/Helpers
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.helpers.check_range import *
from cl_instr_lib.helpers.user_delay import progress_bar
# from cl_instr_lib.base_classes.FCAs.FCA3103_components.calculations import Calculations
from cl_instr_lib.base_classes.FCAs.FCA3103_components.trigger import Trigger
from cl_instr_lib.base_classes.FCAs.FCA3103_components.measure_and_config import Measure
from cl_instr_lib.base_classes.FCAs.FCA3103_components.measure_and_config import Config
from cl_instr_lib.base_classes.FCAs.FCA3103_components.system import System
# from cl_instr_lib.base_classes.FCAs.FCA3103_components.sense import Sense
from cl_instr_lib.base_classes.FCAs.FCA3103_components.zero_dead_time import ZeroDeadTimeTest
# Include python libraries
from enum import Enum
import numpy as np
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class FCA3103(InstrumentVisa):
    """Class for controlling Tektronix FCA3103 Frequency Counter."""

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):
        super().__init__(visa_resource_name, logger,
                         model_re='^FCA3103$',  # match the model string from the IDN
                         sim_idn='TEKTRONIX, FCA3103, 384731, V1.28 25 Aug 2010 11:52',  # a simulated IDN string
                         **kwargs)

        #: Object containing the `Measure`_  methods. Inherits from the `Measure Config ABC`_ class.
        self.measure = Measure(self)  # Include the measure class

        #: Object containing the `Config`_  methods. Inherits from the `Measure Config ABC`_ class.
        self.config = Config(self)  # Include the measure class

        #: Object containing the `Trigger`_  methods.
        self.trigger = Trigger(self)  # Include the trigger class

        # self.calculations = Calculations(self)  # Include the calculations class

        #: Object containing the `System`_  methods.
        self.system = System(self)  # Include the system class

        # self.sense = Sense(self)  # Include the sense class

        #: Object containing the `Zero Dead Time / Frequency Wander Test`_  methods.
        self.zdt_test = ZeroDeadTimeTest(self)  # Include the zero dead time test class

    enum_channel_AB = Enum("enum_channel_continuous", {'A': "(@1)", 'B': "(@2)"})
    enum_channel_ABC = Enum("enum_channel", {'A': "(@1)", 'B': "(@2)", 'C': "(@3)"})
    enum_slope = Enum("enum_slope", {'POSITIVE': "POS", 'NEGATIVE': "NEG"})
    acq_aperture = min_max_units(20e-9, 1000, 'seconds')
    acq_aperture_btb = min_max_units(10e-6, 500, 'seconds')
    delay_range = min_max_units(20e-9, 2.0, 'Seconds')
    _formatting = "ASCII"

    def reset(self):
        super().reset()
        self._formatting = "ASCII"
        self.log_inst_errors()

    # @StaticMethod not wanted since pyro does not see it
    # noinspection PyMethodMayBeStatic
    def decode_ieee_header(self, dataset):
        """
        Helper for reading an IEEE header designating the amount of data in a binary data packet, PACKED and REAL data
        always starts with this IEEE header

        :param dataset: Binary/byte data received from the instrument.
        :type dataset: bytes
        :return: The length of the dataset and the dataset with the header removed.
        :rtype: int & bytes
        """

        ieee_header_length = int(chr(dataset[1]))
        # ieee_header = raw_data[0:1+ieee_header_length]
        data_length = int(dataset[2:2 + ieee_header_length])
        if data_length > 0:
            data = dataset[2 + ieee_header_length:]
        else:
            data = None
        return data_length, data

    @staticmethod
    def byte_decode(dataset):
        """
        Binary data decoder for use on a dataset of bytes returned from the instrument for PACKED format data.

        **Note:** Only necessary if the user is manually reading the file into memory using the file_io module,
        Otherwise data should be accessed using the recall_continuous_test_data method. Will not work over pyro server
        because of numpy. Import an empty reference to the driver to use this method.

        Decodes the double precision float measurement and the uint64 timestamp, also returning the time deltas in
        milliseconds.

        :param dataset: A binary data string to be decoded
        :type dataset: bytes
        :return: Returns decoded measurements, timestamps, and time deltas from a binary file
        :rtype: numpy.ndarray & numpy.ndarray & numpy.ndarray
        """

        if not isinstance(dataset, bytes):
            raise ValueError("Bad Dataset. Should be of type bytes or byte array")
        progress_bar(0, 4)
        decoded_data = np.frombuffer(dataset, dtype=np.float64).byteswap()
        progress_bar(1, 4)
        readings = decoded_data[0::2]
        progress_bar(2, 4)
        timestamps = np.copy(decoded_data[1::2].view(np.uint64))
        progress_bar(3, 4)
        deltas = np.diff(timestamps)/1e6
        progress_bar(4, 4)
        return readings, timestamps, deltas

# -----------------------------------------------------------
#                            MAIN
# -----------------------------------------------------------


if __name__ == '__main__':
    fca3103 = FCA3103('GPIB0::10')
    fca3103.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
