"""Module containing resuables methods across multiple APx methods/classes."""

from typing import Any, List, Union
from pandas import Series
from dataclasses import dataclass, asdict

from cl_instr_lib.helpers.on_off import OnOff, on_off_vals


def check_enum_or_str(name, param, enum_set):
    """Handle checking on parameters that could be a string or enum value."""
    error_msg = f'Bad {name} enum value: {param}. Acceptable values: {[v.name for v in enum_set]} or ' \
                f'{list(enum_set)}'
    if param is None:
        return None
    else:
        if isinstance(param, str):
            if param not in [v.name for v in enum_set]:
                raise ValueError(error_msg)
            return enum_set[param]
        elif isinstance(param, enum_set):
            if param not in list(enum_set):
                raise ValueError(error_msg)
            return param
        elif isinstance(param, int):
            if param not in [v.value for v in enum_set]:
                raise ValueError(error_msg + 'This parameter also accepts int types that are apart of the enum set for'
                                             ' this parameter.')
            return enum_set(param)
        else:
            raise ValueError(error_msg)


def check_array(name:str, array_to_check: List[Any], channel_count:int):
    if array_to_check is not None:
        if len(array_to_check) != channel_count:
            raise ValueError(f'{name} must be an array of length {channel_count} if {channel_count} channels are '
                             f'active.')


on_off = OnOff(off_vals=on_off_vals(('OFF', False, 0, '0'), False, ('OFF', '0', 0), 'OFF'),
                on_vals=on_off_vals(('ON', True, 1, '1'), True, ('ON', '1', 1), 'ON'))


class SweepSeries(Series):
    """
    Child class of Pandas Series that type hints and returns the units and series_type
    """

    def __init__(self, name, data, units: str, series_type: Union[str, int], *args, **kwargs):
        super().__init__(name=name, data=data)
        self.units = units
        self.series_type = series_type

    def __repr__(self):
        current = super().__repr__()
        return f'\n{current}, units: {self.units}, series_type: {self.series_type}'


@dataclass
class MeterData:
    measurement: str
    value: float
    units: str

    def asdict(self):
        return asdict(self)
