import clr
import os
import sys
from enum import Enum, EnumMeta
from cl_instr_lib.base_classes.instrument import Instrument
from cl_instr_lib.drivers.audio.apx.enums import *
from cl_instr_lib.drivers.audio.apx import enums as apx_enums
from typing import Union
from dataclasses import dataclass

from cl_instr_lib.drivers.audio.apx.bench.bench import Bench
from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str


class ApxArgs:
    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs


@dataclass
class ApxEnumContainer:
    """Class for keeping track of an item in inventory."""
    def add_attrs(self, enums_dict):
        for name, c in enums_dict.items():
            if hasattr(self, name):
                raise AttributeError(f"Enum {name} exists in two locations. Change names to avoid overwriting.")
            setattr(self, name, c)


class Apx(Instrument):
    """Base class for the apx"""

    def __init__(self, sw_version: str = "4.5", visible: bool = True, operation_mode: Union[str, Enum] = 'BENCH_MODE',
                 rm_handle: ApxArgs = None, logger=None, **kwargs):
        # If rm_handle is provided, grab arguments and call constructor
        if rm_handle is not None:
            self.__init__(*rm_handle.args, **rm_handle.kwargs)
            return
        sys.path.append(fr"C:\Program Files\Audio Precision\APx500 {sw_version}\API")
        clr.AddReference("AudioPrecision.API")
        clr.AddReference("AudioPrecision.API2")
        clr.AddReference("AudioPrecision.API3")
        from AudioPrecision import API
        self._imports = API
        # Create dataclass to store kwargs
        self.rm_handle = ApxArgs(sw_version=sw_version, visible=visible, operation_mode=operation_mode, **kwargs)
        operation_mode = check_enum_or_str('operating_mode', operation_mode, OperatingModes)
        # Configure application
        self.visa_resource_name = "None"
        self.resource_name = 'apx'
        self.log = self.get_logger_adapter(logger)
        # Add server side info message ('Launching APx GUI')
        self.api = API.APx500_Application(operation_mode.value)
        self.application_visible(visible)
        self.bench = Bench(self)
        self.enums = ApxEnumContainer()
        self.sw_version = sw_version
        self.unused_args_handling = self.enum_unused_args_handling.LOG_UNUSED

        # pull enum classes from enums.py and set as attrs so they can be accessed from object
        for enum_group in [apx_enums]:
            enums_dict = {
                name: c
                for name, c in enum_group.__dict__.items()
                if type(c) is EnumMeta and c is not Enum
            }
            self.enums.add_attrs(enums_dict)

    @property
    def software_version(self):
        return self.api.Version.SoftwareVersion

    def application_visible(self, visible: bool = None) -> bool:
        """
        Dertermines whether to application GUI is visible.

        :param visible: Whether the application is visble. Accepts True or False
        :type visible: bool
        :return: Current application_visble settings
        :rtype: bool
        """

        if visible is None:
            return self.api.Visible
        else:
            self.api.Visible = visible

    def create_new_project(self):
        self.api.CreateNewProject()
    
    def open_project(self, filepath: str):
        """
        Open an APX project.

        :param filepath: Path to file including filename.
        :type filepath: str
        """
        self.api.OpenProject(filepath)
        self.current_project_path = filepath

    def save_project(self, save_path: str = None):
        """
        Save an APX project.

        :param save_path: Path to file including filename.
        :type save_path: str
        """
        if save_path is None:
            if self.api.ProjectFileName is not '':
                self.api.SaveProject(self.api.ProjectFileName)
            else:
                raise FileNotFoundError('Must specify a name if a project has not been loaded or saved.')
        else:
            self.api.SaveProject(save_path)

    def operating_mode(self, mode: str = None) -> str:
        """
        Set a new mode of operation for APx.

        :param mode: Operation mode. Accepts 'BENCH_MODE' or 'SEQUENCE_MODE'.
        :type mode: str
        :return: Current apx operating mode
        :rtype: str
        """

        if mode is None:
            return OperatingModes(self.api.get_OperatingMode()).name

        mode = check_enum_or_str('operating_mode', mode, OperatingModes)

        if mode is not None:
            self.api.OperatingMode = mode.value


if __name__ == '__main__':
    apx =  Apx(sw_version='4.5', operation_mode='BENCH_MODE')
    generator = apx.bench.generator
    analyzer = apx.bench.analyzer
