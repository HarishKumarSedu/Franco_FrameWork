import re
from typing import Any, Dict, Union

from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str, on_off
from cl_instr_lib.drivers.audio.apx.enums import VarPhaseUnits, ChannelAssignments, OffsetUnits, SumOrSplit, \
    DualSineLevelRatioUnits, ImdSignalTypeDigital, ImdSignalTypeAnalog, NoiseShape, LevelUnits, WaveFormNames, FreqUnits


class Generator:
    """Base class for the APx generator."""

    # Benchmode.Generator

    def __init__(self, apx):
        self._apx = apx

    def auto_on(self, state: Union[bool, int, str] = None) -> str:
        """

        Enable or disable automatic turn on of generator when a measurement begins.

        :param state: True to enable and False to disable auto_on.

            To enable, accepts:

            * 'ON'
            * True
            * 1
            * '1'

            To disable, accepts:

            * 'OFF'
            * False
            * 0
            * '0'

        :type state: bool | int | str
        :return: current auto_on settings for generator. 'ON' or 'OFF'
        :rtype: str
        """

        if state is None:
            return on_off.to_api(self._apx.api.BenchMode.Generator.get_AutoOn())

        self._apx.api.BenchMode.Generator.set_AutoOn(on_off.to_inst(state))

    def configure_sine_waveform(self, channel: int = None, level: Union[int, float] = None,
                                freq: Union[int, float] = None, offset: Union[int, float] = None,
                                track_first_channel: Union[bool, str, int] = None,
                                level_units: Union[str, LevelUnits] = None,
                                freq_units: Union[str, FreqUnits] = None,
                                offset_units: Union[str, OffsetUnits] = None, *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for generator output sine wave.

        :param channel: Channel to configure settings. Parameter accepts 1 indexed integer value. The channel parameter
            is required unless if track_first_channel is enabled, in which case the defaulted configurable channel is
            channel 1.
        :type channel: int
        :param level: Amplitude of sine wave.
        :type level: int|float
        :param freq: Frequency of sine wave.
        :type freq: int|float
        :param offset: Offset of sine wave.
        :type offset: int|float
        :param track_first_channel: Set to True for every channel to have the same level and offset as Channel 1. Set to
            False for each channel to have its own individual configuration. Currently also accept int 1 as True and
            0 as False. Note that changing units of level or offset for any channel will convert every other channel
            to the same unit. The level and offset values are the only individual aspect from each channel.
        :type track_first_channel: bool|int
        :param level_units: Units for the amplitude/level of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('level') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current configuration:

            * 'Vrms'
            * 'Vp'
            * 'Vpp'
            * 'dBV'
            * 'dBu'
            * 'dBrG'
            * 'dBm'
            * 'W'
            * 'FS'
            * '%FS'
            * 'dBFS'

        :type level_units: str|LevelUnits
        :param freq_units: Units for the frequency of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('freq') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current:

            * 'Hz'
            * 'dHz'
            * 'F/R'
            * '%Hz'

        :type freq_units: str|FreqUnits
        :param offset_units: Units for the offset of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('offset') method within the Generator class. Depending
            on the current configuration, the below options may be viable:

            * 'V'
            * 'D'
            * 'hex'

        :type offset_units: str|OffsetUnits
        :return: If no parameter is input, return a dicitonary of dictionaries containing the current status on all
            channels. If nothing but the channel is input, method returns a dictionary of current parameter
            configurations for the sine waveform for the channel defined.
        :rtype: dict
        """

        # APx.BenchMode.Generator.Levels
        # APx.BenchMode.Generator.Frequency.Value
        # APx.BenchMode.Generator.Levels.GetOffsetValue()
        # APx.BenchMode.Generator.Levels.SetOffsetValue()
        # APx.BenchMode.Generator.Levels.TrackFirstChannel
        # APx.BenchMode.Generator.Levels.Unit

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (level, freq, offset, track_first_channel, level_units, freq_units, offset_units)):
            channel = self._check_channel(channel, track_first_channel, 'READ')
            return self._readback_waveform(channel, self._configure_sine_waveform_readback)
        else:
            # If Sine is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.SINE.name:
                self.active_waveform(WaveFormNames.SINE)

        # Error Checking
        channel = self._check_channel(channel, track_first_channel, 'WRITE')
        if level is not None or offset is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set level or offset')

        level_units = self._check_level_units(level_units)

        freq_units = self._check_freq_units(freq_units)

        offset_units = self._check_offset_units(offset_units)

        track_first_channel = on_off.to_inst(track_first_channel)

        # Write to Instrument
        if track_first_channel is not None:
            self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel = track_first_channel
        # Write units first so actual values get written in the correct unit.
        if level_units is not None:
            self._apx.api.BenchMode.Generator.Levels.Unit = level_units.value
        if freq_units is not None:
            self._apx.api.BenchMode.Generator.Frequency.Unit = freq_units.value
        if offset_units is not None:
            self._apx.api.BenchMode.Generator.Levels.OffsetUnit = offset_units.value
        if level is not None:
            self._apx.api.BenchMode.Generator.Levels.SetValue(channel, float(level))
        if freq is not None:
            self._apx.api.BenchMode.Generator.Frequency.Value = freq
        if offset is not None:
            self._apx.api.BenchMode.Generator.Levels.SetOffsetValue(channel, float(offset))

    def _configure_sine_waveform_readback(self, channel):
        return_values = {}
        return_values.update(level=self._apx.api.BenchMode.Generator.Levels.GetValue(channel))
        return_values.update(level_units=LevelUnits(self._apx.api.BenchMode.Generator.Levels.Unit).name)
        return_values.update(freq=self._apx.api.BenchMode.Generator.Frequency.Value)
        return_values.update(freq_units=FreqUnits(self._apx.api.BenchMode.Generator.Frequency.Unit).name)
        return_values.update(offset=self._apx.api.BenchMode.Generator.Levels.GetOffsetValue(channel))
        return_values.update(offset_units=OffsetUnits(self._apx.api.BenchMode.Generator.Levels.OffsetUnit).name)
        return_values.update(track_first_channel=on_off.to_api(
            self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel))
        return return_values

    def configure_dual_sine_waveform(self, channel: int = None, level: Union[int, float] = None,
                                     level_units: Union[str, LevelUnits] = None, freq_a: Union[int, float] = None,
                                     freq_b: Union[int, float] = None, freq_units: Union[str, FreqUnits] = None,
                                     offset: Union[int, float] = None, offset_units: Union[str, OffsetUnits] = None,
                                     sum_split: Union[str, SumOrSplit] = None,
                                     level_ratio: Union[int, float] = None,
                                     level_ratio_units: Union[str, DualSineLevelRatioUnits] = None,
                                     track_first_channel: Union[bool, str, int] = None,
                                     ch_assign: Dict[str, Union[str, ChannelAssignments]] = None,
                                     *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for generator output dual sine waveform.

        :param channel: Channel to configure settings. Parameter accepts int value. The channel paremter is
            required unless if track_first_channel is enabled, in which case the defaulted configurable channel is
            channel 1.
        :type channel: int
        :param level: Amplitude of sine wave.
        :type level: int|float
        :param level_units: Units for the amplitude/level of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('level') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current configuration:

            * 'Vrms'
            * 'Vp'
            * 'Vpp'
            * 'dBV'
            * 'dBu'
            * 'dBrG'
            * 'dBm'
            * 'W'
            * 'FS'
            * '%FS'
            * 'dBFS'

        :type level_units: str|LevelUnits
        :param freq_a: Set frequency A in generator.
        :type freq_a: int|float
        :param freq_b: Set frequency B in generator.
        :type freq_b: int|float
        :param freq_units: Units for frequency A and B of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('freq') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current:

            * 'Hz'
            * 'dHz'
            * 'F/R'
            * '%Hz'

        :type freq_units: str|FreqUnits
        :param offset: Set offset for selected channel.
        :type offset: int|float
        :param offset_units: Units for the offset of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('offset') method within the Generator class. Depending
            on the current configuration, the below options may be viable:

            * 'V'
            * 'D'
            * 'hex'

        :type offset_units: str|OffsetUnits
        :param sum_split: Select whether the two frequenceis are either combined in each channel, or are separated onto
            individual output channels. Accepts: 'SUM', 'SPLIT'. See SumOrSplit enum for acceptable values.
        :type sum_split: str|SumOrSplit
            individual output channels. Accepts: 'SUM', 'SPLIT'. See SumOrSplit enum for acceptable values.
        :type sum_split: str|SumOrSplit
        :param level_ratio: Set the ratio of signal amplitudes on channels with each IMD frequency.
        :type level_ratio: int|float
        :param level_ratio_units: Units for the level_ratio of the generator output. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('level_ratio') method within the Generator class.
        :type level_ratio_units: str|DualSineLevelRatioUnits
        :param track_first_channel: Set to True for every channel to have the same level and offset as Channel 1. Set to
            False for each channel to have its own individual configuration. Currently also accept int 1 as True and
            0 as False. Note that changing units of level or offset for any channel will convert every other channel
            to the same unit. The level and offset values are the only individual aspect from each channel.
        :type track_first_channel: bool|int
        :param ch_assign: Set a dictionary for which frequency (A or B) should be assigned to which channel.
            The keys to the dictionary should be 'CH{x}' where x is the channel number, and the corresponding values
            should be either string 'A' or 'B' or derived from the enum ChannelAssignments.
        :type ch_assign: Dict[str, str|ChannelAssignments]
        :return: If no parameter is input, return a dicitonary of dictionary containing the current status on all
            channels. If nothing but the channel is input, method returns a dictionary of current parameter
            configurations for the dual sine waveform for the channel defined.
        :rtype: dict
        """

        # APx.BenchMode.Generator.Levels
        # APx.BenchMode.Generator.Frequency.Value
        # APx.BenchMode.Generator.Levels.GetOffsetValue()
        # APx.BenchMode.Generator.Levels.SetOffsetValue()
        # APx.BenchMode.Generator.Levels.TrackFirstChannel
        # APx.BenchMode.Generator.Levels.Unit

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (level, level_units, freq_a, freq_b, freq_units, offset, offset_units, sum_split,
                                   level_ratio, level_ratio_units, track_first_channel, ch_assign)):
            channel = self._check_channel(channel, track_first_channel, 'READ')
            return self._readback_waveform(channel, self._configure_dual_sine_waveform_readback)
        else:
            # If Dual Sine is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.DUAL_SINE.name:
                self.active_waveform(WaveFormNames.DUAL_SINE)

        # Error Checking
        channel = self._check_channel(channel, track_first_channel, 'WRITE')
        if level is not None or offset is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set level or offset')

        level_units = self._check_level_units(level_units)

        freq_units = self._check_freq_units(freq_units)

        offset_units = self._check_offset_units(offset_units)

        sum_split = check_enum_or_str('sum_split', sum_split, SumOrSplit)

        level_ratio_units = check_enum_or_str('level_ratio_units', level_ratio_units, DualSineLevelRatioUnits)

        track_first_channel = on_off.to_inst(track_first_channel)

        if ch_assign is not None:
            for ch, asgmt in ch_assign.items():
                if re.match('(CH\d\d?)', ch):
                    ch_num = int(ch.replace('CH', ''))
                    if not (0 < ch_num <= self.get_level_count()):
                        raise ValueError(f'Out of bounds channel number for ch_assign key: {ch}. Channel # needs'
                                         f'to be greater than 0 and less than {self.get_level_count()}.')
                else:
                    raise ValueError(f'Bad channel key in ch_assign: {ch}. Valid argument is CHX where X is the '
                                     f'channel number.')
                ch_assign[ch] = check_enum_or_str(f'ch_assign value for {ch}', asgmt,
                                                       ChannelAssignments)

        # Write to Instrument
        if track_first_channel is not None:
            self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel = track_first_channel
        if sum_split is not None:
            self._apx.api.BenchMode.Generator.SineDual.Split = sum_split.value
        # Write units first so actual values get written in the correct unit.
        if level_units is not None:
            self._apx.api.BenchMode.Generator.Levels.Unit = level_units.value
        if freq_units is not None:
            self._apx.api.BenchMode.Generator.Frequency.Unit = freq_units.value
        if offset_units is not None:
            self._apx.api.BenchMode.Generator.Levels.OffsetUnit = offset_units.value
        if level_ratio_units is not None:
            self._apx.api.BenchMode.Generator.SineDual.Frequency1ToFrequency2AmplitudeRatio.Unit = level_ratio_units.value
        if level is not None:
            self._apx.api.BenchMode.Generator.Levels.SetValue(channel, float(level))
        if freq_a is not None:
            self._apx.api.BenchMode.Generator.Frequency.Value = freq_a
        if freq_b is not None:
            self._apx.api.BenchMode.Generator.SineDual.FrequencyB.Value = freq_b
        if offset is not None:
            self._apx.api.BenchMode.Generator.Levels.SetOffsetValue(channel, float(offset))
        if level_ratio is not None:
            self._apx.api.BenchMode.Generator.SineDual.Frequency1ToFrequency2AmplitudeRatio.Value = level_ratio
        if ch_assign is not None:
            for channel, asgmt in ch_assign.items():
                ch_num = int(channel.replace('CH', ''))
                self._apx.api.BenchMode.Generator.SineDual.SetOutputChannelAssignment(ch_num - 1, asgmt.value)

    def _configure_dual_sine_waveform_readback(self, channel):
        return_values = {}
        return_values.update(level=self._apx.api.BenchMode.Generator.Levels.GetValue(channel))
        return_values.update(level_units=LevelUnits(self._apx.api.BenchMode.Generator.Levels.Unit).name)
        return_values.update(freq_a=self._apx.api.BenchMode.Generator.Frequency.Value)
        return_values.update(freq_b=self._apx.api.BenchMode.Generator.SineDual.FrequencyB.Value)
        return_values.update(freq_units=FreqUnits(self._apx.api.BenchMode.Generator.Frequency.Unit).name)
        return_values.update(offset=self._apx.api.BenchMode.Generator.Levels.GetOffsetValue(channel))
        return_values.update(offset_units=OffsetUnits(self._apx.api.BenchMode.Generator.Levels.OffsetUnit).name)
        return_values.update(sum_split=SumOrSplit(self._apx.api.BenchMode.Generator.SineDual.Split).name)
        return_values.update(level_ratio=self._apx.api.BenchMode.Generator.SineDual.Frequency1ToFrequency2AmplitudeRatio.Value)
        return_values.update(level_ratio_units=DualSineLevelRatioUnits(
            self._apx.api.BenchMode.Generator.SineDual.Frequency1ToFrequency2AmplitudeRatio.Unit).name)
        return_values.update(track_first_channel=on_off.to_api(self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel))
        ch_asgmts = {}
        for ch in range(0, self.get_level_count()):
            ch_asgmts[f'CH{ch + 1}'] = ChannelAssignments(
                self._apx.api.BenchMode.Generator.SineDual.GetOutputChannelAssignment(ch)).name
        return_values.update(ch_assign=ch_asgmts)
        return return_values

    def configure_var_phase_sine_waveform(self, channel: int = None, level: Union[int, float] = None,
                                          level_units: Union[str, LevelUnits] = None, freq: Union[int, float] = None,
                                          freq_units: Union[str, FreqUnits] = None, offset: Union[int, float] = None,
                                          offset_units: Union[str, OffsetUnits] = None,
                                          phase_b: Union[int, float] = None,
                                          phase_b_units: Union[str, VarPhaseUnits] = None,
                                          track_first_channel: Union[bool, str, int] = None,
                                          ch_assign: Dict[str, Union[str, ChannelAssignments]] = None,
                                          *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for generator output var phase sine waveform.

        :param channel: Channel to configure settings. Parameter accepts int value. The channel paremter is
            required unless if track_first_channel is enabled, in which case the defaulted configurable channel is
            channel 1.
        :type channel: int
        :param level: Amplitude of sine wave.
        :type level: int|float
        :param level_units: Units for the amplitude/level of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('level') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current configuration:

            * 'Vrms'
            * 'Vp'
            * 'Vpp'
            * 'dBV'
            * 'dBu'
            * 'dBrG'
            * 'dBm'
            * 'W'
            * 'FS'
            * '%FS'
            * 'dBFS'

        :type level_units: str|LevelUnits
        :param freq: Frequency of sine wave.
        :type freq: int|float
        :param freq_units: Units for frequency A and B of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('freq') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current:

            * 'Hz'
            * 'dHz'
            * 'F/R'
            * '%Hz'

        :type freq_units: str|FreqUnits
        :param offset: Set offset for selected channel.
        :type offset: int|float
        :param offset_units: Units for the offset of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('offset') method within the Generator class. Depending
            on the current configuration, the below options may be viable:

            * 'V'
            * 'D'
            * 'hex'

        :type offset_units: str|OffsetUnits
        :param phase_b: Phase offset of Channels assigned to signal 'B'. Used to compare channels assigned to signal 'A'
            with a constant phase offset of 0.
        :type phase_b: int|float
        :param phase_b_units: Units for the phase of signal B for the generator output waveform. For a list of viable
            units based on current apx configurations, call get_available_units('phase') method within the Generator
            class.
        :type phase_b_units: str|VarPhaseUnits
        :param track_first_channel: Set to True for every channel to have the same level and offset as Channel 1. Set to
            False for each channel to have its own individual configuration. Currently also accept int 1 as True and
            0 as False. Note that changing units of level or offset for any channel will convert every other channel
            to the same unit. The level and offset values are the only individual aspect from each channel.
        :type track_first_channel: bool|int
        :param ch_assign: Set a dictionary for which phase (A or B) should be assigned to which channel. Phase A is
            fixed at 0 (rad or deg) and phase B is whatever value is input for Phase B. The keys to the dictionary
            should be 'CH{x}' where x is the channel number, and the corresponding values should be either string 'A'
            or 'B' or derived from the enum ChannelAssignments.
        :type ch_assign: Dict[str, str|ChannelAssignments]
        :return: If no parameter is input, return a dicitonary of dictionary containing the current status on all
            channels. If nothing but the channel is input, method returns a dictionary of current parameter
            configurations for the var phase sine waveform for the channel defined.
        :rtype: dict
        """

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (level, level_units, freq, freq_units, offset, offset_units, phase_b, phase_b_units,
                                   track_first_channel, ch_assign)):
            channel = self._check_channel(channel, track_first_channel, 'READ')
            return self._readback_waveform(channel, self._configure_var_phase_sine_waveform_readback)
        else:
            # If Var Phase Sine is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.VAR_PHASE_SINE.name:
                self.active_waveform(WaveFormNames.VAR_PHASE_SINE)

        # Error Checking
        channel = self._check_channel(channel, track_first_channel, 'WRITE')
        if level is not None or offset is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set level or offset')

        level_units = self._check_level_units(level_units)

        freq_units = self._check_freq_units(freq_units)

        offset_units = self._check_offset_units(offset_units)

        phase_b_units = check_enum_or_str('phase_b_units', phase_b_units, VarPhaseUnits)
        if phase_b_units is not None:
            if phase_b_units not in self.get_available_units('phase'):
                raise ValueError(f'Bad phase_b_units value: {phase_b_units}. Must be in '
                                 f'{self.get_available_units("phase")} for current APx '
                                 f'configurations')

        track_first_channel = on_off.to_inst(track_first_channel)

        if ch_assign is not None:
            for ch, asgmt in ch_assign.items():
                if re.match('(CH\d\d?)', ch):
                    ch_num = int(ch.replace('CH', ''))
                    if not (0 < ch_num <= self.get_level_count()):
                        raise ValueError(f'Out of bounds ch number for ch_assign key: {ch}. Channel # needs'
                                         f'to be greater than 0 and less than {self.get_level_count()}.')
                else:
                    raise ValueError(f'Bad ch key in ch_assign: {ch}. Valid argument is CHX where X is the '
                                     f'ch number.')
                ch_assign[ch] = check_enum_or_str(f'ch_assign value for {ch}', asgmt,
                                                       ChannelAssignments)

        # Write to Instrument
        if track_first_channel is not None:
            self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel = track_first_channel
        # Write units first so actual values get written in the correct unit.
        if level_units is not None:
            self._apx.api.BenchMode.Generator.Levels.Unit = level_units.value
        if freq_units is not None:
            self._apx.api.BenchMode.Generator.Frequency.Unit = freq_units.value
        if offset_units is not None:
            self._apx.api.BenchMode.Generator.Levels.OffsetUnit = offset_units.value
        if phase_b_units is not None:
            self._apx.api.BenchMode.Generator.SineVarPhase.PhaseB.Unit = phase_b_units.value
        if level is not None:
            self._apx.api.BenchMode.Generator.Levels.SetValue(channel, float(level))
        if freq is not None:
            self._apx.api.BenchMode.Generator.Frequency.Value = freq
        if offset is not None:
            self._apx.api.BenchMode.Generator.Levels.SetOffsetValue(channel, float(offset))
        if phase_b is not None:
            self._apx.api.BenchMode.Generator.SineVarPhase.PhaseB.Value = phase_b
        if ch_assign is not None:
            for channel, asgmt in ch_assign.items():
                ch_num = int(channel.replace('CH', ''))
                self._apx.api.BenchMode.Generator.SineVarPhase.SetOutputChannelAssignment(ch_num - 1, asgmt.value)

    def _configure_var_phase_sine_waveform_readback(self, channel):
        return_values = {}
        return_values.update(level=self._apx.api.BenchMode.Generator.Levels.GetValue(channel))
        return_values.update(level_units=LevelUnits(self._apx.api.BenchMode.Generator.Levels.Unit).name)
        return_values.update(freq=self._apx.api.BenchMode.Generator.Frequency.Value)
        return_values.update(freq_units=FreqUnits(self._apx.api.BenchMode.Generator.Frequency.Unit).name)
        return_values.update(offset=self._apx.api.BenchMode.Generator.Levels.GetOffsetValue(channel))
        return_values.update(offset_units=OffsetUnits(self._apx.api.BenchMode.Generator.Levels.OffsetUnit).name)
        return_values.update(phase_b=self._apx.api.BenchMode.Generator.SineVarPhase.PhaseB.Value)
        return_values.update(phase_b_units=VarPhaseUnits(self._apx.api.BenchMode.Generator.SineVarPhase.PhaseB.Unit).name)
        return_values.update(track_first_channel=on_off.to_api(self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel))
        ch_asgmts = {}
        for ch in range(0, self.get_level_count()):
            ch_asgmts[f'CH{ch + 1}'] = ChannelAssignments(
                self._apx.api.BenchMode.Generator.SineVarPhase.GetOutputChannelAssignment(ch)).name
        return_values.update(ch_assign=ch_asgmts)
        return return_values

    def configure_imd_waveform(self, channel: int = None, level: Union[int, float] = None,
                               level_units: Union[str, LevelUnits] = None, freq_1: Union[int, float] = None,
                               freq_2: Union[int, float] = None, freq_units: Union[str, FreqUnits] = None,
                               offset: Union[int, float] = None, offset_units: Union[str, OffsetUnits] = None,
                               signal_type: Union[str, ImdSignalTypeAnalog, ImdSignalTypeDigital] = None,
                               sum_split: Union[str, SumOrSplit] = None,
                               track_first_channel: Union[bool, str, int] = None, *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for generator output IMD waveform.

        :param channel: Channel to configure settings. Parameter accepts int value. The channel paremter is
            required unless if track_first_channel is enabled, in which case the defaulted configurable channel is
            channel 1.
        :type channel: int
        :param level: Amplitude of sine wave.
        :type level: int|float
        :param level_units: Units for the amplitude/level of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('level') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current configuration:

            * 'Vrms'
            * 'Vp'
            * 'Vpp'
            * 'dBV'
            * 'dBu'
            * 'dBrG'
            * 'dBm'
            * 'W'
            * 'FS'
            * '%FS'
            * 'dBFS'

        :type level_units: str|LevelUnits
        :param freq_1: Set frequency 1 in generator. Depending on the IMD signal type selected (see signal_type
            parameter), frequency one may be called Frequency 1, Mean Frequency, or Square Freq in the GUI. For all
            IMD signal types labled with Square Frequency, the value for freq_1 will be fixed.
        :type freq_1: int|float
        :param freq_2: Set frequency 2 in generator. Depending on the IMD signal type selected (see signal_type
            parameter), frequency two may be called Frequency 2, Diff Frequency, or Sine Freq in the GUI. For all
            IMD signal types labled with Sine Frequency, the value for freq_2 will be fixed.
        :type freq_2: int|float
        :param freq_units: Units for frequency 1 and 2 of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('freq') method within the Generator class. Options:

            * 'Hz'
            * 'dHz'
            * F/R'
            * '%Hz'

        :type freq_units: str|FreqUnits
        :param offset: Set offset for selected channel.
        :type offset: int|float
        :param offset_units: Units for the offset of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('offset') method within the Generator class. Depending
            on the current configuration, the below options may be viable:

            * 'V'
            * 'D'
            * 'hex'

        :type offset_units: str|OffsetUnits
        :param signal_type: Set the type of IMD waveform to generate. Accepts strings for values contained in
            IMDSignalTypes Enum. Valid waveforms are listed here:

            * SMPTE_10_TO_1
            * SMPTE_4_TO_1
            * SMPTE_1_TO_1
            * DIN
            * DFD_OR_CCIF
            * DIM_30 - Fixed frequency values.
            * DIM_100 - Fixed frequency values.
            * DIM_B - Fixed frequency values.
            * DIM_B8 - Fixed frequency values.

        :type signal_type: str|ImdSignalTypeAnalog|ImdSignalTypeDigital
        :param sum_split: Select whether the two frequenceis are either combined in each channel, or are separated onto
            individual output channels. Accepts: 'SUM', 'SPLIT'. See SumOrSplit enum for acceptable values. Not
            available for all types of IMD signal types.
        :type sum_split: str|SumOrSplit
        :param track_first_channel: Set to True for every channel to have the same level and offset as Channel 1. Set to
            False for each channel to have its own individual configuration. Currently also accept int 1 as True and
            0 as False. Note that changing units of level or offset for any channel will convert every other channel
            to the same unit. The level and offset values are the only individual aspect from each channel.
        :type track_first_channel: bool|int
        :return: If no parameter is input, return a dicitonary of dictionary containing the current status on all
            channels. If nothing but the channel is input, method returns a dictionary of current parameter
            configurations for the IMD waveform for the channel defined.
        :rtype: dict
        """

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (level, level_units, freq_1, freq_2, freq_units, offset, offset_units, signal_type,
                                   sum_split, track_first_channel)):
            channel = self._check_channel(channel, track_first_channel, 'READ')
            return self._readback_waveform(channel, self._configure_imd_waveform_readback)
        else:
            # If IMD is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.IMD.name:
                self.active_waveform(WaveFormNames.IMD)

        # Error Checking
        # Check channel parameter.
        channel = self._check_channel(channel, track_first_channel, 'WRITE')
        if level is not None or offset is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set level or offset')

        level_units = self._check_level_units(level_units)

        freq_units = self._check_freq_units(freq_units)

        offset_units = self._check_offset_units(offset_units)

        if self._apx.bench.signal_path.output.IsAnalog():
            signal_type = check_enum_or_str('signal_type', signal_type, ImdSignalTypeAnalog)
        else:
            signal_type = check_enum_or_str('signal_type', signal_type, ImdSignalTypeDigital)
        if signal_type is not None:
            if signal_type not in self.get_available_units("imd_signal_type"):
                raise ValueError(f'Bad signal_type value: {signal_type}. Must be in '
                                 f'{self.get_available_units("imd_signal_type")} for current APx configurations.')

        sum_split = check_enum_or_str('sum_split', sum_split, SumOrSplit)
        if sum_split is not None:
            curr_signal_type = ImdSignalTypeAnalog(self._apx.api.BenchMode.Generator.Imd.SignalType)
            if signal_type is not None:
                curr_signal_type = signal_type
            if curr_signal_type.name not in [x.name for x in ImdSignalTypeDigital]:
                raise ValueError(f'The current IMD Signal Type: {curr_signal_type} does not have the capability of'
                                 f'choosing between sum or split. List of IMD Signal Types that allow sum/split'
                                 f'choice: {[x.name for x in ImdSignalTypeDigital]}')

        track_first_channel = on_off.to_inst(track_first_channel)

        # Write to Instrument
        if track_first_channel is not None:
            self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel = track_first_channel
        if signal_type is not None:
            self._apx.api.BenchMode.Generator.Imd.SignalType = signal_type.value
        if sum_split is not None:
            self._apx.api.BenchMode.Generator.Imd.Split = sum_split.value
        # Write units first so actual values get written in the correct unit.
        if level_units is not None:
            self._apx.api.BenchMode.Generator.Levels.Unit = level_units.value
        if freq_units is not None:
            self._apx.api.BenchMode.Generator.Frequency.Unit = freq_units.value
        if offset_units is not None:
            self._apx.api.BenchMode.Generator.Levels.OffsetUnit = offset_units.value
        if level is not None:
            self._apx.api.BenchMode.Generator.Levels.SetValue(channel, float(level))
        if freq_1 is not None:
            self._apx.api.BenchMode.Generator.Imd.Frequency1.Value = freq_1
        if freq_2 is not None:
            self._apx.api.BenchMode.Generator.Imd.Frequency2.Value = freq_2
        if offset is not None:
            self._apx.api.BenchMode.Generator.Levels.SetOffsetValue(channel, float(offset))

    def _configure_imd_waveform_readback(self, channel):
        return_values = {}
        return_values.update(level=self._apx.api.BenchMode.Generator.Levels.GetValue(channel))
        return_values.update(level_units=LevelUnits(self._apx.api.BenchMode.Generator.Levels.Unit).name)
        return_values.update(freq_1=self._apx.api.BenchMode.Generator.Imd.Frequency1.Value)
        return_values.update(freq_2=self._apx.api.BenchMode.Generator.Imd.Frequency2.Value)
        return_values.update(freq_units=FreqUnits(self._apx.api.BenchMode.Generator.Frequency.Unit).name)
        return_values.update(offset=self._apx.api.BenchMode.Generator.Levels.GetOffsetValue(channel))
        return_values.update(offset_units=OffsetUnits(self._apx.api.BenchMode.Generator.Levels.OffsetUnit).name)
        return_values.update(signal_type=ImdSignalTypeAnalog(self._apx.api.BenchMode.Generator.Imd.SignalType).name)
        return_values.update(sum_split=SumOrSplit(self._apx.api.BenchMode.Generator.Imd.Split).name)
        return_values.update(track_first_channel=on_off.to_api(self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel))
        return return_values

    def get_available_units(self, parameter: str) -> list:  # TODO: Make this more specific.
        """
        Get a list of what units are available for a parameter based on current configurations of the APx.

        :param parameter: The parameter to get available units for. Currently accepts the following:

            * 'level'
            * 'freq'
            * 'offset'
            * 'level_ratio'
            * 'phase'
            * 'imd_signal_type'
            * 'constant'

        :type parameter: str
        :return: List of enums of available units.
        :rtype: list
        """

        if parameter == 'level':
            unit_list = list(self._apx.api.BenchMode.Generator.Levels.UnitList)
            unit_enum = LevelUnits
        elif parameter == 'freq':
            unit_list = list(self._apx.api.BenchMode.Generator.Frequency.UnitList)
            unit_enum = FreqUnits
        elif parameter == 'offset':
            unit_list = list(self._apx.api.BenchMode.Generator.Levels.OffsetUnitList)
            unit_enum = OffsetUnits
        elif parameter == 'level_ratio':
            unit_list = list(self._apx.api.BenchMode.Generator.SineDual.Frequency1ToFrequency2AmplitudeRatio.UnitList)
            unit_enum = DualSineLevelRatioUnits
        elif parameter == 'phase':
            unit_list = list(self._apx.api.BenchMode.Generator.SineVarPhase.PhaseB.UnitList)
            unit_enum = VarPhaseUnits
        elif parameter == 'imd_signal_type':
            if self._apx.bench.signal_path.output.IsAnalog():
                unit_list = [0, 1, 2, 3, 4, 5, 6, 7, 8]  # Available analog sources
                unit_enum = ImdSignalTypeAnalog
            else:
                unit_list = [0, 1, 2, 3, 4]  # Available digital sources
                unit_enum = ImdSignalTypeDigital
        else:
            raise ValueError(f'Unsupported parameter: {parameter}. Currently supports level, freq, offset, level_ratio,'
                             f' phase, imd_signal_type')
        ret_list = []
        for unit in unit_list:
            ret_list.append(unit_enum(unit))
        return ret_list

    def configure_square_waveform(self, channel: int = None, track_first_channel: Union[bool, str, int] = None,
                                  level: Union[int, float] = None,
                                  level_units: Union[str, LevelUnits] = None,
                                  offset: Union[int, float] = None, offset_units: Union[str, OffsetUnits] = None,
                                  freq: Union[int, float] = None,
                                  freq_units: Union[str, FreqUnits] = None, *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for generator output square wave.

        :param channel: Channel to configure settings. Parameter accepts 1 indexed integer value. The channel parameter
            is required unless if track_first_channel is enabled, in which case the defaulted configurable channel is
            channel 1.
        :type channel: int
        :param track_first_channel: Set to True for every channel to have the same level and offset as Channel 1. Set to
            False for each channel to have its own individual configuration. Currently also accept int 1 as True and
            0 as False. Note that changing units of level or offset for any channel will convert every other channel
            to the same unit. The level and offset values are the only individual aspect from each channel.
        :type track_first_channel: bool|int
        :param level: Amplitude of sine wave.
        :type level: int|float
        :param level_units: Units for the amplitude/level of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('level') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current configuration:

            * 'Vrms'
            * 'Vp'
            * 'Vpp'
            * 'dBV'
            * 'dBu'
            * 'dBrG'
            * 'dBm'
            * 'W'
            * 'FS'
            * '%FS'
            * 'dBFS'

        :type level_units: str|LevelUnits
        :param offset: Set offset for selected channel.
        :type offset: int|float
        :param offset_units: Units for the offset of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('offset') method within the Generator class. Depending
            on the current configuration, the below options may be viable:

            * 'V'
            * 'D'
            * 'hex'

        :type offset_units: str|OffsetUnits
        :param freq: Frequency of sine wave.
        :type freq: int|float
        :param freq_units: Units for the frequency of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('freq') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current:

            * 'Hz'
            * 'dHz'
            * 'F/R'
            * '%Hz'

        :type freq_units: str|FreqUnits
        :return: If no parameter is input, return a dicitonary of dictionary containing the current status on all
            channels. If nothing but the channel is input, method returns a dictionary of current parameter configurations
            for the sine waveform for the channel defined.
        :rtype: dict
        """

        # APx.BenchMode.Generator.Levels
        # APx.BenchMode.Generator.Frequency.Value
        # APx.BenchMode.Generator.Levels.GetOffsetValue()
        # APx.BenchMode.Generator.Levels.SetOffsetValue()
        # APx.BenchMode.Generator.Levels.TrackFirstChannel
        # APx.BenchMode.Generator.Levels.Unit

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (level, freq, track_first_channel, level_units, freq_units)):
            channel = self._check_channel(channel, track_first_channel, 'READ')
            return self._readback_waveform(channel, self._configure_square_waveform_readback)
        else:
            if self.active_waveform() != WaveFormNames.SQUARE.name:
                self.active_waveform(WaveFormNames.SQUARE)

        channel = self._check_channel(channel, track_first_channel, 'WRITE')
        if level is not None or offset is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set level or offset')
        # Error Checking
        level_units = self._check_level_units(level_units)
        offset_units = self._check_offset_units(offset_units)
        freq_units = self._check_freq_units(freq_units)
        if self._apx.bench.signal_path.output.connector() != 'DIGITAL_SERIAL':
            if offset is not None or offset_units is not None:
                raise ValueError(f'Offset and offset_units can only be configured with connector is DIGITAL_SERIAL')

        # Write to Instrument
        if track_first_channel is not None:
            self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel = on_off.to_inst(track_first_channel)
        # Write units first so actual values get written in the correct unit.
        if level_units is not None:
            self._apx.api.BenchMode.Generator.Levels.Unit = level_units.value
        if freq_units is not None:
            self._apx.api.BenchMode.Generator.Frequency.Unit = freq_units.value
        if level is not None:
            self._apx.api.BenchMode.Generator.Levels.SetValue(channel, float(level))
        if freq is not None:
            self._apx.api.BenchMode.Generator.Frequency.Value = freq
        if offset_units is not None:
            self._apx.api.BenchMode.Generator.Levels.OffsetUnit = offset_units.value
        if offset is not None:
            self._apx.api.BenchMode.Generator.Levels.SetOffsetValue(channel, float(offset))

    def _configure_square_waveform_readback(self, channel):
        return_values = {}
        return_values.update(
            track_first_channel=on_off.to_api(self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel))
        return_values.update(level=self._apx.api.BenchMode.Generator.Levels.GetValue(channel))
        return_values.update(level_units=LevelUnits(self._apx.api.BenchMode.Generator.Levels.Unit).name)
        if self._apx.bench.signal_path.output.connector() == 'DIGITAL_SERIAL':
            return_values.update(offset=self._apx.api.BenchMode.Generator.Levels.GetOffsetValue(channel))
            return_values.update(offset_units=OffsetUnits(self._apx.api.BenchMode.Generator.Levels.OffsetUnit).name)
        return_values.update(freq=self._apx.api.BenchMode.Generator.Frequency.Value)
        return_values.update(freq_units=FreqUnits(self._apx.api.BenchMode.Generator.Frequency.Unit).name)
        return return_values

    def configure_noise_waveform(self, channel: int = None, noise_shape: Union[str, NoiseShape] = None,
                                 level: Union[int, float] = None, level_units: Union[str, LevelUnits] = None,
                                 offset: Union[int, float] = None, offset_units: Union[str, OffsetUnits] = None,
                                 track_first_channel: Union[bool, int, str] = None, *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for generator output noise waveform.

        :param channel: Channel to configure settings. Parameter accepts int value. The channel paremter is
            required unless if track_first_channel is enabled, in which case the defaulted configurable channel is
            channel 1.
        :type channel: int
        :param noise_shape: Gets or sets the noise type. Accepts following:

            * WHITE
            * PINK
            * IEC_60268_1
            * BS_EN_50332_1

        :type noise_shape: str|NoiseShape Enum
        :param level: Amplitude of sine wave.
        :type level: int|float
        :param level_units: Units for the amplitude/level of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('level') method within the Generator class. Options are
            listed below, although not all will be viable depending on the current configuration:

            * 'Vrms'
            * 'Vp'
            * 'Vpp'
            * 'dBV'
            * 'dBu'
            * 'dBrG'
            * 'dBm'
            * 'W'
            * 'FS'
            * '%FS'
            * 'dBFS'

        :type level_units: str|LevelUnits
        :param offset: Offset of sine wave.
        :type offset: int|float
        :param offset_units: Units for the offset of the generator output waveform. The available units depends
            on whether the output configuration is an analog or digital connector. For a list of viable units based on
            current apx configurations, call get_available_units('offset') method within the Generator class. Depending
            on the current configuration, the below options may be viable:

            * 'V'
            * 'D'
            * 'hex'

        :type offset_units: str|OffsetUnits
        :param track_first_channel: Set to True for every channel to have the same level and offset as Channel 1. Set to
            False for each channel to have its own individual configuration. Accepts: 'ON', True, 1 or '1'. For OFF
            accepts: 'OFF', False, 0, or '0'. Note that changing units of level or offset for any channel will convert
            every other channel to the same unit. The level and offset values are the only individual aspect from each
            channel.
        :type track_first_channel: bool|int
        :return: If no parameter is input, return a dicitonary of dictionaries containing the current status on all
            channels. If nothing but the channel is input, method returns a dictionary of current parameter
            configurations for the sine waveform for the channel defined.
        :rtype: dict
        """

        self._apx.log_unused_args(args, kwargs)

        # APx.BenchMode.Generator.NoiseShape
        # APx.BenchMode.Generator.Levels

        # Readback
        if all(v is None for v in (noise_shape, level, level_units, offset, offset_units, track_first_channel)):
            channel = self._check_channel(channel, track_first_channel, 'READ')
            return self._readback_waveform(channel, self._configure_noise_waveform_readback)
        else:
            # If Noise is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.NOISE.name:
                self.active_waveform(WaveFormNames.NOISE)

        # Error Checking
        channel = self._check_channel(channel, track_first_channel, 'WRITE')
        if level is not None or offset is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set level or offset')

        noise_shape = check_enum_or_str('noise_shape', noise_shape, NoiseShape)

        if level is not None:
            if not isinstance(level, (int, float)):
                raise ValueError(f'Bad level type: {type(level)}. Must be an int or float.')

        level_units = check_enum_or_str('level_units', level_units, LevelUnits)

        if offset is not None:
            if not isinstance(offset, (int, float)):
                raise ValueError(f'Bad level type: {type(offset)}. Must be an int or float.')

        offset_units = check_enum_or_str('offset_units', offset_units, OffsetUnits)

        track_first_channel = on_off.to_inst(track_first_channel)
        if level is not None or offset is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set level or offset')

        # Write to Instrument
        if track_first_channel is not None:
            self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel = track_first_channel
        if level_units is not None:
            self._apx.api.BenchMode.Generator.Levels.Unit = level_units.value
        if offset_units is not None:
            self._apx.api.BenchMode.Generator.Levels.OffsetUnit = offset_units.value
        if noise_shape is not None:
            self._apx.api.BenchMode.Generator.NoiseShape = noise_shape.value
        if level is not None:
            self._apx.api.BenchMode.Generator.Levels.SetValue(channel, float(level))
        if offset is not None:
            self._apx.api.BenchMode.Generator.Levels.SetOffsetValue(channel, float(offset))

    def _configure_noise_waveform_readback(self, channel):
        return_values = {}
        return_values.update(noise_shape=NoiseShape(self._apx.api.BenchMode.Generator.NoiseShape).name)
        return_values.update(level=self._apx.api.BenchMode.Generator.Levels.GetValue(channel))
        return_values.update(level_units=LevelUnits(self._apx.api.BenchMode.Generator.Levels.Unit).name)
        return_values.update(offset=self._apx.api.BenchMode.Generator.Levels.GetOffsetValue(channel))
        return_values.update(offset_units=OffsetUnits(self._apx.api.BenchMode.Generator.Levels.OffsetUnit).name)
        return_values.update(track_first_channel=on_off.to_api(self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel))
        return return_values

    def configure_constant_waveform(self, channel: int = None, value: int = None,
                                    track_first_channel: Union[bool, int, str] = None,
                                    *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for generator output noise waveform.

        Bug notice: As of 10/26/22, there is a no current call within APx's native API that allows the configuration
        of the constant value's unit. For this reason, our this method will only work with 'hex' as the only supported
        unit.

        :param channel: Channel to configure settings. Parameter accepts int value. The channel parameter is
            required unless if track_first_channel is enabled, in which case the defaulted configurable channel is
            channel 1.
        :type channel: int
        :param value: Set or get the constant value of a channel.
        :type value: int|float
        :param track_first_channel: Set to True for every channel to have the same level and offset as Channel 1. Set to
            False for each channel to have its own individual configuration. Accepts: 'ON', True, 1 or '1'. For OFF
            accepts: 'OFF', False, 0, or '0'. Note that changing units of level or offset for any channel will convert
            every other channel to the same unit. The level and offset values are the only individual aspect from each
            channel.
        :type track_first_channel: bool|int
        :return: If no parameter is input, return a dictionary of dictionaries containing the current status on all
            channels. If nothing but the channel is input, method returns a dictionary of current parameter
            configurations for the sine waveform for the channel defined.
        :rtype: dict
        """

        self._apx.log_unused_args(args, kwargs)

        # APx.BenchMode.Generator.ConstantValues
        # APx.BenchMode.Generator.Levels
        # APx.BenchMode.Generator.ConstantValues.TrackFirstChannel

        # Readback
        if all(v is None for v in (value, track_first_channel)):
            channel = self._check_channel(channel, track_first_channel, 'READ')
            return self._readback_waveform(channel, self._configure_constant_waveform_readback)
        else:
            # If Constant is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.CONSTANT_VALUE.name:
                self.active_waveform(WaveFormNames.CONSTANT_VALUE)

        # Error Checking
        channel = self._check_channel(channel, track_first_channel, 'WRITE')
        if value is not None:
            if channel is None:
                raise AttributeError('channel parameter must be specified if track_first_channel is disabled in order '
                                     'to set value')

        if value is not None:
            if not isinstance(value, int):
                raise ValueError(f'Bad value type: {type(value)}. With current unit type, value must be an int.')

        track_first_channel = on_off.to_inst(track_first_channel)

        # Write to Instrument
        if track_first_channel is not None:
            self._apx.api.BenchMode.Generator.ConstantValues.TrackFirstChannel = track_first_channel
        if value is not None:
            self._apx.api.BenchMode.Generator.ConstantValues.SetValue(channel, value)
            if self._apx.api.BenchMode.Generator.ConstantValues.GetValue(channel) != value:
                self._apx.log.warning(f'Value was not set correctly. Attempted to write {value} but APx set '
                              f'{self._apx.api.BenchMode.Generator.ConstantValues.GetValue(channel)}. Change settings within the '
                              f'Digital Serial Output Connector configuration to correctly set this parameter.')

    def _configure_constant_waveform_readback(self, channel):
        return_values = {}
        return_values.update(value=self._apx.api.BenchMode.Generator.ConstantValues.GetValue(channel))
        return_values.update(track_first_channel=on_off.to_api(
            self._apx.api.BenchMode.Generator.ConstantValues.TrackFirstChannel))
        return return_values

    def configure_walking_ones_waveform(self, samples_per_step: int = None, *args, **kwargs):
        """
        Configure settings for generator output walking ones waveform.

        :param samples_per_step: Sets the number of samples per step for the Walking Ones digital generator type.
        :type samples_per_step: int
        :return: Dictionary containing current samples_per_step
        :rtype: Dict[str: int]
        """

        # APx.BenchMode.Generator.SamplesPerStep

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if samples_per_step is None:
            return {'samples_per_step': self._apx.api.BenchMode.Generator.SamplesPerStep}
        else:
            # If Walking Ones is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.WALKING_ONES.name:
                self.active_waveform(WaveFormNames.WALKING_ONES)

        # Error Checking
        if not isinstance(samples_per_step, int):
            raise ValueError(f'Bad samples_per_step type: {type(samples_per_step)}. Must be type int.')
        check_range('samples_per_step', samples_per_step, min_max_units(1, 999999, ''))

        # Write to Instrument
        self._apx.api.BenchMode.Generator.SamplesPerStep = samples_per_step

    def configure_walking_zeros_waveform(self, samples_per_step: int = None, *args, **kwargs):
        """
        Configure settings for generator output walk zeroes waveform.

        :param samples_per_step: Sets the number of samples per step for the Walking Zeros digital generator type.
        :type samples_per_step: int
        :return: Dictionary containing current samples_per_step
        :rtype: Dict[str: int]
        """

        # APx.BenchMode.Generator.SamplesPerStep

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if samples_per_step is None:
            return {'samples_per_step': self._apx.api.BenchMode.Generator.SamplesPerStep}
        else:
            # If Walking Zeros is not active waveform, change it so it is.
            if self.active_waveform() != WaveFormNames.WALKING_ZEROS.name:
                self.active_waveform(WaveFormNames.WALKING_ZEROS)

        # Error Checking
        if not isinstance(samples_per_step, int):
            raise ValueError(f'Bad samples_per_step type: {type(samples_per_step)}. Must be type int.')
        check_range('samples_per_step', samples_per_step, min_max_units(1, 999999, ''))

        # Write to Instrument
        self._apx.api.BenchMode.Generator.SamplesPerStep = samples_per_step

    def get_available_waveforms(self) -> list:
        """
        Retrieve a list of available generator waveforms available based on current APx configurations.

        :return: Generator waveforms.
        :rtype: list
        """
        ret_list = []
        for wave in list(self._apx.api.BenchMode.Generator.WaveformNames):
            ret_list.append(WaveFormNames(wave))
        return ret_list

    def output_state(self, state: Union[bool, int, str] = None) -> bool:
        """
        Set output state of generator.

        :param state: State to set generator to. Accepts True or False.
        :type state: bool|int|str
        :return: Current output state of generator. Will be True or False.
        :rtype: None
        """

        if state is None:
            return on_off.to_api(self._apx.api.BenchMode.Generator.get_On())

        self._apx.api.BenchMode.Generator.set_On(on_off.to_inst(state))

    def active_waveform(self, new_waveform: Union[str, WaveFormNames] = None) -> str:
        """
        Set the active waveform or get the current active waveform.

        :param new_waveform: Accepts the following:

            * 'SINE'
            * 'DUAL_SINE'
            * 'BURST_SINE'
            * 'VAR_PHASE_SINE'
            * 'IMD'
            * 'SQUARE'
            * 'NOISE'
            * 'BIT_TEST'
            * 'CONSTANT_VALUE'
            * 'WALKING_ONES'
            * 'WALKING_ZEROS'

            Note that depending on the APx configuration not all these will be available.
        :type new_waveform: str|WaveFormNames
        :return: Current generator waveform.
        :rtype: str
        """

        if new_waveform is None:
            return WaveFormNames(self._apx.api.BenchMode.Generator.get_Waveform()).name

        # APx Configuration Checking
        new_waveform = check_enum_or_str('new_waveform', new_waveform, WaveFormNames)
        if new_waveform not in self.get_available_waveforms():
            raise ValueError(f'APx is not currently configured to have the Sine waveform as a valid waveform for the '
                             f'generator. Currently available waveforms: {[x.name for x in self.get_available_waveforms()]}')

        try:
            self._apx.api.BenchMode.Generator.set_Waveform(new_waveform.value)
        except KeyError:
            raise KeyError(f'Unknown mode: {new_waveform}. Acceptable modes: {[x.name for x in WaveFormNames]}')
        
    def get_level_count(self):
        return self._apx.api.BenchMode.Generator.Levels.Count

    def configure_ch_enable(self, channel: int = None, enable: Union[bool, int, str] = None):
        """
        Sets or reads the enable value for the specified channel. Channel must be specified. To read or set all channel
        enable values use the configure_all_ch_enables function. Channel is 1 indexed. Accepts: 'ON', True, 1 or
        '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :param channel: Specify the channel to set or read the enable.
        :type channel: int
        :param enable: the enable value to set.
        :type enable: bool|int|str
        :return: Returns the enable value for specified channel if the enable parameter is None. 'ON' or 'OFF'
        :rtype: str
        """
        if channel is not None:
            if not isinstance(channel, int):
                raise ValueError(f'Bad channel value: {channel}. Ensure channel is an int')
            channel -= 1  # Decrement APx channel indexing by 1 so that index 1 = channel 1 and so on.
            if not (0 <= channel < self.get_level_count()):
                raise ValueError(f'Bad channel value: {channel + 1}. Must be 0 < channel <= '
                                 f'{self.get_level_count()}')
        else:
            raise ValueError('channel parameter must be specified. use configure all_ch_enables to read back all values')

        if enable is None:
            return on_off.to_api(self._apx.api.BenchMode.Generator.GetChannelEnabled(channel))
        else:
            self._apx.api.BenchMode.Generator.SetChannelEnabled(channel, on_off.to_inst(enable))


    def configure_all_ch_enables(self, enable: Union[bool, int, str] = None):
        """
        Sets the enable value for all available channels for the current configuration. If enable is None, it reads the
        current enable values for all channels and returns a list.
        :param enable: enable value to set. Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type enable: bool|int|str
        :return: Returns a list of the enable setting per channel. 'ON' or 'OFF' for each setting.
        :rtype: list(str)
        """
        chs = self.get_level_count()
        if enable is None:
            return [on_off.to_api(self._apx.api.BenchMode.Generator.GetChannelEnabled(ch)) for ch in range(0, chs)]
        else:
            for ch in range(0, chs):
                self._apx.api.BenchMode.Generator.SetChannelEnabled(ch, on_off.to_inst(enable))



    def _readback_waveform(self, channel, readback_method):
        return_values = {}
        curr_track_first_channel = on_off.to_api(self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel)
        if channel is not None and curr_track_first_channel is 'OFF':  # Readback specified single channel
            return_values = readback_method(channel)
        elif channel is None and curr_track_first_channel is 'OFF':  # Readback every channel
            for channel in range(self.get_level_count()):
                return_values[f'CH{channel + 1}'] = readback_method(channel)
        else:  # track_first_channel must be enabled, Readback channel 1
            return_values = readback_method(0)  # 0 -> channel 1
        return return_values

    def _check_channel(self, channel, track_first_channel, action):
        curr_track_first_channel = on_off.to_inst(track_first_channel)

        if curr_track_first_channel is None:
            curr_track_first_channel = self._apx.api.BenchMode.Generator.Levels.TrackFirstChannel
        if channel is not None:
            if not isinstance(channel, int):
                raise ValueError(f'Bad channel value: {channel}. Ensure channel is an int')
            channel -= 1  # Decrement APx channel indexing by 1 so that index 1 = channel 1 and so on.
            if not (0 <= channel < self.get_level_count()):
                raise ValueError(f'Bad channel value: {channel + 1}. Must be 0 < channel <= '
                                 f'{self.get_level_count()}')
            if channel != 0:
                if curr_track_first_channel == True:
                    if action == 'WRITE':
                        raise Exception(f'track_first_channel is enabled. Only channel 1 configurations may be set')
        else:
            if curr_track_first_channel == True:
                channel = 0
        return channel

    def _check_level_units(self, level_units):
        """Perform error checking on level_units parameter within APx Generator."""
        level_units = check_enum_or_str('level_units', level_units, LevelUnits)
        if level_units is not None:
            if level_units not in self.get_available_units("level"):
                raise ValueError(f'Bad level_unit value: {level_units}. Must be in '
                                 f'{self.get_available_units("level")} for current APx configurations.')
        return level_units

    def _check_freq_units(self, freq_units):
        freq_units = check_enum_or_str('freq_units', freq_units, FreqUnits)
        if freq_units is not None:
            if freq_units not in self.get_available_units("freq"):
                raise ValueError(f'Bad level_unit value: {freq_units}. Must be in '
                                 f'{self.get_available_units("freq")} for current APx configurations.')
        return freq_units

    def _check_offset_units(self, offset_units):
        offset_units = check_enum_or_str('offset_units', offset_units, OffsetUnits)
        if offset_units is not None:
            if offset_units not in self.get_available_units("offset"):
                raise ValueError(f'Bad level_unit value: {offset_units}. Must be in {self.get_available_units("offset")}'
                                 f' for current APx configurations.')
        return offset_units