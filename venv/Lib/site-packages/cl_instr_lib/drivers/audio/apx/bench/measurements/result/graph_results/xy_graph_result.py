from typing import Union, List, Optional, Dict
import re

from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.graph_results.graph_result import GraphResult
from cl_instr_lib.drivers.audio.apx.enums import MeasurementResultType, XUnits, YUnits, Axis, VerticalAxis, \
    NumberOfGraphPoints
from cl_instr_lib.drivers.audio.apx.reusables import SweepSeries


class XYGraphResult(GraphResult):
    """Base class for XY Graph Results, inherits from GraphResult"""

    @property
    def _result_obj(self):
        """Native APX API reference for the result object AsXYGraph()"""
        return self._graph_obj.Result.AsXYGraph()

    def is_right_axis_result(self) -> bool:
        """
        Returns whether the result is a right axis result

        :return: True if the result is a right-axis result
        :rtype: bool
        """
        if self._graph_obj.Result.IsXYGraph:
            return self._result_obj.IsRightAxisResult
        else:
            return False

    def has_right_axis_result(self) -> bool:
        """
        Returns whether the result has a right axis result

        :return: True if the result has a right axis result
        :rtype: bool
        """
        if self._graph_obj.Result.IsXYGraph:
            return self._result_obj.IsRightAxisResultDefined
        else:
            return False

    def add_derived_result(self, result_type: Union[MeasurementResultType, str]):
        """
        Add a derived result based on the current result

        :param result_type: MeasurementResultType Enum or string value or derived result to add
        :type result_type: MeasurementResultType | str
        """
        result_type = check_enum_or_str('result_type', result_type, MeasurementResultType)
        if result_type.name not in self.get_valid_derived_result_options():
            self._measurement._apx.log.error(f'{result_type.name} is not a valid derived result for this result. '
                                             f'Valid options include:'
                                             f'{self.get_valid_derived_result_options()}')
        else:
            self._graph_obj.AddDerivedResult(self._graph_obj.Result.ResultType.__getattribute__(result_type.value))
            self._measurement.sync_with_gui()

    def get_valid_derived_result_options(self) -> List[str]:
        """
        Gets all available strings for use with add_derived_result()

        :return: A list of MeasurementResultType strings that are valid derived results for this result
        :rtype: List[str]
        """
        return [MeasurementResultType(str(x)).name for x in self._graph_obj.DerivedResultTypes]

    def configure_right_axis_result(self, result_type: Union[str, MeasurementResultType] = None) -> Optional[str]:
        """
        Adds a result to the right axis of this result.

        :param result_type: MeasurementResultType  or string of which to add to right axis
        :type result_type: MeasurementResultType | str
        :return: if nothing is passed in, returns the current right axis result name. Returns 'NONE' if no right axis
            result is configured.
        :rtype: str
        """
        if self._graph_obj.Result.IsXYGraph:
            result_type = check_enum_or_str('result_type', result_type, MeasurementResultType)
            if result_type is None:
                return MeasurementResultType(str(self._result_obj.RightAxisResult.ResultType)).name
            else:
                self._result_obj.DefineRightAxisResult(
                    self._graph_obj.Result.ResultType.__getattribute__(result_type.value))
                self._measurement.sync_with_gui()
        else:
            self._measurement._apx.log.error(f'Can only define right axis result for XY Graphs at the time')

    def get_xy_data(self, channel: int = None, vertical_axis: Union[VerticalAxis, int] = VerticalAxis.LEFT,
                    add_ch_suffix: bool = True) -> List[SweepSeries]:
        """
        Gets X and Y values. First element [0] is always the x data, followed by each channel's (or the specified
        channel's) y data. If add_ch_suffix is true, the channel name is appended for each y_label. Uses the currently
        configured units and names for the X and Y axis. To change these use the configure_units(), and
        configure_axis_names() functions.

        :param channel: input measurement channel
        :type channel: int
        :param vertical_axis: vertical axis to retrieve data: LEFT or RIGHT
        :type vertical_axis: VerticalAxis | int
        :param add_ch_suffix: whether to append the channel name to the y axis data labels automatically
        :type add_ch_suffix: bool
        :return: Returns a list of pandas Series. Index 0 is always the x values, followed by each channel's (or the
            specified channel's) y data. Each Series contains attributes units, series_type, values and name.
        :rtype: list[SweepSeries]
        """
        vertical_axis = check_enum_or_str('vertical_axis', vertical_axis, VerticalAxis)
        x_values = self._result_obj.GetXValues(0, vertical_axis.value)
        x_values = [float(val) for val in x_values]
        x_data_series = SweepSeries(name=self.configure_axis_names(vertical_axis=vertical_axis)['x_axis'], data=x_values,
                                    units=self._result_obj.XAxis.Unit, series_type='apx_xy_results')
        data = [x_data_series]
        if channel is None:
            channels = range(self.get_channel_count())
        else:
            self.verify_ch(channel)
            channels = [channel - 1]
        for ch in channels:
            y_values = self._result_obj.GetYValues(ch, vertical_axis.value)
            y_values = [float(val) for val in y_values]
            y_label = self.configure_axis_names(vertical_axis=vertical_axis)['y_axis']
            if add_ch_suffix:
                y_label = y_label + ' ' + self._result_obj.ChannelNames[ch]
            y_data_series = SweepSeries(name=y_label, data=y_values, units=self._result_obj.YAxis.Unit,
                                        series_type='apx_xy_results')
            data.append(y_data_series)
        return data

    def configure_axis_names(self, x_axis: str = None, y_axis: str = None, vertical_axis:
                             Union[VerticalAxis, int] = VerticalAxis.LEFT) -> Dict[str, str]:
        """
        Configure or retrieve the x and y axis names
        
        :param x_axis: x axis name
        :type x_axis:  str
        :param y_axis: y axis name
        :type y_axis: str
        :param vertical_axis: vertical axis to retrieve data: LEFT or RIGHT
        :type vertical_axis: VerticalAxis | int
        :return: dictionary of the x and y axis names
        :rtype: Dict[str, str]
        """
        vertical_axis = check_enum_or_str('vertical_axis', vertical_axis, VerticalAxis)
        if vertical_axis == VerticalAxis.RIGHT:
            y_title = self._result_obj.RightAxis
        else:
            y_title = self._result_obj.YAxis

        if x_axis is None and y_axis is None:
            x_axis_title = self._result_obj.XAxis.Title
            x_axis_title = re.sub("\(DCX\)", "dcx", x_axis_title)  # keep dcx suffix if found in ()
            x_axis_title = re.sub("[\(\[].*?[\)\]]", "", x_axis_title)  # delete all other text in ()
            x_axis_title = x_axis_title.strip(' ').replace(',', '').replace('-', '').replace('>', '')
            y_axis_title = y_title.Title
            y_axis_title = re.sub("\(DCX\)", "dcx", y_axis_title)  # keep dcx suffix if found in ()
            y_axis_title = re.sub("[\(\[].*?[\)\]]", "", y_axis_title)  # delete all other text in ()
            y_axis_title = y_axis_title.strip(' ').replace(',', '').replace('-', '').replace('>', '')
            return {'x_axis': x_axis_title, 'y_axis': y_axis_title}
        if x_axis is not None:
            self._result_obj.XAxis.Title = x_axis
        if y_axis is not None:
            y_title.Title = y_axis

    def get_xy_data_with_defined_points(self, channel: int = None, graph_points: Union[NumberOfGraphPoints, int] =
                                        NumberOfGraphPoints.GRAPH_POINTS_ALL_POINTS, vertical_axis: Union[VerticalAxis,
                                        int] = VerticalAxis.LEFT, add_ch_suffix: bool = True) -> List[SweepSeries]:
        """
        Gets X and Y values. First element [0] is always the x data, followed by each channel's (or the specified
        channel's) y data. Configures the number of graph points to retrieve. if add_ch_suffix is true, the channel name
        is appended for each y_label.

        :param channel: Input measurement channel
        :type channel: int
        :param graph_points: Specifies the number of graph points to fetch. Options include:

            GRAPH_POINTS_ALL_POINTS
            GRAPH_POINTS_SAME_AS_GRAPH
            GRAPH_POINTS_10
            GRAPH_POINTS_20
            GRAPH_POINTS_30
            GRAPH_POINTS_40
            GRAPH_POINTS_50
            GRAPH_POINTS_100
            GRAPH_POINTS_200
            GRAPH_POINTS_500

        :type graph_points: NumberOfGraphPoints | int
        :param vertical_axis: specifies the axis. LEFT, RIGHT
        :type vertical_axis: VerticalAxis | str
        :param add_ch_suffix: whether to append the channel name to the y axis data labels automatically
        :type add_ch_suffix: bool
        :return: Returns a list of pandas Series. Index 0 is always the x values, followed by each channel's (or the
            specified channel's) y data. Each Series contains attributes units, series_type, values and name.
        :rtype: list[SweepSeries]
        """
        vertical_axis = check_enum_or_str('vertical_axis', vertical_axis, VerticalAxis)
        graph_points = check_enum_or_str('graph_points', graph_points, NumberOfGraphPoints)
        x_values = self._result_obj.GetData(0, 0, graph_points.value).GetXValues(0, vertical_axis.value)
        x_values = [float(val) for val in x_values]
        x_data_series = SweepSeries(name=self.configure_axis_names(vertical_axis=vertical_axis)['x_axis'], data=x_values,
                                    units=self._result_obj.XAxis.Unit, series_type='apx_xy_results')
        data = [x_data_series]
        if channel is None:
            channels = range(self.get_channel_count())
        else:
            channels = [channel - 1]
        for ch in channels:
            y_values = self._result_obj.GetData(0, 0, graph_points.value).GetYValues(ch, vertical_axis.value)
            y_values = [float(val) for val in y_values]
            y_label = self.configure_axis_names(vertical_axis=vertical_axis)['y_axis']
            if add_ch_suffix:
                y_label = y_label + ' ' + self._result_obj.ChannelNames[ch]
            y_data_series = SweepSeries(name=y_label, data=y_values, units=self._result_obj.YAxis.Unit,
                                        series_type='apx_xy_results')
            data.append(y_data_series)
        return data

    def get_available_units(self, axis: Union[Axis, str]):
        """
        Retrieves the valid unit options for the specified axis of this measurement.

        :param axis: X or Y
        :type axis: Axis | str
        :return: Returns a list of enum strings that are valid for this axis.
        :rtype: list[str]
        """
        axis = check_enum_or_str('axis', axis.upper(), Axis)
        if axis.value == 'x':
            unit_enum = XUnits
        elif axis.value == 'y':
            unit_enum = YUnits
        else:
            raise ValueError(f'Axis input {axis} is not valid. Options are x and y.')
        return [unit_enum(x).name for x in self._result_obj.__getattribute__(f'{axis.name}Axis').UnitList]

    def configure_units(self, x_unit: Union[XUnits, str] = None, y_unit: Union[YUnits, str] = None):
        """
        Allows configuration of the x or y units, or both. If left empty will return the currently configured units.

        :param x_unit: X units options. All may not be valid depending on input connector settings, but the function
            will check validity for trying to set the configuration. Options include

            S, HZ, DHZ, F_R, PERCENT_HZ

        :type x_unit: XUnits | str
        :param y_unit: Y units options. All may not be valid depending on input connector settings, but the function
            will check validity for trying to set the configuration.

            FS, PERCENT_FS, DBFS, DBSPL1, DBSPL2, VRMS, DBV, DBU, DBRA, DBRB, DBM, W, V, D, HEX, D_V, X_Y

        :type y_unit: YUnits | str
        :return: a tuple of the (x_unit, y_unit) if no parameters are entered, otherwise returns nothing
        :rtype: dict | None
        """

        if x_unit is None and y_unit is None:
            return {'x_unit': XUnits(self._result_obj.XAxis.Unit).name,
                    'y_unit': YUnits(self._result_obj.YAxis.Unit).name}

        x_unit = check_enum_or_str('x_unit', x_unit, XUnits)
        y_unit = check_enum_or_str('y_unit', y_unit, YUnits)

        if x_unit is not None:
            if x_unit.name not in self.get_available_units('x'):
                raise ValueError(f'Invalid x_unit "{x_unit}". Valid options are '
                                 f'{[x for x in self.get_available_units("x")]}.')
            self._result_obj.XAxis.Unit = x_unit.value

        if y_unit is not None:
            if y_unit.name not in self.get_available_units('y'):
                raise ValueError(f'Invalid y_unit "{y_unit}". Valid options are '
                                 f'{[x for x in self.get_available_units("y")]}.')
            self._result_obj.YAxis.Unit = y_unit.value

    def _get_export_units(self):
        return [XUnits[self.configure_units()[0]].value, YUnits[self.configure_units()[1]].value]

    def get_result_type(self) -> str:
        """
        If the result is derived this returns the MeasurementResultType enum string, otherwise it returns the
        PrimaryResult enum string for this measurement type

        :return: the corresponding enum string
        :rtype: str
        """
        if self.is_derived():
            result_type = MeasurementResultType(self._graph_obj.ViewType.ToString()).name
        else:
            result_type = self._measurement._primary_result_enum(self._graph_obj.ViewType.Name).name
        return result_type
