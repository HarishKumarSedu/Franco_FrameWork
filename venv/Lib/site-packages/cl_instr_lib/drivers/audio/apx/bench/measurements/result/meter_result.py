import re
from typing import Union, List

from cl_instr_lib.drivers.audio.apx.bench.measurements.result.result import Result
from cl_instr_lib.drivers.audio.apx.enums import MeterUnits, BenchMeterType, SettledMeterType
from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str, MeterData


class MeterResult(Result):
    """Parent Result Class for all Meter Results, inherits from Result"""
    def __init__(self, measurement, result_name, index):
        self._measurement = measurement
        self.result_name = result_name
        self.index = index

    @property
    def meter_type(self):
        return self.api_ref.GetMeterType(self.index)

    @property
    def api_ref(self):
        """APX Meters Native API reference"""
        return self._measurement.api_ref

    @property
    def _result_obj(self):
        """The Native APx API reference for the meter result object"""
        return self.api_ref

    def get_data(self, channel: int = None, add_ch_suffix: bool = True) -> Union[List[MeterData], MeterData]:
        """
        Returns the meter data for the specified channel as a MeterData dataclass, if no channel is specified,
        returns a list of all channels. Channel is 1 indexed.

        :param channel: channel number
        :type channel: int
        :param add_ch_suffix: whether to append the channel name to the end of each measurement name
        :type add_ch_suffix: bool
        :return: measured data
        :rtype: List[MeterData] | MeterData
        """
        self.meter_type
        data = []
        if channel is None:
            channels = range(self.get_channel_count())
        else:
            self.verify_ch(channel)
            channels = [channel - 1]
        count = 0
        valid = False

        if self.get_result_type() == 'BITS':
            while count < 5:  # Sometimes the GetReadings is blank.. not sure if this is a DemoMode issue,
                # adding retries for unit testing
                values = [x for x in self.api_ref.GetReadings(self.meter_type)]
                if len(values) == len(channels):
                    valid = True
                    break
                count += 1
            if not valid:
                raise Exception(f'Unable to retrieve valid data for meter after 5 tries. Retrieved {len(values)} values'
                                f' instead of {len(channels)}, this is an issue of trying to read while the GUI is '
                                f'updating. Please try again.')

        else:
            index = SettledMeterType[BenchMeterType[self.get_result_type()].value.replace('Meter', '')].value
            values = [x for x in self._measurement._apx.api.BenchMode.GetSettledMeterReadings([index])[index].
                      GetValues(self.api_ref.GetDisplaySettings(self.index).Unit)]

        for ch in channels:
            label = self.configure_title()
            if add_ch_suffix:
                label = label + ' ' + f'Ch{ch+1}'
            value = values[ch]
            data.append(MeterData(measurement=label, value=value,
                                  units=self.api_ref.GetDisplaySettings(self.index).Unit))
        return data[0] if channel else data

    def get_available_units(self):
        """
        Retrieves the valid unit options for the specified axis of this measurement.

        :return: Returns a list of enum strings that are valid.
        :rtype: list[str]
        """
        return [MeterUnits(x).name for x in self.api_ref.GetDisplaySettings(self.index).UnitList]

    def configure_units(self, unit: Union[MeterUnits, str] = None):
        """
        Allows configuration of the x or y units, or both. If left empty will return the currently configured units.

        :param unit: unit options.. all may not be valid depending on input connector settings, but the function
            will check validity for trying to set the configuration.

            DB

        :type unit: MeterUnits | str
        :return: the units if no units are specified when called, otherwise returns nothing
        :rtype: str | None
        """

        if unit is None:
            return MeterUnits(self.api_ref.GetDisplaySettings(self.index).Unit).name

        unit = check_enum_or_str('unit', unit, MeterUnits)
        if unit is not None:
            if unit.name not in self.get_available_units():
                raise ValueError(f'Invalid y_unit "{unit}". Valid options are '
                                 f'{[x for x in self.get_available_units()]}.')
            self.api_ref.GetDisplaySettings(self.index).Unit = unit.value

    def configure_title(self, title: str = None):
        """
        Allows configuration of meter title. This functions removes text in () so units are only logged in one place

        :param title: title to set
        :type title: str
        :return: the title if no title is specified when called, otherwise returns nothing
        :rtype: str | None
        """

        if title is None:

            title = self.api_ref.GetDisplaySettings(self.index).Title
            title = re.sub("\(DCX\)", "dcx", title)  # keep dcx suffix if found in ()
            title = re.sub("[\(\[].*?[\)\]]", "", title)  # delete all other text in ()
            title = title.strip(' ').replace(',', '').replace('-', '').replace('>', '')
            return title
        else:
            self.api_ref.GetDisplaySettings(self.index).Title = title

    def _get_export_units(self):
        return [MeterUnits[self.configure_units()].value]

    def get_channel_count(self):
        """
        Returns the channel count for this meter

        :return: channel count
        :rtype: int
        """
        return self._result_obj.GetChannelCount(self.index)

    def get_result_type(self) -> str:
        """
        Returns the BenchMeterType enum string for this result

        :return: BenchModeMeterType string for this meter result
        :rtype: str
        """
        return BenchMeterType[re.sub("\(DCX\)", "dcx", self.meter_type.Name.replace(' ', '_').replace("+", '')).upper()
                              ].name



