import os
from pathlib import Path
from typing import Any, Dict, List, Union
from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str, on_off
from cl_instr_lib.drivers.audio.apx.enums import MasterClockSource, ClockDirection, SerialDataLine, SerialFormat, \
    SerialChannels, SerialLogicLevel, SerialCustomDataJustification, FrameClockPulseWidth, EdgeSync, DataEdge, \
    OutputConnectorTypes, AnalogBalancedSourceImpdedanceValues, AnalogBalancedConfigurationType, Interpolation, \
    ScalePdmOutFreqBy, ScaleOutputFreqBy, AnalogSineGenMode, AnalogUnbalancedSourceImpdedanceValues, PdmModulatorOrder, \
    PdmModulatorOsr
from cl_instr_lib.helpers.check_range import check_range, min_max_units


connector_values = {5.0: {'AnalogUnbalanced': 0,
                            'AnalogBalanced': 1,
                            'AnalogBalancedAdcTest': 2,
                            'DigitalUnbalanced': 3,
                            'DigitalBalanced': 4,
                            'DigitalOptical': 5,
                            'DigitalHdmi': 6,
                            'HdmiArc': 7,
                            'Bluetooth': 8,
                            'DigitalSerial': 9,
                            'PDM': 10,
                            'ASIO': 11,
                            'TransducerInterface': 12,
                            'Speaker': 13,
                            'Telecoil': 14,
                            'None': 15},
                    4.5: {'AnalogUnbalanced': 0,
                          'AnalogBalanced': 1,
                          'DigitalUnbalanced': 2,
                          'DigitalBalanced': 3,
                          'DigitalOptical': 4,
                          'DigitalHdmi': 5,
                          'HdmiArc': 6,
                          'Bluetooth': 7,
                          'DigitalSerial': 8,
                          'PDM': 9,
                          'ASIO': 10,
                          'TransducerInterface': 11,
                          'Speaker': 12,
                          'Telecoil': 13,
                          'None': 14}}


class Output:
    """Base class for APx output module."""
    def __init__(self, apx):
        self._apx = apx

    def connector(self, connector_type: Union[str, OutputConnectorTypes] = None) -> str:
        """
        Set the output connector to one of the following configurations:

            * Analog Unbalanced
            * Analog Balanced
            * Digital Unbalanced
            * Digital Balanced
            * Digital Optical
            * HDMI Source
            * HDMI ARC Tx
            * Bluetooth
            * Digital Serial
            * PDM
            * ASIO
            * External

        Call method with no parameters to return the current connector settings.

        :param connector_type: Connector setting to set.
        :type connector_type: str|OuputConnectorTypes
        :return: Current connector type if method is called with no parameters, otherwise None
        :rtype: str|None
        """

        if connector_type is None:
            return OutputConnectorTypes(list(connector_values[self._apx.sw_version].keys())
                                        [list(connector_values[self._apx.sw_version].values()).index(
                                         self._apx.api.BenchMode.Setup.OutputConnector.Type)]).name
        connector_type = check_enum_or_str('connector_type', connector_type, OutputConnectorTypes)
        self._apx.api.BenchMode.Setup.OutputConnector.Type = connector_values[self._apx.sw_version][connector_type.value]

    def configure_analog_unbalanced(self, channels: int = None, source_impedance:
                                    Union[str, AnalogUnbalancedSourceImpdedanceValues] = None,
                                    acoustic: Union[bool, int, str] = None, eq: str = None,
                                    sine_gen_mode: Union[AnalogSineGenMode, str] = None,
                                    *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for the analog unbalanced output. This function automatically changes the output
        connector to ANALOG_UNBALANCED.

        :param channels: Change the number of allowable channels configured on output connector. Accepts an integer
            between 1 and the maximum allowable channels for an instrument.
        :type channels: int
        :param source_impedance: Set source impdeance for output connector. Options include:
            
                * _20_OHM 
                * _50_OHM 
                * _75_OHM 
                * _100_OHM
                * _600_OHM
                
        :type source_impedance: str|AnalogUnbalancedSourceImpdedanceValues
        :param acoustic: Enable/disable acoustic setting for output connector. Accepts: 'ON', True, 1 or '1'. For OFF
            accepts: 'OFF', False, 0, or '0'.
        :type acoustic: bool|int|str
        :param eq: Filepath to EQ curve data file.
        :type eq: str
        :param sine_gen_mode: Specifies the sine generator mode. Options: 'HIGH_PERFORMANCE_SINE_GEN', 'DAC_GEN'
        :type sine_gen_mode: AnalogSineGenMode|str
        :return: If no parameters are passed in, this function returns a dictionary of all currrently configured
            parameters.
        :rtype: dict
        """

        # APx.BenchMode.Setup.AnalogOutput.ChannelCount
        # APx.BenchMode.Setup.AnalogOutput.UnbalancedSourceImpedance
        # APx.BenchMode.Setup.AcousticOutput
        # APx.BenchMode.Setup.OutputEq
        # APx.BenchMode.Setup.AnalogOutput.ChannelCount
        # APx.BenchMode.Setup.OutputChannelCount
        # APx.BenchMode.Generator.Levels.Count

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (channels, source_impedance, acoustic, eq, sine_gen_mode)):
            return_values = {}
            return_values.update(channels=self._apx.api.BenchMode.Setup.AnalogOutput.ChannelCount)
            return_values.update(source_impedance=AnalogUnbalancedSourceImpdedanceValues(
                self._apx.api.BenchMode.Setup.AnalogOutput.UnbalancedSourceImpedance).name)
            return_values.update(acoustic=on_off.to_api(self._apx.api.BenchMode.Setup.AcousticOutput))
            return_values.update(eq=self._apx.api.BenchMode.Setup.OutputEq.Eq)
            return_values.update(sine_gen_mode=AnalogSineGenMode(self._apx.api.BenchMode.Generator.AnalogSineMode).name)
            return return_values
        else:
            if self.connector() != OutputConnectorTypes.ANALOG_UNBALANCED.name:
                self.connector(OutputConnectorTypes.ANALOG_UNBALANCED)

        # Error Checking
        if channels is not None:
            if not 0 < channels <= self._apx.api.Version.MaxAnalogOutputChannelCount:
                raise ValueError(f'Bad channels value: {channels}. Must be 0 < channels <= '
                                 f'{self._apx.api.Version.MaxAnalogOutputChannelCount}')
        source_impedance = check_enum_or_str('source_impedance', source_impedance,
                                             AnalogUnbalancedSourceImpdedanceValues)
        if eq is not None:
            if not isinstance(eq, str):
                raise ValueError(f'Bad eq: {eq}. Must be str')
            if eq not in self._apx.api.BenchMode.Setup.OutputEq.EqNames:
                raise ValueError(f'Bad eq name {eq}. Valid names are {self._apx.api.BenchMode.Setup.OutputEq.EqNames}')
        sine_gen_mode = check_enum_or_str('sine_gen_mode', sine_gen_mode, AnalogSineGenMode)

        acoustic = on_off.to_inst(acoustic)

        # Write to Instrument
        if channels is not None:
            self._apx.api.BenchMode.Setup.AnalogOutput.ChannelCount = channels
        if source_impedance is not None:
            self._apx.api.BenchMode.Setup.AnalogOutput.UnbalancedSourceImpedance = source_impedance.value
        if acoustic is not None:
            self._apx.api.BenchMode.Setup.AcousticOutput = acoustic
        if eq is not None:
            self._apx.api.BenchMode.Setup.OutputEq.Eq=eq
        if sine_gen_mode is not None:
            self._apx.api.BenchMode.Generator.AnalogSineMode = sine_gen_mode.value

    def configure_analog_balanced(self, channels: int = None, source_impedance:
                                    Union[str, AnalogBalancedSourceImpdedanceValues] = None,
                                    acoustic: Union[bool, int, str] = None, eq: str = None, configuration:
                                    Union[str,AnalogBalancedConfigurationType] = None,
                                    sine_gen_mode: Union[AnalogSineGenMode, str] = None,
                                             *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for the analog balanced output. This function automatically changes the output
        connector to ANALOG_BALANCED.

        :param channels: Change the number of allowable channels configured on output connector. Accepts an integer
            between 1 and the maximum allowable channels for an instrument.
        :type channels: int
        :param source_impedance: Set source impdeance for output connector. Options include:
        
            * _40_OHM 
            * _100_OHM
            * _150_OHM
            * _200_OHM
            * _600_OHM
            
        :type source_impedance: str|AnalogBalancedSourceImpdedanceValues
        :param acoustic: Enable/disable acoustic setting for output connector. Accepts: 'ON', True, 1 or '1'. For OFF
            accepts: 'OFF', False, 0, or '0'.
        :type acoustic: bool|int|str
        :param eq: Filepath to EQ curve data file.
        :type eq: str
        :param configuration: The common mode signal generation setting. Options: 'NORMAL', CMTST', 'CMTST_PIN_2', 
            'CMTST_PIN_3'
        :type configuration: str|AnalogBalancedConfigurationType
        :param sine_gen_mode: Specifies the sine generator mode. Options: 'HIGH_PERFORMANCE_SINE_GEN', 'DAC_GEN'
        :type sine_gen_mode: AnalogSineGenMode|str
        :return: If nothing but the channel is input, method returns a dictionary of current parameter configurations
            for the analog balanced output connector. Otherwise returns None.
        :rtype: dict|None
        """

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (channels, source_impedance, acoustic, eq, configuration, sine_gen_mode)):
            return_values = {}
            return_values.update(channels=self._apx.api.BenchMode.Setup.AnalogOutput.ChannelCount)
            return_values.update(acoustic=on_off.to_api(self._apx.api.BenchMode.Setup.AcousticOutput))
            return_values.update(eq=self._apx.api.BenchMode.Setup.OutputEq.Eq)
            config = AnalogBalancedConfigurationType(
                self._apx.api.BenchMode.Setup.AnalogOutput.CommonModeConfiguration)
            return_values.update(configuration=config.name)
            if config.value < 2:
                return_values.update(source_impedance=AnalogBalancedSourceImpdedanceValues(
                    self._apx.api.BenchMode.Setup.AnalogOutput.BalancedSourceImpedance).name)
            return_values.update(sine_gen_mode=AnalogSineGenMode(self._apx.api.BenchMode.Generator.AnalogSineMode).name)
            return return_values
        else:
            if self.connector() != OutputConnectorTypes.ANALOG_BALANCED.name:
                self.connector(OutputConnectorTypes.ANALOG_BALANCED)

        # Error Checking
        if channels is not None:
            if not 0 < channels <= self._apx.api.Version.MaxAnalogOutputChannelCount:
                raise ValueError(f'Bad channels value: {channels}. Must be 0 < channels <= '
                                 f'{self._apx.api.Version.MaxAnalogOutputChannelCount}')
        source_impedance = check_enum_or_str('source_impedance', source_impedance,
                                             AnalogBalancedSourceImpdedanceValues)
        configuration = check_enum_or_str('configuration', configuration, AnalogBalancedConfigurationType)
        config = AnalogBalancedConfigurationType(
            self._apx.api.BenchMode.Setup.AnalogOutput.CommonModeConfiguration)
        if source_impedance is not None:
            err = False
            if (configuration is None and config.value > 1):
                err = True
            elif configuration is not None:
                if configuration.value > 1:
                    err = True
            else:
                err = False
            if err:
                raise ValueError('Cannot set source impedance if configuration is "CMTST_PIN_2", "CMTST_PIN_3"')
        sine_gen_mode = check_enum_or_str('sine_gen_mode', sine_gen_mode, AnalogSineGenMode)

        if eq is not None:
            if not isinstance(eq, str):
                raise ValueError(f'Bad eq: {eq}. Must be str')
            if eq not in self._apx.api.BenchMode.Setup.OutputEq.EqNames:
                raise ValueError(f'Bad eq name {eq}. Valid names are {self._apx.api.BenchMode.Setup.OutputEq.EqNames}')

        acoustic = on_off.to_inst(acoustic)

        # Write to Instrument
        if channels is not None:
            self._apx.api.BenchMode.Setup.AnalogOutput.ChannelCount = channels
        if source_impedance is not None:
            self._apx.api.BenchMode.Setup.AnalogOutput.BalancedSourceImpedance = source_impedance.value
        if acoustic is not None:
            self._apx.api.BenchMode.Setup.AcousticOutput = acoustic
        if eq is not None:
            self._apx.api.BenchMode.Setup.OutputEq.Eq=eq
        if configuration is not None:
            self._apx.api.BenchMode.Setup.AnalogOutput.CommonModeConfiguration = configuration.value
        if sine_gen_mode is not None:
            self._apx.api.BenchMode.Generator.AnalogSineMode = sine_gen_mode.value

    def configure_dso_audio_settings(self, use_single_data_line: Union[bool, int, str] = None,
                                     enabled_data_lines: List[Union[SerialDataLine, str, int]] = None,
                                     channels: Union[SerialChannels, str, int] = None,
                                     format: Union[SerialFormat, str] = None, msb_first: Union[bool, int, str] = None,
                                     word_width: int = None, bit_depth: int = None,
                                     justification: Union[SerialCustomDataJustification, str] = None,
                                     frame_clock_pulse_width: Union[FrameClockPulseWidth, str] = None,
                                     frame_clk_invert: Union[bool, int, str] = None,
                                     frame_clk_shift_left: Union[bool, int, str] = None,
                                     *args, **kwargs) -> Dict[str, Any]:
        """
        This function configures the output connector to Digital Serial Transmitter and allows configuring all
        associated settings. If no parameters are passed in it will return the current configuration settings from the
        instrument.

        :param use_single_data_line: Gets or sets whether the output channels are to be transmitted on a single data
            line using Time Division Multiplexing (TDM), or whether the channels are to be received in stereo pairs on
            each data line. True if single_data_line(tdm), false if multiple data lines.
            Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'
        :type use_single_data_line: str|bool|int
        :param enabled_data_lines: Gets or sets whether or not a specified data line carries data. Input a list
            composed of data lines that will carry data. All data lines not specified within the set list will be
            disabled. Options for enabling a data line include ONE, TWO, THREE or FOUR, or 1, 2, 3, 4, or values from
            SerialDataLine enum.
        :type enabled_data_lines: str|int|SerialDataLine
        :type enabled_data_lines: List[str|int|SerialDataLine]
        :param channels: Gets or sets the number of channels to transmit. 'ONE', 'TWO', 'FOUR', 'SIX', 'EIGHT',
            'SIXTEEN', or 1, 2, 4, 6, 8, 16
        :type channels: str|int|SerialChannels
        :param format: Gets or sets the expected format and justification of the incoming bitstream.
            'I2S', 'DSP', 'CUSTOM'
        :type format: SerialFormat|str
        :param msb_first: Gets or sets whether the MSB or LSB is first in the data. Accepts: 'ON', True, 1 or '1'. For
            OFF accepts: 'OFF', False, 0, or '0'
        :type msb_first: str|bool|int
        :param word_width: Gets or sets the size of the output word.
        :type word_width: int
        :param bit_depth: Gets or sets the digital output bit depth.
        :type bit_depth: int
        :param justification: Gets or sets how the data is justified relative to the frame clock. This property
            supercedes the SerialFormat.LeftJustified and SerialFormat.RightJustified values previously used in the
            Format property. This setting only applies when the Format property is Custom. 'LEFT_JUSTIFIED' or
            'RIGHT_JUSTIFIED'
        :type justification: str|SerialCustomDataJustification
        :param frame_clock_pulse_width: Gets or sets the width of the frame clock pulse. This setting only applies when
            the Format property is Custom. Options are 'ONE_BIT_CLOCK', ONE_SUBFRAME', or 'FIFTY_PERCENT_DUTY_CYCLE'
        :type frame_clock_pulse_width: str|FrameClockPulseWidth
        :param frame_clk_invert: Gets or sets whether the frame clock is inverted. This setting only applies when the
            Format property is Custom. Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'
        :type frame_clk_invert: str|int|bool
        :param frame_clk_shift_left: When "ON' then the frame clock is advanced by one bit clock. This setting only
            applies when the Format property is Custom. Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False,
            0, or '0'
        :type frame_clk_shift_left: str|int|bool
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
         """

        # APx.BenchMode.Setup.DigitalOutput
        # APx.BenchMode.Setup.Clocks
        # APx.BenchMode.Setup.SerialDigitalTransmitter.SingleDataLine
        # APx.BenchMode.Setup.SerialDigitalTransmitter.GetDataLineEnabled
        # APx.BenchMode.Setup.SerialDigitalTransmitter.SetDataLineEnabled

        self._apx.log_unused_args(args, kwargs)

        # readback
        if all(v is None for v in (use_single_data_line, enabled_data_lines, channels, format, msb_first,
                                   word_width, bit_depth, justification, frame_clock_pulse_width, frame_clk_invert,
                                   frame_clk_shift_left)):
            return_values = {}
            data_line_is_single = self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SingleDataLine
            return_values.update(use_single_data_line=on_off.to_api(data_line_is_single))
            if data_line_is_single:
                data_line_values = []
                for line in range(0, 4):
                    if self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.GetDataLineEnabled(line):
                        data_line_values.append(SerialDataLine(line + 1).name)
                return_values.update(enabled_data_lines=data_line_values)
            return_values.update(channels=SerialChannels(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.Channels)
                                 .value)
            return_values.update(format=SerialFormat(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.Format).name)
            return_values.update(msb_first=on_off.to_api(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MsbFirst))
            return_values.update(word_width=self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.WordWidth)
            return_values.update(bit_depth=self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitDepth)
            if SerialFormat(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.Format) == SerialFormat.CUSTOM:
                return_values.update(justification=SerialCustomDataJustification(
                    self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.DataJustification).name)
            return_values.update(frame_clock_pulse_width=FrameClockPulseWidth(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.FrameClockPulseWidth).name)
            return_values.update(frame_clk_invert=on_off.to_api(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.FrameClockInvert))
            return_values.update(frame_clk_shift_left=on_off.to_api(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.FrameClockLeftOneBit))
            return return_values
        else:
            if self.connector() != OutputConnectorTypes.DIGITAL_SERIAL.name:
                self.connector(OutputConnectorTypes.DIGITAL_SERIAL)

        # Error checking
        use_single_data_line = on_off.to_inst(use_single_data_line)
        single_line = use_single_data_line
        if single_line is None:
            single_line = on_off.to_inst(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SingleDataLine)
        if not single_line and enabled_data_lines is not None:
            raise ValueError(f'enabled_data_lines can not be configured when use_single_data_line is disabled.')
        if enabled_data_lines is not None:
            for index, line in enumerate(enabled_data_lines):
                enabled_data_lines[index] = check_enum_or_str('enabled_data_lines', line, SerialDataLine)
        channels = check_enum_or_str('channels', channels, SerialChannels)
        format = check_enum_or_str('format', format, SerialFormat)
        msb_first = on_off.to_inst(msb_first)
        if word_width is not None:
            if word_width > 128:
                raise ValueError(f'Bad word_width value: {word_width}. Needs to be less than 128.')
        check_range('bit_depth', bit_depth, min_max_units(8, 32, 'bits'))
        justification = check_enum_or_str('justification', justification, SerialCustomDataJustification)
        frame_clock_pulse_width = check_enum_or_str('frame_clock_pulse_width', frame_clock_pulse_width,
                                                    FrameClockPulseWidth)
        frame_clk_invert = on_off.to_inst(frame_clk_invert)
        frame_clk_shift_left = on_off.to_inst(frame_clk_shift_left)
        param_name = None

        # Write to Instrument
        if use_single_data_line is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SingleDataLine = use_single_data_line
        if enabled_data_lines is not None:
            for line in range(0, 4):
                if SerialDataLine(line + 1) in enabled_data_lines:
                    self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SetDataLineEnabled(
                        line, 1)
                else:
                    self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SetDataLineEnabled(line, 0)
        if channels is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.Channels = channels.value
        if format is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.Format = format.value
        if msb_first is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MsbFirst = msb_first
        if bit_depth is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitDepth = bit_depth
        if word_width is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.WordWidth = word_width
        if justification is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.DataJustification = justification.value
        if frame_clock_pulse_width is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.FrameClockPulseWidth = frame_clock_pulse_width.value
        if frame_clk_invert is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.FrameClockInvert = frame_clk_invert
        if frame_clk_shift_left is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.FrameClockLeftOneBit = frame_clk_shift_left

    def configure_dso_clocks(self, master_clock_source: Union[str,MasterClockSource] = None,
                             master_clock_rate: Union[int, float] = None, mclk_out_en: Union[bool, int, str] = None,
                             mclk_invert:  Union[bool, int, str] = None, bit_frame_clk_dir: Union[str, ClockDirection]
                             = None, frame_clk_rate_hz: Union[int, float] = None, mclk_ratio: int = None,
                             logic_level: Union[str, SerialLogicLevel] = None, bit_clk_out_edge: Union[str, EdgeSync] =
                             None, bit_clk_in_edge: Union[str, EdgeSync] = None, *args, **kwargs) -> Dict:
        """
        Configures the clocking settings for the digital serial transmitter. This function will update the connector
        tpye to digital serial if not already set.

        :param master_clock_source: Gets or sets whether the master clock is generated by APx or by the DUT.
            On the Digital Serial Receiver, the master clock can either be generated by APx or by the DUT.
            On the Digital Serial Transmitter, the master clock is always generated by APx. Options: 'INTERNAL',
            'EXTERNAL'
        :type master_clock_source: str|MasterClockSource
        :param master_clock_rate: sets the master clock rate (in terms of the curretly configured units.
            APx default is Hz. This rate can only be configured when using an internal master clock source and a bit
            clock direction of IN. This code will error if trying to set the rate when not in this configuration.
        :type master_clock_rate: int|float
        :param mclk_out_en: Gets or sets whether or not the master clock is generated/output by APx. Accepts: 'ON',
            True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type mclk_out_en: bool, int, str
        :param mclk_invert: Gets or sets whether the master clock is inverted. Accepts: 'ON', True, 1 or '1'.
            For OFF accepts: 'OFF', False, 0, or '0'.
        :type mclk_invert: bool, int, str
        :param bit_frame_clk_dir: Gets or sets the direction of the bit clock. Options: 'IN', 'OUT'
        :type bit_frame_clk_dir: str|ClockDirection
        :param frame_clk_rate_hz: Gets the setting for the output sample rate. This setting is only valid when the
            master clock is configured as an output.
        :type frame_clk_rate_hz: int|float
        :param mclk_ratio: Gets or sets the master clock rate multiplier.
        :type mclk_ratio: int
        :param logic_level: output voltage level for the Digital Serial Transmitter. Options: 'V1P8', 'V2P5', 'V3P3'
        :type logic_level: str|SerialLogicLevel
        :param bit_clk_out_edge: whether the leading edge of the frame (and data) are synchronized with the rising edge
            or the falling edge of the bit clock. Options: 'RISING_EDGE', 'FALLING_EDGE'
        :type bit_clk_out_edge: str|EdgeSync
        :param bit_clk_in_edge: whether the leading edge of the frame (and data) are synchronized with the rising edge
            or the falling edge of the bit clock, for DSIO receiver inputs. Options: 'RISING_EDGE', 'FALLING_EDGE'
        :type bit_clk_in_edge: str|EdgeSync
        :return: If no parameters are passed in, this function returns a dictionary of all currrently configured
            parameters.
        :rtype: dict
        """

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (master_clock_source, master_clock_rate, mclk_out_en, mclk_invert, bit_frame_clk_dir,
                                   frame_clk_rate_hz, mclk_ratio, logic_level, bit_clk_out_edge, bit_clk_in_edge)):
            return_values = {}
            master_clock_source = MasterClockSource(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockSource).name
            bit_frame_clk_dir = ClockDirection(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitFrameClockDirection).name
            logic_level=SerialLogicLevel(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.LogicLevel).name
            if master_clock_source == 'INTERNAL':
                mclk_out_en=on_off.to_api(not(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockOff))
                if bit_frame_clk_dir == 'OUT':
                    master_clock_rate=self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SampleRate.Value * \
                                      self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockMultiplier
                    mclk_invert=on_off.to_api(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.InvertMasterClock)
                    frame_clk_rate_hz=self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SampleRate.Value
                else:
                    master_clock_rate=self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockRate.Value
            if bit_frame_clk_dir == 'OUT':
                mclk_ratio=self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockMultiplier
            if bit_frame_clk_dir == 'IN':
                bit_clk_in_edge = EdgeSync(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitClkReceiveEdgeSync).name
            bit_clk_out_edge=EdgeSync(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitClkSendEdgeSync).name
            return_values.update(master_clock_source=master_clock_source)
            if master_clock_rate is not None:
                return_values.update(master_clock_rate=master_clock_rate)
            if mclk_out_en is not None:
                return_values.update(mclk_out_en=mclk_out_en)
            if mclk_invert is not None:
                return_values.update(mclk_invert=mclk_invert)
            return_values.update(bit_frame_clk_dir=bit_frame_clk_dir)
            if frame_clk_rate_hz is not None:
                return_values.update(frame_clk_rate_hz=frame_clk_rate_hz)
            if mclk_ratio is not None:
                return_values.update(mclk_ratio=mclk_ratio)
            return_values.update(logic_level=logic_level)
            return_values.update(bit_clk_out_edge=bit_clk_out_edge)
            if bit_clk_in_edge is not None:
                return_values.update(bit_clk_in_edge=bit_clk_in_edge)
            return return_values
        else:
            if self.connector() != OutputConnectorTypes.DIGITAL_SERIAL.name:
                self.connector(OutputConnectorTypes.DIGITAL_SERIAL)

        # Error Checking

        # master_clock_source
        master_clock_source = check_enum_or_str('master_clock_source', master_clock_source, MasterClockSource)
        if master_clock_source is None:
            mclk_src = MasterClockSource(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockSource)
        else:
            mclk_src = master_clock_source
        # bit_frame_clk_dir
        bit_frame_clk_dir = check_enum_or_str('bit_frame_clk_dir', bit_frame_clk_dir, ClockDirection)
        if bit_frame_clk_dir is None:
            direction = ClockDirection(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitFrameClockDirection)
        else:
            direction = bit_frame_clk_dir

        # master_clock_rate
        if (mclk_src != MasterClockSource.INTERNAL or direction != ClockDirection.IN) \
                and master_clock_rate is not None:
            raise ValueError(f'master_clock_rate cannot be set unless master_clock_source=INTERNAL and '
                             f'bit_frame_clk_dir=IN')
        # frame_clk_rate_hz
        elif mclk_src != MasterClockSource.INTERNAL and direction != ClockDirection.OUT \
                and frame_clk_rate_hz is not None:
            raise ValueError(f'frame_clk_rate_hz cannot be set unless master_clock_source=INTERNAL and '
                             f'bit_frame_clk_dir=OUT')

        # mclk_out_en
        if mclk_out_en is not None:
            mclk_out_en = not (on_off.to_inst(mclk_out_en))
            if mclk_src != MasterClockSource.INTERNAL:
                raise ValueError(f'Cannot set mclk_out_en when the master_clock_source is not INTERNAL.')
            if direction != ClockDirection.OUT:
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to OUT, mclk_out_en is '
                                 f'fixed to the ON state. Set bit_frame_clk_dir to OUT to change master_clock_rate.')

        # mclk_invert
        mclk_invert = on_off.to_inst(mclk_invert)
        if mclk_invert is not None:
            if mclk_src != MasterClockSource.INTERNAL:
                raise ValueError(f'Cannot set mclk_invert when the master_clock_source is not INTERNAL.')
            if direction != ClockDirection.OUT:
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to OUT, mclk_invert is '
                                 f'unavailable. Set bit_frame_clk_dir to OUT to change mclk_invert parameter.')

        # mclk_ratio
        if mclk_ratio is not None:
            if direction != ClockDirection.OUT:
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to OUT, mclk_ratio is'
                                 f' unavailable. Set bit_frame_clk_dir to OUT to change mclk_ratio.')
            check_range('mclk_ratio', mclk_ratio, min_max_units(1, 14000, ''))

        # logic_level
        logic_level = check_enum_or_str('logic_level', logic_level, SerialLogicLevel)

        # bit_clk_out_edge
        bit_clk_out_edge = check_enum_or_str('bit_clk_out_edge', bit_clk_out_edge, EdgeSync)

        # bit_clk_in_edge
        bit_clk_in_edge = check_enum_or_str('bit_clk_in_edge', bit_clk_in_edge, EdgeSync)
        if bit_clk_in_edge is not None:
            if direction != ClockDirection.IN:
                raise ValueError('bit_clk_in_edge fixed to "RISING_EDGE" when bit_frame_clk_dir is "OUT". Change '
                                 'bit_frame_clk_dir to "IN" to change bit_clk_in_edge.')

        # Write values to instrument
        if master_clock_source is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockSource = master_clock_source.value
        if bit_frame_clk_dir is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitFrameClockDirection = bit_frame_clk_dir.value
        if master_clock_rate is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockRate.Value = master_clock_rate
        if mclk_out_en is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockOff = mclk_out_en
        if mclk_invert is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.InvertMasterClock = mclk_invert
        if frame_clk_rate_hz is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.SampleRate.Value = float(frame_clk_rate_hz)
        if mclk_ratio is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockMultiplier = mclk_ratio
        if logic_level is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.LogicLevel = logic_level.value
        if bit_clk_out_edge is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitClkSendEdgeSync = bit_clk_out_edge.value
        if bit_clk_in_edge is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitClkReceiveEdgeSync = bit_clk_in_edge.value

    def configure_dso(self, open_config_file: Union[str, Path] = None,
                      scale_freq_by: Union[str, ScaleOutputFreqBy] = None,
                      fixed_rate_freq: Union[int, float] = None, outputs_en: Union[str, int, bool] = None,
                      *args, **kwargs):
        """
        This function configures the output connector to Digital Serial Reciever and allows configuring all associated
        miscellaneous settings (not specific to audio or clock). If no parameters are passed in it will return the
        current configuration settings from the instrument.

        :param open_config_file: Open a saved configuration for Digital Serial Transmitter config. Insert the file path
            with file name to apply the saved config. Parameter has no readback option.
        :type open_config_file: str|Path
        :param scale_freq_by: Set how the output sample rate is determined. Accepts the following inputs:

            * OUTPUT_SR - Only if output connector is digital
            * FIXED_RATE

        :type scale_freq_by: str|ScaleOutputFreqBy
        :param fixed_rate_freq: When scale_freq_by is set to FIXED_RATE, use this parameter to set what frequency the
            fixed rate should be set to. Hz is the only unit available.
        :type fixed_rate_freq: int|float
        :param outputs_en: Sets whether the Digital Serial Transmitter module is generating any voltage.
        :type outputs_en: bool|str|int
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        # APx.BenchMode.Setup.SerialDigitalTransmitter.Open(fileName)
        # APx.BenchMode.Setup.SerialDigitalTransmitter.ScaleFreqBy
        # APx.BenchMode.Setup.SerialDigitalTransmitter.ScaleFreqByFixedRate
        # APx.BenchMode.Setup.SerialDigitalTransmitter.EnableOutputs

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (open_config_file, scale_freq_by, fixed_rate_freq, outputs_en)):
            return_values = {}
            return_values.update(scale_freq_by=ScaleOutputFreqBy(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.ScaleFreqBy).name)
            return_values.update(fixed_rate_freq=self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.ScaleFreqByFixedRate)
            return_values.update(outputs_en=on_off.to_api(
                self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.EnableOutputs))
            return return_values
        else:
            if self.connector() != OutputConnectorTypes.DIGITAL_SERIAL.name:
                self.connector(OutputConnectorTypes.DIGITAL_SERIAL)

        # Error Checking
        if open_config_file is not None:
            if isinstance(open_config_file, Path):
                open_config_file = os.path.abspath(open_config_file)  # convert to string.
            if isinstance(open_config_file, str):
                if not os.path.isfile(open_config_file):
                    raise ValueError(f'Bad config_file_path: {open_config_file}. Not a valid filepath or filename.')
                if not open_config_file.endswith('.stx'):
                    raise ValueError(f'Bad config_file_path: {open_config_file}. File type needs to be .stx')
            else:
                raise ValueError(f'Bad config_file_path: {open_config_file}. Needs to be of type str or Path. '
                                 f'Current type is {type(open_config_file)}')

        scale_freq_by = check_enum_or_str('scale_freq_by', scale_freq_by, ScaleOutputFreqBy)

        if fixed_rate_freq is not None:
            curr_scale_freq_by = ScaleOutputFreqBy(self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.ScaleFreqBy).name
            if scale_freq_by is not None:
                curr_scale_freq_by = scale_freq_by
            if curr_scale_freq_by != 'FIXED_RATE':
                raise ValueError(f'scale_freq_by parameter must be set to "FIXED_RATE" in order to set the Fixed Rate '
                                 f'frequency. Currectly set to {curr_scale_freq_by}')
            check_range('fixed_rate_freq', fixed_rate_freq, min_max_units(4e3, 432e3, 'Hz'))

        outputs_en = on_off.to_inst(outputs_en)
        if outputs_en is not None:
            if self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.MasterClockSource == 1:
                curr_bit_frame_clock_dir = self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.BitFrameClockDirection
                if curr_bit_frame_clock_dir != 1:
                    raise ValueError('Bit & Frame Direction must be configured "OUT" to enabled outputs.')

        # Write to Instrument
        if open_config_file is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.Open(open_config_file)
        if scale_freq_by is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.ScaleFreqBy = scale_freq_by.value
        if fixed_rate_freq is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.ScaleFreqByFixedRate = fixed_rate_freq
        if outputs_en is not None:
            self._apx.api.BenchMode.Setup.SerialDigitalTransmitter.EnableOutputs = outputs_en

    def configure_pdm(self, bit_clk_dir: Union[str, ClockDirection] = None,
                      interpolation: Union[str, Interpolation] = None,
                      decimated_rate: Union[int, float] = None, modulator_order: Union[str, PdmModulatorOrder] = None,
                      modulator_osr: Union[str, PdmModulatorOsr] = None, data_edge: Union[str, DataEdge] = None,
                      logic_level: Union[int, float] = None, vdd_level: Union[int, float] = None,
                      limit_logic_level: Union[bool, int, str] = None, output_state_vdd: Union[bool, int, str] = None,
                      scale_freq_by: Union[str, ScalePdmOutFreqBy] = None, fixed_rate_freq: Union[int, float] = None,
                      *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for the output PDM connector.

        :param bit_clk_dir: Sets the direction of the bit clock.  Options include: IN, OUT
        :type bit_clk_dir: str|ClockDirection Enum
        :param interpolation: Sets the interpolation ratio (a.k.a. oversampling ratio). Options include:

            * X16
            * X16P67
            * X21P33
            * X24
            * X25
            * X32
            * X33P33
            * X37P5
            * X42P67
            * X48
            * X50
            * X62P5
            * X64
            * X66P67
            * X75
            * X85P33
            * X96
            * X100
            * X125
            * X128
            * X150
            * X192
            * X200
            * X250
            * X256
            * X300
            * X384
            * X400
            * X500
            * X512
            * X600
            * X768
            * X800

        :type interpolation: st|Interpolation Enum
        :param decimated_rate: Set the decimated sample rate. Can only be set if bit_clk_dir is "OUT".
        :type decimated_rate: int|float
        :param modulator_order: Sets the modulator order. Options: ORDER4, ORDER5
        :type modulator_order: str|PdmModulatorOrder
        :param modulator_osr: Gets or sets the modulator sample rate multiplier. Options: OSR_AUTO, OSR_64, OSR_128,
            OSR_256, OSR_512
        :type modulator_osr: str|PdmModulatorOsr
        :param data_edge: Set which edge or edges the data is sampled on. Options include: RISING_EDGE, FALLING_EDGE
        :type data_edge: str|DataEdge Enum
        :param logic_level: Sets the DC logic level provided at the PDM output connector.
        :type logic_level: int|float
        :param vdd_level: Sets the DC voltage level provided at the Vdd connector on the PDM module front panel.
        :type vdd_level: int|float
        :param limit_logic_level: Sets whether or not the Vdd level will limit the Logic level. Accepts: 'ON', True, 1
            or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type limit_logic_level: bool|int|str
        :param output_state_vdd: Sets whether or not the Vdd supply voltage is turned ON. Accepts: 'ON', True, 1 or '1'.
            For OFF accepts: 'OFF', False, 0, or '0'.
        :type output_state_vdd: bool|int|str
        :param scale_freq_by: Gets or sets how the clock rate is computed when the BitClkDir is in. The user can provide
            a fixed output rate value if set to FIXED_RATE. Options include: FIXED_RATE, DECIMATED_RATE
        :type scale_freq_by: str|ScalePdmOutFreqBy Enum
        :param fixed_rate_freq: Gets the setting for the fixed clock frequency scaling when the ScalePdmOutFreqBy
            setting is FixedRate.
        :type fixed_rate_freq: float
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        # APx.BenchMode.Setup.PdmOutput.BitClkDir
        # APx.BenchMode.Setup.PdmOutput.Interpolation
        # APx.BenchMode.Setup.PdmOutput.DecimatedRate
        # APx.BenchMode.Setup.PdmOutput.ModulatorOrder
        # APx.BenchMode.Setup.PdmOutput.ModulatorOsr
        # APx.BenchMode.Setup.PdmOutput.BitClockRate
        # APx.BenchMode.Setup.PdmOutput.DataEdge
        # APx.BenchMode.Setup.PdmOutput.LogicLevel
        # APx.BenchMode.Setup.PdmOutput.VddLevel
        # APx.BenchMode.Setup.PdmOutput.LimitLogicLevel
        # APx.BenchMode.Setup.PdmOutput.VddOn
        # APx.BenchMode.Setup.PdmOutput.ScaleFreqBy
        # APx.BenchMode.Setup.PdmOutput.FixedRate.Value

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (bit_clk_dir, interpolation, decimated_rate, modulator_order, modulator_osr,
                                   data_edge, logic_level, vdd_level,
                                   limit_logic_level, output_state_vdd, scale_freq_by, fixed_rate_freq)):
            return_values = {}
            curr_bit_clk_dir = ClockDirection(self._apx.api.BenchMode.Setup.PdmOutput.BitClkDir).name
            return_values.update(bit_clk_dir=curr_bit_clk_dir)
            return_values.update(interpolation=Interpolation(self._apx.api.BenchMode.Setup.PdmOutput.Interpolation).name)
            if curr_bit_clk_dir == ClockDirection.OUT.name:
                return_values.update(decimated_rate=self._apx.api.BenchMode.Setup.PdmOutput.DecimatedRate.Value)
                return_values.update(bit_clk_rate=self._apx.api.BenchMode.Setup.PdmOutput.BitClockRate)
            return_values.update(modulator_order=PdmModulatorOrder(self._apx.api.BenchMode.Setup.PdmOutput.ModulatorOrder).
                                 name)
            return_values.update(
                modulator_osr=PdmModulatorOsr(self._apx.api.BenchMode.Setup.PdmOutput.ModulatorOsr).name)
            return_values.update(data_edge=DataEdge(self._apx.api.BenchMode.Setup.PdmOutput.DataEdge).name)
            return_values.update(logic_level=self._apx.api.BenchMode.Setup.PdmOutput.LogicLevel.Value)
            return_values.update(vdd_level=self._apx.api.BenchMode.Setup.PdmOutput.VddLevel.Value)
            return_values.update(limit_logic_level=on_off.to_api(
                self._apx.api.BenchMode.Setup.PdmOutput.LimitLogicLevel))
            return_values.update(output_state_vdd=on_off.to_api(self._apx.api.BenchMode.Setup.PdmOutput.VddOn))
            curr_scale_freq_by = ScalePdmOutFreqBy(self._apx.api.BenchMode.Setup.PdmOutput.ScaleFreqBy).name
            return_values.update(scale_freq_by=curr_scale_freq_by)
            if curr_scale_freq_by == ScalePdmOutFreqBy.FIXED_RATE.name:
                return_values.update(fixed_rate_freq=self._apx.api.BenchMode.Setup.PdmOutput.FixedRate.Value)
            return return_values
        else:
            if self.connector() != OutputConnectorTypes.PDM.name:
                self.connector(OutputConnectorTypes.PDM)

        # Error Checking
        bit_clk_dir = check_enum_or_str('bit_clk_dir', bit_clk_dir, ClockDirection)

        curr_bit_clk_dir = bit_clk_dir
        if curr_bit_clk_dir is None:
            curr_bit_clk_dir = ClockDirection(self._apx.api.BenchMode.Setup.PdmOutput.BitClkDir)

        curr_logic_level = logic_level
        if curr_logic_level is None:
            curr_logic_level = self._apx.api.BenchMode.Setup.PdmOutput.LogicLevel.Value

        if curr_logic_level >= 2.0:
            max_bit_clk_rate = 24.576e6
        elif curr_logic_level >= 1.5:
            max_bit_clk_rate = 12.288e6
        elif curr_logic_level >= 1.0:
            max_bit_clk_rate = 6.144e6
        else:
            max_bit_clk_rate = 3.072e6

        interpolation = check_enum_or_str('interpolation', interpolation, Interpolation)
        if interpolation is not None:
            if interpolation == Interpolation.X800:
                if curr_logic_level < 1.0:
                    raise ValueError(f'Interpolation cannot be set to "X800" because the logic level is either set to '
                                     f'or attempting to be set to {curr_logic_level}V. Set logic_level to a value '
                                     f'greater than or equal to 1.0V to set interpolation to "X800".')

        curr_interpolation = interpolation
        if curr_interpolation is None:
            curr_interpolation = Interpolation(self._apx.api.BenchMode.Setup.PdmOutput.Interpolation)
        curr_interpolation_num = float(curr_interpolation.name.replace('X', '').replace('P', '.'))

        min_dec_rate = 4e3

        if decimated_rate is not None:
            if curr_bit_clk_dir.name != 'OUT':
                raise ValueError(f'Cannot set decimated_rate. Parameter bit_clk_dir needs to be set to OUT, currently'
                                 f' set to {curr_bit_clk_dir.name}')
            check_range('decimated_rate', decimated_rate,
                        min_max_units(min_dec_rate, min(216e3, max_bit_clk_rate/curr_interpolation_num), 'Hz'))

        modulator_order = check_enum_or_str('modulator_order', modulator_order, PdmModulatorOrder)
        modulator_osr = check_enum_or_str('modulator_osr', modulator_osr, PdmModulatorOsr)

        data_edge = check_enum_or_str('data_edge', data_edge, DataEdge)

        limit_logic_level = on_off.to_inst(limit_logic_level)

        curr_limit_logic_level = limit_logic_level
        if curr_limit_logic_level is None:
            curr_limit_logic_level = on_off.to_inst(self._apx.api.BenchMode.Setup.PdmOutput.LimitLogicLevel)

        if vdd_level is not None:
            if not isinstance(vdd_level, (int, float)):
                raise ValueError(f'Bad vdd_level type: {type(vdd_level)}. Must be an int or float type.')
            check_range('vdd_level', vdd_level, min_max_units(0, 3.6, 'V'))
            if curr_limit_logic_level is True:
                if curr_logic_level > vdd_level:
                    raise ValueError(f'Setting vdd_level to {vdd_level} cause it to be lower than logic_level: '
                                     f'{logic_level}. Either lower logic_level with vdd_level or set limit_logic_level'
                                     f' to OFF.')

        curr_vdd_level = vdd_level
        if curr_vdd_level is None:
            curr_vdd_level = self._apx.api.BenchMode.Setup.PdmOutput.VddLevel.Value

        if limit_logic_level is not None:
            if limit_logic_level is True:
                if curr_vdd_level < curr_logic_level:
                    raise ValueError(f'Cannot set limit_logic_level to ON as logic_level: {curr_logic_level} is greater than '
                          f'vdd_level: {curr_vdd_level}. Either decrease logic_level or increase vdd_level.')

        if logic_level is not None:
            if not isinstance(logic_level, (int, float)):
                raise ValueError(f'Bad logic_level type: {type(logic_level)}. Must be an int or float type.')
            check_range('logic_level', logic_level, min_max_units(800e-3, 3.3, 'V'))
            if logic_level < 1.0:
                if curr_interpolation_num == Interpolation.X800:
                    raise ValueError(f'logic_level cannot be set to {logic_level}. When interpolation is set to "X800", '
                                     f'the logic_level cannot be less than 1.0V. Set interpolation to a different setting'
                                     f'in order to set logic_level below 1.0V.')
            if curr_limit_logic_level is True:
                if curr_vdd_level < logic_level:
                    raise ValueError(f'Bad logic_level: {logic_level}. When limit_logic_level is ON, logic_level must '
                                     f'be less than or equal to vdd_level: {curr_vdd_level}.')

        output_state_vdd = on_off.to_inst(output_state_vdd)

        scale_freq_by = check_enum_or_str('scale_freq_by', scale_freq_by, ScalePdmOutFreqBy)
        curr_scale_freq_by = scale_freq_by
        if curr_scale_freq_by is None:
            curr_scale_freq_by = ScalePdmOutFreqBy(self._apx.api.BenchMode.Setup.PdmOutput.ScaleFreqBy)

        if fixed_rate_freq is not None:
            if curr_scale_freq_by != ScalePdmOutFreqBy.FIXED_RATE:
                raise ValueError(f'In order to set fixed_rate_freq, scale_freq_by parameter needs to be set to '
                                 f'FIXED_RATE. Currently set to {curr_scale_freq_by.name}')
            check_range('fixed_rate_freq', fixed_rate_freq, min_max_units(4e3, 432e3, 'Hz'))

        # Write to instrument
        if bit_clk_dir is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.BitClkDir = bit_clk_dir.value
        if limit_logic_level is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.LimitLogicLevel = limit_logic_level
        if (interpolation is not None) and (logic_level is not None):
            if curr_interpolation == Interpolation.X800:
                self._apx.api.BenchMode.Setup.PdmOutput.LogicLevel.Value = logic_level
                self._apx.api.BenchMode.Setup.PdmOutput.Interpolation = interpolation.value
            if curr_logic_level <= 1.0:
                self._apx.api.BenchMode.Setup.PdmOutput.Interpolation = interpolation.value
                self._apx.api.BenchMode.Setup.PdmOutput.LogicLevel.Value = logic_level
        elif interpolation is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.Interpolation = interpolation.value
        elif logic_level is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.LogicLevel.Value = logic_level
        if modulator_order is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.ModulatorOrder = modulator_order.value
        if modulator_osr is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.ModulatorOsr = modulator_osr.value
        if decimated_rate is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.DecimatedRate.Value = decimated_rate
        if data_edge is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.DataEdge = data_edge.value
        if vdd_level is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.VddLevel.Value = vdd_level
        if output_state_vdd is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.VddOn = output_state_vdd
        if scale_freq_by is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.ScaleFreqBy = scale_freq_by.value
        if fixed_rate_freq is not None:
            self._apx.api.BenchMode.Setup.PdmOutput.FixedRate.Value = fixed_rate_freq

    def IsAnalog(self):
        """
        Check if Outputconnector is Analog or Digital.

        :return: Return True if output is analog else False.
        :rtype: bool
        """
        return self._apx.api.BenchMode.Setup.OutputConnector.IsAnalog

    