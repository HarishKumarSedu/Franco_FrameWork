import os
import re
import time
from typing import Any, Union, List, Optional

from cl_instr_lib.drivers.audio.apx.reusables import on_off
from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.results_container.results_container import ResultsContainer
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.result import Result


class Measurement:
    """
    Base class for APx Bench Mode Measurements
    """
    meas_name = None
    results: ResultsContainer

    def __init__(self, apx):
        self._apx = apx
        self.results = ResultsContainer
        self.sync_with_gui()

    @property
    def api_ref(self):
        """
        Native APx API Reference for the Measurement

        :return: Native APx API Reference
        :rtype: reference
        """
        return self._apx.api.BenchMode.Measurements.__getattribute__(self.meas_name)

    def repeat(self, state: Union[bool, int, str] = None) -> str:
        """
        Gets or sets whether the measurement will keep running until the user cancels it.

        :param state: enable repeat measurement
        :type state: bool | int | str
        :return: Returns repeat setting as string(ON/OFF) if state is left empty
        :rtype: string
        """
        if state is None:
            return on_off.to_api(self.api_ref.Repeat)

        self.api_ref.Repeat = on_off.to_inst(state)

    def append(self, state: Union[bool, int, str] = None) -> str:
        """
        Gets or sets whether new data will be appended to the existing graph, or whether
            the data will be cleared each time the measurement starts.

        :param state: enable appending measurement data
        :type state: bool | int | str
        :return: Returns append setting as string(ON/OFF) if state is left empty
        :rtype: string
        """
        if state is None:
            return on_off.to_api(self.api_ref.Append)

        self.api_ref.Append = on_off.to_inst(state)

    def start(self):
        """
        Starts the measurement data collection
        """
        self.api_ref.Start()

    def stop(self):
        """
        Stops the measurement data collection
        """
        self.api_ref.Stop()

    def wait_for_measurement(self, timeout: int = 10, error_on_timeout: bool = True) -> bool:
        """
        Waits until the sweep completes, optionally errors on timeout

        :param timeout: time in seconds to wait before returning or raising an error
        :type timeout: int
        :param error_on_timeout: if true, logs an error if timeout is reached before sweep stops
        :type error_on_timeout: bool
        :return: Returns whether the sweep completed
        :rtype: bool
        """
        start = time.time()
        while self.api_ref.IsStarted:
            time.sleep(.01)
            if time.time() - start > timeout:
                if error_on_timeout:
                    self._apx.log.error(f"Data collection of {self.meas_name} exceeded timeout of {timeout} sec")
                else:
                    break
        return not self.api_ref.IsStarted  # returns whether the sweep completed

    def delete_all_results(self):
        """
        Removes all result graphs
        """
        while self.api_ref.Graphs.Count > 0:
            self.api_ref.Graphs.Delete(0)
        self.sync_with_gui()

    def add_result(self, result):
        """
        This is called from the child add_result

        :param result: result type as string, see child class definition for specific options.
        :type result: str
        """
        self.api_ref.Graphs.Add(result)
        self.sync_with_gui()

    def configure_results(self, results: List[Any] = None) -> Optional[List[str]]:
        """
        Deletes existing results and configures the specified results. See child class implementation docstring  for
        specific result options or call get_result_options()

        :param results: result name
        :type results: List[Any]
        :return: if nothing is configured it returns the current results
        :rtype: List[str]
        """
        if results is None:
            results = []
            for result in self.results.__dict__.values():
                if isinstance(result, Result) and result.is_derived() is False:
                    results.append(result.get_result_type())  # meas children will be xy or meter graph not result
            return results
        else:
            results = [check_enum_or_str(f'{result}', result, self._primary_result_enum) for result in results]
            self.delete_all_results()
            for result in results:
                self.add_result(result)
            self.sync_with_gui()

    def get_result_options(self) -> List[str]:
        """
        Returns a list of valid result options for the measurement

        :return: list of primary result options
        :rtype: List[str]
        """
        return [result.name for result in self._primary_result_enum]

    def get_configured_result_names(self) -> List[str]:
        """
        Retrieves the names of all result objects configured for this measurement

        :return: list of strings of result names
        :rtype: List[str]
        """
        results = []
        for result in self.results.__dict__.values():
            if isinstance(result, Result):
                results.append(result.result_name)
        return results

    def _query_current_results(self):
        """
        Reads all result names (modified) from the GUI
        """
        result_names = []
        for index in range(self.api_ref.Graphs.Count):

            result_name = self.api_ref.Graphs[index].Name
            result_name = re.sub("\(DCX\)", "dcx", result_name)  # keep dcx suffix if found in ()
            result_name = re.sub("[\(\[].*?[\)\]]", "", result_name)  # delete all other text in ()
            result_name = result_name.lower().strip(' ').replace(' ', '_').replace(',', '').replace('-', '').replace('>', '')
            result_names.append(result_name)
        return result_names

    def sync_with_gui(self):
        """
        Recreates the Results Container to match the results in GUI

        :return: None
        :rtype: None
        """
        self.results = ResultsContainer(self, self._query_current_results())
        self.update_pyi_file()

    def _update_pyi_section(self, old_contents):
        """
        Determines the text to be modified in the pyi file

        :param old_contents: string of file contents in pyi file
        :type old_contents: str
        :return: updated string of file contents
        :rtype: str
        """
        pyi_contents = []
        tab = '    '
        start_string = 'class %s\(%s\):\n' % (self.results.__class__.__name__, ResultsContainer.__name__)
        pyi_contents.extend([start_string.replace('\\', '')])
        num_results = 0
        for result in self.results.__dict__.values():
            if isinstance(result, Result):
                num_results += 1
                pyi_contents.extend([tab, result.result_name, ': ', result.__class__.__name__, '\n'])
        if num_results == 0:
            pyi_contents.extend([tab, 'pass', '\n'])
        pyi_contents.extend(([tab, "# END"]))
        new_section = ''.join(pyi_contents)
        new_contents = re.sub(f'{start_string}.*?# END', new_section, old_contents, 1, flags=re.DOTALL)
        return new_contents

    def update_pyi_file(self):
        """
        Rewrites te pyi file to update the section to match the gui
        """
        pyi_file = os.path.dirname(os.path.realpath(__file__)) + '\\result\\results_container\\results_container.pyi'
        old_contents = ''
        if os.path.exists(pyi_file):  # Read to check for differences
            with open(pyi_file, 'r') as f:
                old_contents = f.read()
        pyi_content = self._update_pyi_section(old_contents)
        if pyi_content != old_contents:  # Only overwrite if there's been changes to the pyi structure
            self._apx.log.debug(f"Updating stub file: {os.path.basename(pyi_file)}")
            with open(pyi_file, 'w') as f:
                f.write(pyi_content)
        else:
            self._apx.log.debug(f"Stub file for {self.meas_name} up to date")
