import os
from pathlib import Path
from typing import Any, Dict, Union, List, Optional

from cl_instr_lib.drivers.audio.apx.enums import InputConnectorTypes, AnalogInputTerminations, MasterClockSource, \
    ClockDirection, Decimation, ScaleInputFreqBy, SerialDataLine, SerialFormat, SerialChannels, SerialLogicLevel, \
    SerialCustomDataJustification, FrameClockPulseWidth, EdgeSync, PdmMeasure, AnalogInputRangeUnits, DataEdge
from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str, check_array, on_off
from cl_instr_lib.helpers.check_range import check_range, min_max_units


class Input:
    """Base class for APx input module."""

    def __init__(self, apx):
        self._api = apx.api
        self._apx = apx

    def connector(self, connector_type: Union[str, InputConnectorTypes] = None) -> str:
        """
        Set the input connector to one of the following configurations:

            * Analog Unbalanced
            * Analog Balanced
            * Analog Custom
            * Digital Unbalanced
            * Digital Balanced
            * Digital Optical
            * HDMI Sink
            * HDMI ARC Rx
            * Bluetooth
            * Digital Serial
            * PDM
            * ASIO
            * Transducer Interface
            * Microphone
            * Battery Voltage
            * battery Current
            * Speaker Voltage
            * Telecoil Current
            * Mic Bias Voltage
            * Analog File
            * Digital File

            Call method with no parameters to return the current connector settings.

        :param connector_type: Connector setting to set.
        :type type: str|InputConnectorTypes
        :return: Current connector type if method is called with no parameters, otherwise None
        :rtype: str|None
        """

        if connector_type is None:
            return InputConnectorTypes(self._api.BenchMode.Setup.InputConnector.Type).name

        connector_type = check_enum_or_str('connector_type', connector_type, InputConnectorTypes)
        self._api.BenchMode.Setup.InputConnector.Type = connector_type.value

    def loopback(self, state: Union[bool, int, str] = None) -> str:
        """
        Gets or sets whether or not the generator signal is automatically looped
        back to the input of the APx instrument.  This setting only applies in specific
        input and output configurations.

        :param state: Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type state: bool|int|str
        :return: None
        :rtype: None
        """
        if state is None:
            return on_off.to_api(self._api.BenchMode.Setup.Loopback)

        self._api.BenchMode.Setup.Loopback = on_off.to_inst(state)

    def configure_analog_balanced(self, channels: int = None, termination: Union[str, AnalogInputTerminations] = None,
                                    acoustic: Union[bool, int, str] = None, single_channel_selection: int = None,
                                    use_hp_sine_analyzer: Union[bool, int, str] = None,
                                    channel_labels: List[str] = None, *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for the analog balanced input. This function automatically changes the input
        connector to ANALOG_BALANCED.

        :param channels: Change the number of analog unbalanced channels. Accepts an integer
            between 1 and the maximum allowable channels.
        :type channels: int
        :param termination: Specifies the input termination impedance.
        :type termination: str | AnalogInputTerminations
        :param acoustic: Enable/disable acoustic setting for output connector. Accepts: 'ON', True, 1 or '1'. For OFF
            accepts: 'OFF', False, 0, or '0'.
        :type acoustic: bool|int|str
        :param use_hp_sine_analyzer: Gets or sets whether or not the high performance sine analyzer engages its notch
            filters to improve measurement performance. This setting only applies to instruments with the appropriate
            hardware modules. Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type use_hp_sine_analyzer: bool|int|str
        :param single_channel_selection: Gets or sets which input channel will be observed when ChannelCount is 1.
            Unused if more than one channel is configured. Channels range from 1 to the maximum analog input channel
            per device.
        :type single_channel_selection: int
        :param channel_labels: user customized input channel names for the specified connector. Must be a list of
            len(channels)
        :type channel_labels: List[str]
        :param args: None
        :type args: None
        :param kwargs: None
        :type kwargs: None
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        self._apx.log_unused_args(args, kwargs)

        if not all(v is None for v in
                   (channels, termination, acoustic, single_channel_selection, use_hp_sine_analyzer, channel_labels)):
            if self.connector() != InputConnectorTypes.ANALOG_BALANCED:
                self.connector(InputConnectorTypes.ANALOG_BALANCED)

        return self.__configure_analog(channels=channels, termination=termination, acoustic=acoustic,
                                       single_channel_selection=single_channel_selection,
                                       use_hp_sine_analyzer=use_hp_sine_analyzer,
                                       channel_labels=channel_labels, *args, **kwargs)

    def configure_analog_unbalanced(self, channels: int = None, termination: Union[str, AnalogInputTerminations] = None,
                                    acoustic: Union[bool, int, str] = None, single_channel_selection: int = None,
                                    use_hp_sine_analyzer: Union[bool, int, str] = None,
                                    channel_labels: List[str] = None, *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for the analog unbalanced input. This function automatically changes the input
        connector to ANALOG_UNBALANCED.

        :param channels: Change the number of analog unbalanced channels. Accepts an integer
            between 1 and the maximum allowable channels.
        :type channels: int
        :param termination: Specifies the input termination impedance.
        :type termination: str | AnalogInputTerminations
        :param acoustic: Enable/disable acoustic setting for output connector. Accepts: 'ON', True, 1 or '1'. For OFF
            accepts: 'OFF', False, 0, or '0'.
        :type acoustic: bool|int|str
        :param use_hp_sine_analyzer: Gets or sets whether or not the high performance sine analyzer engages its notch
            filters to improve measurement performance. This setting only applies to instruments with the appropriate
            hardware modules. Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type use_hp_sine_analyzer: bool|int|str
        :param single_channel_selection: Gets or sets which input channel will be observed when ChannelCount is 1.
            Unused if more than one channel is configured. Channels range from 1 to the maximum analog input channel
            per device.
        :type single_channel_selection: int
        :param channel_labels: user customized input channel names for the specified connector. Must be a list of
            len(channels)
        :type channel_labels: List[str]
        :param args: None
        :type args: None
        :param kwargs: None
        :type kwargs: None
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        if not all(v is None for v in
               (channels, termination, acoustic, single_channel_selection, use_hp_sine_analyzer, channel_labels)):
            if self.connector() != InputConnectorTypes.ANALOG_UNBALANCED:
                self.connector(InputConnectorTypes.ANALOG_UNBALANCED)

        return self.__configure_analog(channels=channels, termination=termination, acoustic=acoustic,
                                       use_hp_sine_analyzer=use_hp_sine_analyzer,
                                       single_channel_selection=single_channel_selection,
                                       channel_labels=channel_labels, *args, **kwargs)

    def __configure_analog(self, channels: int = None, termination: Union[str, AnalogInputTerminations] = None,
                           acoustic: Union[bool, int, str] = None, use_hp_sine_analyzer: Union[bool, int, str]
                           = None, single_channel_selection: int = None, channel_labels: List[str] = None,
                           *args, **kwargs) -> Dict[str, Any]:
        """
        Configures common analog input settings

        :param channels: Change the number of analog unbalanced channels. Accepts an integer
            between 1 and the maximum allowable channels.
        :type channels: int
        :param termination: Specifies the input termination impedance.
        :type termination: str | AnalogInputTerminations
        :param acoustic: Enable/disable acoustic setting for output connector. Accepts: 'ON', True, 1 or '1'. For OFF
            accepts: 'OFF', False, 0, or '0'.
        :type acoustic: bool|int|str
        :param use_hp_sine_analyzer: Gets or sets whether or not the high performance sine analyzer engages its notch
            filters to improve measurement performance. This setting only applies to instruments with the appropriate
            hardware modules. Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type use_hp_sine_analyzer: bool|int|str
        :param single_channel_selection: Gets or sets which input channel will be observed when ChannelCount is 1.
            Unused if more than one channel is configured. Channels range from 1 to the maximum analog input channel
            per device.
        :type single_channel_selection: int
        :param channel_labels: user customized input channel names for the specified connector. Must be a list of
            len(channels)
        :type channel_labels: List[str]
        :param args: None
        :type args: None
        :param kwargs: None
        :type kwargs: None
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        # APx.BenchMode.Setup.AnalogInput.ChannelCount
        # APx.BenchMode.Setup.AnalogInput.GetTermination(channel)/SetTermination(ch, val)
        # #Always tracks on both channels when not in custom analog mode.
        # Apx.BenchMode.Setup.AcousticInput
        # APx.BenchMode.Setup.AnalogInput.UseHighPerformanceSineAnalyzer
        # Apx.BenchMode.Setup.AnalogInput.SingleInputChannel
        # Apx.BenchMode.Setup.GetInputChannelName/SetInputChannelName

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (channels, termination, acoustic, use_hp_sine_analyzer, single_channel_selection,
                                   channel_labels)):
            return_values = {}
            return_values.update(channels=self.__get_analog_ch_count())

            return_values.update(acoustic=on_off.to_api(self._api.BenchMode.Setup.AcousticInput))
            return_values.update(use_hp_sine_analyzer=on_off.to_api(
                self._api.BenchMode.Setup.AnalogInput.UseHighPerformanceSineAnalyzer))
            if self._api.BenchMode.Setup.AnalogInput.ChannelCount == 1:
                single_ch = self._api.BenchMode.Setup.AnalogInput.SingleInputChannel
                return_values.update(single_channel_selection=single_ch + 1)
                return_values.update(termination=AnalogInputTerminations(
                    self._api.BenchMode.Setup.AnalogInput.GetTermination(single_ch)).name)
            else:
                return_values.update(termination=AnalogInputTerminations(
                    self._api.BenchMode.Setup.AnalogInput.GetTermination(0)).name)
            return_values.update(channel_labels=[self._api.BenchMode.Setup.GetInputChannelName(ch) for ch in
                                                 range(0,self.__get_analog_ch_count())])
            return return_values

        # Error Checking
        if channels is not None:
            if not 1 <= channels <= self._api.Version.MaxAnalogInputChannelCount:
                raise ValueError(f'Bad channels value: {channels}. Must be 1 < channels <= '
                                 f'{self._api.Version.MaxAnalogInputChannelCount}')

        if termination is not None:
            termination = check_enum_or_str('termination', termination, AnalogInputTerminations)
            if (self.connector() == InputConnectorTypes.ANALOG_UNBALANCED and
                termination == AnalogInputTerminations._BAL_200K_OHM)\
                    or (self.connector() == InputConnectorTypes.ANALOG_BALANCED and
                        termination == AnalogInputTerminations._UNBAL_100K_OHM):
                raise Exception(f'{termination} is not valid for {self.connector()}')
        if single_channel_selection is not None:
            if self._api.BenchMode.Setup.AnalogInput.ChannelCount != 1:
                raise ValueError(f'Unable to configure single_channel_selection while multiple channels are enabled.')
            if not 1 <= single_channel_selection <= self._api.Version.MaxAnalogInputChannelCount:
                raise ValueError(f'Bad single_channel_selection value: {channels}. Must be 1 < single_channel_selection'
                                 f' <= {self._api.Version.MaxAnalogInputChannelCount}')

        if channel_labels is not None:
            check_array('channel_labels', channel_labels, self.__get_analog_ch_count())
        acoustic = on_off.to_inst(acoustic)
        use_hp_sine_analyzer = on_off.to_inst(use_hp_sine_analyzer)

        curr_chs = channels
        if curr_chs is None:
            curr_chs = self.__get_analog_ch_count()
        curr_single_ch = single_channel_selection
        if curr_single_ch is None:
            curr_single_ch = self._api.BenchMode.Setup.AnalogInput.SingleInputChannel
        if curr_chs > 1:
            ch = 0

        else:
            ch = curr_single_ch

        # Write to Instrument
        if channels is not None:
            self._api.BenchMode.Setup.AnalogInput.ChannelCount = channels
        if termination is not None:
            self._api.BenchMode.Setup.AnalogInput.SetTermination(ch, termination.value)
        if acoustic is not None:
            self._api.BenchMode.Setup.AcousticInput = acoustic
        if use_hp_sine_analyzer is not None:
            self._api.BenchMode.Setup.AnalogInput.UseHighPerformanceSineAnalyzer = use_hp_sine_analyzer
        if single_channel_selection is not None:
            self._api.BenchMode.Setup.AnalogInput.SingleInputChannel = single_channel_selection - 1
        if channel_labels is not None:
            for ch in range(0,self.__get_analog_ch_count()):
                self._api.BenchMode.Setup.SetInputChannelName(ch, channel_labels[ch])

    def configure_analog_input_range(self, auto_range: Union[bool, int, str] = None, range_track_ch1:
                                     Union[bool, int, str] = None, input_range_units: Union[str, AnalogInputRangeUnits]
                                     = None, input_ranges: Union[float, List[float]] = None, *args, **kwargs) \
            -> Dict[str, Any]:
        """
        
        Configure analog input ranges for balanced or unbalanced input. All active channels must be specified in List if
        designating input_ranges while range_track_ch1 is disabled.
        
        :param auto_range: Gets or set whether the analog input uses auto ranging. Accepts: 'ON', True, 1 or '1'.
            For OFF accepts: 'OFF', False, 0, or '0'
        :type auto_range: str|bool|int
        :param range_track_ch1: Gets or sets whether all channels have the same value.  If true,
            all channels have the same value as the first channel. Accepts: 'ON', True, 1 or '1'.
            For OFF accepts: 'OFF', False, 0, or '0'
        :type range_track_ch1: str|bool|int
        :param input_range_units: 'VRMS', 'DBV', 'DBU', 'DBRA', 'DBRB', 'DBSPL1', 'DBSPL2', 'DBM', 'W'
        :type input_range_units: str | AnalogInputRangeUnits
        :param input_ranges: Sets the input range to the specified value in the current input range unit.
            If range_track_ch1 is enabled, a float can be specified, otherwise a list of length(channels) is required.
        :type input_ranges: float|List[float]
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        # APx.BenchMode.AnalogInputRanges.AutoRange
        # Apx.BenchMode.AnalogInputRanges.Unit
        # Apx.BenchMode.AnalogInputRanges.TrackFirstChannel
        # Apx.BenchMode.AnalogInputRanges.SetValue

        self._apx.log_unused_args(args, kwargs)

        #Readback
        if all(v is None for v in (auto_range, range_track_ch1, input_range_units, input_ranges)):
            return_values = {}
            return_values.update(auto_range=on_off.to_api(self._api.BenchMode.AnalogInputRanges.AutoRange))
            return_values.update(range_track_ch1=on_off.to_api(
                self._api.BenchMode.AnalogInputRanges.TrackFirstChannel))
            return_values.update(input_range_units=AnalogInputRangeUnits(
                self._api.BenchMode.AnalogInputRanges.Unit).name)
            return_values.update(input_ranges=[self._api.BenchMode.AnalogInputRanges.GetValue(ch) for ch in
                                               range(0,self.__get_analog_ch_count())])
            return return_values

        #Error Checking
        input_range_units = check_enum_or_str('input_range_units', input_range_units, AnalogInputRangeUnits)
        if auto_range is not None:
            set_auto_range = True
            auto_range = on_off.to_inst(auto_range)
        else:
            set_auto_range = False
            auto_range = self._api.BenchMode.AnalogInputRanges.AutoRange
        if range_track_ch1 is not None:
            set_range_track_ch1 = True
            range_track_ch1 = on_off.to_inst(range_track_ch1)
        else:
            set_range_track_ch1 = False
            range_track_ch1 = self._api.BenchMode.AnalogInputRanges.TrackFirstChannel
        if input_ranges is not None and not auto_range:
            #Needs to be after checking new or existing values of auto_range and range_track_ch1
            if range_track_ch1:
                if isinstance(input_ranges, List) and (len(set(input_ranges)) != 1):
                    raise ValueError(f'Input ranges are configured to track ch1 settings. '
                                     f'All channels will be set to {input_ranges[0]}. '
                                     f'Disable range_track_ch1 to set different input ranges per channel.')
                channel_end = 1
                if not isinstance(input_ranges, List):
                    input_ranges = [input_ranges]
            else:
                channel_end = self.__get_analog_ch_count()
                if not isinstance(input_ranges, List):
                    raise ValueError(f'Input ranges must be a list if range_track_ch1 is disabled.')
                else:
                    check_array('input_ranges', input_ranges, self.__get_analog_ch_count())
        elif input_ranges is not None and auto_range:
            self._apx.log.warning(f'Specified ranges will not be configured when auto range is enabled.')

        #Write to Instrument
        if set_auto_range:
            self._api.BenchMode.AnalogInputRanges.AutoRange = auto_range
        if set_range_track_ch1:
            self._api.BenchMode.AnalogInputRanges.TrackFirstChannel = range_track_ch1
        if input_range_units is not None:
            self._api.BenchMode.AnalogInputRanges.Unit = input_range_units.value
        if input_ranges is not None and not auto_range:
            for ch in range(0, channel_end):
                self._api.BenchMode.AnalogInputRanges.SetValue(ch, input_ranges[ch])
                readback = self._api.BenchMode.AnalogInputRanges.GetValue(ch)
                if readback != input_ranges[ch]:
                    self._apx.log.warning(f'Input range for ch{ch + 1} was coerced to {readback}')

    def __get_analog_ch_count(self):
        return self._api.BenchMode.Setup.AnalogInput.ChannelCount

    def configure_dsi_audio_settings(self, use_single_data_line: Union[bool, int, str] = None,
                                     selected_single_data_line:
        Union[SerialDataLine, str, int] = None, channels: Union[SerialChannels, str, int] = None,
        format: Union[SerialFormat, str] = None, msb_first: Union[bool, int, str] = None, word_width: int = None,
        bit_depth: int = None, justification: Union[SerialCustomDataJustification, str] = None, frame_clock_pulse_width:
        Union[str,FrameClockPulseWidth] = None, frame_clk_invert: Union[bool, int, str] = None, frame_clk_shift_left:
        Union[bool, int, str] = None, *args, **kwargs) -> Dict[str, Any]:
        """
        This function configures the input connector to Digital Serial Reciever and allows configuring all associated 
        audio settings. If no parameters are passed in it will return the current configuration settings from the 
        instrument.
        
        :param use_single_data_line: Gets or sets whether the input channels are to be received on a single data line 
            using Time Division Multiplexing (TDM), or whether the channels are to be received in stereo pairs
            on each data line. True if single_data_line(tdm), false if multiple data lines. 
            Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0' 
        :type use_single_data_line: str|bool|int
        :param selected_single_data_line: Gets or sets which data line contains the data when the SingleDataLine 
            property is True. Options include ONE, TWO, THREE or FOUR, or 1, 2, 3, 4. 
        :type selected_single_data_line: str|int|SerialDataLine 
        :param channels: Gets or sets the number of channels to receive. 'ONE', 'TWO', 'FOUR', 'SIX', 'EIGHT', 'SIXTEEN'
            , or 1, 2, 4, 6, 8, 16
        :type channels: str|int|SerialChannels
        :param format: Gets or sets the expected format and justification of the incoming bitstream.
            I2S, DSP', 'CUSTOM'    
        :type format: SerialFormat|str
        :param msb_first: Gets or sets whether the MSB or LSB is first in the data. Accepts: 'ON', True, 1 or '1'. 
            For OFF accepts: 'OFF', False, 0, or '0' 
        :type msb_first: str|bool|int
        :param word_width: Gets or sets the size of the input word.
        :type word_width: int
        :param bit_depth: Gets or sets the digital input bit depth.
        :type bit_depth: int
        :param justification: Gets or sets how the data is justified relative to the frame clock.  
            This property supercedes the SerialFormat.LeftJustified and SerialFormat.RightJustified values
            previously used in the Format property. This setting only applies when the Format property is Custom.
            'LEFT_JUSTIFIED' or 'RIGHT_JUSTIFIED'
        :type justification: str|SerialCustomDataJustification
        :param frame_clock_pulse_width: Gets or sets the width of the frame clock pulse. This setting only applies when 
            the Format property is Custom. Options are 'ONE_BIT_CLOCK', ONE_SUBFRAME', or 'FIFTY_PERCENT_DUTY_CYCLE'
        :type frame_clock_pulse_width: str|FrameClockPulseWidth
        :param frame_clk_invert: Gets or sets whether the frame clock is inverted. This setting only applies when 
            the Format property is Custom. Accepts: 'ON', True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'
        :type frame_clk_invert: str|int|bool
        :param frame_clk_shift_left: When true then the frame clock is advanced by one bit clock.
            This setting only applies when the Format property is Custom. Accepts: 'ON', True, 1 or '1'. 
            For OFF accepts: 'OFF', False, 0, or '0'
        :type frame_clk_shift_left: str|int|bool
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (use_single_data_line, selected_single_data_line, channels, format, msb_first,
                                   word_width, bit_depth, justification, frame_clock_pulse_width, frame_clk_invert,
                                   frame_clk_shift_left)):
            return_values = {}
            data_line_is_single = self._api.BenchMode.Setup.SerialDigitalReceiver.SingleDataLine
            return_values.update(use_single_data_line=on_off.to_api(data_line_is_single))
            if data_line_is_single:
                return_values.update(selected_single_data_line=SerialDataLine(
                    self._api.BenchMode.Setup.SerialDigitalReceiver.SelectedDataLine + 1).value)
            return_values.update(channels=SerialChannels(self._api.BenchMode.Setup.SerialDigitalReceiver.Channels)
                                 .value)
            return_values.update(format=SerialFormat(self._api.BenchMode.Setup.SerialDigitalReceiver.Format).name)
            return_values.update(msb_first=on_off.to_api(self._api.BenchMode.Setup.SerialDigitalReceiver.MsbFirst))
            return_values.update(word_width=self._api.BenchMode.Setup.SerialDigitalReceiver.WordWidth)
            return_values.update(bit_depth=self._api.BenchMode.Setup.SerialDigitalReceiver.BitDepth)
            if SerialFormat(self._api.BenchMode.Setup.SerialDigitalReceiver.Format) == SerialFormat.CUSTOM:
                return_values.update(justification=SerialCustomDataJustification(
                    self._api.BenchMode.Setup.SerialDigitalReceiver.DataJustification).name)
            return_values.update(frame_clock_pulse_width=FrameClockPulseWidth(
                self._api.BenchMode.Setup.SerialDigitalReceiver.FrameClockPulseWidth).name)
            return_values.update(frame_clk_invert=on_off.to_api(
                self._api.BenchMode.Setup.SerialDigitalReceiver.FrameClockInvert))
            return_values.update(frame_clk_shift_left=on_off.to_api(
                self._api.BenchMode.Setup.SerialDigitalReceiver.FrameClockLeftOneBit))
            return return_values
        else:
            if self.connector() != InputConnectorTypes.DIGITAL_SERIAL:
                self.connector(InputConnectorTypes.DIGITAL_SERIAL)

        # Error checking
        use_single_data_line = on_off.to_inst(use_single_data_line)
        single_line = use_single_data_line
        if single_line is None:
            single_line = on_off.to_inst(self._api.BenchMode.Setup.SerialDigitalReceiver.SingleDataLine)
        if not single_line and selected_single_data_line is not None:
            raise ValueError(f'selected_single_data_line can not be configured when use_single_data_line is disabled.')
        selected_single_data_line = check_enum_or_str('selected_single_data_line', selected_single_data_line,
                                                      SerialDataLine)
        channels = check_enum_or_str('channels', channels, SerialChannels)
        format = check_enum_or_str('format', format, SerialFormat)
        msb_first = on_off.to_inst(msb_first)
        if word_width is not None:
            if word_width > 128:
                raise ValueError(f'Bad word_width value: {word_width}. Needs to be less than 128.')
        check_range('bit_depth', bit_depth, min_max_units(8, 32, 'bits'))
        justification = check_enum_or_str('justification', justification, SerialCustomDataJustification)
        frame_clock_pulse_width = check_enum_or_str('frame_clock_pulse_width', frame_clock_pulse_width,
                                                    FrameClockPulseWidth)
        frame_clk_invert = on_off.to_inst(frame_clk_invert)
        frame_clk_shift_left = on_off.to_inst(frame_clk_shift_left)
        param_name = None

        # Write to Instrument
        if use_single_data_line is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.SingleDataLine = use_single_data_line
        if selected_single_data_line is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.SelectedDataLine = selected_single_data_line.value - 1
        if channels is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.Channels = channels.value
        if format is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.Format = format.value
        if msb_first is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.MsbFirst = msb_first
        if bit_depth is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.BitDepth = bit_depth
        if word_width is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.WordWidth = word_width
        if justification is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.DataJustification = justification.value
        if frame_clock_pulse_width is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.FrameClockPulseWidth = frame_clock_pulse_width.value
        if frame_clk_invert is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.FrameClockInvert = frame_clk_invert
        if frame_clk_shift_left is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.FrameClockLeftOneBit = frame_clk_shift_left

    def configure_dsi_clocks(self, master_clock_source: Union[str, MasterClockSource] = None,
                             master_clock_rate: Union[int, float] = None, mclk_out_en: Union[bool, int, str] = None,
                             mclk_invert:  Union[bool, int, str] = None, bit_frame_clk_dir: Union[str, ClockDirection]
                             = None, frame_clk_rate_hz: Union[int, float] = None, mclk_ratio: int = None,
                             logic_level: Union[str, SerialLogicLevel] = None, bit_clk_out_edge: Union[str, EdgeSync] =
                             None, bit_clk_in_edge: Union[str, EdgeSync] = None) -> Optional[Dict[str, Any]]:
        """
        Configures the clocking settings for the digital serial receiver.This function will update the connector type
        to digital serial if not already set.

        :param master_clock_source: Gets or sets whether the master clock is generated by APx or by the DUT.
            On the Digital Serial Receiver, the master clock can either be generated by APx or by the DUT.
            On the Digital Serial Transmitter, the master clock is always generated by APx. Options: 'INTERNAL',
            'EXTERNAL'
        :type master_clock_source: str|MasterClockSource
        :param master_clock_rate: Sets the master clock rate in terms of the currently configured units.
            APx default is Hz. This rate can only be configured when using an internal master clock source and a bit
            clock direction of IN. This code will error if trying to set the rate when not in this configuration.
        :type master_clock_rate: int|float
        :param mclk_out_en: Gets or sets whether or not the master clock is generated/output by APx. This parameter is
            only valid when the master_clock_source is INTERNAL and bit_frame_clk_dir is OUT. Accepts: 'ON',
            True, 1 or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type mclk_out_en: bool, int, str
        :param mclk_invert: Gets or sets whether the master clock is inverted. This parameter is
            only valid when the master_clock_source is INTERNAL and bit_frame_clk_dir is OUT. Accepts: 'ON', True, 1 or
            '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type mclk_invert: bool, int, str
        :param bit_frame_clk_dir: Gets or sets the direction of the bit clock. Options: 'IN', 'OUT'
        :type bit_frame_clk_dir: str|ClockDirection
        :param frame_clk_rate_hz: Gets the setting for the output sample rate. This setting is only valid when the
            master clock is configured as internal and bit & frame clock direction is configured as an output.
        :type frame_clk_rate_hz: int|float
        :param mclk_ratio: Gets or sets the master clock rate multiplier. Parameter can only be changed if
            bit_frame_clk_dir is OUT.
        :type mclk_ratio: int
        :param logic_level: output voltage level for the Digital Serial Receiver. Options: 'V1P8', 'V2P5', 'V3P3'
        :type logic_level: str|SerialLogicLevel
        :param bit_clk_out_edge: Whether the leading edge of the frame (and data) are synchronized with the rising edge
            or the falling edge of the bit clock. Only available when bit_frame_clk_dir is OUT.
            Options: 'RISING_EDGE', 'FALLING_EDGE'.
        :type bit_clk_out_edge: str|EdgeSync
        :param bit_clk_in_edge: Gets or sets whether the leading edge of the frame (and data) are synchronized with the
            rising edge or the falling edge of the bit clock. Options: 'RISING_EDGE', 'FALLING_EDGE'.
        :type bit_clk_in_edge: str|EdgeSync
        :return: If no parameters are passed in, this function returns a dictionary of all currrently configured
            parameters.
        :rtype: dict
        """

        # APx.BenchMode.Setup.SerialDigitalReceiver.MasterClockSource
        # APx.BenchMode.Setup.SerialDigitalReceiver.MasterClockRate
        # APx.BenchMode.Setup.SerialDigitalReceiver.MasterClockOff
        # APx.BenchMode.Setup.SerialDigitalReceiver.InvertMasterClock
        # APx.BenchMode.Setup.SerialDigitalReceiver.BitFrameClockDirection
        # APx.BenchMode.Setup.SerialDigitalReceiver.MasterClockMultiplier
        # APx.BenchMode.Setup.SerialDigitalReceiver.LogicLevel
        # APx.BenchMode.Setup.SerialDigitalReceiver.BitClkSendEdgeSync
        # APx.BenchMode.Setup.SerialDigitalReceiver.BitClkReceiveEdgeSync

        # Readback
        if all(v is None for v in (master_clock_source, master_clock_rate, mclk_out_en, mclk_invert, bit_frame_clk_dir,
                                   frame_clk_rate_hz, mclk_ratio, logic_level, bit_clk_out_edge, bit_clk_in_edge)):
            return_values = {}
            master_clock_source = MasterClockSource(
                self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockSource).name
            bit_frame_clk_dir = ClockDirection(
                self._api.BenchMode.Setup.SerialDigitalReceiver.BitFrameClockDirection).name
            logic_level=SerialLogicLevel(self._api.BenchMode.Setup.SerialDigitalReceiver.LogicLevel).name
            if master_clock_source == 'INTERNAL':
                mclk_out_en=on_off.to_api(not(self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockOff))
                if bit_frame_clk_dir == 'OUT':
                    master_clock_rate=self._api.BenchMode.Setup.SerialDigitalReceiver.SampleRate.Value * \
                                      self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockMultiplier
                    mclk_invert=on_off.to_api(self._api.BenchMode.Setup.SerialDigitalReceiver.InvertMasterClock)
                    frame_clk_rate_hz=self._api.BenchMode.Setup.SerialDigitalReceiver.SampleRate.Value
                else:
                    master_clock_rate=self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockRate.Value
            if bit_frame_clk_dir == 'OUT':
                mclk_ratio=self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockMultiplier
                bit_clk_out_edge=EdgeSync(self._api.BenchMode.Setup.SerialDigitalReceiver.BitClkSendEdgeSync).name
            bit_clk_in_edge=EdgeSync(self._api.BenchMode.Setup.SerialDigitalReceiver.BitClkReceiveEdgeSync).name
            return_values.update(master_clock_source=master_clock_source)
            if master_clock_rate is not None:
                return_values.update(master_clock_rate=master_clock_rate)
            if mclk_out_en is not None:
                return_values.update(mclk_out_en=mclk_out_en)
            if mclk_invert is not None:
                return_values.update(mclk_invert=mclk_invert)
            return_values.update(bit_frame_clk_dir=bit_frame_clk_dir)
            if frame_clk_rate_hz is not None:
                return_values.update(frame_clk_rate_hz=frame_clk_rate_hz)
            if mclk_ratio is not None:
                return_values.update(mclk_ratio=mclk_ratio)
            return_values.update(logic_level=logic_level)
            if bit_clk_out_edge is not None:
                return_values.update(bit_clk_out_edge=bit_clk_out_edge)
            return_values.update(bit_clk_in_edge=bit_clk_in_edge)
            return return_values
        else:
            if self.connector() != InputConnectorTypes.DIGITAL_SERIAL:
                self.connector(InputConnectorTypes.DIGITAL_SERIAL)

        # Error Checking
        master_clock_source = check_enum_or_str('master_clock_source', master_clock_source, MasterClockSource)
        curr_master_clock_source = master_clock_source
        if curr_master_clock_source is None:
            curr_master_clock_source = MasterClockSource(
                self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockSource)
        bit_frame_clk_dir = check_enum_or_str('bit_frame_clk_dr', bit_frame_clk_dir, ClockDirection)
        curr_bit_frame_clk_dir = bit_frame_clk_dir
        if curr_bit_frame_clk_dir is None:
            curr_bit_frame_clk_dir = ClockDirection(
                self._api.BenchMode.Setup.SerialDigitalReceiver.BitFrameClockDirection)

        if master_clock_rate is not None:
            if curr_master_clock_source != MasterClockSource.INTERNAL:
                raise ValueError(f'Cannot set master_clock_rate when the master_clock_source is not INTERNAL.')
            if curr_bit_frame_clk_dir != ClockDirection.IN:
                SampleRate = self._api.BenchMode.Setup.SerialDigitalReceiver.SampleRate
                MasterClockMultiplier = self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockMultiplier
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to IN, master_clock_rate is'
                                 f' set to Frame Clk Rate * MClk/FClk Ratio: {SampleRate * MasterClockMultiplier} '
                                 f'Set bit_frame_clk_dir to IN to change master_clock_rate.')

        if mclk_out_en is not None:
            mclk_out_en = not (on_off.to_inst(mclk_out_en))
            if curr_master_clock_source != MasterClockSource.INTERNAL:
                raise ValueError(f'Cannot set mclk_out_en when the master_clock_source is not INTERNAL.')
            if curr_bit_frame_clk_dir != ClockDirection.OUT:
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to OUT, mclk_out_en is '
                                 f'fixed to the ON state. Set bit_frame_clk_dir to OUT to change master_clock_rate.')

        mclk_invert = on_off.to_inst(mclk_invert)
        if mclk_invert is not None:
            if curr_master_clock_source != MasterClockSource.INTERNAL:
                raise ValueError(f'Cannot set mclk_invert when the master_clock_source is not INTERNAL.')
            if curr_bit_frame_clk_dir != ClockDirection.OUT:
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to OUT, mclk_invert is '
                                 f'unavailable. Set bit_frame_clk_dir to OUT to change mclk_invert parameter.')

        if frame_clk_rate_hz is not None:
            if curr_master_clock_source != MasterClockSource.INTERNAL:
                raise ValueError(f'Cannot set master_clock_rate when the master_clock_source is not INTERNAL.')
            if curr_bit_frame_clk_dir != ClockDirection.OUT:
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to IN, frame_clk_rate_hz is'
                                 f' unavailable. Set bit_frame_clk_dir to OUT to change frame_clk_rate_hz.')

        if mclk_ratio is not None:
            if curr_bit_frame_clk_dir != ClockDirection.OUT:
                raise ValueError(f'When the Bit & Frame Dir (bit_frame_clk_dir) is not set to IN, mclk_ratio is'
                                 f' unavailable. Set bit_frame_clk_dir to OUT to change mclk_ratio.')
            check_range('mclk_ratio', mclk_ratio, min_max_units(1, 14000, ''))

        logic_level = check_enum_or_str('logic_level', logic_level, SerialLogicLevel)

        bit_clk_out_edge = check_enum_or_str('bit_clk_out_edge', bit_clk_out_edge, EdgeSync)
        if bit_clk_out_edge is not None:
            if curr_bit_frame_clk_dir != ClockDirection.OUT:
                raise ValueError('bit_clk_out_edge fixed to "RISING_EDGE" when bit_frame_clk_dir is "IN". Change '
                                 'bit_frame_clk_dir to "OUT" to change bit_clk_out_edge')

        bit_clk_in_edge = check_enum_or_str('bit_clk_in_edge', bit_clk_in_edge, EdgeSync)

        # Write to Instrument
        if master_clock_source is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockSource = master_clock_source.value
        if bit_frame_clk_dir is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.BitFrameClockDirection = bit_frame_clk_dir.value
        if master_clock_rate is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockRate.Value = master_clock_rate
        if mclk_out_en is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockOff = mclk_out_en
        if mclk_invert is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.InvertMasterClock = mclk_invert
        if frame_clk_rate_hz is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.SampleRate.Value = frame_clk_rate_hz
        if mclk_ratio is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockMultiplier = mclk_ratio
        if logic_level is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.LogicLevel = logic_level.value
        if bit_clk_out_edge is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.BitClkSendEdgeSync = bit_clk_out_edge.value
        if bit_clk_in_edge is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.BitClkReceiveEdgeSync = bit_clk_in_edge.value

    def configure_dsi(self, open_config_file: Union[str, Path] = None, scale_freq_by: Union[str, ScaleInputFreqBy]
                      = None, fixed_rate_freq: Union[int, float] = None, outputs_en: Union[str, int, bool] = None) -> \
            Optional[Dict[str, Any]]:
        """
        This function configures the input connector to Digital Serial Receiver and allows configuring all associated
        miscellaneous settings (not specific to audio or clock). If no parameters are passed in it will return the
        current configuration settings from the instrument.

        :param open_config_file: Open a saved configuration for Digital Serial Receiver config. Insert the file path
            with file name to apply the saved config. Parameter has no readback option.
        :type open_config_file: str|Path
        :param scale_freq_by: Set how the input sample rate is determined. Accepts the following inputs:

            * INPUT_SR
            * OUTPUT_SR - Only if output connector is digital
            * FIXED_RATE


        :type scale_freq_by: str | ScaleInputFreqBy
        :param fixed_rate_freq: When scale_freq_by is set to FIXED_RATE, use this parameter to set what frequency the
            fixed rate should be set to. Hz is the only unit available.
        :type fixed_rate_freq: int | float
        :param outputs_en: Sets whether the Digital Serial Receiver module is generating any voltage.
        :type outputs_en: bool | str | int
        :return: dictionary of all parameters read from the instrument.
        :rtype: Dict[str, Any]
        """

        # APx.BenchMode.Setup.SerialDigitalReceiver.Open(fileName)
        # APx.BenchMode.Setup.SerialDigitalReceiver.ScaleFreqBy
        # APx.BenchMode.Setup.SerialDigitalReceiver.FixedInputSampleRate
        # APx.BenchMode.Setup.SerialDigitalReceiver.EnableOutputs

        # Readback
        if all(v is None for v in (open_config_file, scale_freq_by, fixed_rate_freq, outputs_en)):
            return_values = {}
            return_values.update(scale_freq_by=ScaleInputFreqBy(
                self._api.BenchMode.Setup.SerialDigitalReceiver.ScaleFreqBy).name)
            return_values.update(fixed_rate_freq=self._api.BenchMode.Setup.SerialDigitalReceiver.FixedInputSampleRate)
            return_values.update(outputs_en=on_off.to_api(self._api.BenchMode.Setup.SerialDigitalReceiver.EnableOutputs))
            return return_values
        else:
            if self.connector() != InputConnectorTypes.DIGITAL_SERIAL:
                self.connector(InputConnectorTypes.DIGITAL_SERIAL)

        # Error Checking
        if open_config_file is not None:
            if isinstance(open_config_file, Path):
                open_config_file = os.path.abspath(open_config_file)  # convert to string.
            if isinstance(open_config_file, str):
                if not os.path.isfile(open_config_file):
                    raise ValueError(f'Bad config_file_path: {open_config_file}. Not a valid filepath or filename.')
                if not open_config_file.endswith('.srx'):
                    raise ValueError(f'Bad config_file_path: {open_config_file}. File type needs to be .srx')
            else:
                raise ValueError(f'Bad config_file_path: {open_config_file}. Needs to be of type str or Path. '
                                 f'Current type is {type(open_config_file)}')

        scale_freq_by = check_enum_or_str('scale_freq_by', scale_freq_by, ScaleInputFreqBy)
        if scale_freq_by is not None:
            if scale_freq_by == ScaleInputFreqBy.OUTPUT_SR:
                if self.IsOutputAnalog:
                    raise ValueError('scale_freq_by can only be set to OUTPUT_SR if the output connector is Digital, '
                                     'not Analog')

        if fixed_rate_freq is not None:
            curr_scale_freq_by = ScaleInputFreqBy(self._api.BenchMode.Setup.SerialDigitalReceiver.ScaleFreqBy).name
            if scale_freq_by is not None:
                curr_scale_freq_by = scale_freq_by
            if curr_scale_freq_by != 'FIXED_RATE':
                raise ValueError(f'scale_freq_by parameter must be set to "FIXED_RATE" in order to set the Fixed Rate '
                                 f'frequency. Currently set to {curr_scale_freq_by}')
            check_range('fixed_rate_freq', fixed_rate_freq, min_max_units(4e3, 432e3, 'Hz'))

        outputs_en = on_off.to_inst(outputs_en)
        if outputs_en is not None:
            if self._api.BenchMode.Setup.SerialDigitalReceiver.MasterClockSource == 1:
                curr_bit_frame_clock_dir = self._api.BenchMode.Setup.SerialDigitalReceiver.BitFrameClockDirection
                if curr_bit_frame_clock_dir != 1:
                    raise ValueError('Bit & Frame Direction must be configured "OUT" to enabled outputs.')

        # Write to Instrument
        if open_config_file is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.Open(open_config_file)
        if scale_freq_by is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.ScaleFreqBy = scale_freq_by.value
        if fixed_rate_freq is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.FixedInputSampleRate = fixed_rate_freq
        if outputs_en is not None:
            self._api.BenchMode.Setup.SerialDigitalReceiver.EnableOutputs = outputs_en

    def configure_pdm(self, bit_clk_dir: Union[str, ClockDirection] = None, decimation: Union[str, Decimation] = None,
                      decimation_rate: Union[int, float] = None, data_edge: Union[str, DataEdge] = None,
                      logic_level: Union[int, float] = None, vdd_level: Union[int, float] = None,
                      limit_logic_level: Union[bool, int, str] = None, output_state_vdd: Union[bool, int, str] = None,
                      output_state_rec_outputs: Union[bool, int, str] = None, measure: Union[str, PdmMeasure] = None,
                      scale_freq_by: Union[str, ScaleInputFreqBy] = None, fixed_rate_freq: Union[int, float] = None,
                      *args, **kwargs) -> Dict[str, Any]:
        """
        Configure settings for the input PDM connector.

        :param bit_clk_dir: Sets the direction of the bit clock. Options include: IN, OUT
        :type bit_clk_dir: str|ClockDirection Enum
        :param decimation: Sets the decimation value for computing the decimated sample rate. Options include:

            * X1
            * X3P125
            * X4
            * X6P25
            * X8
            * X8P33
            * X10P67
            * X12P5
            * X15P625
            * X16
            * X16P67
            * X18P75
            * X21P33
            * X24
            * X25
            * X3125
            * X32
            * X33P33
            * X37P5
            * X42P67
            * X46P875
            * X48
            * X50
            * X62P5
            * X64
            * X66P67
            * X75
            * X85P33
            * X96
            * X100
            * X125
            * X128
            * X150
            * X192
            * X200
            * X250
            * X256
            * X300
            * X384
            * X400
            * X500
            * X512
            * X600
            * X768
            * X800

        :type decimation: st|Decimation Enum
        :param decimation_rate: Set the decimated sample rate. Can only be set if bit_clk_dir is "OUT".
        :type decimation_rate: int|float
        :param data_edge: Set which edge or edges the data is sampled on. Options include: RISING_EDGE, FALLING_EDGE
        :type data_edge: str|DataEdge Enum
        :param logic_level: Sets the DC logic level provided at the PDM input connector.
        :type logic_level: int|float
        :param vdd_level: Sets the DC voltage level provided at the Vdd connector on the PDM module front panel.
        :type vdd_level: int|float
        :param limit_logic_level: Sets whether or not the Vdd level will limit the Logic level. Accepts: 'ON', True, 1
            or '1'. For OFF accepts: 'OFF', False, 0, or '0'.
        :type limit_logic_level: bool|int|str
        :param output_state_vdd: Sets whether or not the Vdd supply voltage is turned ON. Accepts: 'ON', True, 1 or '1'.
            For OFF accepts: 'OFF', False, 0, or '0'.
        :type output_state_vdd: bool|int|str
        :param output_state_rec_outputs: Turn ON or OFF the receiver outputs.
        :type output_state_rec_outputs: bool|int|str
        :param measure: Set type of input signal, AUDIO, JITTER_UI, or JITTER_SEC.
            Note: This is only valid when the APx instrument is capable of measuring Jitter. Options include: AUDIO,
            JITTER_UI, JITTER_SEC
        :type measure: str|PdmMeasure Enum
        :param scale_freq_by: Sets how the input sample rate is determined. The user can provide a fixed input rate
            value in cases where the device under test has high amounts of clock jitter. Options include: INPUT_SR,
            OUTPUT_SR, FIXED_RATE
        :type scale_freq_by: str|ScaleInputFreqBy Enum
        :param fixed_rate_freq:
        :type fixed_rate_freq:
        :return:
        :rtype:
        """

        # APx.BenchMode.Setup.PdmInput.BitClkDir
        # APx.BenchMode.Setup.PdmInput.Decimation
        # APx.BenchMode.Setup.PdmInput.DecimatedRate
        # APx.BenchMode.Setup.PdmInput.BitClockRate
        # APx.BenchMode.Setup.PdmInput.DataEdge
        # APx.BenchMode.Setup.PdmInput.LogicLevel
        # APx.BenchMode.Setup.PdmInput.VddLevel
        # APx.BenchMode.Setup.PdmInput.LimitLogicLevel
        # APx.BenchMode.Setup.PdmInput.VddOn
        # APx.BenchMode.Setup.PdmInput.EnableOutputs
        # APx.BenchMode.Setup.PdmInput.MeasureInputSignalType
        # APx.BenchMode.Setup.PdmInput.ScaleFreqBy
        # APx.BenchMode.Setup.PdmInput.FixedInputSampleRate

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (bit_clk_dir, decimation, decimation_rate, data_edge, logic_level, vdd_level,
                                   limit_logic_level, output_state_vdd, output_state_rec_outputs, measure,
                                   scale_freq_by, fixed_rate_freq)):
            return_values = {}
            curr_bit_clk_dir = ClockDirection(self._api.BenchMode.Setup.PdmInput.BitClkDir).name
            return_values.update(bit_clk_dir=curr_bit_clk_dir)
            return_values.update(decimation=Decimation(self._api.BenchMode.Setup.PdmInput.Decimation).name)
            if curr_bit_clk_dir == ClockDirection.OUT.name:
                return_values.update(decimation_rate=self._api.BenchMode.Setup.PdmInput.DecimatedRate.Value)
                return_values.update(bit_clk_rate=self._api.BenchMode.Setup.PdmInput.BitClockRate)
            return_values.update(data_edge=DataEdge(self._api.BenchMode.Setup.PdmInput.DataEdge).name)
            return_values.update(logic_level=self._api.BenchMode.Setup.PdmInput.LogicLevel.Value)
            return_values.update(vdd_level=self._api.BenchMode.Setup.PdmInput.VddLevel.Value)
            return_values.update(limit_logic_level=on_off.to_api(
                self._api.BenchMode.Setup.PdmInput.LimitLogicLevel))
            return_values.update(output_state_vdd=on_off.to_api(self._api.BenchMode.Setup.PdmInput.VddOn))
            if curr_bit_clk_dir == ClockDirection.OUT.name:
                return_values.update(output_state_rec_outputs=on_off.to_api(
                    self._api.BenchMode.Setup.PdmInput.EnableOutputs))
            else:
                return_values.update(measure=PdmMeasure(self._api.BenchMode.Setup.PdmInput.MeasureInputSignalType).name)
            curr_scale_freq_by = ScaleInputFreqBy(self._api.BenchMode.Setup.PdmInput.ScaleFreqBy).name
            return_values.update(scale_freq_by=curr_scale_freq_by)
            if curr_scale_freq_by == ScaleInputFreqBy.FIXED_RATE.name:
                return_values.update(fixed_rate_freq=self._api.BenchMode.Setup.PdmInput.FixedInputSampleRate)
            return return_values
        else:
            if self.connector() != InputConnectorTypes.PDM:
                self.connector(InputConnectorTypes.PDM)

        # Error Checking
        bit_clk_dir = check_enum_or_str('bit_clk_dir', bit_clk_dir, ClockDirection)

        curr_bit_clk_dir = bit_clk_dir
        if curr_bit_clk_dir is None:
            curr_bit_clk_dir = ClockDirection(self._api.BenchMode.Setup.PdmInput.BitClkDir)

        curr_logic_level = logic_level
        if curr_logic_level is None:
            curr_logic_level = self._api.BenchMode.Setup.PdmInput.LogicLevel.Value

        if curr_logic_level >= 2.0:
            max_bit_clk_rate = 24.576e6
        elif curr_logic_level >= 1.5:
            max_bit_clk_rate = 12.288e6
        elif curr_logic_level >= 1.0:
            max_bit_clk_rate = 6.144e6
        else:
            max_bit_clk_rate = 3.072e6

        decimation = check_enum_or_str('decimation', decimation, Decimation)
        if decimation is not None:
            if decimation == Decimation.X800:
                if curr_logic_level < 1.0:
                    raise ValueError(f'Decimation cannot be set to "X800" because the logic level is either set to '
                                     f'or attempting to be set to {curr_logic_level}V. Set logic_level to a value '
                                     f'greater than or equal to 1.0V to set decimation to "X800".')

        curr_decimation = decimation
        if curr_decimation is None:
            curr_decimation = Decimation(self._api.BenchMode.Setup.PdmInput.Decimation)
        curr_decimation_num = float(curr_decimation.name.replace('X', '').replace('P', '.'))

        if curr_decimation == Decimation.X1:
            min_bit_clk_rate = 28e3
        elif curr_decimation == Decimation.X3P125:
            min_bit_clk_rate = 8.98e3
        elif curr_decimation == Decimation.X4:
            min_bit_clk_rate = 7e3
        elif curr_decimation == Decimation.X6P25:
            min_bit_clk_rate = 4.48e3
        else:
            min_bit_clk_rate = 4e3

        if decimation_rate is not None:
            if curr_bit_clk_dir.name != 'OUT':
                raise ValueError(f'Cannot set decimation_rate. Parameter bit_clk_dir needs to be set to OUT, currently'
                                 f' set to {curr_bit_clk_dir.name}')
            check_range('decimation_rate', decimation_rate,
                        min_max_units(min_bit_clk_rate, min(216e3, max_bit_clk_rate/curr_decimation_num), 'Hz'))

        data_edge = check_enum_or_str('data_edge', data_edge, DataEdge)

        limit_logic_level = on_off.to_inst(limit_logic_level)

        curr_limit_logic_level = limit_logic_level
        if curr_limit_logic_level is None:
            curr_limit_logic_level = on_off.to_inst(self._api.BenchMode.Setup.PdmInput.LimitLogicLevel)

        if vdd_level is not None:
            if not isinstance(vdd_level, (int, float)):
                raise ValueError(f'Bad vdd_level type: {type(vdd_level)}. Must be an int or float type.')
            check_range('vdd_level', vdd_level, min_max_units(0, 3.6, 'V'))
            if curr_limit_logic_level is True:
                if curr_logic_level > vdd_level:
                    raise ValueError(f'Setting vdd_level to {vdd_level} cause it to be lower than logic_level: '
                                     f'{logic_level}. Either lower logic_level with vdd_level or set limit_logic_level'
                                     f' to OFF.')

        curr_vdd_level = vdd_level
        if curr_vdd_level is None:
            curr_vdd_level = self._api.BenchMode.Setup.PdmInput.VddLevel.Value

        if limit_logic_level is not None:
            if limit_logic_level is True:
                if curr_vdd_level < curr_logic_level:
                    raise ValueError(f'Cannot set limit_logic_level to ON as logic_level: {curr_logic_level} is greater than '
                          f'vdd_level: {curr_vdd_level}. Either decrease logic_level or increase vdd_level.')

        if logic_level is not None:
            if not isinstance(logic_level, (int, float)):
                raise ValueError(f'Bad logic_level type: {type(logic_level)}. Must be an int or float type.')
            check_range('logic_level', logic_level, min_max_units(800e-3, 3.3, 'V'))
            if logic_level < 1.0:
                if curr_decimation_num == Decimation.X800:
                    raise ValueError(f'logic_level cannot be set to {logic_level}. When decimation is set to "X800", '
                                     f'the logic_level cannot be less than 1.0V. Set decimation to a different setting'
                                     f'in order to set logic_level below 1.0V.')
            if curr_limit_logic_level is True:
                if curr_vdd_level < logic_level:
                    raise ValueError(f'Bad logic_level: {logic_level}. When limit_logic_level is ON, logic_level must '
                                     f'be less than or equal to vdd_level: {curr_vdd_level}.')

        output_state_vdd = on_off.to_inst(output_state_vdd)

        output_state_rec_outputs = on_off.to_inst(output_state_rec_outputs)
        if output_state_rec_outputs is not None:
            if curr_bit_clk_dir != ClockDirection.OUT:
                raise ValueError(f'In order to set the output_state_rec_outputs parameter to '
                                 f'{on_off.to_api(output_state_rec_outputs)}, the bit_clk_dir parameter needs to '
                                 f'be set to OUT. Currently set to {curr_bit_clk_dir.name}')

        measure = check_enum_or_str('measure', measure, PdmMeasure)
        if measure is not None:
            if curr_bit_clk_dir != ClockDirection.IN:
                raise ValueError(f'In order to set the measure parameter to {measure}, the bit_clk_dir parameter needs'
                                 f' to be set to IN. Currently set to {curr_bit_clk_dir.name}')

        scale_freq_by = check_enum_or_str('scale_freq_by', scale_freq_by, ScaleInputFreqBy)
        curr_scale_freq_by = scale_freq_by
        if curr_scale_freq_by is None:
            curr_scale_freq_by = ScaleInputFreqBy(self._api.BenchMode.Setup.PdmInput.ScaleFreqBy)

        if fixed_rate_freq is not None:
            if curr_scale_freq_by != ScaleInputFreqBy.FIXED_RATE:
                raise ValueError(f'In order to set fixed_rate_freq, scale_freq_by parameter needs to be set to '
                                 f'FIXED_RATE. Currently set to {curr_scale_freq_by.name}')
            check_range('fixed_rate_freq', fixed_rate_freq, min_max_units(4e3, 432e3, 'Hz'))

        # Write to instrument
        if bit_clk_dir is not None:
            self._api.BenchMode.Setup.PdmInput.BitClkDir = bit_clk_dir.value
        if limit_logic_level is not None:
            self._api.BenchMode.Setup.PdmInput.LimitLogicLevel = limit_logic_level
        if (decimation is not None) and (logic_level is not None):
            if curr_decimation == Decimation.X800:
                self._api.BenchMode.Setup.PdmInput.LogicLevel.Value = logic_level
                self._api.BenchMode.Setup.PdmInput.Decimation = decimation.value
            if curr_logic_level <= 1.0:
                self._api.BenchMode.Setup.PdmInput.Decimation = decimation.value
                self._api.BenchMode.Setup.PdmInput.LogicLevel.Value = logic_level
        elif decimation is not None:
            self._api.BenchMode.Setup.PdmInput.Decimation = decimation.value
        elif logic_level is not None:
            self._api.BenchMode.Setup.PdmInput.LogicLevel.Value = logic_level
        if decimation_rate is not None:
            self._api.BenchMode.Setup.PdmInput.DecimatedRate.Value = decimation_rate
        if data_edge is not None:
            self._api.BenchMode.Setup.PdmInput.DataEdge = data_edge.value
        if vdd_level is not None:
            self._api.BenchMode.Setup.PdmInput.VddLevel.Value = vdd_level
        if output_state_vdd is not None:
            self._api.BenchMode.Setup.PdmInput.VddOn = output_state_vdd
        if output_state_rec_outputs is not None:
            self._api.BenchMode.Setup.PdmInput.EnableOutputs = output_state_rec_outputs
        if measure is not None:
            self._api.BenchMode.Setup.PdmInput.MeasureInputSignalType = measure.value
        if scale_freq_by is not None:
            self._api.BenchMode.Setup.PdmInput.ScaleFreqBy = scale_freq_by.value
        if fixed_rate_freq is not None:
            self._api.BenchMode.Setup.PdmInput.FixedInputSampleRate = fixed_rate_freq

    def IsAnalog(self):
        """
        Check if Input Connector is Analog or Digital.

        :return: Return True if output is analog else False.
        :rtype: bool
        """
        return self._api.BenchMode.Setup.InputConnector.IsAnalog

    def IsOutputAnalog(self):
        """
        Check if Outputconnector is Analog or Digital.

        :return: Return True if output is analog else False.
        :rtype: bool
        """
        return self._api.BenchMode.Setup.OutputConnector.IsAnalog
