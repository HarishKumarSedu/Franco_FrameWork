from typing import Dict, Union, Optional, Any
from cl_instr_lib.drivers.audio.apx.bench.signal_path.input import Input
from cl_instr_lib.drivers.audio.apx.bench.signal_path.output import Output
from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str
from cl_instr_lib.drivers.audio.apx.enums import HighPassFilter, AdcBandwidth, LowPassFilterAnalog, \
    LowPassFilterDigital, FilterWeighting


class SignalPath:
    """Base class for APx signal path."""

    def __init__(self, apx):
        self._api_setup = apx.api.BenchMode.Setup
        self._apx = apx
        self.input = Input(apx)
        self.output = Output(apx)

    def configure_filters(self, high_pass: Union[str, HighPassFilter] = None,
                          high_pass_freq_hz: Union[int, float] = None,
                          low_pass: Union[str, LowPassFilterAnalog, LowPassFilterDigital] = None,
                          low_pass_freq_hz: Union[int, float] = None, adc_bandwidth: Union[str, AdcBandwidth] = None,
                          weighting: Union[str, FilterWeighting] = None, eq: str = None, *args, **kwargs) -> \
            Optional[Dict[str, Any]]:

        """
        Configure filters for Signal Path Input and Output functionality.

        :param high_pass: Set the high pass filter. Accepts the following:

            * DC
            * AC
            * BUTTERWORTH
            * ELLIPTIC

        :type high_pass: str|HighPassFilter Enum
        :param high_pass_freq_hz: Sets the high-pass filter frequency in Hz. Only available when BUTTERWORTH or
            ELLIPTIC is the set high pass filter.
        :type high_pass_freq_hz: int|float
        :param low_pass: Sets the low-pass filter frequency in Hz.

            If Input Connector is analog, accepts the following:

            * ADC_PASSBAND
            * AES17_20KHZ
            * AES17_40KHZ
            * BUTTERWORTH
            * ELLIPTIC

            If Input Connector is digital, accepts the following:

            * FS_OVER_2
            * BUTTERWORTH
            * ELLIPTIC


        :type low_pass: str | LowPassFilterAnalog|LowPassFilterDigital
        :param low_pass_freq_hz: Sets the low-pass filter frequency in Hz when the low pass filter is set to
            BUTTERWORTH or ELLIPTIC.
        :type low_pass_freq_hz: int | float
        :param adc_bandwidth: Sets the analog input bandwidth values which control the rate of the ADC.
        :type adc_bandwidth: str | AdcBandwidth Enum
        :param weighting: sets the weighting filter applied to the entire input signal.
        :type weighting: str | FilterWeighting
        :param eq: Set the EQ filter. Accepts the filename of EQ curve.
        :type eq: str
        :return: If no parameters are passed in, this function returns a dictionary of all currently configured
            parameters.
        :rtype: Dict[str, Any]
        """

        # APx.BenchMode.Setup.HighpassFilter
        # APx.BenchMode.Setup.HighpassFilterFrequency
        # APx.BenchMode.Setup.LowpassFilterAnalog
        # APx.BenchMode.Setup.LowpassFilterDigital
        # APx.BenchMode.Setup.LowpassFilterFrequencyAnalog
        # APx.BenchMode.Setup.LowpassFilterFrequencyDigital
        # APx.BenchMode.Setup.LowpassFilterAnalogBandwidth
        # APx.BenchMode.Setup.WeightingFilter
        # APx.BenchMode.Setup.InputEq

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (high_pass, high_pass_freq_hz, low_pass, low_pass_freq_hz, adc_bandwidth, weighting,
                                   eq)):
            return_values = {}
            return_values.update(high_pass=HighPassFilter(self._api_setup.HighpassFilter).name)
            return_values.update(high_pass_freq_hz=self._api_setup.HighpassFilterFrequency)
            if self.input.IsAnalog():
                curr_low_pass = LowPassFilterAnalog(self._api_setup.LowpassFilterAnalog).name
                return_values.update(low_pass=curr_low_pass)
                return_values.update(low_pass_freq_hz=self._api_setup.LowpassFilterFrequencyAnalog)
            else:
                curr_low_pass = LowPassFilterDigital(self._api_setup.LowpassFilterDigital).name
                return_values.update(low_pass=curr_low_pass)
                return_values.update(low_pass_freq_hz=self._api_setup.LowpassFilterFrequencyDigital)
            if curr_low_pass == LowPassFilterAnalog.ADC_PASSBAND.name:
                return_values.update(adc_bandwidth=AdcBandwidth(
                    self._api_setup.LowpassFilterAnalogBandwidth).name)
            return_values.update(weighting=FilterWeighting(
                self._api_setup.WeightingFilter).name)
            return_values.update(eq=self._api_setup.InputEq.Eq)

            return return_values

        # Error Checking
        high_pass = check_enum_or_str('high_pass', high_pass, HighPassFilter)

        curr_high_pass = high_pass
        if curr_high_pass is None:
            curr_high_pass = HighPassFilter(self._api_setup.HighpassFilter)

        if high_pass_freq_hz is not None:
            if curr_high_pass not in (HighPassFilter.BUTTERWORTH, HighPassFilter.ELLIPTIC):
                raise ValueError(f'In order to set a high pass frequency, the high pass filter must be set to either '
                                 f'BUTTERWORTH or ELLIPTIC. Currently set to {curr_high_pass.name}.')
            if not isinstance(high_pass_freq_hz, (int, float)):
                raise ValueError(f'Bad type for high_pass_freq_hz: {type(high_pass_freq_hz)}. Needs to be an '
                                 f'int or float.')

        if self.input.IsAnalog():
            low_pass = check_enum_or_str('low_pass', low_pass, LowPassFilterAnalog)
            if low_pass_freq_hz is not None:
                if not isinstance(low_pass_freq_hz, (int, float)):
                    raise ValueError(f'Bad type for low_pass_freq_hz: {type(low_pass_freq_hz)}. Needs to be an '
                                     f'int or float.')
        else:
            low_pass = check_enum_or_str('low_pass', low_pass, LowPassFilterDigital)
            if low_pass_freq_hz is not None:
                if not isinstance(low_pass_freq_hz, (int, float)):
                    raise ValueError(f'Bad type for low_pass_freq_hz: {type(low_pass_freq_hz)}. Needs to be an '
                                     f'int or float.')
        curr_low_pass = low_pass
        if curr_low_pass is None:
            if self.input.IsAnalog():
                curr_low_pass = LowPassFilterAnalog(self._api_setup.LowpassFilterAnalog)
            else:
                curr_low_pass = LowPassFilterDigital(self._api_setup.LowpassFilterDigital)

        adc_bandwidth = check_enum_or_str('adc_bandwidth', adc_bandwidth, AdcBandwidth)
        if adc_bandwidth is not None:
            if curr_low_pass != LowPassFilterAnalog.ADC_PASSBAND:
                raise ValueError(f'Cannot set adc_bandwidth parameter to {adc_bandwidth}. Signal Path Input/Output'
                                 f' low-pass filter needs to be configured to ADC passband, currently set to '
                                 f'{curr_low_pass.name}. Set the low_pass parameter within configure_filters() to '
                                 f'"ADC_PASSBAND".')

        weighting = check_enum_or_str('weighting', weighting, FilterWeighting)

        if eq is not None:
            if not isinstance(eq, str):
                raise ValueError(f'Bad eq: {eq}. Must be str')
            if eq not in self._api_setup.InputEq.EqNames:
                raise ValueError(f'Bad eq name {eq}. Valid names are '
                                 f'{[v for v in self._api_setup.OutputEq.EqNames]}')

        # Write to Instrument
        if high_pass is not None:
            self._api_setup.HighpassFilter = high_pass.value
        if high_pass_freq_hz is not None:
            self._api_setup.HighpassFilterFrequency = high_pass_freq_hz
            if self.configure_filters()['high_pass_freq_hz'] != high_pass_freq_hz:
                self._apx.log.warning(f'Attempted to set high_pass_freq_hz parameter to {high_pass_freq_hz}, however value was'
                              f'coerced to {self.configure_filters()["high_pass_freq_hz"]} due to'
                              f'limitations of the APx model.')
        if self.input.IsAnalog():
            if low_pass is not None:
                self._api_setup.LowpassFilterAnalog = low_pass.value
            if low_pass_freq_hz is not None:
                self._api_setup.LowpassFilterFrequencyAnalog = low_pass_freq_hz
                if self.configure_filters()['low_pass_freq_hz'] != low_pass_freq_hz:
                    self._apx.log.warning(f'Attempted to set low_pass_freq_hz parameter to {low_pass_freq_hz}, however value '
                                  f'was coerced to {self.configure_filters()["low_pass_freq_hz"]}'
                                  f' due to limitations of the APx model.')
        else:
            if low_pass is not None:
                self._api_setup.LowpassFilterDigital = low_pass.value
            if low_pass_freq_hz is not None:
                self._api_setup.LowpassFilterFrequencyDigital = low_pass_freq_hz
                if self.configure_filters()['low_pass_freq_hz'] != low_pass_freq_hz:
                    self._apx.log.warning(f'Attempted to set low_pass_freq_hz parameter to {low_pass_freq_hz}, however value '
                                  f'was coerced to {self.configure_filters()["low_pass_freq_hz"]}'
                                  f' due to limitations of the APx model.')
        if adc_bandwidth is not None:
            self._api_setup.LowpassFilterAnalogBandwidth = adc_bandwidth.value
        if weighting is not None:
            self._api_setup.WeightingFilter = weighting.value
        if eq is not None:
            self._api_setup.InputEq.Eq = eq
