from enum import Enum
from typing import Any, Dict, Union

from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str
from cl_instr_lib.drivers.audio.apx.enums import TuningValues, WeightingValues, BandpassFixedFreqUnits, IMDValues, \
    ThdFixedFreqUnits


class Analyzer:

    """Base class for APx analyzer"""

    def __init__(self, apx):
        self._apx = apx

    def configure(self, notch_tuning: Union[str, TuningValues] = None, thd_freq: Union[int, float] = None,
                  thd_freq_units: str = None, weighting: Union[str, WeightingValues] = None,
                  bandpass_tune_mode: Union[str, TuningValues] = None, bandpass_freq: Union[int, float] = None,
                  bandpass_freq_units: Union[str, BandpassFixedFreqUnits] = None, reference_ch: int = None,
                  imd_type: Union[str, IMDValues] = None, *args, **kwargs) -> Dict[str, Any]:

        """
        Method to configure the APx Analyzer settings.

        :param notch_tuning: Set the Notch Filter Tune Mode. See TuningValues enum for a list of values. Options
            include: GENERATOR_FREQUENCY, JITTER_GENERATOR_FREQUENCY, MEASURED_FREQUENCY, FIXED_FREQUENCY
        :type notch_tuning: str|TuningValues
        :param thd_freq: Set the Fixed Frequency of the THD+N when the Notch Filter Tune Mode is Fixed Frequency.
        :type thd_freq: int|float
        :param thd_freq_units: Set the unit for THD+N Fixed Frequency. See ThdFixedFreqUnits enum for a list of values.
        :type thd_freq_units: str|ThdFixedFreqUnits
        :param weighting: Set the weighting filter for noise measurements. Options include NA, A_WT, B_WT, C_WT,
            CCIR_1K, CCIR_2K, CCITT, C_MESSAGE, US_DE_EMPPH_50, US_DE_EMPPH_75, US_DE_EMPPH_50_PLUS_A_WT,
            US_DE_EMPPH_75_PLUS_A_WT

        :type weighting: str
        :param bandpass_tune_mode: Set the Bandpass Filter Tune Mode. See TuningValues enum for a list of values.
            Options include GENERATOR_FREQUENCY, JITTER_GENERATOR_FREQUENCY, MEASURED_FREQUENCY, FIXED_FREQUENCY

        :type bandpass_tune_mode: str|TuningValues
        :param bandpass_freq: Set the Fixed Frequency of the Bandpass Filter when the Bandpass Filter Tune Mode is set
            to Fixed Frequency
        :type bandpass_freq: int|float
        :param bandpass_freq_units: Set the unit for Bandpass Fixed Frequency. See BandpassFixedFreqUnits for a list
            of values. Options include HZ, DHZ, F_R, PERCENT_HZ

        :type bandpass_freq_units: str|BandpassFixedFreqUnits
        :param reference_ch: Set the reference channel(1 indexed) used to measure phase or level ratio.
        :type reference_ch: int
        :param imd_type: Set the IMD analysis type. See IMDValues enum for a list of values. Options include SMPTE_DIN,
            DFD, CCIF, DIM

        :type imd_type: str|IMDValues
        :return: If nothing but the channel is input, method returns a dictionary of current parameter configurations
            for the sine waveform for the channel defined. Otherwise returns None.
        :rtype: dict|None
        """

        # APx.BenchMode.Analyzer.NotchFilterTuning
        # APx.BenchMode.Analyzer.NotchFilterFrequency.Value
        # APx.BenchMode.Analyzer.NotchFilterFrequency.Unit
        # APx.BenchMode.Analyzer.ThdNWeighting
        # APx.BenchMode.Analyzer.BandpassFilterTuning
        # APx.BenchMode.Analyzer.BandpassFixedFilterFrequency.Value
        # APx.BenchMode.Analyzer.BandpassFixedFilterFrequency.Unit
        # APx.BenchMode.Analyzer.ReferenceChannel
        # APx.BenchMode.Analyzer.ImdMeterType

        self._apx.log_unused_args(args, kwargs)

        # Readback
        if all(v is None for v in (notch_tuning, thd_freq, thd_freq_units, weighting, bandpass_tune_mode,
                                   bandpass_freq, bandpass_freq_units, reference_ch, imd_type)):
            return_values = {}
            curr_notchtuningvalues = TuningValues(self._apx.api.BenchMode.Analyzer.NotchFilterTuning).name
            return_values.update(notch_tuning=curr_notchtuningvalues)
            if curr_notchtuningvalues == TuningValues.FIXED_FREQUENCY.name:
                return_values.update(thd_freq=self._apx.api.BenchMode.Analyzer.NotchFilterFrequency.Value)
                return_values.update(thd_freq_units=self._apx.api.BenchMode.Analyzer.NotchFilterFrequency.Unit)
            return_values.update(weighting=WeightingValues(self._apx.api.BenchMode.Analyzer.ThdNWeighting).name)
            curr_bandpasstuningvalues = TuningValues(self._apx.api.BenchMode.Analyzer.BandpassFilterTuning).name
            return_values.update(bandpass_tune_mode=curr_bandpasstuningvalues)
            if curr_bandpasstuningvalues == TuningValues.FIXED_FREQUENCY.name:
                return_values.update(bandpass_freq=
                                     self._apx.api.BenchMode.Analyzer.BandpassFixedFilterFrequency.Value)
                return_values.update(bandpass_freq_units=self._apx.api.BenchMode.Analyzer.BandpassFixedFilterFrequency.Unit)
            return_values.update(reference_ch=self._apx.api.BenchMode.Analyzer.ReferenceChannel + 1)
            return_values.update(imd_type=IMDValues(self._apx.api.BenchMode.Analyzer.ImdMeterType).name)
            return return_values

        # Error Checking
        notch_tuning = check_enum_or_str('notch_tuning', notch_tuning, TuningValues)
        if thd_freq is not None:
            if not isinstance(thd_freq, (int, float)):
                raise ValueError(f'Bad thd_freq: {thd_freq}. Must be int or float')
        thd_freq_units = check_enum_or_str('thd_freq_units', thd_freq_units, ThdFixedFreqUnits)
        if thd_freq_units is not None:
            if thd_freq_units not in self.get_available_units("thd_freq"):
                raise ValueError(f'Bad level_unit value: {thd_freq_units}. Must be in '
                                 f'{[v.name for v in self.get_available_units("thd_freq")]} for current APx configurations.')
        weighting = check_enum_or_str('weighting', weighting, WeightingValues)
        bandpass_tune_mode = check_enum_or_str('bandpass_tune_mode', bandpass_tune_mode, TuningValues)
        if bandpass_freq is not None:
            if not isinstance(bandpass_freq, (int, float)):
                raise ValueError(f'Bad thd_freq: {bandpass_freq}. Must be int or float')
        bandpass_freq_units = check_enum_or_str('bandpass_freq_units', bandpass_freq_units, BandpassFixedFreqUnits)
        if bandpass_freq_units is not None:
            if bandpass_freq_units not in self.get_available_units("bandpass_freq"):
                raise ValueError(f'Bad level_unit value: {bandpass_freq_units}. Must be in '
                                 f'{[v.name for v in self.get_available_units("bandpass_freq")]} for current APx configurations.')
        if reference_ch is not None:
            if not isinstance(reference_ch, int):
                raise ValueError(f'Bad reference_ch: {reference_ch}. Must be type int')
            reference_ch -= 1  # Index channel properly
            if not (0 <= reference_ch < self._apx.api.BenchMode.Setup.InputChannelCount):
                raise ValueError(f'Bad channel value: {reference_ch + 1}. Must be 1 >= channel <= '
                                 f'{self._apx.api.BenchMode.Setup.InputChannelCount}')
        imd_type = check_enum_or_str('imd_type', imd_type, IMDValues)

        # Write to Instrument
        if thd_freq_units is not None:
            self._apx.api.BenchMode.Analyzer.NotchFilterFrequency.Unit = thd_freq_units
        if bandpass_freq_units is not None:
            self._apx.api.BenchMode.Analyzer.BandpassFixedFilterFrequency.Unit = bandpass_freq_units
        if notch_tuning is not None:
            self._apx.api.BenchMode.Analyzer.NotchFilterTuning = notch_tuning.value
        if thd_freq is not None:
            self._apx.api.BenchMode.Analyzer.NotchFilterFrequency.Value = thd_freq
        if weighting is not None:
            self._apx.api.BenchMode.Analyzer.ThdNWeighting = weighting.value
        if bandpass_tune_mode is not None:
            self._apx.api.BenchMode.Analyzer.BandpassFilterTuning = bandpass_tune_mode.value
        if bandpass_freq is not None:
            self._apx.api.BenchMode.Analyzer.BandpassFixedFilterFrequency.Value = bandpass_freq
        if reference_ch is not None:
            self._apx.api.BenchMode.Analyzer.ReferenceChannel = reference_ch
        if imd_type is not None:
            self._apx.api.BenchMode.Analyzer.ImdMeterType = imd_type.value

    def get_available_units(self, parameter: str):  # TODO: Make this more specific.

        """
        Get a list of what units are available for a parameter based on current configurations of the APx.

        :param parameter: The parameter to get available units for.

            Currently accepts the following:

            * 'thd_freq'
            * 'bandpass_freq'

        :type parameter: str
        :return: List of available units.
        :rtype: list
        """

        if parameter == 'thd_freq':
            unit_list = list(self._apx.api.BenchMode.Analyzer.NotchFilterFrequency.UnitList)
            unit_enum = ThdFixedFreqUnits
        elif parameter == 'bandpass_freq':
            unit_list = list(self._apx.api.BenchMode.Analyzer.BandpassFixedFilterFrequency.UnitList)
            unit_enum = BandpassFixedFreqUnits
        else:
            raise ValueError(f'Unsupported parameter: {parameter}. Currently supports fixed_freq')
        ret_list = []
        for unit in unit_list:
            ret_list.append(unit_enum(unit))
        return ret_list