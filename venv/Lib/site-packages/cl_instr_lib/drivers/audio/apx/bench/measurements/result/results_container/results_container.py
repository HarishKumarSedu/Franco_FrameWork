from cl_instr_lib.drivers.audio.apx.bench.measurements.result.result import Result
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.graph_results.xy_graph_result import XYGraphResult
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.graph_results.meter_graph_result import MeterGraphResult
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.meter_result import MeterResult


class ResultsContainer:
    """Parent Result Class"""

    def __init__(self, measurement, results):
        """
        creates a container class for the measurement that has dynamic attributes for each result in the gui.

        :param measurement: Class of which to attach the result container (ex: Fft, AcousticResponse)
        :type measurement: class
        :param results: List of strings of modified result names queried from the GUI
        :type results: List[str]
        """
        self._measurement = measurement
        modified_names = []
        indexes = []
        # In some cases the gui may have multiple graphs of the same time and name. In an effort to keep both result
        # objects, we will append _1, _2, _3 etc for each duplicate result
        for index, name in enumerate(results):
            if modified_names.count(name) >= 1:
                name = name + '_' + str(results[:index].count(name))
            modified_names.append(name)
            indexes.append(index)
        # Meter class attributes to be handled differently than the other measurements
        for index, name in enumerate(modified_names):
            if self._measurement.meas_name == 'Meter':
                self.__setattr__(name, MeterResult(self._measurement, name, index))
            else:
                if self._measurement.api_ref.Graphs[index].Result.IsXYGraph:
                    self.__setattr__(name, XYGraphResult(self._measurement, name, index))
                    if self.__getattribute__(name).is_right_axis_result():
                        self.__delattr__(name)
                elif self._measurement.api_ref.Graphs[index].Result.IsMeterGraph:
                    self.__setattr__(name, MeterGraphResult(self._measurement, name, index))
                else:
                    self.__setattr__(name, Result(self._measurement, name, index))

# the below child classes are needed purely for ease in creating the results_container.pyi


class FftResultsContainer(ResultsContainer):
    pass


class SweepResultsContainer(ResultsContainer):
    pass


class AcousticResponseResultsContainer(ResultsContainer):
    pass


class ContinuousSweepResultsContainer(ResultsContainer):
    pass


class RecorderResultsContainer(ResultsContainer):
    pass


class MeterResultsContainer(ResultsContainer):
    pass

