import re
import os
from typing import List, Union, Optional

from cl_instr_lib.drivers.audio.apx.reusables import check_enum_or_str
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.results_container.results_container import \
    MeterResultsContainer, ResultsContainer
from cl_instr_lib.drivers.audio.apx.bench.measurements.result.meter_result import MeterResult
from cl_instr_lib.drivers.audio.apx.enums import BenchMeterType


class Meters:
    meas_name = 'Meter'
    results: MeterResultsContainer
    """Base class for APx Meters"""

    def __init__(self, apx):
        self._apx = apx
        self.sync_with_gui()

    @property
    def api_ref(self):
        """APx Meters Native API"""
        return self._apx.api.BenchMode.Meters

    def remove_all_meters(self):
        """
        Removes all result graphs
        """
        for x in range(self.api_ref.Count):
            self.api_ref.Remove(0)
        self.sync_with_gui()

    def get_meter_options(self) -> List[str]:
        """
        Returns a list of BenchMeterType enum strings that are valid for add/configure_results. This returns the full
        list of analog and digital meters, all may not be valid for the input configuration. There is unfortunately no
        native API to determine which are valid (IsValid only returns the currently configured meter types)

        :return: list of string meter names
        :rtype: list[str]
        """
        return [meter_type.name for meter_type in BenchMeterType]

    def get_configured_meter_names(self) -> List[str]:
        """
        Gets a list of the meter result objects that currently exist

        :return: list of string names
        :rtype: List[str]
        """
        results = []
        for result in self.results.__dict__.values():
            if isinstance(result, MeterResult):
                results.append(result.result_name)
        return results

    def add_meter(self, meter: Union[BenchMeterType, str]):
        """
        Adds any valid meter.

        :param meter: Name of meter to add. Options include:

            SINAD, AVERAGE_JITTER_LEVEL, RMS_LEVEL, PHASE, THDN_RATIO, RESISTANCE_DCX, THDN_LEVEL, PEAK_LEVEL,
            BANDPASS_LEVEL, CREST_FACTOR, BITS, DC_LEVEL, DC_LEVEL_DCX, GAIN, DIGITAL_INTERFACE_LEVEL, FREQUENCY,
            IMD_RATIO, INPUT_SAMPLE_RATE, RMS_LEVEL_RATIO, ERROR_RATE

        :type meter: BenchMeterType | str
        """
        meter = check_enum_or_str(f'meter', meter, BenchMeterType)
        self.api_ref.Add(self._apx._imports.BenchModeMeterType.RmsLevelMeter.__getattribute__(meter.value))
        self.sync_with_gui()

    def configure_meters(self, meters: List[Union[BenchMeterType, str]] = None) -> Optional[List[str]]:
        """
        Clears current meters and configures the specified meters in order.

        :param meters: List of names of the meters to add. Options include:

            SINAD, AVERAGE_JITTER_LEVEL, RMS_LEVEL, PHASE, THDN_RATIO, RESISTANCE_DCX, THDN_LEVEL, PEAK_LEVEL,
            BANDPASS_LEVEL, CREST_FACTOR, BITS, DC_LEVEL, DC_LEVEL_DCX, GAIN, DIGITAL_INTERFACE_LEVEL, FREQUENCY,
            IMD_RATIO, INPUT_SAMPLE_RATE, RMS_LEVEL_RATIO, ERROR_RATE

        :type meters: List[BenchMeterType | str]
        """

        if meters is None:
            meters = []
            for meter in self.results.__dict__.values():
                if isinstance(meter, MeterResult):
                    meters.append(meter.get_result_type())
            return meters
        else:
            meters = [check_enum_or_str(f'{meter}', meter, BenchMeterType) for meter in meters]
            self.remove_all_meters()
            for meter in meters:
                self.add_meter(meter)
            self.sync_with_gui()

    def _query_current_results(self):
        """
        gets a modified list of result names from the GUI

        :return: list of strings
        :rtype: list[str]
        """
        result_names = []
        for index in range(self.api_ref.Count):

            result_name = self.api_ref.GetMeterType(index).Name
            result_name = re.sub("\(DCX\)", "dcx", result_name)  # keep dcx suffix if found in ()
            result_name = re.sub("[\(\[].*?[\)\]]", "", result_name)  # delete all other text in ()
            result_name = result_name.lower().strip(' ').replace(' ', '_').replace(',', '').replace('-', '').\
                replace('>', '').replace('+', '')
            result_names.append(result_name)
        return result_names

    def sync_with_gui(self):
        """
        Updates the results container to match the GUI
        """
        self.results = MeterResultsContainer(self, self._query_current_results())
        self.update_pyi_file()

    def update_pyi_file(self):
        """
        Updates the pyi file section for meters to help with autocompletion in tests.

        :return: None
        """
        pyi_file = os.path.dirname(os.path.realpath(__file__)) + \
            '\\result\\results_container\\results_container.pyi'
        old_contents = ''
        if os.path.exists(pyi_file):  # Read to check for differences
            with open(pyi_file, 'r') as f:
                old_contents = f.read()
        pyi_content = self._update_pyi_section(old_contents)
        if pyi_content != old_contents:  # Only overwrite if there's been changes to the pyi structure
            self._apx.log.debug(f"Updating stub file: {os.path.basename(pyi_file)}")
            with open(pyi_file, 'w') as f:
                f.write(pyi_content)
        else:
            self._apx.log.debug(f"Stub file for {self.meas_name} up to date")

    def _update_pyi_section(self, old_contents):
        """
        Modifies the existing pyi_content string, updates the Meters section to match the GUI

        :param old_contents: string of original content
        :type old_contents: str
        :return: modified pyi file contents string
        :rtype: str
        """
        pyi_contents = []
        tab = '    '
        start_string = 'class %s\(%s\):\n' % (self.results.__class__.__name__, ResultsContainer.__name__)
        pyi_contents.extend([start_string.replace('\\', '')])
        num_results = 0
        for result in self.results.__dict__.values():
            if isinstance(result, MeterResult):
                num_results += 1
                pyi_contents.extend([tab, result.result_name, ': ', result.__class__.__name__, '\n'])
        if num_results == 0:
            pyi_contents.extend([tab, 'pass', '\n'])
        pyi_contents.extend(([tab, "# END"]))
        new_section = ''.join(pyi_contents)
        new_contents = re.sub(f'{start_string}.*?# END', new_section, old_contents, 1, flags=re.DOTALL)
        return new_contents
