# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Inherit from the instrument class
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa

# Include Other Instrument Drivers/Helpers
from cl_instr_lib.helpers.check_enum_str import check_enum_str

# Include Python libraries
from collections import namedtuple
from enum import Enum
import time
# -----------------------------------------------------------
#                           GLOBALS
# -----------------------------------------------------------
ProgrammingRange = namedtuple('ProgrammingRange', 'MIN MAX')
IncrementorRange = namedtuple('IncrementorRange', 'MIN MAX')
RadiometricRange = namedtuple('RadiometricRange', 'MIN MAX')
# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# This machine often times out when sending multiple queries in succession
# This has been fixed by implementing time.sleep() delays or delaying queries for
# Blocks of code.
#
# The instrument also has issue reading back the set value of the standard value function where the data
# can be written successfully but not read with accuracy. often the data comes back corrupted. This seems like a
# hardware/firmware issue. Contacting the manufacturer may be necessary to solve.
#
# Increment/Decrement have no direct SCPI command to control the method, rather emulate Home screen key presses.
# to make sure the Increment/Decrement command is read, a key press is sent and the new resistance value is compared
# to the previous resistance. in the event INC/DEC has not been pressed, the command sent would be navigating menus
# on the instrument. A BACK command is sent and the process repeats until the resistance changes.
# INC/DEC are commented out for later development.
#
# The implementation of calibration and tables are unnecessary methods at the moment, however SCPI commands for them
# are listed in the reference section
#
# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class PRS330(InstrumentVisa):
    """
    PRS-330 Programmable Decade Resistance Substituter

    resistance: from 0.1Ω to 20MΩ,  resolution: 1uΩ or 6 digits
    """

    resolution_sig_fig = 7
    enum_terminal_values = {"FRONT": 'FRONT', "REAR": 'REAR'}
    enum_switch_values = {"DEFAULT": 'DEFAULT', "OPEN": 'OPEN', "CLOSED": 'CLOSED'}
    enum_connection_mode = Enum("enum_connection_mode", {'MODE2W': 2, 'MODE4W': 4})
    enum_standard_values = Enum("enum_standard_values", {'SET': "'SET'", 'DECADE': "'DEC'", 'STANDARD': "'STAN'",
                                                         'RADIOMETRIC': "'RAD'"})
    # I made these protected so the end user does not touch them as input for the methods
    # The desired value the user should be input as str | float | int
    _enum_decade_values = Enum("_enum_decade_values", {'0.1': 0.1, '1': 1, '10': 10, '100': 1e2, '1K': 1e3, '10K': 1e4,
                                                       '100K': 1e5, '1M': 1e6, '10M': 1e7})
    _enum_eia_std_values = Enum("_enum_eia_std_values", {'1%': 1, '0.01': 1, '1': 1, '5%': 5, '0.05': 5, '5': 5,
                                                         '10%': 10, '0.1': 10, '10': 10})

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):

        super().__init__(visa_resource_name, logger,
                         model_re='^PRS-330$',  # match the model string from the IDN
                         sim_idn='IET Labs Inc.,PRS-330,A5-21151215,A5',  # a simulated IDN string
                         **kwargs)

        self.programming_range_res_val = ProgrammingRange(0.1, 20e6)
        self.incrementor_range_std_val = IncrementorRange(0.1, 10e6)
        self.radiometric_range_std_val = RadiometricRange(0.001, 10)

# -----------------------------------------------------------
#                           METHODS
# -----------------------------------------------------------
    def reset(self):
        """
        Reset method that overloads the instrument base reset with the added functionality
        of receiving the identification string and current resistance.
        """

        super().reset()
        time.sleep(3.0)
        self.get_idn()
        time.sleep(1.0)
        self.resistance()

    # Set/Get resistance
    def resistance(self, res_val=None):
        """
        Configure the resistance value similar to setting a value using the instruments'
        number pad and pressing enter.

        Manual Notes: Sets output resistance of the PRS-330 if table is set to
        None or the resistance value corresponding to the display value for the table selected.
        Display value in form of number and decimal point representing desired display value.
        example res_val = 1.000002 would set resistance value to 1.000002Ω if Table is set to
        None.

        :param res_val: Input resistance value. resistance: from 0.1Ω to 20MΩ
                resolution: 1uΩ or 6 digits
        :type res_val: int | float

        :return: Resistance value being returned from the PRS330
        :rtype: float | None
        """

        # echo back current configuration
        if res_val is None:
            return_value = {}
            return_value.update(res_val=float((self.query('SOUR:DATA', str)).replace(',', '')))
            return return_value

        # General Case: Set the resistance if a table is not in use
        table_sel_var = self.query('CONF:TABL:SEL', str)
        if table_sel_var == '0':
            if self.programming_range_res_val.MIN <= res_val <= self.programming_range_res_val.MAX:  # range check

                # resolution checkers
                sig_fig_str = str(res_val)
                dec_pos = sig_fig_str.find('.')  # find where the decimal is.
                if dec_pos > -1:  # if a decimal point exists in the number

                    if len(sig_fig_str.replace('.', '')) >= self.resolution_sig_fig:
                        # if the value as a string is greater than allowed sig figs
                        res_val = round(res_val, (self.resolution_sig_fig - dec_pos))  # round to allowed sig figs
                        # let the user know that the value has been shortened.
                        self.log.warning("res_val " + sig_fig_str + f" has been rounded to {res_val}")

                self.write('SOUR:DATA', res_val)
            else:
                raise ValueError(f'Bad res_val {res_val}, should be {self.programming_range_res_val.MIN} to '
                                 f'{self.programming_range_res_val.MAX} Ohms')

        else:  # Special Case: a table is being used
            raise RuntimeError(f" Table {table_sel_var} in use, change to (0/No Table) for resistance input")

        # make sure there are no errors with the commands sent to the device.
        self.log_inst_errors()

    # Set/Get resistance settings (wire config, terminal, Switching mode)
    def resistance_settings(self, connection_mode=None, terminal=None, switch_mode=None):
        """
        Set the wire count, selected terminal, and the switching mode for the instrument found
        within the resistance settings menu on the PRS-330

        :param connection_mode: the amount of wires used, either 2 or 4.
        :type connection_mode: str | enum_connection_mode

        :param terminal: the choice of using the front or back terminals,
                            there is no difference in performance
        :type terminal: str | enum_terminal_values

        :param switch_mode: the switching mode used when changing resistance.
                            either short, open, or default
        :type switch_mode: str | enum_switch_values

        :return: Parameter names and values from the PRS330
        :rtype: dict | None
        """

        # echo back current configuration
        if all(val is None for val in {connection_mode, terminal, switch_mode}):
            self.rm_handle.query_delay = 0.5  # Delay for bug fix
            # if no parameters are passed through, query for relevant values
            return_value = {}
            return_value.update(connection_mode=self.query('CONF:SEL?', str))  # display wire config
            return_value.update(terminal=self.query('CONF:TERM?', str))
            return_value.update(switch_mode=self.query('CONF:SWIT?', str))
            self.rm_handle.query_delay = 0.0  # remove query delay
            return return_value

        # special cases
        connection_mode = check_enum_str('connection_mode', connection_mode, self.enum_connection_mode)
        terminal = check_enum_str('terminal', terminal, self.enum_terminal_values)
        switch_mode = check_enum_str('switch_mode', switch_mode, self.enum_switch_values)

        # general cases
        if connection_mode is not None:
            self.write('CONF:SEL', connection_mode.value)
        if terminal is not None:
            self.write('CONF:TERM', terminal.value)
        if switch_mode is not None:
            self.write('CONF:SWIT', switch_mode.value)

        # make sure there are no errors with this command
        self.log_inst_errors()

    # set/Get standard values of incrementation
    def standard_values(self, std_val_sel=None, set_val=None, eia_std_val=None, dec_val=None, per_val=None):
        """
        Allows for the editing and selection of the four possible values for incrementing and decrementing
        the resistance. This does NOT directly change the resistance, rather the possible increment/decrement values.

        :param std_val_sel: Selecting the Standard value used in incrementing and decrementing. Possible values: SET,
         STANDARD,RADIOMETRIC, and DECADE
        :type std_val_sel: str | enum_standard_values

        :param set_val: Set a specific value to increment by ranging from  0.1Ω to 10MΩ
        :type std_val_sel: str | float | int

        :param dec_val: Decade value ranging for 0.1Ω to 10MΩ.  10, 100, 1K, ... 10M
        :type std_val_sel: str

        :param per_val: Percent Value from 0.001% to 10%
        :type std_val_sel: str

        :param eia_std_val: EIA Standard Value, allows the PRS-330 to be
           used as an automated resistance carousel with built-in EIA “preferred value” resistance tables
           1%, 5% and 10% tolerance increments. when using INC or DEC the instrument with go to the next preferred value
        :type std_val_sel: str

        :return: Parameter names and values from the PRS330
        :rtype: dict | None
        """

        # echo back current configuration
        if all(val is None for val in {std_val_sel, set_val, eia_std_val, dec_val, per_val}):
            # if no parameters are passed through, query for relevant values
            return_value = {}
            self.rm_handle.query_delay = 0.1  # Delay for bug fix
            return_value.update(std_val_sel=self.query('CONF:STDV:STAN', str))

            # TODO: Contact Manufacturer to see about read back issue
            # the PRS330 has errors reading back this specific value
            try:
                temp_value = self.query('CONF:STDV:SET', str)
                set_val1 = float(temp_value)
            except:
                self.log.warning(f'There is an error reading back the value of set_val, Try again')
            else:
                return_value.update(set_val=set_val1)

            # return_value.update(set_val=self.query('CONF:STDV:SET', str))
            return_value.update(eia_std_val=str(self.query('CONF:STDV:STD', float))+'%')
            return_value.update(dec_val=self.query('CONF:STDV:DEC', str))
            return_value.update(per_val=str(self.query('CONF:STDV:RAD', float))+'%')
            self.rm_handle.query_delay = 0.0  # Delay for bug fix
            return return_value

        # special cases
        std_val_sel = check_enum_str('std_val_sel', std_val_sel, self.enum_standard_values)

        if set_val is not None:  # set val can be from 0.1 to 10 Mohm
            if self.incrementor_range_std_val.MIN > set_val or set_val > self.incrementor_range_std_val.MAX:
                raise ValueError(f'Bad set_val {set_val}, should be {self.incrementor_range_std_val.MIN} to '
                                 f'{self.incrementor_range_std_val.MAX} Ohms')

        if dec_val is not None:  # dec val can be 0.1 ,1 ,10, 100, .... 10M
            if type(dec_val) in [int, float]:
                dec_val = str(dec_val)
            if isinstance(dec_val, str):
                dec_val = dec_val.upper()
            dec_val = check_enum_str('dec_val', dec_val, self._enum_decade_values)

        if eia_std_val is not None:  # 1% 5% 10%
            # accepts integer and float values to be converted to be used
            if type(eia_std_val) in [int, float]:
                eia_std_val = str(eia_std_val)
            eia_std_val = check_enum_str('eia_std_val', eia_std_val, self._enum_eia_std_values)

        if per_val is not None:  # percentage value from 0.001% to 10%
            if isinstance(per_val, int):
                per_val = str(per_val)+'.00'
            if isinstance(per_val, str):
                per_val = float(per_val.replace('%', ''))

            if self.radiometric_range_std_val.MIN > per_val or per_val > self.radiometric_range_std_val.MAX:
                raise ValueError(f'Bad per_val {per_val}, should be {self.radiometric_range_std_val.MIN}% to '
                                 f'{self.radiometric_range_std_val.MAX}%')

        # General cases
        if std_val_sel is not None:
            self.write('CONF:STDV', std_val_sel.name)
        if set_val is not None:
            self.write('CONF:STDV:SET', set_val)
        if eia_std_val is not None:
            self.write('CONF:STDV:STD', eia_std_val.value)
        if dec_val is not None:
            self.write('CONF:STDV:DEC', dec_val.value)
        if per_val is not None:
            self.write('CONF:STDV:RAD', per_val)
        # make sure there are no errors with this command
        self.log_inst_errors()

    # test: this command always reads back zero on my device
    def self_test(self):
        """
        Have the PRS-330 Instrument Self-Test
        Returns ASCII 0 or 1, 0 = bad or 1 = good

        :return: BAD or GOOD
        """

        return_val = self.query('*TST?', int)
        self.query('*OPC', int)
        time.sleep(5)
        # self.write('*WAI', "")
        # make sure there are no errors with this command
        self.log_inst_errors()
        if return_val == 0:
            return "BAD"
        else:
            return "GOOD"
    # -----------------------------------------------------------
    # Low Priority functionality

    # # increment and decrement
    # def inc(self):
    #     """
    #     Increments the resistance value based on the the standard value chosen
    #
    #     :return: New resistance value after increment
    #     """
    #     # Recieve data as to how we will Dec/Inc
    #     self.rm_handle.query_delay = 0.5  # Delay for bug fix
    #     prev_res_val = float((self.query('SOUR:DATA', str)).replace(',', ''))
    #     std_val_sel = self.query('CONF:STDV', str)
    #
    #     if std_val_sel == 'STANDARD':
    #         increment_val = self.query(f'CONF:STDV:STD', float)  # std_val_sel in this case is STAN, not STD
    #     else:
    #         increment_val = self.query(f'CONF:STDV:{std_val_sel}', float)
    #     self.rm_handle.query_delay = 0.0  # Delay for bug fix
    #
    #     # Check that the incrementor stays in bounds
    #     if std_val_sel == 'DECADE' or std_val_sel == 'SET':
    #         if (increment_val + prev_res_val) > self.programming_range_res_val.MAX:
    #
    #             self.write("SOUR:DATA", self.programming_range_res_val.MAX)  # write maximum value
    #             self.log.warning(f'{increment_val} increment value is too high for current resistance'
    #                              f' {prev_res_val}, stopping at {self.programming_range_res_val.MAX}')
    #             prev_res_val = self.programming_range_res_val.MAX
    #
    #     if std_val_sel == "RADIOMETRIC":
    #         if (prev_res_val + ((increment_val * prev_res_val)/100)) > self.programming_range_res_val.MAX:
    #             self.log.warning(f'{increment_val} increment value is too high for current resistance'
    #                              f' {prev_res_val}, stopping at {self.programming_range_res_val.MAX}')
    #
    #      Dec/Inc works by emulating button presses on the machine using SYST:KEY. This only works from the HOME screen
    #     # Try to Dec/Inc, if the value has not changed, the command sent is actually just moving through menus
    #     # this is fixed by sending the back command and trying again. once resistance has changed, we leave loop.
    #
    #     complete_flag = False
    #     while not complete_flag:
    #         # if the previous resistance value is not on a boundary
    #         if prev_res_val == self.programming_range_res_val.MAX:
    #           raise Warning(f'At resistance boundary {self.programming_range_res_val.MAX}, cannot increment further')
    #         else:
    #             # try to Dec/Inc
    #             time.sleep(0.5)
    #             self.write('SYST:KEY', 11)  # Increment button if on main menu
    #             self.query('*OPC', int)
    #             time.sleep(1)
    #             new_res_val = float((self.query('SOUR:DATA', str)).replace(',', ''))
    #             self.query('*OPC', int)
    #
    #           if new_res_val == prev_res_val:  # If the Resistance value has not changed. press back button on machine
    #                 time.sleep(0.5)
    #                 self.write("SYST:KEY", 10)
    #                 self.query('*OPC', int)
    #             else:
    #                 complete_flag = True
    #
    #     # make sure there are no errors with this command
    #     self.log_inst_errors()
    #
    #     # Overflow warning, no longer necessary but good for debug
    #     if new_res_val < self.programming_range_res_val.MAX and new_res_val < prev_res_val:
    #         self.log.warning(f'Overflow error, Resistance now at {new_res_val}')
    #
    #     return f"Increment using {std_val_sel} method. From {prev_res_val} to {new_res_val}"
    #
    # def dec(self):
    #     """
    #     Decrements the resistance value based on the the standard value chosen
    #
    #     :return: New resistance value after decrement
    #     """
    #     # Recieve data as to how we will Dec/Inc
    #     self.rm_handle.query_delay = 0.5  # Delay for bug fix
    #     prev_res_val = float((self.query('SOUR:DATA', str)).replace(',', ''))
    #     std_val_sel = self.query('CONF:STDV', str)
    #
    #     if std_val_sel == 'STANDARD':
    #         increment_val = self.query(f'CONF:STDV:STD', float)  # std_val_sel in this case is STAN, not STD
    #     else:
    #         increment_val = self.query(f'CONF:STDV:{std_val_sel}', float)
    #     self.rm_handle.query_delay = 0.0  # Delay for bug fix
    #
    #     # Check that the incrementor stays in bounds
    #     if std_val_sel == 'DECADE' or std_val_sel == 'SET':
    #         if (prev_res_val - increment_val) < self.programming_range_res_val.MIN:
    #             self.write("SOUR:DATA", self.programming_range_res_val.MIN)  # write minimum value
    #             self.log.warning(f'{increment_val} increment value is too low for current resistance'
    #                              f' {prev_res_val}, stopping at {self.programming_range_res_val.MIN}')
    #             prev_res_val = self.programming_range_res_val.MIN
    #
    #     if std_val_sel == "RADIOMETRIC":
    #         if (prev_res_val - ((increment_val * prev_res_val)/100)) < self.programming_range_res_val.MIN:
    #             self.log.warning(f'{increment_val} increment value is too low for current resistance'
    #                              f' {prev_res_val}, stopping at {self.programming_range_res_val.MIN}')
    #
    #     # TODO: Implement a Better way of returning to the menu
    #      Dec/Inc works by emulating button presses on the machine using SYST:KEY. This only works from the HOME screen
    #     # Try to Dec/Inc, if the value has not changed, the command sent is actually just moving through menus
    #     # this is fixed by sending the back command and trying again.
    #
    #     complete_flag = False
    #     while not complete_flag:
    #         # if the previous resistance value is not on a boundary
    #         if prev_res_val == self.programming_range_res_val.MIN:
    #            raise Warning(f'At resistance boundary {self.programming_range_res_val.MIN}, cannot decrement further')
    #         else:
    #             # try to Dec/Inc
    #             time.sleep(0.5)
    #             self.write('SYST:KEY', 12)  # Decrement button if on main menu
    #             self.query('*OPC', int)
    #             time.sleep(1)
    #             new_res_val = float((self.query('SOUR:DATA', str)).replace(',', ''))
    #             self.query('*OPC', int)
    #
    #           if new_res_val == prev_res_val:  # If the Resistance value has not changed. press back button on machine
    #                 time.sleep(0.5)
    #                 self.write("SYST:KEY", 10)
    #                 self.query('*OPC', int)
    #             else:
    #                 complete_flag = True
    #
    #     # make sure there are no errors with this command
    #     self.log_inst_errors()
    #
    #     # Overflow warning, no longer necessary but good for debug
    #     if new_res_val > self.programming_range_res_val.MIN and new_res_val > prev_res_val:
    #         self.log.warning(f'Underflow error, Resistance now at {new_res_val}')
    #
    #     return f"Decrement using {std_val_sel} method. From {prev_res_val} to {new_res_val}"


if __name__ == '__main__':
    prs330 = PRS330('GPIB0::4')  # Replace visa_resource_name with None for simulated hardware.
    prs330.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')
    # prs330.initialize()

# -----------------------------------------------------------
#                       END OF FILE
# -----------------------------------------------------------
