# -----------------------------------------------------------
#                          INCLUDES
# -----------------------------------------------------------
# Include python libraries
from enum import Enum
from re import match
# Include Instrument Drivers/Helpers
from cl_instr_lib.base_classes.instrument_visa import InstrumentVisa
from cl_instr_lib.helpers.check_enum_str import check_enum_str
from cl_instr_lib.helpers.check_range import check_range, min_max_units
from cl_instr_lib.base_classes.power_analyzers.N6705C_components.measure_and_fetch import Measure, Fetch
from cl_instr_lib.base_classes.power_analyzers.N6705C_components.sense import Sense
from cl_instr_lib.base_classes.power_analyzers.N6705C_components.source import Source
from cl_instr_lib.base_classes.power_analyzers.N6705C_components.system import System
from cl_instr_lib.base_classes.power_analyzers.N6705C_components.trigger import Trigger
import cl_instr_lib.helpers.file_io as file_io

# -----------------------------------------------------------
#                            NOTES
# -----------------------------------------------------------
# LAN IP 141.131.222.87

# -----------------------------------------------------------
#                            CLASS
# -----------------------------------------------------------


class N6705C(InstrumentVisa):
    """
    Class for controlling Keysight N6705C Modular DC Power Analyzer.

    """

    def __init__(self, visa_resource_name=None, logger=None, **kwargs):
        super().__init__(visa_resource_name, logger,
                         model_re='^N6705C$',  # match the model string from the IDN
                         sim_idn='Keysight Technologies,N6705C,MY56005926,E.02.05.3215',  # a simulated IDN string
                         **kwargs)

        # dynamically create the available channels on startup.
        self._channel_dict = {}
        self._all_channels = {}
        self._models_tuple = ()
        self._enum_acq_source = None
        self._enum_elog_source = None
        self._enum_dlog_source = None
        self._enum_hist_source = None
        self._enum_tran_source = None
        self.update_channels()

        #: Object containing the `Measure`_  methods. Inherits from the `Measure Fetch ABC`_.
        self.measure = Measure(self)  # Include the measure class

        #: Object containing the `Fetch`_ methods. Inherits from the `Measure Fetch ABC`_.
        self.fetch = Fetch(self)  # Include the fetch class

        #: Object containing the `Trigger`_  methods.
        self.trigger = Trigger(self)  # Include the trigger class

        #: Object containing the `System`_  methods.
        self.system = System(self)  # Include the system class

        #: Object containing the `Sense`_  methods.
        self.sense = Sense(self)  # Include the sense class

        #: Object containing the `Source`_  methods.
        self.source = Source(self)  # Include the Source class

    # class attributes
    # ----------------------
    enum_display_mode = Enum("enum_display_mode", {'SINGLE': "METER1", 'MULTI': "METER4"})
    _formatting = "ASCII"

    def update_channels(self):
        """
        Queries for data on the installed modules and their channels. Dynamically creates attributes
        of channels that are within the N7605C object. Existing attributes are updated.
        """
        #  SYSTem:CHANnel[:COUNt]? Returns the number of output channels in a mainframe
        #  SYSTem:CHANnel:MODel? (@chanlist) Returns the model number of the selected channel
        #  SYSTem:CHANnel:OPTion? (@chanlist) Returns the option installed in the selected channel
        #  SYSTem:CHANnel:SERial? (@chanlist) Returns the serial number of the selected channel

        # clear all previous saved data relating to the channels.
        for key in self._channel_dict.keys():
            delattr(self, key)
        self._channel_dict = {}
        self._all_channels = {}
        self._enum_acq_source = None
        self._enum_elog_source = None
        self._enum_dlog_source = None
        self._enum_hist_source = None
        self._enum_tran_source = None
        self._models_tuple = ()

        # try to find attached modules, and information on the modules
        channel_count = self.query("SYST:CHAN", int)

        # channel : values
        module_models = {}
        module_list = []

        if channel_count > 0:
            normal_timeout = self.rm_handle.timeout
            self.rm_handle.timeout = 250
            for channel in range(1, 5):

                # get the modules and the channels they are on.
                channel_model = None
                try:
                    channel_model = self.query("SYST:CHAN:MOD", pre_target_params=f"(@{channel})")
                except:
                    pass
                self.get_inst_errors()
                if channel_model is not None:
                    module_models.update({channel: channel_model})
                    module_list.append(channel_model)

            self.rm_handle.timeout = normal_timeout
            self._models_tuple = tuple(module_list)

            # Of the valid channels, get the options and serials of each.
            for channel in module_models.keys():
                option = self.query("SYST:CHAN:OPT", pre_target_params=f"(@{channel})")
                serial = self.query("SYST:CHAN:SER", pre_target_params=f"(@{channel})")
                attribute_name = f"ch{channel}"
                channel_obj = self.Channel(channel, module_models.get(channel), option, serial)
                self.__setattr__(attribute_name, channel_obj)
                self._channel_dict.update({attribute_name: channel_obj})

            # create dynamic enumerations for the trigger sources
            _acq_source = {'BUS': 'BUS', 'EXTERNAL': 'EXT'}
            _elog_source = {'BUS': 'BUS', 'EXTERNAL': 'EXT', 'IMMEDIATE': "IMM"}
            _dlog_source = {'BUS': 'BUS', 'EXTERNAL': 'EXT', 'IMMEDIATE': "IMM", 'ARB_RUN_STOP_KEY': "ARSK",
                            'OUT_ON_OFF_KEY': "OOOK"}
            _hist_source = {'BUS': 'BUS', 'EXTERNAL': 'EXT', 'IMMEDIATE': "IMM"}
            _tran_source = {'BUS': 'BUS', 'EXTERNAL': 'EXT', 'IMMEDIATE': "IMM"}

            for channel_obj in self._channel_dict.values():
                curr_chx = {f"CURRENT_CH{channel_obj.value}": f"CURR{channel_obj.value}"}
                volt_chx = {f"VOLTAGE_CH{channel_obj.value}": f"VOLT{channel_obj.value}"}
                tran_chx = {f"TRANSIENT_CH{channel_obj.value}": f"TRAN{channel_obj.value}"}

                # add curr, volt, and tran to available items
                _acq_source.update(curr_chx)
                _acq_source.update(volt_chx)
                _acq_source.update(tran_chx)

                # add curr and volt to available items
                _dlog_source.update(curr_chx)
                _dlog_source.update(volt_chx)

                # add tran to available items
                _tran_source.update(tran_chx)

                # TODO add digital pin(n) when supported
                # _elog_source.update()
                # _hist_source.update()
                # _tran_source.update()

            # assemble the enums
            self._enum_acq_source = Enum("enum_acq_source", _acq_source)
            self._enum_elog_source = Enum("elog_source", _elog_source)
            self._enum_dlog_source = Enum("dlog_source", _dlog_source)
            self._enum_hist_source = Enum("hist_source", _hist_source)
            self._enum_tran_source = Enum("tran_source", _tran_source)

        self._all_channels = [channel_obj for channel_obj in self._channel_dict.values()]
        self.log_inst_errors()

    def screenshot(self, pc_dir, file_name, create_dir=False):
        """
        Queries the instrument for a block of data containing a screen image in PNG format. This image will be
        saved to the directory and filename specified by the pc_dir and file_name parameters.

        :param pc_dir: Directory being accessed or created for the write command.
        :type pc_dir: str
        :param file_name: File name for the write command. exclude file extension. 'sample.txt' should be 'sample'.
        :type file_name: str
        :param create_dir: on_off value ('ON'/'OFF' preferred) that determines if a directory will be made in the event
            pc_dir does not currently exist. Defaults to False.
        :type create_dir: bool | int | str
        :return: Creates a PNG file in the specified directory.
        """
        # HCOPy:SDUMp:DATA? Returns an image of the display in .gif format
        self.write("HCOP:SDUM:DATA?")
        raw_data = self.rm_handle.read_raw()
        self.log_inst_errors()
        # remove newline and IEEE header from read
        data_length, data = file_io.decode_ieee_header(raw_data[:len(raw_data)-1])
        file_io.write(pc_dir, file_name, 'png', data, binary_data=True, create_dir=create_dir)

    def display_mode(self, mode=None):
        """
        This command selects the output channel view of the front panel display.

        :param mode: display mode, either SINGLE channel or MULTI channel.
        :type mode: str | enum_display mode
        :return: If called empty, returns the method's parameters reflecting the state of the instrument.
        :rtype: str | None
        """
        # DISPlay[:WINDow]:VIEW METER1 | METER4 Selects 1-channel or 4-channel meter view

        if mode is None:
            return self.query("DISP:VIEW", self.enum_display_mode).name

        mode_obj = check_enum_str("mode", mode, self.enum_display_mode)
        self.write("DISP:VIEW", mode_obj.value)
        self.log_inst_errors()

    def dlog_create_header_helper(self, current_en=False, curr_min_max_en=False, voltage_en=False,
                                  volt_min_max_en=False):
        """
        Helper that creates a header that is formatted the same as the data being observed in a data logger read/fetch.

        Note: This does not change data logger settings! go to sense sub-system to enable/disable measure_enable and
        min_max_enable for setup of current and voltage.

        :param current_en: on_off value (True/False preferred) that represents receiving current data from the
            data logger.
        :type current_en: str | int | bool
        :param curr_min_max_en: on_off value (True/False preferred) that represents receiving current minimum and
            maximum data from the data logger.
        :type curr_min_max_en: str | int | bool
        :param voltage_en: on_off value (True/False preferred) that represents receiving voltage data from the
            data logger.
        :type voltage_en: str | int | bool
        :param volt_min_max_en: on_off value (True/False preferred) that represents receiving voltage minimum and
            maximum data from the data logger.
        :type volt_min_max_en: str | int | bool
        :return: Header list with the order of data received from the data logger. Can be used for a csv file.
        :rtype: list
        """

        header = []
        if current_en in self.on_off.on_vals.from_api:
            header.append("Current")
        if curr_min_max_en in self.on_off.on_vals.from_api:
            header.extend(["Current_min", 'Current_max'])
        if voltage_en in self.on_off.on_vals.from_api:
            header.append("Voltage")
        if volt_min_max_en in self.on_off.on_vals.from_api:
            header.extend(["Voltage_min", 'Voltage_max'])

        return header

    # noinspection PyMethodMayBeStatic
    def dlog_parse_data_helper(self, raw_data, header):
        """
        Helper used in parsing a list of data from the external data logger.

        :param raw_data: data returned from the instrument.
        :type raw_data: list | bytes
        :param header: header list created using dlog_create_header_helper.
        :type header: list
        :return: list of values for each parameter of the header, stored in a dictionary of lists.
        :rtype: dict
        """
        # cleanup data
        # formatting: (current, curr_min, curr_max, voltage, volt_min, volt_max)
        header_length = len(header)
        start_index = 0

        # the below if statements simulate these comments while being dynamic on selection of wanted parameters.
        # current_data = all_data[0::2]
        # voltage_data = all_data[1::2]
        return_dict = {}

        if 'Current' in header:
            current_data = raw_data[start_index::header_length]
            return_dict.update(current_data=current_data)
            start_index += 1
        if 'Current_min' in header and "Current_max" in header:
            current_min_data = raw_data[start_index::header_length]
            current_max_data = raw_data[(start_index + 1)::header_length]
            return_dict.update(current_min_data=current_min_data)
            return_dict.update(current_max_data=current_max_data)
            start_index += 2
        if 'Voltage' in header:
            voltage_data = raw_data[start_index::header_length]
            return_dict.update(voltage_data=voltage_data)
            start_index += 1
        if 'Voltage_min' in header and "Voltage_max" in header:
            voltage_min_data = raw_data[start_index::header_length]
            voltage_max_data = raw_data[(start_index + 1)::header_length]
            return_dict.update(voltage_min_data=voltage_min_data)
            return_dict.update(voltage_max_data=voltage_max_data)
            start_index += 2

        return return_dict

    # noinspection PyMethodMayBeStatic
    def dlog_create_timestamp_data_helper(self, parsed_data_dict, sample_period):
        """
        helper used in creating timestamp data based on the parsed data dictionary gathered from
        dlog_parse_data_helper.

        :param parsed_data_dict: dictionary of values from the parse data helper.
        :type parsed_data_dict: dict
        :param sample_period: Sample period given in the external_dlog.setup_period() or datalog.setup_acquisition
            method.
        :type sample_period: int | float
        :return: created list of timestamps applicable to all parsed_data_dict datasets.
        :rtype: list
        """
        check_range('sample_period', sample_period, min_max_units(0, 60, 'seconds'))
        current_data = parsed_data_dict.get('current_data')
        current_min_data = parsed_data_dict.get('current_min_data')
        current_max_data = parsed_data_dict.get('current_max_data')
        voltage_data = parsed_data_dict.get('voltage_data')
        voltage_min_data = parsed_data_dict.get('voltage_min_data')
        voltage_max_data = parsed_data_dict.get('voltage_max_data')

        sample_times = []
        for data_list in (current_data, current_min_data, current_max_data, voltage_data, voltage_max_data,
                          voltage_min_data):
            if data_list is not None:
                # get time elapsed
                temp_period = 0
                for element in data_list:
                    sample_times.append(temp_period)
                    temp_period += sample_period
                break

        return sample_times

    def _check_channel(self, user_input, name='channel'):
        """Helper to check the user's channel input."""

        available_channels = []
        for channel_obj in self._channel_dict.values():
            available_channels.append(channel_obj.value)
        available_channels_str = ', '.join(str(ch) for ch in available_channels)

        error_template = "Bad Channel(s) {value}. Available channels are: " + available_channels_str + ". " \
                         "Acceptable inputs are a Channel int between {min} and {max} " \
                         "or a channel object."

        if user_input is None:
            return None

        # chain of possible channel inputs
        if isinstance(user_input, N6705C.Channel):  # user passed in a single channel obj
            return user_input.to_inst, user_input

        if isinstance(user_input, str):  # if the user inserts the channel name, get the int of it
            if match(r"CH\d", user_input.upper()) is not None:
                user_input = self._channel_dict.get(user_input).value

        if isinstance(user_input, int):  # user may select a single channel

            check_range(name, user_input, min_max_units(1, 4, "Channel"), error_template=error_template)
            if user_input not in available_channels:
                raise ValueError(f"Bad channel {user_input}, Should be one of the available channels:"
                                 f"{available_channels}")

            # all checks have been passed, return the string of channels and objects
            channel_obj = self._get_channel_object(user_input)
            return channel_obj.to_inst, channel_obj

        if isinstance(user_input, (list, tuple)):  # user may send a list when not allowed
            raise ValueError(f"Bad use of multiple Channels {user_input}. This method only accepts single channels.\n"
                             f"Available channels are: {available_channels} Acceptable inputs are a Channel "
                             f"int between 1 and 4 or a channel object.")

        # the user's input does not conform at all. raise an error.
        raise ValueError(f"Bad Channel(s) {user_input}. Available channels are: {available_channels} "
                         f"Acceptable inputs are  a Channel int between 1 and 4 or a channel object.")

    def _check_multi_channels(self, user_input, name='channels'):
        """Helper to check the user's channel input."""

        available_channels = []
        for channel_obj in self._channel_dict.values():
            available_channels.append(channel_obj.value)
        available_channels_str = ', '.join(str(ch) for ch in available_channels)

        error_template = "Bad Channel(s) {value}. Available channels are: " + available_channels_str + ". " \
                         "Acceptable inputs are a Channel int between {min} and {max} " \
                         "or a channel object."

        if user_input is None:
            return None

        # chain of possible channel inputs
        if isinstance(user_input, (N6705C.Channel, int, str)):  # user passed in a single channel obj, int, or str
            channel_str, channel_obj = self._check_channel(user_input)
            return channel_str, [channel_obj]

        if isinstance(user_input, (list, tuple)):  # user may want a list of channels, accepting channel objects and int

            chan_list = []
            chan_int = None

            # allow for a list of channels or int value
            for element in user_input:
                if isinstance(element, N6705C.Channel):
                    chan_int = element.value

                elif isinstance(element, str):
                    if match(r"CH\d", element.upper()) is not None:
                        chan_int = int(element.upper().lstrip('CH'))

                elif isinstance(element, int):
                    chan_int = element
                else:
                    raise ValueError(f"Bad list of {name}, {user_input}. A {type(element).__name__} of {element} was"
                                     f" used to describe a channel. Should be of type int or channel object.")

                # check that the channel is a valid channel number and that something is installed on the channel
                check_range(name, chan_int, min_max_units(1, 4, "Channel"), error_template=error_template)
                if chan_int not in available_channels:
                    raise ValueError(f"Bad channel {chan_int} of selected channels {user_input}, "
                                     f"Should be one of the available channels: {available_channels}")

                chan_list.append(chan_int)

            # all values the user sent can be sorted now that they are integers
            chan_list.sort()

            if len(chan_list) > len(available_channels):
                # user had selected more channels than are available on instrument
                raise ValueError(f"Bad list of {name}, {user_input}. A maximum of {len(available_channels)}"
                                 f"channels may be selected.")

            # All list values are valid. Check for duplicate channels
            for element in [chan_list.count(1), chan_list.count(2), chan_list.count(3), chan_list.count(4)]:
                if element > 1:
                    raise ValueError(f"Bad list of Channels, {user_input}. Duplicates of channels are not allowed.")

            # all checks have been passed, return the string of channels and objects
            channels = [str(element) for element in chan_list]
            channel_str = "(@" + ",".join(channels) + ")"
            channel_objs = []
            for element in chan_list:
                channel_objs.append(self._get_channel_object(element))

            return channel_str, channel_objs

        # the user's input does not conform at all. raise an error.
        raise ValueError(f"Bad Channel(s) {user_input}. Available channels are: {available_channels} "
                         f"Acceptable inputs are a Channel int between 1 and 4, a channel object, "
                         f"or a list of up to {len(available_channels)} valid Channels. Example: [1,2,3]")

    def _get_channel_object(self, channel):
        """Helper to return the channel object for checking models"""
        if channel in ['ch1', 'ch2', 'ch3', 'ch4']:
            return self._channel_dict.get(channel)
        else:
            return self._channel_dict.get(f"ch{channel}")

    def _raise_error_check_all_channels(self, required_models, required_options=None):
        """Helper that raises an error listing the required models and the channels (if any) that can be used."""

        acceptable_channels = []
        all_channels = [channel_obj for channel_obj in self._channel_dict.values()]

        for module in all_channels:
            if self._check_module(module.model, required_models) is not None:
                acceptable_channels.append(module.name)
            elif required_options is not None and self._check_module(module.options, required_options) is not None:
                acceptable_channels.append(module.name)

        if len(acceptable_channels) > 0:
            raise ValueError("Invalid channel specified. Must be a channel that has one of the following modules "
                             f"{required_models}.\n"
                             f"The following channels work with this command: {acceptable_channels}")
        else:
            raise ValueError("Invalid channel specified. Must be a channel that has one of the following modules "
                             f"{required_models}.\n"
                             f"No channels have these modules installed.")

    @staticmethod
    def _check_module(models, accepted_modules):
        """Helper to return model numbers if an accepted module is installed for a given method"""
        model_list = []

        if isinstance(accepted_modules, str):
            temp_list = list()
            temp_list.append(accepted_modules)
            accepted_modules = temp_list
        if isinstance(models, str):
            temp_list = list()
            temp_list.append(models)
            models = temp_list

        for model in models:
            for accepted_module in accepted_modules:
                if match(accepted_module, model):
                    model_list.append(model)

        if not model_list:
            return None
        return model_list

    @staticmethod
    def _return_split(data, expected_type=str):
        """Helper to return multiple readings from instruments"""
        # ret_value is a str. return a float if one value is returned, otherwise return a list of floats.
        data = data.split(',')

        if expected_type in [float, 'float']:
            ret_data = [float(value) for value in data] if len(data) > 1 else float(data[0])

        elif expected_type in [str, 'str']:
            ret_data = data if len(data) > 1 else data[0]

        else:
            ret_data = data

        return ret_data

    class Channel:
        """Channel Class that is used for dynamic creation of instrument channels on driver startup."""
        _all_model_bounds = \
            {
                # DC N673X 50W power modules
                "N6734B": {"VOLT": min_max_units(0, 35, "Volts"),
                           "CURR": min_max_units(0, 1.5, "Amps"),
                           "POW": min_max_units(0, 50, "Watts"),
                           "TYPE": "DC N673X 50W power module"},

                "N6735B": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 0.8, "Amps"),
                           "POW": min_max_units(0, 50, "Watts"),
                           "TYPE": "DC N673X 50W power module"},

                "N6736B": {"VOLT": min_max_units(0, 100, "Volts"),
                           "CURR": min_max_units(0, 0.5, "Amps"),
                           "POW": min_max_units(0, 50, "Watts"),
                           "TYPE": "DC N673X 50W power module"},

                # DC N674X 100W power modules
                "N6741B": {"VOLT": min_max_units(0, 5, "Volts"),
                           "CURR": min_max_units(0, 20, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N674X 100W power module"},

                "N6742B": {"VOLT": min_max_units(0, 8, "Volts"),
                           "CURR": min_max_units(0, 12.5, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N674X 100W power module"},

                "N6743B": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(0, 5, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N674X 100W power module"},

                "N6744B": {"VOLT": min_max_units(0, 35, "Volts"),
                           "CURR": min_max_units(0, 3, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N674X 100W power module"},

                "N6745B": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 1.6, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N674X 100W power module"},

                "N6746B": {"VOLT": min_max_units(0, 100, "Volts"),
                           "CURR": min_max_units(0, 1, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N674X 100W power module"},

                # DC N675X high performance auto ranging power modules
                "N6751A": {"VOLT": min_max_units(0, 50, "Volts"),
                           "CURR": min_max_units(0, 5, "Amps"),
                           "POW": min_max_units(0, 50, "Watts"),
                           "TYPE": "DC N675X high performance auto ranging power module"},

                "N6752A": {"VOLT": min_max_units(0, 50, "Volts"),
                           "CURR": min_max_units(0, 10, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N675X high performance auto ranging power module"},

                "N6753A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(0, 50, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N675X high performance auto ranging power module"},

                "N6754A": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 20, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N675X high performance auto ranging power module"},

                "N6755A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(0, 50, "Amps"),
                           "POW": min_max_units(0, 500, "Watts"),
                           "TYPE": "DC N675X high performance auto ranging power module"},

                "N6756A": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 17, "Amps"),
                           "POW": min_max_units(0, 500, "Watts"),
                           "TYPE": "DC N675X high performance auto ranging power module"},

                # DC N676X precision power modules
                "N6761A": {"VOLT": min_max_units(0, 50, "Volts"),
                           "CURR": min_max_units(0, 1.5, "Amps"),
                           "POW": min_max_units(0, 50, "Watts"),
                           "TYPE": "DC N676X precision power module"},

                "N6762A": {"VOLT": min_max_units(0, 50, "Volts"),
                           "CURR": min_max_units(0, 3, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "TYPE": "DC N676X precision power module"},

                "N6763A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(0, 50, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N676X precision power module"},

                "N6764A": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 20, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N676X precision power module"},

                "N6765A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(0, 50, "Amps"),
                           "POW": min_max_units(0, 500, "Watts"),
                           "TYPE": "DC N676X precision power module"},

                "N6766A": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 17, "Amps"),
                           "POW": min_max_units(0, 500, "Watts"),
                           "TYPE": "DC N676X precision power module"},

                # DC N677X 300W power modules
                "N6773A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(0, 15, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N677X 300W power module"},

                "N6774A": {"VOLT": min_max_units(0, 35, "Volts"),
                           "CURR": min_max_units(0, 8.5, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N677X 300W power module"},

                "N6775A": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 5, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N677X 300W power module"},

                "N6776A": {"VOLT": min_max_units(0, 100, "Volts"),
                           "CURR": min_max_units(0, 3, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N677X 300W power module"},

                "N6777A": {"VOLT": min_max_units(0, 150, "Volts"),
                           "CURR": min_max_units(0, 2, "Amps"),
                           "POW": min_max_units(0, 300, "Watts"),
                           "TYPE": "DC N677X 300W power module"},

                # DC N678X Source-Measure units
                "N6781A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(-3, 3, "Amps"),
                           "POW": min_max_units(0, 20, "Watts"),
                           "TYPE": "DC N678X Source-Measure unit"},

                "N6782A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(-3, 3, "Amps"),
                           "POW": min_max_units(0, 20, "Watts"),
                           "TYPE": "DC N678X Source-Measure unit"},

                "N6783A-BAT": {"VOLT": min_max_units(0, 8, "Volts"),
                               "CURR": min_max_units(0, 3, "Amps"),
                               "POW": min_max_units(0, 24, "Watts"),
                               "TYPE": "DC N678X Source-Measure unit w/ Battery Charge/Discharge module"},

                "N6784A": {"VOLT": min_max_units(-20, 20, "Volts"),
                           "CURR": min_max_units(-3, 3, "Amps"),
                           "POW": min_max_units(0, 20, "Watts"),
                           "TYPE": "DC N678X Source-Measure unit"},


                "N6785A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(-8, 8, "Amps"),
                           "POW": min_max_units(0, 80, "Watts"),
                           "TYPE": "DC N678X Source-Measure unit"},


                "N6786A": {"VOLT": min_max_units(0, 20, "Volts"),
                           "CURR": min_max_units(-8, 8, "Amps"),
                           "POW": min_max_units(0, 80, "Watts"),
                           "TYPE": "DC N678X Source-Measure unit"},


                # DC N678X Electronic load modules
                "N6783A-MFG": {"VOLT": min_max_units(0, 6, "Volts"),
                               "CURR": min_max_units(0, 3, "Amps"),
                               "POW": min_max_units(0, 18, "Watts"),
                               "TYPE": "DC N678X Electronic load module"},

                "N6791A": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 20, "Amps"),
                           "POW": min_max_units(0, 100, "Watts"),
                           "RES": min_max_units(0.04, 8000, "Ohms"),
                           "TYPE": "DC N679X Electronic load module"},

                "N6792A": {"VOLT": min_max_units(0, 60, "Volts"),
                           "CURR": min_max_units(0, 40, "Amps"),
                           "POW": min_max_units(0, 200, "Watts"),
                           "RES": min_max_units(0.04, 8000, "Ohms"),
                           "TYPE": "DC N679X Electronic load module"},

            }

        _all_model_names = list(_all_model_bounds.keys())

        def __init__(self, channel_number, model_number, options, serial_number):

            self.channel = channel_number          #: Channel Number e.g. '1'
            self.value = channel_number            #: Channel Number e.g. '1'
            self.name = f'ch{channel_number}'      #: Channel Name   e.g. 'ch1'
            self.to_inst = f'(@{channel_number})'  #: Channel Instrument Command   e.g. '(@1)'
            self.model = model_number              #: Channel Module Model e.g. 'N6765A'
            self.serial = serial_number            #: Channel Serial Model e.g. 'MY59000580'
            self.options = options                 #: Channel attached Options e.g. '054'
            self._model_boundaries = self._all_model_bounds.get(model_number)

            self._info = {"name": self.name,
                          "channel": self.channel,
                          "to_inst": self.to_inst,
                          "model": self.model,
                          "serial": self.serial,
                          "options": self.options,
                          }

            if self._model_boundaries is not None:

                if self._model_boundaries.get("VOLT") is not None:
                    self.voltage_range = self._model_boundaries.get('VOLT')  #: Module Voltage Range e.g. '0-60V'
                    self._info.update({'voltage_range': self.voltage_range})

                if self._model_boundaries.get("CURR") is not None:
                    self.current_range = self._model_boundaries.get('CURR')  #: Module Current Range e.g. '0-40A'
                    self._info.update({"current_range": self.current_range})

                if self._model_boundaries.get("POW") is not None:
                    self.power_range = self._model_boundaries.get('POW')  #: Module Power Range e.g. '0-300W'
                    self._info.update({"power_range": self.power_range})

                if self._model_boundaries.get("RES") is not None:
                    #: Module Resistance Range (if applicable) e.g. '0-8000 Ohms'
                    self.resistance_range = self._model_boundaries.get("RES")
                    self._info.update({'resistance_range': self.resistance_range})

                if self._model_boundaries.get("TYPE") is not None:
                    #: Module Descriptor e.g. 'DC N679X Electronic load module'
                    self.model_description = self._model_boundaries.get('TYPE')
                    self._info.update({"type": self.model_description})

        def get_info(self):
            """
            :return: Returns a dictionary of the channels attributes.
            :rtype: dict
            """
            return self._info

# -----------------------------------------------------------
#                            MAIN
# -----------------------------------------------------------


if __name__ == '__main__':
    analyzer = N6705C('USB0::0x2A8D::0x0F02::MY56005926')
    analyzer.debug_options(log_scpi=True, inst_error_handling='LOG_ALWAYS')

# -----------------------------------------------------------
#                          END OF FILE
# -----------------------------------------------------------
